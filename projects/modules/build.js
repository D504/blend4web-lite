(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.nb4w = factory());
}(this, (function () { 'use strict';

	var _factories = {};
	var register = function(module_name, module_context, export_functions) {
	  console.log(module_name);
	  if (_factories[module_name] !== undefined) {
	    return _factories[module_name];
	  } else {
	    var _ns = {};
	    var factory = _factories[module_name] = function(ns, exports) {
	      if (_ns[ns] !== undefined) {
	        return _ns[ns];
	      }

	      _ns[ns] = {};
	      module_context(ns, _ns[ns]);

	      return _ns[ns];
	    };

	    b4w._n_module[module_name] = factory;

	    return factory;
	  }
	};

	"use strict";

	/**
	 * @module 4x4 Matrix
	 * @name mat4
	 */
	function Mat4(ns, exports) {

	var GLMAT_EPSILON = 0.0000001;
	var GLMAT_ARRAY_TYPE = (typeof Float32Array !== 'undefined') ? Float32Array : Array;
	var mat4 = exports;

	/**
	 * Creates a new identity mat4
	 *
	 * @returns {Mat4} a new 4x4 matrix
	 * @method module:mat4.create
	 */
	mat4.create = function() {
	    var out = new GLMAT_ARRAY_TYPE(16);
	    out[0] = 1;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = 0;
	    out[5] = 1;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = 0;
	    out[9] = 0;
	    out[10] = 1;
	    out[11] = 0;
	    out[12] = 0;
	    out[13] = 0;
	    out[14] = 0;
	    out[15] = 1;
	    return out;
	};

	/**
	 * Creates a new mat4 initialized with values from an existing matrix
	 *
	 * @param {Mat4} a matrix to clone
	 * @returns {Mat4} a new 4x4 matrix
	 * @method module:mat4.clone
	 */
	mat4.clone = function(a) {
	    var out = new GLMAT_ARRAY_TYPE(16);
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = a[2];
	    out[3] = a[3];
	    out[4] = a[4];
	    out[5] = a[5];
	    out[6] = a[6];
	    out[7] = a[7];
	    out[8] = a[8];
	    out[9] = a[9];
	    out[10] = a[10];
	    out[11] = a[11];
	    out[12] = a[12];
	    out[13] = a[13];
	    out[14] = a[14];
	    out[15] = a[15];
	    return out;
	};

	/**
	 * Copy the values from one mat4 to another
	 *
	 * @param {Mat4} a the source matrix
	 * @returns {Mat4} out
	 * @param {Mat4} out the receiving matrix
	 * @method module:mat4.copy
	 */
	mat4.copy = function(a, out) {
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = a[2];
	    out[3] = a[3];
	    out[4] = a[4];
	    out[5] = a[5];
	    out[6] = a[6];
	    out[7] = a[7];
	    out[8] = a[8];
	    out[9] = a[9];
	    out[10] = a[10];
	    out[11] = a[11];
	    out[12] = a[12];
	    out[13] = a[13];
	    out[14] = a[14];
	    out[15] = a[15];
	    return out;
	};

	/**
	 * Set a mat4 to the identity matrix
	 *
	 * @returns {Mat4} out
	 * @param {Mat4} out the receiving matrix
	 * @method module:mat4.identity
	 */
	mat4.identity = function(out) {
	    out[0] = 1;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = 0;
	    out[5] = 1;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = 0;
	    out[9] = 0;
	    out[10] = 1;
	    out[11] = 0;
	    out[12] = 0;
	    out[13] = 0;
	    out[14] = 0;
	    out[15] = 1;
	    return out;
	};

	/**
	 * Transpose the values of a mat4
	 *
	 * @param {Mat4} a the source matrix
	 * @returns {Mat4} out
	 * @param {Mat4} out the receiving matrix
	 * @method module:mat4.transpose
	 */
	mat4.transpose = function(a, out) {
	    // If we are transposing ourselves we can skip a few steps but have to cache some values
	    if (out === a) {
	        var a01 = a[1], a02 = a[2], a03 = a[3],
	            a12 = a[6], a13 = a[7],
	            a23 = a[11];

	        out[1] = a[4];
	        out[2] = a[8];
	        out[3] = a[12];
	        out[4] = a01;
	        out[6] = a[9];
	        out[7] = a[13];
	        out[8] = a02;
	        out[9] = a12;
	        out[11] = a[14];
	        out[12] = a03;
	        out[13] = a13;
	        out[14] = a23;
	    } else {
	        out[0] = a[0];
	        out[1] = a[4];
	        out[2] = a[8];
	        out[3] = a[12];
	        out[4] = a[1];
	        out[5] = a[5];
	        out[6] = a[9];
	        out[7] = a[13];
	        out[8] = a[2];
	        out[9] = a[6];
	        out[10] = a[10];
	        out[11] = a[14];
	        out[12] = a[3];
	        out[13] = a[7];
	        out[14] = a[11];
	        out[15] = a[15];
	    }
	    
	    return out;
	};

	/**
	 * Inverts a mat4
	 *
	 * @param {Mat4} a the source matrix
	 * @returns {Mat4} out
	 * @param {Mat4} out the receiving matrix
	 * @method module:mat4.invert
	 */
	mat4.invert = function(a, out) {
	    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
	        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
	        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
	        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

	        b00 = a00 * a11 - a01 * a10,
	        b01 = a00 * a12 - a02 * a10,
	        b02 = a00 * a13 - a03 * a10,
	        b03 = a01 * a12 - a02 * a11,
	        b04 = a01 * a13 - a03 * a11,
	        b05 = a02 * a13 - a03 * a12,
	        b06 = a20 * a31 - a21 * a30,
	        b07 = a20 * a32 - a22 * a30,
	        b08 = a20 * a33 - a23 * a30,
	        b09 = a21 * a32 - a22 * a31,
	        b10 = a21 * a33 - a23 * a31,
	        b11 = a22 * a33 - a23 * a32,

	        // Calculate the determinant
	        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

	    if (!det) { 
	        return null; 
	    }
	    det = 1.0 / det;

	    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
	    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
	    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
	    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
	    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
	    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
	    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
	    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
	    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
	    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
	    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
	    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
	    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
	    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
	    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
	    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

	    return out;
	};

	/**
	 * Calculates the adjugate of a mat4
	 *
	 * @param {Mat4} a the source matrix
	 * @returns {Mat4} out
	 * @param {Mat4} out the receiving matrix
	 * @method module:mat4.adjoint
	 */
	mat4.adjoint = function(a, out) {
	    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
	        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
	        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
	        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

	    out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
	    out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
	    out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
	    out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
	    out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
	    out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
	    out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
	    out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
	    out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
	    out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
	    out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
	    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
	    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
	    out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
	    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
	    out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
	    return out;
	};

	/**
	 * Calculates the determinant of a mat4
	 *
	 * @param {Mat4} a the source matrix
	 * @returns {Number} determinant of a
	 * @method module:mat4.determinant
	 */
	mat4.determinant = function (a) {
	    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
	        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
	        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
	        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

	        b00 = a00 * a11 - a01 * a10,
	        b01 = a00 * a12 - a02 * a10,
	        b02 = a00 * a13 - a03 * a10,
	        b03 = a01 * a12 - a02 * a11,
	        b04 = a01 * a13 - a03 * a11,
	        b05 = a02 * a13 - a03 * a12,
	        b06 = a20 * a31 - a21 * a30,
	        b07 = a20 * a32 - a22 * a30,
	        b08 = a20 * a33 - a23 * a30,
	        b09 = a21 * a32 - a22 * a31,
	        b10 = a21 * a33 - a23 * a31,
	        b11 = a22 * a33 - a23 * a32;

	    // Calculate the determinant
	    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
	};

	/**
	 * Multiplies two mat4's
	 *
	 * @param {Mat4} a the first operand
	 * @param {Mat4} b the second operand
	 * @returns {Mat4} out
	 * @param {Mat4} out the receiving matrix
	 * @method module:mat4.multiply
	 */
	mat4.multiply = function (a, b, out) {
	    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
	        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
	        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
	        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

	    // Cache only the current line of the second matrix
	    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];  
	    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
	    out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
	    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
	    out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

	    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
	    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
	    out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
	    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
	    out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

	    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
	    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
	    out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
	    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
	    out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

	    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
	    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
	    out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
	    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
	    out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
	    return out;
	};

	/**
	 * Alias for {@link mat4.multiply}
	 * @function
	 * @method module:mat4.mul
	 */
	mat4.mul = mat4.multiply;

	/**
	 * Translate a mat4 by the given vector
	 *
	 * @param {Mat4} a the matrix to translate
	 * @param {Vec3} v vector to translate by
	 * @returns {Mat4} out
	 * @param {Mat4} out the receiving matrix
	 * @method module:mat4.translate
	 */
	mat4.translate = function (a, v, out) {
	    var x = v[0], y = v[1], z = v[2],
	        a00, a01, a02, a03,
	        a10, a11, a12, a13,
	        a20, a21, a22, a23;

	    if (a === out) {
	        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
	        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
	        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
	        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
	    } else {
	        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
	        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
	        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

	        out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
	        out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
	        out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

	        out[12] = a00 * x + a10 * y + a20 * z + a[12];
	        out[13] = a01 * x + a11 * y + a21 * z + a[13];
	        out[14] = a02 * x + a12 * y + a22 * z + a[14];
	        out[15] = a03 * x + a13 * y + a23 * z + a[15];
	    }

	    return out;
	};

	/**
	 * Scales the mat4 by the dimensions in the given vec3
	 *
	 * @param {Mat4} a the matrix to scale
	 * @param {Vec3} v the vec3 to scale the matrix by
	 * @returns {Mat4} out
	 * @param {Mat4} out the receiving matrix
	 * @method module:mat4.scale
	 */
	mat4.scale = function(a, v, out) {
	    var x = v[0], y = v[1], z = v[2];

	    out[0] = a[0] * x;
	    out[1] = a[1] * x;
	    out[2] = a[2] * x;
	    out[3] = a[3] * x;
	    out[4] = a[4] * y;
	    out[5] = a[5] * y;
	    out[6] = a[6] * y;
	    out[7] = a[7] * y;
	    out[8] = a[8] * z;
	    out[9] = a[9] * z;
	    out[10] = a[10] * z;
	    out[11] = a[11] * z;
	    out[12] = a[12];
	    out[13] = a[13];
	    out[14] = a[14];
	    out[15] = a[15];
	    return out;
	};

	/**
	 * Rotates a mat4 by the given angle around the given axis
	 *
	 * @param {Mat4} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @param {Vec3} axis the axis to rotate around
	 * @returns {Mat4} out
	 * @param {Mat4} out the receiving matrix
	 * @method module:mat4.rotate
	 */
	mat4.rotate = function (a, rad, axis, out) {
	    var x = axis[0], y = axis[1], z = axis[2],
	        len = Math.sqrt(x * x + y * y + z * z),
	        s, c, t,
	        a00, a01, a02, a03,
	        a10, a11, a12, a13,
	        a20, a21, a22, a23,
	        b00, b01, b02,
	        b10, b11, b12,
	        b20, b21, b22;

	    if (Math.abs(len) < GLMAT_EPSILON) { return null; }
	    
	    len = 1 / len;
	    x *= len;
	    y *= len;
	    z *= len;

	    s = Math.sin(rad);
	    c = Math.cos(rad);
	    t = 1 - c;

	    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
	    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
	    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

	    // Construct the elements of the rotation matrix
	    b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
	    b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
	    b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

	    // Perform rotation-specific matrix multiplication
	    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
	    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
	    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
	    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
	    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
	    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
	    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
	    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
	    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
	    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
	    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
	    out[11] = a03 * b20 + a13 * b21 + a23 * b22;

	    if (a !== out) { // If the source and destination differ, copy the unchanged last row
	        out[12] = a[12];
	        out[13] = a[13];
	        out[14] = a[14];
	        out[15] = a[15];
	    }
	    return out;
	};

	/**
	 * Rotates a matrix by the given angle around the X axis
	 *
	 * @param {Mat4} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {Mat4} out
	 * @param {Mat4} out the receiving matrix
	 * @method module:mat4.rotateX
	 */
	mat4.rotateX = function (a, rad, out) {
	    var s = Math.sin(rad),
	        c = Math.cos(rad),
	        a10 = a[4],
	        a11 = a[5],
	        a12 = a[6],
	        a13 = a[7],
	        a20 = a[8],
	        a21 = a[9],
	        a22 = a[10],
	        a23 = a[11];

	    if (a !== out) { // If the source and destination differ, copy the unchanged rows
	        out[0]  = a[0];
	        out[1]  = a[1];
	        out[2]  = a[2];
	        out[3]  = a[3];
	        out[12] = a[12];
	        out[13] = a[13];
	        out[14] = a[14];
	        out[15] = a[15];
	    }

	    // Perform axis-specific matrix multiplication
	    out[4] = a10 * c + a20 * s;
	    out[5] = a11 * c + a21 * s;
	    out[6] = a12 * c + a22 * s;
	    out[7] = a13 * c + a23 * s;
	    out[8] = a20 * c - a10 * s;
	    out[9] = a21 * c - a11 * s;
	    out[10] = a22 * c - a12 * s;
	    out[11] = a23 * c - a13 * s;
	    return out;
	};

	/**
	 * Rotates a matrix by the given angle around the Y axis
	 *
	 * @param {Mat4} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {Mat4} out
	 * @param {Mat4} out the receiving matrix
	 * @method module:mat4.rotateY
	 */
	mat4.rotateY = function (a, rad, out) {
	    var s = Math.sin(rad),
	        c = Math.cos(rad),
	        a00 = a[0],
	        a01 = a[1],
	        a02 = a[2],
	        a03 = a[3],
	        a20 = a[8],
	        a21 = a[9],
	        a22 = a[10],
	        a23 = a[11];

	    if (a !== out) { // If the source and destination differ, copy the unchanged rows
	        out[4]  = a[4];
	        out[5]  = a[5];
	        out[6]  = a[6];
	        out[7]  = a[7];
	        out[12] = a[12];
	        out[13] = a[13];
	        out[14] = a[14];
	        out[15] = a[15];
	    }

	    // Perform axis-specific matrix multiplication
	    out[0] = a00 * c - a20 * s;
	    out[1] = a01 * c - a21 * s;
	    out[2] = a02 * c - a22 * s;
	    out[3] = a03 * c - a23 * s;
	    out[8] = a00 * s + a20 * c;
	    out[9] = a01 * s + a21 * c;
	    out[10] = a02 * s + a22 * c;
	    out[11] = a03 * s + a23 * c;
	    return out;
	};

	/**
	 * Rotates a matrix by the given angle around the Z axis
	 *
	 * @param {Mat4} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {Mat4} out
	 * @param {Mat4} out the receiving matrix
	 * @method module:mat4.rotateZ
	 */
	mat4.rotateZ = function (a, rad, out) {
	    var s = Math.sin(rad),
	        c = Math.cos(rad),
	        a00 = a[0],
	        a01 = a[1],
	        a02 = a[2],
	        a03 = a[3],
	        a10 = a[4],
	        a11 = a[5],
	        a12 = a[6],
	        a13 = a[7];

	    if (a !== out) { // If the source and destination differ, copy the unchanged last row
	        out[8]  = a[8];
	        out[9]  = a[9];
	        out[10] = a[10];
	        out[11] = a[11];
	        out[12] = a[12];
	        out[13] = a[13];
	        out[14] = a[14];
	        out[15] = a[15];
	    }

	    // Perform axis-specific matrix multiplication
	    out[0] = a00 * c + a10 * s;
	    out[1] = a01 * c + a11 * s;
	    out[2] = a02 * c + a12 * s;
	    out[3] = a03 * c + a13 * s;
	    out[4] = a10 * c - a00 * s;
	    out[5] = a11 * c - a01 * s;
	    out[6] = a12 * c - a02 * s;
	    out[7] = a13 * c - a03 * s;
	    return out;
	};

	/**
	 * Creates a matrix from a vector translation
	 * This is equivalent to (but much faster than):
	 *
	 *     mat4.identity(dest);
	 *     mat4.translate(dest, dest, vec);
	 *
	 * @param {Vec3} v Translation vector
	 * @returns {Mat4} out
	 * @param {Mat4} out mat4 receiving operation result
	 * @method module:mat4.fromTranslation
	 */
	mat4.fromTranslation = function(v, out) {
	    out[0] = 1;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = 0;
	    out[5] = 1;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = 0;
	    out[9] = 0;
	    out[10] = 1;
	    out[11] = 0;
	    out[12] = v[0];
	    out[13] = v[1];
	    out[14] = v[2];
	    out[15] = 1;
	    return out;
	};

	/**
	 * Creates a matrix from a vector scaling
	 * This is equivalent to (but much faster than):
	 *
	 *     mat4.identity(dest);
	 *     mat4.scale(dest, dest, vec);
	 *
	 * @param {Vec3} v Scaling vector
	 * @returns {Mat4} out
	 * @param {Mat4} out mat4 receiving operation result
	 * @method module:mat4.fromScaling
	 */
	mat4.fromScaling = function(v, out) {
	    out[0] = v[0];
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = 0;
	    out[5] = v[1];
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = 0;
	    out[9] = 0;
	    out[10] = v[2];
	    out[11] = 0;
	    out[12] = 0;
	    out[13] = 0;
	    out[14] = 0;
	    out[15] = 1;
	    return out;
	};

	/**
	 * Creates a matrix from a given angle around a given axis
	 * This is equivalent to (but much faster than):
	 *
	 *     mat4.identity(dest);
	 *     mat4.rotate(dest, dest, rad, axis);
	 *
	 * @param {Number} rad the angle to rotate the matrix by
	 * @param {Vec3} axis the axis to rotate around
	 * @returns {Mat4} out
	 * @param {Mat4} out mat4 receiving operation result
	 * @method module:mat4.fromRotation
	 */
	mat4.fromRotation = function(rad, axis, out) {
	    var x = axis[0], y = axis[1], z = axis[2],
	        len = Math.sqrt(x * x + y * y + z * z),
	        s, c, t;
	    
	    if (Math.abs(len) < GLMAT_EPSILON) { return null; }
	    
	    len = 1 / len;
	    x *= len;
	    y *= len;
	    z *= len;
	    
	    s = Math.sin(rad);
	    c = Math.cos(rad);
	    t = 1 - c;
	    
	    // Perform rotation-specific matrix multiplication
	    out[0] = x * x * t + c;
	    out[1] = y * x * t + z * s;
	    out[2] = z * x * t - y * s;
	    out[3] = 0;
	    out[4] = x * y * t - z * s;
	    out[5] = y * y * t + c;
	    out[6] = z * y * t + x * s;
	    out[7] = 0;
	    out[8] = x * z * t + y * s;
	    out[9] = y * z * t - x * s;
	    out[10] = z * z * t + c;
	    out[11] = 0;
	    out[12] = 0;
	    out[13] = 0;
	    out[14] = 0;
	    out[15] = 1;
	    return out;
	};

	/**
	 * Creates a matrix from the given angle around the X axis
	 * This is equivalent to (but much faster than):
	 *
	 *     mat4.identity(dest);
	 *     mat4.rotateX(dest, dest, rad);
	 *
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {Mat4} out
	 * @param {Mat4} out mat4 receiving operation result
	 * @method module:mat4.fromXRotation
	 */
	mat4.fromXRotation = function(rad, out) {
	    var s = Math.sin(rad),
	        c = Math.cos(rad);
	    
	    // Perform axis-specific matrix multiplication
	    out[0]  = 1;
	    out[1]  = 0;
	    out[2]  = 0;
	    out[3]  = 0;
	    out[4] = 0;
	    out[5] = c;
	    out[6] = s;
	    out[7] = 0;
	    out[8] = 0;
	    out[9] = -s;
	    out[10] = c;
	    out[11] = 0;
	    out[12] = 0;
	    out[13] = 0;
	    out[14] = 0;
	    out[15] = 1;
	    return out;
	};

	/**
	 * Creates a matrix from the given angle around the Y axis
	 * This is equivalent to (but much faster than):
	 *
	 *     mat4.identity(dest);
	 *     mat4.rotateY(dest, dest, rad);
	 *
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {Mat4} out
	 * @param {Mat4} out mat4 receiving operation result
	 * @method module:mat4.fromYRotation
	 */
	mat4.fromYRotation = function(rad, out) {
	    var s = Math.sin(rad),
	        c = Math.cos(rad);
	    
	    // Perform axis-specific matrix multiplication
	    out[0]  = c;
	    out[1]  = 0;
	    out[2]  = -s;
	    out[3]  = 0;
	    out[4] = 0;
	    out[5] = 1;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = s;
	    out[9] = 0;
	    out[10] = c;
	    out[11] = 0;
	    out[12] = 0;
	    out[13] = 0;
	    out[14] = 0;
	    out[15] = 1;
	    return out;
	};

	/**
	 * Creates a matrix from the given angle around the Z axis
	 * This is equivalent to (but much faster than):
	 *
	 *     mat4.identity(dest);
	 *     mat4.rotateZ(dest, dest, rad);
	 *
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {Mat4} out
	 * @param {Mat4} out mat4 receiving operation result
	 * @method module:mat4.fromZRotation
	 */
	mat4.fromZRotation = function(rad, out) {
	    var s = Math.sin(rad),
	        c = Math.cos(rad);
	    
	    // Perform axis-specific matrix multiplication
	    out[0]  = c;
	    out[1]  = s;
	    out[2]  = 0;
	    out[3]  = 0;
	    out[4] = -s;
	    out[5] = c;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = 0;
	    out[9] = 0;
	    out[10] = 1;
	    out[11] = 0;
	    out[12] = 0;
	    out[13] = 0;
	    out[14] = 0;
	    out[15] = 1;
	    return out;
	};

	/**
	 * Creates a matrix from a quaternion rotation and vector translation
	 * This is equivalent to (but much faster than):
	 *
	 *     mat4.identity(dest);
	 *     mat4.translate(dest, vec);
	 *     var quatMat = mat4.create();
	 *     quat4.toMat4(quat, quatMat);
	 *     mat4.multiply(dest, quatMat);
	 *
	 * @param {quat4} q Rotation quaternion
	 * @param {Vec3} v Translation vector
	 * @returns {Mat4} out
	 * @param {Mat4} out mat4 receiving operation result
	 * @method module:mat4.fromRotationTranslation
	 */
	mat4.fromRotationTranslation = function (q, v, out) {
	    // Quaternion math
	    var x = q[0], y = q[1], z = q[2], w = q[3],
	        x2 = x + x,
	        y2 = y + y,
	        z2 = z + z,

	        xx = x * x2,
	        xy = x * y2,
	        xz = x * z2,
	        yy = y * y2,
	        yz = y * z2,
	        zz = z * z2,
	        wx = w * x2,
	        wy = w * y2,
	        wz = w * z2;

	    out[0] = 1 - (yy + zz);
	    out[1] = xy + wz;
	    out[2] = xz - wy;
	    out[3] = 0;
	    out[4] = xy - wz;
	    out[5] = 1 - (xx + zz);
	    out[6] = yz + wx;
	    out[7] = 0;
	    out[8] = xz + wy;
	    out[9] = yz - wx;
	    out[10] = 1 - (xx + yy);
	    out[11] = 0;
	    out[12] = v[0];
	    out[13] = v[1];
	    out[14] = v[2];
	    out[15] = 1;
	    
	    return out;
	};

	/**
	 * Creates a matrix from a quaternion rotation, vector translation and vector scale
	 * This is equivalent to (but much faster than):
	 *
	 *     mat4.identity(dest);
	 *     mat4.translate(dest, vec);
	 *     var quatMat = mat4.create();
	 *     quat4.toMat4(quat, quatMat);
	 *     mat4.multiply(dest, quatMat);
	 *     mat4.scale(dest, scale)
	 *
	 * @param {quat4} q Rotation quaternion
	 * @param {Vec3} v Translation vector
	 * @param {Vec3} s Scaling vector
	 * @returns {Mat4} out
	 * @param {Mat4} out mat4 receiving operation result
	 * @method module:mat4.fromRotationTranslationScale
	 */
	mat4.fromRotationTranslationScale = function (q, v, s, out) {
	    // Quaternion math
	    var x = q[0], y = q[1], z = q[2], w = q[3],
	        x2 = x + x,
	        y2 = y + y,
	        z2 = z + z,

	        xx = x * x2,
	        xy = x * y2,
	        xz = x * z2,
	        yy = y * y2,
	        yz = y * z2,
	        zz = z * z2,
	        wx = w * x2,
	        wy = w * y2,
	        wz = w * z2,
	        sx = s[0],
	        sy = s[1],
	        sz = s[2];

	    out[0] = (1 - (yy + zz)) * sx;
	    out[1] = (xy + wz) * sx;
	    out[2] = (xz - wy) * sx;
	    out[3] = 0;
	    out[4] = (xy - wz) * sy;
	    out[5] = (1 - (xx + zz)) * sy;
	    out[6] = (yz + wx) * sy;
	    out[7] = 0;
	    out[8] = (xz + wy) * sz;
	    out[9] = (yz - wx) * sz;
	    out[10] = (1 - (xx + yy)) * sz;
	    out[11] = 0;
	    out[12] = v[0];
	    out[13] = v[1];
	    out[14] = v[2];
	    out[15] = 1;
	    
	    return out;
	};

	/**
	 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
	 * This is equivalent to (but much faster than):
	 *
	 *     mat4.identity(dest);
	 *     mat4.translate(dest, vec);
	 *     mat4.translate(dest, origin);
	 *     var quatMat = mat4.create();
	 *     quat4.toMat4(quat, quatMat);
	 *     mat4.multiply(dest, quatMat);
	 *     mat4.scale(dest, scale)
	 *     mat4.translate(dest, negativeOrigin);
	 *
	 * @param {quat4} q Rotation quaternion
	 * @param {Vec3} v Translation vector
	 * @param {Vec3} s Scaling vector
	 * @param {Vec3} o The origin vector around which to scale and rotate
	 * @returns {Mat4} out
	 * @param {Mat4} out mat4 receiving operation result
	 * @method module:mat4.fromRotationTranslationScaleOrigin
	 */
	mat4.fromRotationTranslationScaleOrigin = function (q, v, s, o, out) {
	  // Quaternion math
	  var x = q[0], y = q[1], z = q[2], w = q[3],
	      x2 = x + x,
	      y2 = y + y,
	      z2 = z + z,

	      xx = x * x2,
	      xy = x * y2,
	      xz = x * z2,
	      yy = y * y2,
	      yz = y * z2,
	      zz = z * z2,
	      wx = w * x2,
	      wy = w * y2,
	      wz = w * z2,
	      
	      sx = s[0],
	      sy = s[1],
	      sz = s[2],

	      ox = o[0],
	      oy = o[1],
	      oz = o[2];
	      
	  out[0] = (1 - (yy + zz)) * sx;
	  out[1] = (xy + wz) * sx;
	  out[2] = (xz - wy) * sx;
	  out[3] = 0;
	  out[4] = (xy - wz) * sy;
	  out[5] = (1 - (xx + zz)) * sy;
	  out[6] = (yz + wx) * sy;
	  out[7] = 0;
	  out[8] = (xz + wy) * sz;
	  out[9] = (yz - wx) * sz;
	  out[10] = (1 - (xx + yy)) * sz;
	  out[11] = 0;
	  out[12] = v[0] + ox - (out[0] * ox + out[4] * oy + out[8] * oz);
	  out[13] = v[1] + oy - (out[1] * ox + out[5] * oy + out[9] * oz);
	  out[14] = v[2] + oz - (out[2] * ox + out[6] * oy + out[10] * oz);
	  out[15] = 1;
	        
	  return out;
	};

	mat4.fromQuat = function (q, out) {
	    var x = q[0], y = q[1], z = q[2], w = q[3],
	        x2 = x + x,
	        y2 = y + y,
	        z2 = z + z,

	        xx = x * x2,
	        yx = y * x2,
	        yy = y * y2,
	        zx = z * x2,
	        zy = z * y2,
	        zz = z * z2,
	        wx = w * x2,
	        wy = w * y2,
	        wz = w * z2;

	    out[0] = 1 - yy - zz;
	    out[1] = yx + wz;
	    out[2] = zx - wy;
	    out[3] = 0;

	    out[4] = yx - wz;
	    out[5] = 1 - xx - zz;
	    out[6] = zy + wx;
	    out[7] = 0;

	    out[8] = zx + wy;
	    out[9] = zy - wx;
	    out[10] = 1 - xx - yy;
	    out[11] = 0;

	    out[12] = 0;
	    out[13] = 0;
	    out[14] = 0;
	    out[15] = 1;

	    return out;
	};

	/**
	 * Generates a frustum matrix with the given bounds
	 *
	 * @param {Number} left Left bound of the frustum
	 * @param {Number} right Right bound of the frustum
	 * @param {Number} bottom Bottom bound of the frustum
	 * @param {Number} top Top bound of the frustum
	 * @param {Number} near Near bound of the frustum
	 * @param {Number} far Far bound of the frustum
	 * @returns {Mat4} out
	 * @param {Mat4} out mat4 frustum matrix will be written into
	 * @method module:mat4.frustum
	 */
	mat4.frustum = function (left, right, bottom, top, near, far, out) {
	    var rl = 1 / (right - left),
	        tb = 1 / (top - bottom),
	        nf = 1 / (near - far);
	    out[0] = (near * 2) * rl;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = 0;
	    out[5] = (near * 2) * tb;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = (right + left) * rl;
	    out[9] = (top + bottom) * tb;
	    out[10] = (far + near) * nf;
	    out[11] = -1;
	    out[12] = 0;
	    out[13] = 0;
	    out[14] = (far * near * 2) * nf;
	    out[15] = 0;
	    return out;
	};

	/**
	 * Generates a perspective projection matrix with the given bounds
	 *
	 * @param {number} fovy Vertical field of view in radians
	 * @param {number} aspect Aspect ratio. typically viewport width/height
	 * @param {number} near Near bound of the frustum
	 * @param {number} far Far bound of the frustum
	 * @returns {Mat4} out
	 * @param {Mat4} out mat4 frustum matrix will be written into
	 * @method module:mat4.perspective
	 */
	mat4.perspective = function (fovy, aspect, near, far, out) {
	    var f = 1.0 / Math.tan(fovy / 2),
	        nf = 1 / (near - far);
	    out[0] = f / aspect;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = 0;
	    out[5] = f;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = 0;
	    out[9] = 0;
	    out[10] = (far + near) * nf;
	    out[11] = -1;
	    out[12] = 0;
	    out[13] = 0;
	    out[14] = (2 * far * near) * nf;
	    out[15] = 0;
	    return out;
	};

	/**
	 * Generates a perspective projection matrix with the given field of view.
	 * This is primarily useful for generating projection matrices to be used
	 * with the still experiemental WebVR API.
	 *
	 * @param {number} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
	 * @param {number} near Near bound of the frustum
	 * @param {number} far Far bound of the frustum
	 * @returns {Mat4} out
	 * @param {Mat4} out mat4 frustum matrix will be written into
	 * @method module:mat4.perspectiveFromFieldOfView
	 */
	mat4.perspectiveFromFieldOfView = function (fov, near, far, out) {
	    var upTan = Math.tan(fov.upDegrees * Math.PI/180.0),
	        downTan = Math.tan(fov.downDegrees * Math.PI/180.0),
	        leftTan = Math.tan(fov.leftDegrees * Math.PI/180.0),
	        rightTan = Math.tan(fov.rightDegrees * Math.PI/180.0),
	        xScale = 2.0 / (leftTan + rightTan),
	        yScale = 2.0 / (upTan + downTan);

	    out[0] = xScale;
	    out[1] = 0.0;
	    out[2] = 0.0;
	    out[3] = 0.0;
	    out[4] = 0.0;
	    out[5] = yScale;
	    out[6] = 0.0;
	    out[7] = 0.0;
	    out[8] = -((leftTan - rightTan) * xScale * 0.5);
	    out[9] = ((upTan - downTan) * yScale * 0.5);
	    out[10] = far / (near - far);
	    out[11] = -1.0;
	    out[12] = 0.0;
	    out[13] = 0.0;
	    out[14] = (far * near) / (near - far);
	    out[15] = 0.0;
	    return out;
	};

	/**
	 * Generates a orthogonal projection matrix with the given bounds
	 *
	 * @param {number} left Left bound of the frustum
	 * @param {number} right Right bound of the frustum
	 * @param {number} bottom Bottom bound of the frustum
	 * @param {number} top Top bound of the frustum
	 * @param {number} near Near bound of the frustum
	 * @param {number} far Far bound of the frustum
	 * @returns {Mat4} out
	 * @param {Mat4} out mat4 frustum matrix will be written into
	 * @method module:mat4.ortho
	 */
	mat4.ortho = function (left, right, bottom, top, near, far, out) {
	    var lr = 1 / (left - right),
	        bt = 1 / (bottom - top),
	        nf = 1 / (near - far);
	    out[0] = -2 * lr;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = 0;
	    out[5] = -2 * bt;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = 0;
	    out[9] = 0;
	    out[10] = 2 * nf;
	    out[11] = 0;
	    out[12] = (left + right) * lr;
	    out[13] = (top + bottom) * bt;
	    out[14] = (far + near) * nf;
	    out[15] = 1;
	    return out;
	};

	/**
	 * Generates a look-at matrix with the given eye position, focal point, and up axis
	 *
	 * @param {Vec3} eye Position of the viewer
	 * @param {Vec3} center Point the viewer is looking at
	 * @param {Vec3} up vec3 pointing up
	 * @returns {Mat4} out
	 * @param {Mat4} out mat4 frustum matrix will be written into
	 * @method module:mat4.lookAt
	 */
	mat4.lookAt = function (eye, center, up, out) {
	    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
	        eyex = eye[0],
	        eyey = eye[1],
	        eyez = eye[2],
	        upx = up[0],
	        upy = up[1],
	        upz = up[2],
	        centerx = center[0],
	        centery = center[1],
	        centerz = center[2];

	    if (Math.abs(eyex - centerx) < GLMAT_EPSILON &&
	        Math.abs(eyey - centery) < GLMAT_EPSILON &&
	        Math.abs(eyez - centerz) < GLMAT_EPSILON) {
	        return mat4.identity(out);
	    }

	    z0 = eyex - centerx;
	    z1 = eyey - centery;
	    z2 = eyez - centerz;

	    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
	    z0 *= len;
	    z1 *= len;
	    z2 *= len;

	    x0 = upy * z2 - upz * z1;
	    x1 = upz * z0 - upx * z2;
	    x2 = upx * z1 - upy * z0;
	    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
	    if (!len) {
	        x0 = 0;
	        x1 = 0;
	        x2 = 0;
	    } else {
	        len = 1 / len;
	        x0 *= len;
	        x1 *= len;
	        x2 *= len;
	    }

	    y0 = z1 * x2 - z2 * x1;
	    y1 = z2 * x0 - z0 * x2;
	    y2 = z0 * x1 - z1 * x0;

	    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
	    if (!len) {
	        y0 = 0;
	        y1 = 0;
	        y2 = 0;
	    } else {
	        len = 1 / len;
	        y0 *= len;
	        y1 *= len;
	        y2 *= len;
	    }

	    out[0] = x0;
	    out[1] = y0;
	    out[2] = z0;
	    out[3] = 0;
	    out[4] = x1;
	    out[5] = y1;
	    out[6] = z1;
	    out[7] = 0;
	    out[8] = x2;
	    out[9] = y2;
	    out[10] = z2;
	    out[11] = 0;
	    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
	    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
	    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
	    out[15] = 1;

	    return out;
	};

	/**
	 * Returns a string representation of a mat4
	 *
	 * @param {Mat4} mat matrix to represent as a string
	 * @returns {String} string representation of the matrix
	 * @method module:mat4.str
	 */
	mat4.str = function (a) {
	    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
	                    a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +
	                    a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + 
	                    a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
	};

	/**
	 * Returns Frobenius norm of a mat4
	 *
	 * @param {Mat4} a the matrix to calculate Frobenius norm of
	 * @returns {Number} Frobenius norm
	 * @method module:mat4.frob
	 */
	mat4.frob = function (a) {
	    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2) ))
	};


	}

	var mat4_factory = register("mat4", Mat4);
	register("__mat4", Mat4);

	"use strict";

	/**
	 * Auto-generated set of math modules.
	 * based on glMatrix 2.1.0
	 * pay attention to parameters order, quat.rotationTo() and quat.setAxes()
	 */

	/**
	 * @module 3 Dimensional Vector
	 * @name vec3
	 */
	function Vec3(ns, exports) {


	var GLMAT_ARRAY_TYPE = (typeof Float32Array !== 'undefined') ? Float32Array : Array;
	var GLMAT_RANDOM = Math.random;

	/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE. */

	var vec3 = exports;

	/**
	 * Creates a new, empty vec3
	 *
	 * @returns {Vec3} a new 3D vector
	 * @method module:vec3.create
	 */
	vec3.create = function() {
	    var out = new GLMAT_ARRAY_TYPE(3);
	    out[0] = 0;
	    out[1] = 0;
	    out[2] = 0;
	    return out;
	};

	/**
	 * Creates a new vec3 initialized with values from an existing vector
	 *
	 * @param {Vec3} a vector to clone
	 * @returns {Vec3} a new 3D vector
	 * @method module:vec3.clone
	 */
	vec3.clone = function(a) {
	    var out = new GLMAT_ARRAY_TYPE(3);
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = a[2];
	    return out;
	};

	/**
	 * Creates a new vec3 initialized with the given values
	 *
	 * @param {Number} x X component
	 * @param {Number} y Y component
	 * @param {Number} z Z component
	 * @returns {Vec3} a new 3D vector
	 * @method module:vec3.fromValues
	 */
	vec3.fromValues = function(x, y, z) {
	    var out = new GLMAT_ARRAY_TYPE(3);
	    out[0] = x;
	    out[1] = y;
	    out[2] = z;
	    return out;
	};

	/**
	 * Copy the values from one vec3 to another
	 *
	 * @param {Vec3} a the source vector
	 * @returns {Vec3} out
	 * @param {Vec3} out the receiving vector
	 * @method module:vec3.copy
	 */
	vec3.copy = function(a, out) {
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = a[2];
	    return out;
	};

	/**
	 * Set the components of a vec3 to the given values
	 *
	 * @param {Number} x X component
	 * @param {Number} y Y component
	 * @param {Number} z Z component
	 * @returns {Vec3} out
	 * @param {Vec3} out the receiving vector
	 * @method module:vec3.set
	 */
	vec3.set = function(x, y, z, out) {
	    out[0] = x;
	    out[1] = y;
	    out[2] = z;
	    return out;
	};

	/**
	 * Adds two vec3's
	 *
	 * @param {Vec3} a the first operand
	 * @param {Vec3} b the second operand
	 * @returns {Vec3} out
	 * @param {Vec3} out the receiving vector
	 * @method module:vec3.add
	 */
	vec3.add = function(a, b, out) {
	    out[0] = a[0] + b[0];
	    out[1] = a[1] + b[1];
	    out[2] = a[2] + b[2];
	    return out;
	};

	/**
	 * Subtracts vector b from vector a
	 *
	 * @param {Vec3} a the first operand
	 * @param {Vec3} b the second operand
	 * @returns {Vec3} out
	 * @param {Vec3} out the receiving vector
	 * @method module:vec3.subtract
	 */
	vec3.subtract = function(a, b, out) {
	    out[0] = a[0] - b[0];
	    out[1] = a[1] - b[1];
	    out[2] = a[2] - b[2];
	    return out;
	};

	/**
	 * Alias for {@link vec3.subtract}
	 * @function
	 * @method module:vec3.sub
	 */
	vec3.sub = vec3.subtract;

	/**
	 * Multiplies two vec3's
	 *
	 * @param {Vec3} a the first operand
	 * @param {Vec3} b the second operand
	 * @returns {Vec3} out
	 * @param {Vec3} out the receiving vector
	 * @method module:vec3.multiply
	 */
	vec3.multiply = function(a, b, out) {
	    out[0] = a[0] * b[0];
	    out[1] = a[1] * b[1];
	    out[2] = a[2] * b[2];
	    return out;
	};

	/**
	 * Alias for {@link vec3.multiply}
	 * @function
	 * @method module:vec3.mul
	 */
	vec3.mul = vec3.multiply;

	/**
	 * Divides two vec3's
	 *
	 * @param {Vec3} a the first operand
	 * @param {Vec3} b the second operand
	 * @returns {Vec3} out
	 * @param {Vec3} out the receiving vector
	 * @method module:vec3.divide
	 */
	vec3.divide = function(a, b, out) {
	    out[0] = a[0] / b[0];
	    out[1] = a[1] / b[1];
	    out[2] = a[2] / b[2];
	    return out;
	};

	/**
	 * Alias for {@link vec3.divide}
	 * @function
	 * @method module:vec3.div
	 */
	vec3.div = vec3.divide;

	/**
	 * Returns the minimum of two vec3's
	 *
	 * @param {Vec3} a the first operand
	 * @param {Vec3} b the second operand
	 * @returns {Vec3} out
	 * @param {Vec3} out the receiving vector
	 * @method module:vec3.min
	 */
	vec3.min = function(a, b, out) {
	    out[0] = Math.min(a[0], b[0]);
	    out[1] = Math.min(a[1], b[1]);
	    out[2] = Math.min(a[2], b[2]);
	    return out;
	};

	/**
	 * Returns the maximum of two vec3's
	 *
	 * @param {Vec3} a the first operand
	 * @param {Vec3} b the second operand
	 * @returns {Vec3} out
	 * @param {Vec3} out the receiving vector
	 * @method module:vec3.max
	 */
	vec3.max = function(a, b, out) {
	    out[0] = Math.max(a[0], b[0]);
	    out[1] = Math.max(a[1], b[1]);
	    out[2] = Math.max(a[2], b[2]);
	    return out;
	};

	/**
	 * Scales a vec3 by a scalar number
	 *
	 * @param {Vec3} a the vector to scale
	 * @param {Number} b amount to scale the vector by
	 * @returns {Vec3} out
	 * @param {Vec3} out the receiving vector
	 * @method module:vec3.scale
	 */
	vec3.scale = function(a, b, out) {
	    out[0] = a[0] * b;
	    out[1] = a[1] * b;
	    out[2] = a[2] * b;
	    return out;
	};

	/**
	 * Adds two vec3's after scaling the second operand by a scalar value
	 *
	 * @param {Vec3} a the first operand
	 * @param {Vec3} b the second operand
	 * @param {Number} scale the amount to scale b by before adding
	 * @returns {Vec3} out
	 * @param {Vec3} out the receiving vector
	 * @method module:vec3.scaleAndAdd
	 */
	vec3.scaleAndAdd = function(a, b, scale, out) {
	    out[0] = a[0] + (b[0] * scale);
	    out[1] = a[1] + (b[1] * scale);
	    out[2] = a[2] + (b[2] * scale);
	    return out;
	};

	/**
	 * Calculates the euclidian distance between two vec3's
	 *
	 * @param {Vec3} a the first operand
	 * @param {Vec3} b the second operand
	 * @returns {Number} distance between a and b
	 * @method module:vec3.distance
	 */
	vec3.distance = function(a, b) {
	    var x = b[0] - a[0],
	        y = b[1] - a[1],
	        z = b[2] - a[2];
	    return Math.sqrt(x*x + y*y + z*z);
	};

	/**
	 * Alias for {@link vec3.distance}
	 * @function
	 * @method module:vec3.dist
	 */
	vec3.dist = vec3.distance;

	/**
	 * Calculates the squared euclidian distance between two vec3's
	 *
	 * @param {Vec3} a the first operand
	 * @param {Vec3} b the second operand
	 * @returns {Number} squared distance between a and b
	 * @method module:vec3.squaredDistance
	 */
	vec3.squaredDistance = function(a, b) {
	    var x = b[0] - a[0],
	        y = b[1] - a[1],
	        z = b[2] - a[2];
	    return x*x + y*y + z*z;
	};

	/**
	 * Alias for {@link vec3.squaredDistance}
	 * @function
	 * @method module:vec3.sqrDist
	 */
	vec3.sqrDist = vec3.squaredDistance;

	/**
	 * Calculates the length of a vec3
	 *
	 * @param {Vec3} a vector to calculate length of
	 * @returns {Number} length of a
	 * @method module:vec3.length
	 */
	vec3.length = function (a) {
	    var x = a[0],
	        y = a[1],
	        z = a[2];
	    return Math.sqrt(x*x + y*y + z*z);
	};

	/**
	 * Alias for {@link vec3.length}
	 * @function
	 * @method module:vec3.len
	 */
	vec3.len = vec3.length;

	/**
	 * Calculates the squared length of a vec3
	 *
	 * @param {Vec3} a vector to calculate squared length of
	 * @returns {Number} squared length of a
	 * @method module:vec3.squaredLength
	 */
	vec3.squaredLength = function (a) {
	    var x = a[0],
	        y = a[1],
	        z = a[2];
	    return x*x + y*y + z*z;
	};

	/**
	 * Alias for {@link vec3.squaredLength}
	 * @function
	 * @method module:vec3.sqrLen
	 */
	vec3.sqrLen = vec3.squaredLength;

	/**
	 * Negates the components of a vec3
	 *
	 * @param {Vec3} a vector to negate
	 * @returns {Vec3} out
	 * @param {Vec3} out the receiving vector
	 * @method module:vec3.negate
	 */
	vec3.negate = function(a, out) {
	    out[0] = -a[0];
	    out[1] = -a[1];
	    out[2] = -a[2];
	    return out;
	};

	/**
	 * Returns the inverse of the components of a vec3
	 *
	 * @param {Vec3} a vector to invert
	 * @returns {Vec3} out
	 * @param {Vec3} out the receiving vector
	 * @method module:vec3.inverse
	 */
	vec3.inverse = function(a, out) {
	  out[0] = 1.0 / a[0];
	  out[1] = 1.0 / a[1];
	  out[2] = 1.0 / a[2];
	  return out;
	};

	/**
	 * Normalize a vec3
	 *
	 * @param {Vec3} a vector to normalize
	 * @returns {Vec3} out
	 * @param {Vec3} out the receiving vector
	 * @method module:vec3.normalize
	 */
	vec3.normalize = function(a, out) {
	    var x = a[0],
	        y = a[1],
	        z = a[2];
	    var len = x*x + y*y + z*z;
	    if (len > 0) {
	        //TODO: evaluate use of glm_invsqrt here?
	        len = 1 / Math.sqrt(len);
	        out[0] = a[0] * len;
	        out[1] = a[1] * len;
	        out[2] = a[2] * len;
	    }
	    return out;
	};

	/**
	 * Calculates the dot product of two vec3's
	 *
	 * @param {Vec3} a the first operand
	 * @param {Vec3} b the second operand
	 * @returns {Number} dot product of a and b
	 * @method module:vec3.dot
	 */
	vec3.dot = function (a, b) {
	    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
	};

	/**
	 * Computes the cross product of two vec3's
	 *
	 * @param {Vec3} a the first operand
	 * @param {Vec3} b the second operand
	 * @returns {Vec3} out
	 * @param {Vec3} out the receiving vector
	 * @method module:vec3.cross
	 */
	vec3.cross = function(a, b, out) {
	    var ax = a[0], ay = a[1], az = a[2],
	        bx = b[0], by = b[1], bz = b[2];

	    out[0] = ay * bz - az * by;
	    out[1] = az * bx - ax * bz;
	    out[2] = ax * by - ay * bx;
	    return out;
	};

	/**
	 * Performs a linear interpolation between two vec3's
	 *
	 * @param {Vec3} a the first operand
	 * @param {Vec3} b the second operand
	 * @param {Number} t interpolation amount between the two inputs
	 * @returns {Vec3} out
	 * @param {Vec3} out the receiving vector
	 * @method module:vec3.lerp
	 */
	vec3.lerp = function (a, b, t, out) {
	    var ax = a[0],
	        ay = a[1],
	        az = a[2];
	    out[0] = ax + t * (b[0] - ax);
	    out[1] = ay + t * (b[1] - ay);
	    out[2] = az + t * (b[2] - az);
	    return out;
	};

	/**
	 * Performs a hermite interpolation with two control points
	 *
	 * @param {Vec3} a the first operand
	 * @param {Vec3} b the second operand
	 * @param {Vec3} c the third operand
	 * @param {Vec3} d the fourth operand
	 * @param {Number} t interpolation amount between the two inputs
	 * @returns {Vec3} out
	 * @param {Vec3} out the receiving vector
	 * @method module:vec3.hermite
	 */
	vec3.hermite = function (a, b, c, d, t, out) {
	  var factorTimes2 = t * t,
	      factor1 = factorTimes2 * (2 * t - 3) + 1,
	      factor2 = factorTimes2 * (t - 2) + t,
	      factor3 = factorTimes2 * (t - 1),
	      factor4 = factorTimes2 * (3 - 2 * t);
	  
	  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
	  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
	  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
	  
	  return out;
	};

	/**
	 * Performs a bezier interpolation with two control points
	 *
	 * @param {Vec3} a the first operand
	 * @param {Vec3} b the second operand
	 * @param {Vec3} c the third operand
	 * @param {Vec3} d the fourth operand
	 * @param {Number} t interpolation amount between the two inputs
	 * @returns {Vec3} out
	 * @param {Vec3} out the receiving vector
	 * @method module:vec3.bezier
	 */
	vec3.bezier = function (a, b, c, d, t, out) {
	  var inverseFactor = 1 - t,
	      inverseFactorTimesTwo = inverseFactor * inverseFactor,
	      factorTimes2 = t * t,
	      factor1 = inverseFactorTimesTwo * inverseFactor,
	      factor2 = 3 * t * inverseFactorTimesTwo,
	      factor3 = 3 * factorTimes2 * inverseFactor,
	      factor4 = factorTimes2 * t;
	  
	  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
	  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
	  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
	  
	  return out;
	};

	/**
	 * Generates a random vector with the given scale
	 *
	 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
	 * @returns {Vec3} out
	 * @param {Vec3} out the receiving vector
	 * @method module:vec3.random
	 */
	vec3.random = function (scale, out) {
	    scale = scale || 1.0;

	    var r = GLMAT_RANDOM() * 2.0 * Math.PI;
	    var z = (GLMAT_RANDOM() * 2.0) - 1.0;
	    var zScale = Math.sqrt(1.0-z*z) * scale;

	    out[0] = Math.cos(r) * zScale;
	    out[1] = Math.sin(r) * zScale;
	    out[2] = z * scale;
	    return out;
	};

	/**
	 * Transforms the vec3 with a mat4.
	 * 4th vector component is implicitly '1'
	 *
	 * @param {Vec3} a the vector to transform
	 * @param {Mat4} m matrix to transform with
	 * @returns {Vec3} out
	 * @param {Vec3} out the receiving vector
	 * @method module:vec3.transformMat4
	 */
	vec3.transformMat4 = function(a, m, out) {
	    var x = a[0], y = a[1], z = a[2],
	        w = m[3] * x + m[7] * y + m[11] * z + m[15];
	    w = w || 1.0;
	    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
	    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
	    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
	    return out;
	};

	/**
	 * Transforms the vec3 with a mat3.
	 *
	 * @param {Vec3} a the vector to transform
	 * @param {Mat4} m the 3x3 matrix to transform with
	 * @returns {Vec3} out
	 * @param {Vec3} out the receiving vector
	 * @method module:vec3.transformMat3
	 */
	vec3.transformMat3 = function(a, m, out) {
	    var x = a[0], y = a[1], z = a[2];
	    out[0] = x * m[0] + y * m[3] + z * m[6];
	    out[1] = x * m[1] + y * m[4] + z * m[7];
	    out[2] = x * m[2] + y * m[5] + z * m[8];
	    return out;
	};

	/**
	 * Transforms the vec3 with a quat
	 *
	 * @param {Vec3} a the vector to transform
	 * @param {Quat} q quaternion to transform with
	 * @returns {Vec3} out
	 * @param {Vec3} out the receiving vector
	 * @method module:vec3.transformQuat
	 */
	vec3.transformQuat = function(a, q, out) {
	    // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations

	    var x = a[0], y = a[1], z = a[2],
	        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

	        // calculate quat * vec
	        ix = qw * x + qy * z - qz * y,
	        iy = qw * y + qz * x - qx * z,
	        iz = qw * z + qx * y - qy * x,
	        iw = -qx * x - qy * y - qz * z;

	    // calculate result * inverse quat
	    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
	    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
	    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
	    return out;
	};

	/**
	 * Rotate a 3D vector around the x-axis
	 * @param {Vec3} a The vec3 point to rotate
	 * @param {Vec3} b The origin of the rotation
	 * @param {Number} c The angle of rotation
	 * @returns {Vec3} out
	 * @param {Vec3} out The receiving vec3
	 * @method module:vec3.rotateX
	 */
	vec3.rotateX = function(a, b, c, out){
	   var p = [], r=[];
		  //Translate point to the origin
		  p[0] = a[0] - b[0];
		  p[1] = a[1] - b[1];
	  	p[2] = a[2] - b[2];

		  //perform rotation
		  r[0] = p[0];
		  r[1] = p[1]*Math.cos(c) - p[2]*Math.sin(c);
		  r[2] = p[1]*Math.sin(c) + p[2]*Math.cos(c);

		  //translate to correct position
		  out[0] = r[0] + b[0];
		  out[1] = r[1] + b[1];
		  out[2] = r[2] + b[2];

	  	return out;
	};

	/**
	 * Rotate a 3D vector around the y-axis
	 * @param {Vec3} a The vec3 point to rotate
	 * @param {Vec3} b The origin of the rotation
	 * @param {Number} c The angle of rotation
	 * @returns {Vec3} out
	 * @param {Vec3} out The receiving vec3
	 * @method module:vec3.rotateY
	 */
	vec3.rotateY = function(a, b, c, out){
	  	var p = [], r=[];
	  	//Translate point to the origin
	  	p[0] = a[0] - b[0];
	  	p[1] = a[1] - b[1];
	  	p[2] = a[2] - b[2];
	  
	  	//perform rotation
	  	r[0] = p[2]*Math.sin(c) + p[0]*Math.cos(c);
	  	r[1] = p[1];
	  	r[2] = p[2]*Math.cos(c) - p[0]*Math.sin(c);
	  
	  	//translate to correct position
	  	out[0] = r[0] + b[0];
	  	out[1] = r[1] + b[1];
	  	out[2] = r[2] + b[2];
	  
	  	return out;
	};

	/**
	 * Rotate a 3D vector around the z-axis
	 * @param {Vec3} a The vec3 point to rotate
	 * @param {Vec3} b The origin of the rotation
	 * @param {Number} c The angle of rotation
	 * @returns {Vec3} out
	 * @param {Vec3} out The receiving vec3
	 * @method module:vec3.rotateZ
	 */
	vec3.rotateZ = function(a, b, c, out){
	  	var p = [], r=[];
	  	//Translate point to the origin
	  	p[0] = a[0] - b[0];
	  	p[1] = a[1] - b[1];
	  	p[2] = a[2] - b[2];
	  
	  	//perform rotation
	  	r[0] = p[0]*Math.cos(c) - p[1]*Math.sin(c);
	  	r[1] = p[0]*Math.sin(c) + p[1]*Math.cos(c);
	  	r[2] = p[2];
	  
	  	//translate to correct position
	  	out[0] = r[0] + b[0];
	  	out[1] = r[1] + b[1];
	  	out[2] = r[2] + b[2];
	  
	  	return out;
	};

	/**
	 * Perform some operation over an array of vec3s.
	 *
	 * @param {Array} a the array of vectors to iterate over
	 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
	 * @param {Number} offset Number of elements to skip at the beginning of the array
	 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
	 * @param {Function} fn Function to call for each vector in the array
	 * @param {Object} [arg] additional argument to pass to fn
	 * @returns {Array} a
	 * @function
	 * @method module:vec3.forEach
	 */
	vec3.forEach = (function() {
	    var vec = vec3.create();

	    return function(a, stride, offset, count, fn, arg) {
	        var i, l;
	        if(!stride) {
	            stride = 3;
	        }

	        if(!offset) {
	            offset = 0;
	        }
	        
	        if(count) {
	            l = Math.min((count * stride) + offset, a.length);
	        } else {
	            l = a.length;
	        }

	        for(i = offset; i < l; i += stride) {
	            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2];
	            fn(vec, arg, vec);
	            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2];
	        }
	        
	        return a;
	    };
	})();

	/**
	 * Get the angle between two 3D vectors
	 * @param {Vec3} a The first operand
	 * @param {Vec3} b The second operand
	 * @returns {Number} The angle in radians
	 * @method module:vec3.angle
	 */
	vec3.angle = function(a, b) {
	   
	    var tempA = vec3.fromValues(a[0], a[1], a[2]);
	    var tempB = vec3.fromValues(b[0], b[1], b[2]);
	 
	    vec3.normalize(tempA, tempA);
	    vec3.normalize(tempB, tempB);
	 
	    var cosine = vec3.dot(tempA, tempB);

	    if(cosine > 1.0){
	        return 0;
	    } else {
	        return Math.acos(cosine);
	    }     
	};

	/**
	 * Returns a string representation of a vector
	 *
	 * @param {Vec3} vec vector to represent as a string
	 * @returns {String} string representation of the vector
	 * @method module:vec3.str
	 */
	vec3.str = function (a) {
	    return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
	};

	}

	var vec3_factory = register("vec3", Vec3);
	register("__vec3", Vec3);

	"use strict";

	/**
	 * @module 4 Dimensional Vector
	 * @name vec4
	 */
	function Vec4(ns, exports) {

	var GLMAT_ARRAY_TYPE = (typeof Float32Array !== 'undefined') ? Float32Array : Array;
	var GLMAT_RANDOM = Math.random;

	/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE. */

	var vec4 = exports;

	/**
	 * Creates a new, empty vec4
	 *
	 * @returns {Vec4} a new 4D vector
	 * @method module:vec4.create
	 */
	vec4.create = function() {
	    var out = new GLMAT_ARRAY_TYPE(4);
	    out[0] = 0;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    return out;
	};

	/**
	 * Creates a new vec4 initialized with values from an existing vector
	 *
	 * @param {Vec4} a vector to clone
	 * @returns {Vec4} a new 4D vector
	 * @method module:vec4.clone
	 */
	vec4.clone = function(a) {
	    var out = new GLMAT_ARRAY_TYPE(4);
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = a[2];
	    out[3] = a[3];
	    return out;
	};

	/**
	 * Creates a new vec4 initialized with the given values
	 *
	 * @param {Number} x X component
	 * @param {Number} y Y component
	 * @param {Number} z Z component
	 * @param {Number} w W component
	 * @returns {Vec4} a new 4D vector
	 * @method module:vec4.fromValues
	 */
	vec4.fromValues = function(x, y, z, w) {
	    var out = new GLMAT_ARRAY_TYPE(4);
	    out[0] = x;
	    out[1] = y;
	    out[2] = z;
	    out[3] = w;
	    return out;
	};

	/**
	 * Copy the values from one vec4 to another
	 *
	 * @param {Vec4} a the source vector
	 * @returns {Vec4} out
	 * @param {Vec4} out the receiving vector
	 * @method module:vec4.copy
	 */
	vec4.copy = function(a, out) {
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = a[2];
	    out[3] = a[3];
	    return out;
	};

	/**
	 * Set the components of a vec4 to the given values
	 *
	 * @param {Number} x X component
	 * @param {Number} y Y component
	 * @param {Number} z Z component
	 * @param {Number} w W component
	 * @returns {Vec4} out
	 * @param {Vec4} out the receiving vector
	 * @method module:vec4.set
	 */
	vec4.set = function(x, y, z, w, out) {
	    out[0] = x;
	    out[1] = y;
	    out[2] = z;
	    out[3] = w;
	    return out;
	};

	/**
	 * Adds two vec4's
	 *
	 * @param {Vec4} a the first operand
	 * @param {Vec4} b the second operand
	 * @returns {Vec4} out
	 * @param {Vec4} out the receiving vector
	 * @method module:vec4.add
	 */
	vec4.add = function(a, b, out) {
	    out[0] = a[0] + b[0];
	    out[1] = a[1] + b[1];
	    out[2] = a[2] + b[2];
	    out[3] = a[3] + b[3];
	    return out;
	};

	/**
	 * Subtracts vector b from vector a
	 *
	 * @param {Vec4} a the first operand
	 * @param {Vec4} b the second operand
	 * @returns {Vec4} out
	 * @param {Vec4} out the receiving vector
	 * @method module:vec4.subtract
	 */
	vec4.subtract = function(a, b, out) {
	    out[0] = a[0] - b[0];
	    out[1] = a[1] - b[1];
	    out[2] = a[2] - b[2];
	    out[3] = a[3] - b[3];
	    return out;
	};

	/**
	 * Alias for {@link vec4.subtract}
	 * @function
	 * @method module:vec4.sub
	 */
	vec4.sub = vec4.subtract;

	/**
	 * Multiplies two vec4's
	 *
	 * @param {Vec4} a the first operand
	 * @param {Vec4} b the second operand
	 * @returns {Vec4} out
	 * @param {Vec4} out the receiving vector
	 * @method module:vec4.multiply
	 */
	vec4.multiply = function(a, b, out) {
	    out[0] = a[0] * b[0];
	    out[1] = a[1] * b[1];
	    out[2] = a[2] * b[2];
	    out[3] = a[3] * b[3];
	    return out;
	};

	/**
	 * Alias for {@link vec4.multiply}
	 * @function
	 * @method module:vec4.mul
	 */
	vec4.mul = vec4.multiply;

	/**
	 * Divides two vec4's
	 *
	 * @param {Vec4} a the first operand
	 * @param {Vec4} b the second operand
	 * @returns {Vec4} out
	 * @param {Vec4} out the receiving vector
	 * @method module:vec4.divide
	 */
	vec4.divide = function(a, b, out) {
	    out[0] = a[0] / b[0];
	    out[1] = a[1] / b[1];
	    out[2] = a[2] / b[2];
	    out[3] = a[3] / b[3];
	    return out;
	};

	/**
	 * Alias for {@link vec4.divide}
	 * @function
	 * @method module:vec4.div
	 */
	vec4.div = vec4.divide;

	/**
	 * Returns the minimum of two vec4's
	 *
	 * @param {Vec4} a the first operand
	 * @param {Vec4} b the second operand
	 * @returns {Vec4} out
	 * @param {Vec4} out the receiving vector
	 * @method module:vec4.min
	 */
	vec4.min = function(a, b, out) {
	    out[0] = Math.min(a[0], b[0]);
	    out[1] = Math.min(a[1], b[1]);
	    out[2] = Math.min(a[2], b[2]);
	    out[3] = Math.min(a[3], b[3]);
	    return out;
	};

	/**
	 * Returns the maximum of two vec4's
	 *
	 * @param {Vec4} a the first operand
	 * @param {Vec4} b the second operand
	 * @returns {Vec4} out
	 * @param {Vec4} out the receiving vector
	 * @method module:vec4.max
	 */
	vec4.max = function(a, b, out) {
	    out[0] = Math.max(a[0], b[0]);
	    out[1] = Math.max(a[1], b[1]);
	    out[2] = Math.max(a[2], b[2]);
	    out[3] = Math.max(a[3], b[3]);
	    return out;
	};

	/**
	 * Scales a vec4 by a scalar number
	 *
	 * @param {Vec4} a the vector to scale
	 * @param {Number} b amount to scale the vector by
	 * @returns {Vec4} out
	 * @param {Vec4} out the receiving vector
	 * @method module:vec4.scale
	 */
	vec4.scale = function(a, b, out) {
	    out[0] = a[0] * b;
	    out[1] = a[1] * b;
	    out[2] = a[2] * b;
	    out[3] = a[3] * b;
	    return out;
	};

	/**
	 * Adds two vec4's after scaling the second operand by a scalar value
	 *
	 * @param {Vec4} a the first operand
	 * @param {Vec4} b the second operand
	 * @param {Number} scale the amount to scale b by before adding
	 * @returns {Vec4} out
	 * @param {Vec4} out the receiving vector
	 * @method module:vec4.scaleAndAdd
	 */
	vec4.scaleAndAdd = function(a, b, scale, out) {
	    out[0] = a[0] + (b[0] * scale);
	    out[1] = a[1] + (b[1] * scale);
	    out[2] = a[2] + (b[2] * scale);
	    out[3] = a[3] + (b[3] * scale);
	    return out;
	};

	/**
	 * Calculates the euclidian distance between two vec4's
	 *
	 * @param {Vec4} a the first operand
	 * @param {Vec4} b the second operand
	 * @returns {Number} distance between a and b
	 * @method module:vec4.distance
	 */
	vec4.distance = function(a, b) {
	    var x = b[0] - a[0],
	        y = b[1] - a[1],
	        z = b[2] - a[2],
	        w = b[3] - a[3];
	    return Math.sqrt(x*x + y*y + z*z + w*w);
	};

	/**
	 * Alias for {@link vec4.distance}
	 * @function
	 * @method module:vec4.dist
	 */
	vec4.dist = vec4.distance;

	/**
	 * Calculates the squared euclidian distance between two vec4's
	 *
	 * @param {Vec4} a the first operand
	 * @param {Vec4} b the second operand
	 * @returns {Number} squared distance between a and b
	 * @method module:vec4.squaredDistance
	 */
	vec4.squaredDistance = function(a, b) {
	    var x = b[0] - a[0],
	        y = b[1] - a[1],
	        z = b[2] - a[2],
	        w = b[3] - a[3];
	    return x*x + y*y + z*z + w*w;
	};

	/**
	 * Alias for {@link vec4.squaredDistance}
	 * @function
	 * @method module:vec4.sqrDist
	 */
	vec4.sqrDist = vec4.squaredDistance;

	/**
	 * Calculates the length of a vec4
	 *
	 * @param {Vec4} a vector to calculate length of
	 * @returns {Number} length of a
	 * @method module:vec4.length
	 */
	vec4.length = function (a) {
	    var x = a[0],
	        y = a[1],
	        z = a[2],
	        w = a[3];
	    return Math.sqrt(x*x + y*y + z*z + w*w);
	};

	/**
	 * Alias for {@link vec4.length}
	 * @function
	 * @method module:vec4.len
	 */
	vec4.len = vec4.length;

	/**
	 * Calculates the squared length of a vec4
	 *
	 * @param {Vec4} a vector to calculate squared length of
	 * @returns {Number} squared length of a
	 * @method module:vec4.squaredLength
	 */
	vec4.squaredLength = function (a) {
	    var x = a[0],
	        y = a[1],
	        z = a[2],
	        w = a[3];
	    return x*x + y*y + z*z + w*w;
	};

	/**
	 * Alias for {@link vec4.squaredLength}
	 * @function
	 * @method module:vec4.sqrLen
	 */
	vec4.sqrLen = vec4.squaredLength;

	/**
	 * Negates the components of a vec4
	 *
	 * @param {Vec4} a vector to negate
	 * @returns {Vec4} out
	 * @param {Vec4} out the receiving vector
	 * @method module:vec4.negate
	 */
	vec4.negate = function(a, out) {
	    out[0] = -a[0];
	    out[1] = -a[1];
	    out[2] = -a[2];
	    out[3] = -a[3];
	    return out;
	};

	/**
	 * Returns the inverse of the components of a vec4
	 *
	 * @param {Vec4} a vector to invert
	 * @returns {Vec4} out
	 * @param {Vec4} out the receiving vector
	 * @method module:vec4.inverse
	 */
	vec4.inverse = function(a, out) {
	  out[0] = 1.0 / a[0];
	  out[1] = 1.0 / a[1];
	  out[2] = 1.0 / a[2];
	  out[3] = 1.0 / a[3];
	  return out;
	};

	/**
	 * Normalize a vec4
	 *
	 * @param {Vec4} a vector to normalize
	 * @returns {Vec4} out
	 * @param {Vec4} out the receiving vector
	 * @method module:vec4.normalize
	 */
	vec4.normalize = function(a, out) {
	    var x = a[0],
	        y = a[1],
	        z = a[2],
	        w = a[3];
	    var len = x*x + y*y + z*z + w*w;
	    if (len > 0) {
	        len = 1 / Math.sqrt(len);
	        out[0] = x * len;
	        out[1] = y * len;
	        out[2] = z * len;
	        out[3] = w * len;
	    }
	    return out;
	};

	/**
	 * Calculates the dot product of two vec4's
	 *
	 * @param {Vec4} a the first operand
	 * @param {Vec4} b the second operand
	 * @returns {Number} dot product of a and b
	 * @method module:vec4.dot
	 */
	vec4.dot = function (a, b) {
	    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
	};

	/**
	 * Performs a linear interpolation between two vec4's
	 *
	 * @param {Vec4} a the first operand
	 * @param {Vec4} b the second operand
	 * @param {Number} t interpolation amount between the two inputs
	 * @returns {Vec4} out
	 * @param {Vec4} out the receiving vector
	 * @method module:vec4.lerp
	 */
	vec4.lerp = function (a, b, t, out) {
	    var ax = a[0],
	        ay = a[1],
	        az = a[2],
	        aw = a[3];
	    out[0] = ax + t * (b[0] - ax);
	    out[1] = ay + t * (b[1] - ay);
	    out[2] = az + t * (b[2] - az);
	    out[3] = aw + t * (b[3] - aw);
	    return out;
	};

	/**
	 * Generates a random vector with the given scale
	 *
	 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
	 * @returns {Vec4} out
	 * @param {Vec4} out the receiving vector
	 * @method module:vec4.random
	 */
	vec4.random = function (scale, out) {
	    scale = scale || 1.0;

	    //TODO: This is a pretty awful way of doing exports. Find something better.
	    out[0] = GLMAT_RANDOM();
	    out[1] = GLMAT_RANDOM();
	    out[2] = GLMAT_RANDOM();
	    out[3] = GLMAT_RANDOM();
	    vec4.normalize(out, out);
	    vec4.scale(out, scale, out);
	    return out;
	};

	/**
	 * Transforms the vec4 with a mat4.
	 *
	 * @param {Vec4} a the vector to transform
	 * @param {Mat4} m matrix to transform with
	 * @returns {Vec4} out
	 * @param {Vec4} out the receiving vector
	 * @method module:vec4.transformMat4
	 */
	vec4.transformMat4 = function(a, m, out) {
	    var x = a[0], y = a[1], z = a[2], w = a[3];
	    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
	    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
	    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
	    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
	    return out;
	};

	/**
	 * Transforms the vec4 with a quat
	 *
	 * @param {Vec4} a the vector to transform
	 * @param {Quat} q quaternion to transform with
	 * @returns {Vec4} out
	 * @param {Vec4} out the receiving vector
	 * @method module:vec4.transformQuat
	 */
	vec4.transformQuat = function(a, q, out) {
	    var x = a[0], y = a[1], z = a[2],
	        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

	        // calculate quat * vec
	        ix = qw * x + qy * z - qz * y,
	        iy = qw * y + qz * x - qx * z,
	        iz = qw * z + qx * y - qy * x,
	        iw = -qx * x - qy * y - qz * z;

	    // calculate result * inverse quat
	    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
	    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
	    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
	    out[3] = a[3];
	    return out;
	};

	/**
	 * Perform some operation over an array of vec4s.
	 *
	 * @param {Array} a the array of vectors to iterate over
	 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
	 * @param {Number} offset Number of elements to skip at the beginning of the array
	 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
	 * @param {Function} fn Function to call for each vector in the array
	 * @param {Object} [arg] additional argument to pass to fn
	 * @returns {Array} a
	 * @function
	 * @method module:vec4.forEach
	 */
	vec4.forEach = (function() {
	    var vec = vec4.create();

	    return function(a, stride, offset, count, fn, arg) {
	        var i, l;
	        if(!stride) {
	            stride = 4;
	        }

	        if(!offset) {
	            offset = 0;
	        }
	        
	        if(count) {
	            l = Math.min((count * stride) + offset, a.length);
	        } else {
	            l = a.length;
	        }

	        for(i = offset; i < l; i += stride) {
	            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2]; vec[3] = a[i+3];
	            fn(vec, arg, vec);
	            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2]; a[i+3] = vec[3];
	        }
	        
	        return a;
	    };
	})();

	/**
	 * Returns a string representation of a vector
	 *
	 * @param {Vec4} vec vector to represent as a string
	 * @returns {String} string representation of the vector
	 * @method module:vec4.str
	 */
	vec4.str = function (a) {
	    return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
	};

	}

	var vec4_factory = register("vec4", Vec4);
	register("__vec4", Vec4);

	"use strict";

	/**
	 * @module 3x3 Matrix
	 * @name mat3
	 */
	function Mat3(ns, exports) {

	var GLMAT_ARRAY_TYPE = (typeof Float32Array !== 'undefined') ? Float32Array : Array;
	var mat3 = exports;

	/**
	 * Creates a new identity mat3
	 *
	 * @returns {Mat3} a new 3x3 matrix
	 * @method module:mat3.create
	 */
	mat3.create = function() {
	    var out = new GLMAT_ARRAY_TYPE(9);
	    out[0] = 1;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = 1;
	    out[5] = 0;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = 1;
	    return out;
	};

	/**
	 * Copies the upper-left 3x3 values into the given mat3.
	 *
	 * @param {Mat4} a   the source 4x4 matrix
	 * @returns {Mat3} out
	 * @param {Mat3} out the receiving 3x3 matrix
	 * @method module:mat3.fromMat4
	 */
	mat3.fromMat4 = function(a, out) {
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = a[2];
	    out[3] = a[4];
	    out[4] = a[5];
	    out[5] = a[6];
	    out[6] = a[8];
	    out[7] = a[9];
	    out[8] = a[10];
	    return out;
	};

	/**
	 * Creates a new mat3 initialized with values from an existing matrix
	 *
	 * @param {Mat3} a matrix to clone
	 * @returns {Mat3} a new 3x3 matrix
	 * @method module:mat3.clone
	 */
	mat3.clone = function(a) {
	    var out = new GLMAT_ARRAY_TYPE(9);
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = a[2];
	    out[3] = a[3];
	    out[4] = a[4];
	    out[5] = a[5];
	    out[6] = a[6];
	    out[7] = a[7];
	    out[8] = a[8];
	    return out;
	};

	/**
	 * Copy the values from one mat3 to another
	 *
	 * @param {Mat3} a the source matrix
	 * @returns {Mat3} out
	 * @param {Mat3} out the receiving matrix
	 * @method module:mat3.copy
	 */
	mat3.copy = function(a, out) {
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = a[2];
	    out[3] = a[3];
	    out[4] = a[4];
	    out[5] = a[5];
	    out[6] = a[6];
	    out[7] = a[7];
	    out[8] = a[8];
	    return out;
	};

	/**
	 * Set a mat3 to the identity matrix
	 *
	 * @returns {Mat3} out
	 * @param {Mat3} out the receiving matrix
	 * @method module:mat3.identity
	 */
	mat3.identity = function(out) {
	    out[0] = 1;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = 1;
	    out[5] = 0;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = 1;
	    return out;
	};

	/**
	 * Transpose the values of a mat3
	 *
	 * @param {Mat3} a the source matrix
	 * @returns {Mat3} out
	 * @param {Mat3} out the receiving matrix
	 * @method module:mat3.transpose
	 */
	mat3.transpose = function(a, out) {
	    // If we are transposing ourselves we can skip a few steps but have to cache some values
	    if (out === a) {
	        var a01 = a[1], a02 = a[2], a12 = a[5];
	        out[1] = a[3];
	        out[2] = a[6];
	        out[3] = a01;
	        out[5] = a[7];
	        out[6] = a02;
	        out[7] = a12;
	    } else {
	        out[0] = a[0];
	        out[1] = a[3];
	        out[2] = a[6];
	        out[3] = a[1];
	        out[4] = a[4];
	        out[5] = a[7];
	        out[6] = a[2];
	        out[7] = a[5];
	        out[8] = a[8];
	    }
	    
	    return out;
	};

	/**
	 * Inverts a mat3
	 *
	 * @param {Mat3} a the source matrix
	 * @returns {Mat3} out
	 * @param {Mat3} out the receiving matrix
	 * @method module:mat3.invert
	 */
	mat3.invert = function(a, out) {
	    var a00 = a[0], a01 = a[1], a02 = a[2],
	        a10 = a[3], a11 = a[4], a12 = a[5],
	        a20 = a[6], a21 = a[7], a22 = a[8],

	        b01 = a22 * a11 - a12 * a21,
	        b11 = -a22 * a10 + a12 * a20,
	        b21 = a21 * a10 - a11 * a20,

	        // Calculate the determinant
	        det = a00 * b01 + a01 * b11 + a02 * b21;

	    if (!det) { 
	        return null; 
	    }
	    det = 1.0 / det;

	    out[0] = b01 * det;
	    out[1] = (-a22 * a01 + a02 * a21) * det;
	    out[2] = (a12 * a01 - a02 * a11) * det;
	    out[3] = b11 * det;
	    out[4] = (a22 * a00 - a02 * a20) * det;
	    out[5] = (-a12 * a00 + a02 * a10) * det;
	    out[6] = b21 * det;
	    out[7] = (-a21 * a00 + a01 * a20) * det;
	    out[8] = (a11 * a00 - a01 * a10) * det;
	    return out;
	};

	/**
	 * Calculates the adjugate of a mat3
	 *
	 * @param {Mat3} a the source matrix
	 * @returns {Mat3} out
	 * @param {Mat3} out the receiving matrix
	 * @method module:mat3.adjoint
	 */
	mat3.adjoint = function(a, out) {
	    var a00 = a[0], a01 = a[1], a02 = a[2],
	        a10 = a[3], a11 = a[4], a12 = a[5],
	        a20 = a[6], a21 = a[7], a22 = a[8];

	    out[0] = (a11 * a22 - a12 * a21);
	    out[1] = (a02 * a21 - a01 * a22);
	    out[2] = (a01 * a12 - a02 * a11);
	    out[3] = (a12 * a20 - a10 * a22);
	    out[4] = (a00 * a22 - a02 * a20);
	    out[5] = (a02 * a10 - a00 * a12);
	    out[6] = (a10 * a21 - a11 * a20);
	    out[7] = (a01 * a20 - a00 * a21);
	    out[8] = (a00 * a11 - a01 * a10);
	    return out;
	};

	/**
	 * Calculates the determinant of a mat3
	 *
	 * @param {Mat3} a the source matrix
	 * @returns {Number} determinant of a
	 * @method module:mat3.determinant
	 */
	mat3.determinant = function (a) {
	    var a00 = a[0], a01 = a[1], a02 = a[2],
	        a10 = a[3], a11 = a[4], a12 = a[5],
	        a20 = a[6], a21 = a[7], a22 = a[8];

	    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
	};

	/**
	 * Multiplies two mat3's
	 *
	 * @param {Mat3} a the first operand
	 * @param {Mat3} b the second operand
	 * @returns {Mat3} out
	 * @param {Mat3} out the receiving matrix
	 * @method module:mat3.multiply
	 */
	mat3.multiply = function (a, b, out) {
	    var a00 = a[0], a01 = a[1], a02 = a[2],
	        a10 = a[3], a11 = a[4], a12 = a[5],
	        a20 = a[6], a21 = a[7], a22 = a[8],

	        b00 = b[0], b01 = b[1], b02 = b[2],
	        b10 = b[3], b11 = b[4], b12 = b[5],
	        b20 = b[6], b21 = b[7], b22 = b[8];

	    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
	    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
	    out[2] = b00 * a02 + b01 * a12 + b02 * a22;

	    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
	    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
	    out[5] = b10 * a02 + b11 * a12 + b12 * a22;

	    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
	    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
	    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
	    return out;
	};

	/**
	 * Alias for {@link mat3.multiply}
	 * @function
	 * @method module:mat3.mul
	 */
	mat3.mul = mat3.multiply;

	/**
	 * Translate a mat3 by the given vector
	 *
	 * @param {Mat3} a the matrix to translate
	 * @param {vec2} v vector to translate by
	 * @returns {Mat3} out
	 * @param {Mat3} out the receiving matrix
	 * @method module:mat3.translate
	 */
	mat3.translate = function(a, v, out) {
	    var a00 = a[0], a01 = a[1], a02 = a[2],
	        a10 = a[3], a11 = a[4], a12 = a[5],
	        a20 = a[6], a21 = a[7], a22 = a[8],
	        x = v[0], y = v[1];

	    out[0] = a00;
	    out[1] = a01;
	    out[2] = a02;

	    out[3] = a10;
	    out[4] = a11;
	    out[5] = a12;

	    out[6] = x * a00 + y * a10 + a20;
	    out[7] = x * a01 + y * a11 + a21;
	    out[8] = x * a02 + y * a12 + a22;
	    return out;
	};

	/**
	 * Rotates a mat3 by the given angle
	 *
	 * @param {Mat3} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {Mat3} out
	 * @param {Mat3} out the receiving matrix
	 * @method module:mat3.rotate
	 */
	mat3.rotate = function (a, rad, out) {
	    var a00 = a[0], a01 = a[1], a02 = a[2],
	        a10 = a[3], a11 = a[4], a12 = a[5],
	        a20 = a[6], a21 = a[7], a22 = a[8],

	        s = Math.sin(rad),
	        c = Math.cos(rad);

	    out[0] = c * a00 + s * a10;
	    out[1] = c * a01 + s * a11;
	    out[2] = c * a02 + s * a12;

	    out[3] = c * a10 - s * a00;
	    out[4] = c * a11 - s * a01;
	    out[5] = c * a12 - s * a02;

	    out[6] = a20;
	    out[7] = a21;
	    out[8] = a22;
	    return out;
	};

	/**
	 * Scales the mat3 by the dimensions in the given vec2
	 *
	 * @param {Mat3} a the matrix to rotate
	 * @param {vec2} v the vec2 to scale the matrix by
	 * @returns {Mat3} out
	 * @param {Mat3} out the receiving matrix
	 * @method module:mat3.scale
	 */
	mat3.scale = function(a, v, out) {
	    var x = v[0], y = v[1];

	    out[0] = x * a[0];
	    out[1] = x * a[1];
	    out[2] = x * a[2];

	    out[3] = y * a[3];
	    out[4] = y * a[4];
	    out[5] = y * a[5];

	    out[6] = a[6];
	    out[7] = a[7];
	    out[8] = a[8];
	    return out;
	};

	/**
	 * Creates a matrix from a vector translation
	 * This is equivalent to (but much faster than):
	 *
	 *     mat3.identity(dest);
	 *     mat3.translate(dest, dest, vec);
	 *
	 * @param {vec2} v Translation vector
	 * @returns {Mat3} out
	 * @param {Mat3} out mat3 receiving operation result
	 * @method module:mat3.fromTranslation
	 */
	mat3.fromTranslation = function(v, out) {
	    out[0] = 1;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = 1;
	    out[5] = 0;
	    out[6] = v[0];
	    out[7] = v[1];
	    out[8] = 1;
	    return out;
	};

	/**
	 * Creates a matrix from a given angle
	 * This is equivalent to (but much faster than):
	 *
	 *     mat3.identity(dest);
	 *     mat3.rotate(dest, dest, rad);
	 *
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {Mat3} out
	 * @param {Mat3} out mat3 receiving operation result
	 * @method module:mat3.fromRotation
	 */
	mat3.fromRotation = function(rad, out) {
	    var s = Math.sin(rad), c = Math.cos(rad);

	    out[0] = c;
	    out[1] = s;
	    out[2] = 0;

	    out[3] = -s;
	    out[4] = c;
	    out[5] = 0;

	    out[6] = 0;
	    out[7] = 0;
	    out[8] = 1;
	    return out;
	};

	/**
	 * Creates a matrix from a vector scaling
	 * This is equivalent to (but much faster than):
	 *
	 *     mat3.identity(dest);
	 *     mat3.scale(dest, dest, vec);
	 *
	 * @param {vec2} v Scaling vector
	 * @returns {Mat3} out
	 * @param {Mat3} out mat3 receiving operation result
	 * @method module:mat3.fromScaling
	 */
	mat3.fromScaling = function(v, out) {
	    out[0] = v[0];
	    out[1] = 0;
	    out[2] = 0;

	    out[3] = 0;
	    out[4] = v[1];
	    out[5] = 0;

	    out[6] = 0;
	    out[7] = 0;
	    out[8] = 1;
	    return out;
	};

	/**
	 * Copies the values from a mat2d into a mat3
	 *
	 * @param {mat2d} a the matrix to copy
	 * @returns {Mat3} out
	 * @param {Mat3} out the receiving matrix
	 * @method module:mat3.fromMat2d
	 */
	mat3.fromMat2d = function(a, out) {
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = 0;

	    out[3] = a[2];
	    out[4] = a[3];
	    out[5] = 0;

	    out[6] = a[4];
	    out[7] = a[5];
	    out[8] = 1;
	    return out;
	};

	/**
	* Calculates a 3x3 matrix from the given quaternion
	*
	* @param {Quat} q Quaternion to create matrix from
	*
	* @returns {Mat3} out
	* @param {Mat3} out mat3 receiving operation result
	  * @method module:mat3.fromQuat
	  */
	mat3.fromQuat = function (q, out) {
	    var x = q[0], y = q[1], z = q[2], w = q[3],
	        x2 = x + x,
	        y2 = y + y,
	        z2 = z + z,

	        xx = x * x2,
	        yx = y * x2,
	        yy = y * y2,
	        zx = z * x2,
	        zy = z * y2,
	        zz = z * z2,
	        wx = w * x2,
	        wy = w * y2,
	        wz = w * z2;

	    out[0] = 1 - yy - zz;
	    out[3] = yx - wz;
	    out[6] = zx + wy;

	    out[1] = yx + wz;
	    out[4] = 1 - xx - zz;
	    out[7] = zy - wx;

	    out[2] = zx - wy;
	    out[5] = zy + wx;
	    out[8] = 1 - xx - yy;

	    return out;
	};

	/**
	* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
	*
	* @param {Mat4} a Mat4 to derive the normal matrix from
	*
	* @returns {Mat3} out
	* @param {Mat3} out mat3 receiving operation result
	  * @method module:mat3.normalFromMat4
	  */
	mat3.normalFromMat4 = function (a, out) {
	    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
	        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
	        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
	        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

	        b00 = a00 * a11 - a01 * a10,
	        b01 = a00 * a12 - a02 * a10,
	        b02 = a00 * a13 - a03 * a10,
	        b03 = a01 * a12 - a02 * a11,
	        b04 = a01 * a13 - a03 * a11,
	        b05 = a02 * a13 - a03 * a12,
	        b06 = a20 * a31 - a21 * a30,
	        b07 = a20 * a32 - a22 * a30,
	        b08 = a20 * a33 - a23 * a30,
	        b09 = a21 * a32 - a22 * a31,
	        b10 = a21 * a33 - a23 * a31,
	        b11 = a22 * a33 - a23 * a32,

	        // Calculate the determinant
	        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

	    if (!det) { 
	        return null; 
	    }
	    det = 1.0 / det;

	    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
	    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
	    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;

	    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
	    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
	    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;

	    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
	    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
	    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;

	    return out;
	};

	/**
	 * Returns a string representation of a mat3
	 *
	 * @param {Mat3} mat matrix to represent as a string
	 * @returns {String} string representation of the matrix
	 * @method module:mat3.str
	 */
	mat3.str = function (a) {
	    return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + 
	                    a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + 
	                    a[6] + ', ' + a[7] + ', ' + a[8] + ')';
	};

	/**
	 * Returns Frobenius norm of a mat3
	 *
	 * @param {Mat3} a the matrix to calculate Frobenius norm of
	 * @returns {Number} Frobenius norm
	 * @method module:mat3.frob
	 */
	mat3.frob = function (a) {
	    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2)))
	};


	}

	var mat3_factory = register("mat3", Mat3);
	register("__mat3", Mat3);

	"use strict";

	/**
	 * @module Quaternion
	 * @name quat
	 */
	function Quat(ns, exports) {

	var vec3 = vec3_factory(ns);
	var vec4 = vec4_factory(ns);
	var mat3 = mat3_factory(ns);

	var GLMAT_ARRAY_TYPE = (typeof Float32Array !== 'undefined') ? Float32Array : Array;
	var quat = exports;

	/**
	 * Creates a new identity quat
	 *
	 * @returns {Quat} a new quaternion
	 * @method module:quat.create
	 */
	quat.create = function() {
	    var out = new GLMAT_ARRAY_TYPE(4);
	    out[0] = 0;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 1;
	    return out;
	};

	/**
	 * Sets a quaternion to represent the shortest rotation from one
	 * vector to another.
	 *
	 * Both vectors are assumed to be unit length.
	 *
	 * @param {Vec3} a the initial vector
	 * @param {Vec3} b the destination vector
	 * @returns {Quat} out
	 * @param {Quat} out the receiving quaternion.
	 * @method module:quat.rotationTo
	 */
	quat.rotationTo = (function() {
	    var tmpvec3 = vec3.create();
	    var xUnitVec3 = vec3.fromValues(1,0,0);
	    var yUnitVec3 = vec3.fromValues(0,1,0);

	    return function(a, b, out) {
	        var dot = vec3.dot(a, b);
	        if (dot < -0.9999999) {
	            vec3.cross(xUnitVec3, a, tmpvec3); /* NOTE: CUSTOM REORDER: (tmpvec3, xUnitVec3, a)->(xUnitVec3, a ,tmpvec3) */
	            if (vec3.length(tmpvec3) < 0.000001)
	                vec3.cross(yUnitVec3, a, tmpvec3); /* NOTE: CUSTOM REORDER: (tmpvec3, yUnitVec3, a)->(yUnitVec3, a ,tmpvec3) */
	            vec3.normalize(tmpvec3, tmpvec3);
	            quat.setAxisAngle(tmpvec3, Math.PI, out); /* NOTE: CUSTOM REORDER: (out, tmpvec3, Math.PI)->(tmpvec3, Math.PI ,out)*/
	            return out;
	        } else if (dot > 0.9999999) {
	            out[0] = 0;
	            out[1] = 0;
	            out[2] = 0;
	            out[3] = 1;
	            return out;
	        } else {
	            vec3.cross(a, b, tmpvec3); /* NOTE: CUSTOM REORDER: (tmpvec3, a, b)->(a, b ,tmpvec3) */
	            out[0] = tmpvec3[0];
	            out[1] = tmpvec3[1];
	            out[2] = tmpvec3[2];
	            out[3] = 1 + dot;
	            return quat.normalize(out, out);
	        }
	    };
	})();

	/**
	 * Sets the specified quaternion with values corresponding to the given
	 * axes. Each axis is a vec3 and is expected to be unit length and
	 * perpendicular to all other specified axes.
	 *
	 * @param {Vec3} view  the vector representing the viewing direction
	 * @param {Vec3} right the vector representing the local "right" direction
	 * @param {Vec3} up    the vector representing the local "up" direction
	 * @returns {Quat} out
	 * @method module:quat.setAxes
	 */
	quat.setAxes = (function() {
	    var matr = mat3.create();

	    return function(view, right, up, out) {
	        matr[0] = right[0];
	        matr[3] = right[1];
	        matr[6] = right[2];

	        matr[1] = up[0];
	        matr[4] = up[1];
	        matr[7] = up[2];

	        matr[2] = -view[0];
	        matr[5] = -view[1];
	        matr[8] = -view[2];

	        return quat.normalize(quat.fromMat3(matr, out), out); /* NOTE: DOUBLE CUSTOM REORDER */
	    };
	})();

	/**
	 * Creates a new quat initialized with values from an existing quaternion
	 *
	 * @param {Quat} a quaternion to clone
	 * @returns {Quat} a new quaternion
	 * @function
	 * @method module:quat.clone
	 */
	quat.clone = vec4.clone;

	/**
	 * Creates a new quat initialized with the given values
	 *
	 * @param {Number} x X component
	 * @param {Number} y Y component
	 * @param {Number} z Z component
	 * @param {Number} w W component
	 * @returns {Quat} a new quaternion
	 * @function
	 * @method module:quat.fromValues
	 */
	quat.fromValues = vec4.fromValues;

	/**
	 * Copy the values from one quat to another
	 *
	 * @param {Quat} a the source quaternion
	 * @returns {Quat} out
	 * @function
	 * @param {Quat} out the receiving quaternion
	 * @method module:quat.copy
	 */
	quat.copy = vec4.copy;

	/**
	 * Set the components of a quat to the given values
	 *
	 * @param {Number} x X component
	 * @param {Number} y Y component
	 * @param {Number} z Z component
	 * @param {Number} w W component
	 * @returns {Quat} out
	 * @function
	 * @param {Quat} out the receiving quaternion
	 * @method module:quat.set
	 */
	quat.set = vec4.set;

	/**
	 * Set a quat to the identity quaternion
	 *
	 * @returns {Quat} out
	 * @param {Quat} out the receiving quaternion
	 * @method module:quat.identity
	 */
	quat.identity = function(out) {
	    out[0] = 0;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 1;
	    return out;
	};

	/**
	 * Sets a quat from the given angle and rotation axis,
	 * then returns it.
	 *
	 * @param {Vec3} axis the axis around which to rotate
	 * @param {Number} rad the angle in radians
	 * @returns {Quat} out
	 * @param {Quat} out the receiving quaternion
	 * @method module:quat.setAxisAngle
	 */
	quat.setAxisAngle = function(axis, rad, out) {
	    rad = rad * 0.5;
	    var s = Math.sin(rad);
	    out[0] = s * axis[0];
	    out[1] = s * axis[1];
	    out[2] = s * axis[2];
	    out[3] = Math.cos(rad);
	    return out;
	};

	/**
	 * Adds two quat's
	 *
	 * @param {Quat} a the first operand
	 * @param {Quat} b the second operand
	 * @returns {Quat} out
	 * @function
	 * @param {Quat} out the receiving quaternion
	 * @method module:quat.add
	 */
	quat.add = vec4.add;

	/**
	 * Multiplies two quat's
	 *
	 * @param {Quat} a the first operand
	 * @param {Quat} b the second operand
	 * @returns {Quat} out
	 * @param {Quat} out the receiving quaternion
	 * @method module:quat.multiply
	 */
	quat.multiply = function(a, b, out) {
	    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
	        bx = b[0], by = b[1], bz = b[2], bw = b[3];

	    out[0] = ax * bw + aw * bx + ay * bz - az * by;
	    out[1] = ay * bw + aw * by + az * bx - ax * bz;
	    out[2] = az * bw + aw * bz + ax * by - ay * bx;
	    out[3] = aw * bw - ax * bx - ay * by - az * bz;
	    return out;
	};

	/**
	 * Alias for {@link quat.multiply}
	 * @function
	 * @method module:quat.mul
	 */
	quat.mul = quat.multiply;

	/**
	 * Scales a quat by a scalar number
	 *
	 * @param {Quat} a the vector to scale
	 * @param {Number} b amount to scale the vector by
	 * @returns {Quat} out
	 * @function
	 * @param {Quat} out the receiving vector
	 * @method module:quat.scale
	 */
	quat.scale = vec4.scale;

	/**
	 * Rotates a quaternion by the given angle about the X axis
	 *
	 * @param {Quat} a quat to rotate
	 * @param {number} rad angle (in radians) to rotate
	 * @returns {Quat} out
	 * @param {Quat} out quat receiving operation result
	 * @method module:quat.rotateX
	 */
	quat.rotateX = function (a, rad, out) {
	    rad *= 0.5; 

	    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
	        bx = Math.sin(rad), bw = Math.cos(rad);

	    out[0] = ax * bw + aw * bx;
	    out[1] = ay * bw + az * bx;
	    out[2] = az * bw - ay * bx;
	    out[3] = aw * bw - ax * bx;
	    return out;
	};

	/**
	 * Rotates a quaternion by the given angle about the Y axis
	 *
	 * @param {Quat} a quat to rotate
	 * @param {number} rad angle (in radians) to rotate
	 * @returns {Quat} out
	 * @param {Quat} out quat receiving operation result
	 * @method module:quat.rotateY
	 */
	quat.rotateY = function (a, rad, out) {
	    rad *= 0.5; 

	    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
	        by = Math.sin(rad), bw = Math.cos(rad);

	    out[0] = ax * bw - az * by;
	    out[1] = ay * bw + aw * by;
	    out[2] = az * bw + ax * by;
	    out[3] = aw * bw - ay * by;
	    return out;
	};

	/**
	 * Rotates a quaternion by the given angle about the Z axis
	 *
	 * @param {Quat} a quat to rotate
	 * @param {number} rad angle (in radians) to rotate
	 * @returns {Quat} out
	 * @param {Quat} out quat receiving operation result
	 * @method module:quat.rotateZ
	 */
	quat.rotateZ = function (a, rad, out) {
	    rad *= 0.5; 

	    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
	        bz = Math.sin(rad), bw = Math.cos(rad);

	    out[0] = ax * bw + ay * bz;
	    out[1] = ay * bw - ax * bz;
	    out[2] = az * bw + aw * bz;
	    out[3] = aw * bw - az * bz;
	    return out;
	};

	/**
	 * Calculates the W component of a quat from the X, Y, and Z components.
	 * Assumes that quaternion is 1 unit in length.
	 * Any existing W component will be ignored.
	 *
	 * @param {Quat} a quat to calculate W component of
	 * @returns {Quat} out
	 * @param {Quat} out the receiving quaternion
	 * @method module:quat.calculateW
	 */
	quat.calculateW = function (a, out) {
	    var x = a[0], y = a[1], z = a[2];

	    out[0] = x;
	    out[1] = y;
	    out[2] = z;
	    out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
	    return out;
	};

	/**
	 * Calculates the dot product of two quat's
	 *
	 * @param {Quat} a the first operand
	 * @param {Quat} b the second operand
	 * @returns {Number} dot product of a and b
	 * @function
	 * @method module:quat.dot
	 */
	quat.dot = vec4.dot;

	/**
	 * Performs a linear interpolation between two quat's
	 *
	 * @param {Quat} a the first operand
	 * @param {Quat} b the second operand
	 * @param {Number} t interpolation amount between the two inputs
	 * @returns {Quat} out
	 * @function
	 * @param {Quat} out the receiving quaternion
	 * @method module:quat.lerp
	 */
	quat.lerp = vec4.lerp;

	/**
	 * Performs a spherical linear interpolation between two quat
	 *
	 * @param {Quat} a the first operand
	 * @param {Quat} b the second operand
	 * @param {Number} t interpolation amount between the two inputs
	 * @returns {Quat} out
	 * @param {Quat} out the receiving quaternion
	 * @method module:quat.slerp
	 */
	quat.slerp = function (a, b, t, out) {
	    // benchmarks:
	    //    http://jsperf.com/quaternion-slerp-implementations

	    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
	        bx = b[0], by = b[1], bz = b[2], bw = b[3];

	    var        omega, cosom, sinom, scale0, scale1;

	    // calc cosine
	    cosom = ax * bx + ay * by + az * bz + aw * bw;
	    // adjust signs (if necessary)
	    if ( cosom < 0.0 ) {
	        cosom = -cosom;
	        bx = - bx;
	        by = - by;
	        bz = - bz;
	        bw = - bw;
	    }
	    // calculate coefficients
	    if ( (1.0 - cosom) > 0.000001 ) {
	        // standard case (slerp)
	        omega  = Math.acos(cosom);
	        sinom  = Math.sin(omega);
	        scale0 = Math.sin((1.0 - t) * omega) / sinom;
	        scale1 = Math.sin(t * omega) / sinom;
	    } else {        
	        // "from" and "to" quaternions are very close 
	        //  ... so we can do a linear interpolation
	        scale0 = 1.0 - t;
	        scale1 = t;
	    }
	    // calculate final values
	    out[0] = scale0 * ax + scale1 * bx;
	    out[1] = scale0 * ay + scale1 * by;
	    out[2] = scale0 * az + scale1 * bz;
	    out[3] = scale0 * aw + scale1 * bw;
	    
	    return out;
	};

	/**
	 * Performs a spherical linear interpolation with two control points
	 *
	 * @param {Quat} a the first operand
	 * @param {Quat} b the second operand
	 * @param {Quat} c the third operand
	 * @param {Quat} d the fourth operand
	 * @param {Number} t interpolation amount
	 * @returns {Quat} out
	 * @param {Quat} out the receiving quaternion
	 * @method module:quat.sqlerp
	 */
	quat.sqlerp = (function () {
	  var temp1 = quat.create();
	  var temp2 = quat.create();
	  
	  return function (a, b, c, d, t, out) {
	    quat.slerp(a, d, t, temp1); /* NOTE: CUSTOM REORDER: */
	    quat.slerp(b, c, t, temp2); /* NOTE: CUSTOM REORDER: */
	    quat.slerp(temp1, temp2, 2 * t * (1 - t), out); /* NOTE: CUSTOM REORDER:*/
	    
	    return out;
	  };
	}());

	/**
	 * Calculates the inverse of a quat
	 *
	 * @param {Quat} a quat to calculate inverse of
	 * @returns {Quat} out
	 * @param {Quat} out the receiving quaternion
	 * @method module:quat.invert
	 */
	quat.invert = function(a, out) {
	    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
	        dot = a0*a0 + a1*a1 + a2*a2 + a3*a3,
	        invDot = dot ? 1.0/dot : 0;
	    
	    // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

	    out[0] = -a0*invDot;
	    out[1] = -a1*invDot;
	    out[2] = -a2*invDot;
	    out[3] = a3*invDot;
	    return out;
	};

	/**
	 * Calculates the conjugate of a quat
	 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
	 *
	 * @param {Quat} a quat to calculate conjugate of
	 * @returns {Quat} out
	 * @param {Quat} out the receiving quaternion
	 * @method module:quat.conjugate
	 */
	quat.conjugate = function (a, out) {
	    out[0] = -a[0];
	    out[1] = -a[1];
	    out[2] = -a[2];
	    out[3] = a[3];
	    return out;
	};

	/**
	 * Calculates the length of a quat
	 *
	 * @param {Quat} a vector to calculate length of
	 * @returns {Number} length of a
	 * @function
	 * @method module:quat.length
	 */
	quat.length = vec4.length;

	/**
	 * Alias for {@link quat.length}
	 * @function
	 * @method module:quat.len
	 */
	quat.len = quat.length;

	/**
	 * Calculates the squared length of a quat
	 *
	 * @param {Quat} a vector to calculate squared length of
	 * @returns {Number} squared length of a
	 * @function
	 * @method module:quat.squaredLength
	 */
	quat.squaredLength = vec4.squaredLength;

	/**
	 * Alias for {@link quat.squaredLength}
	 * @function
	 * @method module:quat.sqrLen
	 */
	quat.sqrLen = quat.squaredLength;

	/**
	 * Normalize a quat
	 *
	 * @param {Quat} a quaternion to normalize
	 * @returns {Quat} out
	 * @function
	 * @param {Quat} out the receiving quaternion
	 * @method module:quat.normalize
	 */
	quat.normalize = vec4.normalize;

	/**
	 * Creates a quaternion from the given 3x3 rotation matrix.
	 *
	 * NOTE: The resultant quaternion is not normalized, so you should be sure
	 * to renormalize the quaternion yourself where necessary.
	 *
	 * @param {Mat3} m rotation matrix
	 * @returns {Quat} out
	 * @function
	 * @param {Quat} out the receiving quaternion
	 * @method module:quat.fromMat3
	 */
	quat.fromMat3 = function(m, out) {
	    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
	    // article "Quaternion Calculus and Fast Animation".
	    var fTrace = m[0] + m[4] + m[8];
	    var fRoot;

	    if ( fTrace > 0.0 ) {
	        // |w| > 1/2, may as well choose w > 1/2
	        fRoot = Math.sqrt(fTrace + 1.0);  // 2w
	        out[3] = 0.5 * fRoot;
	        fRoot = 0.5/fRoot;  // 1/(4w)
	        out[0] = (m[5]-m[7])*fRoot;
	        out[1] = (m[6]-m[2])*fRoot;
	        out[2] = (m[1]-m[3])*fRoot;
	    } else {
	        // |w| <= 1/2
	        var i = 0;
	        if ( m[4] > m[0] )
	          i = 1;
	        if ( m[8] > m[i*3+i] )
	          i = 2;
	        var j = (i+1)%3;
	        var k = (i+2)%3;
	        
	        fRoot = Math.sqrt(m[i*3+i]-m[j*3+j]-m[k*3+k] + 1.0);
	        out[i] = 0.5 * fRoot;
	        fRoot = 0.5 / fRoot;
	        out[3] = (m[j*3+k] - m[k*3+j]) * fRoot;
	        out[j] = (m[j*3+i] + m[i*3+j]) * fRoot;
	        out[k] = (m[k*3+i] + m[i*3+k]) * fRoot;
	    }
	    
	    return out;
	};

	/**
	 * Returns a string representation of a quatenion
	 *
	 * @param {Quat} vec vector to represent as a string
	 * @returns {String} string representation of the vector
	 * @method module:quat.str
	 */
	quat.str = function (a) {
	    return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
	};

	}


	var quat_factory = register("quat", Quat);
	register("__quat", Quat);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/* ============================================================
	 * jQuery Easing v1.3 - http://gsgd.co.uk/sandbox/jquery/easing/
	 *
	 * Open source under the BSD License.
	 *
	 * Copyright © 2008 George McGinley Smith
	 * All rights reserved.
	 * https://raw.github.com/danro/jquery-easing/master/LICENSE
	 * ======================================================== */

	/**
	 * Math internal functions.
	 * @name math
	 * @namespace
	 * @exports exports as math
	 */
	function Int_math(ns, exports) {

	var m_mat3 = mat3_factory(ns);
	var m_vec3 = vec3_factory(ns);

	var _vec3_tmp = new Float32Array(3);
	var _mat3_tmp = new Float32Array(9);
	var _mat3_tmp2 = new Float32Array(9);
	var _mat3_tmp3 = new Float32Array(9);
	var _mat3_tmp4 = new Float32Array(9);

	var MAX_ITER_NUM = 100;

	exports.get_pline_directional_vec = function(pline, dest) {
	    dest = dest || new Float32Array(3);
	    dest[0] = pline[3];
	    dest[1] = pline[4];
	    dest[2] = pline[5];
	    return dest;
	};

	exports.get_pline_initial_point = function(pline, dest) {
	    dest = dest || new Float32Array(3);
	    return m_vec3.copy(pline, dest);
	};

	exports.set_pline_initial_point = function(pline, point) {
	    m_vec3.copy(point, pline);
	};

	exports.set_pline_directional_vec = function(pline, vec) {
	    m_vec3.normalize(vec, _vec3_tmp);
	    pline[3] = _vec3_tmp[0];
	    pline[4] = _vec3_tmp[1];
	    pline[5] = _vec3_tmp[2];
	};

	exports.calc_pline_point = function(pline, t, dest) {
	    dest = dest || new Float32Array(3);
	    dest[0] = pline[0] + pline[3] * t;
	    dest[1] = pline[1] + pline[4] * t;
	    dest[2] = pline[2] + pline[5] * t;
	    return dest;
	};

	exports.calk_average_position = function(points, dest) {
	    dest[0] = 0; dest[1] = 0; dest[2] = 0;
	    for (var i = 0; i < points.length; i = i + 3) {
	        dest[0] += points[i];
	        dest[1] += points[i + 1];
	        dest[2] += points[i + 2];
	    }
	    return m_vec3.scale(dest, 3 / points.length, dest);
	};

	exports.calc_covariance_matrix = function(points, average_pos, dest) {

	    for (var i = 0; i < dest.length; i++)
	        dest[i] = 0;

	    for (var i = 0; i < points.length; i = i + 3) {
	        var xm = points[i] - average_pos[0];
	        var ym = points[i + 1] - average_pos[1];
	        var zm = points[i + 2] - average_pos[2];
	        dest[0] += xm * xm;
	        dest[1] += xm * ym;
	        dest[2] += xm * zm;
	        dest[4] += ym * ym;
	        dest[5] += ym * zm;
	        dest[8] += zm * zm;
	    }
	    dest[3] = dest[1];
	    dest[6] = dest[2];
	    dest[7] = dest[5];
	    for (var i = 0; i < dest.length; i++)
	        dest[i] *= 3 / points.length;
	    return dest;
	};

	exports.find_eigenvectors = function(m, err, dest) {

	    var matrix = m_mat3.copy(m, _mat3_tmp);

	    if (calc_canonical_mat_error(matrix) < err) {
	        return m_mat3.identity(dest);
	    }

	    var rot_matrix = find_elem_rotation_matrix(matrix, _mat3_tmp2);
	    var rot_matrix_t = m_mat3.transpose(rot_matrix, _mat3_tmp3);
	    m_mat3.multiply(matrix, rot_matrix_t, _mat3_tmp4);
	    m_mat3.multiply(rot_matrix, _mat3_tmp4, matrix);
	    var eigenvectors = m_mat3.copy(rot_matrix, dest);

	    var count = 1;
	    while (err <= calc_canonical_mat_error(matrix) && count < MAX_ITER_NUM) {
	        rot_matrix = find_elem_rotation_matrix(matrix, _mat3_tmp2);
	        rot_matrix_t = m_mat3.transpose(rot_matrix, _mat3_tmp3);
	        m_mat3.multiply(matrix, rot_matrix_t, _mat3_tmp4);
	        m_mat3.multiply(rot_matrix, _mat3_tmp4, matrix);
	        m_mat3.multiply(rot_matrix, eigenvectors, eigenvectors);
	        count++;
	    }
	    return eigenvectors;
	};

	function find_elem_rotation_matrix(m, dest) {

	    var max = m[1];
	    var ind = 1;
	    for (var i = 2; i < m.length; i++)
	        if (i != 4 && i!= 8 && Math.abs(m[i]) > Math.abs(max)) {
	            max = m[i];
	            ind = i;
	        }
	    var ii = Math.floor(ind / 3);
	    var jj = ind % 3;
	    var fi = 0.5 * Math.atan(2 * max / (m[ii * 3 + ii] - m[jj * 3 + jj]));

	    for (var i = 0; i < dest.length; i++)
	        if (i == 0 || i == 4 || i == 8)
	            dest[i] = 1;
	        else
	            dest[i] = 0;
	    dest[jj + ii * 3] = - Math.sin(fi);
	    dest[ii + jj * 3] = Math.sin(fi);
	    dest[ii + ii * 3] = Math.cos(fi);
	    dest[jj + jj * 3] = Math.cos(fi);

	    return dest;
	}

	function calc_canonical_mat_error(m) {
	    return Math.sqrt(m[1] * m[1] + m[2] * m[2] + m[5] * m[5]);
	}
	/**
	 * Calculate distance from point to plane.
	 */
	exports.point_plane_dist = function(pt, plane) {
	    return plane[0] * pt[0] + plane[1] * pt[1] + plane[2] * pt[2] + plane[3];
	};

	/**
	 *  Binary heap http://eloquentjavascript.net/1st_edition/appendix2.html
	 */
	exports.binary_heap_new = binary_heap_new;
	function binary_heap_new(score_function) {
	    return {
	        content: [],
	        score_function: score_function
	    }
	}

	exports.binary_heap_push = binary_heap_push;
	function binary_heap_push(heap, element) {
	    heap.content.push(element);
	    binary_heap_sink_down(heap, heap.content.length - 1);
	}

	function binary_heap_sink_down(heap, n) {
	    // Fetch the element that has to be sunk.
	    var element = heap.content[n];

	    // When at 0, an element can not sink any further.
	    while (n > 0) {
	        // Compute the parent element's index, and fetch it.
	        var parent_n = ((n + 1) >> 1) - 1,
	            parent = heap.content[parent_n];
	        // Swap the elements if the parent is greater.
	        if (heap.score_function(element) < heap.score_function(parent)) {
	            heap.content[parent_n] = element;
	            heap.content[n] = parent;
	            // Update 'n' to continue at the new position.
	            n = parent_n;
	        }
	        // Found a parent that is less, no need to sink any further.
	        else {
	            break;
	        }
	    }
	}

	exports.binary_heap_pop = binary_heap_pop;
	function binary_heap_pop(heap) {
	    // Store the first element so we can return it later.
	    var result = heap.content[0];
	    // Get the element at the end of the array.
	    var end = heap.content.pop();
	    // If there are any elements left, put the end element at the
	    // start, and let it bubble up.
	    if (heap.content.length > 0) {
	        heap.content[0] = end;
	        binary_heap_bubble_up(heap, 0);
	    }
	    return result;
	}

	exports.binary_heap_remove = binary_heap_remove;
	function binary_heap_remove(heap, node) {
	    var i = heap.content.indexOf(node);

	    // When it is found, the process seen in 'pop' is repeated
	    // to fill up the hole.
	    var end = heap.content.pop();

	    if (i !== heap.content.length - 1) {
	        heap.content[i] = end;

	        if (heap.score_function(end) < heap.score_function(node)) {
	            binary_heap_sink_down(i);
	        } else {
	            binary_heap_bubble_up(i);
	        }
	    }
	}

	exports.binary_heap_rescore_element = binary_heap_rescore_element;
	function binary_heap_rescore_element(heap, node) {
	    binary_heap_sink_down(heap, heap.content.indexOf(node));
	}

	function binary_heap_bubble_up(heap, n) {
	    // Look up the target element and its score.
	    var length = heap.content.length,
	        element = heap.content[n],
	        elem_score = heap.score_function(element);
	    while (true) {
	        // Compute the indices of the child elements.
	        var child2_n = (n + 1) << 1,
	            child1_n = child2_n - 1;
	        // This is used to store the new position of the element,
	        // if any.
	        var swap = null;
	        // If the first child exists (is inside the array)...
	        if (child1_n < length) {
	            // Look it up and compute its score.
	            var child1 = heap.content[child1_n],
	                child1_score = heap.score_function(child1);

	            // If the score is less than our element's, we need to swap.
	            if (child1_score < elem_score)
	                swap = child1_n;
	        }
	        // Do the same checks for the other child.
	        if (child2_n < length) {
	            var child2 = heap.content[child2_n],
	                child2_score = heap.score_function(child2);
	            if (child2_score < (swap === null ? elem_score : child1_score)) {
	                swap = child2_n;
	            }
	        }
	        // If the element needs to be moved, swap it, and continue.
	        if (swap !== null) {
	            heap.content[n] = heap.content[swap];
	            heap.content[swap] = element;
	            n = swap;
	        }
	        // Otherwise, we are done.
	        else {
	            break;
	        }
	    }
	}


	// t: current time, b: begInnIng value, c: change In value, d: duration
	exports.linear_tween = linear_tween;
	function linear_tween(t, b, c, d) {
	    return c*t/d + b;
	}
	exports.ease_in_quad = ease_in_quad;
	function ease_in_quad(t, b, c, d) {
	    return c*(t/=d)*t + b;
	}
	exports.ease_out_quad = ease_out_quad;
	function ease_out_quad(t, b, c, d) {
	    return -c *(t/=d)*(t-2) + b;
	}
	exports.ease_in_out_quad = ease_in_out_quad;
	function ease_in_out_quad(t, b, c, d) {
	    if ((t/=d/2) < 1) return c/2*t*t + b;
	    return -c/2 * ((--t)*(t-2) - 1) + b;
	}
	exports.ease_in_cubic = ease_in_cubic;
	function ease_in_cubic(t, b, c, d) {
	    return c*(t/=d)*t*t + b;
	}
	exports.ease_out_cubic = ease_out_cubic;
	function ease_out_cubic(t, b, c, d) {
	    return c*((t=t/d-1)*t*t + 1) + b;
	}
	exports.ease_in_out_cubic = ease_in_out_cubic;
	function ease_in_out_cubic(t, b, c, d) {
	    if ((t/=d/2) < 1) return c/2*t*t*t + b;
	    return c/2*((t-=2)*t*t + 2) + b;
	}
	exports.ease_in_quart = ease_in_quart;
	function ease_in_quart(t, b, c, d) {
	    return c*(t/=d)*t*t*t + b;
	}
	exports.ease_out_quart = ease_out_quart;
	function ease_out_quart(t, b, c, d) {
	    return -c * ((t=t/d-1)*t*t*t - 1) + b;
	}
	exports.ease_in_out_quart = ease_in_out_quart;
	function ease_in_out_quart(t, b, c, d) {
	    if ((t/=d/2) < 1) return c/2*t*t*t*t + b;
	    return -c/2 * ((t-=2)*t*t*t - 2) + b;
	}
	exports.ease_in_quint = ease_in_quint;
	function ease_in_quint(t, b, c, d) {
	    return c*(t/=d)*t*t*t*t + b;
	}
	exports.ease_out_quint = ease_out_quint;
	function ease_out_quint(t, b, c, d) {
	    return c*((t=t/d-1)*t*t*t*t + 1) + b;
	}
	exports.ease_in_out_quint = ease_in_out_quint;
	function ease_in_out_quint(t, b, c, d) {
	    if ((t/=d/2) < 1) return c/2*t*t*t*t*t + b;
	    return c/2*((t-=2)*t*t*t*t + 2) + b;
	}
	exports.ease_in_sine = ease_in_sine;
	function ease_in_sine(t, b, c, d) {
	    return -c * Math.cos(t/d * (Math.PI/2)) + c + b;
	}
	exports.ease_out_sine = ease_out_sine;
	function ease_out_sine(t, b, c, d) {
	    return c * Math.sin(t/d * (Math.PI/2)) + b;
	}
	exports.ease_in_out_sine = ease_in_out_sine;
	function ease_in_out_sine(t, b, c, d) {
	    return -c/2 * (Math.cos(Math.PI*t/d) - 1) + b;
	}
	exports.ease_in_expo = ease_in_expo;
	function ease_in_expo(t, b, c, d) {
	    return (t==0) ? b : c * Math.pow(2, 10 * (t/d - 1)) + b;
	}
	exports.ease_out_expo = ease_out_expo;
	function ease_out_expo(t, b, c, d) {
	    return (t==d) ? b+c : c * (-Math.pow(2, -10 * t/d) + 1) + b;
	}
	exports.ease_in_out_expo = ease_in_out_expo;
	function ease_in_out_expo(t, b, c, d) {
	    if (t==0) return b;
	    if (t==d) return b+c;
	    if ((t/=d/2) < 1) return c/2 * Math.pow(2, 10 * (t - 1)) + b;
	    return c/2 * (-Math.pow(2, -10 * --t) + 2) + b;
	}
	exports.ease_in_circ = ease_in_circ;
	function ease_in_circ(t, b, c, d) {
	    return -c * (Math.sqrt(1 - (t/=d)*t) - 1) + b;
	}
	exports.ease_out_circ = ease_out_circ;
	function ease_out_circ(t, b, c, d) {
	    return c * Math.sqrt(1 - (t=t/d-1)*t) + b;
	}
	exports.ease_in_out_circ = ease_in_out_circ;
	function ease_in_out_circ(t, b, c, d) {
	    if ((t/=d/2) < 1) return -c/2 * (Math.sqrt(1 - t*t) - 1) + b;
	    return c/2 * (Math.sqrt(1 - (t-=2)*t) + 1) + b;
	}
	exports.ease_in_elastic = ease_in_elastic;
	function ease_in_elastic(t, b, c, d) {
	    var s=1.70158;var p=0;var a=c;
	    if (t==0) return b;  if ((t/=d)==1) return b+c;  if (!p) p=d*.3;
	    if (a < Math.abs(c)) { a=c; s=p/4; }
	    else s = p/(2*Math.PI) * Math.asin (c/a);
	    return -(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b;
	}
	exports.ease_out_elastic = ease_out_elastic;
	function ease_out_elastic(t, b, c, d) {
	    var s=1.70158;var p=0;var a=c;
	    if (t==0) return b;  if ((t/=d)==1) return b+c;  if (!p) p=d*.3;
	    if (a < Math.abs(c)) { a=c; s=p/4; }
	    else s = p/(2*Math.PI) * Math.asin (c/a);
	    return a*Math.pow(2,-10*t) * Math.sin( (t*d-s)*(2*Math.PI)/p ) + c + b;
	}
	exports.ease_in_out_elastic = ease_in_out_elastic;
	function ease_in_out_elastic(t, b, c, d) {
	    var s=1.70158;var p=0;var a=c;
	    if (t==0) return b;  if ((t/=d/2)==2) return b+c;  if (!p) p=d*(.3*1.5);
	    if (a < Math.abs(c)) { a=c; s=p/4; }
	    else s = p/(2*Math.PI) * Math.asin (c/a);
	    if (t < 1) return -.5*(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b;
	    return a*Math.pow(2,-10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )*.5 + c + b;
	}
	exports.ease_in_back = ease_in_back;
	function ease_in_back(t, b, c, d, s) {
	    if (s == undefined) s = 1.70158;
	    return c*(t/=d)*t*((s+1)*t - s) + b;
	}
	exports.ease_out_back = ease_out_back;
	function ease_out_back(t, b, c, d, s) {
	    if (s == undefined) s = 1.70158;
	    return c*((t=t/d-1)*t*((s+1)*t + s) + 1) + b;
	}
	exports.ease_in_out_back = ease_in_out_back;
	function ease_in_out_back(t, b, c, d, s) {
	    if (s == undefined) s = 1.70158; 
	    if ((t/=d/2) < 1) return c/2*(t*t*(((s*=(1.525))+1)*t - s)) + b;
	    return c/2*((t-=2)*t*(((s*=(1.525))+1)*t + s) + 2) + b;
	}
	exports.ease_in_bounce = ease_in_bounce;
	function ease_in_bounce(t, b, c, d) {
	    return c - ease_out_bounce (d-t, 0, c, d) + b;
	}
	exports.ease_out_bounce = ease_out_bounce;
	function ease_out_bounce(t, b, c, d) {
	    if ((t/=d) < (1/2.75)) {
	        return c*(7.5625*t*t) + b;
	    } else if (t < (2/2.75)) {
	        return c*(7.5625*(t-=(1.5/2.75))*t + .75) + b;
	    } else if (t < (2.5/2.75)) {
	        return c*(7.5625*(t-=(2.25/2.75))*t + .9375) + b;
	    } else {
	        return c*(7.5625*(t-=(2.625/2.75))*t + .984375) + b;
	    }
	}
	exports.ease_in_out_bounce = ease_in_out_bounce;
	function ease_in_out_bounce(t, b, c, d) {
	    if (t < d/2) return ease_in_bounce (t*2, 0, c, d) * .5 + b;
	    return ease_out_bounce (t*2-d, 0, c, d) * .5 + c*.5 + b;
	}

	}

	var int_math_factory = register("__math", Int_math);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Print API. Overrides some standart js console functions
	 * @name print
	 * @namespace
	 * @exports exports as print
	 */

	function Print(ns, exports) {

	// no module requires

	var _verbose = false;
	var _error_count = 0;
	var _warning_count = 0;

	var _deprecated_methods = {};
	/**
	 * Set verbose flag for console output.
	 */
	exports.set_verbose = function(v) {
	    _verbose = v;
	};

	exports.log_raw = function() {
	    console.log.apply(console, arguments);
	};

	exports.log = function() {
	    if (_verbose) {
	        var args = compose_args_prefix(arguments, "B4W LOG");
	        console.log.apply(console, args);
	    }
	};

	exports.compose_args_prefix = compose_args_prefix;
	function compose_args_prefix(args_in, prefix) {
	    var args_out = [];

	    if (args_in[0].indexOf("%c") > -1)
	        args_out.push(args_in[0].replace("%c", "%c" + prefix + ": "));
	    else
	        args_out.push(prefix + ": " + args_in[0]);

	    for (var i = 1; i < args_in.length; i++)
	        args_out.push(args_in[i]);

	    return args_out;
	}

	exports.error = error;
	function error() {
	    // always reporting errors
	    _error_count++;

	    var args = compose_args_prefix(arguments, "B4W ERROR");
	    console.error.apply(console, args);
	}
	exports.error_once = error_once;
	function error_once(message) {
	    if (!(message in _deprecated_methods)) {
	        _deprecated_methods[message] = message;
	        error([message]);
	    }
	}

	exports.error_deprecated = error_deprecated;
	function error_deprecated(depr_func, new_func) {
	    error_once(depr_func + "() is deprecated, use " + new_func + "() instead.");
	}

	exports.error_deprecated_arr = function(depr_func, new_func_arr) {
	    switch (new_func_arr.length > 1) {
	    case true:
	        error_once(depr_func + "() is deprecated, use " 
	                + new_func_arr.slice(0, -1).join("(), ")
	                + "() or " + new_func_arr[new_func_arr.length - 1] + "() instead.");
	        break;
	    case false:
	        error_deprecated(depr_func, new_func_arr[0]);
	        break;
	    }
	};

	exports.error_deprecated_cfg = function(depr_cfg, new_cfg) {
	    if (new_cfg === undefined)
	        error_once("Config option \"" + depr_cfg + "\" is deprecated.");
	    else
	        error_once("Config option \"" + depr_cfg + "\" is deprecated, use \"" +
	                new_cfg + "\" instead.");
	};

	exports.warn = function() {
	    // always reporting warnings
	    _warning_count++;

	    var args = compose_args_prefix(arguments, "B4W WARN");
	    console.warn.apply(console, args);
	};

	exports.info = function() {
	    var args = compose_args_prefix(arguments, "B4W INFO");
	    console.info.apply(console, args);
	};

	exports.export_error = function() {
	    // always reporting errors
	    _error_count++;

	    var args = compose_args_prefix(arguments, "B4W EXPORT ERROR");
	    console.error.apply(console, args);
	};

	exports.export_warn = function() {
	    // always reporting warnings
	    _warning_count++;

	    var args = compose_args_prefix(arguments, "B4W EXPORT WARNING");
	    console.warn.apply(console, args);
	};

	exports.time = function() {
	    if (_verbose)
	        console.time.apply(console, arguments);
	};

	exports.timeEnd = function() {
	    if (_verbose)
	        console.timeEnd.apply(console, arguments);
	};

	exports.group = function() {
	    console.group.apply(console, arguments);
	};

	exports.groupCollapsed = function() {
	    console.groupCollapsed.apply(console, arguments);
	};

	exports.groupEnd = function() {
	    console.groupEnd.apply(console, arguments);
	};

	exports.clear = function() {
	    if (typeof console.clear == "function")
	        console.clear.apply(console, arguments);
	};

	exports.get_warning_count = function() {
	    return _warning_count;
	};

	exports.get_error_count = function() {
	    return _error_count;
	};

	exports.clear_errors_warnings = function() {
	    _warning_count = 0;
	    _error_count = 0;
	};

	}

	var print_factory = register("print", Print);
	register("__print", Print);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * TBN internal API.
	 * @name tbn
	 * @namespace
	 * @exports exports as tbn
	 */
	function Int_TBN(ns, exports) {

	// offset > 2/65535 to prevent zeroes when converting to short
	var ZERO_TBN_EPSILON = 0.000031;
	var TBN_NUM_COMP = 4;
	var INIT_ANGLE = 0.5;

	exports.TBN_NUM_COMP = TBN_NUM_COMP;

	var m_quat = quat_factory(ns);
	var m_tsr  = int_tsr_factory(ns);
	var m_vec3 = vec3_factory(ns);
	var m_vec4 = vec4_factory(ns);
	var m_util = int_util_factory(ns);

	var _quat_tmp = m_quat.create();
	var _quat_tmp2 = m_quat.create();
	var _vec3_tmp = m_vec3.create();
	var _vec3_tmp2 = m_vec3.create();
	var _vec3_tmp3 = m_vec3.create();
	var _vec4_tmp = m_vec4.create();
	var _vec4_tmp2 = m_vec4.create();

	exports.from_norm_tan = function(normals, tangents, dest) {
	    var use_tangent = !!(tangents && tangents.length);
	    var count = normals.length / 3;
	    dest = dest || create(count);

	    for (var i = 0; i < count; ++i) {
	        var norm = _vec3_tmp;
	        norm[0] = normals[3 * i];
	        norm[1] = normals[3 * i + 1];
	        norm[2] = normals[3 * i + 2];
	        m_vec3.normalize(norm, norm);

	        if (use_tangent) {
	            var tan = _vec4_tmp2;
	            tan[0] = tangents[TBN_NUM_COMP * i];
	            tan[1] = tangents[TBN_NUM_COMP * i + 1];
	            tan[2] = tangents[TBN_NUM_COMP * i + 2];
	            tan[3] = tangents[TBN_NUM_COMP * i + 3];
	            m_vec3.normalize(tan, tan);

	            var binorm = m_vec3.cross(tan, norm, _vec3_tmp2);
	            m_vec3.normalize(binorm, binorm);

	            var binorm_quat = m_quat.rotationTo(m_util.AXIS_Z, binorm, _quat_tmp);
	            var new_y = m_vec3.transformQuat(m_util.AXIS_Y, binorm_quat, _vec3_tmp3);
	            var norm_quat = m_quat.rotationTo(new_y, norm, _quat_tmp2);
	            var quat = m_quat.multiply(norm_quat, binorm_quat, _quat_tmp);

	            m_quat.normalize(quat, quat);

	            var angle = INIT_ANGLE;
	            var new_tan = m_vec3.cross(norm, binorm, _vec3_tmp3);
	            if (Math.abs(new_tan[0] - tan[0]) > ZERO_TBN_EPSILON ||
	                    Math.abs(new_tan[1] - tan[1]) > ZERO_TBN_EPSILON ||
	                    Math.abs(new_tan[2] - tan[2]) > ZERO_TBN_EPSILON)
	                // angle is in [0.0, 1.0], [0.0, 1.0] ~ [0, Pi]
	                angle = Math.acos(m_vec3.dot(norm, tan)) / Math.PI;

	            set_quat(dest, quat, i);
	            set_handedness(dest, m_util.sign(tan[3]), i);
	            set_angle(dest, angle, i);
	        } else {
	            var quat = m_quat.rotationTo(m_util.AXIS_Y, norm, _quat_tmp);
	            set_quat(dest, quat, i);
	        }
	    }
	    return dest;
	};

	exports.copy = function(src_tbn, src_offset, src_length, dest_tbn) {
	    if (src_length === 0)
	        return;

	    src_offset = 4 * src_offset || 0;
	    src_length = src_length || src_tbn.length;

	    for (var i = 0, j = 0; i < 4 * src_length; i += 4, j += 4) {
	        dest_tbn[j] = src_tbn[src_offset + i];
	        dest_tbn[j + 1] = src_tbn[src_offset + i + 1];
	        dest_tbn[j + 2] = src_tbn[src_offset + i + 2];
	        dest_tbn[j + 3] = src_tbn[src_offset + i + 3];
	    }
	};

	exports.get_quat = get_quat;
	function get_quat(tbn, index, dest) {
	    index = index || 0;

	    var cur_tbn = get_item(tbn, index, dest);
	    m_quat.normalize(cur_tbn, dest);

	    return dest;
	}

	exports.set_quat = set_quat;
	function set_quat(tbn, quat, index) {
	    index = index || 0;

	    var cur_tbn = get_item(tbn, index, _vec4_tmp);

	    var angle = m_quat.length(cur_tbn);

	    var is_changed_hand = m_util.sign(cur_tbn[3]) * m_util.sign(quat[3]) || 1.0;
	    m_quat.scale(quat, is_changed_hand * angle, cur_tbn);

	    // NOTE: fixes +/- issues with zeroes
	    if (Math.abs(cur_tbn[3]) < ZERO_TBN_EPSILON)
	        if (cur_tbn[3] > 0)
	            cur_tbn[3] = ZERO_TBN_EPSILON;
	        else
	            cur_tbn[3] = -ZERO_TBN_EPSILON;

	    set_item(tbn, cur_tbn, index);
	    return tbn;
	}

	function get_handedness(tbn, index) {
	    index = index || 0;

	    return m_util.sign(tbn[index * 4 + 3]);
	}

	function set_handedness(tbn, handedness, index) {
	    index = index || 0;

	    var cur_tbn = get_item(tbn, index, _vec4_tmp);
	    var is_changed_hand = m_util.sign(cur_tbn[3]) * handedness;
	    if (is_changed_hand < 0)
	        m_quat.scale(cur_tbn, -1, cur_tbn);

	    set_item(tbn, cur_tbn, index);
	    return tbn;
	}

	function set_angle(tbn, angle, index) {
	    index = index || 0;

	    var cur_tbn = get_item(tbn, index, _vec4_tmp);
	    m_quat.normalize(cur_tbn, cur_tbn);
	    m_quat.scale(cur_tbn, angle, cur_tbn);

	    // NOTE: fixes +/- issues with zeroes
	    if (Math.abs(cur_tbn[3]) < ZERO_TBN_EPSILON)
	        if (cur_tbn[3] > 0)
	            cur_tbn[3] += ZERO_TBN_EPSILON;
	        else
	            cur_tbn[3] -= ZERO_TBN_EPSILON;

	    set_item(tbn, cur_tbn, index);
	    return tbn;
	}

	function get_angle(tbn, index) {
	    index = index || 0;

	    var cur_tbn = get_item(tbn, index, _vec4_tmp);

	    return m_quat.length(cur_tbn);
	}

	exports.get_norm = function(tbn, index, dest) {
	    var quat = get_quat(tbn, index, _quat_tmp);
	    return m_vec3.transformQuat(m_util.AXIS_Y, quat, dest);
	};

	exports.create = create;
	function create(count) {
	    count = count !== 0 ? count || 1: 0;

	    var tbn = new Float32Array(4 * count);

	    for (var i = 0; i < count; i++)
	        tbn[4 * i + 3] = INIT_ANGLE;

	    return tbn;
	}

	exports.identity = identity;
	function identity(tbn) {
	    for (var i = 0; i < tbn.length; i += 4) {
	        tbn[i] = 0.0;
	        tbn[i + 1] = 0.0;
	        tbn[i + 2] = 0.0;
	        tbn[i + 3] = INIT_ANGLE;
	    }

	    return tbn;
	}

	exports.get_item = get_item;
	function get_item(tbn, index, dest) {
	    dest[0] = tbn[4 * index];
	    dest[1] = tbn[4 * index + 1];
	    dest[2] = tbn[4 * index + 2];
	    dest[3] = tbn[4 * index + 3];

	    return dest;
	}

	exports.set_item = set_item;
	function set_item(tbn, item, index) {
	    tbn[4 * index] = item[0];
	    tbn[4 * index + 1] = item[1];
	    tbn[4 * index + 2] = item[2];
	    tbn[4 * index + 3] = item[3];

	    return tbn;
	}

	exports.get_items_count = get_items_count;
	function get_items_count(tbn) {
	    return tbn.length / 4;
	}

	exports.multiply_quat = multiply_quat;
	function multiply_quat(tbn, quat, dest) {
	    var length = get_items_count(tbn);

	    for (var i = 0; i < length; i++) {
	        var handedness = get_handedness(tbn, i);
	        var angle = get_angle(tbn, i);
	        var cur_quat = get_quat(tbn, i, _quat_tmp2);

	        var res_quat = m_quat.multiply(quat, cur_quat, _quat_tmp2);

	        set_quat(dest, res_quat, i);
	        set_angle(dest, angle, i);
	        set_handedness(dest, handedness, i);
	    }
	}

	exports.multiply_tsr = function(tbn, tsr, dest) {
	    var quat = m_tsr.get_quat(tsr, _quat_tmp);

	    return multiply_quat(tbn, quat, dest);
	};

	exports.slerp = function(tbn1, tbn2, value, dest) {
	    var handedness = get_handedness(tbn2, 0);

	    var quat1 = get_quat(tbn1, 0, _quat_tmp);
	    var quat2 = get_quat(tbn2, 0, _quat_tmp2);
	    var angle1 = get_angle(tbn1);
	    var angle2 = get_angle(tbn2);

	    var r_quat = m_quat.slerp(quat1, quat2, value, _quat_tmp2);

	    m_quat.normalize(r_quat, r_quat);

	    set_quat(dest, r_quat, 0);
	    set_angle(dest, value * (angle1 - angle2) + angle2);
	    set_handedness(dest, handedness, 0);

	    return dest;
	};

	exports.multiply_tbn = function(tbn1, tbn2, dest) {
	    var handedness = get_handedness(tbn2, 0);
	    var quat1 = get_quat(tbn1, 0, _quat_tmp);
	    var quat2 = get_quat(tbn2, 0, _quat_tmp2);
	    var angle1 = get_angle(tbn1, 0);
	    var angle2 = get_angle(tbn2, 0);

	    var r_quat = m_quat.multiply(quat1, quat2, _quat_tmp);

	    set_quat(dest, r_quat, 0);
	    set_angle(dest, angle1 + angle2 - INIT_ANGLE);
	    set_handedness(dest, handedness, 0);
	    return dest;
	};

	exports.multiply_tbn_inv = function(tbn1, tbn2, dest) {
	    var handedness = get_handedness(tbn2, 0);
	    var quat1 = get_quat(tbn1, 0, _quat_tmp);
	    var quat2 = get_quat(tbn2, 0, _quat_tmp2);
	    var angle1 = get_angle(tbn1);
	    var angle2 = get_angle(tbn2);

	    var inv_quat2 = m_quat.invert(quat2, _quat_tmp2);
	    var r_quat = m_quat.multiply(quat1, inv_quat2, _quat_tmp);

	    set_quat(dest, r_quat, 0);
	    set_angle(dest, angle1 - angle2 + INIT_ANGLE);
	    set_handedness(dest, handedness, 0);
	    return dest;
	};

	}

	var int_tbn_factory = register("__tbn", Int_TBN);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Utility functions.
	 * @name util
	 * @namespace
	 * @exports exports as util
	 */
	function Int_util(ns, exports) {

	var m_mat3  = mat3_factory(ns);
	var m_mat4  = mat4_factory(ns);
	var m_math  = int_math_factory(ns);
	var m_print = print_factory(ns);
	var m_tbn   = int_tbn_factory(ns);
	var m_tsr   = int_tsr_factory(ns);
	var m_quat  = quat_factory(ns);
	var m_vec3  = vec3_factory(ns);
	var m_vec4  = vec4_factory(ns);

	var _unique_counter = 0;
	var _unique_name_counters = {};

	// for internal usage
	var _vec3_tmp = new Float32Array(3);
	var _vec3_tmp2 = new Float32Array(3);
	var _vec3_tmp3 = new Float32Array(3);
	var _vec3_tmp4 = new Float32Array(3);
	var _vec3_tmp5 = new Float32Array(3);
	var _vec3_tmp6 = new Float32Array(3);
	var _vec3_tmp7 = new Float32Array(3);
	var _vec3_tmp8 = new Float32Array(3);
	var _vec4_tmp = new Float32Array(4);
	var _vec4_tmp2 = new Float32Array(4);
	var _mat3_tmp = new Float32Array(9);
	var _mat3_tmp2 = new Float32Array(9);
	var _mat3_tmp3 = new Float32Array(9);
	var _mat4_tmp = new Float32Array(16);
	var _mat4_tmp2 = new Float32Array(16);
	var _quat_tmp = m_quat.create();
	var _quat_tmp2 = m_quat.create();

	var _hash_buffer_in = new Float64Array(1);
	var _hash_buffer_out = new Uint32Array(_hash_buffer_in.buffer);

	var VEC3_IDENT = new Float32Array([0,0,0]);
	var QUAT4_IDENT = new Float32Array([0,0,0,1]);
	var TSR8_IDENT = new Float32Array([0,0,0,1,0,0,0,1]);
	var VEC3_UNIT = new Float32Array([1,1,1]);

	var AXIS_X = new Float32Array([1, 0, 0]);
	var AXIS_Y = new Float32Array([0, 1, 0]);
	var AXIS_Z = new Float32Array([0, 0, 1]);
	var AXIS_MX = new Float32Array([-1, 0, 0]);
	var AXIS_MY = new Float32Array([ 0,-1, 0]);
	var AXIS_MZ = new Float32Array([ 0, 0,-1]);

	var XYX = 0;
	var YZY = 1;
	var ZXZ = 2;
	var XZX = 3;
	var YXY = 4;
	var ZYZ = 5;
	var XYZ = 6;
	var YZX = 7;
	var ZXY = 8;
	var XZY = 9;
	var YXZ = 10;
	var ZYX = 11;

	var PROPER_EULER_ANGLES_LIST = [XYX, YZY, ZXZ, YXY, ZYZ];

	var DEFAULT_SEED = 50000;
	var RAND_A = 48271;
	var RAND_M = 2147483647;
	var RAND_R = RAND_M % RAND_A;
	var RAND_Q = Math.floor(RAND_M / RAND_A);

	// view matrixes representing 6 cube sides
	var INV_CUBE_VIEW_MATRS =
	    [new Float32Array([ 0, 0, -1, 0, 0, -1,  0, 0, -1,  0,  0, 0, 0, 0, 0, 1]),
	     new Float32Array([ 0, 0,  1, 0, 0, -1,  0, 0,  1,  0,  0, 0, 0, 0, 0, 1]),
	     new Float32Array([ 1, 0,  0, 0, 0,  0, -1, 0,  0,  1,  0, 0, 0, 0, 0, 1]),
	     new Float32Array([ 1, 0,  0, 0, 0,  0,  1, 0,  0, -1,  0, 0, 0, 0, 0, 1]),
	     new Float32Array([ 1, 0,  0, 0, 0, -1,  0, 0,  0,  0, -1, 0, 0, 0, 0, 1]),
	     new Float32Array([-1, 0,  0, 0, 0, -1,  0, 0,  0,  0,  1, 0, 0, 0, 0, 1])];

	var GAMMA = 2.2;

	exports.VEC3_IDENT = VEC3_IDENT;
	exports.QUAT4_IDENT = QUAT4_IDENT;
	exports.TSR8_IDENT = TSR8_IDENT;
	exports.VEC3_UNIT = VEC3_UNIT;

	exports.AXIS_X = AXIS_X;
	exports.AXIS_Y = AXIS_Y;
	exports.AXIS_Z = AXIS_Z;
	exports.AXIS_MX = AXIS_MX;
	exports.AXIS_MY = AXIS_MY;
	exports.AXIS_MZ = AXIS_MZ;

	exports.XYX = XYX;
	exports.YZY = YZY;
	exports.ZXZ = ZXZ;
	exports.XZX = XZX;
	exports.YXY = YXY;
	exports.ZYZ = ZYZ;
	exports.XYZ = XYZ;
	exports.YZX = YZX;
	exports.ZXY = ZXY;
	exports.XZY = XZY;
	exports.YXZ = YXZ;
	exports.ZYX = ZYX;

	exports.INV_CUBE_VIEW_MATRS = INV_CUBE_VIEW_MATRS;

	var BYTE_SIZE = 1;
	var SHORT_SIZE = 2;
	var FLOAT_SIZE = 4;
	var INT_SIZE = 4;

	exports.BYTE_SIZE = BYTE_SIZE;
	exports.SHORT_SIZE = SHORT_SIZE;
	exports.FLOAT_SIZE = FLOAT_SIZE;
	exports.INT_SIZE = INT_SIZE;

	exports.isdef = function(v) {
	    return (typeof v != "undefined");
	};

	exports.keyfind = keyfind;
	function keyfind(key, value, array) {
	    var results = [];

	    var len = array.length;
	    for (var i = 0; i < len; i++) {
	        var obj = array[i];
	        if (obj[key] == value)
	            results.push(obj);
	    }
	    return results;
	}

	exports.f32 = function(arr) {
	    return new Float32Array(arr);
	};

	/**
	 * Arrays concatenation.
	 */
	exports.float32_concat = function(first, second) {
	    var firstLength = first.length;
	    var result = new Float32Array(firstLength + second.length);

	    result.set(first);
	    result.set(second, firstLength);

	    return result;
	};

	exports.uint32_concat = function(first, second) {
	    var firstLength = first.length;
	    var result = new Uint32Array(firstLength + second.length);

	    result.set(first);
	    result.set(second, firstLength);

	    return result;
	};

	/**
	 * @returns {boolean} True if we have a little-endian architecture.
	 */
	exports.check_endians = function() {

	    var value = 0xFF;
	    var x = new Uint16Array([value]);
	    var dataview = new DataView(x.buffer);

	    return (dataview.getUint16(0, true) == value);
	};

	/**
	 * Taken from http://www.falsepositives.com/index.php/2009/12/01/javascript-
	 * function-to-get-the-intersect-of-2-arrays/
	 * @returns {Array} Intersection between arrays
	 */
	exports.array_intersect = function(arr1, arr2) {
	    var r = [], o = {}, l = arr2.length, i, v;
	    for (i = 0; i < l; i++) {
	        o[arr2[i]] = true;
	    }
	    l = arr1.length;
	    for (i = 0; i < l; i++) {
	        v = arr1[i];
	        if (v in o) {
	            r.push(v);
	        }
	    }
	    return r;
	};

	/**
	 * Taken from http://stackoverflow.com/questions/7624920/number-sign-in-javascript
	 * @returns {number} Signum function from argument
	 */
	exports.sign = sign;
	function sign(value) {
	    return (value > 0) ? 1 : (value < 0 ? -1 : 0);
	}

	/**
	 * Check if an object with a given key:value is present in the array.
	 */
	exports.keycheck = function(key, value, array) {
	    var len = array.length;

	    for (var i = 0; i < len; i++) {
	        var obj = array[i];
	        if (obj[key] == value)
	            return true;
	    }
	    return false;
	};

	exports.keysearch = function(key, value, array) {
	    for (var i = 0; i < array.length; i++) {
	        var obj = array[i];
	        if (obj[key] === value)
	            return obj;
	    }

	    return null;
	};

	/**
	 * Helper search function.
	 * Returns single element or throws error if not found
	 */
	exports.key2search = function(key1, value1, key2, value2, array) {
	    for (var i = 0; i < array.length; i++) {
	        var obj = array[i];
	        if (obj[key1] == value1 && obj[key2] == value2)
	            return obj;
	    }
	    return null;
	};

	/**
	 * Helper search function
	 */
	exports.get_index_for_key_value = function(array, key, value) {
	    for (var i = 0; i < array.length; i++)
	        if (array[i][key] == value)
	            return i;
	    return -1;
	};

	/**
	 * Append to array unique values
	 */
	exports.append_unique = function(array, value) {

	    for (var i = 0; i < array.length; i++)
	        if (array[i] == value)
	            return;

	    array.push(value);
	};

	/**
	 * Check if all elements in array is unique.
	 */
	exports.check_uniqueness = function(array) {

	    for (var i = 0; i < array.length-1; i++) {

	        var elem_i = array[i];

	        for (var j = i+1; j < array.length; j++) {
	            var elem_j = array[j];

	            if (elem_i == elem_j)
	                return false;
	        }
	    }

	    return true;
	};

	/**
	 * Create translation matrix
	 */
	exports.trans_matrix = function(x, y, z, dest) {

	    if (!dest)
	        dest = new Float32Array(16);

	    m_mat4.identity(dest);

	    dest[12] = x;
	    dest[13] = y;
	    dest[14] = z;

	    return dest;
	};

	var _next = 1;

	/** get random number */
	exports.rand = function() {
	    _next = (_next * 69069 + 5) % Math.pow(2, 32);
	    return (Math.round(_next/65536) % 32768)/32767;
	};

	/** store seed */
	exports.srand = function(seed) {
	    _next = seed;
	};

	/**
	 * Pseudo random number generator.
	 * (Lehmer Generator)
	 */
	exports.rand_r = function(seedp) {
	    var high = Math.floor(seedp[0] / RAND_Q);
	    var low = seedp[0] % RAND_Q;

	    var test = RAND_A * low - RAND_R * high;

	    if (test > 0)
	        seedp[0] = test;
	    else
	        seedp[0] = test + RAND_M;

	    return (seedp[0] - 1) / (RAND_M - 1);
	};

	/**
	 * Initialize reasonable seed for rand_r() function, based on integer seed
	 * number.
	 */
	exports.init_rand_r_seed = function(seed_number, dest) {
	    if (!dest)
	        dest = [];

	    dest[0] = DEFAULT_SEED + Math.floor(seed_number);
	    return dest;
	};

	/**
	 * <p>Translate BLENDER euler to BLENDER quat
	 */
	exports.euler_to_quat = function(euler, quat) {
	    // reorder angles from XYZ to ZYX
	    var angles = _vec3_tmp;
	    angles[0] = euler[2];
	    angles[1] = euler[1];
	    angles[2] = euler[0];

	    ordered_angles_to_quat(angles, ZYX, quat);

	    return quat;
	};


	/**
	 * Translate Euler angles in the intrinsic rotation sequence to quaternion
	 * Source: Appendix A of http://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/19770024290.pdf
	 */
	exports.ordered_angles_to_quat = ordered_angles_to_quat;
	function ordered_angles_to_quat(angles, order, quat) {
	    var alpha   = angles[0];
	    var beta    = angles[1];
	    var gamma   = angles[2];

	    var c1 = Math.cos(alpha / 2);
	    var c2 = Math.cos(beta  / 2);
	    var c3 = Math.cos(gamma / 2);
	    var s1 = Math.sin(alpha / 2);
	    var s2 = Math.sin(beta  / 2);
	    var s3 = Math.sin(gamma / 2);

	    if (PROPER_EULER_ANGLES_LIST.indexOf(order) > -1) {
	        var c13  = Math.cos((alpha + gamma) / 2);
	        var s13  = Math.sin((alpha + gamma) / 2);
	        var c1_3 = Math.cos((alpha - gamma) / 2);
	        var s1_3 = Math.sin((alpha - gamma) / 2);
	        var c3_1 = Math.cos((gamma - alpha) / 2);
	        var s3_1 = Math.sin((gamma - alpha) / 2);
	    }

	    switch(order) {
	    case XYX:
	        quat[0] = c2 * s13;
	        quat[1] = s2 * c1_3;
	        quat[2] = s2 * s1_3;
	        quat[3] = c2 * c13;
	        break;
	    case YZY:
	        quat[0] = s2 * s1_3;
	        quat[1] = c2 * s13;
	        quat[2] = s2 * c1_3;
	        quat[3] = c2 * c13;
	        break;
	    case ZXZ:
	        quat[0] = s2 * c1_3;
	        quat[1] = s2 * s1_3;
	        quat[2] = c2 * s13;
	        quat[3] = c2 * c13;
	        break;
	    case XZX:
	        quat[0] = c2 * s13;
	        quat[1] = s2 * s3_1;
	        quat[2] = s2 * c3_1;
	        quat[3] = c2 * c13;
	        break;
	    case YXY:
	        quat[0] = s2 * c3_1;
	        quat[1] = c2 * s13;
	        quat[2] = s2 * s3_1;
	        quat[3] = c2 * c13;
	        break;
	    case ZYZ:
	        quat[0] = s2 * s3_1;
	        quat[1] = s2 * c3_1;
	        quat[2] = c2 * s13;
	        quat[3] = c2 * c13;
	        break;
	    case XYZ:
	        quat[0] = s1 * c2 * c3 + c1 * s2 * s3;
	        quat[1] = c1 * s2 * c3 - s1 * c2 * s3;
	        quat[2] = c1 * c2 * s3 + s1 * s2 * c3;
	        quat[3] = c1 * c2 * c3 - s1 * s2 * s3;
	        break;
	    case YZX:
	        quat[0] = c1 * c2 * s3 + s1 * s2 * c3;
	        quat[1] = s1 * c2 * c3 + c1 * s2 * s3;
	        quat[2] = c1 * s2 * c3 - s1 * c2 * s3;
	        quat[3] = c1 * c2 * c3 - s1 * s2 * s3;
	        break;
	    case ZXY:
	        quat[0] = c1 * s2 * c3 - s1 * c2 * s3;
	        quat[1] = c1 * c2 * s3 + s1 * s2 * c3;
	        quat[2] = s1 * c2 * c3 + c1 * s2 * s3;
	        quat[3] = c1 * c2 * c3 - s1 * s2 * s3;
	        break;
	    case XZY:
	        quat[0] = s1 * c2 * c3 - c1 * s2 * s3;
	        quat[1] = c1 * c2 * s3 - s1 * s2 * c3;
	        quat[2] = c1 * s2 * c3 + s1 * c2 * s3;
	        quat[3] = c1 * c2 * c3 + s1 * s2 * s3;
	        break;
	    case YXZ:
	        quat[0] = c1 * s2 * c3 + s1 * c2 * s3;
	        quat[1] = s1 * c2 * c3 - c1 * s2 * s3;
	        quat[2] = c1 * c2 * s3 - s1 * s2 * c3;
	        quat[3] = c1 * c2 * c3 + s1 * s2 * s3;
	        break;
	    case ZYX:
	        quat[0] = c1 * c2 * s3 - s1 * s2 * c3;
	        quat[1] = c1 * s2 * c3 + s1 * c2 * s3;
	        quat[2] = s1 * c2 * c3 - c1 * s2 * s3;
	        quat[3] = c1 * c2 * c3 + s1 * s2 * s3;
	        break;
	    }

	    return quat;
	}

	/**
	 * Translate quaternion to Euler angles in the intrinsic rotation sequence
	 * Source: Appendix A of http://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/19770024290.pdf
	 * quat must be normalized
	 */
	exports.quat_to_ordered_angles = quat_to_ordered_angles;
	function quat_to_ordered_angles(q, order, angles) {
	    var x = q[0], y = q[1], z = q[2], w = q[3];

	    switch(order) {
	    case XYX:
	        angles[0] = Math.atan2(x * y + z * w, y * w - x * z);
	        angles[1] = Math.acos(1 - 2 * (y * y + z * z));
	        angles[2] = Math.atan2(x * y - z * w, x * z + y * w);
	        break;
	    case YZY:
	        angles[0] = Math.atan2(x * w + y * z, z * w - x * y);
	        angles[1] = Math.acos(1 - 2 * (x * x + z * z));
	        angles[2] = Math.atan2(y * z - x * w, x * y + z * w);
	        break;
	    case ZXZ:
	        angles[0] = Math.atan2(x * z + y * w, x * w - y * z);
	        angles[1] = Math.acos(1 - 2 * (x * x + y * y));
	        angles[2] = Math.atan2(x * z - y * w, x * w + y * z);
	        break;
	    case XZX:
	        angles[0] = Math.atan2(x * z - y * w, x * y + z * w);
	        angles[1] = Math.acos(1 - 2 * (y * y + z * z));
	        angles[2] = Math.atan2(x * z + y * w, z * w - x * y);
	        break;
	    case YXY:
	        angles[0] = Math.atan2(x * y - z * w, x * w + y * z);
	        angles[1] = Math.acos(1 - 2 * (x * x + z * z));
	        angles[2] = Math.atan2(x * y + z * w, x * w - y * z);
	        break;
	    case ZYZ:
	        angles[0] = Math.atan2(y * z - x * w, x * z + y * w);
	        angles[1] = Math.acos(1 - 2 * (x * x + y * y));
	        angles[2] = Math.atan2(x * w + y * z, y * w - x * z);
	        break;
	    case XYZ:
	        angles[0] = Math.atan2(2 * (x * w - y * z), 1 - 2 * (x * x + y * y));
	        angles[1] = Math.asin(2 * (x * z + y * w));
	        angles[2] = Math.atan2(2 * (z * w - x * y), 1 - 2 * (y * y + z * z));
	        break;
	    case YZX:
	        var test = x * y + z * w;
	        if (test > 0.499999) {
	            angles[0] = 0;
	            angles[1] = Math.PI / 2;
	            angles[2] = 2 * Math.atan2(x, w);
	        } else if (test < -0.499999) {
	            angles[0] = 0;
	            angles[1] = -Math.PI / 2;
	            angles[2] = -2 * Math.atan2(x, w);
	        } else {
	            angles[0] = Math.atan2(2 * (y * w - x * z), 1 - 2 * (y * y + z * z));
	            angles[1] = Math.asin(2 * (x * y + z * w));
	            angles[2] = Math.atan2(2 * (x * w - y * z), 1 - 2 * (x * x + z * z));
	        }
	        break;
	    case ZXY:
	        angles[0] = Math.atan2(2 * (z * w - x * y), 1 - 2 * (x * x + z * z));
	        angles[1] = Math.asin(2 * (x * w + y * z));
	        angles[2] = Math.atan2(2 * (y * w - x * z), 1 - 2 * (x * x + y * y));
	        break;
	    case XZY:
	        angles[0] = Math.atan2(2 * (x * w + y * z), 1 - 2 * (x * x + z * z));
	        angles[1] = Math.asin(2 * (z * w - x * y));
	        angles[2] = Math.atan2(2 * (x * z + y * w), 1 - 2 * (y * y + z * z));
	        break;
	    case YXZ:
	        angles[0] = Math.atan2(2 * (x * z + y * w), 1 - 2 * (x * x + y * y));
	        angles[1] = Math.asin(2 * (x * w - y * z));
	        angles[2] = Math.atan2(2 * (x * y + z * w), 1 - 2 * (x * x + z * z));
	        break;
	    case ZYX:
	        var test = y * w - x * z;
	        if (test > 0.499999) {
	            angles[0] = 0;
	            angles[1] = Math.PI / 2;
	            angles[2] = -2 * Math.atan2(z, w);
	        } else if (test < -0.499999) {
	            angles[0] = 0;
	            angles[1] = -Math.PI / 2;
	            angles[2] = 2 * Math.atan2(z, w);
	        } else {
	            angles[0] = Math.atan2(2 * (x * y + z * w), 1 - 2 * (y * y + z * z));
	            angles[1] = Math.asin(2 * (y * w - x * z));
	            angles[2] = Math.atan2(2 * (x * w + y * z), 1 - 2 * (x * x + y * y));
	        }
	        break;
	    }
	    // TODO: add check the orientation is far a singularity.
	    // In case of order in {XYZ, YZX, ZXY, XZY, YXZ, ZYX} singularity is angles[1] resides in {-PI/2, PI/2}.
	    // In case of order in {XYX, YZY, ZXZ, XZX, YXY, ZYZ} singularity is angles[1] resides in {0, PI}.
	    return angles;
	}

	 /**
	 * <p>Return rotation matrix from euler angles
	 *
	 * <p>Euler angles have following meaning:
	 * <ol>
	 * <li>heading, x
	 * <li>attitude, y
	 * <li>bank, z
	 * </ol>
	 * <p>Usage discouraged
	 *
	 * @methodOf util
	 * @param {vec3} euler Euler
	 */
	exports.euler_to_rotation_matrix = euler_to_rotation_matrix;
	function euler_to_rotation_matrix(euler, matrix) {

	    var cosX = Math.cos(euler[0]);
	    var cosY = Math.cos(euler[1]);
	    var cosZ = Math.cos(euler[2]);
	    var sinX = Math.sin(euler[0]);
	    var sinY = Math.sin(euler[1]);
	    var sinZ = Math.sin(euler[2]);

	    var cosXcosZ = cosX * cosZ;
	    var cosXsinZ = cosX * sinZ;
	    var sinXcosZ = sinX * cosZ;
	    var sinXsinZ = sinX * sinZ;

	    matrix[0] = cosY * cosZ;
	    matrix[1] = cosY * sinZ;
	    matrix[2] = - sinY;

	    matrix[3] = sinY * sinXcosZ - cosXsinZ;
	    matrix[4] = sinY * sinXsinZ + cosXcosZ;
	    matrix[5] = cosY * sinX;

	    matrix[6] = sinY * cosXcosZ + sinXsinZ;
	    matrix[7] = sinY * cosXsinZ - sinXcosZ;
	    matrix[8] = cosY * cosX;

	    return matrix;
	}

	// Engine uses ZYX intrinsic rotation sequence
	exports.quat_to_euler = quat_to_euler;
	function quat_to_euler(quat, euler) {
	    var angles = quat_to_ordered_angles(quat, ZYX, _vec3_tmp);

	    // reorder angles from XYZ to ZYX
	    euler[0] = angles[2];
	    euler[1] = angles[1];
	    euler[2] = angles[0];

	    return euler;
	}

	/**
	 * Convert quaternion to directional vector.
	 */
	exports.quat_to_dir = quat_to_dir;
	function quat_to_dir(quat, ident, dest) {
	    if (!dest)
	        dest = new Float32Array(3);

	    m_vec3.transformQuat(ident, quat, dest);
	    return dest;
	}
	/**
	 * Convert directional vector to quaternion.
	 * execution discouraged, use quaternion directly
	 */
	exports.dir_to_quat = function(dir, ident, dest) {
	    if (!dest)
	        dest = new Float32Array(4);

	    dir = m_vec3.normalize(dir, _vec3_tmp);

	    var dot = m_vec3.dot(ident, dir);
	    var A = m_vec3.cross(ident, dir, _vec3_tmp2);

	    var teta = Math.acos(dot);

	    dest[0] = A[0] * Math.sin(teta/2);
	    dest[1] = A[1] * Math.sin(teta/2);
	    dest[2] = A[2] * Math.sin(teta/2);
	    dest[3] = Math.cos(teta/2);

	    return dest;
	};

	exports.trans_quat_to_plane = function(trans, quat, ident, dest) {
	    if (!dest)
	        dest = new Float32Array(4);

	    m_vec3.transformQuat(ident, quat, dest);
	    dest[3] = -m_vec3.dot(trans, dest);

	    return dest;
	};

	/**
	 * @methodOf util
	 * Returns angle (in radians) between obj direction ground projection
	 * and default obj direction (depends on object type)
	 */
	exports.dir_ground_proj_angle = function(obj) {

	    var render = obj.render;
	    var quat = m_tsr.get_quat_view(render.world_tsr);

	    var proj   = _vec3_tmp;
	    var defdir = _vec3_tmp2;

	    switch (obj.type) {
	    case "CAMERA":
	        proj[0] =  0;
	        proj[1] = -1;
	        proj[2] =  0;
	        m_vec3.transformQuat(proj, quat, proj);
	        // -Z axis is positive direction
	        defdir[0] =  0;
	        defdir[1] =  0;
	        defdir[2] = -1;
	        break;
	    case "MESH":
	        proj[0] = 0;
	        proj[1] = 0;
	        proj[2] = 1;
	        m_vec3.transformQuat(proj, quat, proj);
	        // Y axis is positive direction
	        defdir[0] = 0;
	        defdir[1] = 0;
	        defdir[2] = 1;
	        break;
	    case "EMPTY":
	        proj[0] = 0;
	        proj[1] = 1;
	        proj[2] = 0;
	        m_vec3.transformQuat(proj, quat, proj);
	        // Z axis is positive direction
	        defdir[0] = 0;
	        defdir[1] = 1;
	        defdir[2] = 0;
	        break;
	    }

	    // project to XZ plane
	    proj[1] = 0;
	    m_vec3.normalize(proj, proj);

	    var cos = m_vec3.dot(proj, defdir);

	    // angle sign is a vertical part of cross cross(proj, defdir)
	    var sign = (-proj[0] * defdir[2]) > 0? -1: 1;

	    var angle  = Math.acos(cos) * sign;
	    return angle;
	};

	exports.blend_arrays = blend_arrays;
	/**
	 * Blend two arrays like GLSL mix()
	 */
	function blend_arrays(a1, a2, f, dest) {

	    // simple optimization (see bflags)
	    if (f == 0)
	        return a1;

	    dest = dest || [];
	    for (var i = 0; i < a1.length; i++)
	        dest[i] = (1 - f) * a1[i] + f * a2[i];
	    return dest;
	}

	/**
	 * Compose unique string ID.
	 */
	exports.unique_id = function() {
	    _unique_counter++;
	    return _unique_counter.toString(10);
	};


	/**
	 * Compose unique name based on given name.
	 */
	exports.unique_name = function(name_base) {
	    if (!_unique_name_counters[name_base])
	        _unique_name_counters[name_base] = 0;

	    var name = name_base + _unique_name_counters[name_base];
	    _unique_name_counters[name_base]++;
	    return name;
	};


	exports.create_empty_va_frame = function() {
	    var va_frame = {
	        "a_position": new Float32Array(0),
	        "a_tbn": m_tbn.create(0)
	    };

	    return va_frame;
	};

	/**
	 * Clone object recursively
	 * NOTE: operation is dangerous because of possible cyclic links
	 * NOTE: leads to code deoptimizations
	 */
	exports.clone_object_r = function(obj) {
	    if (!(obj instanceof Object)) {
	        return obj;
	    }

	    var obj_clone;

	    var Constructor = obj.constructor;

	    switch (Constructor) {
	    case Int8Array:
	    case Uint8Array:
	    case Uint8ClampedArray:
	    case Int16Array:
	    case Uint16Array:
	    case Int32Array:
	    case Uint32Array:
	    case Float32Array:
	    case Float64Array:
	        obj_clone = new Constructor(obj);
	        break;
	    case Array:
	        obj_clone = new Constructor(obj.length);

	        for (var i = 0; i < obj.length; i++)
	            obj_clone[i] = exports.clone_object_r(obj[i]);

	        break;
	    default:
	        obj_clone = new Constructor();

	        for (var prop in obj)
	            if (obj.hasOwnProperty(prop))
	                obj_clone[prop] = exports.clone_object_r(obj[prop]);

	        break;
	    }

	    return obj_clone;
	};

	/**
	 * Clone object non-recursively.
	 * NOTE: leads to code deoptimizations
	 */
	exports.clone_object_nr = function(obj) {

	    var new_obj = (obj instanceof Array) ? [] : {};

	    for (var prop in obj) {
	        if (obj.hasOwnProperty(prop)) {
	            if (obj[prop] instanceof Object) {

	                var Constructor = obj[prop].constructor;

	                switch (Constructor) {
	                case Int8Array:
	                case Uint8Array:
	                case Uint8ClampedArray:
	                case Int16Array:
	                case Uint16Array:
	                case Int32Array:
	                case Uint32Array:
	                case Float32Array:
	                case Float64Array:
	                    new_obj[prop] = new Constructor(obj[prop]);
	                    break;
	                case Array:
	                    new_obj[prop] = obj[prop].slice(0);
	                    break;
	                default:
	                    new_obj[prop] = obj[prop];
	                    break;
	                }
	            } else
	                new_obj[prop] = obj[prop];
	        }
	    }

	    return new_obj;
	};

	exports.matrix_to_quat = matrix_to_quat;
	/**
	 * Extract rotation quaternion from 4x4 matrix.
	 * Only uniform scale supported.
	 * @methodOf util
	 */
	function matrix_to_quat(matrix, dest) {
	    if (!dest)
	        dest = new Float32Array(4);

	    m_mat3.fromMat4(matrix, _mat3_tmp);

	    // drop scale if any by normalizing line vectors

	    var m0 = _mat3_tmp[0];
	    var m3 = _mat3_tmp[3];
	    var m6 = _mat3_tmp[6];

	    var m1 = _mat3_tmp[1];
	    var m4 = _mat3_tmp[4];
	    var m7 = _mat3_tmp[7];

	    var m2 = _mat3_tmp[2];
	    var m5 = _mat3_tmp[5];
	    var m8 = _mat3_tmp[8];

	    // prevent NaN results for zero vectors
	    var l0 = Math.sqrt(m0 * m0 + m3 * m3 + m6 * m6) || 1;
	    var l1 = Math.sqrt(m1 * m1 + m4 * m4 + m7 * m7) || 1;
	    var l2 = Math.sqrt(m2 * m2 + m5 * m5 + m8 * m8) || 1;

	    _mat3_tmp[0] /= l0;
	    _mat3_tmp[3] /= l0;
	    _mat3_tmp[6] /= l0;

	    _mat3_tmp[1] /= l1;
	    _mat3_tmp[4] /= l1;
	    _mat3_tmp[7] /= l1;

	    _mat3_tmp[2] /= l2;
	    _mat3_tmp[5] /= l2;
	    _mat3_tmp[8] /= l2;

	    m_quat.fromMat3(_mat3_tmp, dest);
	    m_quat.normalize(dest, dest);

	    return dest;
	}

	/**
	 * Extract transform vector from given matrix
	 */
	exports.matrix_to_trans = function(matrix, dest) {
	    if (!dest)
	        dest = new Float32Array(3);

	    dest[0] = matrix[12];
	    dest[1] = matrix[13];
	    dest[2] = matrix[14];

	    return dest;
	};

	/**
	 * Return mat4 average scale factor.
	 */
	exports.matrix_to_scale = function(matrix) {

	    _vec4_tmp[0] = 0.577350269189626;
	    _vec4_tmp[1] = 0.577350269189626;
	    _vec4_tmp[2] = 0.577350269189626;
	    _vec4_tmp[3] = 0;

	    m_vec4.transformMat4(_vec4_tmp, matrix, _vec4_tmp);
	    return m_vec4.length(_vec4_tmp);
	};

	/**
	 * Perform some frustum culling stuff
	 * plane [a, b, c, d]
	 * @methodOf util
	 */
	exports.extract_frustum_planes = function(m, planes) {

	    var left   = planes.left;
	    var right  = planes.right;
	    var top    = planes.top;
	    var bottom = planes.bottom;
	    var near   = planes.near;
	    var far    = planes.far;

	    left[0] = m[3] + m[0];
	    left[1] = m[7] + m[4];
	    left[2] = m[11] + m[8];
	    left[3] = m[15] + m[12];

	    right[0] = m[3] - m[0];
	    right[1] = m[7] - m[4];
	    right[2] = m[11] - m[8];
	    right[3] = m[15] - m[12];

	    top[0] = m[3] - m[1];
	    top[1] = m[7] - m[5];
	    top[2] = m[11] - m[9];
	    top[3] = m[15] - m[13];

	    bottom[0] = m[3] + m[1];
	    bottom[1] = m[7] + m[5];
	    bottom[2] = m[11] + m[9];
	    bottom[3] = m[15] + m[13];

	    near[0] = m[3] + m[2];
	    near[1] = m[7] + m[6];
	    near[2] = m[11] + m[10];
	    near[3] = m[15] + m[14];

	    far[0] = m[3] - m[2];
	    far[1] = m[7] - m[6];
	    far[2] = m[11] - m[10];
	    far[3] = m[15] - m[14];

	    normalize_plane(left);
	    normalize_plane(right);
	    normalize_plane(top);
	    normalize_plane(bottom);
	    normalize_plane(near);
	    normalize_plane(far);

	    return planes;
	};

	function normalize_plane(plane) {
	    var a = plane[0], b = plane[1], c = plane[2], d = plane[3];

	    var len = Math.sqrt(a * a + b * b + c * c);
	    len = 1 / len;

	    plane[0] = a * len;
	    plane[1] = b * len;
	    plane[2] = c * len;
	    plane[3] = d * len;
	}

	/**
	 * Detect if given sphere is out of frustum.
	 */
	exports.sphere_is_out_of_frustum = function(pt, planes, radius) {

	    if (radius < -m_math.point_plane_dist(pt, planes.near) ||
	        radius < -m_math.point_plane_dist(pt, planes.left) ||
	        radius < -m_math.point_plane_dist(pt, planes.right) ||
	        radius < -m_math.point_plane_dist(pt, planes.top) ||
	        radius < -m_math.point_plane_dist(pt, planes.bottom) ||
	        radius < -m_math.point_plane_dist(pt, planes.far))
	        return true;
	    else
	        return false;
	};

	/**
	 * Detect if given ellipsoid is out of frustum.
	 */
	exports.ellipsoid_is_out_of_frustum = function(pt, planes,
	                                               axis_x, axis_y, axis_z) {

	    // effective radius - far/near plane
	    var dot_nx = m_vec3.dot(axis_x, planes.far);
	    var dot_ny = m_vec3.dot(axis_y, planes.far);
	    var dot_nz = m_vec3.dot(axis_z, planes.far);
	    var r_far = Math.sqrt(dot_nx * dot_nx + dot_ny * dot_ny + dot_nz * dot_nz);

	    // near and far effective radiuses coincide (far is parallel to near)
	    if (r_far   < -m_math.point_plane_dist(pt, planes.near) ||
	        r_far   < -m_math.point_plane_dist(pt, planes.far)) {
	        return true;
	    }

	    // effective radius - left plane
	    dot_nx = m_vec3.dot(axis_x, planes.left);
	    dot_ny = m_vec3.dot(axis_y, planes.left);
	    dot_nz = m_vec3.dot(axis_z, planes.left);
	    var r_left = Math.sqrt(dot_nx * dot_nx + dot_ny * dot_ny + dot_nz * dot_nz);
	    if (r_left  < -m_math.point_plane_dist(pt, planes.left)) {
	        return true;
	    }

	    // effective radius - right plane
	    dot_nx = m_vec3.dot(axis_x, planes.right);
	    dot_ny = m_vec3.dot(axis_y, planes.right);
	    dot_nz = m_vec3.dot(axis_z, planes.right);
	    var r_right = Math.sqrt(dot_nx * dot_nx + dot_ny * dot_ny + dot_nz * dot_nz);
	    if (r_right < -m_math.point_plane_dist(pt, planes.right)) {
	        return true;
	    }

	    // effective radius - top plane
	    dot_nx = m_vec3.dot(axis_x, planes.top);
	    dot_ny = m_vec3.dot(axis_y, planes.top);
	    dot_nz = m_vec3.dot(axis_z, planes.top);
	    var r_top = Math.sqrt(dot_nx * dot_nx + dot_ny * dot_ny + dot_nz * dot_nz);
	    if (r_top < -m_math.point_plane_dist(pt, planes.top)) {
	        return true;
	    }

	    // effective radius - bottom plane
	    dot_nx = m_vec3.dot(axis_x, planes.bottom);
	    dot_ny = m_vec3.dot(axis_y, planes.bottom);
	    dot_nz = m_vec3.dot(axis_z, planes.bottom);
	    var r_bott = Math.sqrt(dot_nx * dot_nx + dot_ny * dot_ny + dot_nz * dot_nz);
	    if (r_bott < -m_math.point_plane_dist(pt, planes.bottom)) {
	        return true;
	    }

	    return false;
	};

	/**
	 * Translate positions by matrix
	 * optimized function, uses preallocated arrays (Array or Float32Array)
	 * optional destination offset in values (not vectors, not bytes)
	 */
	exports.positions_multiply_matrix = function(positions, matrix, new_positions,
	        dest_offset) {

	    if (!dest_offset)
	        dest_offset = 0;

	    var len = positions.length;

	    for (var i = 0; i < len; i+=3) {
	        var x = positions[i];
	        var y = positions[i+1];
	        var z = positions[i+2];

	        new_positions[dest_offset + i] = matrix[0] * x + matrix[4] * y +
	                matrix[8] * z + matrix[12];
	        new_positions[dest_offset + i + 1] = matrix[1] * x + matrix[5] * y +
	                matrix[9] * z + matrix[13];
	        new_positions[dest_offset + i + 2] = matrix[2] * x + matrix[6] * y +
	                matrix[10] * z + matrix[14];
	    }

	    return new_positions;
	};

	/**
	 * Translate directional (TBN) vectors by matrix.
	 * Optimized function, uses preallocated arrays (Array or Float32Array).
	 * Works only for uniform-scaled matrices.
	 * optional destination offset in values (not vectors, not bytes)
	 */
	exports.vectors_multiply_matrix = function(vectors, matrix, new_vectors,
	        dest_offset) {

	    if (!dest_offset)
	        dest_offset = 0;

	    var len = vectors.length;

	    for (var i = 0; i < len; i+=3) {
	        var x = vectors[i];
	        var y = vectors[i+1];
	        var z = vectors[i+2];

	        // ignore matrix translation part
	        new_vectors[dest_offset + i] = matrix[0] * x + matrix[4] * y + matrix[8] * z;
	        new_vectors[dest_offset + i + 1] = matrix[1] * x + matrix[5] * y + matrix[9] * z;
	        new_vectors[dest_offset + i + 2] = matrix[2] * x + matrix[6] * y + matrix[10] * z;
	    }

	    return new_vectors;
	};

	exports.quats_multiply_quat = function(vectors, quat, new_vectors,
	        dest_offset) {
	    dest_offset = dest_offset || 0;

	    var len = vectors.length;
	    var new_quat = _quat_tmp;
	    for (var i = 0; i < len; i+=4) {

	        new_quat[0] = vectors[i];
	        new_quat[1] = vectors[i+1];
	        new_quat[2] = vectors[i+2];
	        new_quat[3] = vectors[i+3];

	        var is_righthand = new_quat[3] > 0;
	        m_quat.multiply(quat, new_quat, new_quat);
	        if (is_righthand && new_quat[3] < 0 || !is_righthand && new_quat[3] > 0)
	            m_vec4.scale(new_quat, -1, new_quat);

	        new_vectors[dest_offset + i] = new_quat[0];
	        new_vectors[dest_offset + i + 1] = new_quat[1];
	        new_vectors[dest_offset + i + 2] = new_quat[2];
	        new_vectors[dest_offset + i + 3] = new_quat[3];
	    }

	    return new_vectors;
	};

	/**
	 * Translate vector representing direction (e.g. normal)
	 */
	exports.vecdir_multiply_matrix = function(vec, matrix, dest) {
	    if (!dest)
	        dest = new Float32Array(3);

	    var v4 = _vec4_tmp;

	    v4[0] = vec[0];
	    v4[1] = vec[1];
	    v4[2] = vec[2];
	    v4[3] = 0;

	    m_vec4.transformMat4(v4, matrix, v4);
	    dest[0] = v4[0];
	    dest[1] = v4[1];
	    dest[2] = v4[2];
	};

	/**
	 * Make flat (Float32Array) version of given array.
	 * Only single level supported
	 */
	exports.flatten = function(array, dest) {

	    var len = array.length;
	    if (!len)
	        panic("flatten(): Wrong or empty array");

	    var len0 = array[0].length;
	    // already required array
	    if (!len0)
	        panic("flatten(): Wrong or empty subarray");

	    if (!dest)
	        dest = new Float32Array(len * len0);

	    for (var i = 0; i < len; i++)
	        for (var j = 0; j < len0; j++)
	            dest[i * len0 + j] = array[i][j];

	    return dest;
	};
	/**
	 * Make vectorized version of given flat array (opposite to flatten())
	 */
	exports.vectorize = function(array, dest) {

	    if (!dest)
	        dest = [];

	    for (var i = 0; i < array.length; i+=3) {
	        var v3 = new Float32Array([array[i], array[i+1], array[i+2]]);
	        dest[i/3] = v3;
	    }

	    return dest;
	};

	/**
	 * Find index of last element in elements which less than max.
	 * @param arr Array with cumulative (increased) values
	 * @param max Range value
	 * @param start Start index to search
	 * @param end End index to search
	 */
	exports.binary_search_max = function(arr, max, start, end) {

	    // return closest larger index if exact number is not found
	    if (end < start)
	        return start;

	    var mid = start + Math.floor((end - start) / 2);

	    if (arr[mid] > max)
	        return exports.binary_search_max(arr, max, start, mid - 1);
	    else if (arr[mid] < max)
	        return exports.binary_search_max(arr, max, mid + 1, end);
	    else
	        return mid;
	};

	/**
	 * Compare two flat arrays
	 * @returns true if equal
	 */
	exports.cmp_arr = function(arr_1, arr_2) {
	    for (var i = 0; i < arr_1.length; i++)
	        if (arr_1[i] != arr_2[i])
	            return false;

	    return true;
	};

	/**
	 * Compare two float flat arrays using minimal precision value
	 * @returns true if equal
	 */
	exports.cmp_arr_float = function(arr_1, arr_2, precision) {

	    for (var i = 0; i < arr_1.length; i++)
	        if (Math.abs(arr_1[i] - arr_2[i]) > precision)
	            return false;

	    return true;
	};

	/**
	 * Apply uniform scale to matrix.
	 */
	exports.scale_mat4 = function(matrix, scale, dest) {
	    if (!dest)
	        dest = new Float32Array(16);

	    for (var i = 0; i < 12; i++)
	        dest[i] = matrix[i] * scale;

	    dest[12] = matrix[12];
	    dest[13] = matrix[13];
	    dest[14] = matrix[14];
	    dest[15] = matrix[15];

	    return dest;
	};

	/**
	 * Unused. Unoptimized (uses matrix)
	 */
	exports.transform_mat4 = function(matrix, scale, quat, trans, dest) {
	    if (!dest)
	        dest = new Float32Array(16);
	    var m = m_mat4.fromRotationTranslation(quat, trans, _mat4_tmp);

	    m_mat4.multiply(m, matrix, dest);

	    return dest;
	};
	/**
	 * Unoptimized (uses matrix)
	 */
	exports.transform_vec3 = function(vec, scale, quat, trans, dest) {
	    if (!dest)
	        dest = new Float32Array(3);

	    var m1 = m_mat4.fromRotationTranslation(quat, trans, _mat4_tmp);
	    if (scale !== 1) {
	        var m2 = m_mat4.identity(_mat4_tmp2);
	        var s = m_vec3.set(scale, scale, scale, _vec3_tmp);
	        m_mat4.scale(m2, s, m2);
	        m_mat4.multiply(m1, m2, m1);
	    }

	    m_vec3.transformMat4(vec, m1, dest);

	    return dest;
	};
	/**
	 * Unoptimized (uses matrix)
	 */
	exports.transform_vec4 = function(vec, scale, quat, trans, dest) {
	    if (!dest)
	        dest = new Float32Array(4);
	    var m = m_mat4.fromRotationTranslation(quat, trans, _mat4_tmp);

	    m_vec4.transformMat4(vec, m, dest);

	    return dest;
	};

	/**
	 * Unoptimized (uses matrix)
	 */
	exports.inverse_transform_vec3 = function(vec, scale, quat, trans, dest) {
	    if (!dest)
	        dest = new Float32Array(3);
	    var m = m_mat4.fromRotationTranslation(quat, trans, _mat4_tmp);
	    m_mat4.invert(m, m);
	    m_vec3.transformMat4(vec, m, dest);

	    return dest;
	};

	exports.transcale_quat_to_matrix = function(trans, quat, dest) {
	    if (!dest)
	        dest = new Float32Array(16);

	    m_mat4.fromRotationTranslation(quat, trans, dest);

	    var scale = trans[3];
	    for (var i = 0; i < 12; i++)
	        dest[i] *= scale;

	    return dest;
	};

	exports.matrix_to_transcale_quat = function(matrix, dest_transcale, dest_quat) {
	    exports.matrix_to_trans(matrix, dest_transcale);
	    dest_transcale[3] = exports.matrix_to_scale(matrix);
	    matrix_to_quat(matrix, dest_quat);
	};

	/**
	 * Works for typed array also
	 */
	exports.array_stringify = function(array) {

	    var out = [];
	    for (var i = 0; i < array.length; i++)
	        out.push(array[i]);

	    return JSON.stringify(out);
	};

	exports.rotate_point_pivot = function(point, pivot, quat, dest) {
	    if (!dest)
	        dest = new Float32Array(3);

	    var point_rel = _vec3_tmp;

	    m_vec3.subtract(pivot, point, point_rel);
	    m_vec3.transformQuat(point_rel, quat, point_rel);

	    m_vec3.subtract(pivot, point_rel, dest);
	};

	/**
	 * Construct 6 view matrices for 6 cubemap sides
	 */
	exports.generate_cubemap_matrices = function() {

	    var eye_pos = _vec3_tmp;
	    eye_pos[0] = 0; eye_pos[1] = 0; eye_pos[2] = 0;
	    var x_pos   = new Float32Array(16);
	    var x_neg   = new Float32Array(16);
	    var y_pos   = new Float32Array(16);
	    var y_neg   = new Float32Array(16);
	    var z_pos   = new Float32Array(16);
	    var z_neg   = new Float32Array(16);

	    m_mat4.lookAt(eye_pos, [-1, 0, 0], [0, -1, 0], x_pos);
	    m_mat4.scale(x_pos, [-1, 1, 1], x_pos);
	    m_mat4.scale(x_pos, [-1, 1,-1], x_neg);

	    m_mat4.lookAt(eye_pos, [0, -1, 0], [0, 0, -1], y_pos);
	    m_mat4.scale(y_pos, [1, 1,-1], y_pos);
	    m_mat4.scale(y_pos, [1,-1,-1], y_neg);

	    m_mat4.lookAt(eye_pos, [0, 0, -1], [0, -1, 0], z_pos);
	    m_mat4.scale(z_pos, [-1, 1, 1], z_pos);
	    m_mat4.scale(z_pos, [-1, 1,-1], z_neg);

	    return [x_pos, x_neg, y_pos, y_neg, z_pos, z_neg];
	};
	/**
	 * Construct 6 view matrices for 6 cubemap sides
	 */
	exports.generate_inv_cubemap_matrices = function() {

	    var eye_pos = _vec3_tmp;
	    eye_pos[0] = 0; eye_pos[1] = 0; eye_pos[2] = 0;

	    var x_pos   = new Float32Array(16);
	    var x_neg   = new Float32Array(16);
	    var y_pos   = new Float32Array(16);
	    var y_neg   = new Float32Array(16);
	    var z_pos   = new Float32Array(16);
	    var z_neg   = new Float32Array(16);

	    m_mat4.lookAt(eye_pos, [1, 0, 0], [0, -1, 0], x_pos);
	    m_mat4.scale(x_pos, [-1, 1,-1], x_neg);

	    m_mat4.lookAt(eye_pos, [0, 1, 0], [0, 0, 1], y_pos);
	    m_mat4.scale(y_pos, [1,-1, -1], y_neg);

	    m_mat4.lookAt(eye_pos, [0, 0, 1], [0, -1, 0], z_pos);
	    m_mat4.scale(z_pos, [-1, 1,-1], z_neg);

	    return [x_pos, x_neg, y_pos, y_neg, z_pos, z_neg];
	};

	/**
	 * Calculate id for strongly typed variables (batch, render, slink, ...).
	 * init_val parameter is a sort of seed.
	 */
	exports.calc_variable_id = function(a, init_val) {
	    return hash_code(a, init_val);
	};

	exports.hash_code = hash_code;
	function hash_code(a, init_val) {
	    var hash = init_val;

	    switch (typeof a) {
	    case "object":
	        if (a) {
	            // NOTE: some additional props could be added to GL-type objs
	            // so don't build hash code for them
	            switch (a.constructor) {
	            case Object:
	                for (var prop in a)
	                    hash = hash_code(a[prop], hash);
	                break;
	            case Int8Array:
	            case Uint8Array:
	            case Uint8ClampedArray:
	            case Int16Array:
	            case Uint16Array:
	            case Int32Array:
	            case Uint32Array:
	            case Float32Array:
	            case Float64Array:
	                for (var i = 0; i < a.length; i++)
	                    hash = hash_code_number(a[i], hash);
	                break;
	            case Array:
	                for (var i = 0; i < a.length; i++)
	                    hash = hash_code(a[i], hash);
	                break;
	            case WebGLUniformLocation:
	            case WebGLProgram:
	            case WebGLShader:
	            case WebGLFramebuffer:
	            case WebGLRenderbuffer:
	            case WebGLTexture:
	            case WebGLBuffer:
	                hash = hash_code_number(0, hash);
	                break;
	            default:
	                panic("Wrong object constructor:", a.constructor);
	                break;
	            }
	        } else
	            hash = hash_code_number(0, hash);

	        return hash;
	    case "number":
	        return hash_code_number(a, hash);
	    case "boolean":
	        return hash_code_number(a | 0, hash);
	    case "string":
	        return hash_code_string(a, hash);
	    case "function":
	    case "undefined":
	        return hash_code_number(0, hash);
	    }
	}

	function hash_code_number(num, init_val) {
	    var hash = init_val;
	    _hash_buffer_in[0] = num;

	    hash = (hash<<5) - hash + _hash_buffer_out[0];
	    hash = hash & hash;
	    hash = (hash<<5) - hash + _hash_buffer_out[1];
	    hash = hash & hash;

	    return hash;
	}

	/**
	 * Implementation of Java's String.hashCode().
	 */
	exports.hash_code_string = hash_code_string;
	function hash_code_string(str, init_val) {
	    var hash = init_val;

	    for (var i = 0; i < str.length; i++) {
	        var symbol = str.charCodeAt(i);
	        hash = ((hash<<5) - hash) + symbol;
	        hash = hash & hash; // convert to 32 bit integer
	    }
	    return hash;
	}

	exports.mat3_to_mat4 = function(mat, dest) {
	    dest[15] = 1;
	    dest[14] = 0;
	    dest[13] = 0;
	    dest[12] = 0;

	    dest[11] = 0;
	    dest[10] = mat[8];
	    dest[9] = mat[7];
	    dest[8] = mat[6];

	    dest[7] = 0;
	    dest[6] = mat[5];
	    dest[5] = mat[4];
	    dest[4] = mat[3];

	    dest[3] = 0;
	    dest[2] = mat[2];
	    dest[1] = mat[1];
	    dest[0] = mat[0];

	    return dest;
	};

	/**
	 * From glMatrix 1
	 */
	exports.quat_to_angle_axis = function(src, dest) {
	    if (!dest) dest = src;
	    // The quaternion representing the rotation is
	    //   q = cos(A/2)+sin(A/2)*(x*i+y*j+z*k)

	    var sqrlen = src[0]*src[0]+src[1]*src[1]+src[2]*src[2];
	    if (sqrlen > 0)
	    {
	        dest[3] = 2 * Math.acos(src[3]);
	        var invlen = 1 / Math.sqrt(sqrlen);
	        dest[0] = src[0]*invlen;
	        dest[1] = src[1]*invlen;
	        dest[2] = src[2]*invlen;
	    } else {
	        // angle is 0 (mod 2*pi), so any axis will do
	        dest[3] = 0;
	        dest[0] = 1;
	        dest[1] = 0;
	        dest[2] = 0;
	    }

	    return dest;
	};

	function permute3(x) {
	    x = ( ((34 * x) + 1) * x);
	    return x % 289;
	}

	function fract(x) {
	    return x - Math.floor(x);
	}

	/**
	 * Returns truncate value
	 * Expected in "ECMAScript Language Specification 6th Edition (ECMA-262)"
	 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc
	 */
	exports.trunc = function(x) {
	    return isNaN(x) || typeof x == "undefined" ? NaN : x | 0;
	};

	exports.deg_to_rad = function(x) {
	    return x * Math.PI / 180;
	};

	exports.rad_to_deg = function(x) {
	    return x * 180 / Math.PI;
	};

	exports.snoise = function(p) {

	    var C_x =  0.211324865405187; // (3.0-sqrt(3.0))/6.0
	    var C_y =  0.366025403784439; // 0.5*(sqrt(3.0)-1.0)
	    var C_z = -0.577350269189626; // -1.0 + 2.0 * C.x
	    var C_w =  0.024390243902439; // 1.0 / 41.0

	    // First corner
	    var v_dot_Cyy = p[0] * C_y + p[1] * C_y;
	    var i_x = Math.floor(p[0] + v_dot_Cyy);
	    var i_y = Math.floor(p[1] + v_dot_Cyy);

	    var i_dot_Cxx = i_x * C_x + i_y * C_x;
	    var x0_x = p[0] - i_x + i_dot_Cxx;
	    var x0_y = p[1] - i_y + i_dot_Cxx;

	    // Other corners
	    var i1_x = x0_x > x0_y ? 1 : 0;
	    var i1_y = 1 - i1_x;

	    var x12_x = x0_x + C_x - i1_x;
	    var x12_y = x0_y + C_x - i1_y;
	    var x12_z = x0_x + C_z;
	    var x12_w = x0_y + C_z;

	    // Permutations
	    i_x %= 289; // Avoid truncation effects in permutation
	    i_y %= 289;

	    var p_x = permute3( permute3(i_y)        + i_x);
	    var p_y = permute3( permute3(i_y + i1_y) + i_x + i1_x);
	    var p_z = permute3( permute3(i_y + 1)    + i_x + 1);

	    var m_x = Math.max(0.5 - (x0_x  * x0_x  + x0_y  * x0_y ), 0);
	    var m_y = Math.max(0.5 - (x12_x * x12_x + x12_y * x12_y), 0);
	    var m_z = Math.max(0.5 - (x12_z * x12_z + x12_w * x12_w), 0);

	    m_x *= m_x * m_x * m_x;
	    m_y *= m_y * m_y * m_y;
	    m_z *= m_z * m_z * m_z;

	    // Gradients: 41 points uniformly over a line, mapped onto a diamond.
	    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)

	    var x_x = 2.0 * fract(p_x * C_w) - 1.0;
	    var x_y = 2.0 * fract(p_y * C_w) - 1.0;
	    var x_z = 2.0 * fract(p_z * C_w) - 1.0;

	    var h_x = Math.abs(x_x) - 0.5;
	    var h_y = Math.abs(x_y) - 0.5;
	    var h_z = Math.abs(x_z) - 0.5;

	    var ox_x = Math.floor(x_x + 0.5);
	    var ox_y = Math.floor(x_y + 0.5);
	    var ox_z = Math.floor(x_z + 0.5);

	    var a0_x = x_x - ox_x;
	    var a0_y = x_y - ox_y;
	    var a0_z = x_z - ox_z;

	    // Normalise gradients implicitly by scaling m
	    // Approximation of: m *= inversesqrt( a0*a0 + h*h );
	    m_x *= 1.79284291400159 - 0.85373472095314 * (a0_x * a0_x + h_x * h_x);
	    m_y *= 1.79284291400159 - 0.85373472095314 * (a0_y * a0_y + h_y * h_y);
	    m_z *= 1.79284291400159 - 0.85373472095314 * (a0_z * a0_z + h_z * h_z);

	    // Compute final noise value at P
	    var g_x = a0_x * x0_x + h_x * x0_y;

	    var g_y = a0_y * x12_x + h_y * x12_y;
	    var g_z = a0_z * x12_z + h_z * x12_w;

	    var m_dot_g = m_x * g_x + m_y * g_y + m_z * g_z;
	    return 130 * m_dot_g;
	};

	function permute(x) {
	    return mod289((34.0 * x + 5.0) * x);
	}

	function mod289(x) {
	    return x - Math.floor(x / 289) * 289;
	}

	function mod7(x) {
	    return x - Math.floor(x / 7) * 7;
	}

	exports.cellular2x2 = function(P) {

	    var K = 1/7; // 1/7
	    var K2 = K/2; // K/2
	    var JITTER = 0.7; // JITTER 1.0 makes F1 wrong more often

	    var Pi_x = mod289(Math.floor(P[0]));
	    var Pi_y = mod289(Math.floor(P[1]));
	    var Pf_x = fract(P[0]);
	    var Pf_y = fract(P[1]);
	    var Pfx_x = Pf_x - 0.5;
	    var Pfx_y = Pf_x - 1.5;
	    var Pfx_z = Pfx_x;
	    var Pfx_w = Pfx_y;

	    var Pfy_x = Pf_y - 0.5;
	    var Pfy_y = Pfy_x;
	    var Pfy_z = Pf_y - 1.5;
	    var Pfy_w = Pfy_z;

	    var p_x = permute(Pi_x);
	    var p_y = permute(Pi_x + 1.0);
	    var p_z = p_x;
	    var p_w = p_y;
	    p_x = permute(p_x + Pi_y);
	    p_y = permute(p_y + Pi_y);
	    p_z = permute(p_z + Pi_y + 1.0);
	    p_w = permute(p_w + Pi_y + 1.0);

	    var ox_x = mod7(p_x) * K + K2;
	    var ox_y = mod7(p_y) * K + K2;
	    var ox_z = mod7(p_z) * K + K2;
	    var ox_w = mod7(p_w) * K + K2;

	    var oy_x = mod7(Math.floor(p_x * K)) * K + K2;
	    var oy_y = mod7(Math.floor(p_y * K)) * K + K2;
	    var oy_z = mod7(Math.floor(p_z * K)) * K + K2;
	    var oy_w = mod7(Math.floor(p_w * K)) * K + K2;

	    var dx_x = Pfx_x + JITTER * ox_x;
	    var dx_y = Pfx_y + JITTER * ox_y;
	    var dx_z = Pfx_z + JITTER * ox_z;
	    var dx_w = Pfx_w + JITTER * ox_w;

	    var dy_x = Pfy_x + JITTER * oy_x;
	    var dy_y = Pfy_y + JITTER * oy_y;
	    var dy_z = Pfy_z + JITTER * oy_z;
	    var dy_w = Pfy_w + JITTER * oy_w;

	    // d11, d12, d21 and d22, squared
	    var d_x = dx_x * dx_x + dy_x * dy_x;
	    var d_y = dx_y * dx_y + dy_y * dy_y;
	    var d_z = dx_z * dx_z + dy_z * dy_z;
	    var d_w = dx_w * dx_w + dy_w * dy_w;

	    // sort out the two smallest distances
	    // cheat and pick only F1
	    var d = Math.min(d_x, d_y, d_z, d_w);
	    return d;
	};

	exports.quat_project = function(quat, quat_ident_dir,
	        plane, plane_ident_dir, dest) {
	    if (!dest)
	        dest = new Float32Array(4);

	    var to = m_vec3.transformQuat(quat_ident_dir, quat, _vec3_tmp);

	    var a = plane[0];
	    var b = plane[1];
	    var c = plane[2];

	    // plane project matrix
	    var proj = _mat3_tmp;

	    proj[0] = b*b + c*c;
	    proj[1] =-b*a;
	    proj[2] =-c*a;
	    proj[3] =-a*b;
	    proj[4] = a*a + c*c;
	    proj[5] =-c*b;
	    proj[6] =-a*c;
	    proj[7] =-b*c;
	    proj[8] = a*a + b*b;

	    m_vec3.transformMat3(to, proj, to);
	    m_vec3.normalize(to, to);
	    m_quat.rotationTo(plane_ident_dir, to, dest);

	    return dest;
	};

	exports.cam_quat_to_mesh_quat = function(cam_quat, dest) {

	    if (!dest)
	        dest = new Float32Array(4);

	    var quat_offset = _vec4_tmp;
	    var quat_offset_x = _vec4_tmp2;
	    quat_offset = m_quat.setAxisAngle([0,0,1], Math.PI, m_quat.create());
	    quat_offset_x = m_quat.setAxisAngle([1,0,0], Math.PI/2, m_quat.create());

	    m_quat.multiply(quat_offset, quat_offset_x, quat_offset);
	    m_quat.multiply(cam_quat, quat_offset, dest);

	    return dest;
	};

	exports.cleanup = function() {
	    _unique_counter = 0;
	    _unique_name_counters = {};
	};

	exports.clamp = clamp;
	function clamp(value, min, max) {
	    // NOTE: optimized for intensive usage, much faster than Math.min/Math.max
	    if (value < min)
	        value = min;
	    if (value > max)
	        value = max;
	    return value;
	}

	exports.smooth = function(curr, last, delta, period) {

	    if (period) {
	        var e = Math.exp(-delta/period);
	        return (1 - e) * curr + e * last;
	    } else
	        return curr;
	};

	/**
	 * Perform exponential smoothing (vector form).
	 */
	exports.smooth_v = function(curr, last, delta, period, dest) {
	    if (!dest)
	        dest = new Float32Array(curr.length);

	    if (period) {
	        var e = Math.exp(-delta/period);

	        for (var i = 0; i < dest.length; i++)
	            dest[i] = (1 - e) * curr[i] + e * last[i];
	    } else
	        m_vec3.copy(curr, dest);

	    return dest;
	};

	/**
	 * Perform exponential smoothing (quaternion form).
	 */
	exports.smooth_q = function(curr, last, delta, period, dest) {
	    if (!dest)
	        dest = new Float32Array(curr.length);

	    if (period) {
	        var e = Math.exp(-delta/period);
	        m_quat.slerp(curr, last, e, dest);
	    } else 
	        m_quat.copy(curr, dest);

	    return dest;
	};

	/**
	 * Check if object is instance of ArrayBufferView.
	 * switch to ArrayBuffer.isView() when available.
	 */
	exports.is_arr_buf_view = function(o) {
	    if (typeof o === "object" && o.buffer && o.buffer instanceof ArrayBuffer)
	        return true;
	    else
	        return false;
	};

	exports.is_vector = function(o, dimension) {
	    if (o instanceof Array || (o.buffer && o.buffer instanceof ArrayBuffer)) {
	        if (dimension && dimension == o.length)
	            return true;
	        else if (dimension)
	            return false;
	        else
	            return true;
	    }

	    return false;
	};

	exports.correct_cam_quat_up = function(quat, up_only) {

	    // convenient to get 3x3 matrix
	    var rmat = m_mat3.fromQuat(quat, _mat3_tmp);

	    // local camera Z in world space
	    var z_cam_world = _vec3_tmp;
	    z_cam_world[0] = rmat[6];
	    z_cam_world[1] = rmat[7];
	    z_cam_world[2] = rmat[8];

	    var x_cam_world_new = m_vec3.cross(AXIS_Z, z_cam_world, z_cam_world);
	    m_vec3.normalize(x_cam_world_new, x_cam_world_new);

	    // Z coord of local camera MY axis in world space
	    var my_cam_world_z = rmat[4];
	    if (!up_only && my_cam_world_z > 0) {
	        x_cam_world_new[0] *= -1;
	        x_cam_world_new[1] *= -1;
	        x_cam_world_new[2] *= -1;
	    }

	    var x_cam_world = _vec3_tmp2;
	    x_cam_world[0] = rmat[0];
	    x_cam_world[1] = rmat[1];
	    x_cam_world[2] = rmat[2];
	    m_vec3.normalize(x_cam_world, x_cam_world);

	    var correct_quat = _vec4_tmp2;
	    m_quat.rotationTo(x_cam_world, x_cam_world_new, correct_quat);
	    m_quat.multiply(correct_quat, quat, quat);
	};

	exports.get_array_smooth_value = function(array, row_width, x, y) {
	    // get coordinates
	    var px = x * row_width - 0.5;
	    var py = y * row_width - 0.5;

	    var fract_px = px - Math.floor(px);
	    var fract_py = py - Math.floor(py);

	    px = Math.floor(px);
	    py = Math.floor(py);

	    var up_lim = row_width - 1;

	    var val_00 = array[py * row_width + px];
	    var val_10 = array[py * row_width + Math.min(px+1, up_lim)];
	    var val_01 = array[Math.min(py+1, up_lim) * row_width + px];
	    var val_11 = array[Math.min(py+1, up_lim) * row_width
	                                 + Math.min(px+1, up_lim)];

	    // distance on bottom, top edge
	    var val_0010 = val_00 * (1 - fract_px) + val_10 * fract_px;
	    var val_0111 = val_01 * (1 - fract_px) + val_11 * fract_px;

	    var smooth_value = val_0010 * (1 - fract_py) + val_0111 * fract_py;

	    return smooth_value;
	};

	/**
	 * Returns count of used RGB channels by binary mask
	 */
	exports.rgb_mask_get_channels_count = function(mask) {
	    var count = 0;
	    for (var i = 0; i < 3; i++)
	        if ((mask & 1<<i) > 0) {
	            count++;
	        }
	    return count;
	};

	/**
	 * Returns usage list of RGB channels by binary mask
	 */
	exports.rgb_mask_get_channels_presence = rgb_mask_get_channels_presence;
	function rgb_mask_get_channels_presence(mask) {
	    var presence = [0,0,0];
	    for (var i = 0; i < 3; i++)
	        if ((mask & 1<<i) > 0) {
	            presence[2 - i] = 1;
	        }
	    return presence;
	}

	/**
	 * Returns index of RGB channel considering channels presence
	 * Channels order: R = 0, G = 1, B = 2
	 */
	exports.rgb_mask_get_channel_presence_index = function(mask, channel) {
	    var index = 0;
	    if ((channel == 1) || (channel == 2))
	        if ((mask & 1<<2) > 0)
	            index++;
	    if (channel == 2)
	        if ((mask & 1<<1) > 0)
	            index++;

	    return index;
	};

	/**
	 * Generate uuid compliant with RFC 4122 version 4 (http://tools.ietf.org/html/rfc4122)
	 * Taken from http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	 */
	exports.gen_uuid = function() {
	    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
	        var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
	        return v.toString(16);
	    });
	};

	exports.get_dict_length = function(dict) {
	    var count = 0;
	    for (var prop in dict)
	        if (dict.hasOwnProperty(prop))
	            count++;
	    return count;
	};

	exports.random_from_array = function(array) {

	    if (!array.length)
	        return null;

	    var pos = Math.floor(Math.random() * array.length);
	    return array[pos];
	};

	exports.horizontal_direction = function(a, b, dest) {

	    if (!dest)
	        dest = new Float32Array(3);

	    dest[0] = a[0] - b[0];
	    dest[1] = a[1] - b[1];
	    dest[2] = 0;
	    m_vec3.normalize(dest, dest);
	};

	/**
	 * Transforms the vec3 with a quat (alternative implementation)
	 *
	 * @param {Vec3} out the receiving vector
	 * @param {Vec3} a the vector to transform
	 * @param {Quat} q quaternion to transform with
	 * @returns {Vec3} out
	 */
	exports.transformQuatFast = function(a, q, out) {
	    // nVidia SDK implementation
	    var ax = a[0], ay = a[1], az = a[2];
	    var qx = q[0], qy = q[1], qz = q[2], qw = q[3];

	    // var qvec = [qx, qy, qz];
	    // var uv = vec3.cross([], qvec, a);
	    var uvx = qy * az - qz * ay,
	        uvy = qz * ax - qx * az,
	        uvz = qx * ay - qy * ax;

	    // var uuv = vec3.cross([], qvec, uv);
	    var uuvx = qy * uvz - qz * uvy,
	        uuvy = qz * uvx - qx * uvz,
	        uuvz = qx * uvy - qy * uvx;

	    // vec3.scale(uv, uv, 2 * w);
	    uvx *= qw * 2;
	    uvy *= qw * 2;
	    uvz *= qw * 2;

	    // vec3.scale(uuv, uuv, 2);
	    uuvx *= 2;
	    uuvy *= 2;
	    uuvz *= 2;

	    // return vec3.add(out, a, vec3.add(out, uv, uuv));
	    out[0] = ax + uvx + uuvx;
	    out[1] = ay + uvy + uuvy;
	    out[2] = az + uvz + uuvz;
	    return out;
	};

	exports.assert = function(cond) {
	    if (!cond)
	        panic("Assertion failed");
	};

	exports.panic = panic;
	function panic(s) {
	    if (s)
	        m_print.error.apply(m_print, arguments);
	    throw "engine panic:\n" +
	          "The engine tried to perform an invalid operation and halted.\n" +
	          "Please copy the console contents above and submit it to the Blend4Web forum at\n" +
	          "https://www.blend4web.com/en/forums/forum/17/";
	}

	/**
	 * Convert radian angle into range [from, to)
	 */
	exports.angle_wrap_periodic = angle_wrap_periodic;
	function angle_wrap_periodic(angle, from, to) {
	    var rel_angle = angle - from; // 2Pi
	    var period = to - from; // 2Pi
	    return from + (rel_angle - Math.floor(rel_angle / period) * period); //-Pi + (2Pi - 2Pi)
	}

	exports.angle_wrap_0_2pi = angle_wrap_0_2pi;
	function angle_wrap_0_2pi(angle) {
	    return angle_wrap_periodic(angle, 0, 2 * Math.PI);
	}

	exports.get_file_extension = function(file_path) {
	    var re = /(?:\.([^.]+))?$/;
	    return re.exec(file_path)[1];
	};

	/**
	 * Check strictly typed objects equality: batch, render.
	 * NOTE: do not check the difference between Array and TypedArray
	 */
	exports.strict_objs_is_equal = strict_objs_is_equal;
	function strict_objs_is_equal(a, b) {
	    for (var prop in a) {
	        var props_is_equal = true;

	        var val1 = a[prop];
	        var val2 = b[prop];

	        // typeof val1 == typeof val2 for strictly typed objects
	        switch (typeof val1) {
	        case "number":
	        case "string":
	        case "boolean":
	            props_is_equal = val1 == val2;
	            break;
	        case "object":
	            props_is_equal = objs_is_equal(val1, val2);
	            break;
	        // true for other cases ("function", "undefined")
	        default:
	            break;
	        }

	        if (!props_is_equal)
	            return false;
	    }

	    return true;
	}

	/**
	 * Check objects equality
	 */
	function objs_is_equal(a, b) {
	    // checking not-null objects
	    if (a && b) {
	        // array checking
	        var a_is_arr = a instanceof Array;
	        var b_is_arr = b instanceof Array;
	        if (a_is_arr != b_is_arr)
	            return false;

	        var a_is_typed_arr = a.buffer instanceof ArrayBuffer
	                && a.byteLength !== "undefined";
	        var b_is_typed_arr = b.buffer instanceof ArrayBuffer
	                && b.byteLength !== "undefined";
	        if (a_is_typed_arr != b_is_typed_arr)
	            return false;

	        if (a_is_arr) {
	            if (a.length != b.length)
	                return false;
	            for (var i = 0; i < a.length; i++)
	                if (!vars_is_equal(a[i], b[i]))
	                    return false;
	        } else if (a_is_typed_arr) {
	            if (a.length != b.length)
	                return false;
	            for (var i = 0; i < a.length; i++)
	                if (a[i] != b[i])
	                    return false;
	        } else {
	            // NOTE: some additional props could be added to GL-type objs
	            // so don't iterate over their props
	            switch (a.constructor) {
	            case WebGLUniformLocation:
	            case WebGLProgram:
	            case WebGLShader:
	            case WebGLFramebuffer:
	            case WebGLRenderbuffer:
	            case WebGLTexture:
	            case WebGLBuffer:
	                return a == b;
	            }

	            for (var prop in a) {
	                if (!vars_is_equal(a[prop], b[prop]))
	                    return false;
	            }
	            for (var prop in b)
	                if (!(prop in a))
	                    return false;
	        }
	        return true;
	    } else
	        return !(a || b);
	}

	/**
	 * Check variables equality
	 */
	function vars_is_equal(a, b) {
	    if (typeof a != typeof b)
	        return false;

	    switch (typeof a) {
	    case "number":
	    case "string":
	    case "boolean":
	        return a == b;
	    case "object":
	        return objs_is_equal(a, b);
	    // true for other cases ("function", "undefined")
	    default:
	        return true;
	    }
	}

	exports.quat_bpy_b4w = function(quat, dest) {
	    var w = quat[0];
	    var x = quat[1];
	    var y = quat[2];
	    var z = quat[3];

	    dest[0] = x;
	    dest[1] = y;
	    dest[2] = z;
	    dest[3] = w;

	    return dest;
	};

	exports.gen_color_id = function(counter) {

	    // black reserved for background
	    counter++;

	    if (counter > 51 * 51 * 51)
	        m_print.error("Color ID pool depleted");

	    // 255 / 5 = 51
	    var r = Math.floor(counter / (51 * 51));
	    counter %= (51 * 51);
	    var g = Math.floor(counter / 51);
	    counter %= 51;
	    var b = counter;

	    var color_id = new Float32Array([r/51, g/51, b/51]);

	    return color_id;
	};

	// see Lengyel E. - Mathematics for 3D Game Programming and Computer Graphics,
	// Third Edition. Chapter 5.2.1 Intersection of a Line and a Plane
	exports.line_plane_intersect = function(pn, p_dist, pline, dest) {
	    // four-dimensional representation of a plane
	    var plane = _vec4_tmp;
	    plane.set(pn);
	    plane[3] = p_dist;

	    // four-dimensional representation of line direction vector
	    var line_dir = _vec4_tmp2;
	    _vec3_tmp[0] = pline[3];
	    _vec3_tmp[1] = pline[4];
	    _vec3_tmp[2] = pline[5];
	    line_dir.set(_vec3_tmp);
	    line_dir[3] = 0;

	    var denominator = m_vec4.dot(plane, line_dir);

	    // parallel case
	    if (denominator == 0.0)
	        return null;

	    // four-dimensional representation of line point
	    var line_point = _vec4_tmp2;
	    m_vec3.copy(pline, _vec3_tmp);
	    line_point.set(_vec3_tmp);
	    line_point[3] = 1;

	    var numerator = m_vec4.dot(plane, line_point);

	    var t = - numerator / denominator;

	    // point of intersection
	    dest[0] = pline[0] + t * pline[3];
	    dest[1] = pline[1] + t * pline[4];
	    dest[2] = pline[2] + t * pline[5];

	    return dest;
	};

	/**
	 * Calculate plane normal by 3 points through the point-normal form of the
	 * plane equation
	 */
	exports.get_plane_normal = function(a, b, c, dest) {
	    var a12 = b[0] - a[0];
	    var a13 = c[0] - a[0];

	    var a22 = b[1] - a[1];
	    var a23 = c[1] - a[1];

	    var a32 = b[2] - a[2];
	    var a33 = c[2] - a[2];

	    dest[0] = a22 * a33 - a32 * a23;
	    dest[1] = a13 * a32 - a12 * a33;
	    dest[2] = a12 * a23 - a22 * a13;

	    return dest;
	};

	/**
	 * Copy the values from one array to another
	 */
	exports.copy_array = function(a, out) {
	    for (var i = 0; i < a.length; i++) {
	        out[i] = a[i];
	    }
	    return out;
	};

	/**
	 * Copied form gl-matrix.js quat.rotationTo() method.
	 * Stable for input vectors which are near-parallel.
	 *
	 * Sets a quaternion to represent the shortest rotation from one
	 * vector to another.
	 *
	 * Both vectors are assumed to be unit length.
	 *
	 * @param {vec3} a the initial vector
	 * @param {vec3} b the destination vector
	 * @param {quat} out the receiving quaternion.
	 * @returns {quat} out
	 */
	exports.rotation_to_stable = rotation_to_stable;
	function rotation_to_stable(a, b, out) {
	    var tmp = _vec3_tmp;
	    var dot = m_vec3.dot(a, b);

	    if (dot < -0.9999999) {
	        m_vec3.cross(AXIS_X, a, tmp);
	        if (m_vec3.length(tmp) < 0.000001)
	            m_vec3.cross(AXIS_Y, a, tmp);
	        m_vec3.normalize(tmp, tmp);
	        m_quat.setAxisAngle(tmp, Math.PI, out);
	    } else {
	        m_vec3.cross(a, b, tmp);
	        out.set(tmp);
	        out[3] = 1 + dot;
	        m_quat.normalize(out, out);
	    }

	    return out;
	}

	/**
	 * Get the angle which returns current angle into range [min_angle, max_angle]
	 */
	exports.calc_returning_angle = function(angle, min_angle, max_angle) {
	    // simple optimization
	    if (min_angle == max_angle)
	        return max_angle - angle;

	    // convert all type of angles (phi, theta) regardless of their domain of definition
	    // for simplicity
	    angle = angle_wrap_0_2pi(angle);
	    min_angle = angle_wrap_0_2pi(min_angle);
	    max_angle = angle_wrap_0_2pi(max_angle);

	    // rotate unit circle to ease calculation
	    var rotation = 2 * Math.PI - min_angle;
	    min_angle = 0;
	    max_angle += rotation;
	    max_angle = angle_wrap_0_2pi(max_angle);
	    angle += rotation;
	    angle = angle_wrap_0_2pi(angle);

	    if (angle > max_angle) {
	        // clamp to the proximal edge
	        var delta_to_max = max_angle - angle;
	        var delta_to_min = 2 * Math.PI - angle;
	        return (- delta_to_max > delta_to_min) ? delta_to_min : delta_to_max;
	    }

	    // clamping not needed
	    return 0;
	};

	exports.smooth_step = function(t, min, max) {
	    if (isFinite(min) && isFinite(max))
	        t = clamp(t, min, max);

	    return t * t * (3.0 - 2.0 * t);
	};

	exports.lerp = function(t, from, to) {
	    return from + t * (to - from);
	};

	exports.arrays_have_common = function(arr_1, arr_2) {
	    for (var i = 0; i < arr_1.length; i++) {
	        for (var k = 0; k < arr_2.length; k++) {
	            if (arr_2[k] == arr_1[i]) {
	                return true;
	            }
	        }
	    }
	    return false;
	};

	exports.create_zero_array = function(length) {
	    var array = new Array(length);

	    for (var i = 0; i < length; i++)
	        array[i] = 0;

	    return array;
	};

	exports.version_cmp = function(ver1, ver2) {
	    var max_len = Math.max(ver1.length, ver2.length);

	    for (var i = 0; i < max_len; i++) {
	        var n1 = (i >= ver1.length) ? 0 : ver1[i];
	        var n2 = (i >= ver2.length) ? 0 : ver2[i];

	        var s = sign(n1 - n2);
	        if (s)
	            return s;
	    }

	    return 0;
	};

	/**
	 * It doesn't worry about leading zeros; unappropriate for date
	 * (month, hour, minute, ...) values.
	 */
	exports.version_to_str = function(ver) {
	    return ver.join(".");
	};

	exports.str_to_version = function(str) {
	    return str.split(".").map(function(val){ return val | 0 });
	};

	exports.srgb_to_lin = function(color, dest) {
	    dest[0] = Math.pow(color[0], GAMMA);
	    dest[1] = Math.pow(color[1], GAMMA);
	    dest[2] = Math.pow(color[2], GAMMA);
	    return dest;
	};

	exports.lin_to_srgb = function(color, dest) {
	    dest[0] = Math.pow(color[0], 1/GAMMA);
	    dest[1] = Math.pow(color[1], 1/GAMMA);
	    dest[2] = Math.pow(color[2], 1/GAMMA);
	    return dest;
	};

	exports.normpath_preserve_protocol = function(dir_path) {
	    var separated_str = dir_path.split('://',2);
	    if (separated_str.length > 1) {
	        separated_str[1] = normpath(separated_str[1]);
	        return separated_str.join('://');
	    } else
	        return normpath(dir_path);
	};

	/**
	 * Normalize path, based on python os.path.normpath() function
	 */
	function normpath(path) {
	    var sep = '/';
	    var empty = '';
	    var dot = '.';
	    var dotdot = '..';

	    if (path == empty)
	        return dot;

	    var initial_slashes = (path.indexOf(sep) == 0) | 0;

	    // allow one or two initial slashes, more than two treats as single
	    if (initial_slashes && (path.indexOf(sep + sep) == 0)
	            && (path.indexOf(sep + sep + sep) != 0))
	        initial_slashes = 2;

	    var comps = path.split(sep);
	    var new_comps = [];
	    for (var i = 0; i < comps.length; i++) {
	        var comp = comps[i];
	        if (comp == empty || comp == dot)
	            continue;
	        if (comp != dotdot || (!initial_slashes && !new_comps.length)
	                || (new_comps.length && (new_comps[new_comps.length - 1] == dotdot)))
	            new_comps.push(comp);
	        else if (new_comps.length)
	            new_comps.pop();
	    }

	    comps = new_comps;
	    path = comps.join(sep);
	    for (var i = 0; i < initial_slashes; i++)
	        path = sep + path;

	    return path || dot;
	}

	exports.check_npot = function(num) {
	    return parseInt(num.toString(2).substr(1), 2) != 0;
	};

	exports.ellipsoid_axes_to_mat3 = function(axis_x, axis_y, axis_z, dest) {
	    dest[0] = axis_x[0];
	    dest[1] = axis_y[0];
	    dest[2] = axis_z[0];
	    dest[3] = axis_x[1];
	    dest[4] = axis_y[1];
	    dest[5] = axis_z[1];
	    dest[6] = axis_x[2];
	    dest[7] = axis_y[2];
	    dest[8] = axis_z[2];

	    return dest;
	};

	/**
	 * Create an empty non-smi Array to store generic objects.
	 * Due to V8 optimizations all emtpy arrays created to store small (31 bit)
	 * integer values. This method prevents such optimization.
	 * @returns {Array} New empty Array
	 */
	exports.create_non_smi_array = create_non_smi_array;
	function create_non_smi_array() {
	    var arr = [{}];
	    arr.length = 0;
	    return arr;
	}

	/**
	 * Converts a float value of range [-1, 1] to a short.
	 */
	exports.float_to_short = function(float_val) {
	    var x = Math.round((float_val + 1) * 32767.5 - 32768);
	    // remove possible negative zero before clamping
	    return clamp(x ? x : 0, -32768, 32767);
	};

	/**
	 * Converts a short value of range [-32768, 32767] to a float.
	 */
	exports.short_to_float = function(short_val) {
	    return clamp((short_val + 32768) / 32767.5 - 1, -1, 1);
	};

	/**
	 * Converts an unsigned float value of range [0, 1] to an unsigned byte.
	 */
	exports.ufloat_to_ubyte = function(ufloat_val) {
	    return clamp(Math.round(ufloat_val * 255), 0, 255);
	};

	/**
	 * Converts an unsigned byte value of range [0, 255] to an unsigned float.
	 */
	exports.ubyte_to_ufloat = function(ubyte_val) {
	    return clamp(ubyte_val / 255, 0, 1);
	};

	exports.dist_to_triange = function(point, ver1, ver2, ver3) {
	    var dir_21 = m_vec3.subtract(ver2, ver1, _vec3_tmp);
	    var dir_32 = m_vec3.subtract(ver3, ver2, _vec3_tmp2);
	    var dir_13 = m_vec3.subtract(ver1, ver3, _vec3_tmp3);
	    var dir_p1 = m_vec3.subtract(point, ver1, _vec3_tmp4);
	    var dir_p2 = m_vec3.subtract(point, ver2, _vec3_tmp5);
	    var dir_p3 = m_vec3.subtract(point, ver3, _vec3_tmp6);

	    var normal = m_vec3.cross(dir_21, dir_32, _vec3_tmp7);

	    if (m_vec3.dot(m_vec3.cross(normal, dir_21, _vec3_tmp8), dir_p1) >= 0 &&
	            m_vec3.dot(m_vec3.cross(normal, dir_32, _vec3_tmp8), dir_p2) >= 0 &&
	            m_vec3.dot(m_vec3.cross(normal, dir_13, _vec3_tmp8), dir_p3) >= 0) {
	        // inside of the triange prism
	        // find distance to plane of the triange
	        var normal_length = m_vec3.length(normal);
	        var ndist = m_vec3.dot(normal, dir_p1);
	        return Math.abs(ndist / normal_length);
	    } else {
	        // outside of the triange prism
	        // find min distance of distances to the 3 edges of the triange
	        var proj_p1_on_21 = m_vec3.scale(dir_21,
	                clamp(m_vec3.dot(dir_21, dir_p1) / m_vec3.length(dir_21), 0, 1), _vec3_tmp8);
	        var dist_to_21 = m_vec3.length(m_vec3.subtract(dir_p1, proj_p1_on_21, _vec3_tmp8));

	        var proj_p2_on_32 = m_vec3.scale(dir_32,
	                clamp(m_vec3.dot(dir_32, dir_p2) / m_vec3.length(dir_32), 0, 1), _vec3_tmp8);
	        var dist_to_32 = m_vec3.length(m_vec3.subtract(dir_p2, proj_p2_on_32, _vec3_tmp8));

	        var proj_p3_on_13 = m_vec3.scale(dir_13,
	                clamp(m_vec3.dot(dir_13, dir_p3) / m_vec3.length(dir_13), 0, 1), _vec3_tmp8);
	        var dist_to_13 = m_vec3.length(m_vec3.subtract(dir_p3, proj_p3_on_13, _vec3_tmp8));

	        return Math.min(Math.min(dist_to_21, dist_to_32), dist_to_13);
	    }
	};

	exports.rotate_quat = function(quat, vertical_axis, d_phi, d_theta, dest) {
	    if (d_phi || d_theta) {
	        var rot_quat = m_quat.identity(_quat_tmp);

	        if (d_phi) {
	            var quat_phi = m_quat.setAxisAngle(vertical_axis, d_phi, _quat_tmp2);
	            m_quat.multiply(rot_quat, quat_phi, rot_quat);
	        }

	        var obj_quat = m_quat.copy(quat, dest);
	        if (d_theta) {
	            var x_world_cam = quat_to_dir(obj_quat, AXIS_X, _vec3_tmp);
	            var quat_theta = m_quat.setAxisAngle(x_world_cam, d_theta, _quat_tmp2);
	            // NOTE: obj_quat->x_world_cam->quat_theta->obj_quat leads to
	            // error accumulation if quat_theta is not normalized
	            m_quat.normalize(quat_theta, quat_theta);
	            m_quat.multiply(rot_quat, quat_theta, rot_quat);
	        }
	        m_quat.multiply(rot_quat, obj_quat, obj_quat);
	        // NOTE: It fixes the issue, when objects dance, when camera change
	        // vertical angle sign (+-)
	        m_quat.normalize(obj_quat, obj_quat);
	    }
	};

	/**
	 * Apply rotation to quat
	 */
	exports.quat_rotate_to_target = quat_rotate_to_target;
	function quat_rotate_to_target(trans, quat, target, dir_axis) {
	    var dir_from = _vec3_tmp2;
	    // NOTE: dir_axis is in local space, it will be directed to the target
	    quat_to_dir(quat, dir_axis, dir_from);
	    m_vec3.normalize(dir_from, dir_from);
	    var dir_to = _vec3_tmp3;
	    m_vec3.subtract(target, trans, dir_to);
	    m_vec3.normalize(dir_to, dir_to);
	    // NOTE: we don't check Math.abs(m_vec3.dot(dir_from, dir_to)) < 0.999999
	    var rotation = rotation_to_stable(dir_from, dir_to, _vec4_tmp);
	    m_quat.multiply(rotation, quat, quat);
	    m_quat.normalize(quat, quat);
	}

	exports.quat_set_vertical_axis = function(quat, axis, target_axis, dir) {
	    // NOTE: axis is obj's vertical axis in local space (from Blender),
	    // target_axis - target's Z one in the world space
	    var curr_axis_w = m_vec3.transformQuat(axis, quat, _vec3_tmp2);
	    var proj = m_vec3.dot(dir, target_axis);
	    var delta = m_vec3.scale(dir, proj, _vec3_tmp3);
	    var complanar_targer = m_vec3.subtract(target_axis, delta, _vec3_tmp3);
	    var rot_quat = m_quat.identity(_quat_tmp);
	    m_vec3.normalize(complanar_targer, complanar_targer);
	    if (Math.abs(m_vec3.dot(curr_axis_w, complanar_targer)) < 0.999999)
	        rotation_to_stable(curr_axis_w, complanar_targer, rot_quat);
	    m_quat.normalize(rot_quat, rot_quat);
	    m_quat.multiply(rot_quat, quat, quat);
	};

	/**
	* it's Blender's void compatible_eul(float eul[3], const float oldrot[3])
	**/
	exports.compatible_euler = function(eul, oldrot) {
	    var pi_thresh = 5.1;
	    var pi_x2 = 2 * Math.PI;

	    var deul = [];

	    for (var i = 0; i < 3; i++) {
	        deul[i] = eul[i] - oldrot[i];
	        if (deul[i] > pi_thresh) {
	            eul[i] -= ( deul[i] / pi_x2) * pi_x2;
	            deul[i] = eul[i] - oldrot[i];
	        }
	        else if (deul[i] < -pi_thresh) {
	            eul[i] += (-deul[i] / pi_x2) * pi_x2;
	            deul[i] = eul[i] - oldrot[i];
	        }
	    }

	    if (Math.abs(deul[0]) > 3.2 && Math.abs(deul[1]) < 1.6 && Math.abs(deul[2]) < 1.6) {
	        if (deul[0] > 0.0)
	            eul[0] -= pi_x2;
	        else
	            eul[0] += pi_x2;
	    }
	    if (Math.abs(deul[1]) > 3.2 && Math.abs(deul[2]) < 1.6 && Math.abs(deul[0]) < 1.6) {
	        if (deul[1] > 0.0)
	            eul[1] -= pi_x2;
	        else
	            eul[1] += pi_x2;
	    }
	    if (Math.abs(deul[2]) > 3.2 && Math.abs(deul[0]) < 1.6 && Math.abs(deul[1]) < 1.6) {
	        if (deul[2] > 0.0)
	            eul[2] -= pi_x2;
	        else
	            eul[2] += pi_x2;
	    }
	};

	exports.rotate_eul = function(beul, eul, dest) {
	    var mat1 = euler_to_rotation_matrix(eul, _mat3_tmp);
	    var mat2 = euler_to_rotation_matrix(beul, _mat3_tmp2);
	    var totmat = m_mat3.multiply(mat2, mat1, _mat3_tmp3);
	    return mat3_to_euler(totmat, dest); 
	};

	function mat3_to_eul_opt(mat, eul1, eul2) {
	    var cy = Math.sqrt(mat[0 * 3 + 0] * mat[0 * 3 + 0] + mat[0 * 3 + 1] * mat[0 * 3 + 1]);
	    // we use the next order: i = 0; j = 1; k = 2;
	    if (cy > 0.000001) {
	        eul1[0] = Math.atan2(mat[1 * 3 + 2], mat[2 * 3 + 2]);
	        eul1[1] = Math.atan2(-mat[0 * 3 + 2], cy);
	        eul1[2] = Math.atan2(mat[0 * 3 + 1], mat[0 * 3 + 0]);

	        eul2[0] = Math.atan2(-mat[1 * 3 + 2], -mat[2 * 3 + 2]);
	        eul2[1] = Math.atan2(-mat[0 * 3 + 2], -cy);
	        eul2[2] = Math.atan2(-mat[0 * 3 + 1], -mat[0 * 3 + 0]);
	    } else {
	        eul1[0] = Math.atan2(-mat[2 * 3 + 1], mat[1 * 3 + 1]);
	        eul1[1] = Math.atan2(-mat[0 * 3 + 2], cy);
	        eul1[2] = 0;

	        m_vec3.copy(eul1, eul2);
	    }
	}

	exports.quat_to_eul_opt = function(quat, oldrot, dest) {
	    var mat = m_mat3.fromQuat(quat, _mat3_tmp);
	    var eul1 = _vec3_tmp;
	    var eul2 = _vec3_tmp2;
	    mat3_to_eul_opt(mat, eul1, eul2);
	    var d1 = Math.abs(eul1[0] - oldrot[0]) + Math.abs(eul1[1] - oldrot[1]) + Math.abs(eul1[2] - oldrot[2]);
	    var d2 = Math.abs(eul2[0] - oldrot[0]) + Math.abs(eul2[1] - oldrot[1]) + Math.abs(eul2[2] - oldrot[2]);

	    var euler = d1 > d2 ? eul2 : eul1;
	    m_vec3.copy(euler, dest);

	    return dest;
	};

	function mat3_to_euler(mat, dest) {
	    var eul1 = _vec3_tmp;
	    var eul2 = _vec3_tmp2;
	    mat3_to_eul_opt(mat, eul1, eul2);

	    var d1 = Math.abs(eul1[0]) + Math.abs(eul1[1]) + Math.abs(eul1[2]);
	    var d2 = Math.abs(eul2[0]) + Math.abs(eul2[1]) + Math.abs(eul2[2]);

	    var euler = d1 > d2 ? eul2 : eul1;
	    m_vec3.copy(euler, dest);

	    return dest;
	}

	}

	var int_util_factory = register("__util", Int_util);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * TSR-8 utility functions
	 * @name tsr
	 * @namespace
	 * @exports exports as tsr
	 */
	function Int_TSR(ns, exports) {

	var m_mat4 = mat4_factory(ns);
	var m_quat = quat_factory(ns);
	var m_util = int_util_factory(ns);
	var m_vec3 = vec3_factory(ns);

	var ZUP_SIN = Math.sin(-Math.PI/4);
	var ZUP_COS = -ZUP_SIN;

	var _vec3_tmp = new Float32Array(3);
	var _quat_tmp = new Float32Array(4);
	var _mat4_tmp = new Float32Array(16);

	exports.create = create;
	function create() {
	    var tsr = new Float32Array(8);
	    tsr[3] = 1;
	    tsr[7] = 1;
	    return tsr;
	}

	exports.clone = function(tsr) {
	    var out = create();
	    copy(tsr, out);
	    return out;
	};

	exports.from_values = function(x, y, z, s, qx, qy, qz, qw) {
	    var tsr = create();
	    tsr[0] = x;
	    tsr[1] = y;
	    tsr[2] = z;
	    tsr[3] = s;
	    tsr[4] = qx;
	    tsr[5] = qy;
	    tsr[6] = qz;
	    tsr[7] = qw;
	    return tsr;
	};

	exports.create_ext = create_ext;
	function create_ext() {
	    var tsr = new Float32Array(9);
	    tsr[3] = 1;
	    tsr[7] = 1;
	    return tsr;
	}

	exports.clone_ext = function(tsr) {
	    var out = create_ext();
	    copy(tsr, out);
	    return out;
	};

	exports.from_values_ext = function(x, y, z, s, qx, qy, qz, qw) {
	    var tsr = create_ext();
	    tsr[0] = x;
	    tsr[1] = y;
	    tsr[2] = z;
	    tsr[3] = s;
	    tsr[4] = qx;
	    tsr[5] = qy;
	    tsr[6] = qz;
	    tsr[7] = qw;
	    return tsr;
	};

	exports.copy = copy;
	function copy(tsr, dest) {
	    // faster than .set()

	    dest[0] = tsr[0];
	    dest[1] = tsr[1];
	    dest[2] = tsr[2];
	    dest[3] = tsr[3];
	    dest[4] = tsr[4];
	    dest[5] = tsr[5];
	    dest[6] = tsr[6];
	    dest[7] = tsr[7];
	    return dest;
	}

	exports.identity = function(tsr) {
	    tsr[0] = 0;
	    tsr[1] = 0;
	    tsr[2] = 0;
	    tsr[3] = 1;
	    tsr[4] = 0;
	    tsr[5] = 0;
	    tsr[6] = 0;
	    tsr[7] = 1;

	    return tsr;
	};

	exports.set_sep = set_sep; 
	/**
	 * Set from separate trans, scale and quat.
	 */
	function set_sep(trans, scale, quat, dest) {
	    dest[0] = trans[0];
	    dest[1] = trans[1];
	    dest[2] = trans[2];
	    dest[3] = scale;
	    dest[4] = quat[0];
	    dest[5] = quat[1];
	    dest[6] = quat[2];
	    dest[7] = quat[3];

	    return dest;
	}

	exports.set_trans = function(trans, dest) {
	    dest[0] = trans[0];
	    dest[1] = trans[1];
	    dest[2] = trans[2];

	    return dest;
	};
	exports.set_scale = function(scale, dest) {
	    dest[3] = scale;

	    return dest;
	};
	exports.set_transcale = function(transcale, dest) {
	    dest[0] = transcale[0];
	    dest[1] = transcale[1];
	    dest[2] = transcale[2];
	    dest[3] = transcale[3];

	    return dest;
	};
	exports.set_quat = function(quat, dest) {
	    dest[4] = quat[0];
	    dest[5] = quat[1];
	    dest[6] = quat[2];
	    dest[7] = quat[3];

	    return dest;
	};

	/**
	 * NOTE: bad for CPU and GC
	 */
	exports.get_trans_view = function(tsr) {
	    return tsr.subarray(0, 3);
	};
	exports.get_trans = function(tsr, dest) {
	    dest[0] = tsr[0];
	    dest[1] = tsr[1];
	    dest[2] = tsr[2];

	    return dest;
	};
	exports.get_scale = function(tsr) {
	    return tsr[3];
	};
	exports.get_transcale = function(tsr, dest) {
	    dest[0] = tsr[0];
	    dest[1] = tsr[1];
	    dest[2] = tsr[2];
	    dest[3] = tsr[3];

	    return dest;
	};
	/**
	 * NOTE: bad for CPU and GC
	 */
	exports.get_quat_view = function(tsr) {
	    return tsr.subarray(4, 8);
	};
	exports.get_quat = get_quat;
	function get_quat(tsr, dest) {
	    dest[0] = tsr[4];
	    dest[1] = tsr[5];
	    dest[2] = tsr[6];
	    dest[3] = tsr[7];

	    return dest;
	}

	exports.invert = function(tsr, dest) {
	    var sc_inv = 1/tsr[3];
	    if (!sc_inv)
	        return null;

	    var tx = tsr[0];
	    var ty = tsr[1];
	    var tz = tsr[2];

	    _quat_tmp[0] = tsr[4];
	    _quat_tmp[1] = tsr[5];
	    _quat_tmp[2] = tsr[6];
	    _quat_tmp[3] = tsr[7];

	    m_quat.invert(_quat_tmp, _quat_tmp);

	    var qx_inv = _quat_tmp[0];
	    var qy_inv = _quat_tmp[1];
	    var qz_inv = _quat_tmp[2];
	    var qw_inv = _quat_tmp[3];

	    // scale and rotate
	    var x = tx * sc_inv;
	    var y = ty * sc_inv;
	    var z = tz * sc_inv;

	    // quat * vec
	    var ix = qw_inv * x + qy_inv * z - qz_inv * y;
	    var iy = qw_inv * y + qz_inv * x - qx_inv * z;
	    var iz = qw_inv * z + qx_inv * y - qy_inv * x;
	    var iw = -qx_inv * x - qy_inv * y - qz_inv * z;

	    // result * inverse quat
	    dest[0] = -(ix * qw_inv + iw * -qx_inv + iy * -qz_inv - iz * -qy_inv);
	    dest[1] = -(iy * qw_inv + iw * -qy_inv + iz * -qx_inv - ix * -qz_inv);
	    dest[2] = -(iz * qw_inv + iw * -qz_inv + ix * -qy_inv - iy * -qx_inv);

	    dest[3] = sc_inv;
	    dest[4] = qx_inv;
	    dest[5] = qy_inv;
	    dest[6] = qz_inv;
	    dest[7] = qw_inv;

	    return dest;
	};

	exports.to_mat4 = function(tsr, dest) {
	    var trans = tsr.subarray(0, 3);
	    var scale = tsr[3];
	    var quat = tsr.subarray(4, 8);

	    m_mat4.fromRotationTranslation(quat, trans, dest);

	    for (var i = 0; i < 12; i++)
	        dest[i] *= scale;

	    return dest;
	};

	/**
	 * NOTE: not optimized
	 */
	exports.from_mat4 = function(mat, dest) {
	    var trans = m_util.matrix_to_trans(mat, _vec3_tmp);
	    var scale = m_util.matrix_to_scale(mat);
	    var quat = m_util.matrix_to_quat(mat, _quat_tmp);
	    set_sep(trans, scale, quat, dest);
	    return dest;
	};

	/**
	 * Multiply two TSRs.
	 */
	exports.multiply = function(tsr, tsr2, dest) {

	    // trans
	    transform_vec3(tsr2, tsr, dest);

	    // scale
	    dest[3] = tsr[3] * tsr2[3];

	    // quat
	    var ax = tsr[4], ay = tsr[5], az = tsr[6], aw = tsr[7],
	            bx = tsr2[4], by = tsr2[5], bz = tsr2[6], bw = tsr2[7];

	    dest[4] = ax * bw + aw * bx + ay * bz - az * by;
	    dest[5] = ay * bw + aw * by + az * bx - ax * bz;
	    dest[6] = az * bw + aw * bz + ax * by - ay * bx;
	    dest[7] = aw * bw - ax * bx - ay * by - az * bz;

	    return dest;
	};

	/**
	 * NOTE: unused, non-optimized
	 */
	exports.transform_mat4 = transform_mat4;
	function transform_mat4(matrix, tsr, dest) {
	    var trans = tsr.subarray(0, 3);
	    var scale = tsr[3];
	    var quat = tsr.subarray(4, 8);

	    var m = m_mat4.fromRotationTranslation(quat, trans, _mat4_tmp);

	    for (var i = 0; i < 12; i++)
	        m[i] *= scale;

	    m_mat4.multiply(m, matrix, dest);

	    return dest;
	}

	exports.transform_vec3 = transform_vec3;
	/**
	 * Transform vec3 by TSR
	 */
	function transform_vec3(vec, tsr, dest) {

	    var tx = tsr[0];
	    var ty = tsr[1];
	    var tz = tsr[2];
	    var scale = tsr[3];
	    var qx = tsr[4];
	    var qy = tsr[5];
	    var qz = tsr[6];
	    var qw = tsr[7];

	    // scale and rotate
	    var x = vec[0] * scale;
	    var y = vec[1] * scale;
	    var z = vec[2] * scale;

	    // quat * vec
	    var ix = qw * x + qy * z - qz * y;
	    var iy = qw * y + qz * x - qx * z;
	    var iz = qw * z + qx * y - qy * x;
	    var iw = -qx * x - qy * y - qz * z;

	    // result * inverse quat
	    dest[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
	    dest[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
	    dest[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;

	    // translate
	    dest[0] += tx;
	    dest[1] += ty;
	    dest[2] += tz;

	    return dest;
	}

	/**
	 * Transform vec3 by inverse TSR
	 */
	exports.transform_vec3_inv = function(vec, tsr, dest) {
	    var tx = tsr[0];
	    var ty = tsr[1];
	    var tz = tsr[2];
	    var scale = tsr[3];

	    // inverse translate
	    var x = vec[0] - tx;
	    var y = vec[1] - ty;
	    var z = vec[2] - tz;

	    var qx = tsr[4];
	    var qy = tsr[5];
	    var qz = tsr[6];
	    var qw = tsr[7];

	    var dot = qx*qx + qy*qy + qz*qz + qw*qw;
	    var inv_dot = dot ? 1.0/dot : 0;

	    qx =-qx * inv_dot;
	    qy =-qy * inv_dot;
	    qz =-qz * inv_dot;
	    qw = qw * inv_dot;

	    // quat * vec
	    var ix = qw * x + qy * z - qz * y;
	    var iy = qw * y + qz * x - qx * z;
	    var iz = qw * z + qx * y - qy * x;
	    var iw =-qx * x - qy * y - qz * z;

	    // result * inverse quat
	    dest[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
	    dest[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
	    dest[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;

	    dest[0] /= scale;
	    dest[1] /= scale;
	    dest[2] /= scale;

	    return dest;
	};

	/**
	 * Tranform vec3 vectors by TSR
	 * optional destination offset in values (not vectors, not bytes)
	 */
	exports.transform_vectors = function(vectors, tsr, new_vectors,
	        dest_offset) {

	    if (!dest_offset)
	        dest_offset = 0;

	    var len = vectors.length;

	    var tx = tsr[0];
	    var ty = tsr[1];
	    var tz = tsr[2];
	    var scale = tsr[3];
	    var qx = tsr[4];
	    var qy = tsr[5];
	    var qz = tsr[6];
	    var qw = tsr[7];

	    for (var i = 0; i < len; i+=3) {
	        // scale and rotate
	        var x = vectors[i] * scale;
	        var y = vectors[i+1] * scale;
	        var z = vectors[i+2] * scale;

	        // quat * vec
	        var ix = qw * x + qy * z - qz * y;
	        var iy = qw * y + qz * x - qx * z;
	        var iz = qw * z + qx * y - qy * x;
	        var iw = -qx * x - qy * y - qz * z;

	        // result * inverse quat
	        new_vectors[dest_offset + i] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
	        new_vectors[dest_offset + i + 1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
	        new_vectors[dest_offset + i + 2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;

	        // translate
	        new_vectors[dest_offset + i] += tx;
	        new_vectors[dest_offset + i + 1] += ty;
	        new_vectors[dest_offset + i + 2] += tz;
	    }

	    return new_vectors;
	};

	/**
	 * Transform directional vec3 vectors by TSR.
	 * optional destination offset in values (not vectors, not bytes)
	 */
	exports.transform_dir_vectors = function(vectors, tsr, new_vectors,
	        dest_offset) {

	    if (!dest_offset)
	        dest_offset = 0;

	    var len = vectors.length;

	    var scale = tsr[3];
	    var qx = tsr[4];
	    var qy = tsr[5];
	    var qz = tsr[6];
	    var qw = tsr[7];

	    for (var i = 0; i < len; i+=3) {
	        // scale and rotate
	        var x = vectors[i] * scale;
	        var y = vectors[i+1] * scale;
	        var z = vectors[i+2] * scale;

	        // quat * vec
	        var ix = qw * x + qy * z - qz * y;
	        var iy = qw * y + qz * x - qx * z;
	        var iz = qw * z + qx * y - qy * x;
	        var iw = -qx * x - qy * y - qz * z;

	        // result * inverse quat
	        new_vectors[dest_offset + i] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
	        new_vectors[dest_offset + i + 1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
	        new_vectors[dest_offset + i + 2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
	    }

	    return new_vectors;
	};

	/**
	 * Transform directional vec3 by TSR.
	 */
	exports.transform_dir_vec3 = function(vec, tsr, new_vec) {

	    var scale = tsr[3];
	    var qx = tsr[4];
	    var qy = tsr[5];
	    var qz = tsr[6];
	    var qw = tsr[7];

	    // scale and rotate
	    var x = vec[0] * scale;
	    var y = vec[1] * scale;
	    var z = vec[2] * scale;

	    // quat * vec
	    var ix = qw * x + qy * z - qz * y;
	    var iy = qw * y + qz * x - qx * z;
	    var iz = qw * z + qx * y - qy * x;
	    var iw = -qx * x - qy * y - qz * z;

	    // result * inverse quat
	    new_vec[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
	    new_vec[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
	    new_vec[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;

	    return new_vec;
	};

	/**
	 * Tranform 4 comp tangent vectors by matrix.
	 * optional destination offset in values (not vectors, not bytes)
	 */
	exports.transform_tangents = function(vectors, tsr, new_vectors, 
	        dest_offset) {

	    if (!dest_offset)
	        dest_offset = 0;

	    var len = vectors.length;

	    var scale = tsr[3];
	    var qx = tsr[4];
	    var qy = tsr[5];
	    var qz = tsr[6];
	    var qw = tsr[7];

	    for (var i = 0; i < len; i+=4) {
	        // scale and rotate
	        var x = vectors[i] * scale;
	        var y = vectors[i+1] * scale;
	        var z = vectors[i+2] * scale;

	        // quat * vec
	        var ix = qw * x + qy * z - qz * y;
	        var iy = qw * y + qz * x - qx * z;
	        var iz = qw * z + qx * y - qy * x;
	        var iw = -qx * x - qy * y - qz * z;

	        // result * inverse quat
	        new_vectors[dest_offset + i] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
	        new_vectors[dest_offset + i + 1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
	        new_vectors[dest_offset + i + 2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
	        // just save exact sign
	        new_vectors[dest_offset + i + 3] = vectors[i + 3];
	    }

	    return new_vectors;
	};

	exports.transform_quat = function(quat, tsr, new_quat) {
	    var rot_quat = get_quat(tsr, _quat_tmp);

	    m_quat.multiply(rot_quat, quat, new_quat);

	    return new_quat;
	};

	/**
	 * Tranform quaternions vectors by tsr.
	 * optional destination offset in values (not vectors, not bytes)
	 */
	exports.transform_quats = function(vectors, tsr, new_vectors,
	        dest_offset) {

	    dest_offset = dest_offset || 0;

	    var rot_quat = get_quat(tsr, _quat_tmp);

	    m_util.quats_multiply_quat(vectors, rot_quat, new_vectors, dest_offset);

	    return new_vectors;
	};

	/**
	 * Perform TSR translation by given vec3
	 */
	exports.translate = function(tsr, vec, dest) {
	    var scale = tsr[3];
	    var qx = tsr[4];
	    var qy = tsr[5];
	    var qz = tsr[6];
	    var qw = tsr[7];

	    // scale and rotate
	    var x = vec[0] * scale;
	    var y = vec[1] * scale;
	    var z = vec[2] * scale;

	    // quat * vec
	    var ix = qw * x + qy * z - qz * y;
	    var iy = qw * y + qz * x - qx * z;
	    var iz = qw * z + qx * y - qy * x;
	    var iw = -qx * x - qy * y - qz * z;

	    // tsr + quat * vec * inverse quat
	    dest[0] = tsr[0] + ix * qw + iw * -qx + iy * -qz - iz * -qy;
	    dest[1] = tsr[1] + iy * qw + iw * -qy + iz * -qx - ix * -qz;
	    dest[2] = tsr[2] + iz * qw + iw * -qz + ix * -qy - iy * -qx;
	    dest[3] = tsr[3];
	    dest[4] = tsr[4];
	    dest[5] = tsr[5];
	    dest[6] = tsr[6];
	    dest[7] = tsr[7];

	    return dest;
	};

	exports.interpolate = function(tsr, tsr2, factor, dest) {
	    // linear
	    var trans = tsr.subarray(0, 3);
	    var trans2 = tsr2.subarray(0, 3);
	    var trans_dst = dest.subarray(0, 3);
	    m_vec3.lerp(trans, trans2, factor, trans_dst);

	    // linear
	    var scale = tsr[3];
	    var scale2 = tsr2[3];
	    dest[3] = scale + factor * (scale2 - scale);

	    // spherical
	    var quat = tsr.subarray(4, 8);
	    var quat2 = tsr2.subarray(4, 8);
	    var quat_dst = dest.subarray(4, 8);
	    m_quat.slerp(quat, quat2, factor, quat_dst);

	    return dest;
	};

	/**
	 * Lineary extrapolate two TSR vectors by given factor.
	 * Yextr = Y1 + (Y1 - Y0) * factor = Y1 * (factor + 1) - Y0 * factor
	 * NOTE: unused, untested, incomplete
	 */
	exports.extrapolate = function(tsr, tsr2, factor, dest) {
	    // linear
	    var trans = tsr.subarray(0, 3);
	    var trans2 = tsr2.subarray(0, 3);
	    var trans_dst = dest.subarray(0, 3);

	    trans_dst[0] = trans2[0]*(factor + 1) - trans[0] * factor;
	    trans_dst[1] = trans2[1]*(factor + 1) - trans[1] * factor;
	    trans_dst[2] = trans2[2]*(factor + 1) - trans[2] * factor;

	    // linear
	    var scale = tsr[3];
	    var scale2 = tsr2[3];
	    dest[3] = scale2*(factor + 1) - scale * factor;

	    // NOTE: currently use linear interpolation and normalization
	    var quat = tsr.subarray(4, 8);
	    var quat2 = tsr2.subarray(4, 8);
	    var quat_dst = dest.subarray(4, 8);

	    // NOTE: expect issues with opposed quats
	    quat_dst[0] = quat2[0]*(factor + 1) - quat[0] * factor;
	    quat_dst[1] = quat2[1]*(factor + 1) - quat[1] * factor;
	    quat_dst[2] = quat2[2]*(factor + 1) - quat[2] * factor;
	    quat_dst[3] = quat2[3]*(factor + 1) - quat[3] * factor;
	    m_quat.normalize(quat_dst, quat_dst);

	    return dest;
	};

	exports.integrate = function(tsr, time, linvel, angvel, dest) {
	    dest[0] = tsr[0] + time * linvel[0];
	    dest[1] = tsr[1] + time * linvel[1];
	    dest[2] = tsr[2] + time * linvel[2];

	    dest[3] = tsr[3];

	    tsr_quat_deriv_angvel(tsr, angvel, dest);

	    dest[4] = tsr[4] + dest[4] * time;
	    dest[5] = tsr[5] + dest[5] * time;
	    dest[6] = tsr[6] + dest[6] * time;
	    dest[7] = tsr[7] + dest[7] * time;
	    tsr_quat_normalize(dest, dest);
	};

	/**
	 * Calculate quaternion derivation dQ/dt = 0.5*W*Q
	 */
	function tsr_quat_deriv_angvel(tsr, angvel, dest) {
	    var wx = angvel[0];
	    var wy = angvel[1];
	    var wz = angvel[2];

	    var qx = tsr[4];
	    var qy = tsr[5];
	    var qz = tsr[6];
	    var qw = tsr[7];

	    // basic multiplication, than scale
	    dest[4] = 0.5*( wx*qw + wy*qz - wz*qy);
	    dest[5] = 0.5*( wy*qw + wz*qx - wx*qz);
	    dest[6] = 0.5*( wz*qw + wx*qy - wy*qx);
	    dest[7] = 0.5*(-wx*qx - wy*qy - wz*qz);
	}

	function tsr_quat_normalize(tsr, dest) {
	    var x = tsr[4];
	    var y = tsr[5];
	    var z = tsr[6];
	    var w = tsr[7];

	    var len = x*x + y*y + z*z + w*w;
	    if (len > 0) {
	        len = 1 / Math.sqrt(len);
	        dest[4] = tsr[4] * len;
	        dest[5] = tsr[5] * len;
	        dest[6] = tsr[6] * len;
	        dest[7] = tsr[7] * len;
	    }
	}

	exports.to_zup_view = function(tsr, dest) {
	    dest[0] = tsr[0];
	    dest[1] = tsr[1];
	    dest[2] = tsr[2];

	    dest[3] = tsr[3];

	    // rotation around global X-axis
	    // sin/cos -PI/4 for -PI/2 rotation
	    var ax = tsr[4], ay = tsr[5], az = tsr[6], aw = tsr[7];
	    var bx = ZUP_SIN, bw = ZUP_COS;

	    dest[4] = ax * bw + aw * bx;
	    dest[5] = ay * bw + az * bx;
	    dest[6] = az * bw - ay * bx;
	    dest[7] = aw * bw - ax * bx;
	};

	exports.to_zup_model = function(tsr, dest) {
	    //location
	    dest[0] = tsr[0];
	    dest[1] = -tsr[2];
	    dest[2] = tsr[1];
	    //scale
	    dest[3] = tsr[3];
	    //rot quaternion
	    dest[4] = tsr[4];
	    dest[5] = -tsr[6];
	    dest[6] = tsr[5];
	    dest[7] = tsr[7];
	};

	}

	var int_tsr_factory = register("__tsr", Int_TSR);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Bounding internal API.
	 * @name boundings
	 * @namespace
	 * @exports exports as boundings
	 */
	function Int_boundings(ns, exports) {

	var m_tsr  = int_tsr_factory(ns);
	var m_util = int_util_factory(ns);
	var m_vec3 = vec3_factory(ns);
	var m_math = int_math_factory(ns);
	var m_mat3 = mat3_factory(ns);

	var _bb_corners_cache = new Float32Array(3 * 8);
	var _vec3_tmp = new Float32Array(3);
	var _vec3_tmp2 = new Float32Array(3);
	var _vec3_tmp3 = new Float32Array(3);
	var _vec3_tmp4 = new Float32Array(3);

	var _mat3_tmp = new Float32Array(9);
	var _mat3_tmp2 = new Float32Array(9);
	var _mat3_tmp3 = new Float32Array(9);

	var ELL_EPS = 0.001;
	var MATRIX_PRES = 0.0005;
	var MIN_SEMIAXIS_LEN = ELL_EPS / 2;

	exports.init_boundings = function() {
	    return {
	        bb: create_bb(),
	        be: create_be(),
	        bs: create_bs()
	    }
	};

	exports.copy_boundings = function(boundings_from, boundings_to) {
	    copy_bb(boundings_from.bb, boundings_to.bb);
	    copy_be(boundings_from.be, boundings_to.be);
	    copy_bs(boundings_from.bs, boundings_to.bs);
	    return boundings_to;
	};

	/**
	 * Create a new bounding box with zero volume.
	 * improper use may lead to ugly bugs.
	 */
	exports.create_bb = create_bb;
	function create_bb() {
	    var bb = {
	        max_x: 0,
	        min_x: 0,
	        max_y: 0,
	        min_y: 0,
	        max_z: 0,
	        min_z: 0
	    };

	    return bb;
	}

	exports.copy_bb = copy_bb;
	function copy_bb(bb_from, bb_to) {
	    bb_to.min_x = bb_from.min_x;
	    bb_to.max_x = bb_from.max_x;
	    bb_to.min_y = bb_from.min_y;
	    bb_to.max_y = bb_from.max_y;
	    bb_to.min_z = bb_from.min_z;
	    bb_to.max_z = bb_from.max_z;
	    return bb_to;
	}

	exports.create_rot_bb = create_rot_bb;
	function create_rot_bb() {
	    var rot_bb = {
	        center : new Float32Array(3),
	        axis_x : new Float32Array(3),
	        axis_y : new Float32Array(3),
	        axis_z : new Float32Array(3)
	    };

	    return rot_bb;
	}

	exports.copy_rot_bb = function(rot_bb_from, rot_bb_to) {
	    m_vec3.copy(rot_bb_from.center, rot_bb_to.center);
	    m_vec3.copy(rot_bb_from.axis_x, rot_bb_to.axis_x);
	    m_vec3.copy(rot_bb_from.axis_y, rot_bb_to.axis_y);
	    m_vec3.copy(rot_bb_from.axis_z, rot_bb_to.axis_z);
	    return rot_bb_to;
	};

	/**
	 * NOTE: definitely not the best style of programming
	 */
	exports.big_bounding_box = function() {
	    return {
	        max_x: 1e12,
	        min_x:-1e12,
	        max_y: 1e12,
	        min_y:-1e12,
	        max_z: 1e12,
	        min_z:-1e12
	    };
	};

	exports.zero_bounding_box = function(dest) {
	    dest.max_x = 0;
	    dest.min_x = 0;
	    dest.max_y = 0;
	    dest.min_y = 0;
	    dest.max_z = 0;
	    dest.min_z = 0;
	    return dest;
	};

	exports.clone_bb = function(bb) {
	    var bb_new = create_bb();
	    copy_bb(bb, bb_new);
	    return bb_new;
	};

	/**
	 * Finds the smallest side of the bounding box
	 */
	exports.calc_min_bb_side = function(bb) {

	    var min = bb.max_x - bb.min_x;

	    var y_size = bb.max_y - bb.min_y;
	    if (y_size < min)
	        min = y_size;

	    var z_size = bb.max_z - bb.min_z;
	    if (z_size < min)
	        min = z_size;

	    return min;
	};

	/**
	 * bb - bounding box to expand
	 * bb_exp - expanding bounding box
	 */
	exports.expand_bounding_box = expand_bounding_box;
	function expand_bounding_box(bb, bb_exp) {

	    var max_x = bb.max_x;
	    var max_y = bb.max_y;
	    var max_z = bb.max_z;
	    var min_x = bb.min_x;
	    var min_y = bb.min_y;
	    var min_z = bb.min_z;

	    bb.max_x = Math.max(bb_exp.max_x, max_x);
	    bb.max_y = Math.max(bb_exp.max_y, max_y);
	    bb.max_z = Math.max(bb_exp.max_z, max_z);
	    bb.min_x = Math.min(bb_exp.min_x, min_x);
	    bb.min_y = Math.min(bb_exp.min_y, min_y);
	    bb.min_z = Math.min(bb_exp.min_z, min_z);

	    return bb;
	}

	exports.bb_from_coords = bb_from_coords;
	function bb_from_coords(coords, begin, end, bb) {

	    var max_x = coords[begin];
	    var max_y = coords[begin + 1];
	    var max_z = coords[begin + 2];
	    var min_x = coords[begin];
	    var min_y = coords[begin + 1];
	    var min_z = coords[begin + 2];

	    for (var i = begin + 3; i < end; i += 3) {
	        var x = coords[i];
	        var y = coords[i + 1];
	        var z = coords[i + 2];

	        max_x = Math.max(max_x, x);
	        max_y = Math.max(max_y, y);
	        max_z = Math.max(max_z, z);

	        min_x = Math.min(min_x, x);
	        min_y = Math.min(min_y, y);
	        min_z = Math.min(min_z, z);
	    }

	    bb.max_x = max_x;
	    bb.max_y = max_y;
	    bb.max_z = max_z;
	    bb.min_x = min_x;
	    bb.min_y = min_y;
	    bb.min_z = min_z;

	    return bb;
	}

	/**
	 * Translate shadow object bounding box corners to shadow scene view space
	 */
	exports.bounding_box_transform = function(bb, tsr, bb_new) {

	    if (!bb_new)
	        bb_new = create_bb();

	    var bb_corners = extract_bb_corners(bb, _bb_corners_cache);

	    m_tsr.transform_vectors(bb_corners, tsr, bb_corners);

	    return bb_from_coords(bb_corners, 0, bb_corners.length, bb_new);
	};
	/**
	 * Extract 8 corner coords from bounding box
	 */
	exports.extract_bb_corners = extract_bb_corners;
	function extract_bb_corners(bb, dest) {

	    if (!dest)
	        dest = new Float32Array(3 * 8);

	    var max_x = bb.max_x;
	    var max_y = bb.max_y;
	    var max_z = bb.max_z;
	    var min_x = bb.min_x;
	    var min_y = bb.min_y;
	    var min_z = bb.min_z;

	    // ugly but fast
	    dest[0] = min_x; dest[1] = min_y; dest[2] = min_z;
	    dest[3] = max_x; dest[4] = min_y; dest[5] = min_z;
	    dest[6] = max_x; dest[7] = max_y; dest[8] = min_z;
	    dest[9] = min_x; dest[10]= max_y; dest[11]= min_z;
	    dest[12]= min_x; dest[13]= min_y; dest[14]= max_z;
	    dest[15]= max_x; dest[16]= min_y; dest[17]= max_z;
	    dest[18]= max_x; dest[19]= max_y; dest[20]= max_z;
	    dest[21]= min_x; dest[22]= max_y; dest[23]= max_z;

	    return dest;
	}


	/**
	 * NOTE: unused
	 * Shrink given bounding box by another
	 * return very small bounding box if shrink contstraints do not affect it
	 */
	exports.shrink_bounding_box = function(bb, bb_shrink, bb_new) {
	    if (!bb_new)
	        bb_new = create_bb();

	    var s_min_x = bb_shrink.min_x;
	    var s_max_x = bb_shrink.max_x;
	    var s_min_y = bb_shrink.min_y;
	    var s_max_y = bb_shrink.max_y;
	    var s_min_z = bb_shrink.min_z;
	    var s_max_z = bb_shrink.max_z;

	    if (s_min_x >= bb.max_x || s_max_x <= bb.min_x ||
	            s_min_y >= bb.max_y || s_max_y <= bb.min_y ||
	            s_min_z >= bb.max_z || s_max_z <= bb.min_z) {

	        // NOTE: do not shrink to zero for proper projection construction
	        bb_new.min_x = -0.1;
	        bb_new.max_x = 0.1;

	        bb_new.min_y = -0.1;
	        bb_new.max_y = 0.1;

	        bb_new.min_z = -0.2;
	        bb_new.max_z = -0.1;

	        return bb_new;
	    }

	    bb_new.min_x = Math.max(bb.min_x, s_min_x);
	    bb_new.max_x = Math.min(bb.max_x, s_max_x);

	    bb_new.min_y = Math.max(bb.min_y, s_min_y);
	    bb_new.max_y = Math.min(bb.max_y, s_max_y);

	    bb_new.min_z = Math.max(bb.min_z, s_min_z);
	    bb_new.max_z = Math.min(bb.max_z, s_max_z);

	    return bb_new;
	};

	/**
	 * Stretch bounding box by factor
	 */
	exports.stretch_bounding_box = function(bb, factor, bb_new) {
	    if (!bb_new)
	        bb_new = create_bb();

	    var size_x = bb.max_x - bb.min_x;
	    var size_y = bb.max_y - bb.min_y;
	    var size_z = bb.max_z - bb.min_z;

	    bb_new.min_x = bb.min_x - 0.5 * (factor - 1) * size_x;
	    bb_new.max_x = bb.max_x + 0.5 * (factor - 1) * size_x;

	    bb_new.min_y = bb.min_y - 0.5 * (factor - 1) * size_y;
	    bb_new.max_y = bb.max_y + 0.5 * (factor - 1) * size_y;

	    bb_new.min_z = bb.min_z - 0.5 * (factor - 1) * size_z;
	    bb_new.max_z = bb.max_z + 0.5 * (factor - 1) * size_z;

	    return bb_new;
	};


	exports.bounding_sphere_transform = function(bs, tsr, bs_new) {

	    if (!bs_new)
	        bs_new = create_bs();

	    m_tsr.transform_vec3(bs.center, tsr, bs_new.center);
	    var scale = m_tsr.get_scale(tsr);
	    bs_new.radius = bs.radius * (scale < 0.0 ? -scale : scale);

	    return bs_new;
	};

	exports.bounding_ellipsoid_transform = function(be, tsr, be_new) {

	    if (!be_new)
	        be_new = create_be();

	    m_tsr.transform_vec3(be.center, tsr, be_new.center);

	    m_vec3.copy(be.axis_x, be_new.axis_x);
	    m_vec3.copy(be.axis_y, be_new.axis_y);
	    m_vec3.copy(be.axis_z, be_new.axis_z);

	    m_tsr.transform_dir_vec3(be_new.axis_x, tsr, be_new.axis_x);
	    m_tsr.transform_dir_vec3(be_new.axis_y, tsr, be_new.axis_y);
	    m_tsr.transform_dir_vec3(be_new.axis_z, tsr, be_new.axis_z);

	    return be_new;
	};

	exports.bounding_rot_box_transform = function(bb, tsr, bb_new) {
	    if (!bb_new)
	        bb_new = create_rot_bb();

	    m_tsr.transform_vec3(bb.center, tsr, bb_new.center);

	    m_vec3.copy(bb.axis_x, bb_new.axis_x);
	    m_vec3.copy(bb.axis_y, bb_new.axis_y);
	    m_vec3.copy(bb.axis_z, bb_new.axis_z);

	    m_tsr.transform_dir_vec3(bb_new.axis_x, tsr, bb_new.axis_x);
	    m_tsr.transform_dir_vec3(bb_new.axis_y, tsr, bb_new.axis_y);
	    m_tsr.transform_dir_vec3(bb_new.axis_z, tsr, bb_new.axis_z);

	    return bb_new;
	};

	exports.bs_from_values = bs_from_values;
	function bs_from_values(radius, center) {
	    var bs = create_bs();
	    m_vec3.copy(center, bs.center);
	    bs.radius = radius;
	    return bs;
	}

	exports.rot_bb_from_values = function(bbrcen, axis_x, axis_y, axis_z, bbrscale) {
	    var bb = create_rot_bb();

	    m_vec3.copy(bbrcen, bb.center);
	    m_vec3.copy(axis_x, bb.axis_x);
	    m_vec3.copy(axis_y, bb.axis_y);
	    m_vec3.copy(axis_z, bb.axis_z);
	    m_vec3.scale(bb.axis_x, bbrscale[0], bb.axis_x);
	    m_vec3.scale(bb.axis_y, bbrscale[1], bb.axis_y);
	    m_vec3.scale(bb.axis_z, bbrscale[2], bb.axis_z);

	    return bb;
	};

	/**
	 * Create bounding sphere with zero volume.
	 * improper use may lead to ugly bugs
	 */
	exports.create_bs = create_bs;
	function create_bs() {
	    return {
	        center: new Float32Array(3),
	        radius: 0
	    };
	}

	exports.copy_bs = copy_bs;
	function copy_bs(bs_from, bs_to) {
	    bs_to.center[0] = bs_from.center[0];
	    bs_to.center[1] = bs_from.center[1];
	    bs_to.center[2] = bs_from.center[2];
	    bs_to.radius = bs_from.radius;
	    return bs_to;
	}

	/**
	 * Create bounding ellipsoid with zero volume.
	 */
	exports.create_be = create_be;
	function create_be() {
	    return {
	        axis_x: new Float32Array(3),
	        axis_y: new Float32Array(3),
	        axis_z: new Float32Array(3),
	        center: new Float32Array(3)
	    };
	}

	exports.copy_be = copy_be;
	function copy_be(be, be_new) {
	    m_vec3.copy(be.axis_x, be_new.axis_x);
	    m_vec3.copy(be.axis_y, be_new.axis_y);
	    m_vec3.copy(be.axis_z, be_new.axis_z);
	    m_vec3.copy(be.center, be_new.center);
	    return be_new;
	}

	exports.clone_be = clone_be;
	function clone_be(be) {
	    var be_new = create_be();
	    copy_be(be, be_new);
	    return be_new;
	}

	exports.clone_bs = clone_bs;
	function clone_bs(bs) {
	    var bs_new = create_bs();
	    copy_bs(bs, bs_new);
	    return bs_new;
	}

	exports.be_from_values = be_from_values;
	function be_from_values(axis_x, axis_y, axis_z, center) {
	    return {
	        axis_x: new Float32Array(axis_x),
	        axis_y: new Float32Array(axis_y),
	        axis_z: new Float32Array(axis_z),
	        center: new Float32Array([center[0], center[1], center[2]])
	    };
	}

	/**
	 * NOTE: definitely not the best style of programming
	 */
	exports.big_bounding_sphere = function(dest) {
	    if (!dest)
	        dest = create_bs();
	    m_vec3.set(0, 0, 0, dest.center);
	    dest.radius = 1e12;
	    return dest;
	};

	exports.expand_bounding_sphere = function(bs, bs_exp) {
	    // GARBAGE

	    // vector between 2 centers
	    var v = m_vec3.subtract(bs_exp.center, bs.center, m_vec3.create());

	    // set explicit direction for concentric spheres
	    if (m_vec3.length(v) == 0)
	        m_vec3.set(1, 0, 0, v);

	    var vn = m_vec3.normalize(v, m_vec3.create());

	    // positive/negative extends
	    var e1p = m_vec3.scale(vn, bs.radius, m_vec3.create());
	    m_vec3.add(e1p, bs.center, e1p);

	    var e1n = m_vec3.scale(vn, -bs.radius, m_vec3.create());
	    m_vec3.add(e1n, bs.center, e1n);

	    var e2p = m_vec3.scale(vn, bs_exp.radius, m_vec3.create());
	    m_vec3.add(e2p, bs_exp.center, e2p);

	    var e2n = m_vec3.scale(vn, -bs_exp.radius, m_vec3.create());
	    m_vec3.add(e2n, bs_exp.center, e2n);

	    var min_max = find_min_max_extent([e1p, e1n, e2p, e2n], vn);

	    var min = min_max[0];
	    var max = min_max[1];

	    bs.center = m_vec3.scale(m_vec3.add(min, max, m_vec3.create()), 0.5,
	            m_vec3.create());
	    bs.radius = m_vec3.length(m_vec3.subtract(max, min, m_vec3.create())) / 2;
	};

	exports.extract_rot_bb_corners = function(bbr, corners) {

	    m_vec3.add(bbr.center, bbr.axis_y, _vec3_tmp);
	    m_vec3.add(_vec3_tmp, bbr.axis_x, _vec3_tmp);
	    m_vec3.add(_vec3_tmp, bbr.axis_z, _vec3_tmp);
	    corners.push(_vec3_tmp[0], _vec3_tmp[1], _vec3_tmp[2]);

	    m_vec3.add(bbr.center, bbr.axis_y, _vec3_tmp);
	    m_vec3.add(_vec3_tmp, bbr.axis_x, _vec3_tmp);
	    m_vec3.subtract(_vec3_tmp, bbr.axis_z, _vec3_tmp);
	    corners.push(_vec3_tmp[0], _vec3_tmp[1], _vec3_tmp[2]);

	    m_vec3.add(bbr.center, bbr.axis_y, _vec3_tmp);
	    m_vec3.subtract(_vec3_tmp, bbr.axis_x, _vec3_tmp);
	    m_vec3.add(_vec3_tmp, bbr.axis_z, _vec3_tmp);
	    corners.push(_vec3_tmp[0], _vec3_tmp[1], _vec3_tmp[2]);

	    m_vec3.add(bbr.center, bbr.axis_y, _vec3_tmp);
	    m_vec3.subtract(_vec3_tmp, bbr.axis_x, _vec3_tmp);
	    m_vec3.subtract(_vec3_tmp, bbr.axis_z, _vec3_tmp);
	    corners.push(_vec3_tmp[0], _vec3_tmp[1], _vec3_tmp[2]);

	    m_vec3.subtract(bbr.center, bbr.axis_y, _vec3_tmp);
	    m_vec3.add(_vec3_tmp, bbr.axis_x, _vec3_tmp);
	    m_vec3.add(_vec3_tmp, bbr.axis_z, _vec3_tmp);
	    corners.push(_vec3_tmp[0], _vec3_tmp[1], _vec3_tmp[2]);

	    m_vec3.subtract(bbr.center, bbr.axis_y, _vec3_tmp);
	    m_vec3.add(_vec3_tmp, bbr.axis_x, _vec3_tmp);
	    m_vec3.subtract(_vec3_tmp, bbr.axis_z, _vec3_tmp);
	    corners.push(_vec3_tmp[0], _vec3_tmp[1], _vec3_tmp[2]);

	    m_vec3.subtract(bbr.center, bbr.axis_y, _vec3_tmp);
	    m_vec3.subtract(_vec3_tmp, bbr.axis_x, _vec3_tmp);
	    m_vec3.add(_vec3_tmp, bbr.axis_z, _vec3_tmp);
	    corners.push(_vec3_tmp[0], _vec3_tmp[1], _vec3_tmp[2]);

	    m_vec3.subtract(bbr.center, bbr.axis_y, _vec3_tmp);
	    m_vec3.subtract(_vec3_tmp, bbr.axis_x, _vec3_tmp);
	    m_vec3.subtract(_vec3_tmp, bbr.axis_z, _vec3_tmp);
	    corners.push(_vec3_tmp[0], _vec3_tmp[1], _vec3_tmp[2]);
	};

	/**
	 * see Lengyel E. - Mathematics for 3D Game Programming and Computer Graphics,
	 * Third Edition. Chapter 8.1.4 Bounding Ellipsoid Construction
	 **/
	exports.create_be_by_bb = create_be_by_bb;
	function create_be_by_bb(points, use_rotation) {

	    var center = m_math.calk_average_position(points, _vec3_tmp4);

	    if (use_rotation)
	        var cov_matrix = m_math.calc_covariance_matrix(points, center, _mat3_tmp2);
	    else
	        var cov_matrix = m_mat3.identity(_mat3_tmp2);

	    var t_mat = m_math.find_eigenvectors(cov_matrix, MATRIX_PRES, _mat3_tmp);

	    m_vec3.copy(points, _vec3_tmp);
	    m_vec3.transformMat3(_vec3_tmp, t_mat, _vec3_tmp);

	    var max_dot_x = _vec3_tmp[0];
	    var min_dot_x = max_dot_x;
	    var max_dot_y = _vec3_tmp[1];
	    var min_dot_y = max_dot_y;
	    var max_dot_z = _vec3_tmp[2];
	    var min_dot_z = max_dot_z;

	    var max_x = 0;
	    var min_x = 0;
	    var max_y = 0;
	    var min_y = 0;
	    var max_z = 0;
	    var min_z = 0;

	    for (var i = 3; i < points.length; i = i + 3) {

	        _vec3_tmp[0] = points[i];
	        _vec3_tmp[1] = points[i + 1];
	        _vec3_tmp[2] = points[i + 2];

	        m_vec3.transformMat3(_vec3_tmp, t_mat, _vec3_tmp);

	        var dot_x = _vec3_tmp[0];
	        var dot_y = _vec3_tmp[1];
	        var dot_z = _vec3_tmp[2];

	        if (dot_x > max_dot_x)
	            max_dot_x = dot_x;
	        if (dot_x < min_dot_x)
	            min_dot_x = dot_x;
	        if (dot_y > max_dot_y)
	            max_dot_y = dot_y;
	        if (dot_y < min_dot_y)
	            min_dot_y = dot_y;
	        if (dot_z > max_dot_z)
	            max_dot_z = dot_z;
	        if (dot_z < min_dot_z)
	            min_dot_z = dot_z;
	    }

	    var a = max_dot_x - min_dot_x;
	    var b = max_dot_y - min_dot_y;
	    var c = max_dot_z - min_dot_z;

	    a = Math.max(a, ELL_EPS);
	    b = Math.max(b, ELL_EPS);
	    c = Math.max(c, ELL_EPS);

	    var scale_mat = m_mat3.identity(_mat3_tmp2);
	    scale_mat[0] = a != 0.0 ? 1 / a : 1 / MIN_SEMIAXIS_LEN;
	    scale_mat[4] = b != 0.0 ? 1 / b : 1 / MIN_SEMIAXIS_LEN;
	    scale_mat[8] = c != 0.0 ? 1 / c : 1 / MIN_SEMIAXIS_LEN;

	    m_mat3.transpose(t_mat, _mat3_tmp3);
	    // transform vertex set into cube

	    _vec3_tmp[0] = points[0];
	    _vec3_tmp[1] = points[1];
	    _vec3_tmp[2] = points[2];

	    m_vec3.transformMat3(_vec3_tmp, t_mat, _vec3_tmp);
	    m_vec3.transformMat3(_vec3_tmp, scale_mat, _vec3_tmp);
	    m_vec3.transformMat3(_vec3_tmp, _mat3_tmp3, _vec3_tmp);

	    max_x = _vec3_tmp[0], min_x = _vec3_tmp[0];
	    max_y = _vec3_tmp[1], min_y = _vec3_tmp[1];
	    max_z = _vec3_tmp[2], min_z = _vec3_tmp[2];

	    for (var i = 3; i < points.length; i = i + 3) {
	        _vec3_tmp[0] = points[i];
	        _vec3_tmp[1] = points[i + 1];
	        _vec3_tmp[2] = points[i + 2];
	        m_vec3.transformMat3(_vec3_tmp, t_mat, _vec3_tmp);
	        m_vec3.transformMat3(_vec3_tmp, scale_mat, _vec3_tmp);
	        m_vec3.transformMat3(_vec3_tmp, _mat3_tmp3, _vec3_tmp);

	        max_x = Math.max(max_x, _vec3_tmp[0]);
	        min_x = Math.min(min_x, _vec3_tmp[0]);

	        max_y = Math.max(max_y, _vec3_tmp[1]);
	        min_y = Math.min(min_y, _vec3_tmp[1]);

	        max_z = Math.max(max_z, _vec3_tmp[2]);
	        min_z = Math.min(min_z, _vec3_tmp[2]);
	    }

	    var r = Math.sqrt((max_x - min_x) * (max_x - min_x)
	            + (max_y - min_y) * (max_y - min_y)
	            + (max_z - min_z) * (max_z - min_z)) / 2;

	    r = Math.min(r, 1.0);
	    _vec3_tmp3[0] = (max_x + min_x) / 2;
	    _vec3_tmp3[1] = (max_y + min_y) / 2;
	    _vec3_tmp3[2] = (max_z + min_z) / 2;
	    var s_center = _vec3_tmp3;

	    scale_mat = m_mat3.identity(_mat3_tmp2);
	    scale_mat[0] = a;
	    scale_mat[4] = b;
	    scale_mat[8] = c;

	    m_vec3.transformMat3(s_center, t_mat, s_center);
	    m_vec3.transformMat3(s_center, scale_mat, s_center);
	    m_vec3.transformMat3(s_center, _mat3_tmp3, s_center);

	    var axis_x = [t_mat[0], t_mat[3], t_mat[6]];
	    var axis_y = [t_mat[1], t_mat[4], t_mat[7]];
	    var axis_z = [t_mat[2], t_mat[5], t_mat[8]];

	    m_vec3.scale(axis_x, a * r, axis_x);
	    m_vec3.scale(axis_y, b * r, axis_y);
	    m_vec3.scale(axis_z, c * r, axis_z);

	    return be_from_values(axis_x, axis_y, axis_z, s_center);
	}

	exports.create_bbr_by_be = function(be) {
	    var bbr = create_rot_bb();

	    m_vec3.copy(be.axis_x, bbr.axis_x);
	    m_vec3.copy(be.axis_y, bbr.axis_y);
	    m_vec3.copy(be.axis_z, bbr.axis_z);
	    m_vec3.copy(be.center, bbr.center);

	    return bbr;
	};

	exports.create_bs_by_be = function(be) {
	    var bs = create_bs();

	    var radius = 0;
	    var a = m_vec3.length(be.axis_x);
	    var b = m_vec3.length(be.axis_y);
	    var c = m_vec3.length(be.axis_z);
	    radius = a > b? a: b;
	    radius = c > radius? c: radius;

	    bs.center = be.center;
	    bs.radius = radius;

	    return bs;
	};

	exports.is_be_optimized = function(be, bs) {
	    var a = m_vec3.length(be.axis_x);
	    var b = m_vec3.length(be.axis_y);
	    var c = m_vec3.length(be.axis_z);
	    var be_volume = a * b * c;
	    var bs_volume = bs.radius * bs.radius * bs.radius;
	    return 0.75 * bs_volume > be_volume;
	};


	/**
	 * Find minimum/maximum extent in direction dir
	 */
	function find_min_max_extent(exts, dir) {
	    var dir_n = m_vec3.normalize(dir, m_vec3.create());

	    var min = exts[0];
	    var max = exts[0];
	    for (var i = 1; i < exts.length; i++) {
	        var proj = m_vec3.dot(exts[i], dir_n);

	        if (proj < m_vec3.dot(min, dir_n))
	            min = exts[i];

	        if (proj > m_vec3.dot(max, dir_n))
	            max = exts[i];
	    }

	    return [min, max];
	}

	exports.init_bcap = exports.init_bcyl = exports.init_bcon = init_bcap_bcyl_bcon;
	function init_bcap_bcyl_bcon() {
	    return {
	        radius: 0,
	        height: 0,
	        center: new Float32Array(3)
	    }
	}

	/**
	 * Create a bounding capsule based on the given parameters.
	 */
	exports.bcap_from_values = function(radius, bounding_box) {

	    var max_z = bounding_box.max_z;
	    var min_z = bounding_box.min_z;

	    var height = Math.max(0, (max_z - min_z) - 2*radius);

	    var bcap_local = init_bcap_bcyl_bcon();
	    bcap_local.radius = radius;
	    bcap_local.height = height;

	    bcap_local.center[0] = 0;
	    bcap_local.center[1] = 0;
	    bcap_local.center[2] = (max_z + min_z) / 2;

	    return bcap_local;
	};

	/**
	 * Create a bounding cylinder based on the given parameters.
	 */
	exports.bcyl_from_values = function(radius, bounding_box) {

	    var max_z = bounding_box.max_z;
	    var min_z = bounding_box.min_z;

	    var height = Math.max(0, max_z - min_z);

	    var bcyl_local = init_bcap_bcyl_bcon();
	    bcyl_local.radius = radius;
	    bcyl_local.height = height;

	    bcyl_local.center[0] = 0;
	    bcyl_local.center[1] = 0;
	    bcyl_local.center[2] = (max_z + min_z) / 2;

	    return bcyl_local;
	};

	/**
	 * Create a bounding cone based on the given parameters.
	 */
	exports.bcon_from_values = function(radius, bounding_box) {

	    var max_z = bounding_box.max_z;
	    var min_z = bounding_box.min_z;

	    var height = Math.max(0, max_z - min_z);

	    var bcon_local = init_bcap_bcyl_bcon();
	    bcon_local.radius = radius;
	    bcon_local.height = height;

	    bcon_local.center[0] = 0;
	    bcon_local.center[1] = 0;
	    bcon_local.center[2] = (max_z + min_z) / 2;

	    return bcon_local;
	};

	exports.copy_bcap = exports.copy_bcyl = exports.copy_bcon = copy_bcap_bcyl_bcon;
	function copy_bcap_bcyl_bcon(bcap_bcyl_bcon_from, bcap_bcyl_bcon_to) {
	    bcap_bcyl_bcon_to.radius = bcap_bcyl_bcon_from.radius;
	    bcap_bcyl_bcon_to.height = bcap_bcyl_bcon_from.height;
	    bcap_bcyl_bcon_to.center.set(bcap_bcyl_bcon_from.center);

	    return bcap_bcyl_bcon_to;
	}

	/**
	 * @deprecated unused
	 */
	exports.check_bb_intersection = function(bb1, bb2) {
	    if (bb1.min_x > bb2.max_x || bb1.max_x < bb2.min_x)
	        return false;
	    else if (bb1.min_y > bb2.max_y || bb1.max_y < bb2.min_y)
	        return false;
	    else if (bb1.min_z > bb2.max_z || bb1.max_z < bb2.min_z)
	        return false;
	    else
	        return true;
	};

	/**
	 * Recalculate bpy mesh boundings
	 * NOTE: need rewrite like m_obj_util.update_render_bounds_from_pos_arrays?
	 */
	exports.recalculate_mesh_boundings = function(bpy_mesh) {

	    var srad = 0;
	    var crad = 0;

	    var mesh_bb = create_bb();
	    for (var i = 0; i < bpy_mesh["submeshes"].length; i++) {
	        var submesh = bpy_mesh["submeshes"][i];

	        var positions = submesh["position"];

	        for (var j = 0; j < positions.length / 3; j++) {
	            var x = positions[3 * j];
	            var y = positions[3 * j + 1];
	            var z = positions[3 * j + 2];

	            srad = Math.max(Math.sqrt(x * x + y * y + z * z), srad);
	            crad = Math.max(Math.sqrt(x * x + y * y), crad);
	        }
	        
	        var bpy_sub_bb = submesh["boundings"]["bb"];
	        var sub_bb = bb_from_coords(positions, 0, positions.length, create_bb());
	        bpy_sub_bb["max_x"] = sub_bb.max_x;
	        bpy_sub_bb["min_x"] = sub_bb.min_x;
	        bpy_sub_bb["max_y"] = sub_bb.max_y;
	        bpy_sub_bb["min_y"] = sub_bb.min_y;
	        bpy_sub_bb["max_z"] = sub_bb.max_z;
	        bpy_sub_bb["min_z"] = sub_bb.min_z;

	        var bb_points = extract_bb_corners(sub_bb, _bb_corners_cache);
	        var be_local = create_be_by_bb(bb_points, false);
	        submesh["boundings"]["be_cen"] = be_local.center;
	        submesh["boundings"]["be_ax"] = [be_local.axis_x[0],
	                be_local.axis_y[1], be_local.axis_z[2]];

	        if (i == 0)
	            copy_bb(sub_bb, mesh_bb);
	        else
	            expand_bounding_box(mesh_bb, sub_bb);
	    }

	    var bpy_mesh_bb = bpy_mesh["b4w_boundings"]["bb"];
	    bpy_mesh_bb["max_x"] = mesh_bb.max_x;
	    bpy_mesh_bb["min_x"] = mesh_bb.min_x;
	    bpy_mesh_bb["max_y"] = mesh_bb.max_y;
	    bpy_mesh_bb["min_y"] = mesh_bb.min_y;
	    bpy_mesh_bb["max_z"] = mesh_bb.max_z;
	    bpy_mesh_bb["min_z"] = mesh_bb.min_z;

	    // NOTE: original bounding box is recalculated because of modifiers is applied
	    var bpy_mesh_bb_s = bpy_mesh["b4w_boundings"]["bb_src"];
	    bpy_mesh_bb_s["max_x"] = mesh_bb.max_x;
	    bpy_mesh_bb_s["min_x"] = mesh_bb.min_x;
	    bpy_mesh_bb_s["max_y"] = mesh_bb.max_y;
	    bpy_mesh_bb_s["min_y"] = mesh_bb.min_y;
	    bpy_mesh_bb_s["max_z"] = mesh_bb.max_z;
	    bpy_mesh_bb_s["min_z"] = mesh_bb.min_z;

	    bpy_mesh["b4w_boundings"]["bs_rad"]  = srad;
	    bpy_mesh["b4w_boundings"]["bc_rad"] = crad;

	    var bb_points = extract_bb_corners(mesh_bb, _bb_corners_cache);
	    var be_local = create_be_by_bb(bb_points, false);
	    bpy_mesh["b4w_boundings"]["be_cen"] = be_local.center;
	    bpy_mesh["b4w_boundings"]["be_ax"] = [be_local.axis_x[0],
	            be_local.axis_y[1], be_local.axis_z[2]];
	};

	/**
	 * Get minimal enclosing circle (MEC) for frustum diagonal plane in 3d space
	 */
	exports.get_frustum_mec = function(corners) {
	    // left bottom near
	    var p0 = corners.subarray(0, 3);
	    // right top near
	    var p1 = corners.subarray(6, 9);
	    // left bottom far
	    var p2 = corners.subarray(12, 15);
	    // right top far
	    var p3 = corners.subarray(18, 21);

	    // basis vector: l
	    var l = m_vec3.subtract(p1, p0, _vec3_tmp);
	    m_vec3.normalize(l, l);

	    // basis vector: m
	    var normal = m_util.get_plane_normal(p0, p1, p2, _vec3_tmp2);
	    var m = m_vec3.cross(normal, l, normal);
	    m_vec3.normalize(m, m);

	    // transform points coordinates for new 2D Cartesian coordinate system
	    // q0 - center of the new system (former p0);
	    // NOTE: using gl_matrix vec3 for simplicity
	    var q0 = m_vec3.create();

	    var q1 = m_vec3.create();
	    m_vec3.subtract(p1, p0, _vec3_tmp3);
	    q1[0] = m_vec3.dot(_vec3_tmp3, l);
	    q1[1] = m_vec3.dot(_vec3_tmp3, m);

	    var q2 = m_vec3.create();
	    m_vec3.subtract(p2, p0, _vec3_tmp3);
	    q2[0] = m_vec3.dot(_vec3_tmp3, l);
	    q2[1] = m_vec3.dot(_vec3_tmp3, m);

	    var q3 = m_vec3.create();
	    m_vec3.subtract(p3, p0, _vec3_tmp3);
	    q3[0] = m_vec3.dot(_vec3_tmp3, l);
	    q3[1] = m_vec3.dot(_vec3_tmp3, m);

	    var bs = create_bs();
	    bs = get_mec_2d([q0, q1, q2, q3], bs);

	    var center_origin = m_vec3.scale(l, bs.center[0], _vec3_tmp3);
	    m_vec3.scaleAndAdd(center_origin, m, bs.center[1], center_origin);
	    m_vec3.add(center_origin, p0, bs.center);

	    return bs;
	};

	/**
	 * Calculate minimum enclosing circle MEC
	 * E.Welzl algorithm, O(n) complexity
	 * @see http://www.cs.arizona.edu/classes/cs437/fall11/Lecture4.pdf
	 * @see http://www.sunshine2k.de/coding/java/Welzl/Welzl.html
	 */
	function get_mec_2d(points, bs) {

	    bs = mec_by_2_points(bs, points[0], points[1]);

	    for (var i = 2; i < points.length; i++)
	        if (m_vec3.distance(bs.center, points[i]) > bs.radius)
	            bs = mec_step1(bs, points, points[i], i - 1);

	    return bs;
	}

	function mec_step1(bs, points, q, points_range) {
	    bs = mec_by_2_points(bs, q, points[0]);

	    for (var i = 1; i <= points_range; i++)
	        if (m_vec3.distance(bs.center, points[i]) > bs.radius)
	            bs = mec_step2(bs, points, q, points[i], i - 1);

	    return bs;
	}

	function mec_step2(bs, points, q0, q1, points_range) {
	    bs = mec_by_2_points(bs, q0, q1);

	    for (var i = 0; i <= points_range; i++)
	        if (m_vec3.distance(bs.center, points[i]) > bs.radius)
	            bs = mec_by_3_points(bs, q0, q1, points[i]);

	    return bs;
	}

	function mec_by_2_points(bs, A, B) {
	    m_vec3.add(A, B, bs.center);
	    m_vec3.scale(bs.center, 0.5, bs.center);

	    bs.radius = m_vec3.distance(bs.center, A);
	    return bs;
	}

	/**
	 * Use circumcenter barycentric coordinates
	 * @see http://mathworld.wolfram.com/BarycentricCoordinates.html
	 */
	function mec_by_3_points(bs, A, B, C) {
	    var BC = m_vec3.subtract(B, C, _vec3_tmp3);
	    var a_sq = m_vec3.squaredLength(BC);

	    var AC = m_vec3.subtract(A, C, _vec3_tmp3);
	    var b_sq = m_vec3.squaredLength(AC);

	    var AB = m_vec3.subtract(A, B, _vec3_tmp3);
	    var c_sq = m_vec3.squaredLength(AB);

	    var a_coeff = a_sq * (b_sq + c_sq - a_sq);
	    var b_coeff = b_sq * (c_sq + a_sq - b_sq);
	    var c_coeff = c_sq * (a_sq + b_sq - c_sq);
	    var sum = a_coeff + b_coeff + c_coeff;

	    m_vec3.copy(A, bs.center);
	    m_vec3.scale(bs.center, a_coeff / sum, bs.center);
	    m_vec3.scaleAndAdd(bs.center, B, b_coeff / sum, bs.center);
	    m_vec3.scaleAndAdd(bs.center, C, c_coeff / sum, bs.center);

	    bs.radius = m_vec3.distance(bs.center, A);

	    return bs;
	}

	}

	var int_boundings_factory = register("__boundings", Int_boundings);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Config internal API.
	 * @name config
	 * @namespace
	 * @exports exports as config
	 */
	function Int_config(ns, exports) {

	var m_print = print_factory(ns);
	var m_util  = int_util_factory(ns);

	// profiles
	exports.P_LOW    = 1;  // maximize performance
	exports.P_HIGH   = 2;  // use all requested features
	exports.P_ULTRA  = 3;  // use all requested features and maximize quality
	exports.P_CUSTOM = 4;  // use exports.defaults
	exports.P_AUTO   = 5;  // meta quality for auto configurators

	exports.context = {
	    alpha              : true,
	    antialias          : false,
	    premultipliedAlpha : true
	};
	exports.context_save = m_util.clone_object_r(exports.context);

	exports.defaults = {
	    alpha_sort                 : true,

	    alpha_sort_threshold       : 0.1,

	    min_format_version         : [6, 3],

	    max_fps                    : 10000, // not accurate

	    console_verbose            : false,

	    do_not_load_resources      : false,

	    use_min50                  : false,

	    enable_texture_cache       : true,

	    fps_measurement_interval   : 1.0,

	    fps_callback_interval      : 5,

	    background_color           : [0.0, 0.0, 0.0, 0.0],

	    canvas_resolution_factor   : 1.0,

	    texture_min_filter         : 3,

	    allow_cors                 : false,

	    force_low_quality_nodes    : false,

	    anisotropic_available      : true,

	    anisotropic_filtering      : true,

	    texture_lod_available      : false,

	    // init and show HUD on canvas provided by app
	    show_hud_debug_info        : false,

	    // required for shadows
	    depth_tex_available        : true,

	    shadows                    : true,

	    stereo                     : "NONE",

	    reflections                : true,

	    refractions                : true,

	    ssao                       : true,

	    dof                        : true,

	    god_rays                   : true,

	    bloom                      : true,

	    motion_blur                : true,

	    compositing                : true,

	    antialiasing               : true,

	    smaa                       : false,

	    debug_view                 : false,

	    water_wireframe_debug      : false,

	    // properties updated from hardware capability
	    foam                       : true,

	    parallax                   : true,

	    dynamic_grass              : true,

	    water_dynamic              : true,

	    shore_smoothing            : true,

	    shore_distance             : true,

	    use_compression            : true,

	    precision                  : "highp",

	    // quality profile
	    quality                    : exports.P_HIGH,

	    allow_vertex_textures      : true,

	    lod_leap_smooth_threshold  : 3, // meters

	    assets_gzip_available      : false,

	    no_phy_interp_hack         : false,

	    shader_constants_hack      : false,

	    disable_blend_shadows_hack : false,

	    vert_anim_mix_normals_hack : false,

	    is_mobile_device           : false,

	    init_wa_context_hack       : false,

	    clear_procedural_sky_hack  : false,

	    sky_update_hack            : false,

	    seq_video_fallback         : false,

	    allow_hidpi                : false,

	    shadows_color_slink_hack   : false,

	    mobile_firefox_media_hack  : false,

	    ipad_video_hack            : false,

	    enable_selectable          : true,

	    enable_outlining           : true,

	    lod_smooth_transitions     : true,

	    glow_materials             : true,

	    ie11_edge_touchscreen_hack : false,

	    firefox_tex_reuse_hack     : false,

	    loaded_data_version        : [0, 0],

	    quality_aa_method          : true,

	    skinning_hack              : false,

	    url_params                 : null,

	    webgl2                     : true,

	    msaa_samples               : 4,

	    compared_mode_depth        : false,

	    safari_canvas_alpha_hack   : false,

	    safari_glow_hack           : false,

	    resize_cubemap_canvas_hack : false,

	    resize_texture_canvas_hack : false,

	    chrome_html_bkg_music_hack : false,

	    ie_edge_anchors_floor_hack : false,

	    ie11_edge_mouseoffset_hack : false,

	    media_auto_activation      : true,

	    max_cast_lamps             : 4,

	    mac_os_shadow_hack         : false,

	    gl_debug                   : false,

	    check_framebuffer_hack     : false,

	    allow_instanced_arrays_ext : false,

	    allow_vao_ext              : false,

	    compress_format            : "dds",

	    shadow_blur_samples        : "",

	    reflection_quality         : "",

	    srgb_type                  : "SRGB_SIMPLE",

	    ios_copy_tex_hack          : false,

	    rgba_fallback_shadows      : false,

	    debug_loading              : false,

	    mali_alpha_antialias_hack  : false,

	    mali4_lamps_hack           : false,

	    chrome_csm_blend_hack      : false,

	    reuse_depth_optimization   : true
	};

	exports.defaults_save = m_util.clone_object_r(exports.defaults);

	exports.animation = {
	    framerate: -1,
	    frames_blending_hack: false,
	    frame_steps: 1
	};

	exports.controls = {
	    mouse_wheel_notch_multiplier: 1/120
	};

	exports.assets = {
	    path: "",
	    // relative to engine sources (default value for developer version)
	    path_default: "B4W_ASSETS_PATH=__JS__/../deploy/assets/",
	    proj_path_default: "B4W_PROJ_ASSETS_PATH=__JS__/../projects/__NAME__/assets/",
	    max_requests: 15,
	    prevent_caching: true,
	    min50_available: false,
	    dds_available: false,
	    pvr_available: false
	};
	exports.assets_save = m_util.clone_object_r(exports.assets);

	exports.paths = {
	    shaders_path         : "",
	    // relative to engine sources (default value for developer version)
	    shaders_path_default : "../shaders/",
	    shaders_include_dir : "include/",
	    shaders_postp_dir : "postprocessing/",

	    built_in_data_module : "built_in_data",

	    js_src_search_paths: [
	        "b4w.min.js",
	        "b4w.full.min.js",
	        "b4w.simple.min.js",
	        "b4w.whitespace.min.js",
	        "src/b4w.js",
	        "B4W_MAIN_MODULE"   // replaced when something compiled with the engine
	    ],

	    smaa_search_texture_path: "smaa_search_texture.png",
	    smaa_area_texture_path: "smaa_area_texture.png"
	};

	exports.hmd_params = {
	    "webvr": {
	        distortion_coefs : [0.22, 0.28],
	        chromatic_aberration_coefs : [-0.015, 0.02, 0.025, 0.02]
	    },
	    "nonwebvr": {
	        distor_scale: 0.8,

	        inter_lens_dist: 0.064,
	        base_line_dist: 0.035,
	        screen_to_lens_dist: 0.039,
	        distortion_coefs : [0.34, 0.55],
	        chromatic_aberration_coefs : [0.0, 0.0, 0.0, 0.0],
	        width_dist: 0.110,
	        height_dist: 0.062,
	        bevel_size: 0.004
	    }
	};

	// physics config
	exports.physics = {
	    enabled: true,
	    max_fps: 60,
	    uranium_path: "",
	    uranium_bin: "",
	    // relative to engine sources (default value for developer version)
	    uranium_path_default: "B4W_URANIUM_PATH=../deploy/apps/common/",
	    asmjs_file: "uranium.js",
	    wasmjs_file: "uranium_wasm.js",
	    mem_file: "uranium.js.mem",
	    wasm_file: "uranium_wasm.wasm",
	    uranium_dir: "../deploy/apps/common/",
	    calc_fps: false,
	    ping: false,
	    use_workers: true,
	    use_wasm: true
	};
	exports.physics_save = m_util.clone_object_r(exports.physics);

	exports.scenes = {
	    grass_tex_size: 2*512,
	    // default adjusted size
	    cubemap_tex_size: 256,
	    cube_reflect_low: 32,
	    cube_reflect_medium: 128,
	    cube_reflect_high: 256,
	    plane_reflect_low: 0.25,
	    plane_reflect_medium: 0.5,
	    plane_reflect_high: 1.0
	};
	exports.scenes_save = m_util.clone_object_r(exports.scenes);

	exports.sfx = {
	    webaudio               : true,
	    mix_mode               : false,
	    audio_loading_hack     : false,
	    clamp_playback_rate_hack: false,
	    disable_playback_rate_hack: false

	};
	exports.sfx_save = m_util.clone_object_r(exports.sfx);

	exports.outlining = {
	    outlining_overview_mode : false,
	    outline_color           : [1, 0.4, 0.05],
	    outline_duration        : 0.2,
	    outline_period          : 3.8,
	    outline_relapses        : 1.0
	};


	exports.debug_subs = {
	    enabled     : false,
	    subs_type   : 39,    // look subscene module for the right type number
	    subs_number : 0,
	    slink_type  : "COLOR"
	};
	exports.debug_subs_save = m_util.clone_object_r(exports.debug_subs);

	exports.context_limits = {
	    max_combined_texture_image_units : 8,
	    max_fragment_uniform_vectors     : 64,
	    max_texture_image_units          : 8,
	    max_varying_vectors              : 8,
	    max_vertex_attribs               : 15,
	    max_vertex_texture_image_units   : 0,
	    max_vertex_uniform_vectors       : 128,

	    max_cube_map_texture_size        : 1024,
	    max_renderbuffer_size            : 4096,
	    max_texture_size                 : 4096,
	    max_viewport_dims                : [4096, 4096],

	    depth_bits                       : 24
	};
	exports.context_limits_save = m_util.clone_object_r(exports.context_limits);

	/**
	 * Override default values of engine settings according to quality param
	 */
	exports.apply_quality = function() {

	    var cfg_def = exports.defaults;
	    var cfg_phy = exports.physics;
	    var cfg_scs = exports.scenes;

	    switch (cfg_def.quality) {

	    case exports.P_ULTRA:

	        cfg_def.shadows = true,

	        cfg_def.shore_smoothing = true,

	        cfg_def.ssao = true;

	        cfg_def.dof = true;

	        cfg_def.god_rays = true;

	        cfg_def.bloom = true;

	        cfg_def.reflections = true;

	        cfg_def.refractions = true;

	        cfg_def.foam = true;

	        cfg_def.parallax = true;

	        cfg_def.dynamic_grass = true;

	        cfg_scs.grass_tex_size = 4.0*512;

	        cfg_scs.cubemap_tex_size = 512;

	        cfg_def.texture_min_filter = 3;

	        cfg_def.anisotropic_filtering = true;

	        cfg_def.use_min50 = false;

	        cfg_def.water_dynamic = true;

	        cfg_def.shore_distance = true;

	        cfg_def.antialiasing = true;

	        cfg_def.smaa = false;

	        cfg_def.compositing = true;

	        cfg_def.motion_blur = true;

	        cfg_def.allow_hidpi = true;

	        cfg_def.enable_outlining = true;

	        cfg_def.glow_materials = true;

	        cfg_def.msaa_samples = 16;

	        cfg_def.srgb_type = "SRGB_PROPER";

	        cfg_phy.max_fps = 120;

	        cfg_def.lod_smooth_transitions = true;

	        break;

	    case exports.P_HIGH:

	        cfg_def.shadows = true;

	        cfg_def.shore_smoothing = true;

	        cfg_def.ssao = true;

	        cfg_def.dof = true;

	        cfg_def.god_rays = true;

	        cfg_def.bloom = true;

	        cfg_def.reflections = true;

	        cfg_def.refractions = true;

	        cfg_def.foam = true;

	        cfg_def.parallax = true;

	        cfg_def.dynamic_grass = true;

	        cfg_scs.grass_tex_size = 2*512;

	        cfg_scs.cubemap_tex_size = 256;

	        cfg_def.texture_min_filter = 3;

	        cfg_def.anisotropic_filtering = true;

	        cfg_def.use_min50 = false;

	        cfg_def.water_dynamic = true;

	        cfg_def.shore_distance = true;

	        cfg_def.antialiasing = true;

	        cfg_def.smaa = false;

	        cfg_def.compositing = true;

	        cfg_def.motion_blur = true;

	        cfg_def.allow_hidpi = false;

	        cfg_def.enable_outlining = true;

	        cfg_def.glow_materials = true;

	        cfg_def.srgb_type = "SRGB_SIMPLE";

	        cfg_def.msaa_samples = 4;

	        cfg_phy.max_fps = 60;

	        cfg_def.lod_smooth_transitions = true;

	        break;

	    case exports.P_LOW:

	        cfg_def.shadows = false;

	        cfg_def.shore_smoothing = false;

	        cfg_def.ssao = false;

	        cfg_def.dof = false;

	        cfg_def.god_rays = false;

	        cfg_def.bloom = false;

	        cfg_def.reflections = false;

	        cfg_def.refractions = false;

	        cfg_def.foam = false;

	        cfg_def.parallax = false;

	        cfg_def.dynamic_grass = false;

	        cfg_scs.grass_tex_size = 1*512;

	        cfg_scs.cubemap_tex_size = 256;

	        cfg_def.texture_min_filter = 2;

	        cfg_def.anisotropic_filtering = false;

	        cfg_def.use_min50 = true;

	        cfg_def.water_dynamic = false;

	        cfg_def.shore_distance = false;

	        cfg_def.antialiasing = false;

	        cfg_def.smaa = false;

	        cfg_def.compositing = false;

	        cfg_def.motion_blur = false;

	        cfg_def.allow_hidpi = false;

	        cfg_def.enable_outlining = false;

	        cfg_def.glow_materials = false;

	        cfg_def.srgb_type = "SRGB_SIMPLE";

	        cfg_def.msaa_samples = 1;

	        cfg_phy.max_fps = 60;

	        cfg_def.lod_smooth_transitions = false;

	        break;
	    case exports.P_CUSTOM:
	        // do nothing
	        break;
	    case exports.P_AUTO:
	        m_util.panic("Direct AUTO quality profile setting is forbidden");
	        break;
	    }
	};

	exports.set = set;
	/**
	 * @methodOf config
	 */
	function set(prop, value) {
	    switch (prop) {
	    case "allow_cors":
	        exports.defaults.allow_cors = value;
	        break;
	    case "allow_hidpi":
	        exports.defaults.allow_hidpi = value;
	        break;
	    case "alpha":
	        exports.context.alpha = value;
	        break;
	    case "alpha_sort":
	        exports.defaults.alpha_sort = value;
	        break;
	    case "alpha_sort_threshold":
	        exports.defaults.alpha_sort_threshold = value;
	        break;
	    case "anaglyph_use":
	        m_print.error_deprecated_cfg("anaglyph_use", "stereo");
	        exports.defaults.stereo = value? "ANAGLYPH": exports.defaults.stereo;
	        break;
	    case "animation_framerate":
	        exports.animation.framerate = value;
	        break;
	    case "anisotropic_filtering":
	        exports.defaults.anisotropic_filtering = value;
	        break;
	    case "antialiasing":
	        exports.defaults.antialiasing = value;
	        break;
	    // @deprecated
	    case "assets_dir":
	    case "assets_path":
	        exports.assets.path = value;
	        break;
	    case "assets_dds_available":
	        exports.assets.dds_available = value;
	        break;
	    case "assets_pvr_available":
	        exports.assets.pvr_available = value;
	        break;
	    case "assets_min50_available":
	        exports.assets.min50_available = value;
	        break;
	    case "audio":
	        exports.sfx.webaudio = value;
	        break;
	    case "background_color":
	        exports.defaults.background_color = value;
	        break;
	    case "bloom":
	        exports.defaults.bloom = value;
	        break;
	    case "built_in_module_name":
	        exports.paths.built_in_data_module = value;
	        break;
	    case "canvas_resolution_factor":
	        exports.defaults.canvas_resolution_factor = value;
	        break;
	    case "console_verbose":
	        exports.defaults.console_verbose = value;
	        break;
	    case "compositing":
	        exports.defaults.compositing = value;
	        break;
	    case "dof":
	        exports.defaults.dof = value;
	        break;
	    case "do_not_load_resources":
	        exports.defaults.do_not_load_resources = value;
	        break;
	    case "god_rays":
	        exports.defaults.god_rays = value;
	        break;
	    case "stereo":
	        exports.defaults.stereo = value;
	        break;
	    case "lod_leap_smooth_threshold":
	        exports.defaults.lod_leap_smooth_threshold = value;
	        break;
	    case "lod_smooth_transitions":
	        exports.defaults.lod_smooth_transitions = value;
	        break;
	    case "max_fps":
	        exports.defaults.max_fps = value;
	        break;
	    case "max_fps_physics":
	        exports.physics.max_fps = value;
	        break;
	    case "media_auto_activation":
	        exports.defaults.media_auto_activation = value;
	        break;
	    case "motion_blur":
	        exports.defaults.motion_blur = value;
	        break;
	    case "physics_enabled":
	        exports.physics.enabled = value;
	        break;
	    case "physics_uranium_path":
	        if (is_wasm_enabled()) {
	            exports.physics.uranium_path = value + exports.physics.wasmjs_file;
	            exports.physics.uranium_bin = value + exports.physics.wasm_file;
	        } else {
	            exports.physics.uranium_path = value + exports.physics.asmjs_file;
	            exports.physics.uranium_bin = value + exports.physics.mem_file;
	        }
	        exports.physics.uranium_dir = value;
	        break;
	    case "physics_use_wasm":
	        exports.physics.use_wasm = value;
	        break;
	    case "physics_calc_fps":
	        exports.physics.calc_fps = value;
	        break;
	    case "physics_use_workers":
	        exports.physics.use_workers = value;
	        break;
	    case "precision":
	        exports.defaults.precision = value;
	        break;
	    case "prevent_caching":
	        exports.assets.prevent_caching = value;
	        break;
	    case "quality":
	        exports.defaults.quality = value;
	        break;
	    case "reflections":
	        exports.defaults.reflections = value;
	        break;
	    case "refractions":
	        exports.defaults.refractions = value;
	        break;
	    case "sfx_mix_mode":
	        exports.sfx.mix_mode = value;
	        break;
	    // @deprecated
	    case "shaders_dir":
	    case "shaders_path":
	        exports.paths.shaders_path = value;
	        break;
	    case "shadows":
	        exports.defaults.shadows = value;
	        break;
	    case "show_hud_debug_info":
	        exports.defaults.show_hud_debug_info = value;
	        break;
	    case "smaa":
	        m_print.error_deprecated_cfg("smaa");
	        exports.defaults.smaa = value;
	        break;
	    case "smaa_search_texture_path":
	        m_print.error_deprecated_cfg("smaa_search_texture_path");
	        exports.paths.smaa_search_texture_path = value;
	        break;
	    case "smaa_area_texture_path":
	        m_print.error_deprecated_cfg("smaa_area_texture_path");
	        exports.paths.smaa_area_texture_path = value;
	        break;
	    case "ssao":
	        exports.defaults.ssao = value;
	        break;
	    case "debug_view":
	        exports.defaults.debug_view = value;
	        break;
	    case "enable_selectable":
	        exports.defaults.enable_selectable = value;
	        break;
	    case "enable_outlining":
	        exports.defaults.enable_outlining = value;
	        break;
	    case "outlining_overview_mode":
	        exports.outlining.outlining_overview_mode = value;
	        break;
	    case "glow_materials":
	        exports.defaults.glow_materials = value;
	        break;
	    case "url_params":
	        exports.defaults.url_params = value;
	        break;
	    case "use_min50":
	        exports.defaults.use_min50 = value;
	        break;
	    case "enable_texture_cache":
	        exports.defaults.enable_texture_cache = value;
	        break;
	    case "gl_debug":
	        exports.defaults.gl_debug = value;
	        break;
	    case "srgb_type":
	        exports.defaults.srgb_type = value;
	        break;
	    case "shadow_blur_samples":
	        exports.defaults.shadow_blur_samples = value;
	        break;
	    case "reflection_quality":
	        exports.defaults.reflection_quality = value;
	        break;
	    case "assets_gzip_available":
	        exports.defaults.assets_gzip_available = value;
	        break;
	    case "debug_loading":
	        exports.defaults.debug_loading = value;
	        break;
	    case "msaa_samples":
	        exports.defaults.msaa_samples = value;
	        break;
	    default:
	        m_print.error("Unknown config property: " + prop);
	        break;
	    }
	}

	exports.get = function(prop) {
	    switch (prop) {
	    case "allow_cors":
	        return exports.defaults.allow_cors;
	    case "allow_hidpi":
	        return exports.defaults.allow_hidpi;
	    case "alpha":
	        return exports.context.alpha;
	    case "alpha_sort":
	        return exports.defaults.alpha_sort;
	    case "alpha_sort_threshold":
	        return exports.defaults.alpha_sort_threshold;
	    case "anaglyph_use":
	        return exports.defaults.stereo == "ANAGLYPH";
	    case "animation_framerate":
	        return exports.animation.framerate;
	    case "anisotropic_filtering":
	        return exports.defaults.anisotropic_filtering;
	    case "antialiasing":
	        return exports.defaults.antialiasing;
	    // @deprecated
	    case "assets_dir":
	    case "assets_path":
	        return exports.assets.path;
	    case "assets_dds_available":
	        return exports.assets.dds_available;
	    case "assets_pvr_available":
	        return exports.assets.pvr_available;
	    case "assets_min50_available":
	        return exports.assets.min50_available;
	    case "audio":
	        return exports.sfx.webaudio;
	    case "background_color":
	        return exports.defaults.background_color;
	    case "bloom":
	        return exports.defaults.bloom;
	    case "built_in_module_name":
	        return exports.paths.built_in_data_module;
	    case "canvas_resolution_factor":
	        return exports.defaults.canvas_resolution_factor;
	    case "console_verbose":
	        return exports.defaults.console_verbose;
	    case "compositing":
	        return exports.defaults.compositing;
	    case "dof":
	        return exports.defaults.dof;
	    case "do_not_load_resources":
	        return exports.defaults.do_not_load_resources;
	    case "is_mobile_device":
	        return exports.defaults.is_mobile_device;
	    case "god_rays":
	        return exports.defaults.god_rays;
	    case "stereo":
	        return exports.defaults.stereo;
	    case "lod_leap_smooth_threshold":
	        return exports.defaults.lod_leap_smooth_threshold;
	    case "lod_smooth_transitions":
	        return exports.defaults.lod_smooth_transitions;
	    case "max_fps":
	        return exports.defaults.max_fps;
	    case "max_fps_physics":
	        return exports.physics.max_fps;
	    case "media_auto_activation":
	        return exports.defaults.media_auto_activation;
	    case "motion_blur":
	        return exports.defaults.motion_blur;
	    case "physics_enabled":
	        return exports.physics.enabled;
	    case "physics_uranium_path":
	        return exports.physics.uranium_dir;
	    case "physics_uranium_bin":
	        return exports.physics.uranium_bin;
	    case "physics_use_wasm":
	        return exports.physics.use_wasm;
	    case "physics_calc_fps":
	        return exports.physics.calc_fps;
	    case "physics_use_workers":
	        return exports.physics.use_workers;
	    case "precision":
	        return exports.defaults.precision;
	    case "prevent_caching":
	        return exports.assets.prevent_caching;
	    case "quality":
	        return exports.defaults.quality;
	    case "reflections":
	        return exports.defaults.reflections;
	    case "refractions":
	        return exports.defaults.refractions;
	    case "sfx_mix_mode":
	        return exports.sfx.mix_mode;
	    // @deprecated
	    case "shaders_dir":
	    case "shaders_path":
	        return exports.paths.shaders_path;
	    case "shadows":
	        return exports.defaults.shadows;
	    case "show_hud_debug_info":
	        return exports.defaults.show_hud_debug_info;
	    case "smaa":
	        return exports.defaults.smaa;
	    case "smaa_search_texture_path":
	        return exports.paths.smaa_search_texture_path;
	    case "smaa_area_texture_path":
	        return exports.paths.smaa_area_texture_path;
	    case "ssao":
	        return exports.defaults.ssao;
	    case "debug_view":
	        return exports.defaults.debug_view;
	    case "enable_selectable":
	        return exports.defaults.enable_selectable;
	    case "enable_outlining":
	        return exports.defaults.enable_outlining;
	    case "outlining_overview_mode":
	        return exports.outlining.outlining_overview_mode;
	    case "glow_materials":
	        return exports.defaults.glow_materials;
	    case "url_params":
	        return exports.defaults.url_params;
	    case "use_min50":
	        return exports.defaults.use_min50;
	    case "enable_texture_cache":
	        return exports.defaults.enable_texture_cache;
	    case "gl_debug":
	        return exports.defaults.gl_debug;
	    case "srgb_type":
	        return exports.defaults.srgb_type;
	    case "shadow_blur_samples":
	        return exports.defaults.shadow_blur_samples;
	    case "reflection_quality":
	        return exports.defaults.reflection_quality;
	    case "assets_gzip_available":
	        return exports.defaults.assets_gzip_available;
	    case "debug_loading":
	        return exports.defaults.debug_loading;
	    case "msaa_samples":
	        return exports.defaults.msaa_samples;
	    default:
	        m_print.error("Unknown config property: " + prop);
	        break;
	    }
	};

	exports.reset = function() {
	    for (var i in exports.context_save)
	        exports.context[i] = exports.context_save[i];
	    for (var i in exports.defaults_save)
	        exports.defaults[i] = exports.defaults_save[i];
	    for (var i in exports.assets_save)
	        exports.assets[i] = exports.assets_save[i];
	    for (var i in exports.physics_save)
	        exports.physics[i] = exports.physics_save[i];
	    for (var i in exports.scenes_save)
	        exports.scenes[i] = exports.scenes_save[i];
	    for (var i in exports.sfx_save)
	        exports.sfx[i] = exports.sfx_save[i];
	    for (var i in exports.debug_subs_save)
	        exports.debug_subs[i] = exports.debug_subs_save[i];
	};

	exports.reset_limits = function() {
	    // NOTE: depth_bits is too subtle/hacky to change it manually here
	    var depth_bits = exports.context_limits.depth_bits;
	    for (var i in exports.context_limits_save)
	        exports.context_limits[i] = exports.context_limits_save[i];
	    exports.context_limits.depth_bits = depth_bits;
	};

	exports.is_built_in_data = is_built_in_data;
	function is_built_in_data() {
	    return b4w.module_check(exports.paths.built_in_data_module);
	}

	function is_wasm_enabled() {
	    return exports.physics.use_wasm && window.WebAssembly;
	}

	/**
	 * Set configuration paths for shaders, uranium engine and smaa textures.
	 */
	exports.set_paths = function() {
	    var cfg_pth = exports.paths;
	    var cfg_phy = exports.physics;

	    if (!is_built_in_data() && cfg_pth.shaders_path == "")
	        cfg_pth.shaders_path = js_src_dir() + "/" + cfg_pth.shaders_path_default;

	    if (is_wasm_enabled()) {
	        var uranium_path = cfg_phy.uranium_path_default + cfg_phy.wasmjs_file;
	        var uranium_bin = cfg_phy.uranium_path_default + cfg_phy.wasm_file;
	    } else {
	        var uranium_path = cfg_phy.uranium_path_default + cfg_phy.asmjs_file;
	        var uranium_bin = cfg_phy.uranium_path_default + cfg_phy.mem_file;
	    }

	    if (cfg_phy.enabled && cfg_phy.uranium_path == "") {
	        cfg_phy.uranium_path = js_src_dir() + "/" +
	                uranium_path.replace("B4W_URANIUM_PATH=", "");
	        cfg_phy.uranium_bin = js_src_dir() + "/" +
	                uranium_bin.replace("B4W_URANIUM_PATH=", "");
	    }
	};

	/**
	 * Get path to the engine's source
	 */
	function js_src_dir() {
	    var cfg_pth = exports.paths;

	    var src_path = null;

	    var scripts = document.getElementsByTagName('script');

	    for (var i = 0; i < scripts.length; i++) {
	        var src = scripts[i].src;

	        for (var j = 0; j < cfg_pth.js_src_search_paths.length; j++) {
	            var script_path = cfg_pth.js_src_search_paths[j];
	            if (src.indexOf(script_path) >= 0) {
	                src_path = src;
	                break;
	            }
	        }

	        if (src_path !== null)
	            break;
	    }

	    if (!src_path) {
	        m_print.warn("Couldn't determine path to ancillary resources, " +
	                "fallback to the current page directory");
	        src_path = document.location.href;
	    }

	    var index = src_path.indexOf("?");
	    if (index >= 0)
	        src_path = src_path.substring(0, index);

	    return src_path.substring(0, src_path.lastIndexOf("/"));
	}

	exports.get_assets_path = function(name) {
	    console.log(this);
	    var cfg_ass = exports.assets;

	    if (cfg_ass.path)
	        return cfg_ass.path;

	    var cfg_ass_def = cfg_ass.path_default;
	    var assets_repl_pref = "B4W_ASSETS_PATH=";

	    if (name) {
	        cfg_ass_def = cfg_ass.proj_path_default;
	        assets_repl_pref = "B4W_PROJ_ASSETS_PATH=";
	        cfg_ass_def = cfg_ass_def.replace("__NAME__", name);
	    }

	    cfg_ass_def = cfg_ass_def.replace(assets_repl_pref, "");
	    cfg_ass_def = cfg_ass_def.replace("__JS__", js_src_dir());

	    return cfg_ass_def;
	};

	}

	var int_config_factory = register("__config", Int_config);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Extensions internal API.
	 * @name extensions
	 * @namespace
	 * @exports exports as extensions
	 */
	function Int_extensions(ns, exports) {

	var m_cfg   = int_config_factory(ns);
	var m_print = print_factory(ns);

	var cfg_def = m_cfg.defaults;

	var _gl = null;

	var _ext_cache = {};

	/**
	 * Setup WebGL context
	 * @param gl WebGL context
	 */
	exports.setup_context = function(gl) {
	    _gl = gl;
	};

	/**
	 * Request WEBGL_compressed_texture_s3tc extension
	 * @methodOf extensions
	 */
	exports.get_s3tc = function() {

	    var ext_s3tc = get(       "WEBGL_compressed_texture_s3tc") ||
	                   get("WEBKIT_WEBGL_compressed_texture_s3tc");
	    return ext_s3tc;
	};
	exports.get_pvr = function() {
	    var ext_pvr = get("WEBKIT_WEBGL_compressed_texture_pvrtc") ||
	            get("WEBGL_compressed_texture_pvrtc");
	    return ext_pvr;
	};

	/**
	 * Request WEBGL_depth_texture extension
	 * @methodOf extensions
	 */
	exports.get_depth_texture = function() {

	    if (cfg_def.webgl2)
	        return webgl2_get("WEBGL_depth_texture");

	    var ext_dtex = get(       "WEBGL_depth_texture") ||
	                   get("WEBKIT_WEBGL_depth_texture");
	    return ext_dtex;
	};

	/**
	 * Request EXT_texture_filter_anisotropic extension
	 * @methodOf extensions
	 */
	exports.get_aniso = function() {

	    var ext_aniso = get(       "EXT_texture_filter_anisotropic") ||
	                    get("WEBKIT_EXT_texture_filter_anisotropic");
	    return ext_aniso;
	};

	exports.get_texture_lod = function() {

	    if (cfg_def.webgl2)
	        return webgl2_get("EXT_shader_texture_lod");

	    var ext_tex_lod = get("EXT_shader_texture_lod");
	    return ext_tex_lod;
	};

	/**
	 * Request WEBGL_debug_shaders extension
	 * @methodOf extensions
	 */
	exports.get_debug_shaders = function() {

	    var ext_ds = get("WEBGL_debug_shaders");
	    return ext_ds; 
	};

	/**
	 * Request WEBGL_debug_renderer_info extension
	 * @methodOf extensions
	 */
	exports.get_renderer_info = function() {

	    var ext_ri = get("WEBGL_debug_renderer_info");
	    return ext_ri; 
	};

	/**
	 * Request OES_element_index_uint extension
	 * @methodOf extensions
	 */
	exports.get_elem_index_uint = function() {

	    if (cfg_def.webgl2)
	        return webgl2_get("OES_element_index_uint");

	    var ext_elem_index_uint = get("OES_element_index_uint");
	    return ext_elem_index_uint;
	};

	/**
	 * Request OES_standard_derivatives extension
	 * @methodOf extensions
	 */
	exports.get_standard_derivatives = function() {

	    if (cfg_def.webgl2)
	        return webgl2_get("OES_standard_derivatives");

	    var ext_standard_derivatives = get("OES_standard_derivatives");
	    return ext_standard_derivatives;
	};

	/**
	 * Request OES_standard_derivatives extension
	 * @methodOf extensions
	 */
	exports.get_disjoint_timer_query = function() {
	    if (cfg_def.webgl2)
	        var ext = webgl2_get("EXT_disjoint_timer_query_webgl2");
	    else
	        var ext = get("EXT_disjoint_timer_query");

	    if (ext == null)
	        return ext;

	    if (ext.createQueryEXT)
	        var ext_complete = {
	            createQuery: function() {
	                return ext.createQueryEXT();
	            },
	            beginQuery: function(query) {
	                ext.beginQueryEXT(ext.TIME_ELAPSED_EXT, query);
	            },
	            endQuery: function() {
	                ext.endQueryEXT(ext.TIME_ELAPSED_EXT);
	            },
	            getQueryAvailable: function(query) {
	                return ext.getQueryObjectEXT(query, ext.QUERY_RESULT_AVAILABLE_EXT);
	            },
	            getQueryObject: function(query) {
	                return ext.getQueryObjectEXT(query, ext.QUERY_RESULT_EXT);
	            },
	            getDisjoint: function() {
	                return ext.GPU_DISJOINT_EXT;
	            }
	        };
	    else
	        var ext_complete = {
	            createQuery: function() {
	                return _gl.createQuery();
	            },
	            beginQuery: function(query) {
	                _gl.beginQuery(ext.TIME_ELAPSED_EXT, query);
	            },
	            endQuery: function() {
	                _gl.endQuery(ext.TIME_ELAPSED_EXT);
	            },
	            getQueryAvailable: function(query) {
	                return _gl.getQueryParameter(query, _gl.QUERY_RESULT_AVAILABLE);
	            },
	            getQueryObject: function(query) {
	                return _gl.getQueryParameter(query, _gl.QUERY_RESULT);
	            },
	            getDisjoint: function() {
	                return ext.GPU_DISJOINT_EXT;
	            }
	        };

	    return ext_complete;
	};

	exports.get_instanced_arrays = function() {

	    if (cfg_def.webgl2)
	        return webgl2_get("ANGLE_instanced_arrays");

	    var ext = get("ANGLE_instanced_arrays");
	    if (ext == null)
	        return ext;

	    var ext_complete = {
	        drawElementsInstanced: function(mode, count, type, offset, primcount) {
	            ext.drawElementsInstancedANGLE(mode, count, type, offset,
	                    primcount);
	        },
	        vertexAttribDivisor: function(loc, div) {
	            ext.vertexAttribDivisorANGLE(loc, div);
	        },
	        drawArraysInstanced: function(mode, first, count, primcount) {
	            ext.drawArraysInstancedANGLE(mode, first, count, primcount);
	        }
	    };
	    return ext_complete;
	};

	exports.get_vertex_array_object = function() {

	    if (cfg_def.webgl2)
	        return webgl2_get("OES_vertex_array_object");

	    var ext = get("OES_vertex_array_object");
	    if (ext == null)
	        return ext;

	    var ext_complete = {
	        bindVertexArray: function(vao) {
	            ext.bindVertexArrayOES(vao);
	        },
	        createVertexArray: function() {
	            return ext.createVertexArrayOES();
	        },
	        deleteVertexArray: function(vao) {
	            ext.deleteVertexArrayOES(vao);
	        },
	        isVertexArray: function(vao) {
	            return ext.isVertexArrayOES(vao);
	        }
	    };
	    return ext_complete;
	};

	function get(name) {

	    if (name in _ext_cache)
	        return _ext_cache[name];

	    var ext = _gl.getExtension(name) || null;

	    _ext_cache[name] = ext;

	    if (ext)
	        var color = "0a0";
	    else
	        var color = "a00";

	    m_print.log("%cGET EXTENSION", "color: #" + color, name);

	    return ext;
	}

	function webgl2_get(name) {

	    if (name in _ext_cache)
	        return _ext_cache[name];

	    switch(name) {
	    case "WEBGL_depth_texture":
	    case "OES_element_index_uint":
	    case "OES_standard_derivatives":
	    case "EXT_shader_texture_lod":
	        var ext = {};
	        break;
	    case "ANGLE_instanced_arrays":
	    case "OES_vertex_array_object":
	        var ext = _gl;
	        break;
	    default:
	        var ext = _gl.getExtension(name) || null;
	        break;
	    }

	    _ext_cache[name] = ext;

	    if (ext)
	        var color = "0a0";
	    else
	        var color = "a00";

	    m_print.log("%cGET EXTENSION (WebGL 2)", "color: #" + color, name);

	    return ext;
	}

	/**
	 * Perform module cleanup
	 */
	exports.cleanup = function() {
	    _ext_cache = {};
	};

	exports.reset = function() {
	    _gl = null;
	};

	}

	var int_extensions_factory = register("__extensions", Int_extensions);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Generic graph routines.
	 *
	 * @name graph
	 * @namespace
	 * @exports exports as graph
	 */
	function Int_graph(ns, exports) {

	var m_util  = int_util_factory(ns);

	var NULL_NODE    = -1;
	var NULL         = 0;

	var FORWARD_DIR  = 10;
	var BACKWARD_DIR = 20;
	var TWO_WAY      = 30;

	var _next_pair_cache = [NULL_NODE, NULL_NODE];

	exports.NULL_NODE    = NULL_NODE;
	exports.FORWARD_DIR  = FORWARD_DIR;
	exports.BACKWARD_DIR = BACKWARD_DIR;
	exports.TWO_WAY      = TWO_WAY;

	/**
	 * Create graph using constructor pattern.
	 * Argument params: node_or_edge1 Node [ID, ATTR] or Edge [ID1, ID2, ATTR], 
	 * node_or_edge2 ...
	 */
	exports.create = function() {

	    var node_edge_arr = arguments;

	    var nodes = [];
	    var edges = [];

	    for (var i = 0; i < node_edge_arr.length; i++) {
	        var node_edge = node_edge_arr[i];

	        switch(node_edge.length) {
	        case 2:
	            // node index, edge attribute
	            nodes.push(node_edge[0], node_edge[1]);
	            break;
	        case 3:
	            // node index 1, node index 2, edge attrubute
	            edges.push(node_edge[0], node_edge[1], node_edge[2]);
	            break;
	        default:
	            m_util.panic("Wrong graph constructor params");
	            break;
	        }
	    }

	    var graph = {
	        nodes: nodes,
	        edges: edges
	    };

	    return graph;
	};

	exports.clone = function(graph, nodes_cb, edges_cb) {
	    if (nodes_cb) {
	        var nodes = new Array(graph.nodes.length);
	        for (var i = 0; i < graph.nodes.length; i+=2) {
	            nodes[i] = graph.nodes[i];
	            nodes[i+1] = nodes_cb(graph.nodes[i+1]);
	        }
	    } else
	        var nodes = m_util.clone_object_r(graph.nodes);

	    if (edges_cb) {
	        var edges = new Array(graph.edges.length);
	        for (var i = 0; i < graph.edges.length; i+=3) {
	            edges[i] = graph.edges[i];
	            edges[i+1] = graph.edges[i+1];
	            edges[i+2] = edges_cb(graph.edges[i+2]);
	        }
	    } else
	        var edges = m_util.clone_object_r(graph.edges);

	    graph = {
	        nodes: nodes,
	        edges: edges
	    };

	    return graph;
	};

	/**
	 * Create graph using separate node and edge arrays.
	 */
	exports.create_node_edge_arr = function(nodes_arr, edges_arr) {

	    var nodes = [];
	    var edges = [];

	    for (var i = 0; i < nodes_arr.length; i++)
	        nodes.push(nodes_arr[i][0], nodes_arr[i][1]);

	    for (var i = 0; i < edges_arr.length; i++)
	        edges.push(edges_arr[i][0], edges_arr[i][1], edges_arr[i][2]);

	    var graph = {
	        nodes: nodes,
	        edges: edges
	    };
	    return graph;
	};

	exports.append_node = append_node;
	function append_node(graph, id, attr) {
	    if (!attr)
	        attr = null;

	    if (has_node(graph, id))
	        m_util.panic("Graph already has node with given ID");
	    else
	        graph.nodes.push(id, attr);
	}

	exports.has_node = has_node;
	function has_node(graph, id) {
	    var nodes = graph.nodes;

	    for (var i = 0; i < nodes.length; i+=2)
	        if (nodes[i] == id)
	            return true;

	    return false;
	}

	exports.append_edge = append_edge;
	/**
	 * NOTE: check multiple edges case
	 */
	function append_edge(graph, id1, id2, attr) {
	    if (!attr)
	        attr = null;

	    if (!has_node(graph, id1) || !has_node(graph, id2))
	        m_util.panic("Wrong node IDs");
	    else
	        graph.edges.push(id1, id2, attr);
	}

	exports.remove_node = remove_node;
	function remove_node(graph, id) {
	    if (!has_node(graph, id))
	        m_util.panic("Node not found");

	    var nodes = graph.nodes;

	    for (var i = 0; i < nodes.length; i+=2) {
	        if (nodes[i] == id) {
	            nodes.splice(i, 2);
	            i-=2;
	        }
	    }
	}
	exports.remove_edge = remove_edge;
	function remove_edge(graph, id1, id2, edge_num) {
	    if (!has_edge(graph, id1, id2))
	        m_util.panic("Edge not found");

	    var edges = graph.edges;
	    var count = 0;

	    for (var i = 0; i < edges.length; i+=3) {
	        if (edges[i] == id1 && edges[i+1] == id2) {
	            if (edge_num == -1)
	                edges.splice(i, 3);
	            else {
	                if (edge_num == count) {
	                    edges.splice(i, 3);
	                    break;
	                }
	                count++;
	            }

	            i-=3;
	        }
	    }
	}
	exports.remove_edge_by_attr = remove_edge_by_attr;
	function remove_edge_by_attr(graph, id1, id2, attr) {
	    if (!has_edge(graph, id1, id2))
	        m_util.panic("Edge not found");
	    var edges = graph.edges;

	    for (var i = 0; i < edges.length; i+=3) {
	        if (edges[i] == id1 && edges[i+1] == id2
	                && edges[i+2][0] == attr[0] && edges[i+2][1] == attr[1]) {
	            edges.splice(i, 3);
	            break;
	        }
	    }
	}

	/**
	 * Append node by attribute.
	 * Perform attribute uniqueness test and append newly allocated node to graph
	 * with that unique attribute.
	 * @returns New node ID
	 */
	exports.append_node_attr = function(graph, attr) {
	    if (node_by_attr(graph, attr) == NULL_NODE) {
	        var node_id = gen_node_id(graph);
	        append_node(graph, node_id, attr);
	        return node_id;
	    } else
	        m_util.panic("Non-unique attribute");
	};

	/**
	 * For edges connecting two node IDs with given attribute replace it by the new one.
	 */
	exports.replace_edge_attr = function(graph, id1, id2, attr_old, attr_new) {
	    var edges = graph.edges;
	    for (var i = 0; i < edges.length; i+=3)
	        if (edges[i] == id1 && edges[i+1] == id2 && edges[i+2] == attr_old)
	            edges[i+2] = attr_new;
	};

	/**
	 * Append the subgraph to the given graph.
	 * @param {Graph} subgraph Subgraph to append
	 * @param {Graph} graph Graph to append to
	 * @param {Edge[]} subgraph_graph_edges subgraph->graph inter-graph edges
	 * @param {Edge[]} graph_subgraph_edges graph->subgraph inter-graph edges
	 */
	exports.append_subgraph = function(subgraph, graph,
	        subgraph_graph_edges, graph_subgraph_edges) {

	    subgraph_graph_edges = subgraph_graph_edges || [];
	    graph_subgraph_edges = graph_subgraph_edges || [];

	    var ids_new = {};

	    for (var i = 0; i < subgraph.nodes.length; i+=2) {
	        var id_sub = subgraph.nodes[i];
	        var attr = subgraph.nodes[i+1];

	        // subgraph new node id (inside graph)
	        var id_sub_new = gen_node_id(graph);
	        append_node(graph, id_sub_new, attr);
	        ids_new[id_sub] = id_sub_new;
	    }

	    for (var i = 0; i < subgraph.edges.length; i+=3) {
	        var id1_sub_new = ids_new[subgraph.edges[i]];
	        var id2_sub_new = ids_new[subgraph.edges[i+1]];

	        var attr_edge = subgraph.edges[i+2];

	        append_edge(graph, id1_sub_new, id2_sub_new, attr_edge);
	    }

	    for (var i = 0; i < subgraph_graph_edges.length; i+=3) {
	        var id1_sub_new = ids_new[subgraph_graph_edges[i]];
	        var id2 = subgraph_graph_edges[i+1];
	        var attr_edge = subgraph_graph_edges[i+2];

	        append_edge(graph, id1_sub_new, id2, attr_edge);
	    }

	    for (var i = 0; i < graph_subgraph_edges.length; i+=3) {
	        var id1 = graph_subgraph_edges[i];
	        var id2_sub_new = ids_new[graph_subgraph_edges[i+1]];

	        var attr_edge = graph_subgraph_edges[i+2];

	        append_edge(graph, id1, id2_sub_new, attr_edge);
	    }
	};


	exports.gen_node_id = gen_node_id;
	function gen_node_id(graph) {

	    var nodes = graph.nodes;
	    var counter = -1;

	    for (var i = 0; i < nodes.length; i+=2)
	        counter = Math.max(counter, nodes[i]);

	    return (++counter);
	}

	exports.node_by_attr = node_by_attr;
	/**
	 * Find first node by attribute.
	 */
	function node_by_attr(graph, attr) {
	    var nodes = graph.nodes;

	    for (var i = 0; i < nodes.length; i+=2)
	        if (nodes[i+1] == attr)
	            return nodes[i];

	    // not found
	    return NULL_NODE;
	}

	/**
	 * Append new edge by two node attributes.
	 * All node attributes must be unique, because the edge is appended only ones.
	 */
	exports.append_edge_attr = function(graph, attr_node1, attr_node2, attr_edge) {
	    var id1 = node_by_attr(graph, attr_node1);
	    var id2 = node_by_attr(graph, attr_node2);

	    if (id1 != NULL_NODE && id2 != NULL_NODE)
	        append_edge(graph, id1, id2, attr_edge);
	    else
	        m_util.panic("Attributes not found");
	};

	/**
	 * Traverse graph and exec callback per node.
	 * return any positive value from callback to interrupt traversal
	 * do not try to modify graph structure in callback
	 */
	exports.traverse = function(graph, callback) {
	    var nodes = graph.nodes;

	    for (var i = 0; i < nodes.length; i+=2)
	        if (callback(nodes[i], nodes[i+1]))
	            break;
	};

	/**
	 * Traverse graph and exec callback per edge.
	 * return any positive value from callback to interrupt traversal
	 * do not try to modify graph structure in callback
	 */
	exports.traverse_edges = function(graph, callback) {
	    var edges = graph.edges;

	    for (var i = 0; i < edges.length; i+=3)
	        if (callback(edges[i], edges[i+1], edges[i+2]))
	            break;
	};

	/**
	 * Traverse node inputs and exec callback per input.
	 * return any positive value from callback to interrupt traversal
	 * do not try to modify graph structure in callback
	 */
	exports.traverse_inputs = function(graph, node, callback) {

	    var edges = graph.edges;

	    for (var i = 0; i < edges.length; i+=3)
	        if (edges[i+1] == node) {
	            var node_in = edges[i];
	            if (callback(node_in, get_node_attr(graph, node_in), edges[i+2]))
	                return;
	        }
	};

	/**
	 * Traverse node outputs and exec callback per output.
	 * return any positive value from callback to interrupt traversal
	 * do not try to modify graph structure in callback
	 */
	exports.traverse_outputs = function(graph, node, callback) {
	    var edges = graph.edges;

	    for (var i = 0; i < edges.length; i+=3)
	        if (edges[i] == node) {
	            var node_out = edges[i+1];
	            if (callback(node_out, get_node_attr(graph, node_out), edges[i+2]))
	                return;
	        }
	};

	exports.topsort = topsort;
	/**
	 * Topological sorting based on depth-first search algorithm.
	 * @param graph Graph
	 * @returns New graph with sorted nodes
	 */
	function topsort(graph) {

	    var new_nodes = [];
	    var visit_state = {};
	    set_unvisited(graph, visit_state);

	    var nodes = graph.nodes;
	    for (var i = 0; i < nodes.length; i+=2)
	        if (in_edge_count(graph, nodes[i]) == 0)
	            topsort_iter(graph, nodes[i], visit_state, new_nodes);

	    var new_graph = {
	        nodes: new_nodes,
	        edges: graph.edges.slice(0)
	    };

	    return new_graph;
	}

	function set_unvisited(graph, visit_state) {
	    var nodes = graph.nodes;

	    for (var i = 0; i < nodes.length; i+=2)
	        visit_state[nodes[i]] = false;
	}

	/**
	 * topsort visit function
	 */
	function topsort_iter(graph, node_id, visit_state, new_nodes) {
	    if (!visit_state[node_id]) {
	        visit_state[node_id] = true;

	        for (var i = 0; i < out_edge_count(graph, node_id); i++) {
	            var other = get_out_edge(graph, node_id, i);
	            topsort_iter(graph, other, visit_state, new_nodes);
	        }

	        new_nodes.unshift(node_id, get_node_attr(graph, node_id));
	    }
	}


	/**
	 * Topological sorting based on depth-first search algorithm.
	 * @param graph Graph
	 * @returns {Array} Array of node attributes
	 */
	exports.topsort_attr = function(graph) {
	    var nodes = topsort(graph).nodes;
	    var result = [];

	    for (var i = 0; i < nodes.length; i+=2)
	        result.push(nodes[i+1]);

	    return result;
	};


	exports.is_connected = function(graph) {
	    // TODO: implement when needed
	};

	/**
	 * Compose a new subgraph with the nodes connected to a given node.
	 */
	exports.subgraph_node_conn = function(graph, node_id, dir) {
	    if (!has_node(graph, node_id))
	        m_util.panic("No such node");

	    var visit_state = {};
	    set_unvisited(graph, visit_state);

	    subgraph_node_conn_iter(graph, node_id, visit_state, dir);

	    var new_nodes = [];
	    for (var id in visit_state) {
	        if (visit_state[id]) {
	            // String->Number conversion
	            var id = Number(id);
	            new_nodes.push(id, get_node_attr(graph, id));
	        }
	    }

	    var new_graph = {
	        nodes: new_nodes,
	        edges: graph.edges.slice(0)
	    };
	    cleanup_loose_edges(new_graph);

	    return new_graph;
	};

	function subgraph_node_conn_iter(graph, node_id, visit_state, dir) {
	    if (!visit_state[node_id]) {
	        visit_state[node_id] = true;

	        if (dir == FORWARD_DIR || dir == TWO_WAY) {
	            for (var i = 0; i < out_edge_count(graph, node_id); i++) {
	                var other = get_out_edge(graph, node_id, i);
	                subgraph_node_conn_iter(graph, other, visit_state, dir);
	            }
	        }

	        if (dir == BACKWARD_DIR || dir == TWO_WAY) {
	            for (var i = 0; i < in_edge_count(graph, node_id); i++) {
	                var other = get_in_edge(graph, node_id, i);
	                subgraph_node_conn_iter(graph, other, visit_state, dir);
	            }
	        }
	    }
	}

	exports.cleanup_loose_edges = cleanup_loose_edges;
	function cleanup_loose_edges(graph) {
	    var edges = graph.edges;

	    for (var i = 0; i < edges.length; i+=3) {
	        var node1 = edges[i];
	        var node2 = edges[i+1];

	        // remove half-edges too
	        if (!has_node(graph, node1) || !has_node(graph, node2)) {
	            edges.splice(i, 3);
	            i-=3;
	        }
	    }
	}

	/**
	 * Find array of nodes with 0 in-degree.
	 */
	exports.get_source_nodes = function(graph) {
	    var result = [];

	    var nodes = graph.nodes;
	    for (var i = 0; i < nodes.length; i+=2) {
	        var node = nodes[i];
	        if (!in_edge_count(graph, node))
	            result.push(node);
	    }

	    return result;
	};

	/**
	 * Find array of nodes with 0 out-degree.
	 */
	exports.get_sink_nodes = get_sink_nodes;
	function get_sink_nodes(graph) {
	    var result = [];

	    var nodes = graph.nodes;
	    for (var i = 0; i < nodes.length; i+=2) {
	        var node = nodes[i];
	        if (!out_edge_count(graph, node))
	            result.push(node);
	    }

	    return result;
	}

	/**
	 * Search for graph2 subgraph isomorphic to graph1 using VF2 algorithm.
	 * graph1 <= graph2
	 * @see VFLIB implementation
	 * @param graph1 Graph 1 (small one)
	 * @param graph2 Graph 2 (big one)
	 * @param [node_comp] Node attribute comparator function
	 * @param [edge_comp] Edge attribute comparator function
	 * @returns Pair [nodes_in_1, nodes_in_2] or null
	 */
	exports.match = function(graph1, graph2, node_comp, edge_comp) {
	    var state = {};

	    // NOTE: current VFLIB implementation require strict node order:
	    // ID1, ID2, ID3 -> 0, 1, 2
	    state.g1 = gen_ordered_graph(graph1);
	    state.g2 = gen_ordered_graph(graph2);

	    state.node_comp = node_comp ||
	        function(attr1, attr2) {
	            return (attr1 == attr2);
	        };

	    state.edge_comp = edge_comp ||
	        function(attr1, attr2) {
	            return (attr1 == attr2);
	        };

	    var n1 = node_count(graph1);
	    var n2 = node_count(graph2);
	    state.n1 = n1;
	    state.n2 = n2;

	    // NOTE: for compatibility
	    state.order = NULL;

	    state.core_len = state.orig_core_len = 0;
	    state.t1both_len = state.t1in_len = state.t1out_len = 0;
	    state.t2both_len = state.t2in_len = state.t2out_len = 0;

	    state.added_node1 = NULL_NODE;

	    state.core_1 = Array(n1);
	    state.core_2 = Array(n2);

	    state.in_1 = new Array(n1);
	    state.in_2 = new Array(n2);
	    state.out_1 = new Array(n1);
	    state.out_2 = new Array(n2);

	    // NOTE: simulate *var = 1 pattern
	    state.share_count = [1];

	    for (var i = 0; i < n1; i++) {
	        state.core_1[i] = NULL_NODE;

	        state.in_1[i] = 0;
	        state.out_1[i] = 0;
	    }

	    for (var i = 0; i < n2; i++) {
	        state.core_2[i] = NULL_NODE;

	        state.in_2[i] = 0;
	        state.out_2[i] = 0;
	    }

	    var c1 = new Array(n1);
	    var c2 = new Array(n1);

	    var res = match_iter(c1, c2, state);
	    if (res) {
	        // calculate original node IDs
	        for (var i = 0; i < c1.length; i++) {
	            c1[i] = graph1.nodes[2*c1[i]];
	            c2[i] = graph2.nodes[2*c2[i]];
	        }
	        return [c1, c2];
	    } else
	        return null;
	};

	function node_count(graph) {
	    return graph.nodes.length / 2;
	}

	/**
	 * Place node IDs in strict succession, so graph.nodes[2*i] == i
	 */
	function gen_ordered_graph(graph) {
	    var nodes = graph.nodes;
	    var edges = graph.edges;

	    var new_nodes = [];
	    var new_edges = [];

	    // old graph node ID -> new graph node ID
	    var map = [];

	    for (var i = 0; i < nodes.length; i++) {
	        map[nodes[2*i]] = i;
	        new_nodes.push(i, nodes[2*i+1]);
	    }

	    for (var i = 0; i < edges.length; i+=3) {
	        new_edges.push(map[edges[i]], map[edges[i+1]], edges[i+2]);
	    }

	    var new_graph = {
	        nodes: new_nodes,
	        edges: new_edges
	    };

	    return new_graph;
	}


	function match_iter(c1, c2, state) {
	    if (state_is_goal(state)) {
	        state_get_core_set(state, c1, c2);
	        return true;
	    }

	    if (state_is_dead(state))
	        return false;

	    var n1 = NULL_NODE;
	    var n2 = NULL_NODE;
	    var found = false;

	    while (!found && state_next_pair(state, _next_pair_cache, n1, n2)) {
	        n1 = _next_pair_cache[0];
	        n2 = _next_pair_cache[1];

	        if (state_is_feasible_pair(state, n1, n2)) {
	            var new_state = state_clone(state);
	            state_add_pair(new_state, n1, n2);
	            found = match_iter(c1, c2, new_state);
	            state_back_track(new_state);
	        }
	    }
	    return found;
	}

	function state_is_goal(state) {
	    return (state.core_len == state.n1);
	}

	function state_get_core_set(state, c1, c2) {
	    for (var i = 0, j = 0; i < state.n1; i++)
	        if (state.core_1[i] != NULL_NODE) {
	            c1[j] = i;
	            c2[j] = state.core_1[i];
	            j++;
	        }
	}

	function state_is_dead(state) {
	    return (state.n1 > state.n2 || state.t1both_len > state.t2both_len ||
	            state.t1out_len > state.t2out_len || state.t1in_len > state.t2in_len);
	}

	function state_next_pair(state, next_pair, prev_n1, prev_n2) {
	    if (prev_n1 == NULL_NODE)
	        prev_n1 = 0;

	    if (prev_n2 == NULL_NODE)
	        prev_n2 = 0;
	    else
	        prev_n2++;

	    var t1both_len = state.t1both_len;
	    var t2both_len = state.t2both_len;
	    var t1out_len = state.t1out_len;
	    var t2out_len = state.t2out_len;
	    var t1in_len = state.t1in_len;
	    var t2in_len = state.t2in_len;
	    var core_len = state.core_len;

	    var n1 = state.n1;
	    var n2 = state.n2;

	    var core_1 = state.core_1;
	    var core_2 = state.core_2;
	    var in_1 = state.in_1;
	    var in_2 = state.in_2;
	    var out_1 = state.out_1;
	    var out_2 = state.out_2;

	    if (t1both_len > core_len && t2both_len > core_len) {
	        while (prev_n1 < n1 && (core_1[prev_n1] != NULL_NODE ||
	                out_1[prev_n1] == 0 || in_1[prev_n1] == 0)) {
	            prev_n1++;
	            prev_n2 = 0;
	        }
	    } else if (t1out_len > core_len && t2out_len > core_len) {
	        while (prev_n1 < n1 && (core_1[prev_n1] != NULL_NODE || out_1[prev_n1] == 0)) {
	            prev_n1++;
	            prev_n2 = 0;
	        }
	    } else if (t1in_len > core_len && t2in_len > core_len) {
	        while (prev_n1 < n1 && (core_1[prev_n1] != NULL_NODE || in_1[prev_n1] == 0)) {
	            prev_n1++;
	            prev_n2 = 0;
	        }
	    // NOTE: order is not supported
	    } else if (prev_n1 == 0 && state.order != NULL) {
	        var i = 0;
	        while (i < n1 && core_1[prev_n1 = state.order[i]] != NULL_NODE)
	            i++;
	        if (i == n1)
	            prev_n1 = n1;
	    } else {
	        while (prev_n1 < n1 && core_1[prev_n1] != NULL_NODE) {
	            prev_n1++;
	            prev_n2 = 0;
	        }
	    }

	    if (t1both_len > core_len && t2both_len > core_len) {
	        while (prev_n2 < n2 && (core_2[prev_n2] != NULL_NODE ||
	                out_2[prev_n2] == 0 || in_2[prev_n2] == 0)) {
	            prev_n2++;
	        }
	    } else if (t1out_len > core_len && t2out_len > core_len) {
	        while (prev_n2 < n2 && (core_2[prev_n2] != NULL_NODE || out_2[prev_n2] == 0)) {
	            prev_n2++;
	        }
	    } else if (t1in_len > core_len && t2in_len > core_len) {
	        while (prev_n2 < n2 && (core_2[prev_n2] != NULL_NODE || in_2[prev_n2] == 0)) {
	            prev_n2++;
	        }
	    } else {
	        while (prev_n2 < n2 && core_2[prev_n2] != NULL_NODE) {
	            prev_n2++;
	        }
	    }

	    if (prev_n1 < n1 && prev_n2 < n2) {
	        // *pn1, *pn2
	        next_pair[0] = prev_n1;
	        next_pair[1] = prev_n2;
	        return true;
	    }

	    return false;
	}

	function state_is_feasible_pair(state, node1, node2) {

	    var g1 = state.g1;
	    var g2 = state.g2;

	    var n1 = state.n1;
	    var n2 = state.n2;

	    var core_1 = state.core_1;
	    var core_2 = state.core_2;
	    var in_1 = state.in_1;
	    var in_2 = state.in_2;
	    var out_1 = state.out_1;
	    var out_2 = state.out_2;

	    assert(node1 < n1);
	    assert(node2 < n2);
	    assert(core_1[node1] == NULL_NODE);
	    assert(core_2[node2] == NULL_NODE);

	    if (!compatible_node(state.node_comp, g1, node1, g2, node2))
	        return false;

	    var termout1=0, termout2=0, termin1=0, termin2=0, new1=0, new2=0;

	    // Check the 'out' edges of node1
	    for (var i = 0; i < out_edge_count(g1, node1); i++) {
	        var other1 = get_out_edge(g1, node1, i);

	        if (core_1[other1] != NULL_NODE) {
	            var other2 = core_1[other1];
	            if (!has_edge(g2, node2, other2) ||
	                    !compatible_edge(state.edge_comp, g1, node1, other1, g2,
	                            node2, other2))
	                return false;
	        } else {
	            if (in_1[other1])
	                termin1++;
	            if (out_1[other1])
	                termout1++;
	            if (!in_1[other1] && !out_1[other1])
	                new1++;
	        }
	    }

	    // Check the 'in' edges of node1
	    for (var i = 0; i < in_edge_count(g1, node1); i++) {
	        var other1 = get_in_edge(g1, node1, i);

	        if (core_1[other1] != NULL_NODE) {
	            var other2 = core_1[other1];
	            if (!has_edge(g2, other2, node2) ||
	                    !compatible_edge(state.edge_comp, g1, other1, node1, g2,
	                            other2, node2))
	                return false;
	        } else {
	            if (in_1[other1])
	                termin1++;
	            if (out_1[other1])
	                termout1++;
	            if (!in_1[other1] && !out_1[other1])
	                new1++;
	        }
	    }

	    // Check the 'out' edges of node2
	    for (var i = 0; i < out_edge_count(g2, node2); i++) {
	        var other2 = get_out_edge(g2, node2, i);
	        if (core_2[other2] != NULL_NODE) {
	            var other1 = core_2[other2];
	            if (!has_edge(g1, node1, other1))
	                return false;
	        } else {
	            if (in_2[other2])
	                termin2++;
	            if (out_2[other2])
	                termout2++;
	            if (!in_2[other2] && !out_2[other2])
	                new2++;
	        }
	    }

	    // Check the 'in' edges of node2
	    for (var i = 0; i < in_edge_count(g2, node2); i++) {
	        var other2 = get_in_edge(g2, node2, i);
	        if (core_2[other2] != NULL_NODE) {
	            var other1 = core_2[other2];
	            if (!has_edge(g1, other1, node1))
	                return false;
	        } else {
	            if (in_2[other2])
	                termin2++;
	            if (out_2[other2])
	                termout2++;
	            if (!in_2[other2] && !out_2[other2])
	                new2++;
	        }
	    }

	    return (termin1<=termin2 && termout1<=termout2 && new1<=new2);
	}

	// NOTE: temporary debug solution
	function assert(expr) {
	    if (!expr)
	        m_util.panic("Assertion failed");
	}

	/**
	 * Compare node attributes
	 */
	function compatible_node(node_comp, graph1, node1, graph2, node2) {
	    if (node_comp(get_node_attr(graph1, node1), get_node_attr(graph2, node2)))
	        return true;
	    else
	        return false;
	}

	exports.get_node_id = function(graph, attr) {
	    var nodes = graph.nodes;

	    for (var i = 1; i < nodes.length; i+=2) {
	        if (nodes[i] == attr)
	            return nodes[i-1];
	    }

	    return null;
	};

	exports.get_node_attr = get_node_attr;
	function get_node_attr(graph, node) {
	    var nodes = graph.nodes;

	    for (var i = 0; i < nodes.length; i+=2) {
	        if (nodes[i] == node)
	            return nodes[i+1];
	    }

	    return null;
	}

	exports.out_edge_count = out_edge_count;
	function out_edge_count(graph, node) {
	    var edges = graph.edges;
	    var count = 0;

	    for (var i = 0; i < edges.length; i+=3)
	        if (edges[i] == node)
	            count++;

	    return count;
	}

	exports.in_edge_count = in_edge_count;
	function in_edge_count(graph, node) {
	    var edges = graph.edges;
	    var count = 0;

	    for (var i = 0; i < edges.length; i+=3)
	        if (edges[i+1] == node)
	            count++;

	    return count;
	}

	exports.get_out_edge = get_out_edge;
	function get_out_edge(graph, node, num) {
	    var edges = graph.edges;
	    var count = 0;

	    for (var i = 0; i < edges.length; i+=3) {
	        if (edges[i] == node) {

	            if (count == num)
	                return edges[i+1];

	            count++;
	        }
	    }

	    return NULL_NODE;
	}

	exports.get_in_edge = get_in_edge;
	function get_in_edge(graph, node, num) {
	    var edges = graph.edges;
	    var count = 0;

	    for (var i = 0; i < edges.length; i+=3) {
	        if (edges[i+1] == node) {

	            if (count == num)
	                return edges[i];

	            count++;
	        }
	    }

	    return NULL_NODE;
	}

	function has_edge(graph, node1, node2) {
	    var edges = graph.edges;

	    for (var i = 0; i < edges.length; i+=3)
	        if (edges[i] == node1 && edges[i+1] == node2)
	            return true;

	    return false;
	}

	function compatible_edge(edge_comp, graph1, node11, node12, graph2, node21, node22) {

	    var graph1_edge_count = get_edge_count(graph1, node11, node12);
	    var graph2_edge_count = get_edge_count(graph2, node21, node22);

	    // NOTE: for each edge in graph1 find compatible in graph2

	    for (var i = 0; i < graph1_edge_count; i++) {
	        var edge_match = false;

	        for (var j = 0; j < graph2_edge_count; j++) {
	            if (edge_comp(get_edge_attr(graph1, node11, node12, i),
	                    get_edge_attr(graph2, node21, node22, j))) {
	                edge_match = true;
	                break;
	            }
	        }

	        if (!edge_match)
	            return false;
	    }

	    return true;
	}

	exports.get_edge_count = get_edge_count;
	function get_edge_count(graph, node1, node2) {
	    var count = 0;
	    var edges = graph.edges;

	    for (var i = 0; i < edges.length; i+=3) {
	        if (edges[i] == node1 && edges[i+1] == node2)
	            count++;
	    }

	    return count;
	}

	exports.get_edge_attr = get_edge_attr;
	function get_edge_attr(graph, node1, node2, num) {
	    var edges = graph.edges;
	    var count = 0;

	    for (var i = 0; i < edges.length; i+=3) {
	        if (edges[i] == node1 && edges[i+1] == node2) {
	            if (count == num)
	                return edges[i+2];
	            count++;
	        }
	    }

	    return null;
	}

	function state_add_pair(state, node1, node2) {
	    var g1 = state.g1;
	    var g2 = state.g2;

	    var n1 = state.n1;
	    var n2 = state.n2;

	    var core_1 = state.core_1;
	    var core_2 = state.core_2;
	    var in_1 = state.in_1;
	    var in_2 = state.in_2;
	    var out_1 = state.out_1;
	    var out_2 = state.out_2;

	    assert(node1<n1);
	    assert(node2<n2);
	    assert(state.core_len<n1);
	    assert(state.core_len<n2);

	    var core_len = (++state.core_len);

	    state.added_node1 = node1;

	    if (!in_1[node1]) {
	        in_1[node1] = core_len;
	        state.t1in_len++;
	        if (out_1[node1])
	            state.t1both_len++;
	    }
	    if (!out_1[node1]) {
	        out_1[node1] = core_len;
	        state.t1out_len++;
	        if (in_1[node1])
	            state.t1both_len++;
	    }

	    if (!in_2[node2]) {
	        in_2[node2] = core_len;
	        state.t2in_len++;
	        if (out_2[node2])
	            state.t2both_len++;
	    }
	    if (!out_2[node2]) {
	        out_2[node2] = core_len;
	        state.t2out_len++;
	        if (in_2[node2])
	            state.t2both_len++;
	    }

	    core_1[node1] = node2;
	    core_2[node2] = node1;

	    for (var i = 0; i < in_edge_count(g1, node1); i++) {
	        var other = get_in_edge(g1, node1, i);
	        if (!in_1[other]) {
	            in_1[other] = core_len;
	            state.t1in_len++;
	            if (out_1[other])
	                state.t1both_len++;
	        }
	    }

	    for (var i = 0; i < out_edge_count(g1, node1); i++) {
	        var other = get_out_edge(g1, node1, i);
	        if (!out_1[other]) {
	            out_1[other] = core_len;
	            state.t1out_len++;
	            if (in_1[other])
	                state.t1both_len++;
	        }
	    }

	    for (var i = 0; i < in_edge_count(g2, node2); i++) {
	        var other = get_in_edge(g2, node2, i);
	        if (!in_2[other]) {
	            in_2[other] = core_len;
	            state.t2in_len++;
	            if (out_2[other])
	                state.t2both_len++;
	        }
	    }

	    for (var i = 0; i < out_edge_count(g2, node2); i++) {
	        var other = get_out_edge(g2, node2, i);
	        if (!out_2[other]) {
	            out_2[other]=core_len;
	            state.t2out_len++;
	            if (in_2[other])
	                state.t2both_len++;
	        }
	    }
	}

	function state_back_track(state) {

	    assert(state.core_len - state.orig_core_len <= 1);
	    assert(state.added_node1 != NULL_NODE);

	    var g1 = state.g1;
	    var g2 = state.g2;

	    var core_len = state.core_len;
	    var added_node1 = state.added_node1;

	    var core_1 = state.core_1;
	    var core_2 = state.core_2;
	    var in_1 = state.in_1;
	    var in_2 = state.in_2;
	    var out_1 = state.out_1;
	    var out_2 = state.out_2;

	    if (state.orig_core_len < core_len) {
	        if (in_1[added_node1] == core_len)
	            in_1[added_node1] = 0;
	        for (var i = 0; i < in_edge_count(g1, added_node1); i++) {
	            var other = get_in_edge(g1, added_node1, i);
	            if (in_1[other] == core_len)
	                in_1[other]=0;
	        }

	        if (out_1[added_node1] == core_len)
	            out_1[added_node1] = 0;
	        for (var i = 0; i < out_edge_count(g1, added_node1); i++) {
	            var other = get_out_edge(g1, added_node1, i);
	            if (out_1[other] == core_len)
	                out_1[other] = 0;
	        }

	        var node2 = core_1[added_node1];

	        if (in_2[node2] == core_len)
	            in_2[node2] = 0;
	        for (var i = 0; i < in_edge_count(g2, node2); i++) {
	            var other = get_in_edge(g2, node2, i);
	            if (in_2[other] == core_len)
	                in_2[other] = 0;
	        }

	        if (out_2[node2] == core_len)
	            out_2[node2] = 0;

	        for (var i = 0; i < out_edge_count(g2, node2); i++) {
	            var other = get_out_edge(g2, node2, i);
	            if (out_2[other] == core_len)
	                out_2[other] = 0;
	        }

	        core_1[added_node1] = NULL_NODE;
	        core_2[node2] = NULL_NODE;

	        state.core_len = state.orig_core_len;
	        state.added_node1 = NULL_NODE;
	    }
	}

	function state_clone(state) {

	    // GARBAGE
	    var new_state = {};
	    new_state.g1 = state.g1;
	    new_state.g2 = state.g2;
	    new_state.node_comp = state.node_comp;
	    new_state.edge_comp = state.edge_comp;

	    new_state.n1 = state.n1;
	    new_state.n2 = state.n2;

	    new_state.order = state.order;

	    new_state.core_len = new_state.orig_core_len = state.core_len;
	    new_state.t1in_len = state.t1in_len;
	    new_state.t1out_len = state.t1out_len;
	    new_state.t1both_len = state.t1both_len;
	    new_state.t2in_len = state.t2in_len;
	    new_state.t2out_len = state.t2out_len;
	    new_state.t2both_len = state.t2both_len;

	    new_state.added_node1 = NULL_NODE;

	    new_state.core_1 = state.core_1;
	    new_state.core_2 = state.core_2;
	    new_state.in_1 = state.in_1;
	    new_state.in_2 = state.in_2;
	    new_state.out_1 = state.out_1;
	    new_state.out_2 = state.out_2;

	    new_state.share_count = state.share_count;

	    state.share_count[0] += 1;

	    return new_state;
	}


	/**
	 * Replace the nodes by the new one with the given attribute.
	 * may create multigraph (multiple edges connecting same nodes)
	 */
	exports.replace = function(graph, rnode_ids, new_node_attr) {
	    var edges = graph.edges;

	    var new_node_id = gen_node_id(graph);

	    for (var i = 0; i < rnode_ids.length; i++) {
	        var rnode_id = rnode_ids[i];

	        remove_node(graph, rnode_id);

	        for (var j = 0; j < edges.length; j+=3) {
	            if (edges[j] == rnode_id)
	                edges[j] = new_node_id;

	            if (edges[j+1] == rnode_id)
	                edges[j+1] = new_node_id;

	            // remove self-loops
	            if (edges[j] == edges[j+1]) {
	                edges.splice(j, 3);
	                j-=3;
	            }
	        }
	    }

	    append_node(graph, new_node_id, new_node_attr);
	};

	/**
	 * Reconnect all edges connecting two given node IDs.
	 */
	exports.reconnect_edges = function(graph, id1, id2, new_id1, new_id2) {
	    if (!has_edge(graph, id1, id2))
	        m_util.panic("Edge not found");

	    var edges = graph.edges;

	    for (var i = 0; i < edges.length; i+=3)
	        if (edges[i] == id1 && edges[i+1] == id2) {
	            edges[i] = new_id1;
	            edges[i+1] = new_id2;
	        }
	};
	/**
	 * Remove redundant edges and create acyclic graph
	 */
	exports.enforce_acyclic = function(graph, main_node) {

	    if (!main_node)
	        main_node = get_sink_nodes(graph)[0];
	    var edges = graph.edges;
	    if (!edges.length || edges.indexOf(main_node) == -1)
	        return graph;
	    var graph_data = {};
	    var count = 0;
	    for (var i = 0; i < edges.length; i=i+3) {
	        if (edges[i + 1] in graph_data)
	            graph_data[edges[i + 1]].push(edges[i]);
	        else
	            graph_data[edges[i + 1]] = [edges[i]];
	        count++;
	    }

	    var tracking = [];
	    var wrong_edges = [];
	    function find_redundant_edges(node, top_edges) {
	        var index = tracking.indexOf(node);
	        if (index != -1) {
	            var cycle = tracking.slice(tracking.indexOf(node));
	            if (graph_data[cycle[cycle.length - 1]].indexOf(cycle[0]) != -1) {
	                wrong_edges.push([node, cycle[cycle.length - 1]]);
	                return;
	            }
	        }
	        tracking.push(node);
	        for (var i = 0; i < top_edges.length; i++) {
	            if (top_edges[i] in graph_data)
	                find_redundant_edges(top_edges[i], graph_data[top_edges[i]]);
	        }
	    }

	    find_redundant_edges(main_node, graph_data[main_node]);

	    for (var i = 0; i < wrong_edges.length; i++) {
	            count = 0;
	            for (var k = 0; k < edges.length; k=k+3) {
	                if (wrong_edges[i][1] == edges[k + 1] && wrong_edges[i][0] == edges[k])
	                    remove_edge(graph, edges[k], edges[k+1], count);
	                count++;
	            }
	    }
	    return graph;
	};

	exports.debug_dot = function(graph, node_label_cb, edge_label_cb) {
	    var nodes = graph.nodes;
	    var edges = graph.edges;

	    var dot_str = "digraph debug {\n";

	    dot_str += "    ";
	    dot_str += "node [shape=box];\n";

	    for (var i = 0; i < nodes.length; i+=2) {
	        var node = nodes[i];
	        var attr = nodes[i+1];

	        var label = node_label_cb ? node_label_cb(node, attr) : String(node);

	        dot_str += "    ";
	        dot_str += String(node) + " [label=\"" + label.replace(/\"/g, "\\\"") + "\"];\n";
	    }

	    for (var i = 0; i < edges.length; i+=3) {
	        var node1 = edges[i];
	        var node2 = edges[i+1];
	        var attr = edges[i+2];

	        dot_str += "    ";
	        dot_str += String(node1) + " -> " + String(node2);
	        if (edge_label_cb)
	            dot_str += " [label=\"" + edge_label_cb(node1, node2, attr) + "\"]";
	        dot_str += ";\n";
	    }

	    dot_str += "}";

	    return dot_str;
	};

	}

	var int_graph_factory = register("__graph", Int_graph);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Geometry internal API.
	 * Don't forget to register GL context by setup_context() function.
	 * @name geometry
	 * @namespace
	 * @exports exports as geometry
	 */
	function Int_geometry(ns, exports) {

	var m_bounds = int_boundings_factory(ns);
	var m_ext    = int_extensions_factory(ns);
	var m_print  = print_factory(ns);
	var m_quat   = quat_factory(ns);
	var m_tbn    = int_tbn_factory(ns);
	var m_tsr    = int_tsr_factory(ns);
	var m_util   = int_util_factory(ns);
	var m_vec3   = vec3_factory(ns);

	var _tbn_tmp = m_tbn.create();
	var _tbn_tmp2 = m_tbn.create();
	var _tbn_tmp3 = m_tbn.create();
	var _vec3_tmp = new Float32Array(3);
	var _vec3_tmp2 = new Float32Array(3);
	var _vec3_tmp3 = new Float32Array(3);
	var _quat_tmp = m_quat.create();

	var _tsr_tmp = new Float32Array(8);

	var MAX_SUBMESH_LENGTH = 256*256;

	var COMB_SORT_JUMP_COEFF = 1.247330950103979;

	// numbers of components per attribute
	var POS_NUM_COMP = 3;
	var NOR_NUM_COMP = 3;
	var COL_NUM_COMP = 3;
	var TCO_NUM_COMP = 2;
	var SHD_TAN_NUM_COMP = 3;

	var INFLUENCE_NUM_COMP = 4;

	// draw modes
	exports.DM_TRIANGLES         = 10;
	exports.DM_DYNAMIC_TRIANGLES = 20;

	exports.SORT_NUMERIC = 0;
	exports.SORT_STRING = 1;

	exports.DM_DEFAULT = exports.DM_TRIANGLES;

	var _gl = null;

	// NOTE: should be strings as object keys
	var VBO_FLOAT = "float";
	var VBO_SHORT = "short";
	var VBO_UBYTE = "unsigned_byte";

	exports.VBO_FLOAT = VBO_FLOAT;
	exports.VBO_SHORT = VBO_SHORT;
	exports.VBO_UBYTE = VBO_UBYTE;

	/**
	 * Setup WebGL context
	 * @param gl WebGL context
	 */
	exports.setup_context = function(gl) {
	    _gl = gl;
	};

	function init_attr_pointer() {
	    var p = {
	        length: 0,
	        frames: 1,

	        num_comp: 0,
	        offset: 0,
	        divisor: 0
	    };

	    return p;
	}

	/**
	 * Convert mesh/material object to gl buffer data
	 */
	exports.submesh_to_bufs_data = function(submesh, draw_mode, vc_usage) {
	    if (is_long_submesh(submesh))
	        submesh_drop_indices(submesh);

	    var indices = submesh.indices;
	    var base_length = submesh.base_length;
	    var va_frames = submesh.va_frames;
	    var va_common = {};
	    for (var attr_name in submesh.va_common)
	        if (!(attr_name in vc_usage) || vc_usage[attr_name].generate_buffer)
	            va_common[attr_name] = submesh.va_common[attr_name];
	    var bufs_data = init_bufs_data();
	    if (submesh.shape_keys.length > 0)
	        submesh_init_shape_keys(submesh, va_frames[0]);
	    generate_bufs_data_arrays(bufs_data, indices, va_frames, va_common,
	            base_length, submesh.instanced_array_data);
	    update_draw_mode(bufs_data, draw_mode);
	    update_gl_buffers(bufs_data);

	    bufs_data.shape_keys = submesh.shape_keys;

	    return bufs_data;
	};

	exports.submesh_init_shape_keys = submesh_init_shape_keys;
	function submesh_init_shape_keys(submesh, frame) {
	    var f_a_tbn = frame["a_tbn"];
	    var f_a_pos = frame["a_position"];

	    var pos_length = f_a_pos.length;

	    // position
	    for (var i = 1; i < submesh.shape_keys.length; i++) {

	        var geometry = submesh.shape_keys[i].geometry;
	        var value = submesh.shape_keys[i].init_value;

	        var a_pos = geometry["a_position"];

	        for (var j = 0; j < pos_length; j++)
	            f_a_pos[j] += value * a_pos[j];
	    }

	    // tbn
	    var count = m_tbn.get_items_count(f_a_tbn);
	    for (var i = 0; i < count; i++) {
	        var delta_tbn = m_tbn.identity(_tbn_tmp);

	        for (var j = 1; j < submesh.shape_keys.length; j++) {
	            var a_tbn = submesh.shape_keys[j].geometry["a_tbn"];
	            var value = submesh.shape_keys[j].init_value;
	            if (!value)
	                continue;

	            var d_tbn = m_tbn.get_item(a_tbn, i, _tbn_tmp2);
	            var cur_d_tbn = m_tbn.slerp(m_tbn.identity(_tbn_tmp3), d_tbn,
	                    value, _tbn_tmp2);
	            m_tbn.multiply_tbn(cur_d_tbn, delta_tbn, delta_tbn);
	        }

	        var b_tbn = m_tbn.get_item(f_a_tbn, i, _tbn_tmp2);
	        var r_tbn = m_tbn.multiply_tbn(delta_tbn, b_tbn, _tbn_tmp2);

	        m_tbn.set_item(f_a_tbn, r_tbn, i);
	    }
	}

	exports.is_long_submesh = is_long_submesh;
	/**
	 * Check is given submesh is too long to have indices.
	 * Max index value is
	 * @methodOf geometry
	 */
	function is_long_submesh(submesh) {

	    var base_length = submesh.base_length;

	    if (base_length > MAX_SUBMESH_LENGTH) {

	        if (m_ext.get_elem_index_uint())
	            return false;

	        return true;
	    }

	    return false;
	}

	exports.is_indexed = is_indexed;
	/**
	 * Check if submesh is indexed one
	 */
	function is_indexed(submesh) {
	    if (submesh.indices.length > 0)
	        return true;
	    else
	        return false;
	}

	exports.submesh_drop_indices = submesh_drop_indices;
	/**
	 * Drop indices from long submesh and recalculate all VAs
	 */
	function submesh_drop_indices(submesh, count, is_manually_dropped) {

	    if (!is_indexed(submesh))
	        return submesh;

	    count = count || 1;

	    if (!is_manually_dropped)
	    m_print.log("%cDEBUG max vertices exceeded for indexed submesh \"" +
	            submesh.name + "\": " + submesh.base_length * count +
	            ", will use drawArrays", "color: #aa0");

	    var indices = submesh.indices;
	    var base_length = submesh.base_length;
	    var va_common = submesh.va_common;
	    var va_frames = submesh.va_frames;

	    for (var name in va_common) {
	        var arr = va_common[name];
	        var nc = num_comp(arr, base_length);
	        va_common[name] = expand_vertex_array_i(indices, arr, nc);
	    }

	    for (var i = 0; i < va_frames.length; i++) {
	        var va_frame = va_frames[i];

	        for (var name in va_frame) {

	            var arr = va_frame[name];
	            var nc = num_comp(arr, base_length);
	            va_frame[name] = expand_vertex_array_i(indices, arr, nc);
	        }
	    }

	    for (var i = 0; i < submesh.shape_keys.length; i++) {

	        var geometry = submesh.shape_keys[i].geometry;

	        for (var att_name in geometry) {

	            var arr = geometry[att_name];

	            var nc = num_comp(arr, base_length);
	            geometry[att_name] = expand_vertex_array_i(indices, arr, nc);
	        }
	    }

	    submesh.base_length = indices.length;
	    submesh.indices = new Uint16Array(0);

	    return submesh;
	}

	/**
	 * Create a new vertex array value for each index
	 */
	function expand_vertex_array_i(indices, vertex_array, num_comp) {

	    if (vertex_array.length == 0)
	        return new Float32Array(0);

	    var len = indices.length * num_comp;
	    var new_vertex_array = new Float32Array(len);

	    for (var i = 0; i < indices.length; i++) {
	        var index = indices[i];

	        for (var j = 0; j < num_comp; j++)
	            new_vertex_array[num_comp*i + j] =
	                    vertex_array[num_comp*index + j];
	    }

	    return new_vertex_array;
	}

	/**
	 * Update index array for buffers data
	 * @param {Object3D} bufs_data Buffers data
	 * @param {number} draw_mode Buffers draw mode
	 * @param {Uint16Array|Uint32Array} indices Indices specified for TRIANGLES rendering
	 */
	exports.update_bufs_data_index_array = function(bufs_data, draw_mode, indices) {
	    update_draw_mode(bufs_data, draw_mode);

	    bufs_data.count = indices.length;
	    bufs_data.ibo_array = indices;

	    if (indices instanceof Uint16Array)
	        bufs_data.ibo_type = _gl.UNSIGNED_SHORT;
	    else
	        bufs_data.ibo_type = _gl.UNSIGNED_INT;

	    return bufs_data;
	};

	function init_bufs_data() {
	    return {
	        ibo_array: null,
	        vbo_source_data: init_vbo_source_data(),
	        ibo_type: 0,
	        count: 0,
	        pointers: {},
	        usage: 0,
	        debug_ibo_bytes: 0,
	        debug_vbo_bytes: 0,
	        vbo_data: [],
	        ibo: null,
	        shape_keys: null,
	        instance_count: 1,

	        cleanup_gl_data_on_unload: true
	    }
	}

	/**
	 * Append or replace attribute array
	 * @param {Float32Array|Int16Array|Uint8Array} array Attribute array
	 */
	exports.update_bufs_data_array = update_bufs_data_array;
	function update_bufs_data_array(bufs_data, attrib_name, num_comp, array) {
	    if (attrib_name == "a_normal") {
	        var tbn = m_tbn.from_norm_tan(array);
	        return update_bufs_data_array(bufs_data, "a_tbn", num_comp, tbn);
	    }

	    var pointers = bufs_data.pointers;

	    var pointer = pointers[attrib_name];
	    var type = get_vbo_type_by_attr_name(attrib_name);
	    if (pointer) {
	        // replace attribute data
	        if (num_comp && pointer.num_comp != num_comp)
	            m_util.panic("invalid num_comp for \"" + attrib_name + "\"");

	        vbo_source_data_set_attr(bufs_data.vbo_source_data, attrib_name, array, 
	                pointer.offset);
	    } else {
	        // append new attribute data
	        var index = search_vbo_index_by_type(bufs_data.vbo_source_data, type);
	        if (index == -1) {
	            bufs_data.vbo_source_data.push(create_vbo_source_obj(type, 0));
	            index = bufs_data.vbo_source_data.length - 1;
	        }

	        var vbo_source = bufs_data.vbo_source_data[index].vbo_source;

	        var new_vbo_source = new vbo_source.constructor(vbo_source.length + array.length);
	        new_vbo_source.set(vbo_source);
	        bufs_data.vbo_source_data[index].vbo_source = new_vbo_source;

	        vbo_source_data_set_attr(bufs_data.vbo_source_data, attrib_name, array, 
	                vbo_source.length);

	        // append new pointer
	        var p = pointers[attrib_name] = init_attr_pointer();
	        p.num_comp = num_comp;
	        p.offset = vbo_source.length;
	        p.length = array.length;
	    }

	    update_gl_buffers(bufs_data);
	    return bufs_data;
	}

	exports.extract_array_float = extract_array_float;
	/**
	 * Get VBO buffer view by attribute name.
	 * @methodOf geometry
	 * @returns Link to VBO subarray
	 */
	function extract_array_float(bufs_data, name) {
	    if (name == "a_normal") {
	        var a_tbn = extract_array_float(bufs_data, "a_tbn");
	        var count = m_tbn.get_items_count(a_tbn);
	        var a_normal = new Float32Array(count * 3);
	        for (var i = 0; i < count; i++) {
	            var normal = m_tbn.get_norm(a_tbn, i, _vec3_tmp);
	            a_normal.set(normal, i * 3);
	        }
	        return a_normal;
	    } else {
	        var pointer = bufs_data.pointers[name];
	        if (pointer) {
	            var type = get_vbo_type_by_attr_name(name);
	            var vbo_source = get_vbo_source_by_type(bufs_data.vbo_source_data, type);
	            return array_vbo_to_float(name,
	                    vbo_source.subarray(pointer.offset,pointer.offset + pointer.length),
	                    new Float32Array(pointer.length));
	        } else
	            m_util.panic("extract_array_float() failed; invalid name: " + name);
	    }
	}

	/**
	 * Update GL mode (affects draw operations) and GL usage (affects buffers update)
	 * @methodOf geometry
	 */
	function update_draw_mode(bufs_data, draw_mode) {

	    var usage;

	    switch (draw_mode) {
	    case exports.DM_DEFAULT:
	    case exports.DM_TRIANGLES:
	        usage = _gl.STATIC_DRAW;
	        break;
	    case exports.DM_DYNAMIC_TRIANGLES:
	        usage = _gl.DYNAMIC_DRAW;
	        break;
	    default:
	        m_util.panic("Wrong draw_mode");
	    }
	    bufs_data.usage = usage;

	}

	exports.make_static = function(bufs_data) {
	    bufs_data.usage = _gl.STATIC_DRAW;
	};

	exports.make_dynamic = function(bufs_data) {
	    bufs_data.usage = _gl.DYNAMIC_DRAW;
	};

	function generate_bufs_data_arrays(bufs_data, indices, va_frames, va_common,
	        base_length, inst_ar_data) {

	    if (indices.length) {
	        var count = indices.length;
	        if (base_length <= MAX_SUBMESH_LENGTH) {
	            // NOTE: possible transform from Uint32Array, affects performance
	            var ibo_array = new Uint16Array(indices);
	            var ibo_type = _gl.UNSIGNED_SHORT;
	        } else {
	            var ibo_array = new Uint32Array(indices);
	            var ibo_type = _gl.UNSIGNED_INT;
	        }
	    } else {
	        var count = base_length;
	        var ibo_array = null;
	    }

	    var lengths = calc_vbo_lengths(va_frames, va_common, inst_ar_data);
	    var vbo_source_data = init_vbo_source_data(lengths);

	    var offsets = {}; // in elements
	    for (var i = 0; i < vbo_source_data.length; i++)
	        offsets[vbo_source_data[i].type] = 0;

	    var pointers = {};

	    for (var name in va_common) {
	        var arr = va_common[name];
	        var len = arr.length;

	        if (!len)
	            continue;

	        // copy src arrays to vbo
	        var type = get_vbo_type_by_attr_name(name);

	        var p = pointers[name] = init_attr_pointer();
	        p.length = len;
	        p.num_comp = num_comp(arr, base_length);
	        p.offset = offsets[type];

	        vbo_source_data_set_attr(vbo_source_data, name, arr, offsets[type]);
	        offsets[type] += len;
	    }

	    var frames_count = va_frames.length;
	    for (var name in va_frames[0]) {
	        var arr0 = va_frames[0][name];
	        var type = get_vbo_type_by_attr_name(name);
	        var len = arr0.length;
	        var ncomp = num_comp(arr0, base_length);

	        if (!len)
	            continue;

	        var p = pointers[name] = init_attr_pointer();
	        p.length = len;
	        p.frames = frames_count;
	        p.num_comp = ncomp;
	        p.offset = offsets[type];

	        if (frames_count > 1) {
	            p = pointers[name + "_next"] = init_attr_pointer();
	            p.length = len;
	            p.frames = frames_count;
	            p.num_comp = ncomp;
	            p.offset = offsets[type] + len;
	        }

	        for (var i = 0; i < frames_count; i++) {

	            var va_frame = va_frames[i];
	            var arr = va_frame[name];

	            // copy src arrays to vbo
	            type = get_vbo_type_by_attr_name(name);
	            vbo_source_data_set_attr(vbo_source_data, name, arr, offsets[type]);
	            offsets[type] += len;
	        }
	    }
	    if (inst_ar_data) {
	        append_inst_array_data(inst_ar_data, pointers, vbo_source_data, offsets);
	        bufs_data.instance_count = inst_ar_data.tsr_array.length;
	    }

	    bufs_data.count     = count;
	    bufs_data.ibo_array = ibo_array;
	    bufs_data.vbo_source_data = vbo_source_data;
	    bufs_data.ibo_type  = ibo_type;
	    bufs_data.pointers  = pointers;
	}

	function append_inst_array_data(inst_ar_data, pointers, vbo_source_data, offsets) {
	    var tsr_array = inst_ar_data.tsr_array;
	    var em_tsr = inst_ar_data.stat_part_em_tsr;
	    var part_inh_attrs = inst_ar_data.part_inh_attrs;
	    var submesh_params = inst_ar_data.submesh_params;
	    var static_hair = inst_ar_data.static_hair;

	    var attrs_data = {
	        "a_part_ts": { data: [], num_comp: 4 },
	        "a_part_r": { data: [], num_comp: 4 }
	    };
	    for (var name in part_inh_attrs)
	        attrs_data[name] = { data: [], num_comp: part_inh_attrs[name].num_comp };
	    for (var name in submesh_params)
	        attrs_data[name] = { data: [], num_comp: 1 };

	    for (var i = 0; i < tsr_array.length; i++) {
	        var tsr = tsr_array[i];
	        if (static_hair && em_tsr && !inst_ar_data.dyn_grass)
	            tsr = m_tsr.multiply(em_tsr, tsr_array[i], _tsr_tmp);

	        if (!static_hair && inst_ar_data.dyn_grass)
	            m_vec3.subtract(tsr_array[i], em_tsr, tsr_array[i]);

	        attrs_data["a_part_ts"].data.push(tsr[0], tsr[1], tsr[2], tsr[3]);
	        attrs_data["a_part_r"].data.push(tsr[4], tsr[5], tsr[6], tsr[7]);

	        for (var name in part_inh_attrs) {
	            var len = part_inh_attrs[name].num_comp;
	            for (var j = 0; j < len; j++)
	                attrs_data[name].data.push(part_inh_attrs[name].data[i * len + j]);
	        }

	        for (var name in submesh_params)
	            attrs_data[name].data.push(submesh_params[name][0]);
	    }

	    for (var name in attrs_data) {
	        var type = get_vbo_type_by_attr_name(name);
	        vbo_source_data_set_attr(vbo_source_data, name, attrs_data[name].data, 
	                offsets[type]);

	        var pointer = init_attr_pointer();
	        pointer.num_comp = attrs_data[name].num_comp;
	        pointer.offset = offsets[type];
	        pointer.divisor = 1;
	        pointer.length = attrs_data[name].data.length;

	        pointers[name] = pointer;
	        offsets[type] += pointer.length;
	    }
	}

	/**
	 * Calculate vbo length (in elements) needed to store vertex arrays
	 */
	function calc_vbo_lengths(va_frames, va_common, inst_ar_data) {

	    var lengths = {};
	    var inc_length = function(type, value) {
	        if (!lengths[type])
	            lengths[type] = 0;
	        lengths[type] += value;
	    };

	    for (var name in va_frames[0]) {
	        var arr = va_frames[0][name];
	        var type = get_vbo_type_by_attr_name(name);
	        inc_length(type, arr.length * va_frames.length);
	    }

	    for (var name in va_common) {
	        var arr = va_common[name];
	        var type = get_vbo_type_by_attr_name(name);
	        inc_length(type, arr.length);
	    }

	    if (inst_ar_data) {
	        var num_part = inst_ar_data.tsr_array.length;

	        var type = get_vbo_type_by_attr_name("a_part_ts");
	        inc_length(type, num_part * 4);
	        type = get_vbo_type_by_attr_name("a_part_r");
	        inc_length(type, num_part * 4);

	        var part_inh_attrs = inst_ar_data.part_inh_attrs;
	        for (var name in part_inh_attrs) {
	            type = get_vbo_type_by_attr_name(name);
	            inc_length(type, part_inh_attrs[name].num_comp * num_part);
	        }
	        var submesh_params = inst_ar_data.submesh_params;
	        for (var name in submesh_params) {
	            type = get_vbo_type_by_attr_name(name);
	            inc_length(type, num_part);
	        }
	    }

	    return lengths;
	}

	/**
	 * Update gl buffers
	 */
	exports.update_gl_buffers = update_gl_buffers;
	function update_gl_buffers(bufs_data) {
	    // index buffer object
	    if (bufs_data.ibo_array) {

	        if (!bufs_data.ibo)
	            bufs_data.ibo = _gl.createBuffer();

	        _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, bufs_data.ibo);
	        _gl.bufferData(_gl.ELEMENT_ARRAY_BUFFER, bufs_data.ibo_array, bufs_data.usage);

	        bufs_data.debug_ibo_bytes = bufs_data.ibo_array.byteLength;
	    } else
	        bufs_data.debug_ibo_bytes = 0;

	    // vertex buffer objects
	    bufs_data.debug_vbo_bytes = 0;
	    for (var i = 0; i < bufs_data.vbo_source_data.length; i++) {
	        var type = bufs_data.vbo_source_data[i].type;
	        var index = search_vbo_index_by_type(bufs_data.vbo_data, type);

	        if (index == -1) {
	            bufs_data.vbo_data.push({ vbo: null, type: type, debug_id: m_util.unique_id() });
	            index = bufs_data.vbo_data.length - 1;
	        }

	        var vbo_obj = bufs_data.vbo_data[index];
	        if (!vbo_obj.vbo)
	            vbo_obj.vbo = _gl.createBuffer();
	        _gl.bindBuffer(_gl.ARRAY_BUFFER, vbo_obj.vbo);
	        _gl.bufferData(_gl.ARRAY_BUFFER, bufs_data.vbo_source_data[i].vbo_source, bufs_data.usage);

	        bufs_data.debug_vbo_bytes += bufs_data.vbo_source_data[i].vbo_source.byteLength;
	    }
	}

	/**
	 * Partially Update gl buffer using an offset
	 */
	exports.update_gl_buffer_sub_data = update_gl_buffer_sub_data;
	function update_gl_buffer_sub_data(bufs_data, type, data, offset) {
	    // NOTE: do not perform checks for optimization reasons
	    var index = search_vbo_index_by_type(bufs_data.vbo_data, type);
	    var vbo_obj = bufs_data.vbo_data[index];

	    _gl.bindBuffer(_gl.ARRAY_BUFFER, vbo_obj.vbo);
	    _gl.bufferSubData(_gl.ARRAY_BUFFER, m_util.FLOAT_SIZE * offset, data);
	}

	/**
	 * Delete GL Buffer Objects
	 */
	exports.cleanup_bufs_data = function(bufs_data) {
	    if (bufs_data.ibo)
	        _gl.deleteBuffer(bufs_data.ibo);

	    for (var i = 0; i < bufs_data.vbo_data.length; i++)
	        if (bufs_data.vbo_data[i].vbo)
	            _gl.deleteBuffer(bufs_data.vbo_data[i].vbo);

	    bufs_data.vbo_data.length = 0;
	};

	/**
	 * Check if submesh given by index is empty
	 */
	exports.has_empty_submesh = function(mesh, index) {
	    var bsub = mesh["submeshes"][index];

	    if (bsub["base_length"])
	        return false;
	    else
	        return true;
	};

	/**
	 * Apply transforms and return
	 */
	exports.submesh_apply_transform = function(submesh, transform) {

	    // positions/tbn
	    for (var f = 0; f < submesh.va_frames.length; f++) {
	        var positions = submesh.va_frames[f]["a_position"];
	        m_tsr.transform_vectors(positions, transform, positions, 0);

	        var tbn = submesh.va_frames[f]["a_tbn"];
	        m_tbn.multiply_tsr(tbn, transform, tbn);

	        var shade_tangs = submesh.va_frames[f]["a_shade_tangs"];
	        if (shade_tangs && shade_tangs.length > 0)
	            m_tsr.transform_dir_vectors(shade_tangs, transform, shade_tangs, 0);
	    }

	    // transform au_center_pos too
	    // indices, influences, vertex colors, texcoords not affected
	    var au_center_pos = submesh.va_common["au_center_pos"];
	    if (au_center_pos && au_center_pos.length)
	        m_tsr.transform_vectors(au_center_pos, transform, au_center_pos, 0);

	    bounding_data_apply_transform(submesh.submesh_bd, transform);

	    return submesh;
	};

	/**
	 * Apply emitter transforms to particles
	 */
	exports.submesh_apply_particle_transform = function (submesh, transform) {
	    var au_center_pos = submesh.va_common["au_center_pos"];

	    if (au_center_pos && au_center_pos.length) {
	        var cen_pos_transformed = new Float32Array(au_center_pos);
	        m_tsr.transform_vectors(cen_pos_transformed, transform, cen_pos_transformed, 0);

	        for (var i = 0; i < submesh.va_frames.length; i++)
	            for (var j = 0; j < cen_pos_transformed.length; j++)
	                submesh.va_frames[i]["a_position"][j] += cen_pos_transformed[j]
	                        - au_center_pos[j];
	                
	        au_center_pos.set(cen_pos_transformed);
	    } else
	        m_util.panic("Attribute \"au_center_pos\" is missing in particle submesh");

	    bounding_data_apply_transform(submesh.submesh_bd, transform);

	    return submesh;
	};

	exports.bounding_data_apply_transform = bounding_data_apply_transform;
	function bounding_data_apply_transform(bd, tsr) {
	    bd.bb_local = m_bounds.bounding_box_transform(bd.bb_local, tsr);
	    bd.be_local = m_bounds.bounding_ellipsoid_transform(bd.be_local, tsr);
	    bd.bs_local = m_bounds.bounding_sphere_transform(bd.bs_local, tsr);
	    bd.bbr_local = m_bounds.bounding_rot_box_transform(bd.bbr_local, tsr);
	}

	/**
	 * Apply submesh params
	 */
	exports.submesh_apply_params = submesh_apply_params;
	function submesh_apply_params(submesh, params) {

	    var base_length = submesh.base_length;
	    // additional params
	    for (var param in params) {
	        var param_len = params[param].length;
	        submesh.va_common[param] = new Float32Array(param_len * base_length);

	        for (var i = 0; i < base_length; i++)
	            for (var j = 0; j < param_len; j++)
	                submesh.va_common[param][i*param_len + j] = params[param][j];
	    }

	    return submesh;
	}

	/**
	 * Generate new vertex array buffer from source by
	 * copyng source data length times
	 */
	exports.submesh_list_join = submesh_list_join;
	/**
	 * Join submeshes list
	 */
	function submesh_list_join(submeshes) {
	    var submesh0 = submeshes[0];
	    var new_submesh = submesh_list_join_prepare_dest(submeshes);

	    var new_submesh_bd = new_submesh.submesh_bd;

	    new_submesh_bd.bb_local = m_bounds.clone_bb(submesh0.submesh_bd.bb_local);

	    // indices
	    var i_offset = 0;
	    var v_ind_offset = 0;
	    var bounding_verts = [];
	    for (var i = 0; i < submeshes.length; i++) {
	        var submesh = submeshes[i];
	        var indices = submesh.indices;
	        var base_length = submesh.base_length;
	        var va_common = submesh.va_common;
	        var bb_local = submesh.submesh_bd.bb_local;
	        var bs_local = submesh.submesh_bd.bs_local;
	        m_bounds.expand_bounding_box(new_submesh_bd.bb_local, bb_local);
	        m_bounds.expand_bounding_sphere(new_submesh_bd.bs_local, bs_local);
	        m_bounds.extract_rot_bb_corners(submesh.submesh_bd.bbr_local, bounding_verts);
	        // indices
	        for (var j = 0; j < indices.length; j++) {
	            var ind = indices[j];
	            new_submesh.indices[i_offset + j] = ind + v_ind_offset;
	        }
	        i_offset += indices.length;

	        for (var param_name in va_common) {
	            var arr = va_common[param_name];

	            var offset = v_ind_offset * num_comp(arr, base_length);
	            new_submesh.va_common[param_name].set(arr, offset);
	        }

	        for (var j = 0; j < submesh.va_frames.length; j++) {

	            var va_frame = submesh.va_frames[j];
	            var new_va_frame = new_submesh.va_frames[j];

	            for (var param_name in va_frame) {

	                var arr = va_frame[param_name];

	                var offset = v_ind_offset * num_comp(arr, base_length);
	                new_va_frame[param_name].set(arr, offset);
	            }
	        }
	        v_ind_offset += base_length;

	    }
	    new_submesh_bd.be_local = m_bounds.create_be_by_bb(
	            m_util.f32(bounding_verts), true);

	    if (new_submesh.shape_keys.length > 0)
	        for (var i = 0; i < new_submesh.shape_keys.length; i++) {
	            var geometry = new_submesh.shape_keys[i].geometry;
	            var a_pos_offset = 0;
	            var a_tbn_offset = 0;

	            for (var j = 0; j < submeshes.length; j++) {
	                var cur_key_geom = submeshes[j].shape_keys[i].geometry;
	                geometry["a_position"].set(cur_key_geom["a_position"], a_pos_offset);
	                geometry["a_tbn"].set(cur_key_geom["a_tbn"], a_tbn_offset);
	                a_pos_offset += cur_key_geom["a_position"].length;
	                a_tbn_offset += cur_key_geom["a_tbn"].length;
	            }
	        }

	    if (submeshes[0].instanced_array_data)
	        new_submesh.instanced_array_data = {
	            tsr_array : submesh0.instanced_array_data.tsr_array,
	            stat_part_em_tsr : submesh0.instanced_array_data.stat_part_em_tsr,
	            static_hair : true,
	            submesh_params : submesh0.instanced_array_data.submesh_params,
	            part_inh_attrs : submesh0.instanced_array_data.part_inh_attrs,
	            dyn_grass : submesh0.instanced_array_data.dyn_grass
	        };
	    return new_submesh;
	}

	function submesh_list_join_prepare_dest(submeshes) {

	    var submesh0 = submeshes[0];

	    var new_submesh = init_submesh("JOIN_" + submeshes.length
	            + "_SUBMESHES");

	    var len = 0;
	    for (var i = 0; i < submeshes.length; i++)
	        len += submeshes[i].indices.length;
	    new_submesh.indices = new Uint32Array(len);

	    var pos_len = 0;
	    var tbn_len = 0;

	    if (submeshes[0].shape_keys.length > 0) {
	        for (var j = 0; j < submeshes[0].shape_keys.length; j++) {
	            for (var i = 0; i < submeshes.length; i++) {
	                pos_len += submeshes[i].shape_keys[j].geometry["a_position"].length;
	                tbn_len += m_tbn.get_items_count(submeshes[i].shape_keys[j].geometry["a_tbn"]);
	            }

	            var geometry = {
	                "a_position" : new Float32Array(pos_len),
	                "a_tbn" : m_tbn.create(tbn_len)
	            };

	            var key = {
	                init_value : submeshes[0].shape_keys[j].init_value,
	                geometry : geometry
	            };
	            new_submesh.shape_keys.push(key);
	        }
	    }

	    len = 0;
	    for (var i = 0; i < submeshes.length; i++)
	        len += submeshes[i].base_length;
	    new_submesh.base_length = len;

	    for (var param_name in submesh0.va_common) {

	        len = 0;
	        for (var i = 0; i < submeshes.length; i++)
	            len += submeshes[i].va_common[param_name].length;

	        new_submesh.va_common[param_name] = new Float32Array(len);
	    }

	    for (var param_name in submesh0.va_frames[0]) {

	        len = 0;
	        for (var i = 0; i < submeshes.length; i++)
	            len += submeshes[i].va_frames[0][param_name].length;

	        for (var i = 0; i < submesh0.va_frames.length; i++) {
	            new_submesh.va_frames[i] = new_submesh.va_frames[i] || {};
	            new_submesh.va_frames[i][param_name] = new Float32Array(len);
	        }
	    }
	    return new_submesh;
	}

	/**
	 * Extract and propagate submesh by given transforms.
	 * well-suited for hair particles
	 * ignore transform/center positions
	 */
	exports.make_propagated_submesh = function(src_submesh, params, transforms) {

	    // ignore empty submeshes
	    if (!src_submesh.base_length)
	        return init_submesh("EMPTY");

	    var count = transforms.length;
	    if (src_submesh.base_length * count > MAX_SUBMESH_LENGTH
	           && !m_ext.get_elem_index_uint())
	        submesh_drop_indices(src_submesh, count);

	    // for cloned submesh
	    var indices = src_submesh.indices;
	    var base_length = src_submesh.base_length;
	    var va_common = src_submesh.va_common;
	    var va_frames = src_submesh.va_frames;

	    // store additional params in extracted submesh
	    for (var param in params) {
	        var param_len = params[param].length;
	        var len = param_len * base_length;
	        va_common[param] = new Float32Array(len);

	        for (var i = 0; i < base_length; i++)
	            for (var j = 0; j < param_len; j++)
	                va_common[param][i*param_len + j] = params[param][j];
	    }

	    // create new submesh
	    var new_submesh = init_submesh("CLONE_"+count+"_SUBMESHES");
	    new_submesh.base_length = base_length * count;

	    new_submesh.indices = new Uint32Array(indices.length * count);

	    for (var i = 0; i < count; i++) {
	        var i_offset = indices.length * i;
	        var v_offset = base_length * i;

	        // indices
	        for (var j = 0; j < indices.length; j++) {
	            var ind = indices[j];
	            new_submesh.indices[i_offset + j] = ind + v_offset;
	        }
	    }

	    for (var param_name in va_common) {
	        var arr = va_common[param_name];
	        var len = arr.length * count;
	        var ncomp = num_comp(arr, base_length);

	        new_submesh.va_common[param_name] = new Float32Array(len);

	        for (var i = 0; i < count; i++) {
	            var v_offset = base_length * ncomp * i;
	            new_submesh.va_common[param_name].set(arr, v_offset);
	        }
	    }

	    for (var param_name in va_frames[0]) {
	        for (var i = 0; i < va_frames.length; i++) {
	            var arr = va_frames[i][param_name];
	            var len = arr.length * count;
	            var ncomp = num_comp(arr, base_length);

	            new_submesh.va_frames[i] = new_submesh.va_frames[i] || {};
	            new_submesh.va_frames[i][param_name] = new Float32Array(len);

	            for (var j = 0; j < count; j++) {
	                var transform = transforms[j];
	                var v_offset = base_length * ncomp * j;
	                switch(param_name) {
	                case "a_position":
	                    m_tsr.transform_vectors(arr, transform,
	                            new_submesh.va_frames[i][param_name], v_offset);
	                    break;
	                case "a_tbn":
	                    m_tsr.transform_quats(arr, transform,
	                            new_submesh.va_frames[i][param_name], v_offset);
	                    break;
	                case "a_shade_tangs":
	                    m_tsr.transform_tangents(arr, transform,
	                            new_submesh.va_frames[i][param_name], v_offset);
	                    break;
	                default:
	                    m_util.panic("Wrong attribute name: " + param_name);
	                    break;
	                }
	            }
	        }
	    }

	    calc_unit_boundings(src_submesh, new_submesh, transforms);

	    return new_submesh;
	};

	exports.calc_unit_boundings = calc_unit_boundings;
	function calc_unit_boundings(src_submesh, new_submesh, transforms) {
	    // NOTE: transforms should be in src_submesh's local space
	    var submesh_bd = new_submesh.submesh_bd;
	    var bb_tmp = m_bounds.create_bb();
	    var bbr_tmp = m_bounds.create_rot_bb();
	    var bounding_verts = [];
	    for (var i = 0; i < transforms.length; i++) {

	        m_bounds.bounding_box_transform(src_submesh.submesh_bd.bb_local,
	                transforms[i], bb_tmp);
	        m_bounds.expand_bounding_box(submesh_bd.bb_local, bb_tmp);

	        m_bounds.bounding_rot_box_transform(src_submesh.submesh_bd.bbr_local,
	                transforms[i], bbr_tmp);
	        m_bounds.extract_rot_bb_corners(bbr_tmp, bounding_verts);
	    }
	    submesh_bd.be_local = m_bounds.create_be_by_bb(m_util.f32(bounding_verts),
	                                                   true);
	    submesh_bd.bbr_local = m_bounds.create_bbr_by_be(submesh_bd.be_local);
	    submesh_bd.bs_local = m_bounds.create_bs_by_be(submesh_bd.be_local);
	}


	exports.extract_submesh = extract_submesh;
	/**
	 * Extract submesh from mesh with given material index
	 * @methodOf geometry
	 */
	function extract_submesh(mesh, material_index, attr_names, bone_skinning_info,
	        vertex_colors_usage, uv_maps_usage) {

	    // TODO: implement caching
	    // TODO: handle cases when submesh can't provide requested attribute name

	    var bsub = mesh["submeshes"][material_index];
	    var base_length = bsub["base_length"];
	    var mat = mesh["materials"][material_index];

	    var submesh = init_submesh("SUBMESH_" + mesh["name"] + "_" + mat.name);

	    submesh.base_length = base_length;

	    var use_shape_keys = false;
	    // TEXTURE COORDS
	    if (has_attr(attr_names, "a_texcoord"))
	        var texcoords = extract_texcoords(mesh, material_index);
	    else
	        var texcoords = new Float32Array(0);

	    if (has_attr(attr_names, "a_orco_tex_coord"))
	        var local_coord = extract_orco_texcoords_nodes(mesh, bsub);
	    else
	        var local_coord = new Float32Array(0);

	    // INFLUENCES (SKINNING)
	    var influences = extract_influences(attr_names, base_length, bone_skinning_info,
	            bsub["group"]);


	    // VERTEX COLORS

	    if (vertex_colors_usage)
	        var submesh_vc_usage = m_util.clone_object_r(vertex_colors_usage);
	    else
	        var submesh_vc_usage = {};
	    submesh_vc_usage["a_color"] = { generate_buffer: true };

	    if (has_attr(attr_names, "a_color") && mesh["active_vcol_name"])
	        submesh_vc_usage["a_color"].src = [
	            { name: mesh["active_vcol_name"], mask: 7 }
	        ];
	    else
	        submesh_vc_usage["a_color"].src = [];

	    submesh.va_common["a_texcoord"] = texcoords;
	    submesh.va_common["a_influence"] = influences;
	    submesh.va_common["a_orco_tex_coord"] = local_coord;

	    extract_vcols(submesh.va_common, submesh_vc_usage, bsub["vertex_colors"],
	            bsub["color"], base_length, mesh["name"]);

	    assign_node_uv_maps(bsub, mesh["name"], uv_maps_usage, submesh.va_common);

	    submesh.indices = new Uint32Array(bsub["indices"]);

	    // POSITION
	    var frames = bsub["position"].length / base_length / POS_NUM_COMP;

	    // position always needed?

	    if (has_attr(attr_names, "a_tbn") && bsub["tbn"].length)
	        var use_tbn = true;
	    else
	        var use_tbn = false;

	    if (has_attr(attr_names, "a_shade_tangs") && bsub["shade_tangs"].length)
	        var use_tangent_shading = true;
	    else
	        var use_tangent_shading = false;

	    if (mesh["b4w_shape_keys"].length > 0)
	        use_shape_keys = true;

	    for (var i = 0; i < frames; i++) {
	        var va_frame = create_frame(bsub, base_length, use_tbn,
	                use_tangent_shading, i);

	        if (use_shape_keys) {
	            var sk_frame = {};
	            sk_frame.name = mesh["b4w_shape_keys"][i]["name"];
	            submesh.shape_keys.push(sk_frame);
	            if (i != 0) {
	                sk_frame.geometry = va_frame;
	                sk_frame.init_value = mesh["b4w_shape_keys"][i]["value"];
	                continue;
	            } else {
	                // NOTE: create new object for base shape key geometry
	                sk_frame.geometry = create_frame(bsub, base_length, 
	                        use_tbn, use_tangent_shading, i);
	                sk_frame.init_value = 1;
	            }
	        }
	        submesh.va_frames.push(va_frame);
	    }

	    // store first frame copy for possible cyclic vertex anim
	    if (frames > 1 && !use_shape_keys) {
	        var va_frame0 = submesh.va_frames[0];
	        var va_frame = {};

	        for (var prop in va_frame0)
	            va_frame[prop] = new Float32Array(va_frame0[prop]);

	        submesh.va_frames.push(va_frame);
	    }

	    if (has_attr(attr_names, "a_polyindex")) {
	        submesh_drop_indices(submesh, 1, true);
	        submesh.va_common["a_polyindex"] = extract_polyindices(submesh);
	    }

	    // extract submesh bounding data
	    submesh_bd_to_b4w(bsub["boundings"], submesh.submesh_bd);

	    return submesh;
	}

	function submesh_bd_to_b4w(submesh_bd, bd) {

	    bd.bb_local = m_bounds.create_bb();
	    bd.bb_local.max_x = submesh_bd["bb"]["max_x"];
	    bd.bb_local.max_y = submesh_bd["bb"]["max_y"];
	    bd.bb_local.max_z = submesh_bd["bb"]["max_z"];
	    bd.bb_local.min_x = submesh_bd["bb"]["min_x"];
	    bd.bb_local.min_y = submesh_bd["bb"]["min_y"];
	    bd.bb_local.min_z = submesh_bd["bb"]["min_z"];

	    var bbr_data = submesh_bd["rbb"];
	    var cov_axis_x = submesh_bd["caxis_x"];
	    var cov_axis_y = submesh_bd["caxis_y"];
	    var cov_axis_z = submesh_bd["caxis_z"];

	    var be_axes_len = submesh_bd["be_ax"];
	    bd.be_local = m_bounds.be_from_values(
	        cov_axis_x, cov_axis_y, cov_axis_z,
	        submesh_bd["be_cen"]);
	    m_vec3.scale(bd.be_local.axis_x, be_axes_len[0], bd.be_local.axis_x);
	    m_vec3.scale(bd.be_local.axis_y, be_axes_len[1], bd.be_local.axis_y);
	    m_vec3.scale(bd.be_local.axis_z, be_axes_len[2], bd.be_local.axis_z);

	    bd.bs_local = m_bounds.create_bs_by_be(bd.be_local);

	    m_vec3.copy(bbr_data["rbb_c"], bd.bbr_local.center);
	    m_vec3.copy(cov_axis_x, bd.bbr_local.axis_x);
	    m_vec3.copy(cov_axis_y, bd.bbr_local.axis_y);
	    m_vec3.copy(cov_axis_z, bd.bbr_local.axis_z);

	    var rbb_scales = bbr_data["rbb_s"];
	    m_vec3.scale(bd.bbr_local.axis_x, rbb_scales[0], bd.bbr_local.axis_x);
	    m_vec3.scale(bd.bbr_local.axis_y, rbb_scales[1], bd.bbr_local.axis_y);
	    m_vec3.scale(bd.bbr_local.axis_z, rbb_scales[2], bd.bbr_local.axis_z);
	}

	function create_frame(bsub, base_length, use_tbn, use_tangent_shading,
	        frame_index) {

	    var va_frame = {};

	    var pos_arr = new Float32Array(base_length * POS_NUM_COMP);
	    var tbn_arr = m_tbn.create(use_tbn ? base_length: 0);

	    var from_index = frame_index * base_length * POS_NUM_COMP;
	    var to_index = from_index + base_length * POS_NUM_COMP;
	    pos_arr.set(bsub["position"].subarray(from_index, to_index), 0);

	    if (use_tbn) {
	        from_index = frame_index * base_length;
	        m_tbn.copy(bsub["tbn"], from_index, base_length, tbn_arr);
	    }

	    if (use_tangent_shading) {
	        var shading_tan_arr = new Float32Array(base_length * SHD_TAN_NUM_COMP);
	        to_index = base_length * SHD_TAN_NUM_COMP;
	        shading_tan_arr.set(bsub["shade_tangs"].subarray(0, to_index), 0);
	        va_frame["a_shade_tangs"] = shading_tan_arr;
	    }

	    va_frame["a_position"] = pos_arr;
	    va_frame["a_tbn"] = tbn_arr;

	    return va_frame;
	}

	function extract_texcoords(mesh, material_index) {

	    var texcoords = null;
	    var material = mesh["materials"][material_index];
	    var submesh = mesh["submeshes"][material_index];

	    if (material.texture_slots.length) {
	        var slot = material.texture_slots[0];

	        switch (slot["texture_coords"]) {
	        case "UV":
	            texcoords = extract_uv_layer(submesh, slot["uv_layer"] 
	                    || mesh["active_uv_name"], mesh["name"]);
	            break;
	        case "ORCO":
	            texcoords = generate_orco_texcoords(mesh["b4w_boundings"]["bb_src"],
	                    submesh);
	            break;
	        }
	    }

	    if (texcoords === null)
	        texcoords = new Float32Array(submesh["base_length"] * TCO_NUM_COMP);

	    return texcoords;
	}

	function extract_uv_layer(submesh, uv_name, mesh_name) {
	    var layer_len = submesh["base_length"] * TCO_NUM_COMP;

	    var index = submesh["uv_layers"].indexOf(uv_name);

	    if (index == -1) {
	        m_print.warn("uv layer \"" + uv_name
	                + "\" for mesh \"" + mesh_name + "\" not found");
	        return new Float32Array(layer_len);
	    }

	    var from = index * layer_len;
	    var to = from + layer_len;
	 
	    return submesh["texcoord"].subarray(from, to);
	}

	// NOTE: this function is used when node outputs "Orco" & "Generated" are used
	function extract_orco_texcoords_nodes(mesh, submesh) {
	    var bb = mesh["b4w_boundings"]["bb_src"];
	    var local_coords = new Float32Array(submesh["base_length"] * 3);
	    var pos = submesh["position"];

	    var size_x = bb["max_x"] - bb["min_x"];
	    var size_y = bb["max_y"] - bb["min_y"];
	    var size_z = bb["max_z"] - bb["min_z"];

	    var localco_index = 0;
	    for (var i = 0; i < pos.length; i+=3) {
	        // -1 values will be updated in fragment shader
	        if (size_x == 0)
	            local_coords[localco_index++] = 0.5;
	        else
	            local_coords[localco_index++] = m_util.clamp(
	                    parseFloat(((pos[i] - bb.min_x) / size_x).toFixed(5)), 0, 1);
	        if (size_y == 0)
	            local_coords[localco_index++] = 0.5;
	        else
	            local_coords[localco_index++] = m_util.clamp(
	                    parseFloat(((pos[i + 1] - bb.min_y) / size_y).toFixed(5)), 0, 1);
	        if (size_z == 0)
	            local_coords[localco_index++] = 0.5;
	        else
	            local_coords[localco_index++] = m_util.clamp(
	                    parseFloat(((pos[i + 2] - bb.min_z) / size_z).toFixed(5)), 0, 1);
	    }

	    return local_coords;
	}

	function generate_orco_texcoords(bb, submesh) {
	    var texcoords = new Float32Array(submesh["base_length"] * TCO_NUM_COMP);

	    var center_x = (bb["max_x"] + bb["min_x"]) / 2;
	    var center_y = (bb["max_y"] + bb["min_y"]) / 2;
	    var size_x = bb["max_x"] - bb["min_x"];
	    var size_y = bb["max_y"] - bb["min_y"];

	    var texco_index = 0;
	    for (var i = 0; i < submesh["position"].length; i+=3) {
	        texcoords[texco_index++] = (submesh["position"][i] - center_x) / size_x + 0.5;
	        texcoords[texco_index++] = (submesh["position"][i + 1] - center_y) / size_y + 0.5;
	    }

	    return texcoords;
	}

	function extract_vcols(va_common, vc_usage, submesh_vc, bsub_color, base_length, mesh_name) {

	    var submesh_vc_names = submesh_vc_get_names(submesh_vc);
	    for (var attr_name in vc_usage) {

	        var colors_data = vc_usage[attr_name].src;
	        if (colors_data.length) {
	            var dst_channels_count = 0;
	            for (var i = 0; i < colors_data.length; i++)
	                dst_channels_count += m_util.rgb_mask_get_channels_count(colors_data[i].mask);

	            va_common[attr_name] = new Float32Array(dst_channels_count * base_length);

	            var dst_channel_index_offset = 0;
	            for (var i = 0; i < colors_data.length; i++) {
	                var color_name = colors_data[i].name;
	                var color_mask = colors_data[i].mask;
	                var channels_presence = m_util.rgb_mask_get_channels_presence(color_mask);
	                var color_name_index = submesh_vc_names.indexOf(color_name);

	                if (color_name_index == -1) {
	                    m_print.warn("vertex color \"" + color_name
	                            + "\" for mesh \"" + mesh_name+ "\" not found");
	                    var mask_exported = 7;
	                } else {
	                    var mask_exported = submesh_vc[color_name_index]["mask"];
	                    var exported_colors_offset = submesh_vc_get_offset(submesh_vc,
	                        color_name_index, base_length);
	                }

	                var exported_channels_count = m_util.rgb_mask_get_channels_count(mask_exported);
	                if ((color_mask & mask_exported) !== color_mask)
	                    m_print.error("Wrong color extraction from "
	                        + color_name + " to " + attr_name + " for the mesh \"" 
	                        + mesh_name +"\".");

	                for (var j = 0; j < base_length; j++)
	                    for (var k = 0; k < COL_NUM_COMP; k++)
	                        if (channels_presence[k]) {
	                            var dst_channel_index = dst_channel_index_offset
	                                    + m_util.rgb_mask_get_channel_presence_index(color_mask,
	                                    k);
	                            var exported_channel_index =
	                                    m_util.rgb_mask_get_channel_presence_index(mask_exported,
	                                    k);

	                            if (color_name_index == -1)
	                                va_common[attr_name][j * dst_channels_count
	                                        + dst_channel_index] = 0;
	                            else
	                                va_common[attr_name][j * dst_channels_count
	                                        + dst_channel_index]
	                                        = bsub_color[exported_colors_offset
	                                        + j * exported_channels_count
	                                        + exported_channel_index];
	                        }
	                dst_channel_index_offset += exported_channels_count;
	            }
	        } else
	            va_common[attr_name] = new Float32Array(0);
	    }
	}

	function submesh_vc_get_names(submesh_vc) {
	    var submesh_vc_names = [];
	    for (var i = 0; i < submesh_vc.length; i++)
	        submesh_vc_names.push(submesh_vc[i]["name"]);

	    return submesh_vc_names;
	}

	function submesh_vc_get_offset(submesh_vc, vc_index, base_length) {
	    var offset = 0;
	    for (var i = 0; i < vc_index; i++)
	        offset += m_util.rgb_mask_get_channels_count(submesh_vc[i]["mask"]);
	    return offset * base_length;
	}

	function assign_node_uv_maps(bsub, mesh_name, uv_maps_usage, va_common) {
	    if (!uv_maps_usage)
	        return;

	    for (var uv_name in uv_maps_usage)
	        va_common[uv_maps_usage[uv_name]] = extract_uv_layer(bsub, uv_name, mesh_name);
	}

	/**
	 * Extract halo submesh
	 */
	exports.extract_halo_submesh = function(submesh) {

	    var base_length = submesh.base_length;
	    var position_in = submesh.va_frames[0]["a_position"];

	    var pos_arr      = new Float32Array(12 * base_length);
	    var indices_out  = new Uint32Array (4 * submesh.indices.length);
	    var random_vals = new Float32Array (4 * base_length);

	    for (var i = 0; i < base_length; i++) {
	        // generate positions
	        pos_arr[12 * i]      =  position_in[3 * i];
	        pos_arr[12 * i + 1]  =  position_in[3 * i + 1];
	        pos_arr[12 * i + 2]  =  position_in[3 * i + 2];

	        pos_arr[12 * i + 3]  =  position_in[3 * i];
	        pos_arr[12 * i + 4]  =  position_in[3 * i + 1];
	        pos_arr[12 * i + 5]  =  position_in[3 * i + 2];

	        pos_arr[12 * i + 6]  =  position_in[3 * i];
	        pos_arr[12 * i + 7]  =  position_in[3 * i + 1];
	        pos_arr[12 * i + 8]  =  position_in[3 * i + 2];

	        pos_arr[12 * i + 9]  =  position_in[3 * i];
	        pos_arr[12 * i + 10] =  position_in[3 * i + 1];
	        pos_arr[12 * i + 11] =  position_in[3 * i + 2];

	        // generate indices
	        indices_out[6 * i]       =  4 * i + 2;
	        indices_out[6 * i + 1]   =  4 * i + 1;
	        indices_out[6 * i + 2]   =  4 * i;
	        indices_out[6 * i + 3]   =  4 * i + 2;
	        indices_out[6 * i + 4]   =  4 * i;
	        indices_out[6 * i + 5]   =  4 * i + 3;

	        var random_val = Math.random();
	        random_vals[4 * i] = random_val;
	        random_vals[4 * i + 1] = random_val;
	        random_vals[4 * i + 2] = random_val;
	        random_vals[4 * i + 3] = random_val;
	    }

	    var halo_submesh = init_submesh("HALO");
	    halo_submesh.va_frames[0] = {};

	    halo_submesh.base_length = 4 * base_length;
	    halo_submesh.va_frames[0]["a_position"]    = pos_arr;
	    halo_submesh.va_common["a_halo_bb_vertex"] = gen_bb_vertices(base_length);
	    halo_submesh.va_common["a_random_vals"] = random_vals;
	    halo_submesh.indices                       = indices_out;
	    return halo_submesh;
	};

	/**
	 * Convenience method for attribute name check
	 */
	exports.has_attr = has_attr;
	function has_attr(attr_names, name) {
	    if (attr_names.indexOf(name) > -1)
	        return true;
	    else
	        return false;
	}

	/**
	 * Extract all materials.
	 * common_vc_usage - vertex colors which exist for every submesh
	 */
	exports.extract_submesh_all_mats = function(mesh, attr_names, common_vc_usage) {

	    var submeshes = [];

	    for (var i = 0; i < mesh["submeshes"].length; i++) {
	        var submesh = extract_submesh(mesh, i, attr_names, null, common_vc_usage, null);
	        if (submesh.base_length)
	            submeshes.push(submesh);
	    }

	    if (submeshes.length == 0)
	        var submesh_all = init_submesh("EMPTY");
	    else if (submeshes.length == 1)
	        var submesh_all = submeshes[0];
	    else
	        var submesh_all = submesh_list_join(submeshes);

	    return submesh_all;
	};

	function extract_influences(attr_names, base_length, bone_skinning_info,
	        groups) {

	    if (has_attr(attr_names, "a_influence") && bone_skinning_info) {
	        var influences = new Float32Array(base_length * INFLUENCE_NUM_COMP);
	        var groups_num = groups.length/base_length;
	        // bones corresponding to vertex group
	        var deform_bone_indices = get_deform_bone_indices(bone_skinning_info, groups_num);

	        // NOTE: create buffers outside vertices cycle
	        var buf_length = groups_num > 3 ? groups_num: 4;
	        var weights_buf = new Float32Array(buf_length);
	        var bones_buf = new Uint32Array(buf_length);
	        var res_buf = new Float32Array(INFLUENCE_NUM_COMP);

	        var zero_weights = new Float32Array(buf_length);
	        var zero_bones = new Uint32Array(buf_length);
	        var zero_res = new Float32Array(INFLUENCE_NUM_COMP);

	        for (var i = 0; i < base_length; i++) {
	            weights_buf.set(zero_weights);
	            bones_buf.set(zero_bones);
	            res_buf.set(zero_res);
	            influences.set(get_vertex_influences(groups, groups_num, i, base_length,
	                    deform_bone_indices, weights_buf, bones_buf, res_buf),
	                    i * INFLUENCE_NUM_COMP);
	        }
	    } else
	        var influences = new Float32Array(0);

	    return influences;
	}

	function get_deform_bone_indices(bone_skinning_info, groups_num) {
	    var deform_bone_indices = new Float32Array(groups_num);

	    for (var i = 0; i < groups_num; i++) {
	        deform_bone_indices[i] = -1;
	        for (var j in bone_skinning_info) {
	            var bone_sk_info = bone_skinning_info[j];
	            if (bone_sk_info.vgroup_index === i) {
	                deform_bone_indices[i] = bone_sk_info.deform_bone_index;
	                break;
	            }
	        }
	    }

	    return deform_bone_indices;
	}

	function get_vertex_influences(vertex_groups, groups_num, vert_index, base_length,
	        deform_bone_indices, weights_buf, bones_buf, res_buf) {

	    var precision = 0.01;
	    var no_weights = true;

	    for (var i = 0; i < groups_num; i++) {
	        var weight = vertex_groups[i * base_length + vert_index];

	        if (weight !== -1) {
	            var bone_index = deform_bone_indices[i];
	            // vertex can be assigned to non-bone group
	            if (bone_index !== -1) {
	                weights_buf[i] = weight;
	                bones_buf[i] = bone_index;
	                no_weights = false;
	            }
	        }
	    }

	    if (no_weights)
	        return res_buf;

	    // sort in descending order by weights
	    sort_two_arrays(weights_buf, bones_buf, exports.SORT_NUMERIC, false);

	    // normalize weights (in case they were not normalized by author)
	    var sum_weights = 0;
	    for (var i = 0; i < INFLUENCE_NUM_COMP; i++)
	        sum_weights += weights_buf[i];
	    if (sum_weights < precision)
	        return res_buf;
	    for (var i = 0; i < INFLUENCE_NUM_COMP; i++)
	        weights_buf[i] /= sum_weights;

	    // pack to one vector; use a group index in integer part and
	    // a bone weight in fractional part of a number
	    if (Math.abs(weights_buf[0] - 1.0) < precision)
	        // single group case
	        res_buf[0] = bones_buf[0] + 1.0;
	    else
	        // multi group case
	        for (var i = 0; i < INFLUENCE_NUM_COMP; i++)
	            res_buf[i] = bones_buf[i] + weights_buf[i];

	    return res_buf;
	}

	/**
	 * This function works only for non-animated arrays
	 */
	function num_comp(array, base_length) {

	    if (base_length == 0)
	        return 0;
	    var array_length = array.length;

	    var factor = array_length / base_length;

	    if (factor != Math.floor(factor))
	        m_util.panic("Array size mismatch during geometry calculation: array length=" +
	            array_length + ", base length=" + base_length);

	    return factor;
	}


	/**
	 * Sort triangles and update index buffers when camera moves.
	 */
	exports.update_buffers_movable = function(bufs_data, z_sort_info, world_tsr, eye) {

	    // retrieve data required for update
	    var indices = bufs_data.ibo_array;
	    var positions = extract_array_float(bufs_data, "a_position");

	    var median_cache = z_sort_info.median_cache;
	    var median_world_cache = z_sort_info.median_world_cache;
	    var dist_cache = z_sort_info.dist_cache;

	    // get positions to world space and calc medians
	    // note: skinning ignored
	    compute_triangle_medians(indices, positions, median_cache);
	    m_tsr.transform_vectors(median_cache, world_tsr, median_world_cache);

	    compute_triangle_dists(median_world_cache, eye, dist_cache);
	    indices = sort_triangles(dist_cache, indices);

	    // bind and update IBO
	    _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, bufs_data.ibo);
	    _gl.bufferData(_gl.ELEMENT_ARRAY_BUFFER, indices, _gl.DYNAMIC_DRAW);
	};

	/**
	 * Store medians to preallocated Float32Array
	 */
	function compute_triangle_medians(indices, positions, medians) {

	    var num_faces = indices.length / 3;

	    for (var i = 0; i < num_faces; i++) {
	        var index0 = indices[3 * i];
	        var index1 = indices[3 * i + 1];
	        var index2 = indices[3 * i + 2];

	        // vertex coordinate
	        var pos00 = positions[3 * index0];
	        var pos01 = positions[3 * index0 + 1];
	        var pos02 = positions[3 * index0 + 2];

	        var pos10 = positions[3 * index1];
	        var pos11 = positions[3 * index1 + 1];
	        var pos12 = positions[3 * index1 + 2];

	        var pos20 = positions[3 * index2];
	        var pos21 = positions[3 * index2 + 1];
	        var pos22 = positions[3 * index2 + 2];

	        medians[3*i] = (pos00 + pos10 + pos20) / 3;
	        medians[3*i + 1] = (pos01 + pos11 + pos21) / 3;
	        medians[3*i + 2] = (pos02 + pos12 + pos22) / 3;
	    }

	    return medians;
	}

	/**
	 * Store square dists to preallocated Float32Array
	 */
	function compute_triangle_dists(medians, eye, dists) {

	    var len = medians.length/3;

	    for (var i = 0; i < len; i++) {

	        var dx = medians[3*i] - eye[0];
	        var dy = medians[3*i + 1] - eye[1];
	        var dz = medians[3*i + 2] - eye[2];

	        dists[i] = dx*dx + dy*dy + dz*dz;
	    }

	    return dists;
	}

	/**
	 * Using comb sort
	 * currently supported BACK_TO_FRONT sort (discending order)
	 */
	function sort_triangles(dists, indices) {

	    var dlen = dists.length;

	    if (dlen < 2)
	        return indices;

	    var gap = dlen;
	    var swapped = false;
	    var t;

	    while ((gap > 1) || swapped) {
	        if (gap > 1) {
	            gap = Math.floor(gap / COMB_SORT_JUMP_COEFF);
	        }

	        swapped = false;

	        for (var i = 0; gap + i < dlen; i++) {
	            if (dists[i] - dists[i + gap] < 0) {

	                t = dists[i];
	                dists[i] = dists[i+gap];
	                dists[i+gap] = t;

	                swap_indices(indices, i, i+gap);
	                swapped = true;
	            }
	        }
	    }

	    return indices;
	}

	exports.sort_two_arrays = sort_two_arrays;
	function sort_two_arrays(main_arr, extra_arr, type, ascending) {
	    var arr_length = main_arr.length;
	    var gap = arr_length;
	    var swapped = false;
	    var tmp;

	    var order_factor = ascending ? -1 : 1;

	    while (gap > 1 || swapped) {
	        if (gap > 1)
	            gap = Math.floor(gap / COMB_SORT_JUMP_COEFF);

	        swapped = false;

	        for (var i = 0; gap + i < arr_length; i++) {
	            if (type == exports.SORT_NUMERIC)
	                var condition = order_factor * (main_arr[i] - main_arr[i + gap]) < 0;
	            else
	                var condition = main_arr[i] < main_arr[i + gap] && ascending;
	            if (condition) {

	                tmp = main_arr[i];
	                main_arr[i] = main_arr[i + gap];
	                main_arr[i + gap] = tmp;

	                tmp = extra_arr[i];
	                extra_arr[i] = extra_arr[i + gap];
	                extra_arr[i + gap] = tmp;

	                swapped = true;
	            }
	        }
	    }

	}

	/**
	 * pos1 <->  pos2
	 */
	function swap_indices(indices, pos1, pos2) {

	    var t0 = indices[3*pos1];
	    var t1 = indices[3*pos1 + 1];
	    var t2 = indices[3*pos1 + 2];

	    indices[3*pos1] = indices[3*pos2];
	    indices[3*pos1 + 1] = indices[3*pos2 + 1];
	    indices[3*pos1 + 2] = indices[3*pos2 + 2];

	    indices[3*pos2] = t0;
	    indices[3*pos2 + 1] = t1;
	    indices[3*pos2 + 2] = t2;
	}


	/**
	 * Perform normals calculation
	 *
	 * shared indices required in case of normals smoothing
	 * @methodOf geometry
	 */
	exports.calc_normals = function(indices, positions, shared_indices) {

	    // TODO: rewrite to match new submesh architecture (drop explicit binormals)
	    var num_vertices = positions.length / POS_NUM_COMP;
	    var num_faces = indices.length / 3; // FACE === TRIANGLE

	    // init storage (destination)
	    var normals = [];

	    var pos0 = new Array(3);
	    var pos1 = new Array(3);
	    var pos2 = new Array(3);

	    // for each face perform normals calculation
	    for (var i = 0; i < num_faces; i++) {
	        var index0 = indices[3 * i];
	        var index1 = indices[3 * i + 1];
	        var index2 = indices[3 * i + 2];

	        for (var j = 0; j < POS_NUM_COMP; j++) {
	            pos0[j] = positions[POS_NUM_COMP * index0 + j];
	            pos1[j] = positions[POS_NUM_COMP * index1 + j];
	            pos2[j] = positions[POS_NUM_COMP * index2 + j];
	        }

	        if (shared_indices) {
	            // calculate angles to use as weights for averaging
	            var angle0 = angle(pos0, pos1, pos2);
	            var angle1 = angle(pos1, pos2, pos0);
	            var angle2 = Math.PI - angle0 - angle1;
	        } else {
	            var angle0 = 1;
	            var angle1 = 1;
	            var angle2 = 1;
	        }

	        calc_normal_for_face(index0, index1, index2, pos0, pos1, pos2,
	                angle0, angle1, angle2, normals);
	    }

	    // perform normals smoothing
	    if (shared_indices)
	        smooth_normals(shared_indices, normals);

	    // normalize normals
	    for (var i = 0; i < num_vertices; i++)
	        normalize_normal(i, normals);

	    return normals;
	};

	function angle(pos, pos1, pos2) {
	    var vec1 = [];
	    var vec2 = [];
	    m_vec3.subtract(pos1, pos, vec1);
	    m_vec3.subtract(pos2, pos, vec2);

	    m_vec3.normalize(vec1, vec1);
	    m_vec3.normalize(vec2, vec2);

	    var dot = m_util.clamp(m_vec3.dot(vec1, vec2), -1, 1);
	    return Math.acos(dot);
	}

	function calc_normal_for_face(index0, index1, index2, pos0, pos1, pos2,
	        angle0, angle1, angle2, dest) {

	    // calculate a face normal (same for all 3 vertices in a triangle)
	    var normal = calc_normal_by_pos(pos0, pos1, pos2);

	    // sum normals for vertices with the same coords
	    for (var i = 0; i < NOR_NUM_COMP; i++) {
	        var i0 = NOR_NUM_COMP * index0 + i;
	        var i1 = NOR_NUM_COMP * index1 + i;
	        var i2 = NOR_NUM_COMP * index2 + i;

	        dest[i0] = angle0 * normal[i];
	        dest[i1] = angle1 * normal[i];
	        dest[i2] = angle2 * normal[i];
	    }
	}

	function calc_normal_by_pos(pos0, pos1, pos2) {

	    var vec1 = [], vec2 = [], normal = [];

	    m_vec3.subtract(pos1, pos0, vec1);
	    m_vec3.subtract(pos2, pos0, vec2);
	    m_vec3.cross(vec1, vec2, normal);
	    m_vec3.normalize(normal, normal); // required

	    return normal;
	}

	function smooth_normals(shared_indices, normals) {

	    for (var i in shared_indices) {
	        var indices = shared_indices[i];

	        for (var j = 0; j < NOR_NUM_COMP; j++) {
	            var offset0 = NOR_NUM_COMP * indices[0] + j;
	            // smooth
	            for (var k = 1; k < indices.length; k++) {
	                var offset = NOR_NUM_COMP * indices[k] + j;
	                normals[offset0] += normals[offset];
	            }
	            // copy
	            for (var k = 1; k < indices.length; k++) {
	                var offset = NOR_NUM_COMP * indices[k] + j;
	                normals[offset] = normals[offset0];
	            }
	        }
	    }
	}

	function normalize_normal(i, normals) {
	    var normal = new Float32Array(NOR_NUM_COMP);

	    for (var j = 0; j < NOR_NUM_COMP; j++) {
	        var index = NOR_NUM_COMP * i + j;
	        normal[j] = normals[index];
	    }
	    m_vec3.normalize(normal, normal);
	    for (var j = 0; j < NOR_NUM_COMP; j++) {
	        var index = NOR_NUM_COMP * i + j;
	        normals[index] = normal[j];
	    }
	}

	exports.calc_shared_indices = calc_shared_indices;
	/**
	 * Calculate shared indices - indices of vertices having same locations
	 * @methodOf geometry
	 */
	function calc_shared_indices(indices, shared_locations, locations) {

	    var sh_loc_set = {};
	    var loc_len = shared_locations.length / 3;
	    for (var i = 0; i < loc_len; i++) {
	        var key =
	                String(shared_locations[3*i]) +
	                String(shared_locations[3*i + 1]) +
	                String(shared_locations[3*i + 2]);
	        sh_loc_set[key] = [];
	    }

	    var ind_len = indices.length;
	    for (var i = 0; i < ind_len; i++) {
	        var index = indices[i];
	        var key =
	                String(locations[3 * index]) +
	                String(locations[3 * index + 1]) +
	                String(locations[3 * index + 2]);

	        if (key in sh_loc_set)
	            sh_loc_set[key].push(index);
	    }
	    return sh_loc_set;
	}

	/**
	 * Return n points uniformly distributed on geometry
	 * point is Array of Float32Arrays of coords
	 */
	exports.geometry_random_points = function(submesh, n, process_tbn, seed) {

	    var triangles = extract_triangles_position(submesh, null);
	    if (process_tbn)
	        var triangles_tbn = extract_triangles_tbn(submesh, null);

	    var tnum = triangles.length;
	    var areas = new Float32Array(tnum);

	    var A = _vec3_tmp;
	    var B = _vec3_tmp2;
	    var C = _vec3_tmp3;

	    for (var i = 0; i < tnum; i++) {
	        var tri = triangles[i];

	        A.set(tri.subarray(0, 3));
	        B.set(tri.subarray(3, 6));
	        C.set(tri.subarray(6));

	        areas[i] = triangle_area(A, B, C);
	    }

	    var cumulative_areas = new Float32Array(tnum);

	    cumulative_areas[0] = areas[0];

	    for (var i = 1; i < tnum; i++)
	        cumulative_areas[i] = cumulative_areas[i-1] + areas[i];

	    var geom_area = cumulative_areas[areas.length - 1];

	    var points = [];

	    // distribute points
	    for (var i = 0; i < n; i++) {
	        var area = geom_area * m_util.rand_r(seed);

	        var tri_index = m_util.binary_search_max(cumulative_areas, area, 0,
	                cumulative_areas.length - 1);

	        if (process_tbn)
	            var tri = triangles_tbn[tri_index];
	        else
	            var tri = triangles[tri_index];

	        var ps = triangle_random_point(tri, seed, _vec3_tmp);

	        if (process_tbn) {
	            points[i] = new Float32Array(4);
	            m_vec3.normalize(ps, ps);
	            var quat = m_quat.rotationTo(m_util.AXIS_Y, ps, _quat_tmp);
	            points[i][0] = quat[0];
	            points[i][1] = quat[1];
	            points[i][2] = quat[2];
	            points[i][3] = quat[3];
	        } else {
	            points[i] = new Float32Array(3);
	            points[i][0] = ps[0];
	            points[i][1] = ps[1];
	            points[i][2] = ps[2];
	        }
	    }

	    return points;
	};

	/**
	 * <p>Return Array of triangles.
	 * <p>triangle is a Float32Array of 9 cooords
	 * <p>NOTE: Uses only first frame for vertex-animated meshes
	 * @methodOf geometry
	 */
	function extract_triangles_position(submesh, dest) {

	    if (!dest)
	        dest = [];

	    var positions = submesh.va_frames[0]["a_position"];

	    return ext_triangles(positions, submesh, dest);
	}

	function extract_triangles_tbn(submesh, dest) {

	    if (!dest)
	        dest = [];

	    var tbn = submesh.va_frames[0]["a_tbn"];

	    var count = m_tbn.get_items_count(tbn);
	    var positions = new Float32Array(3 * count);
	    for (var i = 0; i < count; i++) {
	        var quat = m_tbn.get_quat(tbn, i, _quat_tmp);
	        var norm = m_vec3.transformQuat(m_util.AXIS_Y, quat, _vec3_tmp);
	        positions[3*i] = norm[0];
	        positions[3*i + 1] = norm[1];
	        positions[3*i + 2] = norm[2];
	    }

	    return ext_triangles(positions, submesh, dest);
	}

	function ext_triangles(positions, submesh, dest) {
	    if (is_indexed(submesh)) {
	        var indices = submesh.indices;

	        var tnum = indices.length / 3;
	        for (var i = 0; i < tnum; i++) {
	            var tri = new Float32Array(9);

	            var i0 = indices[3*i];
	            tri[0] = positions[3*i0];
	            tri[1] = positions[3*i0 + 1];
	            tri[2] = positions[3*i0 + 2];

	            var i1 = indices[3*i + 1];
	            tri[3] = positions[3*i1];
	            tri[4] = positions[3*i1 + 1];
	            tri[5] = positions[3*i1 + 2];

	            var i2 = indices[3*i + 2];
	            tri[6] = positions[3*i2];
	            tri[7] = positions[3*i2 + 1];
	            tri[8] = positions[3*i2 + 2];

	            dest[i] = tri;
	        }
	    } else {

	        var tnum = positions.length / 9;
	        for (var i = 0; i < positions.length; i++) {
	            var tri = new Float32Array(9);

	            tri[0] = positions[9*i];
	            tri[1] = positions[9*i + 1];
	            tri[2] = positions[9*i + 2];

	            tri[3] = positions[9*i + 3];
	            tri[4] = positions[9*i + 4];
	            tri[5] = positions[9*i + 5];

	            tri[6] = positions[9*i + 6];
	            tri[7] = positions[9*i + 7];
	            tri[8] = positions[9*i + 8];

	            dest[i] = tri;
	        }
	    }

	    return dest;
	}

	exports.extract_polyindices = extract_polyindices;
	/**
	 * <p>Return Array of vertex polygone index.
	 * @methodOf geometry
	 */
	function extract_polyindices(submesh) {
	    var polyindices = new Float32Array(submesh.base_length);

	    for (var i = 0; i < submesh.base_length; i++)
	        polyindices[i] = (i % 3) / 2;  // (0, 0.5, 1)

	    return polyindices;
	}

	/**
	 * Calculate triangle area using Heron's formula
	 * @methodOf geometry
	 */
	function triangle_area(A, B, C) {
	    return Math.sqrt(triangle_area_squared(A, B, C));
	}

	/**
	 * Calculate squared triangle area using Heron's formula
	 * @methodOf geometry
	 */
	exports.triangle_area_squared = triangle_area_squared;
	function triangle_area_squared(A, B, C) {
	    var a = m_vec3.dist(A, B);
	    var b = m_vec3.dist(A, C);
	    var c = m_vec3.dist(B, C);

	    var p = (a + b + c) / 2;

	    return p * (p - a) * (p - b) * (p - c);
	}

	/**
	 * Get random point within triangle
	 * @methodOf geometry
	 */
	function triangle_random_point(triangle, seed, dest) {

	    if (!dest)
	        dest = new Float32Array(3);

	    var x0 = triangle[0];
	    var y0 = triangle[1];
	    var z0 = triangle[2];

	    var x1 = triangle[3];
	    var y1 = triangle[4];
	    var z1 = triangle[5];

	    var x2 = triangle[6];
	    var y2 = triangle[7];
	    var z2 = triangle[8];

	    // barycentric coords
	    var w1 = m_util.rand_r(seed);
	    var w2 = m_util.rand_r(seed);

	    if ((w1 + w2) > 1) {
	        w1 = 1 - w1;
	        w2 = 1 - w2;
	    }

	    var w0 = 1 - w1 - w2;

	    var x = w0 * x0 + w1 * x1 + w2 * x2;
	    var y = w0 * y0 + w1 * y1 + w2 * y2;
	    var z = w0 * z0 + w1 * z1 + w2 * z2;

	    dest[0] = x;
	    dest[1] = y;
	    dest[2] = z;

	    return dest;
	}

	/**
	 * Generate billboard vertices
	 */
	exports.gen_bb_vertices = gen_bb_vertices;
	function gen_bb_vertices(count) {
	    var quad = new Float32Array([0,0,0,1,1,1,1,0]);
	    var bb_vertices = new Float32Array(count * 8);

	    for (var i = 0; i < count; i++)
	        bb_vertices.set(quad, i * 8);
	    return bb_vertices;
	}

	exports.scale_submesh_xyz = function(submesh, scale, center) {
	    var positions = submesh.va_frames[0]["a_position"];
	    for (var i = 0; i < positions.length; i += 3) {
	        positions[i]     = (positions[i]     - center[0]) * scale[0] + center[0];
	        positions[i + 1] = (positions[i + 1] - center[1]) * scale[1] + center[1];
	        positions[i + 2] = (positions[i + 2] - center[2]) * scale[2] + center[2];
	    }
	};

	exports.apply_shape_key = function(obj, key_name, new_value) {

	    // NOTE: only applies shape key for the first scene
	    var batches = obj.scenes_data[0].batches;
	    var sk_data = obj.render.shape_keys_values;

	    for (var i = 1; i < sk_data.length; i++)
	        if (sk_data[i]["name"] == key_name)
	            sk_data[i]["value"] = new_value;

	    for (var i = 0; i < batches.length; i++) {
	        if (batches[i].forked_batch || !batches[i].use_shape_keys || batches[i].debug_sphere)
	            continue;

	        var bd = batches[i].bufs_data;

	        // NOTE: split function into smaller ones (optimization issue in Chrome)
	        var pos_type = get_vbo_type_by_attr_name("a_position");
	        var pos_vbo = get_vbo_by_type(bd.vbo_data, pos_type);
	        var pos_vbo_source = get_vbo_source_by_type(bd.vbo_source_data, pos_type);

	        _gl.bindBuffer(_gl.ARRAY_BUFFER, pos_vbo);
	        apply_shape_key_pos(bd.pointers["a_position"], batches[i], pos_vbo_source, 
	                sk_data);

	        var tbn_type = get_vbo_type_by_attr_name("a_tbn");
	        var tbn_vbo = get_vbo_by_type(bd.vbo_data, tbn_type);
	        var tbn_vbo_source = get_vbo_source_by_type(bd.vbo_source_data, tbn_type);

	        _gl.bindBuffer(_gl.ARRAY_BUFFER, tbn_vbo);
	        apply_shape_key_tbn(bd.pointers["a_tbn"], batches[i], tbn_vbo_source,
	                sk_data);
	    }
	};

	function apply_shape_key_pos(pos_pointer, batch, vbo_source, sk_data) {
	    if (pos_pointer) {
	        var pos_offset = pos_pointer.offset;
	        var pos_length = pos_pointer.length + pos_offset;
	        var pos = batch.bufs_data.shape_keys[0].geometry["a_position"];
	        for (var i = pos_offset; i < pos_length; i++)
	            vbo_source[i] = pos[i - pos_offset];
	        for (var i = 1; i < batch.bufs_data.shape_keys.length; i++) {
	            var positions = batch.bufs_data.shape_keys[i].geometry["a_position"];
	            var value = sk_data[i]["value"];
	            if (!value)
	                continue;
	            for (var j = pos_offset; j < pos_length; j++)
	                vbo_source[j] +=  value * positions[j - pos_offset];
	        }
	        _gl.bufferSubData(_gl.ARRAY_BUFFER, m_util.FLOAT_SIZE * pos_offset, 
	                vbo_source.subarray(pos_offset));
	    }
	}

	function apply_shape_key_tbn(tbn_pointer, batch, vbo_source, sk_data) {
	    if (tbn_pointer) {
	        var tbn_offset = tbn_pointer.offset;
	        var tbn_count = tbn_pointer.length + tbn_offset;
	        var shape_keys = batch.bufs_data.shape_keys;
	        var tbn_first = shape_keys[0].geometry["a_tbn"];
	        var ident_tbn = m_tbn.identity(_tbn_tmp);

	        for (var i = tbn_offset; i < tbn_count; i+=m_tbn.TBN_NUM_COMP) {
	            var delta_tbn = m_tbn.identity(_tbn_tmp3);
	            var tbn_ind = (i - tbn_offset) / m_tbn.TBN_NUM_COMP;
	            for (var j = 1; j < shape_keys.length; j++) {
	                var value = sk_data[j]["value"];
	                if (!value)
	                    continue;

	                var tbn = shape_keys[j].geometry["a_tbn"];
	                var d_tbn = m_tbn.get_item(tbn, tbn_ind, _tbn_tmp2);
	                var cur_d_tbn = m_tbn.slerp(ident_tbn, d_tbn, value, _tbn_tmp2);
	                m_tbn.multiply_tbn(cur_d_tbn, ident_tbn, delta_tbn);
	            }

	            var b_tbn = m_tbn.get_item(tbn_first, tbn_ind, _tbn_tmp2);
	            var r_tbn = m_tbn.multiply_tbn(delta_tbn, b_tbn, _tbn_tmp2);

	            // NOTE: optimization: don't check vbo type, consider a_tbn as short 
	            vbo_source[i] = m_util.float_to_short(r_tbn[0]);
	            vbo_source[i + 1] = m_util.float_to_short(r_tbn[1]);
	            vbo_source[i + 2] = m_util.float_to_short(r_tbn[2]);
	            vbo_source[i + 3] = m_util.float_to_short(r_tbn[3]);
	        }
	        _gl.bufferSubData(_gl.ARRAY_BUFFER, m_util.FLOAT_SIZE * tbn_offset,
	                vbo_source.subarray(tbn_offset));
	    }
	}

	exports.check_shape_keys = function(obj) {
	    return obj.render.use_shape_keys;
	};

	exports.get_shape_keys_names = function(obj) {
	    var shape_keys_names = [];
	    if (obj.render)
	        for (var i = 1; i < obj.render.shape_keys_values.length; i++) {
	            shape_keys_names.push(obj.render.shape_keys_values[i]["name"]);
	        }
	    return shape_keys_names;
	};

	exports.get_shape_key_value = function(obj, key_name) {
	    if (obj.render)
	        for (var i = 1; i < obj.render.shape_keys_values.length; i++)
	            if (key_name == obj.render.shape_keys_values[i]["name"])
	                return obj.render.shape_keys_values[i]["value"];
	    return 0;
	};

	exports.has_shape_key = function(obj, key_name) {
	    var shape_keys = obj.render.shape_keys_values;
	    if (shape_keys)
	        for (var i = 1; i < shape_keys.length; i++)
	            if (shape_keys[i]["name"] == key_name)
	                return true;
	    return false;
	};

	exports.has_dyn_geom = function(obj) {
	    if (obj && obj.render && obj.render.dynamic_geometry)
	        return true;
	    else
	        return false;
	};

	exports.draw_line = function(batch, positions, is_split) {

	    var bufs_data = batch.bufs_data;

	    if (bufs_data) {

	        if (is_split)
	            var num_line_segm = positions.length / 3 / 2;
	        else
	            var num_line_segm = positions.length / 3 - 1;

	        // two triangles, 4 vertices, 6 indices
	        var tri_pos = new Float32Array(num_line_segm * 4 * 3);
	        var tri_dir = new Float32Array(num_line_segm * 4 * 3);
	        var tri_ind = new Uint16Array(num_line_segm * 6);

	        for (var i = 0; i < num_line_segm; i++) {
	            if (is_split) {
	                var pos_offset = 2 * 3 * i;
	                var pos_offset_next = 2 * 3 * i + 3;
	            } else {
	                var pos_offset = 3 * i;
	                var pos_offset_next = 3 * (i + 1);
	            }

	            var pos_x = positions[pos_offset];
	            var pos_y = positions[pos_offset + 1];
	            var pos_z = positions[pos_offset + 2];

	            var pos_x_next = positions[pos_offset_next];
	            var pos_y_next = positions[pos_offset_next + 1];
	            var pos_z_next = positions[pos_offset_next + 2];

	            var dir_x = pos_x_next - pos_x;
	            var dir_y = pos_y_next - pos_y;
	            var dir_z = pos_z_next - pos_z;

	            // 0, right
	            tri_pos[i * 4 * 3     ] = pos_x;
	            tri_pos[i * 4 * 3 +  1] = pos_y;
	            tri_pos[i * 4 * 3 +  2] = pos_z;

	            tri_dir[i * 4 * 3     ] = dir_x;
	            tri_dir[i * 4 * 3 +  1] = dir_y;
	            tri_dir[i * 4 * 3 +  2] = dir_z;

	            // 1, left, next
	            tri_pos[i * 4 * 3 +  3] = pos_x_next;
	            tri_pos[i * 4 * 3 +  4] = pos_y_next;
	            tri_pos[i * 4 * 3 +  5] = pos_z_next;

	            tri_dir[i * 4 * 3 +  3] = -dir_x;
	            tri_dir[i * 4 * 3 +  4] = -dir_y;
	            tri_dir[i * 4 * 3 +  5] = -dir_z;

	            // 2, left
	            tri_pos[i * 4 * 3 +  6] = pos_x;
	            tri_pos[i * 4 * 3 +  7] = pos_y;
	            tri_pos[i * 4 * 3 +  8] = pos_z;

	            tri_dir[i * 4 * 3 +  6] = -dir_x;
	            tri_dir[i * 4 * 3 +  7] = -dir_y;
	            tri_dir[i * 4 * 3 +  8] = -dir_z;

	            // 3, right, next
	            tri_pos[i * 4 * 3 +  9] = pos_x_next;
	            tri_pos[i * 4 * 3 + 10] = pos_y_next;
	            tri_pos[i * 4 * 3 + 11] = pos_z_next;

	            tri_dir[i * 4 * 3 +  9] = dir_x;
	            tri_dir[i * 4 * 3 + 10] = dir_y;
	            tri_dir[i * 4 * 3 + 11] = dir_z;

	            // 0 1 2
	            tri_ind[i * 6] = 4 * i;
	            tri_ind[i * 6 + 1] = 4 * i + 1;
	            tri_ind[i * 6 + 2] = 4 * i + 2;

	            // 0 3 1
	            tri_ind[i * 6 + 3] = 4 * i;
	            tri_ind[i * 6 + 4] = 4 * i + 3;
	            tri_ind[i * 6 + 5] = 4 * i + 1;
	        }

	        var new_vbo_size = 0;
	        for (var attr in bufs_data.pointers) {
	            var pointer = bufs_data.pointers[attr];
	            new_vbo_size += tri_pos.length / 3 * pointer.num_comp;
	        }

	        var lengths = {};
	        lengths[VBO_FLOAT] = new_vbo_size;
	        var vsd = bufs_data.vbo_source_data = init_vbo_source_data(lengths);

	        exports.update_bufs_data_index_array(bufs_data, batch.draw_mode,
	                tri_ind);

	        var offset = 0;

	        for (var attr in bufs_data.pointers) {
	            var pointer = bufs_data.pointers[attr];

	            switch (attr) {
	            case "a_position":
	                vbo_source_data_set_attr(vsd, attr, tri_pos, offset);
	                pointer.offset = offset;
	                pointer.length = tri_pos.length;
	                offset += pointer.length;
	                break;
	            case "a_direction":
	                vbo_source_data_set_attr(vsd, attr, tri_dir, offset);
	                pointer.offset = offset;
	                pointer.length = tri_dir.length;
	                offset += pointer.length;
	                break;
	            default:
	                pointer.offset = offset;
	                pointer.length = tri_pos.length / 3 * pointer.num_comp;

	                var new_array = new Float32Array(pointer.length);
	                vbo_source_data_set_attr(vsd, attr, new_array, offset);
	                offset += pointer.length;
	                break;
	            }
	        }

	        update_gl_buffers(bufs_data);
	    }
	};

	// NOTE: cloning without vbo_data - for deferred updating
	exports.clone_bufs_data = function(bufs_data) {

	    if (bufs_data) {
	        var out = init_bufs_data();
	        if (bufs_data.ibo_array)
	            switch (bufs_data.ibo_type) {
	                case _gl.UNSIGNED_SHORT:
	                    out.ibo_array = new Uint16Array(bufs_data.ibo_array);
	                    break;
	                case _gl.UNSIGNED_INT:
	                    out.ibo_array = new Uint32Array(bufs_data.ibo_array);
	                    break;
	            }
	        else
	            out.ibo_array = null;

	        out.vbo_source_data = clone_vbo_source_data(bufs_data.vbo_source_data);

	        out.ibo_type = bufs_data.ibo_type;
	        out.count = bufs_data.count;
	        out.pointers = m_util.clone_object_r(bufs_data.pointers);
	        out.usage = bufs_data.usage;
	        out.debug_ibo_bytes = bufs_data.debug_ibo_bytes;
	        out.debug_vbo_bytes = bufs_data.debug_vbo_bytes;

	        out.ibo = null;

	        out.info_for_z_sort_updates = m_util.clone_object_r(bufs_data.info_for_z_sort_updates);
	        out.shape_keys = m_util.clone_object_r(bufs_data.shape_keys);

	        out.instance_count = bufs_data.instance_count;

	        out.cleanup_gl_data_on_unload = bufs_data.cleanup_gl_data_on_unload;
	    } else
	        var out = null;
	    return out;
	};

	exports.init_submesh = init_submesh;
	function init_submesh(name) {

	    var va_common = {
	        "a_influence": new Float32Array(0),
	        "a_color": new Float32Array(0),
	        "a_texcoord": new Float32Array(0)
	    };

	    return {
	        name: name,
	        // number of vertices per frame
	        base_length: 0,
	        indices: null,
	        va_frames: [],
	        va_common: va_common,
	        shape_keys: [],
	        submesh_bd: {
	            bb_local : m_bounds.create_bb(),
	            be_local : m_bounds.create_be(),
	            bs_local : m_bounds.create_bs(),
	            bbr_local : m_bounds.create_rot_bb()
	        },
	        instanced_array_data: null
	    };
	}

	exports.clone_submesh = function(submesh) {
	    var submesh_new = init_submesh(submesh.name);

	    submesh_new.base_length = submesh.base_length;
	    submesh_new.indices = m_util.clone_object_r(submesh.indices);
	    submesh_new.va_frames = m_util.clone_object_r(submesh.va_frames);
	    submesh_new.va_common = m_util.clone_object_r(submesh.va_common);
	    submesh_new.shape_keys = m_util.clone_object_r(submesh.shape_keys);

	    m_bounds.copy_bb(submesh.submesh_bd.bb_local, submesh_new.submesh_bd.bb_local);
	    m_bounds.copy_be(submesh.submesh_bd.be_local, submesh_new.submesh_bd.be_local);
	    m_bounds.copy_bs(submesh.submesh_bd.bs_local, submesh_new.submesh_bd.bs_local);
	    m_bounds.copy_rot_bb(submesh.submesh_bd.bbr_local, submesh_new.submesh_bd.bbr_local);

	    submesh_new.instanced_array_data = m_util.clone_object_r(submesh.instanced_array_data);

	    return submesh_new;
	};

	exports.reset = function() {
	    _gl = null;
	};

	exports.init_vbo_source_data = init_vbo_source_data;
	function init_vbo_source_data(lengths) {
	    var vbo_source_data = [];
	    for (var type in lengths)
	        vbo_source_data.push(create_vbo_source_obj(type, lengths[type]));

	    return vbo_source_data;
	}

	function create_vbo_source_obj(type, len) {
	    var constructor = get_constructor_by_type(type);
	    return { vbo_source: new constructor(len), type: type };
	}

	function clone_vbo_source_data(vbo_source_data) {
	    var new_vbo_source_data = [];
	    for (var i = 0; i < vbo_source_data.length; i++) {
	        var vbo_source = vbo_source_data[i].vbo_source;
	        var type = vbo_source_data[i].type;

	        new_vbo_source_data.push({ vbo_source: new vbo_source.constructor(vbo_source), 
	                type: type });
	    }

	    return new_vbo_source_data;
	}

	exports.search_vbo_index_by_type = search_vbo_index_by_type;
	function search_vbo_index_by_type(array, type) {
	    for (var i = 0; i < array.length; i++)
	        if (array[i].type == type)
	            return i;

	    return -1;
	}

	exports.get_vbo_by_type = get_vbo_by_type;
	function get_vbo_by_type(vbo_data, type) {
	    var index = search_vbo_index_by_type(vbo_data, type);
	    return index == -1 ? null: vbo_data[index].vbo;
	}

	exports.get_vbo_source_by_type = get_vbo_source_by_type;
	function get_vbo_source_by_type(vbo_source_data, type) {
	    var index = search_vbo_index_by_type(vbo_source_data, type);
	    return index == -1 ? null: vbo_source_data[index].vbo_source;
	}

	exports.get_constructor_by_type = get_constructor_by_type;
	function get_constructor_by_type(type) {
	    switch (type) {
	    case VBO_FLOAT:
	        return Float32Array;
	    case VBO_SHORT:
	        return Int16Array;
	    case VBO_UBYTE:
	        return Uint8Array;
	    default:
	        return Float32Array;
	    }
	}

	exports.get_vbo_type_by_attr_name = get_vbo_type_by_attr_name;
	function get_vbo_type_by_attr_name(name) {

	    name = name.replace(/_next$/, "");
	    name = name.replace(/param_GEOMETRY_VC_a_\w+/, "param_GEOMETRY_VC_a");

	    switch (name) {
	    case "a_tbn":
	    case "a_shade_tangs":
	        return VBO_SHORT;
	    case "a_color":
	    case "a_bending_col_main":
	    case "a_bending_col_detail":
	    case "a_grass_size":
	    case "a_grass_color":
	    case "param_GEOMETRY_VC_a":
	    case "a_polyindex":
	    case "a_p_bb_vertex":
	    case "a_halo_bb_vertex":
	    case "a_bb_vertex":
	        return VBO_UBYTE;
	    default:
	        return VBO_FLOAT;
	    }
	}

	exports.get_type_size_by_attr_name = get_type_size_by_attr_name;
	function get_type_size_by_attr_name(name) {
	    var type = get_vbo_type_by_attr_name(name);
	    switch (type) {
	    case VBO_FLOAT:
	        return m_util.FLOAT_SIZE;
	    case VBO_SHORT:
	        return m_util.SHORT_SIZE;
	    case VBO_UBYTE:
	        return m_util.BYTE_SIZE;
	    default:
	        return m_util.FLOAT_SIZE;
	    }
	}

	exports.get_gl_type_by_attr_name = get_gl_type_by_attr_name;
	function get_gl_type_by_attr_name(name) {
	    var type = get_vbo_type_by_attr_name(name);
	    switch(type) {
	    case VBO_FLOAT:
	        return _gl.FLOAT;
	    case VBO_SHORT:
	        return _gl.SHORT;
	    case VBO_UBYTE:
	        return _gl.UNSIGNED_BYTE;
	    default:
	        return _gl.FLOAT;
	    }
	}

	exports.vbo_source_data_set_attr = vbo_source_data_set_attr;
	function vbo_source_data_set_attr(vbo_source_data, attr_name, array, offset) {
	    var type = get_vbo_type_by_attr_name(attr_name);
	    var index = search_vbo_index_by_type(vbo_source_data, type);

	    array_float_to_vbo(attr_name, array,
	            vbo_source_data[index].vbo_source.subarray(offset));
	}

	exports.value_vbo_to_float = value_vbo_to_float;
	function value_vbo_to_float(attr_name, val) {
	    var type = get_vbo_type_by_attr_name(attr_name);

	    switch (type) {
	    case VBO_FLOAT:
	        return val;
	    case VBO_SHORT:
	        return m_util.short_to_float(val);
	    case VBO_UBYTE:
	        return m_util.ubyte_to_ufloat(val);
	    }

	    return val;
	}

	exports.value_float_to_vbo = value_float_to_vbo;
	function value_float_to_vbo(attr_name, val) {
	    var type = get_vbo_type_by_attr_name(attr_name);

	    switch (type) {
	    case VBO_FLOAT:
	        return val;
	    case VBO_SHORT:
	        return m_util.float_to_short(val);
	    case VBO_UBYTE:
	        return m_util.ufloat_to_ubyte(val);
	    }

	    return val;
	}

	exports.array_vbo_to_float = array_vbo_to_float;
	function array_vbo_to_float(attr_name, source, dest) {
	    var type = get_vbo_type_by_attr_name(attr_name);

	    switch (type) {
	    case VBO_FLOAT:
	        dest.set(source);
	        break;
	    case VBO_SHORT:
	        for (var i = 0; i < source.length; i++)
	            dest[i] = m_util.short_to_float(source[i]);
	        break;
	    case VBO_UBYTE:
	        for (var i = 0; i < source.length; i++)
	            dest[i] = m_util.ubyte_to_ufloat(source[i]);
	        break;
	    }

	    return dest;
	}

	exports.array_float_to_vbo = array_float_to_vbo;
	function array_float_to_vbo(attr_name, source, dest) {
	    var type = get_vbo_type_by_attr_name(attr_name);

	    switch (type) {
	    case VBO_FLOAT:
	        dest.set(source);
	        break;
	    case VBO_SHORT:
	        for (var i = 0; i < source.length; i++)
	            dest[i] = m_util.float_to_short(source[i]);
	        break;
	    case VBO_UBYTE:
	        for (var i = 0; i < source.length; i++)
	            dest[i] = m_util.ufloat_to_ubyte(source[i]);
	        break;
	    }

	    return dest;
	}

	}

	var int_geometry_factory = register("__geometry", Int_geometry);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Rendering graph routines.
	 *
	 * Rendering graph consists of rendering subscenes, which in turn may have
	 * zero or more inputs and one or more outputs. All subscenes must be closed
	 * to last SINK element. SINK element is a fictional subscene without any outputs.
	 *
	 * @name subscene
	 * @namespace
	 * @exports exports as subscene
	 */
	function Int_subscene(ns, exports) {

	var m_cam      = int_camera_factory(ns);
	var m_cfg      = int_config_factory(ns);
	var m_util     = int_util_factory(ns);
	var m_bounds   = int_boundings_factory(ns);

	var cfg_out = m_cfg.outlining;

	var MAIN_OPAQUE                         = 0;
	var MAIN_BLEND                          = 1;
	var MAIN_XRAY                           = 2;
	var MAIN_PLANE_REFLECT                  = 3;
	var MAIN_CUBE_REFLECT                   = 4;
	var MAIN_PLANE_REFLECT_BLEND            = 5;
	var MAIN_CUBE_REFLECT_BLEND             = 6;
	var MAIN_GLOW                           = 7;
	var SHADOW_CAST                         = 8;
	var SHADOW_RECEIVE                      = 9;
	var GRASS_MAP                           = 10;
	var POSTPROCESSING                      = 11;
	var GLOW_COMBINE                        = 13;
	var RESOLVE                             = 14;
	var COLOR_PICKING                       = 15;
	var COLOR_PICKING_XRAY                  = 16;
	var DEBUG_VIEW                          = 17;
	var ANCHOR_VISIBILITY                   = 18;
	var DEPTH_PACK                          = 19;
	var SSAO                                = 20;
	var SSAO_BLUR                           = 21;
	var ANTIALIASING                        = 22;
	var SMAA_BLENDING_WEIGHT_CALCULATION    = 23; 
	var SMAA_EDGE_DETECTION                 = 24;
	var SMAA_RESOLVE                        = 25;
	var SMAA_NEIGHBORHOOD_BLENDING          = 26;
	var COMPOSITING                         = 27;
	var MOTION_BLUR                         = 28;
	var COC                                 = 29;
	var DOF                                 = 30;
	var OUTLINE_MASK                        = 31;
	var OUTLINE                             = 32;
	var GOD_RAYS                            = 33;
	var GOD_RAYS_COMBINE                    = 34;
	var SKY                                 = 35;
	var COPY                                = 36;
	var STEREO                              = 37;
	var LUMINANCE                           = 38;
	var AVERAGE_LUMINANCE                   = 39;
	var LUMINANCE_TRUNCED                   = 40;
	var BLOOM                               = 41;
	var VELOCITY                            = 42;
	var SINK                                = 43;
	var PERFORMANCE                         = 44;
	var RESIZE                              = 45;
	var IRRADIANCE                          = 46;
	var ROUGHNESS_CONVOLUTION               = 47;
	var BRDF                                = 48;

	exports.MAIN_OPAQUE = MAIN_OPAQUE;
	exports.MAIN_BLEND = MAIN_BLEND;
	exports.MAIN_XRAY = MAIN_XRAY;
	exports.MAIN_PLANE_REFLECT = MAIN_PLANE_REFLECT;
	exports.MAIN_CUBE_REFLECT = MAIN_CUBE_REFLECT;
	exports.MAIN_PLANE_REFLECT_BLEND = MAIN_PLANE_REFLECT_BLEND;
	exports.MAIN_CUBE_REFLECT_BLEND = MAIN_CUBE_REFLECT_BLEND;
	exports.MAIN_GLOW = MAIN_GLOW;
	exports.SHADOW_CAST = SHADOW_CAST;
	exports.SHADOW_RECEIVE = SHADOW_RECEIVE;
	exports.GRASS_MAP = GRASS_MAP;
	exports.POSTPROCESSING = POSTPROCESSING;
	exports.GLOW_COMBINE = GLOW_COMBINE;
	exports.RESOLVE = RESOLVE;
	exports.COLOR_PICKING = COLOR_PICKING;
	exports.COLOR_PICKING_XRAY = COLOR_PICKING_XRAY;
	exports.DEBUG_VIEW = DEBUG_VIEW;
	exports.ANCHOR_VISIBILITY = ANCHOR_VISIBILITY;
	exports.DEPTH_PACK = DEPTH_PACK;
	exports.SSAO = SSAO;
	exports.SSAO_BLUR = SSAO_BLUR;
	exports.ANTIALIASING = ANTIALIASING;
	exports.SMAA_BLENDING_WEIGHT_CALCULATION = SMAA_BLENDING_WEIGHT_CALCULATION;
	exports.SMAA_EDGE_DETECTION = SMAA_EDGE_DETECTION;
	exports.SMAA_RESOLVE = SMAA_RESOLVE;
	exports.SMAA_NEIGHBORHOOD_BLENDING = SMAA_NEIGHBORHOOD_BLENDING;
	exports.COMPOSITING = COMPOSITING;
	exports.MOTION_BLUR = MOTION_BLUR;
	exports.COC = COC;
	exports.DOF = DOF;
	exports.OUTLINE_MASK = OUTLINE_MASK;
	exports.OUTLINE = OUTLINE;
	exports.GOD_RAYS = GOD_RAYS;
	exports.GOD_RAYS_COMBINE = GOD_RAYS_COMBINE;
	exports.SKY = SKY;
	exports.COPY = COPY;
	exports.STEREO = STEREO;
	exports.LUMINANCE = LUMINANCE;
	exports.AVERAGE_LUMINANCE = AVERAGE_LUMINANCE;
	exports.LUMINANCE_TRUNCED = LUMINANCE_TRUNCED;
	exports.BLOOM = BLOOM;
	exports.VELOCITY = VELOCITY;
	exports.SINK = SINK;
	exports.PERFORMANCE = PERFORMANCE;
	exports.RESIZE = RESIZE;
	exports.IRRADIANCE = IRRADIANCE;
	exports.ROUGHNESS_CONVOLUTION = ROUGHNESS_CONVOLUTION;
	exports.BRDF = BRDF;


	exports.create_subs_shadow_cast = function(csm_index, lamp_index, shadow_params, num_lights) {
	    var subs = init_subs(SHADOW_CAST);
	    subs.csm_index = csm_index;
	    subs.self_shadow_polygon_offset = shadow_params.self_shadow_polygon_offset;
	    subs.shadow_lamp_index = lamp_index;
	    switch (shadow_params.lamp_types[lamp_index]) {
	    case "SPOT":
	    case "POINT":
	        subs.camera = m_cam.create_camera(m_cam.TYPE_PERSP);
	        var fov  = shadow_params.spot_sizes[lamp_index];
	        var near = shadow_params.clip_start[lamp_index];
	        var far  = shadow_params.clip_end[lamp_index];
	        m_cam.set_frustum(subs.camera, fov, near, far);
	        break;
	    default:
	        subs.camera = m_cam.create_camera(m_cam.TYPE_ORTHO_ASYMMETRIC);
	    }

	    add_light_attributes(subs, num_lights);

	    return subs;
	};

	function add_light_attributes(subs, num_lights) {
	    subs.num_lights = num_lights;
	    subs.light_directions        = new Float32Array(num_lights * 3); // vec3's
	    subs.light_positions         = new Float32Array(num_lights * 4); // vec4's
	    subs.light_color_intensities = new Float32Array(num_lights * 4); // vec4's
	}

	/**
	 * Create abstract subscene.
	 * @param type Subscene type
	 */
	function init_subs(type) {
	    var subs = {
	        type: type,
	        subtype: "",

	        // rendering flags
	        force_do_not_render: false,
	        do_render: false,
	        enqueue: false,
	        clear_color: false,
	        clear_depth: false,
	        depth_test: false,
	        blend: false,
	        pack: false,
	        // assign webgl texture before rendering
	        assign_texture: false,
	        need_fog_update: false,
	        need_perm_uniforms_update: false,

	        // common properties
	        debug_render_calls: 0,
	        debug_render_time: 0,
	        debug_render_time_queries: [],
	        
	        // properties for DEBUG_VIEW subs
	        debug_view_mode: 0,
	        debug_colors_seed: 0,
	        debug_render_time_threshold: 1,
	        
	        do_not_debug: false,
	        time: 0,
	        camera: null,
	        cube_view_matrices: null,
	        cube_cam_frustums:[],
	        draw_data: [],
	        slinks_internal: [],
	        textures_internal: [],
	        wind: new Float32Array(3),
	        grass_map_dim: new Float32Array(3),
	        fog_color_density: new Float32Array(4),
	        fog_params: new Float32Array(4),
	        cube_fog: new Float32Array(16),

	        // environment and world properties
	        sky_tex_default_value: 0,
	        environment_energy: 0,
	        num_lights: 0,
	        light_directions: null,
	        light_positions: null,
	        light_color_intensities: null,
	        light_factors: null,
	        horizon_color: new Float32Array(3),
	        zenith_color: new Float32Array(3),
	        sky_tex_fac: new Float32Array(4),
	        sun_intensity: new Float32Array(3), // affects fog color
	        sun_direction: new Float32Array([0,0,1]),
	        sun_quaternion: new Float32Array(4),
	        sky_tex_color: new Float32Array(3),
	        sky_ngraph_proxy_id: "",
	        bsdf_cube_sky_dim: 0,

	        // outline properties
	        outline_factor: 0,
	        draw_outline_flag: 0,
	        is_for_outline: false,
	        outline_color: new Float32Array(3),

	        // water properties
	        water: false,
	        cam_water_depth: 0,
	        water_fog_color_density: new Float32Array(4),
	        water_level: 0,
	        caustics: false,
	        caust_scale: 0,
	        caust_speed: new Float32Array(2),
	        caust_brightness: 0,

	        // sky properties
	        procedural_skydome: false,
	        use_as_environment_lighting: false,
	        mie_brightness: 0,
	        rayleigh_brightness: 0,
	        spot_brightness: 0,
	        mie_strength: 0,
	        rayleigh_strength: 0,
	        scatter_strength: 0,
	        mie_collection_power: 0,
	        rayleigh_collection_power: 0,
	        mie_distribution: 0,
	        sky_color: new Float32Array(3),

	        // ssao properties
	        ssao_hemisphere: false,
	        ssao_blur_depth: false,
	        ssao_blur_discard_value: 0,
	        ssao_radius_increase: 0,
	        ssao_influence: 0,
	        ssao_dist_factor: 0,
	        ssao_samples: 0,
	        ssao_only: false,
	        ssao_white: false,

	        // color correction properties
	        brightness: 0,
	        contrast: 0,
	        exposure: 0,
	        saturation: 0,

	        // god rays properties
	        god_rays_intensity: 0,
	        max_ray_length: 0,
	        radial_blur_step: 0,
	        steps_per_pass: 0,

	        // shadow map properties
	        csm_index: 0,
	        self_shadow_polygon_offset: 0,
	        self_shadow_normal_offset: 0,
	        v_light_ts: null,
	        v_light_r: null,
	        v_light_tsr: null,
	        p_light_matrix: null,

	        // other postprocessing properties
	        is_pp: false,
	        fxaa_quality: "",
	        bloom_key: 0,
	        bloom_blur: 0,
	        bloom_edge_lum: 0,
	        adaptive_bloom: true,
	        average_luminance: 0,
	        blur_texel_size_mult: 0,
	        ext_texel_size_mult: 0,
	        mb_decay_threshold: 0,
	        mb_factor: 0,
	        motion_blur_exp: 0,
	        pp_effect: "",
	        coc_type: "",
	        jitter_projection_space: new Float32Array(2),
	        last_mip_map_ind: 0.0,
	        bloom_blur_num: 2,
	        bloom_blur_scale: 0.5,

	        small_glow_mask_width: 0,
	        large_glow_mask_width: 0,
	        small_glow_mask_coeff: 0,
	        large_glow_mask_coeff: 0,

	        texel_size_multiplier: 0,
	        texel_size: new Float32Array(2),
	        texel_mask: new Float32Array(2),

	        // head-mounted display params
	        distortion_params: new Float32Array(4),
	        chromatic_aberration_coefs: new Float32Array(4),
	        enable_hmd_stereo: false,

	        shadow_lamp_index: 0,

	        need_draw_data_sort: true,

	        // sky props
	        sky_invert: false,
	        sky_use_rgb_to_intensity: false,
	        sky_use_map_blend: false,
	        sky_use_map_horizon: false,
	        sky_use_map_zenith_up: false,
	        sky_use_map_zenith_down: false,
	        sky_blend_type: "",
	        use_sky_blend: false,
	        use_sky_paper: false,
	        use_sky_real: false
	    };

	    // setting default values
	    subs.do_render = true;
	    subs.enqueue = true;
	    subs.clear_color = true;
	    subs.clear_depth = true;
	    subs.depth_test = true;
	    subs.need_perm_uniforms_update = true;
	    subs.texel_size_multiplier = 1;
	    subs.texel_mask[0] = 1;
	    subs.texel_mask[1] = 1;

	    subs.distortion_params[2] = 0.5;
	    subs.distortion_params[3] = 0.5;

	    subs.ssao_samples = 8;

	    return subs;
	}

	exports.clone_subs = function(subs) {
	    var subs_new = init_subs(subs.type);

	    subs_new.subtype = subs.subtype;

	    // rendering flags
	    subs_new.force_do_not_render = subs.force_do_not_render;
	    subs_new.do_render = subs.do_render;
	    subs_new.enqueue = subs.enqueue;
	    subs_new.clear_color = subs.clear_color;
	    subs_new.clear_depth = subs.clear_depth;
	    subs_new.depth_test = subs.depth_test;
	    subs_new.blend = subs.blend;
	    subs_new.pack = subs.pack;

	    // assign webgl texture before rendering
	    subs_new.assign_texture = subs.assign_texture;
	    subs_new.need_fog_update = subs.need_fog_update;
	    subs_new.need_perm_uniforms_update = subs.need_perm_uniforms_update;

	    // common properties
	    // no need to copy that
	    subs_new.debug_render_calls = 0;
	    subs_new.debug_render_time = 0;
	    subs_new.debug_render_time_queries = [];
	    
	    // properties for DEBUG_VIEW subs
	    subs_new.debug_view_mode = subs.debug_view_mode;
	    subs_new.debug_colors_seed = subs.debug_colors_seed;
	    subs_new.debug_render_time_threshold = subs.debug_render_time_threshold;
	    
	    subs_new.do_not_debug = subs.do_not_debug;
	    subs_new.time = subs.time;

	    subs_new.camera = m_cam.clone_camera(subs.camera, true);

	    subs_new.cube_view_matrices = m_util.clone_object_r(subs.cube_view_matrices);
	    subs_new.cube_cam_frustums = m_util.clone_object_r(subs.cube_cam_frustums);
	    subs_new.draw_data = m_util.clone_object_r(subs.draw_data);
	    subs_new.slinks_internal = m_util.clone_object_r(subs.slinks_internal);
	    subs_new.textures_internal = m_util.clone_object_r(subs.textures_internal);

	    subs_new.wind.set(subs.wind);
	    subs_new.grass_map_dim.set(subs.grass_map_dim);
	    subs_new.fog_color_density.set(subs.fog_color_density);
	    subs_new.fog_params.set(subs.fog_params);
	    subs_new.cube_fog.set(subs.cube_fog);

	    // environment and world properties
	    subs_new.sky_tex_default_value = subs.sky_tex_default_value;
	    subs_new.environment_energy = subs.environment_energy;
	    subs_new.num_lights = subs.num_lights;
	    subs_new.light_directions = m_util.clone_object_r(subs.light_directions);
	    subs_new.light_positions = m_util.clone_object_r(subs.light_positions);
	    subs_new.light_color_intensities = m_util.clone_object_r(subs.light_color_intensities);
	    subs_new.light_factors = m_util.clone_object_r(subs.light_factors);
	    subs_new.horizon_color.set(subs.horizon_color);
	    subs_new.zenith_color.set(subs.zenith_color);
	    subs_new.sky_tex_fac.set(subs.sky_tex_fac);
	    subs_new.sun_intensity.set(subs.sun_intensity);
	    subs_new.sun_direction.set(subs.sun_direction);
	    subs_new.sun_quaternion.set(subs.sun_quaternion);
	    subs_new.sky_tex_color.set(subs.sky_tex_color);
	    subs_new.sky_ngraph_proxy_id = subs.sky_ngraph_proxy_id;
	    subs_new.bsdf_cube_sky_dim = subs.bsdf_cube_sky_dim;

	    // outline properties
	    subs_new.outline_factor = subs.outline_factor;
	    subs_new.draw_outline_flag = subs.draw_outline_flag;
	    subs_new.is_for_outline = subs.is_for_outline;
	    subs_new.outline_color.set(subs.outline_color);

	    // water properties
	    subs_new.water = subs.water;
	    subs_new.cam_water_depth = subs.cam_water_depth;

	    subs_new.water_fog_color_density.set(subs.water_fog_color_density);
	    subs_new.water_level = subs.water_level;
	    subs_new.caustics = subs.caustics;
	    subs_new.caust_scale = subs.caust_scale;
	    subs_new.caust_speed.set(subs.caust_speed);
	    subs_new.caust_brightness = subs.caust_brightness;

	    // sky properties
	    subs_new.procedural_skydome = subs.procedural_skydome;
	    subs_new.use_as_environment_lighting = subs.use_as_environment_lighting;
	    subs_new.mie_brightness = subs.mie_brightness;
	    subs_new.rayleigh_brightness = subs.rayleigh_brightness;
	    subs_new.spot_brightness = subs.spot_brightness;
	    subs_new.mie_strength = subs.mie_strength;
	    subs_new.rayleigh_strength = subs.rayleigh_strength;
	    subs_new.scatter_strength = subs.scatter_strength;
	    subs_new.mie_collection_power = subs.mie_collection_power;
	    subs_new.rayleigh_collection_power = subs.rayleigh_collection_power;
	    subs_new.mie_distribution = subs.mie_distribution;
	    subs_new.sky_color.set(subs.sky_color);

	    // ssao properties
	    subs_new.ssao_hemisphere = subs.ssao_hemisphere;
	    subs_new.ssao_blur_depth = subs.ssao_blur_depth;
	    subs_new.ssao_blur_discard_value = subs.ssao_blur_discard_value;
	    subs_new.ssao_radius_increase = subs.ssao_radius_increase;
	    subs_new.ssao_influence = subs.ssao_influence;
	    subs_new.ssao_dist_factor = subs.ssao_dist_factor;
	    subs_new.ssao_samples = subs.ssao_samples;
	    subs_new.ssao_only = subs.ssao_only;
	    subs_new.ssao_white = subs.ssao_white;

	    // color correction properties
	    subs_new.brightness = subs.brightness;
	    subs_new.contrast = subs.contrast;
	    subs_new.exposure = subs.exposure;
	    subs_new.saturation = subs.saturation;

	    // god rays properties
	    subs_new.god_rays_intensity = subs.god_rays_intensity;
	    subs_new.max_ray_length = subs.max_ray_length;
	    subs_new.radial_blur_step = subs.radial_blur_step;
	    subs_new.steps_per_pass = subs.steps_per_pass;

	    // shadow map properties
	    subs_new.csm_index = subs.csm_index;
	    subs_new.self_shadow_polygon_offset = subs.self_shadow_polygon_offset;
	    subs_new.self_shadow_normal_offset = subs.self_shadow_normal_offset;

	    subs_new.v_light_ts = m_util.clone_object_r(subs.v_light_ts);
	    subs_new.v_light_r = m_util.clone_object_r(subs.v_light_r);
	    subs_new.v_light_tsr = m_util.clone_object_r(subs.v_light_tsr);
	    subs_new.p_light_matrix = m_util.clone_object_r(subs.p_light_matrix);

	    // other postprocessing properties
	    subs_new.is_pp = subs.is_pp;
	    subs_new.fxaa_quality = subs.fxaa_quality;
	    subs_new.bloom_key = subs.bloom_key;
	    subs_new.bloom_blur = subs.bloom_blur;
	    subs_new.bloom_edge_lum = subs.bloom_edge_lum;
	    subs_new.adaptive_bloom = subs.adaptive_bloom;
	    subs_new.average_luminance = subs.average_luminance;
	    subs_new.blur_texel_size_mult = subs.blur_texel_size_mult;
	    subs_new.ext_texel_size_mult = subs.ext_texel_size_mult;
	    subs_new.mb_decay_threshold = subs.mb_decay_threshold;
	    subs_new.mb_factor = subs.mb_factor;
	    subs_new.motion_blur_exp = subs.motion_blur_exp;
	    subs_new.pp_effect = subs.pp_effect;
	    subs_new.coc_type = subs.coc_type;

	    subs_new.jitter_projection_space.set(subs.jitter_projection_space);
	    subs_new.last_mip_map_ind = subs.last_mip_map_ind;
	    subs_new.bloom_blur_num = subs.bloom_blur_num;
	    subs_new.bloom_blur_scale = subs.bloom_blur_scale;

	    subs_new.small_glow_mask_width = subs.small_glow_mask_width;
	    subs_new.large_glow_mask_width = subs.large_glow_mask_width;
	    subs_new.small_glow_mask_coeff = subs.small_glow_mask_coeff;
	    subs_new.large_glow_mask_coeff = subs.large_glow_mask_coeff;

	    subs_new.texel_size_multiplier = subs.texel_size_multiplier;
	    subs_new.texel_size.set(subs.texel_size);
	    subs_new.texel_mask.set(subs.texel_mask);

	    // head-mounted display params
	    subs_new.distortion_params.set(subs.distortion_params);
	    subs_new.chromatic_aberration_coefs.set(subs.chromatic_aberration_coefs);
	    subs_new.enable_hmd_stereo = subs.enable_hmd_stereo;

	    subs_new.shadow_lamp_index = subs.shadow_lamp_index;

	    subs_new.need_draw_data_sort = subs.need_draw_data_sort;

	    // sky props
	    subs_new.sky_invert = subs.sky_invert;
	    subs_new.sky_use_rgb_to_intensity = subs.sky_use_rgb_to_intensity;
	    subs_new.sky_use_map_blend = subs.sky_use_map_blend;
	    subs_new.sky_use_map_horizon = subs.sky_use_map_horizon;
	    subs_new.sky_use_map_zenith_up = subs.sky_use_map_zenith_up;
	    subs_new.sky_use_map_zenith_down = subs.sky_use_map_zenith_down;
	    subs_new.sky_blend_type = subs.sky_blend_type;
	    subs_new.use_sky_blend = subs.use_sky_blend;
	    subs_new.use_sky_paper = subs.use_sky_paper;
	    subs_new.use_sky_real = subs.use_sky_real;

	    return subs_new;
	};

	exports.create_subs_grass_map = function() {

	    var subs = init_subs(GRASS_MAP);
	    subs.camera = m_cam.create_camera(m_cam.TYPE_ORTHO_ASPECT);

	    return subs;
	};

	exports.create_subs_postprocessing = function(pp_effect) {

	    var pp_subs = init_subs(POSTPROCESSING);
	    pp_subs.clear_color = false;
	    pp_subs.clear_depth = false;
	    pp_subs.depth_test = false;
	    pp_subs.is_pp = true;

	    pp_subs.camera = m_cam.create_camera(m_cam.TYPE_NONE);
	    pp_subs.pp_effect = pp_effect;

	    switch (pp_effect) {
	    case "NONE":
	        pp_subs.texel_mask[0] = 1;
	        pp_subs.texel_mask[1] = 1;
	        break;
	    case "GRAYSCALE":
	        pp_subs.texel_mask[0] = 1;
	        pp_subs.texel_mask[1] = 1;
	        break;
	    case "X_BLUR":
	        pp_subs.texel_mask[0] = 1;
	        pp_subs.texel_mask[1] = 0;
	        break;
	    case "Y_BLUR":
	        pp_subs.texel_mask[0] = 0;
	        pp_subs.texel_mask[1] = 1;
	        break;
	    case "X_GLOW_BLUR":
	        pp_subs.texel_mask[0] = 1;
	        pp_subs.texel_mask[1] = 0;
	        break;
	    case "Y_GLOW_BLUR":
	        pp_subs.texel_mask[0] = 0;
	        pp_subs.texel_mask[1] = 1;
	        break;
	    case "X_BLOOM_BLUR":
	        pp_subs.texel_mask[0] = 1;
	        pp_subs.texel_mask[1] = 0;
	        break;
	    case "Y_BLOOM_BLUR":
	        pp_subs.texel_mask[0] = 0;
	        pp_subs.texel_mask[1] = 1;
	        break;
	    case "X_DOF_BLUR":
	        pp_subs.texel_mask[0] = 1;
	        pp_subs.texel_mask[1] = 1;
	        break;
	    case "Y_DOF_BLUR":
	        pp_subs.texel_mask[0] = 1;
	        pp_subs.texel_mask[1] = 1;
	        break;
	    case "X_ALPHA_BLUR":
	        pp_subs.texel_mask[0] = 1;
	        pp_subs.texel_mask[1] = 0;
	        // fixed multiplier for DOF
	        pp_subs.texel_size_multiplier = 3.0;
	        break;
	    case "Y_ALPHA_BLUR":
	        pp_subs.texel_mask[0] = 0;
	        pp_subs.texel_mask[1] = 1;
	        // fixed multiplier for DOF
	        pp_subs.texel_size_multiplier = 3.0;
	        break;
	    case "X_EXTEND":
	        pp_subs.texel_mask[0] = 1;
	        pp_subs.texel_mask[1] = 0;
	        break;
	    case "Y_EXTEND":
	        pp_subs.texel_mask[0] = 0;
	        pp_subs.texel_mask[1] = 1;
	        break;
	    default:
	        m_util.panic("Wrong postprocessing effect: " + pp_effect);
	        break;
	    }

	    return pp_subs;
	};

	exports.create_subs_glow_combine = function(cam, sc_render) {

	    var subs = init_subs(GLOW_COMBINE);
	    subs.clear_color = false;
	    subs.clear_depth = false;
	    subs.depth_test = false;
	    subs.small_glow_mask_coeff = sc_render.glow_params.small_glow_mask_coeff;
	    subs.large_glow_mask_coeff = sc_render.glow_params.large_glow_mask_coeff;
	    subs.small_glow_mask_width = sc_render.glow_params.small_glow_mask_width;
	    subs.large_glow_mask_width = sc_render.glow_params.large_glow_mask_width;

	    subs.camera = cam;

	    subs.is_pp = true;

	    return subs;
	};

	/**
	 * Create MAIN_* subscene
	 * @param main_type "OPAQUE", "BLEND", "REFLECT"
	 * @param cam Camera to attach
	 */
	exports.create_subs_main = function(main_type, cam, opaque_do_clear_depth,
	        water_params, num_lights, wfs_params, wls_params, shadow_params, sun_exist) {
	    var subs = init_subs(main_type);

	    if (main_type == MAIN_OPAQUE) {
	        subs.clear_color = true;
	        subs.clear_depth = opaque_do_clear_depth;
	        subs.blend = false;
	    } else if (main_type == MAIN_BLEND) {
	        subs.clear_color = false;
	        subs.clear_depth = false;
	        subs.blend = true;
	    } else if (main_type == MAIN_XRAY) {
	        subs.clear_color = false;
	        subs.clear_depth = true;
	        subs.blend = true;
	    } else if (main_type == MAIN_PLANE_REFLECT || main_type == MAIN_CUBE_REFLECT) {
	        subs.clear_color = true;
	        subs.clear_depth = true;
	        subs.blend = false;
	    } else if (main_type == MAIN_PLANE_REFLECT_BLEND ||
	               main_type == MAIN_CUBE_REFLECT_BLEND) {
	        subs.clear_color = false;
	        subs.clear_depth = false;
	        subs.blend = true;
	    } else if (main_type == MAIN_GLOW) {
	        subs.clear_color = true;
	        subs.clear_depth = false;
	        subs.blend = true;
	    } else
	        m_util.panic("wrong main subscene type");

	    if (subs.blend && shadow_params)
	        subs.self_shadow_normal_offset = shadow_params.self_shadow_normal_offset;

	    subs.camera = cam;

	    var sts = wls_params.sky_texture_param;
	    if (sts) {
	        subs.sky_tex_fac.set([sts.blend_factor, sts.horizon_factor, sts.zenith_up_factor, sts.zenith_down_factor]);
	        subs.sky_tex_color.set(sts.color);
	        subs.sky_tex_default_value = sts.default_value;
	    }
	    subs.horizon_color.set(wls_params.horizon_color);
	    subs.zenith_color.set(wls_params.zenith_color);
	    subs.environment_energy = wls_params.environment_energy;

	    // by link
	    subs.fog_color_density = wfs_params.fog_color_density;
	    subs.fog_params = wfs_params.fog_params;

	    if (water_params)
	        assign_water_params(subs, water_params, sun_exist);

	    add_light_attributes(subs, num_lights);

	    return subs;
	};

	function assign_water_params(subs, water_params, sun_exist) {
	    var wp = water_params;

	    // water fog
	    if (wp.fog_color_density)
	        subs.water_fog_color_density.set(wp.fog_color_density);

	    // dynamics
	    subs.water_level        = wp.water_level;

	    // caustics
	    if (wp.caustics && sun_exist) {
	        subs.caustics         = true;
	        subs.caust_scale      = wp.caustic_scale;
	        subs.caust_brightness = wp.caustic_brightness;
	        subs.caust_speed.set(wp.caustic_speed);
	    }
	}

	exports.create_subs_resolve = function() {
	    var subs = init_subs(RESOLVE);
	    subs.is_pp = true;
	    subs.camera = m_cam.create_camera(m_cam.TYPE_NONE);
	    return subs;
	};

	exports.create_subs_color_picking = function(cam, xray, num_lights) {

	    var subs = init_subs(COLOR_PICKING);
	    if (xray) {
	        subs.type = COLOR_PICKING_XRAY;
	        subs.clear_color = false;
	        subs.clear_depth = true;
	    }

	    subs.enqueue = false;

	    subs.camera = cam;

	    add_light_attributes(subs, num_lights);

	    return subs;
	};

	exports.create_subs_debug_view = function(cam) {

	    var subs = init_subs(DEBUG_VIEW);
	    subs.do_render = false;
	    subs.clear_color = false;
	    subs.clear_depth = false;

	    subs.camera = cam;

	    return subs;
	};

	exports.create_subs_anchor_visibility = function(cam) {

	    var subs = init_subs(ANCHOR_VISIBILITY);
	    subs.clear_color = true;
	    subs.clear_depth = false;

	    subs.camera = cam;

	    return subs;
	};

	/**
	 * Used for depth and (optionally) shadow receive rendering
	 */
	exports.create_subs_shadow_receive = function(graph, cam, num_lights) {
	    var subs = init_subs(SHADOW_RECEIVE);
	    subs.camera = cam;

	    add_light_attributes(subs, num_lights);

	    return subs;
	};

	/**
	 * Store red channel from subs depth attachment as RGBA texture
	 */
	exports.create_subs_depth_pack = function(cam) {

	    var subs = init_subs(DEPTH_PACK);
	    subs.clear_color = false;
	    subs.clear_depth = false;

	    subs.camera = cam;
	    subs.is_pp = true;

	    return subs;
	};

	exports.create_subs_ssao = function(cam, wfs_params, ssao_params) {

	    var subs = init_subs(SSAO);
	    subs.clear_color = false;
	    subs.clear_depth = false;
	    subs.depth_test = false;

	    subs.camera = cam;

	    // by link
	    subs.fog_color_density = wfs_params.fog_color_density;
	    subs.water_fog_color_density.set(wfs_params.fog_color_density);

	    subs.ssao_radius_increase = ssao_params.radius_increase;
	    subs.ssao_hemisphere = ssao_params.hemisphere;
	    subs.ssao_influence = ssao_params.influence; // how much AO affects final rendering
	    subs.ssao_dist_factor = ssao_params.dist_factor; // how much ao decreases with distance
	    subs.ssao_samples = ssao_params.samples; // number of samples aka quality

	    subs.is_pp = true;

	    return subs;
	};

	exports.create_subs_ssao_blur = function(cam, ssao_params) {
	    var subs = init_subs(SSAO_BLUR);
	    subs.clear_color = false;
	    subs.clear_depth = false;
	    subs.depth_test = false;

	    subs.camera = cam;

	    subs.ssao_blur_depth = ssao_params.blur_depth;
	    subs.ssao_blur_discard_value = ssao_params.blur_discard_value;

	    subs.is_pp = true;

	    return subs;
	};

	exports.create_subs_aa = function(sc_render) {
	    var subs = init_subs(ANTIALIASING);
	    subs.clear_color = false;
	    subs.clear_depth = false;
	    subs.depth_test = false;


	    subs.texel_size_multiplier = 1 / sc_render.resolution_factor;
	    subs.fxaa_quality = sc_render.aa_quality;

	    subs.camera = m_cam.create_camera(m_cam.TYPE_NONE);

	    subs.is_pp = true;

	    return subs;
	};

	exports.create_subs_smaa = function(pass, sc_render) {
	    var subs = init_subs(pass);

	    if (pass == SMAA_BLENDING_WEIGHT_CALCULATION ||
	        pass == SMAA_EDGE_DETECTION)
	        subs.clear_color = true;
	    else
	        subs.clear_color = false;

	    subs.clear_depth = false;
	    subs.depth_test = false;
	    subs.texel_size_multiplier = 1 / sc_render.resolution_factor;

	    subs.camera = m_cam.create_camera(m_cam.TYPE_NONE);

	    if (pass == SMAA_BLENDING_WEIGHT_CALCULATION)
	        subs.jitter_subsample_ind = new Float32Array(4);

	    subs.is_pp = true;

	    return subs;
	};

	exports.create_subs_compositing = function(brightness, contrast, exposure, saturation) {

	    var subs = init_subs(COMPOSITING);
	    subs.clear_color = false;
	    subs.clear_depth = false;
	    subs.depth_test = false;

	    subs.camera = m_cam.create_camera(m_cam.TYPE_NONE);
	    subs.brightness = brightness;
	    subs.contrast   = contrast;
	    subs.exposure   = exposure;
	    subs.saturation = saturation;

	    subs.is_pp = true;

	    return subs;
	};

	exports.create_subs_motion_blur = function(mb_decay_threshold, mb_factor) {
	    var mb_subs = init_subs(MOTION_BLUR);
	    mb_subs.clear_color = false;
	    mb_subs.clear_depth = false;
	    mb_subs.depth_test = false;

	    mb_subs.camera = m_cam.create_camera(m_cam.TYPE_NONE);

	    mb_subs.assign_texture = true;

	    mb_subs.mb_decay_threshold = mb_decay_threshold;
	    mb_subs.mb_factor = mb_factor;

	    mb_subs.is_pp = true;

	    return mb_subs;
	};


	/**
	 * Circle of confusion (~blurriness) calculation
	 * in the alpha channel
	 */
	exports.create_subs_coc = function(cam, coc_type) {

	    var subs = init_subs(COC);
	    subs.clear_color = false;
	    subs.clear_depth = false;
	    subs.depth_test = false;

	    subs.camera = cam;
	    subs.texel_size_multiplier = subs.camera.dof_power;
	    subs.coc_type = coc_type;

	    subs.is_pp = true;

	    return subs;
	};

	exports.create_subs_dof = function(cam) {

	    var subs = init_subs(DOF);
	    subs.clear_color = false;
	    subs.clear_depth = false;
	    subs.depth_test = false;

	    subs.camera = cam;
	    subs.texel_size_multiplier = subs.camera.dof_power;

	    subs.is_pp = true;

	    return subs;
	};


	exports.create_subs_outline_mask = function(cam, num_lights) {
	    var subs = init_subs(OUTLINE_MASK);
	    subs.depth_test = false;
	    subs.camera = cam;

	    add_light_attributes(subs, num_lights);

	    return subs;
	};

	exports.create_subs_outline = function(outline_params) {
	    var subs = init_subs(OUTLINE);

	    if (cfg_out.outlining_overview_mode)
	        subs.outline_color.set(cfg_out.outline_color);
	    else
	        subs.outline_color.set(outline_params.outline_color);
	    subs.outline_factor = outline_params.outline_factor;
	    subs.ext_texel_size_mult = 5;
	    subs.blur_texel_size_mult = 3;
	    subs.depth_test = false;

	    subs.camera = m_cam.create_camera(m_cam.TYPE_NONE);
	    subs.is_pp = true;

	    return subs;
	};

	exports.create_subs_god_rays = function(cam, water, ray_length, pack, step,
	                              num_lights, steps_per_pass) {

	    var subs = init_subs(GOD_RAYS);
	    subs.clear_color = false;
	    subs.clear_depth = false;
	    subs.depth_test = false;

	    subs.horizon_color = new Float32Array([1, 1, 1]);
	    subs.zenith_color = new Float32Array([1, 1, 1]);

	    subs.environment_energy = 1;

	    subs.pack = pack;
	    subs.water = water;
	    subs.radial_blur_step = step;
	    subs.max_ray_length = ray_length;
	    subs.steps_per_pass = steps_per_pass;
	    subs.camera = cam;

	    add_light_attributes(subs, num_lights);

	    return subs;
	};

	exports.create_subs_god_rays_comb = function(intensity, num_lights) {

	    var subs = init_subs(GOD_RAYS_COMBINE);
	    subs.clear_color = false;
	    subs.clear_depth = false;
	    subs.depth_test = false;

	    subs.camera = m_cam.create_camera(m_cam.TYPE_NONE);

	    subs.god_rays_intensity = intensity;

	    add_light_attributes(subs, num_lights);

	    subs.is_pp = true;

	    return subs;
	};

	/**
	 * Create subscene for screen rendering
	 */
	exports.create_subs_sky = function(wls, num_lights, sky_params, size) {

	    var subs = init_subs(SKY);

	    subs.enqueue = false;
	    subs.clear_color = false;
	    subs.clear_depth = false;
	    subs.depth_test = false;

	    var cam = m_cam.create_camera(m_cam.TYPE_NONE);

	    // NOTE: check it
	    cam.width = size;
	    cam.height = size;

	    subs.camera = cam;

	    subs.cube_view_matrices = m_util.generate_cubemap_matrices();

	    add_light_attributes(subs, num_lights);

	    subs.horizon_color = new Float32Array([1, 1, 1]);
	    subs.zenith_color = new Float32Array([1, 1, 1]);

	    subs.environment_energy = 1;

	    subs.sky_color.set(sky_params.sky_color);

	    subs.procedural_skydome          = sky_params.procedural_skydome;
	    subs.use_as_environment_lighting = sky_params.use_as_environment_lighting;
	    subs.rayleigh_brightness         = sky_params.rayleigh_brightness;
	    subs.mie_brightness              = sky_params.mie_brightness;
	    subs.spot_brightness             = sky_params.spot_brightness;
	    subs.scatter_strength            = sky_params.scatter_strength;
	    subs.rayleigh_strength           = sky_params.rayleigh_strength;
	    subs.mie_strength                = sky_params.mie_strength;
	    subs.rayleigh_collection_power   = sky_params.rayleigh_collection_power;
	    subs.mie_collection_power        = sky_params.mie_collection_power;
	    subs.mie_distribution            = sky_params.mie_distribution;

	    if (wls) {
	        subs.horizon_color.set(wls.horizon_color);
	        subs.zenith_color.set(wls.zenith_color);
	        subs.environment_energy = wls.environment_energy;
	        var sts = wls.sky_texture_param;
	        if (sts) {
	            subs.sky_tex_fac.set([sts.blend_factor, sts.horizon_factor,
	                sts.zenith_up_factor, sts.zenith_down_factor]);
	            subs.sky_tex_color.set(sts.color);
	            subs.sky_tex_default_value = sts.default_value;
	            subs.sky_invert = sts.invert;
	            subs.sky_use_rgb_to_intensity = sts.use_rgb_to_intensity;
	            subs.sky_use_map_blend = sts.use_map_blend;
	            subs.sky_use_map_horizon = sts.use_map_horizon;
	            subs.sky_use_map_zenith_up = sts.use_map_zenith_up;
	            subs.sky_use_map_zenith_down = sts.use_map_zenith_down;
	            subs.sky_blend_type = sts.blend_type;
	        }
	        subs.use_sky_blend = wls.use_sky_blend;
	        subs.use_sky_paper = wls.use_sky_paper;
	        subs.use_sky_real = wls.use_sky_real;
	        subs.sky_ngraph_proxy_id = wls.ngraph_proxy_id;
	    }


	    return subs;
	};

	exports.create_subs_irradiance = function(num_lights, size) {

	    var subs = init_subs(IRRADIANCE);

	    subs.enqueue = false;
	    subs.clear_color = false;
	    subs.clear_depth = false;
	    subs.depth_test = false;

	    var cam = m_cam.create_camera(m_cam.TYPE_NONE);

	    // NOTE: check it
	    cam.width = size;
	    cam.height = size;

	    subs.camera = cam;

	    subs.cube_view_matrices = m_util.generate_cubemap_matrices();

	    add_light_attributes(subs, num_lights);

	    return subs;
	};

	exports.create_subs_rougness_convolution = function(num_lights) {

	    var subs = init_subs(ROUGHNESS_CONVOLUTION);

	    subs.enqueue = false;
	    subs.clear_color = false;
	    subs.clear_depth = false;
	    subs.depth_test = false;

	    var cam = m_cam.create_camera(m_cam.TYPE_NONE);

	    // NOTE: check it
	    cam.width = 128;
	    cam.height = 128;

	    subs.camera = cam;

	    subs.cube_view_matrices = m_util.generate_cubemap_matrices();

	    add_light_attributes(subs, num_lights);

	    return subs;
	};

	exports.create_subs_brdf = function() {

	    var subs = init_subs(BRDF);

	    subs.enqueue = false;
	    subs.clear_color = false;
	    subs.clear_depth = false;
	    subs.depth_test = false;

	    var cam = m_cam.create_camera(m_cam.TYPE_NONE);

	    // NOTE: check it
	    cam.width = 512;
	    cam.height = 512;

	    subs.camera = cam;

	    return subs;
	};

	exports.create_subs_copy = function() {

	    var subs = init_subs(COPY);
	    subs.clear_color = false;
	    subs.clear_depth = false;

	    subs.camera = m_cam.create_camera(m_cam.TYPE_NONE);
	    subs.is_pp = true;

	    return subs;
	};

	exports.create_subs_stereo = function(is_hmd_stereo, is_anaglyph_stereo) {

	    var subs = init_subs(STEREO);
	    subs.clear_color = false;
	    subs.clear_depth = false;
	    subs.subtype = is_hmd_stereo? "HMD" :
	            is_anaglyph_stereo ? "ANAGLYPH": "SIDEBYSIDE";

	    subs.camera = m_cam.create_camera(m_cam.TYPE_NONE);
	    subs.is_pp = true;

	    return subs;
	};

	exports.create_subs_luminance = function() {

	    var subs = init_subs(LUMINANCE);
	    subs.clear_color = false;
	    subs.clear_depth = false;

	    subs.camera = m_cam.create_camera(m_cam.TYPE_NONE);
	    subs.is_pp = true;

	    return subs;
	};

	exports.create_subs_av_luminance = function() {

	    var subs = init_subs(AVERAGE_LUMINANCE);
	    subs.clear_color = false;
	    subs.clear_depth = false;

	    subs.camera = m_cam.create_camera(m_cam.TYPE_NONE);
	    subs.is_pp = true;

	    return subs;
	};

	exports.create_resize_subs = function() {

	    var subs = init_subs(RESIZE);
	    subs.clear_color = false;
	    subs.clear_depth = false;

	    subs.camera = m_cam.create_camera(m_cam.TYPE_NONE);
	    subs.is_pp = true;

	    return subs;
	};

	exports.create_subs_luminance_truncated = function(bloom_key, edge_lum, num_lights, cam) {

	    var subs = init_subs(LUMINANCE_TRUNCED);
	    subs.clear_color = false;
	    subs.clear_depth = false;

	    subs.bloom_key = bloom_key;
	    subs.bloom_edge_lum = edge_lum;

	    //var cam = m_cam.create_camera(m_cam.TYPE_NONE);
	    subs.camera = cam;

	    add_light_attributes(subs, num_lights);
	    subs.is_pp = true;

	    return subs;
	};

	exports.create_subs_bloom_combine = function(blur, pass_num) {

	    var subs = init_subs(BLOOM);
	    subs.clear_color = false;
	    subs.clear_depth = false;

	    subs.camera = m_cam.create_camera(m_cam.TYPE_NONE);
	    subs.bloom_blur = blur;
	    subs.bloom_blur_num = pass_num;
	    subs.is_pp = true;

	    return subs;
	};

	exports.create_subs_veloctity = function(cam) {

	    var subs = init_subs(VELOCITY);
	    subs.clear_color = false;
	    subs.clear_depth = false;

	    subs.camera = cam;
	    subs.is_pp = true;

	    return subs;
	};

	/**
	 * Fictional subscene to close graph
	 */
	exports.create_subs_sink = function() {

	    var subs_sink = init_subs(SINK);
	    subs_sink.enqueue = false;

	    return subs_sink;
	};

	exports.create_subs_perf = function() {
	    var subs = init_subs(PERFORMANCE);
	    subs.is_pp = true;
	    return subs;
	};

	exports.subs_label = function(subs) {
	    switch (subs.type) {
	    case MAIN_OPAQUE:
	        return "MAIN OPAQUE";
	    case MAIN_BLEND:
	        return "MAIN BLEND";
	    case MAIN_XRAY:
	        return "MAIN XRAY";
	    case MAIN_PLANE_REFLECT:
	        return "MAIN PLANE REFLECT";
	    case MAIN_CUBE_REFLECT:
	        return "MAIN CUBE REFLECT";
	    case MAIN_PLANE_REFLECT_BLEND:
	        return "MAIN PLANE REFLECT BLEND";
	    case MAIN_CUBE_REFLECT_BLEND:
	        return "MAIN CUBE REFLECT BLEND";
	    case MAIN_GLOW:
	        return "MAIN GLOW";
	    case SHADOW_CAST:
	        return "SHADOW CAST";
	    case SHADOW_RECEIVE:
	        return "SHADOW RECEIVE";
	    case GRASS_MAP:
	        return "GRASS MAP";
	    // one special case
	    case POSTPROCESSING:
	        return "POSTPROCESSING (" + subs.pp_effect.replace(/_/g, " ") + ")";
	    case GLOW_COMBINE:
	        return "GLOW COMBINE";
	    case RESOLVE:
	        return "RESOLVE";
	    case COLOR_PICKING:
	        return "COLOR PICKING";
	    case COLOR_PICKING_XRAY:
	        return "COLOR PICKING XRAY";
	    case DEBUG_VIEW:
	        return "DEBUG VIEW";
	    case ANCHOR_VISIBILITY:
	        return "ANCHOR VISIBILITY";
	    case DEPTH_PACK:
	        return "DEPTH PACK";
	    case SSAO:
	        return "SSAO";
	    case SSAO_BLUR:
	        return "SSAO BLUR";
	    case ANTIALIASING:
	        return "ANTIALIASING";
	    case SMAA_BLENDING_WEIGHT_CALCULATION:
	        return "SMAA BLENDING WEIGHT CALCULATION";
	    case SMAA_EDGE_DETECTION:
	        return "SMAA EDGE DETECTION";
	    case SMAA_RESOLVE:
	        return "SMAA RESOLVE";
	    case SMAA_NEIGHBORHOOD_BLENDING:
	        return "SMAA NEIGHBORHOOD BLENDING";
	    case COMPOSITING:
	        return "COMPOSITING";
	    case MOTION_BLUR:
	        return "MOTION BLUR";
	    case COC:
	        return "COC";
	    case DOF:
	        return "DOF";
	    case OUTLINE_MASK:
	        return "OUTLINE MASK";
	    case OUTLINE:
	        return "OUTLINE";
	    case GOD_RAYS:
	        return "GOD RAYS";
	    case GOD_RAYS_COMBINE:
	        return "GOD RAYS COMBINE";
	    case SKY:
	        return "SKY";
	    case IRRADIANCE:
	        return "IRRADIANCE";
	    case ROUGHNESS_CONVOLUTION:
	        return "ROUGHNESS_CONVOLUTION";
	    case BRDF:
	        return "PRE-COMPUTE_BRDF";
	    case COPY:
	        return "COPY";
	    case STEREO:
	        return "STEREO";
	    case LUMINANCE:
	        return "LUMINANCE";
	    case AVERAGE_LUMINANCE:
	        return "AVERAGE LUMINANCE";
	    case LUMINANCE_TRUNCED:
	        return "LUMINANCE TRUNCED";
	    case BLOOM:
	        return "BLOOM";
	    case VELOCITY:
	        return "VELOCITY";
	    case PERFORMANCE:
	        return "PERFORMANCE";
	    case SINK:
	        return "SINK";
	    case RESIZE:
	        return "RESIZE";
	    default:
	        return "UNKNOWN";
	    }
	};

	exports.append_draw_data = function(subs, rb) {

	    var batch = rb.batch;
	    var shader = batch.shader;
	    var alpha_aa = batch.alpha_antialiasing;

	    // remove existing draw data if any
	    for (var i = 0; i < subs.draw_data.length; i++) {
	        var ddata = subs.draw_data[i];
	        var bundles = ddata.bundles;
	        var bundle_ind = bundles.indexOf(rb);
	        if (bundle_ind != -1) {
	            bundles.splice(bundle_ind, 1);
	            if (!bundles.length) {
	                subs.draw_data.splice(i, 1);
	                break;
	            }
	        }
	    }

	    if (subs.blend)
	        var offset_z = batch.offset_z;
	    else
	        var offset_z = 0;

	    var exist_ddata = get_draw_data(subs.draw_data, shader, alpha_aa, offset_z, batch.is_sky);

	    if (exist_ddata)
	        exist_ddata.bundles.push(rb);
	    else {
	        var d_data = init_draw_data(shader, rb, alpha_aa, offset_z, batch.is_sky);
	        subs.draw_data.push(d_data);
	        subs.need_draw_data_sort = true;
	    }
	};

	function init_draw_data(shader, rb, alpha_antialiasing, offset_z, is_sky) {
	    return {
	        shader: shader,
	        bundles: [rb],
	        alpha_antialiasing: alpha_antialiasing,
	        offset_z: offset_z,
	        is_sky: is_sky,
	        do_render: true,
	        z_index: Infinity
	    };
	}

	exports.init_bundle = function(batch, render, world_bounds) {
	    var bundle = {
	        do_render: true,
	        do_render_cube: [true, true, true, true, true, true],
	        obj_render: render,
	        batch: batch,
	        world_bounds: world_bounds || null,
	        info_for_z_sort_updates: null,
	        z_index: Infinity
	    };

	    // NOTE: Z-sorting is possible only for indexed buffers
	    if (batch.z_sort && batch.bufs_data.ibo_array) {
	        var indices = batch.bufs_data.ibo_array;
	        bundle.info_for_z_sort_updates = {
	            // caching is possible because count does not change
	            median_cache: new Float32Array(indices.length),
	            median_world_cache: new Float32Array(indices.length),
	            dist_cache: new Float32Array(indices.length/3),
	            zsort_eye_last: new Float32Array(3),
	            bb_min_side: m_bounds.calc_min_bb_side(batch.bounds_local.bb)
	        };
	    }

	    return bundle;
	};

	function get_draw_data(draw_data, shader, alpha_antialiasing, offset_z, is_sky) {
	    for (var i = 0; i < draw_data.length; i++) {
	        var ddata = draw_data[i];
	        if (ddata.shader == shader && ddata.alpha_antialiasing == alpha_antialiasing 
	                && ddata.offset_z == offset_z && ddata.is_sky == is_sky)
	            return ddata;
	    }
	    return null;
	}

	exports.sort_draw_data = function(subs) {
	    subs.draw_data.sort(sort_fun_draw_data);
	    subs.need_draw_data_sort = false;
	};

	function sort_fun(a, b) {
	    if (a == b) return 0;
	    return a > b ? 1 : -1;
	}

	function sort_fun_draw_data(a, b) {
	    return sort_fun(a.alpha_antialiasing, b.alpha_antialiasing) ||
	           sort_fun(a.is_sky, b.is_sky) ||
	           sort_fun(a.offset_z, b.offset_z) ||
	           sort_fun(a.shader.has_discard, b.shader.has_discard) ||
	           // sort_fun(a.shader.shader_id, b.shader.shader_id);
	           sort_fun(a.z_index, b.z_index);
	}

	}

	var int_subscene_factory = register("__subscene", Int_subscene);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/*
	 * Copyright (c) 2012 Brandon Jones
	 *
	 * This software is provided 'as-is', without any express or implied
	 * warranty. In no event will the authors be held liable for any damages
	 * arising from the use of this software.
	 *
	 * Permission is granted to anyone to use this software for any purpose,
	 * including commercial applications, and to alter it and redistribute it
	 * freely, subject to the following restrictions:
	 *
	 *    1. The origin of this software must not be misrepresented; you must not
	 *    claim that you wrote the original software. If you use this software
	 *    in a product, an acknowledgment in the product documentation would be
	 *    appreciated but is not required.
	 *
	 *    2. Altered source versions must be plainly marked as such, and must not
	 *    be misrepresented as being the original software.
	 *
	 *    3. This notice may not be removed or altered from any source
	 *    distribution.
	 */

	/**
	 * Utilities for loading DDS texture files
	 * @name texcomp
	 * @namespace
	 * @exports exports as texcomp
	 */
	function Int_texcomp(ns, exports) {

	var m_print = print_factory(ns);
	var m_util  = int_util_factory(ns);
	   
	// All values and structures referenced from:
	// http://msdn.microsoft.com/en-us/library/bb943991.aspx/
	var DDS_MAGIC = 0x20534444;

	// var DDSD_CAPS = 0x1;
	// var DDSD_HEIGHT = 0x2;
	// var DDSD_WIDTH = 0x4;
	// var DDSD_PITCH = 0x8;
	// var DDSD_PIXELFORMAT = 0x1000;
	var DDSD_MIPMAPCOUNT = 0x20000;
	// var DDSD_LINEARSIZE = 0x80000;
	// var DDSD_DEPTH = 0x800000;

	// var DDSCAPS_COMPLEX = 0x8;
	// var DDSCAPS_MIPMAP = 0x400000;
	// var DDSCAPS_TEXTURE = 0x1000;
	    
	// var DDSCAPS2_CUBEMAP = 0x200;
	// var DDSCAPS2_CUBEMAP_POSITIVEX = 0x400;
	// var DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800;
	// var DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000;
	// var DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000;
	// var DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000;
	// var DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000;
	// var DDSCAPS2_VOLUME = 0x200000;

	// var DDPF_ALPHAPIXELS = 0x1;
	// var DDPF_ALPHA = 0x2;
	var DDPF_FOURCC = 0x4;
	// var DDPF_RGB = 0x40;
	// var DDPF_YUV = 0x200;
	// var DDPF_LUMINANCE = 0x20000;

	var FOURCC_DXT1 = fourcc_to_int32("DXT1");
	var FOURCC_DXT3 = fourcc_to_int32("DXT3");
	var FOURCC_DXT5 = fourcc_to_int32("DXT5");

	 // The header length in 32 bit ints
	var DDS_HEADER_LENGTH_INT = 31;

	// Offsets into the header array
	var OFFSET_MAGIC = 0;

	var OFFSET_SIZE = 1;
	var OFFSET_FLAGS = 2;
	var OFFSET_HEIGHT = 3;
	var OFFSET_WIDTH = 4;

	var OFFSET_MIPMAPCOUNT = 7;

	var OFFSET_PF_FLAGS = 20;
	var OFFSET_PF_FOUR_CC = 21;

	var PVRTC_2 = 24;
	var PVRTC_4 = 25;

	// Little reminder for myself where the above values come from
	/*DDS_PIXELFORMAT {
	    int32 dwSize; // offset: 19
	    int32 dwFlags;
	    char[4] dwFourCC;
	    int32 dwRGBBitCount;
	    int32 dwRBitMask;
	    int32 dwGBitMask;
	    int32 dwBBitMask;
	    int32 dwABitMask; // offset: 26
	};

	DDS_HEADER {
	    int32 dwSize; // 1
	    int32 dwFlags;
	    int32 dwHeight;
	    int32 dwWidth;
	    int32 dwPitchOrLinearSize;
	    int32 dwDepth;
	    int32 dwMipMapCount; // offset: 7
	    int32[11] dwReserved1;
	    DDS_PIXELFORMAT ddspf; // offset 19
	    int32 dwCaps; // offset: 27
	    int32 dwCaps2;
	    int32 dwCaps3;
	    int32 dwCaps4;
	    int32 dwReserved2; // offset 31
	};*/

	var PVR_HEADER_LENGTH_INT = 13;
	var PVR_V2 = 0x21525650;
	var PVR_V3 = 0x03525650;

	var RGB_PVRTC_4BPPV1_FORMAT = 0;
	var RGB_PVRTC_2BPPV1_FORMAT = 1;
	var RGBA_PVRTC_4BPPV1_FORMAT = 2;
	var RGBA_PVRTC_2BPPV1_FORMAT = 3;

	/**
	 * Transcodes DXT into RGB565.
	 * Optimizations:
	 * 1. Use integer math to compute c2 and c3 instead of floating point
	 *    math.  Specifically:
	 *      c2 = 5/8 * c0 + 3/8 * c1
	 *      c3 = 3/8 * c0 + 5/8 * c1
	 *    This is about a 40% performance improvement.  It also appears to
	 *    match what hardware DXT decoders do, as the colors produced
	 *    by this integer math match what hardware produces, while the
	 *    floating point in dxtToRgb565Unoptimized() produce slightly
	 *    different colors (for one GPU this was tested on).
	 * 2. Unroll the inner loop.  Another ~10% improvement.
	 * 3. Compute r0, g0, b0, r1, g1, b1 only once instead of twice.
	 *    Another 10% improvement.
	 * 4. Use a Uint16Array instead of a Uint8Array.  Another 10% improvement.
	 * @author Evan Parker
	 * @param {Uint16Array} src The src DXT bits as a Uint16Array.
	 * @param {number} src16Offset
	 * @param {number} width
	 * @param {number} height
	 * @return {Uint16Array} dst
	 */
	function dxt_to_rgb_565(src, src16Offset, width, height) {
	    var c = new Uint16Array(4);
	    var dst = new Uint16Array(width * height);
	    var m = 0;
	    var dstI = 0;
	    var i = 0;
	    var r0 = 0, g0 = 0, b0 = 0, r1 = 0, g1 = 0, b1 = 0;

	    var blockWidth = width / 4;
	    var blockHeight = height / 4;
	    for (var blockY = 0; blockY < blockHeight; blockY++) {
	        for (var blockX = 0; blockX < blockWidth; blockX++) {
	            i = src16Offset + 4 * (blockY * blockWidth + blockX);
	            c[0] = src[i];
	            c[1] = src[i + 1];
	            r0 = c[0] & 0x1f;
	            g0 = c[0] & 0x7e0;
	            b0 = c[0] & 0xf800;
	            r1 = c[1] & 0x1f;
	            g1 = c[1] & 0x7e0;
	            b1 = c[1] & 0xf800;
	            // Interpolate between c0 and c1 to get c2 and c3.
	            // Note that we approximate 1/3 as 3/8 and 2/3 as 5/8 for
	            // speed.  This also appears to be what the hardware DXT
	            // decoder in many GPUs does :)
	            c[2] = ((5 * r0 + 3 * r1) >> 3)
	                | (((5 * g0 + 3 * g1) >> 3) & 0x7e0)
	                | (((5 * b0 + 3 * b1) >> 3) & 0xf800);
	            c[3] = ((5 * r1 + 3 * r0) >> 3)
	                | (((5 * g1 + 3 * g0) >> 3) & 0x7e0)
	                | (((5 * b1 + 3 * b0) >> 3) & 0xf800);
	            m = src[i + 2];
	            dstI = (blockY * 4) * width + blockX * 4;
	            dst[dstI] = c[m & 0x3];
	            dst[dstI + 1] = c[(m >> 2) & 0x3];
	            dst[dstI + 2] = c[(m >> 4) & 0x3];
	            dst[dstI + 3] = c[(m >> 6) & 0x3];
	            dstI += width;
	            dst[dstI] = c[(m >> 8) & 0x3];
	            dst[dstI + 1] = c[(m >> 10) & 0x3];
	            dst[dstI + 2] = c[(m >> 12) & 0x3];
	            dst[dstI + 3] = c[(m >> 14)];
	            m = src[i + 3];
	            dstI += width;
	            dst[dstI] = c[m & 0x3];
	            dst[dstI + 1] = c[(m >> 2) & 0x3];
	            dst[dstI + 2] = c[(m >> 4) & 0x3];
	            dst[dstI + 3] = c[(m >> 6) & 0x3];
	            dstI += width;
	            dst[dstI] = c[(m >> 8) & 0x3];
	            dst[dstI + 1] = c[(m >> 10) & 0x3];
	            dst[dstI + 2] = c[(m >> 12) & 0x3];
	            dst[dstI + 3] = c[(m >> 14)];
	        }
	    }
	    return dst;
	}

	/**
	 * Parses a DDS file from the given arrayBuffer and uploads it into the currently bound texture
	 *
	 * @param {WebGLRenderingContext} gl WebGL rendering context
	 * @param {WebGLCompressedTextureS3TC} ext WEBGL_compressed_texture_s3tc extension object
	 * @param {TypedArray} arrayBuffer Array Buffer containing the DDS files data
	 * @param {boolean} [loadMipmaps] If false only the top mipmap level will be loaded, otherwise all available mipmaps will be uploaded
	 *
	 * @returns {number} Number of mipmaps uploaded, 0 if there was an error
	 */
	exports.upload_dds_levels = upload_dds_levels;
	function upload_dds_levels(gl, ext, arrayBuffer, loadMipmaps) {
	    var header = new Int32Array(arrayBuffer, 0, DDS_HEADER_LENGTH_INT),
	        fourCC, blockBytes, internalFormat,
	        width, height, dataLength, dataOffset,
	        rgb565Data, byteArray, mipmapCount, i;

	    if (header[OFFSET_MAGIC] != DDS_MAGIC) {
	        m_print.error("Invalid magic number in DDS header");
	        return 0;
	    }
	    
	    if (!header[OFFSET_PF_FLAGS] & DDPF_FOURCC) {
	        m_print.error("Unsupported format, must contain a FourCC code");
	        return 0;
	    }

	    fourCC = header[OFFSET_PF_FOUR_CC];
	    switch (fourCC) {
	    case FOURCC_DXT1:
	        blockBytes = 8;
	        internalFormat = ext ? ext.COMPRESSED_RGB_S3TC_DXT1_EXT : null;
	        break;

	    case FOURCC_DXT3:
	        blockBytes = 16;
	        internalFormat = ext ? ext.COMPRESSED_RGBA_S3TC_DXT3_EXT : null;
	        break;

	    case FOURCC_DXT5:
	        blockBytes = 16;
	        internalFormat = ext ? ext.COMPRESSED_RGBA_S3TC_DXT5_EXT : null;
	        break;

	    default:
	        m_print.error("Unsupported FourCC code:", int32_to_fourcc(fourCC));
	        return null;
	    }

	    mipmapCount = 1;
	    if (header[OFFSET_FLAGS] & DDSD_MIPMAPCOUNT && loadMipmaps !== false) {
	        mipmapCount = Math.max(1, header[OFFSET_MIPMAPCOUNT]);
	    }

	    width = header[OFFSET_WIDTH];
	    height = header[OFFSET_HEIGHT];
	    dataOffset = header[OFFSET_SIZE] + 4;

	    if (ext) {
	        for (i = 0; i < mipmapCount; ++i) {
	            dataLength = Math.max( 4, width )/4 * Math.max( 4, height )/4 * blockBytes;
	            byteArray = new Uint8Array(arrayBuffer, dataOffset, dataLength);
	            gl.compressedTexImage2D(gl.TEXTURE_2D, i, internalFormat, width, height, 0, byteArray);
	            dataOffset += dataLength;
	            //width *= 0.5;
	            //height *= 0.5;
	            // fix issue with non-square textures
	            width = Math.max(width * 0.5, 1);
	            height = Math.max(height * 0.5, 1);
	        }
	    } else {
	        if (fourCC == FOURCC_DXT1) {
	            dataLength = Math.max( 4, width )/4 * Math.max( 4, height )/4 * blockBytes;
	            byteArray = new Uint16Array(arrayBuffer);
	            rgb565Data = dxt_to_rgb_565(byteArray, dataOffset / 2, width, height);
	            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, width, height, 0, gl.RGB, gl.UNSIGNED_SHORT_5_6_5, rgb565Data);
	            if (loadMipmaps) {
	                gl.generateMipmap(gl.TEXTURE_2D);
	            }
	        } else {
	            m_print.error("No manual decoder for", int32_to_fourcc(fourCC), "and no native support");
	            return 0;
	        }
	    }

	    return mipmapCount;
	}

	exports.upload_pvr_levels = function(gl, ext, arrayBuffer) {
	    var header = new Uint32Array(arrayBuffer, 0, PVR_HEADER_LENGTH_INT);
	    if (header[0] == PVR_V3) {
	        var width = header[7];
	        var height = header[6];
	        var mipmap_count = header[11];
	        var data_offset = 52 + header[12];
	        var pixel_format = header[2];
	        switch(pixel_format) {
	        case 0:
	            var byte_per_pix = 2;
	            var format = RGB_PVRTC_2BPPV1_FORMAT;
	            break;
	        case 1:
	            var byte_per_pix = 2;
	            var format = RGBA_PVRTC_2BPPV1_FORMAT;
	            break;
	        case 2:
	            var byte_per_pix = 4;
	            var format = RGB_PVRTC_4BPPV1_FORMAT;
	            break;
	        case 3:
	            var byte_per_pix = 4;
	            var format = RGBA_PVRTC_4BPPV1_FORMAT;
	            break;
	        default:
	            m_util.panic("Unsupported PVR V3 format.");
	        }
	    } else if (header[11] == PVR_V2) {
	        var width = header[2];
	        var height = header[1];
	        var mipmap_count = header[3];
	        var data_offset = header[0];
	        mipmap_count++;
	        var type_mask = 0xff;
	        var flags = header[4];
	        var format_flags = flags & type_mask;
	        var bitmask_alpha = header[10];
	        var use_alpha = bitmask_alpha > 0;
	        if (format_flags == PVRTC_4) {
	            var byte_per_pix = 4;
	            var format = use_alpha ? RGBA_PVRTC_4BPPV1_FORMAT : RGB_PVRTC_4BPPV1_FORMAT;
	        } else if (format_flags == PVRTC_2) {
	            var byte_per_pix = 2;
	            var format = use_alpha ? RGBA_PVRTC_2BPPV1_FORMAT : RGB_PVRTC_2BPPV1_FORMAT;
	        } else
	            m_util.panic("Unsupported PVR V2 format.");
	    } else
	        m_util.panic("Unsupported PVR version.");

	    if (byte_per_pix == 2) {
	        var block_width = 8;
	        var block_height = 4;
	    } else {
	        var block_width = 4;
	        var block_height = 4;
	    }
	    switch(format) {
	    case RGB_PVRTC_4BPPV1_FORMAT:
	        var inter_format = ext.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
	        break;
	    case RGB_PVRTC_2BPPV1_FORMAT:
	        var inter_format = ext.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
	        break;
	    case RGBA_PVRTC_4BPPV1_FORMAT:
	        var inter_format = ext.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
	        break;
	    case RGBA_PVRTC_2BPPV1_FORMAT:
	        var inter_format = ext.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
	        break;
	    }

	    var block_size = (block_width * block_height) * byte_per_pix / 8;
	    for (var i = 0; i < mipmap_count; i++) {
	        var s_width = Math.max(width >> i, 1);
	        var s_height = Math.max(height >> i, 1);

	        var width_blocks = s_width / block_width;
	        var height_blocks = s_height / block_height;

	        if (width_blocks < 2)
	            width_blocks = 2;
	        if (height_blocks < 2)
	            height_blocks = 2;

	        var data_size = width_blocks * height_blocks * block_size;
	        var byte_array = new Uint8Array(arrayBuffer, data_offset, data_size);
	        gl.compressedTexImage2D(gl.TEXTURE_2D, i, inter_format, s_width,
	                s_height, 0, byte_array);
	        data_offset += data_size;
	    }
	};

	/**
	 * Extract DDS width and height from the given arrayBuffer
	 * @param {TypedArray} arrayBuffer Array Buffer containing the DDS files data
	 * @returns {Object3D} Width and height of DDS image
	 */
	exports.get_width_height = function(arrayBuffer, format) {
	    switch(format) {
	    case "dds":
	        var header = new Int32Array(arrayBuffer, 0, DDS_HEADER_LENGTH_INT);
	        return {
	            width: header[OFFSET_WIDTH],
	            height: header[OFFSET_HEIGHT]
	        }
	        break;
	    case "pvr":
	        var header = new Uint32Array(arrayBuffer, 0, PVR_HEADER_LENGTH_INT);
	        if (header[0] == PVR_V3) {
	            var width = header[7];
	            var height = header[6];
	        } else {
	            var width = header[2];
	            var height = header[1];
	        }
	        return {
	            width: width,
	            height: height
	        }
	        break;
	    }
	    
	    
	};

	/**
	 * Calculate compress ratio for DDS from the given arrayBuffer
	 * @param {TypedArray} arrayBuffer Array Buffer containing the DDS files data
	 * @param {string} comp_method Compression methos (dds or pvr)
	 * @returns {number} Compress ratio according to DDS compression variant
	 */
	exports.get_compress_ratio = function(arrayBuffer, comp_method) {
	    var comp_ratio = 1;
	    if (comp_method == "dds") {
	        var header = new Int32Array(arrayBuffer, 0, DDS_HEADER_LENGTH_INT);
	        var fourCC = header[OFFSET_PF_FOUR_CC];
	        switch(fourCC) {
	        case FOURCC_DXT1:
	            comp_ratio = 6;
	            break;
	        case FOURCC_DXT3:
	        case FOURCC_DXT5:
	            comp_ratio = 4;
	            break;
	        default:
	            m_print.error("Unsupported FourCC code:", int32_to_fourcc(fourCC));
	            break;
	        }
	    } else if (comp_method == "pvr"){
	        var header = new Uint32Array(arrayBuffer, 0, PVR_HEADER_LENGTH_INT);
	        if (header[0] == PVR_V3) {
	            var pixel_format = header[2];
	            switch(pixel_format) {
	            case 0:
	                comp_ratio = 12;
	                break;
	            case 1:
	                comp_ratio = 16;
	                break;
	            case 2:
	                comp_ratio = 6;
	                break;
	            case 3:
	                comp_ratio = 8;
	                break;
	            }
	        } else {
	            var format_flags = header[4] & 0xff;
	            var use_alpha = header[10] > 0;
	            if (format_flags == PVRTC_4)
	                comp_ratio = use_alpha ? 8 : 6;
	            else if (format_flags == PVRTC_2)
	                comp_ratio = use_alpha ? 16 : 12;
	        }
	    }
	    return comp_ratio;
	};

	/**
	 * Creates a texture from the DDS file at the given URL. Simple shortcut for the most common use case
	 *
	 * @param {WebGLRenderingContext} gl WebGL rendering context
	 * @param {WebGLCompressedTextureS3TC} ext WEBGL_compressed_texture_s3tc extension object
	 * @param {string} src URL to DDS file to be loaded
	 * @param {function} [callback] callback to be fired when the texture has finished loading
	 *
	 * @returns {WebGLTexture} New texture that will receive the DDS image data
	 */
	function load_dds_texture_ex(gl, ext, src, texture, loadMipmaps, callback) {
	    var xhr = new XMLHttpRequest();
	    
	    xhr.open('GET', src, true);
	    xhr.responseType = "arraybuffer";
	    xhr.onload = function() {
	        if (xhr.status == 200) {
	            gl.bindTexture(gl.TEXTURE_2D, texture);
	            var mipmaps = upload_dds_levels(gl, ext, xhr.response, loadMipmaps);
	            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, mipmaps > 1 ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR);
	        }

	        if (callback) {
	            callback(texture);
	        }
	    };
	    xhr.send(null);

	    return texture;
	}

	/**
	 * Creates a texture from the DDS file at the given URL. Simple shortcut for the most common use case
	 *
	 * @param {WebGLRenderingContext} gl WebGL rendering context
	 * @param {WebGLCompressedTextureS3TC} ext WEBGL_compressed_texture_s3tc extension object
	 * @param {string} src URL to DDS file to be loaded
	 * @param {function} [callback] callback to be fired when the texture has finished loading
	 *
	 * @returns {WebGLTexture} New texture that will receive the DDS image data
	 */
	exports.load_dds_texture = function(gl, ext, src, callback) {
	    var texture = gl.createTexture();
	    load_dds_texture_ex(gl, ext, src, texture, true, callback);
	    return texture;
	};

	function fourcc_to_int32(value) {
	    return value.charCodeAt(0) +
	        (value.charCodeAt(1) << 8) +
	        (value.charCodeAt(2) << 16) +
	        (value.charCodeAt(3) << 24);
	}

	function int32_to_fourcc(value) {
	    return String.fromCharCode(
	        value & 0xff,
	        (value >> 8) & 0xff,
	        (value >> 16) & 0xff,
	        (value >> 24) & 0xff
	    );
	}

	}

	var int_texcomp_factory = register("__texcomp", Int_texcomp);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Time internal API.
	 * @name time
	 * @namespace
	 * @exports exports as time
	 */
	function Int_time(ns, exports) {

	var m_cfg   = int_config_factory(ns);

	// engine's global timeline (time since initialization)
	var _timeline = 0;

	var _timeline_epoch = 0;

	var _timeouts = [];
	var _timeout_counter = 0;
	var _animator_counter = 0;

	var _animators = [];

	var _framerate = -1;

	var _delta_from_prev_frame = 0;

	exports.set_timeline = function(timeline) {
	    _timeline = timeline;                   // s
	    _timeline_epoch = performance.now();    // ms

	    for (var i = 0; i < _timeouts.length; i++) {
	        var timeout = _timeouts[i];

	        if (_timeline > timeout.expire_time) {
	            // removing first to prevent race conditions in callback
	            _timeouts.splice(i, 1);
	            i--;
	            timeout.callback();
	        }
	    }

	    for (var i = 0; i < _animators.length; i++) {
	        var animator = _animators[i];

	        var time_amount = 1 - (animator.expire_time - _timeline) / animator.duration;
	        time_amount = Math.min(time_amount, 1);

	        var value = animator.from + time_amount * (animator.to - animator.from);
	        animator.callback(value);

	        if (time_amount == 1) {
	            _animators.splice(i, 1);
	            i--;
	        }
	    }
	};

	exports.get_timeline = get_timeline;
	function get_timeline() {
	    return _timeline;
	}

	function get_timeout_id() {
	    _timeout_counter++;
	    return _timeout_counter;
	}

	function get_animation_id() {
	    _animator_counter++;
	    return _animator_counter;
	}

	exports.set_delta = function(delta) {
	    _delta_from_prev_frame = delta;
	};

	exports.get_delta = function() {
	    return _delta_from_prev_frame;
	};

	/**
	 * Same behavior as window.setTimeout()
	 */
	exports.set_timeout = function(callback, time) {
	    var id = get_timeout_id();

	    var timeout = {
	        id: id,
	        callback: callback,
	        expire_time: _timeline + ((performance.now() - _timeline_epoch) + time) / 1000
	    };

	    _timeouts.push(timeout);

	    return id;
	};

	/**
	 * Same behavior as window.clearTimeout()
	 */
	exports.clear_timeout = function(id) {
	    for (var i = 0; i < _timeouts.length; i++) {
	        var timeout = _timeouts[i];

	        if (timeout.id == id) {
	            _timeouts.splice(i, 1);
	            break;
	        }
	    }
	};

	exports.clear_animation = function(id) {
	    for (var i = _animators.length; i--;) {
	        var animator = _animators[i];

	        if (animator.id == id) {
	            _animators.splice(i, 1);
	            break;
	        }
	    }
	};

	exports.animate = function(from, to, timeout, anim_cb) {

	    var duration = timeout / 1000;
	    var id = get_animation_id();

	    var animator = {
	        id: id,
	        callback: anim_cb,
	        from: from,
	        to: to,
	        expire_time: _timeline + duration,
	        duration: duration
	    };

	    _animators.push(animator);

	    anim_cb(from);

	    return id;
	};

	exports.reset = function(id) {
	    _timeline = 0;
	    _timeline_epoch = 0;

	    _timeouts.length = 0;
	    _animators.length = 0;
	    _timeout_counter = 0;
	    _animator_counter = 0;
	};

	exports.get_framerate = get_framerate;
	function get_framerate() {
	    if (m_cfg.animation.framerate !== -1)
	        return m_cfg.animation.framerate;
	    else
	        return _framerate;
	}

	exports.set_framerate = function(value) {
	    _framerate = value;
	};

	exports.get_frame = function(timeline) {
	    return timeline*get_framerate();
	};

	}

	var int_time_factory = register("__time", Int_time);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Armature utility functions
	 * @name armature
	 * @namespace
	 * @exports exports as armature
	 */
	function Int_armature(ns, exports) {

	var m_util = int_util_factory(ns);
	var m_tsr  = int_tsr_factory(ns);
	var m_quat = quat_factory(ns);
	var m_mat4 = mat4_factory(ns);
	var m_vec3 = vec3_factory(ns);

	var _tsr_tmp = m_tsr.create();
	var _tsr_tmp2 = m_tsr.create();
	var _vec4_tmp = new Float32Array(4);
	var _quat4_tmp = new Float32Array(4);
	var _quat4_tmp2 = new Float32Array(4);

	function init_bone_pointer() {
	    var bone_ptr =
	    {
	        bone_index: 0,
	        vgroup_index: -1,

	        parent_bone_ptr: null,
	        descend_bones_ptrs: [],
	        chain: [],
	        constraint: null,

	        tsr_bone_rest:     m_tsr.create(),
	        tsr_bone_pose:     m_tsr.create(),
	        tsr_local_rest:    m_tsr.create(),
	        tsr_local_rest_i:  m_tsr.create(),
	        tsr_local_pose:    m_tsr.create(),
	        tsr_local_pose_b:   m_tsr.create(),
	        tsr_local_pose_a:   m_tsr.create(),
	        tsr_basis:         m_tsr.create(),
	        tsr_channel_cache: m_tsr.create(),

	        tsr_channel_cache_valid: false,

	        tail: new Float32Array(3)
	    };
	    return bone_ptr;
	}

	exports.update_object = update_object;
	function update_object(bpy_armobj, armobj) {
	    var arm_bones = bpy_armobj["data"]["bones"];
	    var pose_bones = bpy_armobj["pose"]["bones"];

	    var bone_pointers = {};

	    for (var i = 0; i < pose_bones.length; i++) {
	        var pose_bone = pose_bones[i];
	        var arm_bone = pose_bone["bone"];

	        var bone_name = arm_bone["name"];
	        var bpointer = bone_pointers[bone_name] = init_bone_pointer();

	        var mat_loc = new Float32Array(arm_bone["matrix_local"]);
	        var mat_loc_inv = new Float32Array(16);
	        m_mat4.invert(mat_loc, mat_loc_inv);

	        var mat_bas = new Float32Array(pose_bone["matrix_basis"]);

	        var tail = bpointer.tail;
	        m_vec3.subtract(m_util.f32(arm_bone["tail_local"]),
	                m_util.f32(arm_bone["head_local"]), tail);
	        // translate tail offset from armature to bone space
	        m_util.vecdir_multiply_matrix(tail, mat_loc_inv, tail);

	        m_tsr.from_mat4(mat_loc, bpointer.tsr_local_rest);
	        m_tsr.from_mat4(mat_bas, bpointer.tsr_basis);
	        m_tsr.copy(bpointer.tsr_local_rest, bpointer.tsr_local_pose);
	        m_tsr.invert(bpointer.tsr_local_rest, bpointer.tsr_local_rest_i);
	    }

	    for (var i = 0; i < arm_bones.length; i++) {
	        var bone = arm_bones[i];
	        var bone_name = bone["name"];
	        var pose_bone = m_util.keysearch("name", bone_name, pose_bones);

	        var bpointer = bone_pointers[bone_name];
	        var parent_pose_bones = pose_bone["parent_recursive"];

	        // include current bone to chain with its parents
	        bpointer.chain.push(bpointer);
	        for (var j = 0; j < parent_pose_bones.length; j++) {
	            var parent_bone = parent_pose_bones[j];
	            var parent_bone_name = parent_bone["name"];
	            var parent_bone_ptr = bone_pointers[parent_bone_name];
	            bpointer.chain.push(parent_bone_ptr);
	        }

	        if (parent_pose_bones.length) {
	            var parent_bone = parent_pose_bones[0];
	            var parent_bone_name = parent_bone["name"];
	            var parent_bone_ptr = bone_pointers[parent_bone_name];
	            bpointer.parent_bone_ptr = parent_bone_ptr;

	            m_tsr.invert(parent_bone_ptr.tsr_local_rest, _tsr_tmp);
	            m_tsr.multiply(_tsr_tmp, bpointer.tsr_local_rest,
	                           bpointer.tsr_bone_rest);

	            // store only direct bone's descendants
	            parent_bone_ptr.descend_bones_ptrs.push(bpointer);
	        } else
	            m_tsr.copy(bpointer.tsr_local_rest, bpointer.tsr_bone_rest);

	        bpointer.bone_index = i;
	        bpointer.name = bone_name;

	        m_tsr.multiply(bpointer.tsr_bone_rest, bpointer.tsr_basis,
	                       bpointer.tsr_bone_pose);

	    }
	    armobj.render.bone_pointers = bone_pointers;
	}

	/**
	 * Get armature bone pose data (animated or static)
	 * uses _vec4_tmp, _quat4_tmp, _quat4_tmp2, _tsr_tmp, _tsr_tmp2
	 */
	exports.get_bone_tsr = function(armobj, bone_name, get_pose_tail,
	                                use_bone_space, dest_tsr) {
	    var render = armobj.render;

	    var frame_factor = render.frame_factor;
	    var bone_pointer = render.bone_pointers[bone_name];
	    var index = bone_pointer.bone_index;
	    var tsr_local = bone_pointer.tsr_local_rest;

	    var transcale = _vec4_tmp;

	    var trans_before = render.trans_before;
	    var trans_after = render.trans_after;
	    var quats_before = render.quats_before;
	    var quats_after = render.quats_after;

	    var x = trans_before[4*index];
	    var y = trans_before[4*index+1];
	    var z = trans_before[4*index+2];
	    var s = trans_before[4*index+3];

	    var xn = trans_after[4*index];
	    var yn = trans_after[4*index+1];
	    var zn = trans_after[4*index+2];
	    var sn = trans_after[4*index+3];

	    transcale[0] = (1-frame_factor) * x + frame_factor * xn;
	    transcale[1] = (1-frame_factor) * y + frame_factor * yn;
	    transcale[2] = (1-frame_factor) * z + frame_factor * zn;
	    transcale[3] = (1-frame_factor) * s + frame_factor * sn;

	    var quat = _quat4_tmp;
	    var quatn = _quat4_tmp2;

	    quat[0] = quats_before[4*index];
	    quat[1] = quats_before[4*index+1];
	    quat[2] = quats_before[4*index+2];
	    quat[3] = quats_before[4*index+3];

	    quatn[0] = quats_after[4*index];
	    quatn[1] = quats_after[4*index+1];
	    quatn[2] = quats_after[4*index+2];
	    quatn[3] = quats_after[4*index+3];

	    m_quat.slerp(quat, quatn, frame_factor, quat);

	    var tsr_bone = _tsr_tmp;
	    m_tsr.set_transcale(transcale, tsr_bone);
	    m_tsr.set_quat(quat, tsr_bone);

	    if (get_pose_tail) {
	        var tsr_local_tail = _tsr_tmp2;
	        m_tsr.translate(tsr_local, bone_pointer.tail, tsr_local_tail);
	        m_tsr.multiply(tsr_bone, tsr_local_tail, tsr_bone);
	    } else
	        m_tsr.multiply(tsr_bone, tsr_local, tsr_bone);

	    if (use_bone_space) {
	        var parent_bone_ptr = bone_pointer.parent_bone_ptr;
	        if (parent_bone_ptr) {
	            // move to bone space
	            var tsr_par_local = parent_bone_ptr.tsr_local_pose;
	            var inv_tsr_par_local = _tsr_tmp2;
	            m_tsr.invert(tsr_par_local, inv_tsr_par_local);
	            m_tsr.multiply(inv_tsr_par_local, tsr_bone, tsr_bone);
	        }
	        // calculate difference with rest pose tsr
	        var tsr_bone_rest = bone_pointer.tsr_bone_rest;
	        var inv_tsr_bone_rest = _tsr_tmp2;
	        m_tsr.invert(tsr_bone_rest, inv_tsr_bone_rest);
	        m_tsr.multiply(inv_tsr_bone_rest, tsr_bone, tsr_bone);
	    }

	    m_tsr.copy(tsr_bone, dest_tsr);
	};

	exports.set_bone_tsr = function(armobj, bone_name, tsr, use_bone_space) {
	    var render = armobj.render;
	    var bone_pointer = render.bone_pointers[bone_name];
	    var trans_before = render.trans_before;
	    var quats_before = render.quats_before;

	    if (use_bone_space)
	        m_tsr.multiply(bone_pointer.tsr_bone_rest, tsr,
	                       bone_pointer.tsr_bone_pose);
	    else
	        m_tsr.copy(tsr, bone_pointer.tsr_local_pose);

	    update_bone_tsr_r(bone_pointer, use_bone_space, trans_before, quats_before);
	    render.frame_factor = 0;
	    update_skinned_renders(armobj);
	};

	exports.update_skinned_renders = update_skinned_renders;
	function update_skinned_renders(armobj) {
	    var render = armobj.render;

	    var skinned_renders = render.skinned_renders;
	    var bone_maps = render.mesh_to_arm_bone_maps;

	    for (var i = 0; i < skinned_renders.length; i++) {

	        var skinned_render = skinned_renders[i];
	        var bone_map = bone_maps[i];

	        for (var j = 0; j < bone_map.length; j+=2) {
	            var sk_ind = bone_map[j];
	            var arm_ind = bone_map[j+1];

	            for (var k = 0; k < 4; k++) {
	                skinned_render.quats_before[sk_ind + k] =
	                                            render.quats_before[arm_ind + k];
	                skinned_render.quats_after [sk_ind + k] =
	                                            render.quats_after [arm_ind + k];
	                skinned_render.trans_before[sk_ind + k] =
	                                            render.trans_before[arm_ind + k];
	                skinned_render.trans_after [sk_ind + k] =
	                                            render.trans_after [arm_ind + k];
	            }
	        }
	        skinned_render.frame_factor = render.frame_factor;
	    }
	}

	exports.update_bone_tsr_r = update_bone_tsr_r;
	function update_bone_tsr_r(bone_pointer, use_bone_space, trans, quats) {

	    var tsr_bone_pose = bone_pointer.tsr_bone_pose;
	    var tsr_local_rest = bone_pointer.tsr_local_rest;
	    var tsr_local_pose = bone_pointer.tsr_local_pose;

	    var parent_bone_ptr = bone_pointer.parent_bone_ptr;
	    if (parent_bone_ptr) {
	        var tsr_par_local = parent_bone_ptr.tsr_local_pose;

	        if (use_bone_space)
	            m_tsr.multiply(tsr_par_local, tsr_bone_pose, tsr_local_pose);
	        else {
	            var inv_tsr_par_local = _tsr_tmp2;
	            m_tsr.invert(tsr_par_local, inv_tsr_par_local);
	            m_tsr.multiply(inv_tsr_par_local, tsr_local_pose, tsr_bone_pose);
	        }
	    } else
	        if (use_bone_space)
	            m_tsr.copy(tsr_bone_pose, tsr_local_pose);
	        else
	            m_tsr.copy(tsr_local_pose, tsr_bone_pose);

	    var dest_tsr = _tsr_tmp;
	    m_tsr.invert(tsr_local_rest, dest_tsr);
	    m_tsr.multiply(tsr_local_pose, dest_tsr, dest_tsr);

	    var index = bone_pointer.bone_index;

	    trans[4*index]   = dest_tsr[0];
	    trans[4*index+1] = dest_tsr[1];
	    trans[4*index+2] = dest_tsr[2];
	    trans[4*index+3] = dest_tsr[3];
	    quats[4*index]   = dest_tsr[4];
	    quats[4*index+1] = dest_tsr[5];
	    quats[4*index+2] = dest_tsr[6];
	    quats[4*index+3] = dest_tsr[7];

	    var descend_ptrs = bone_pointer.descend_bones_ptrs;
	    for (var i = 0; i < descend_ptrs.length; i++) {
	        var desc_bone_ptr = descend_ptrs[i];
	        // NOTE: temporary do not update child bones with constraints
	        if (desc_bone_ptr.constraint)
	            continue;
	        update_bone_tsr_r(desc_bone_ptr, true, trans, quats);
	    }
	}

	exports.check_bone = function(armobj, bone_name) {
	    return bone_name in armobj.render.bone_pointers;
	};

	}

	var int_armature_factory = register("__armature", Int_armature);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Lights internal API module.
	 * @name lights
	 * @namespace
	 * @exports exports as lights
	 */
	function Int_lights(ns, exports) {

	var m_tsr   = int_tsr_factory(ns);
	var m_util  = int_util_factory(ns);
	var m_vec3  = vec3_factory(ns);

	var _vec3_tmp = new Float32Array(3);

	/**
	 * Create light
	 * @param type Light type: POINT, SUN,...
	 */
	function init_light(type) {

	    // initialize properties (do not consider values as default!)
	    var light = {
	        name: "",
	        type: type,

	        use_diffuse: false,
	        use_specular: false,

	        prev_direction: new Float32Array(3),
	        direction: new Float32Array(3),
	        color: new Float32Array(3),
	        color_intensity: new Float32Array(3),

	        energy: 0,
	        default_energy: 0,
	        distance: 0,

	        use_sphere: false,

	        spot_size: 0,
	        spot_blend: 0,

	        clip_start: 0.1,
	        clip_end: 30.0,

	        falloff_type: "",

	        generate_shadows: false,

	        // have influence only for sun
	        need_sun_fog_update: false,
	        dynamic_intensity: false
	    };

	    //setting default values
	    light.use_diffuse = true;
	    light.use_specular = true;
	    light.energy = 1;
	    light.distance = 25;
	    light.falloff_type = "INVERSE_SQUARE";

	    return light;
	}

	/**
	 * Convert blender lamp object to light
	 */
	exports.lamp_to_light = function(bpy_obj, obj) {

	    var data = bpy_obj["data"];

	    var light = obj.light = init_light(data["type"]);

	    light.name = obj.name;
	    light.use_diffuse = data["use_diffuse"];
	    light.use_specular = data["use_specular"];
	    var quat = m_tsr.get_quat_view(obj.render.world_tsr);
	    var dir = m_util.quat_to_dir(quat, m_util.AXIS_Z, _vec3_tmp);
	    // though dir seems to be normalized, do it explicitely
	    m_vec3.normalize(dir, dir);
	    light.direction.set(dir);

	    light.color[0] = data["color"][0];
	    light.color[1] = data["color"][1];
	    light.color[2] = data["color"][2];

	    light.energy = light.default_energy = data["energy"];
	    update_color_intensity(light);

	    light.distance = data["distance"];
	    light.use_sphere = data["use_sphere"];

	    light.clip_start = data["clip_start"];
	    light.clip_end = data["clip_end"];

	    if (light.type === "POINT" || light.type === "SPOT")
	        light.distance = data["distance"];

	    if (light.type === "SPOT") {
	        light.spot_blend = data["spot_blend"];
	        light.spot_size = data["spot_size"];
	    } else if (light.type === "POINT")
	        light.spot_size = Math.PI / 2;

	    light.generate_shadows = data["b4w_generate_shadows"];
	    light.dynamic_intensity = data["b4w_dynamic_intensity"];
	};


	/**
	 * Set light color
	 */
	exports.set_light_color = function(light, color) {

	    light.color[0] = color[0];
	    light.color[1] = color[1];
	    light.color[2] = color[2];

	    update_color_intensity(light);
	};

	/**
	 * Set light spot blend
	 */
	exports.set_light_spot_blend = function(light, spot_blend) {
	    light.spot_blend = spot_blend;
	};

	/**
	 * Set light distance
	 */
	exports.set_light_distance = function(light, distance) {
	    light.distance = distance;
	};

	/**
	 * Set light spot size
	 */
	exports.set_light_spot_size = function(light, spot_size) {
	    light.spot_size = spot_size;
	};

	/**
	 * Set light energy
	 */
	exports.set_light_energy = function(light, energy) {
	    light.energy = energy;
	    update_color_intensity(light);
	};

	/**
	 * color, energy -> color_intensity
	 */
	function update_color_intensity(light) {
	    m_vec3.scale(light.color, light.energy, light.color_intensity);
	}

	exports.update_light_transform = update_light_transform;
	/**
	 * @methodOf lights 
	 */
	function update_light_transform(obj) {

	    var light = obj.light;
	    if (!light)
	        return;

	    var quat = m_tsr.get_quat_view(obj.render.world_tsr);
	    m_util.quat_to_dir(quat, m_util.AXIS_Z, light.direction);
	    m_vec3.normalize(light.direction, light.direction);

	    if (light.type == "SUN") {
	        var prev_angle = Math.acos(m_vec3.dot(light.prev_direction, m_util.VEC3_UNIT));
	        var new_angle  = Math.acos(m_vec3.dot(light.direction, m_util.VEC3_UNIT));
	        var floor_prev = Math.floor(prev_angle / 0.025);
	        var floor_new  = Math.floor(new_angle / 0.025);

	        if (floor_prev != floor_new)
	            light.need_sun_fog_update = true;
	        else
	            light.need_sun_fog_update = false;
	    }

	    m_vec3.copy(light.direction, light.prev_direction);
	}

	}

	var int_lights_factory = register("__lights", Int_lights);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Objects utility functions
	 * @name obj_util
	 * @namespace
	 * @exports exports as obj_util
	 */
	function Int_obj_util(ns, exports) {

	var m_bounds = int_boundings_factory(ns);
	var m_cfg    = int_config_factory(ns);
	var m_tsr    = int_tsr_factory(ns);
	var m_util   = int_util_factory(ns);
	var m_vec3   = vec3_factory(ns);
	var m_vec4   = vec4_factory(ns);

	var cfg_def = m_cfg.defaults;

	var LOD_DIST_MAX_INFINITY = Infinity;
	exports.LOD_DIST_MAX_INFINITY = LOD_DIST_MAX_INFINITY;

	/**
	 * Create abstract render
	 * @param {string} type "DYNAMIC", "STATIC", "CAMERA", "EMPTY", "NONE"
	 */
	exports.create_render = create_render;
	function create_render(type) {

	    var render = {
	        // common properties
	        type: type,
	        data_id: 0,
	        world_tsr: m_tsr.create_ext(),
	        world_tsr_inv: m_tsr.create_ext(),
	        pivot: new Float32Array(3),
	        hover_pivot: new Float32Array(3),
	        init_dist: 0,
	        init_fov: 0,
	        is_copied: false,
	        is_copied_deep: false,

	        color_id: null,
	        outline_intensity: 0,
	        // used only for TARGET camera
	        target_cam_upside_down: false,
	        vertical_axis: m_vec3.create(),

	        use_panning: false,

	        move_style: 0,
	        velocity_trans: 1,
	        velocity_rot: 1,
	        velocity_zoom: 1,

	        dof_distance: 0,
	        dof_front_start: 0,
	        dof_front_end: 0,
	        dof_rear_start: 0,
	        dof_rear_end: 0,
	        dof_power: 0,
	        dof_bokeh_intensity: 0,
	        dof_bokeh: false,
	        dof_foreground_blur : false,
	        dof_object: null,

	        horizontal_limits: null,
	        vertical_limits: null,
	        distance_limits: null,
	        hover_vert_trans_limits: null,
	        hover_horiz_trans_limits: null,

	        // currently only for TARGET camera
	        pivot_limits: null,

	        enable_hover_hor_rotation: true,
	        
	        outline_anim_settings_default: {
	            outline_duration: 1,
	            outline_period: 1,
	            outline_relapses: 0
	        },
	        
	        cube_reflection_id: -1,
	        plane_reflection_id: -1,
	        reflection_plane: new Float32Array(4),

	        // game/physics/lod properties
	        friction: 0,
	        elasticity: 0,
	        is_lod: false,
	        lod_center: new Float32Array(3), // for STATIC objects
	        main_lod_offset: new Float32Array(3), // for DYNAMIC objects
	        lod_dist_min: 0,
	        lod_dist_max: LOD_DIST_MAX_INFINITY,
	        
	        // the maximum radius around the border of the current lod level that 
	        // doesn't overleap over the adjacent lod levels in both directions:
	        // min(curr_level_interval, prev_level_interval)
	        // min(curr_level_interval, next_level_interval)
	        lod_lower_border_range: 0,
	        lod_upper_border_range: 0,

	        // rendering flags
	        do_not_render: false,
	        shadow_cast: false,
	        shadow_receive: false,
	        shadow_cast_only: false,
	        reflexible: false,
	        reflexible_only: false,
	        reflective: false,
	        reflection_type: "",
	        wind_bending: false,
	        dynamic_geometry: false,
	        dynamic_grass: false,
	        hide: false,
	        hide_children: false,
	        selectable: false,
	        origin_selectable: false,
	        outlining: false,
	        origin_outlining: false,
	        outline_on_select: false,
	        is_hair_particles: false,
	        is_visible: false,
	        force_zsort: false,

	        // wind bending properties
	        wind_bending_angle: 0,
	        wind_bending_amp: 0,
	        wind_bending_freq: 0,
	        detail_bending_freq: 0,
	        detail_bending_amp: 0,
	        branch_bending_amp: 0,
	        main_bend_col: "",
	        detail_bend_col: {
	            leaves_stiffness: "",
	            leaves_phase: "",
	            overall_stiffness: ""
	        },
	        bend_center_only: false,
	        center_pos: new Float32Array(3),

	        // billboarding properties
	        billboard: false,
	        billboard_pres_glob_orientation: false,
	        billboard_type: "",
	        billboard_spherical: false,

	        // animation properties
	        frame_factor: 0,
	        va_frame: 0,
	        va_frame_factor: 0,
	        max_bones: 0,
	        frames_blending: false,
	        vertex_anim: false,
	        use_shape_keys: false,
	        shape_keys_values: [],
	        is_skinning: false,
	        anim_mixing: false,
	        anim_mix_factor: 1.0,
	        anim_mix_factor_change_speed: 0,
	        anim_destination_mix_factor: 1.0,
	        anim_mix_cb: null,
	        mix_with_current: false,
	        blend_skel_slots: new Int8Array([-1, -1]),
	        skinned_renders: [],
	        mesh_to_arm_bone_maps: [],
	        skinning_data_cache: [],
	        quats_before: null,
	        quats_after: null,
	        trans_before: null,
	        trans_after: null,
	        trans_curr: null,
	        quats_curr: null,
	        bone_pointers: null,
	        bone_skinning_info: null,
	        pose_data: null,
	        arm_rel_trans: null,
	        arm_rel_quat: null,

	        // bounding volumes properties
	        bb_original: m_bounds.create_bb(),
	        bb_local: m_bounds.create_bb(),
	        bb_world: m_bounds.create_bb(),
	        bs_local: m_bounds.create_bs(),
	        bs_world: m_bounds.create_bs(),
	        be_local: m_bounds.create_be(),
	        be_world: m_bounds.create_be(),
	        bbr_local: m_bounds.create_rot_bb(),
	        bbr_world: m_bounds.create_rot_bb(),
	        bcyl_local: m_bounds.init_bcyl(),
	        bcap_local: m_bounds.init_bcap(),
	        bcon_local: m_bounds.init_bcon(),

	        pass_index: 0
	    };

	    // setting default values
	    m_vec3.copy(m_util.AXIS_Z, render.vertical_axis);

	    return render;
	}

	exports.clone_render = clone_render;
	function clone_render(render) {
	    var out = create_render(render.type);

	    // common properties
	    out.data_id = render.data_id;
	    m_tsr.copy(render.world_tsr, out.world_tsr);
	    m_tsr.copy(render.world_tsr_inv, out.world_tsr_inv);
	    m_vec3.copy(render.pivot, out.pivot);
	    m_vec3.copy(render.hover_pivot, out.hover_pivot);
	    out.init_dist = render.init_dist;
	    out.init_fov = render.init_fov;
	    out.is_copied = render.is_copied;
	    out.is_copied_deep = render.is_copied_deep;

	    if (render.color_id) // ?
	        out.color_id = m_vec3.clone(render.color_id);
	    out.outline_intensity = render.outline_intensity;
	    out.target_cam_upside_down = render.target_cam_upside_down;
	    m_vec3.copy(render.vertical_axis, out.vertical_axis);

	    out.use_panning = render.use_panning;

	    out.move_style = render.move_style;
	    out.velocity_trans = render.velocity_trans;
	    out.velocity_rot = render.velocity_rot;
	    out.velocity_zoom = render.velocity_zoom;

	    out.dof_distance = render.dof_distance;
	    out.dof_front_start = render.dof_front_start;
	    out.dof_front_end = render.dof_front_end;
	    out.dof_rear_start = render.dof_rear_start;
	    out.dof_rear_end = render.dof_rear_end;
	    out.dof_power = render.dof_power;
	    out.dof_bokeh_intensity = render.dof_bokeh_intensity;
	    out.dof_bokeh = render.dof_bokeh;
	    out.dof_foreground_blur = render.dof_foreground_blur;
	    out.dof_object = render.dof_object;

	    out.horizontal_limits = m_util.clone_object_r(render.horizontal_limits);
	    out.vertical_limits = m_util.clone_object_r(render.vertical_limits);
	    out.distance_limits = m_util.clone_object_r(render.distance_limits);
	    out.hover_vert_trans_limits = m_util.clone_object_r(render.hover_vert_trans_limits);
	    out.hover_horiz_trans_limits = m_util.clone_object_r(render.hover_horiz_trans_limits);

	    out.pivot_limits = render.pivot_limits;

	    out.enable_hover_hor_rotation = render.enable_hover_hor_rotation;
	    out.outline_anim_settings_default.outline_duration =
	            render.outline_anim_settings_default.outline_duration;
	    out.outline_anim_settings_default.outline_period =
	            render.outline_anim_settings_default.outline_period;
	    out.outline_anim_settings_default.outline_relapses =
	            render.outline_anim_settings_default.outline_relapses;
	    out.cube_reflection_id = render.cube_reflection_id;
	    out.plane_reflection_id = render.plane_reflection_id;
	    out.reflection_plane = render.reflection_plane;

	    out.friction = render.friction;
	    out.elasticity = render.elasticity;
	    out.is_lod = render.is_lod;
	    m_vec3.copy(render.lod_center, out.lod_center);
	    m_vec3.copy(render.main_lod_offset, out.main_lod_offset);
	    out.lod_dist_min = render.lod_dist_min;
	    out.lod_dist_max = render.lod_dist_max;
	    out.lod_lower_border_range = render.lod_lower_border_range;
	    out.lod_upper_border_range = render.lod_upper_border_range;

	    out.do_not_render = render.do_not_render;
	    out.shadow_cast = render.shadow_cast;
	    out.shadow_receive = render.shadow_receive;
	    out.shadow_cast_only = render.shadow_cast_only;
	    out.reflexible = render.reflexible;
	    out.reflexible_only = render.reflexible_only;
	    out.reflective = render.reflective;
	    out.reflection_type = render.reflection_type;
	    out.wind_bending = render.wind_bending;
	    out.dynamic_geometry = render.dynamic_geometry;
	    out.dynamic_grass = render.dynamic_grass;
	    out.hide = render.hide;
	    out.selectable = render.selectable;
	    out.origin_selectable = render.origin_selectable;
	    out.outlining = render.outlining;
	    out.origin_outlining = render.origin_outlining;
	    out.outline_on_select = render.outline_on_select;
	    out.is_hair_particles = render.is_hair_particles;
	    out.is_visible = render.is_visible;
	    out.force_zsort = render.force_zsort;

	    out.wind_bending_angle = render.wind_bending_angle;
	    out.wind_bending_amp = render.wind_bending_amp;
	    out.wind_bending_freq = render.wind_bending_freq;
	    out.detail_bending_freq = render.detail_bending_freq;
	    out.detail_bending_amp = render.detail_bending_amp;
	    out.branch_bending_amp = render.branch_bending_amp;
	    out.main_bend_col = render.main_bend_col;
	    // by link, doesn't matter
	    out.detail_bend_col = render.detail_bend_col;
	    out.bend_center_only = render.bend_center_only;
	    m_vec3.copy(render.center_pos, out.center_pos);

	    out.billboard = render.billboard;
	    out.billboard_pres_glob_orientation = render.billboard_pres_glob_orientation;
	    out.billboard_type = render.billboard_type;
	    out.billboard_spherical = render.billboard_spherical;

	    out.frame_factor = render.frame_factor;
	    out.va_frame = render.va_frame;
	    out.va_frame_factor = render.va_frame_factor;
	    out.max_bones = render.max_bones;
	    out.frames_blending = render.frames_blending;
	    out.vertex_anim = render.vertex_anim;
	    out.use_shape_keys = render.use_shape_keys;
	    out.shape_keys_values = m_util.clone_object_r(render.shape_keys_values); //?
	    out.is_skinning = render.is_skinning;
	    out.anim_mixing = render.anim_mixing;
	    out.anim_mix_factor = render.anim_mix_factor;
	    out.anim_mix_factor_change_speed = render.anim_mix_factor_change_speed;
	    out.anim_destination_mix_factor = render.anim_destination_mix_factor;
	    out.blend_skel_slots.set(render.blend_skel_slots);
	    out.skinned_renders = m_util.clone_object_r(render.skinned_renders); //?
	    out.mesh_to_arm_bone_maps = m_util.clone_object_r(render.mesh_to_arm_bone_maps); //?
	    out.skinning_data_cache = m_util.clone_object_r(render.skinning_data_cache); // ?
	    out.quats_before = m_util.clone_object_r(render.quats_before); //?
	    out.quats_after = m_util.clone_object_r(render.quats_after); //?
	    out.trans_before = m_util.clone_object_r(render.trans_before); //?
	    out.trans_after = m_util.clone_object_r(render.trans_after); //?
	    out.bone_pointers = m_util.clone_object_r(render.bone_pointers); //?
	    out.bone_skinning_info = m_util.clone_object_r(render.bone_skinning_info); //?
	    out.pose_data = m_util.clone_object_r(render.pose_data); //?
	    out.arm_rel_trans = m_util.clone_object_r(render.arm_rel_trans); //?
	    out.arm_rel_quat = m_util.clone_object_r(render.arm_rel_quat); //?

	    m_bounds.copy_bb(render.bb_original, out.bb_original);
	    m_bounds.copy_bb(render.bb_local, out.bb_local);
	    m_bounds.copy_bb(render.bb_world, out.bb_world);
	    m_bounds.copy_bs(render.bs_local, out.bs_local);
	    m_bounds.copy_bs(render.bs_world, out.bs_world);
	    m_bounds.copy_be(render.be_local, out.be_local);
	    m_bounds.copy_be(render.be_world, out.be_world);

	    m_bounds.copy_bcap(render.bcap_local, out.bcap_local);
	    m_bounds.copy_bcyl(render.bcyl_local, out.bcyl_local);
	    m_bounds.copy_bcon(render.bcon_local, out.bcon_local);

	    out.pass_index = render.pass_index;

	    return out;
	}

	/**
	 * Create empty object
	 */
	exports.create_object = create_object;
	function create_object(name, type, origin_name) {
	    if (!origin_name)
	        origin_name = name;

	    var obj = {

	        name: name,
	        uuid: m_util.gen_uuid(),
	        origin_name: origin_name,
	        type: type,

	        materials: [],

	        is_meta: true,

	        // material inheritance requires bpy object for batching
	        _bpy_obj: null, 

	        mat_inheritance_data: {
	            // to keep the original mat names after inheritance
	            original_mat_names: [],
	            // to prevent a material from participating in batching
	            is_disabled: []
	        },

	        is_dynamic: false,
	        is_hair_dupli: false,
	        use_default_animation: false,
	        is_boundings_overridden: false,
	        
	        render: null,
	        constraint: null,
	        sfx: null,
	        light: null,
	        armobj: null,
	        anchor: null,
	        field: null,
	        metatags: null,
	        custom_prop: null,

	        scenes_data: [],
	        vertex_anim: [],
	        cons_descends: m_util.create_non_smi_array(),
	        cons_armat_bone_descends: m_util.create_non_smi_array(),
	        anim_slots: [],
	        reflective_objs: [],
	        nla_events: [],
	        action_anim_cache: [],

	        sensor_manifolds : null,
	        sensor_manifolds_arr : [],
	        
	        parent: null,
	        parent_is_dupli: false,
	        parent_bone: "",
	        viewport_alignment: null,
	        pinverse_tsr: null,

	        use_obj_physics: false,
	        collision_id: "",
	        correct_bounding_offset: "AUTO",
	        is_vehicle: false,
	        is_character: false,
	        is_floating: false,

	        bob_synchronize_pos: false,

	        physics: null,
	        vehicle: null,
	        floater: null,

	        vehicle_settings: null,
	        floating_settings: null,
	        character_settings: null,

	        physics_constraints: [],
	        physics_settings: {
	            physics_type:           "NO_COLLISION",
	            use_ghost:              false,
	            use_sleep:              false,
	            mass:                   0,
	            velocity_min:           0,
	            velocity_max:           0,
	            damping:                0,
	            rotation_damping:       0,
	            lock_location_x:        false,
	            lock_location_y:        false,
	            lock_location_z:        false,
	            lock_rotation_x:        false,
	            lock_rotation_y:        false,
	            lock_rotation_z:        false,
	            collision_margin:       0,
	            collision_group:        0,
	            collision_mask:         0,
	            use_collision_bounds:   false,
	            collision_bounds_type:  "BOX",
	            use_collision_compound: false
	        },

	        outline_animation: {
	            time_start: 0,
	            outline_time: 0,
	            period: 0,
	            relapses: 0
	        },

	        anim_behavior_def: 0,
	        def_action_slots: [], // slot: {String dest(e.g. material+group), action}

	        need_update_transform: false, // used for armature bones constraints
	        need_inv_zup_tsr: false, // for MESH only, used in some node materials
	        meta_objects : []
	    };
	    return obj;
	}

	exports.init_scene_data = init_scene_data;
	function init_scene_data(scene) {
	    var sc_data = {
	        scene: scene,
	        is_active: false,
	        batches: [],
	        batch_world_bounds: [],
	        plane_refl_subs: [],
	        cube_refl_subs: null,
	        shadow_subscenes: [],
	        light_index: 0,
	        obj_has_nla_on_scene: false,
	        cameras: [],
	        shadow_cameras: []
	    };
	    return sc_data;
	}

	exports.copy_bpy_object_props_by_link = function(obj) {
	    if (obj instanceof Array)
	        return obj.slice();
	    else
	        return obj;
	};

	/**
	 * unused
	 */
	// exports.copy_batches_props_by_link_nr = function(batches) {
	//     // TODO: remove bounding data from batches
	//     var new_batches = [];
	//     for (var i = 0; i < batches.length; i++) {
	//         var batch = batches[i];
	//         var new_batch = {};
	//         for (var prop in batch)
	//             new_batch[prop] = batch[prop];

	//         new_batches.push(new_batch);
	//     }
	//     return new_batches;
	// }

	exports.copy_object_props_by_value = copy_object_props_by_value;
	function copy_object_props_by_value(obj) {

	    // better than typeof - no need to check for null
	    if (!(obj instanceof Object)) {
	        return obj;
	    }

	    var textures = null;
	    var texture_names = null;
	    var bpy_tex_names = null;
	    var shape_keys = null;
	    var shader = null;
	    var vaos = null;

	    if (obj.textures) {
	        textures = obj.textures;
	        obj.textures = null;
	    }
	    if (obj.texture_names) {
	        texture_names = obj.texture_names;
	        obj.texture_names = null;
	    }
	    if (obj.bpy_tex_names) {
	        bpy_tex_names = obj.bpy_tex_names;
	        obj.bpy_tex_names = null;
	    }
	    if (obj.shape_keys) {
	        shape_keys = obj.shape_keys;
	        obj.shape_keys = null;
	    }
	    if (obj.shader) {
	        shader = obj.shader;
	        obj.shader = null;
	    }
	    if (obj.vaos) {
	        vaos = obj.vaos;
	        obj.vaos = null;
	    }

	    var obj_clone;
	    var Constructor = obj.constructor;

	    switch (Constructor) {
	    case Int8Array:
	    case Uint8Array:
	    case Uint8ClampedArray:
	    case Int16Array:
	    case Uint16Array:
	    case Int32Array:
	    case Uint32Array:
	    case Float32Array:
	    case Float64Array:
	        obj_clone = new Constructor(obj);
	        break;
	    case Array:
	        obj_clone = new Constructor(obj.length);

	        for (var i = 0; i < obj.length; i++)
	            obj_clone[i] = copy_object_props_by_value(obj[i]);
	        break;
	    case WebGLUniformLocation:
	    case WebGLProgram:
	    case WebGLShader:
	        obj_clone = obj;
	        break;
	    case WebGLFramebuffer:
	    case WebGLRenderbuffer:
	    case WebGLTexture:
	    case WebGLBuffer:
	        // NOTE: update geometry will be later
	        obj_clone = null;
	        break;
	    case Function:
	        obj_clone = obj;
	        break;
	    default:
	        obj_clone = new Constructor();

	        for (var prop in obj)
	            obj_clone[prop] = copy_object_props_by_value(obj[prop]);
	        break;
	    }

	    if (textures) {
	        obj_clone.textures = textures;
	        obj.textures = textures;
	    }
	    if (texture_names) {
	        obj_clone.texture_names = texture_names;
	        obj.texture_names = texture_names;
	    }
	    if (bpy_tex_names) {
	        obj_clone.bpy_tex_names = bpy_tex_names;
	        obj.bpy_tex_names = bpy_tex_names;
	    }
	    if (shape_keys) {
	        obj_clone.shape_keys = shape_keys;
	        obj.shape_keys = shape_keys;
	    }
	    if (shader) {
	        obj_clone.shader = shader;
	        obj.shader = shader;
	    }

	    if (vaos) {
	        obj_clone.vaos = m_util.create_non_smi_array();
	        obj.vaos = vaos;
	    }

	    return obj_clone;
	}

	exports.is_dynamic = is_dynamic;
	function is_dynamic(obj) {
	    return obj.is_dynamic;
	}

	exports.is_dynamic_mesh = function(obj) {
	    return obj.type == "MESH" && obj.is_dynamic;
	};

	exports.append_scene_data = function(obj, scene) {
	    var sc_data = init_scene_data(scene);
	    obj.scenes_data.push(sc_data);
	};

	exports.append_batch = function(obj, scene, batch) {
	    var render = obj.render;
	    var sc_data = get_scene_data(obj, scene);

	    sc_data.batches.push(batch);

	    var batch_world_bounds = m_bounds.init_boundings();
	    update_world_bounds_from_batch_tsr(batch, render.world_tsr, 
	            batch_world_bounds);
	    sc_data.batch_world_bounds.push(batch_world_bounds);
	};

	exports.update_render_bounds_billboard = function(obj, obj_local_bb) {
	    var render = obj.render;
	    var x = Math.max(Math.abs(obj_local_bb.max_x), Math.abs(obj_local_bb.min_x));
	    var y = Math.max(Math.abs(obj_local_bb.max_y), Math.abs(obj_local_bb.min_y));
	    var z = Math.max(Math.abs(obj_local_bb.max_z), Math.abs(obj_local_bb.min_z));
	    var sph_rad = Math.sqrt(x * x + y * y + z * z);
	    var cyl_rad = Math.sqrt(x * x + y * y);

	    var bb_local = m_bounds.create_bb();
	    bb_local.max_x = bb_local.max_y = bb_local.max_z = sph_rad;
	    bb_local.min_x = bb_local.min_y = bb_local.min_z = -sph_rad;

	    set_box_render_bounds(render, bb_local);
	    set_sph_render_bounds(render, sph_rad, [0, 0, 0]);
	    set_ell_render_bounds(render, [1, 0, 0], [0, 1, 0], [0, 0, 1], 
	            [sph_rad, sph_rad, sph_rad], [0, 0, 0]);

	    if (is_dynamic(obj))
	        set_local_cyl_cap_cone(render, cyl_rad, cyl_rad, bb_local);
	    else
	        set_bbr_render_bounds(render, [1, 0, 0], [0, 1, 0], [0, 0, 1], 
	                [sph_rad, sph_rad, sph_rad], [0, 0, 0]);
	};

	exports.update_render_bounds_from_bpy = function(obj, obj_local_bb, bpy_bdata) {
	    var render = obj.render;
	    
	    var sph_rad = bpy_bdata["bs_rad"];
	    var cyl_rad = bpy_bdata["bc_rad"];
	    var bs_center = bpy_bdata["bs_cen"];
	    var be_center = bpy_bdata["be_cen"];

	    // use exported covariance axes for dynamic objects
	    var cov_axis_x = bpy_bdata["caxis_x"];
	    var cov_axis_y = bpy_bdata["caxis_y"];
	    var cov_axis_z = bpy_bdata["caxis_z"];
	    var be_axes = bpy_bdata["be_ax"];

	    var bbr_center = bpy_bdata["rbb"]["rbb_c"];
	    var bbr_scale = bpy_bdata["rbb"]["rbb_s"];

	    set_box_render_bounds(render, obj_local_bb);
	    set_sph_render_bounds(render, sph_rad, bs_center);

	    var obj_is_dynamic = is_dynamic(obj);
	    var be_axis_x = obj_is_dynamic ? cov_axis_x : [1, 0, 0];
	    var be_axis_y = obj_is_dynamic ? cov_axis_y : [0, 1, 0];
	    var be_axis_z = obj_is_dynamic ? cov_axis_z : [0, 0, 1];
	    set_ell_render_bounds(render, be_axis_x, be_axis_y, be_axis_z, be_axes, 
	            be_center);

	    if (is_dynamic(obj))
	        set_local_cyl_cap_cone(render, cyl_rad, cyl_rad, render.bb_local);
	    else
	        set_bbr_render_bounds(render, cov_axis_x, cov_axis_y, cov_axis_z, 
	                bbr_scale, bbr_center);
	};

	/**
	 * This algorithm has been taken from bindings.c
	 */
	exports.update_render_bounds_from_pos_arrays = function(obj, obj_local_bb, pos_arrays) {
	    var render = obj.render;
	    
	    var x_width = obj_local_bb.max_x - obj_local_bb.min_x;
	    var y_width = obj_local_bb.max_y - obj_local_bb.min_y;
	    var z_width = obj_local_bb.max_z - obj_local_bb.min_z;

	    var s_cen_x = (obj_local_bb.max_x + obj_local_bb.min_x) / 2;
	    var s_cen_y = (obj_local_bb.max_y + obj_local_bb.min_y) / 2;
	    var s_cen_z = (obj_local_bb.max_z + obj_local_bb.min_z) / 2;

	    var c_cen_x = s_cen_x;
	    var c_cen_z = s_cen_z;

	    var s_rad = Math.max(x_width, Math.max(y_width, z_width)) / 2;
	    var c_rad = Math.max(x_width, z_width) / 2;

	    var tmp_s_cen = [s_cen_x / (x_width ? x_width : 1),
	            s_cen_y / (y_width ? y_width : 1),
	            s_cen_z / (z_width ? z_width : 1)];
	    var tmp_rad = 0.5;

	    for (var i = 0; i < pos_arrays.length; i++) {
	        var pos = pos_arrays[i];

	        for (var j = 0; j < pos.length; j += 3) {
	            var x = pos[j];
	            var y = pos[j + 1];
	            var z = pos[j + 2];

	            var s_cen_dist = Math.sqrt((s_cen_x - x) * (s_cen_x - x) 
	                    + (s_cen_y - y) * (s_cen_y - y) +
	                    (s_cen_z - z) * (s_cen_z - z));

	            if (s_cen_dist > s_rad) {
	                var g_x = s_cen_x - s_rad * (x - s_cen_x) / s_cen_dist;
	                var g_y = s_cen_y - s_rad * (y - s_cen_y) / s_cen_dist;
	                var g_z = s_cen_z - s_rad * (z - s_cen_z) / s_cen_dist;

	                s_cen_x = (g_x + x) / 2;
	                s_cen_y = (g_y + y) / 2;
	                s_cen_z = (g_z + z) / 2;

	                s_rad = Math.sqrt((s_cen_x - x) * (s_cen_x - x) 
	                        + (s_cen_y - y) * (s_cen_y - y) +
	                        (s_cen_z - z) * (s_cen_z - z));
	            }

	            var c_cen_dist = Math.sqrt((c_cen_x - x) * (c_cen_x - x) 
	                        + (c_cen_z - z) * (c_cen_z - z));

	            if (c_cen_dist > c_rad) {
	                var g_x = c_cen_x - c_rad * (x - c_cen_x) / c_cen_dist;
	                var g_z = c_cen_z - c_rad * (z - c_cen_z) / c_cen_dist;

	                c_cen_x = (g_x + x) / 2;
	                c_cen_z = (g_z + z) / 2;
	                c_rad = Math.sqrt((c_cen_x - x) * (c_cen_x - x) 
	                        + (c_cen_z - z) * (c_cen_z - z));
	            }

	            x /= x_width ? x_width : 1;
	            y /= y_width ? y_width : 1;
	            z /= z_width ? z_width : 1;

	            var s_cen_tmp = Math.sqrt((tmp_s_cen[0] - x) * (tmp_s_cen[0] - x) +
	                    (tmp_s_cen[1] - y) * (tmp_s_cen[1] - y) 
	                    + (tmp_s_cen[2] - z) * (tmp_s_cen[2] - z));

	            if (s_cen_tmp > tmp_rad) {
	                var g_x = tmp_s_cen[0] - tmp_rad * (x - tmp_s_cen[0]) / s_cen_tmp;
	                var g_y = tmp_s_cen[1] - tmp_rad * (y - tmp_s_cen[1]) / s_cen_tmp;
	                var g_z = tmp_s_cen[2] - tmp_rad * (z - tmp_s_cen[2]) / s_cen_tmp;

	                tmp_s_cen[0] = (g_x + x) / 2;
	                tmp_s_cen[1] = (g_y + y) / 2;
	                tmp_s_cen[2] = (g_z + z) / 2;

	                tmp_rad = Math.sqrt((tmp_s_cen[0] - x) * (tmp_s_cen[0] - x) 
	                        + (tmp_s_cen[1] - y) * (tmp_s_cen[1] - y)
	                        + (tmp_s_cen[2] - z) * (tmp_s_cen[2] - z));
	            }
	        }
	    }

	    var e_cen_x = x_width ? x_width * tmp_s_cen[0] : obj_local_bb.max_x;
	    var e_cen_y = y_width ? y_width * tmp_s_cen[1] : obj_local_bb.max_y;
	    var e_cen_z = z_width ? z_width * tmp_s_cen[2] : obj_local_bb.max_z;

	    var e_axis_x = tmp_rad * x_width;
	    var e_axis_y = tmp_rad * y_width;
	    var e_axis_z = tmp_rad * z_width;

	    set_box_render_bounds(render, obj_local_bb);
	    set_sph_render_bounds(render, s_rad, [s_cen_x, s_cen_y, s_cen_z]);
	    set_ell_render_bounds(render, [1, 0, 0], [0, 1, 0], [0, 0, 1], 
	            [e_axis_x, e_axis_y, e_axis_z], [e_cen_x, e_cen_y, e_cen_z]);

	    if (is_dynamic(obj))
	        set_local_cyl_cap_cone(render, c_rad, c_rad, render.bb_local);
	    else {
	        var x_len = (render.bb_local.max_x - render.bb_local.min_x) / 2;
	        var y_len = (render.bb_local.max_y - render.bb_local.min_y) / 2;
	        var z_len = (render.bb_local.max_z - render.bb_local.min_z) / 2;

	        var cen_x = (render.bb_local.max_x + render.bb_local.min_x) / 2;
	        var cen_y = (render.bb_local.max_y + render.bb_local.min_y) / 2;
	        var cen_z = (render.bb_local.max_z + render.bb_local.min_z) / 2;

	        set_bbr_render_bounds(render, [x_len, 0, 0], [0, y_len, 0], 
	                [0, 0, z_len], [1, 1, 1], [cen_x, cen_y, cen_z]);
	    }
	};

	function set_box_render_bounds(render, bb_local) {
	    m_bounds.copy_bb(bb_local, render.bb_local);
	    m_bounds.bounding_box_transform(render.bb_local, render.world_tsr, 
	            render.bb_world);
	}

	function set_sph_render_bounds(render, sph_rad, bs_center) {
	    render.bs_local = m_bounds.bs_from_values(sph_rad, bs_center);
	    m_bounds.bounding_sphere_transform(render.bs_local, render.world_tsr, 
	            render.bs_world);
	}

	function set_ell_render_bounds(render, be_axis_x, be_axis_y, be_axis_z, 
	        axes_scale, be_center) {
	    render.be_local = m_bounds.be_from_values(be_axis_x, be_axis_y, be_axis_z, 
	            be_center);
	    m_vec3.scale(render.be_local.axis_x, axes_scale[0], render.be_local.axis_x);
	    m_vec3.scale(render.be_local.axis_y, axes_scale[1], render.be_local.axis_y);
	    m_vec3.scale(render.be_local.axis_z, axes_scale[2], render.be_local.axis_z);
	    m_bounds.bounding_ellipsoid_transform(render.be_local, render.world_tsr, 
	            render.be_world);
	}

	function set_local_cyl_cap_cone(render, cyl_radius, cap_radius, bb_local) {
	    render.bcyl_local = m_bounds.bcyl_from_values(cyl_radius, bb_local);
	    render.bcap_local = m_bounds.bcap_from_values(cap_radius, bb_local);
	    render.bcon_local = m_bounds.bcon_from_values(cyl_radius, bb_local);
	}

	function set_bbr_render_bounds(render, bbr_axis_x, bbr_axis_y, bbr_axis_z, 
	        axes_scale, bbr_center) {
	    render.bbr_local = m_bounds.rot_bb_from_values(bbr_center, bbr_axis_x, 
	            bbr_axis_y, bbr_axis_z, axes_scale);
	    m_bounds.bounding_rot_box_transform(render.bbr_local, render.world_tsr, 
	            render.bbr_world);
	}

	exports.update_world_bounds_from_batch_tsr = update_world_bounds_from_batch_tsr;
	function update_world_bounds_from_batch_tsr(batch, tsr, world_bounds) {
	    m_bounds.bounding_box_transform(batch.bounds_local.bb, tsr, world_bounds.bb);
	    if (batch.use_be)
	        m_bounds.bounding_ellipsoid_transform(batch.bounds_local.be, tsr, 
	                world_bounds.be);
	    m_bounds.bounding_sphere_transform(batch.bounds_local.bs, tsr, world_bounds.bs);
	}

	exports.remove_scene_data = function(obj, scene) {
	    var scenes_data = obj.scenes_data;
	    for (var i = 0; i < scenes_data.length; i++) {
	        var sc_data = scenes_data[i];
	        if (sc_data.scene == scene) {
	            scenes_data.splice(i,1);
	            break;
	        }
	    }
	};

	exports.get_scene_data = get_scene_data;
	function get_scene_data(obj, scene) {
	    var scenes_data = obj.scenes_data;
	    for (var i = 0; i < scenes_data.length; i++) {
	        var sc_data = scenes_data[i];
	        if (sc_data.scene == scene)
	            return sc_data;
	    }
	    return null;
	}

	exports.update_refl_objects = function (objects, reflection_plane) {
	    for (var i = 0; i < objects.length; i++) {
	        m_vec4.copy(reflection_plane,
	                    objects[i].render.reflection_plane);
	    }
	};

	exports.scene_data_set_active = function(obj, flag, scene) {
	    for (var i = 0; i < obj.scenes_data.length; i++) {
	        var sc_data = obj.scenes_data[i];
	        // undefined scene means that all scenes will be processed
	        if (!scene || sc_data.scene == scene)
	            sc_data.is_active = flag;
	    }
	};

	exports.scene_data_remove_batch = function(scene_data, batch_index) {
	    scene_data.batches.splice(batch_index, 1);
	    scene_data.batch_world_bounds.splice(batch_index, 1);
	};

	exports.get_shadow_lamps = function(lamps, use_ssao) {
	    var shadow_lamps = [];
	    var max_shadow_lamps_num = use_ssao ? cfg_def.max_cast_lamps - 1 :
	            cfg_def.max_cast_lamps;
	    for (var i = 0; i < lamps.length; i++) {
	        var lamp = lamps[i];
	        if (lamp.light.generate_shadows && shadow_lamps.length < max_shadow_lamps_num)
	            shadow_lamps.push(lamp);
	    }

	    if (shadow_lamps.length)
	        return shadow_lamps;
	    else if (lamps[0])
	        return [lamps[0]];
	    else
	        return [];
	};

	exports.meta_obj_append_render = function(meta_obj, render) {
	    // NOTE: meta_obj is always STATIC and has zero world_tsr, it's especially
	    // important for physics and alpha-sorting
	    m_tsr.identity(render.world_tsr);
	    render.color_id = null;
	    meta_obj.render = render;
	};

	exports.check_obj_soft_particles_accessibility = function(obj, pset) {

	    if (pset["b4w_enable_soft_particles"] &&
	            pset["b4w_particles_softness"] > 0.0) {
	        var index = pset["material"] - 1;
	        var materials = obj.materials;
	        if (index >= 0 && index < materials.length &&
	            (materials[index].blend_mode == "ADD" ||
	            materials[index].blend_mode == "ALPHA" ||
	            materials[index].blend_mode == "ALPHA_SORT"))
	            return true;
	    }

	    return false;
	};

	exports.check_inv_zup_tsr_is_needed = function(obj) {
	    var scenes_data = obj.scenes_data;
	    for (var i = 0; i < scenes_data.length; i++) {
	        var batches = scenes_data[i].batches;
	        for (var j = 0; j < batches.length; j++) {
	            var dirs = batches[j].shaders_info.directives;
	            for (var k = 0; k < dirs.length; k++) {
	                var dir = dirs[k];
	                if (dir[0] == "USE_MODEL_TSR_INVERSE" && dir[1] == "1")
	                    return true;
	            }
	       }
	    }

	    return false;
	};

	exports.gen_dupli_name = function(dg_parent_name, name) {
	    return dg_parent_name + "*" + name;
	};

	exports.get_parent = function(obj) {
	    return !obj.parent_is_dupli ? obj.parent : null;
	};

	exports.get_dg_parent = get_dg_parent;
	function get_dg_parent(obj) {
	    if (obj.parent_is_dupli)
	        return obj.parent;
	    else if (obj.parent)
	        return get_dg_parent(obj.parent);
	    else
	        return null;
	}

	exports.get_dg_objects = function(dg_parent, objects) {
	    var dg_objs = [];
	    for (var i = 0; i < objects.length; i++) {
	        var obj = objects[i];
	        if (get_dg_parent(obj) == dg_parent)
	            dg_objs.push(obj);
	    }
	    return dg_objs;
	};

	exports.get_object_data_id = function(obj) {
	    return obj.render.data_id;
	};

	exports.is_mesh = function(obj) {
	    return obj.type === "MESH";
	};

	exports.is_armature = function(obj) {
	    return obj.type === "ARMATURE";
	};

	exports.is_speaker = function(obj) {
	    return obj.type === "SPEAKER";
	};

	exports.is_camera = function(obj) {
	    return obj.type === "CAMERA";
	};

	exports.is_lamp = function(obj) {
	    return obj.type === "LAMP";
	};

	exports.is_empty = function(obj) {
	    return obj.type === "EMPTY";
	};

	exports.is_line = function(obj) {
	    return obj.type === "LINE";
	};

	exports.is_world = function(obj) {
	    return obj.type === "WORLD";
	};

	}

	var int_obj_util_factory = register("__obj_util", Int_obj_util);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Particles internal API.
	 * External API implemented in animation.js module.
	 * @name particles
	 * @namespace
	 * @exports exports as particles
	 */
	function Int_particles(ns, exports) {

	var m_cfg    = int_config_factory(ns);
	var m_batch  = int_batch_factory(ns);
	var m_geom   = int_geometry_factory(ns);
	var m_tbn    = int_tbn_factory(ns);
	var m_tex    = int_textures_factory(ns);
	var m_time   = int_time_factory(ns);
	var m_tsr    = int_tsr_factory(ns);
	var m_util   = int_util_factory(ns);
	var m_vec3   = vec3_factory(ns);

	var STDGRAVITY = 9.81;
	var DELAYRANDFACTOR = 10;

	var cfg_def = m_cfg.defaults;

	var _tbn_tmp = m_tbn.create();
	var _tsr_tmp = new Float32Array(8);
	var _vec3_tmp = new Float32Array(3);

	var _particles_objs_cache = [];

	function init_particles_data(name, type) {
	    var pdata = {
	        name: name,
	        p_type: type,

	        time: 0,
	        prev_time: -1,
	        use_world_space: false,
	        count_factor: 1,

	        frame_start: 0,
	        frame_end: 0,
	        time_length: 0,
	        lifetime_frames: 0,
	        lifetime: 0,
	        // bool
	        cyclic: 0,

	        mass: 0,
	        nfactor: 0,
	        gravity: 0,
	        fade_in: 0,
	        fade_out: 0,
	        wind_factor: 0,

	        size: 0,
	        alpha_start: 0,
	        alpha_end: 0,
	        color_ramp_length: 0,
	        color_ramp: new Float32Array(16),

	        need_buffers_update: false,

	        positions: null,
	        positions_cache: null,
	        tbn: null,
	        tbn_cache: null,
	        delay_attrs: null,
	        delay_attrs_masked: null,
	        emitter_tsr_snapshots: null,
	        p_data: null,

	        tilt: 0,
	        tilt_rand: 0
	    };

	    return pdata;
	}

	exports.clone_particles_data = clone_particles_data;
	function clone_particles_data(particles_data) {

	    var particles_data_new = init_particles_data(particles_data.name, 
	            particles_data.type);

	    particles_data_new.time = particles_data.time;
	    particles_data_new.prev_time = particles_data.prev_time;
	    particles_data_new.use_world_space = particles_data.use_world_space;
	    particles_data_new.count_factor = particles_data.count_factor;

	    particles_data_new.frame_start = particles_data.frame_start;
	    particles_data_new.frame_end = particles_data.frame_end;
	    particles_data_new.time_length = particles_data.time_length;
	    particles_data_new.lifetime_frames = particles_data.lifetime_frames;
	    particles_data_new.lifetime = particles_data.lifetime;
	    particles_data_new.cyclic = particles_data.cyclic;

	    particles_data_new.mass = particles_data.mass;
	    particles_data_new.nfactor = particles_data.nfactor;
	    particles_data_new.gravity = particles_data.gravity;
	    particles_data_new.fade_in = particles_data.fade_in;
	    particles_data_new.fade_out = particles_data.fade_out;
	    particles_data_new.wind_factor = particles_data.wind_factor;

	    particles_data_new.size = particles_data.size;
	    particles_data_new.alpha_start = particles_data.alpha_start;
	    particles_data_new.alpha_end = particles_data.alpha_end;
	    particles_data_new.color_ramp_length = particles_data.color_ramp_length;
	    particles_data_new.color_ramp.set(particles_data.color_ramp);

	    particles_data_new.need_buffers_update = particles_data.need_buffers_update;

	    particles_data_new.positions = m_util.clone_object_r(particles_data.positions);
	    particles_data_new.positions_cache = m_util.clone_object_r(
	            particles_data.positions_cache);
	    particles_data_new.tbn = m_util.clone_object_r(particles_data.tbn);
	    particles_data_new.tbn_cache = m_util.clone_object_r(particles_data.tbn_cache);
	    particles_data_new.delay_attrs = m_util.clone_object_r(particles_data.delay_attrs);
	    particles_data_new.delay_attrs_masked = m_util.clone_object_r(
	            particles_data.delay_attrs_masked);
	    particles_data_new.emitter_tsr_snapshots = m_util.clone_object_r(
	            particles_data.emitter_tsr_snapshots);
	    particles_data_new.p_data = m_util.clone_object_r(particles_data.p_data);

	    particles_data_new.tilt = particles_data.tilt;
	    particles_data_new.tilt_rand = particles_data.tilt_rand;

	    return particles_data_new;
	}

	var _rand = function() {
	    m_util.panic("_rand() undefined");
	};

	exports.update = function() {
	    for (var i = 0; i < _particles_objs_cache.length; i++) {
	        var obj = _particles_objs_cache[i];
	        var scenes_data = obj.scenes_data;
	        for (var j = 0; j < scenes_data.length; j++) {
	            var sc_data = scenes_data[j];
	            var batches = sc_data.batches;
	            //TODO: need to track every particle independently
	            update_emitter_transform(obj, batches);
	        }
	    }
	};

	exports.obj_has_particles = function(obj) {
	    var scenes_data = obj.scenes_data;
	    for (var i = 0; i < scenes_data.length; i++) {
	        var batches = scenes_data[i].batches;
	        for (var j = 0; j < batches.length; j++)
	            if (batches[j].particles_data)
	                return true;
	    }

	    return false;
	};

	exports.obj_has_psys = function(obj, psys_name) {
	    var scenes_data = obj.scenes_data;
	    for (var i = 0; i < scenes_data.length; i++) {
	        var batches = scenes_data[i].batches;
	        for (var j = 0; j < batches.length; j++) {
	            var pdata = batches[j].particles_data;
	            if (pdata && pdata.name == psys_name)
	                return true;
	        }
	    }

	    return false;
	};

	/**
	 * Check if object has animated particle system (of type EMITTER)
	 */
	exports.obj_has_anim_particles = function(obj) {
	    var scenes_data = obj.scenes_data;
	    for (var i = 0; i < scenes_data.length; i++) {
	        var batches = scenes_data[i].batches;
	        for (var j = 0; j < batches.length; j++) {
	            var pdata = batches[j].particles_data;
	            if (pdata && pdata.p_type == "EMITTER")
	                return true;
	        }
	    }

	    return false;
	};

	exports.bpy_obj_has_particles = function(bpy_obj) {
	    return bpy_obj["particle_systems"].length > 0;
	};

	/**
	 * Check if object has animated particle system (of type EMITTER)
	 */
	exports.bpy_obj_has_anim_particles = function(bpy_obj) {
	    for (var i = 0; i < bpy_obj["particle_systems"].length; i++) {
	        var psettings = bpy_obj["particle_systems"][i]["settings"];
	        if (psettings["type"] == "EMITTER")
	            return true;
	    }

	    return false;
	};

	exports.has_dynamic_grass_particles = function(bpy_obj) {
	    for (var i = 0; i < bpy_obj["particle_systems"].length; i++) {
	        var psettings = bpy_obj["particle_systems"][i]["settings"];
	        if (psettings["type"] == "HAIR" && psettings["b4w_dynamic_grass"]) {
	            return true;
	        }
	    }

	    return false;
	};

	exports.create_particles_data = function(batch, psystem, pmaterial) {
	    var pdata = batch.particles_data = init_particles_data(psystem["name"],
	            psystem["settings"]["type"]);
	    pdata.frame_start = psystem["settings"]["frame_start"];
	    pdata.frame_end = psystem["settings"]["frame_end"];
	    pdata.time_length = (pdata.frame_end - pdata.frame_start) / m_time.get_framerate();
	    pdata.lifetime_frames = psystem["settings"]["lifetime"];
	    pdata.lifetime = pdata.lifetime_frames / m_time.get_framerate();
	    pdata.cyclic = psystem["settings"]["b4w_cyclic"] ? 1 : 0;

	    pdata.mass = psystem["settings"]["mass"];
	    pdata.nfactor = psystem["settings"]["normal_factor"];
	    pdata.gravity = psystem["settings"]["effector_weights"]["gravity"] * STDGRAVITY;
	    pdata.fade_in = psystem["settings"]["b4w_fade_in"] /m_time.get_framerate();
	    pdata.fade_out = psystem["settings"]["b4w_fade_out"] /m_time.get_framerate();
	    pdata.wind_factor = psystem["settings"]["effector_weights"]["wind"];

	    pdata.use_world_space =
	            psystem["settings"]["b4w_coordinate_system"] == "WORLD"? true: false;

	    var size;
	    var alpha_start;
	    var alpha_end;
	    if (batch.halo_particles) {
	        size = pmaterial.halo_settings.size;

	        var hardness = pmaterial.halo_settings.hardness;

	        // default 50
	        if (hardness < 30) {
	            alpha_start = 0.5;
	            alpha_end = 0.9;
	        } else if (hardness < 40) {
	            alpha_start = 0.1;
	            alpha_end = 1.0;
	        } else if (hardness < 50) {
	            alpha_start = 0.0;
	            alpha_end = 0.8;
	        } else {
	            alpha_start = 0.0;
	            alpha_end = 0.5;
	        }
	    } else {
	        size = psystem["settings"]["particle_size"];
	        alpha_start = 1.0;
	        alpha_end = 1.0;
	    }
	    pdata.size = size;
	    pdata.alpha_start = alpha_start;
	    pdata.alpha_end = alpha_end;

	    if (pmaterial.use_nodes && psystem["settings"]["render_type"] == "BILLBOARD") {
	        m_batch.set_batch_directive(batch, "NODES", 1);
	        m_batch.set_batch_directive(batch, "PARTICLE_BATCH", 1);
	        batch.has_nodes = true;
	    }

	    /** size ramp */
	    var tex_slot = psystem["settings"]["texture_slots"];

	    if (tex_slot[0] && tex_slot[0]["use_map_size"] && tex_slot[0]["texture"] &&
	            tex_slot[0]["texture"]["type"] == "BLEND" &&
	            tex_slot[0]["texture"]["use_color_ramp"] &&
	            cfg_def.allow_vertex_textures) {
	        var bpy_tex = tex_slot[0]["texture"];
	        var image_data = [];
	        m_tex.calc_color_ramp_data(bpy_tex["color_ramp"],
	                m_tex.PART_COLORRAMP_TEXT_SIZE, image_data);
	        image_data = new Uint8Array(image_data.map(function(val) {return m_util.clamp(val * 255,
	            0, 255)}));

	        var tex = m_tex.create_color_ramp_texture(image_data, m_tex.PART_COLORRAMP_TEXT_SIZE);

	        m_batch.append_texture(batch, tex, "u_color_ramp_tex", bpy_tex["name"]);
	        m_batch.set_batch_directive(batch, "USE_COLOR_RAMP", 1);
	    }

	    /** color ramp */
	    var m_tex_slot = pmaterial.texture_slots;
	    var cramp_varr = [-1,0,0,0,
	                     -1,0,0,0,
	                     -1,0,0,0,
	                     -1,0,0,0];

	    if (m_tex_slot[0] && m_tex_slot[0]["texture_coords"] == "STRAND" &&
	            m_tex_slot[0]["texture"] &&
	            m_tex_slot[0]["texture"]["type"] == "BLEND" &&
	            m_tex_slot[0]["texture"]["use_color_ramp"]) {

	        var color_ramp_elems = m_tex_slot[0]["texture"]["color_ramp"]["elements"];
	        var rlen = Math.min(color_ramp_elems.length*4, cramp_varr.length);
	        for (var i = 0; i < rlen; i+=4) {
	            var rel = color_ramp_elems[i/4];

	            cramp_varr[i] = rel["position"];
	            cramp_varr[i+1] = rel["color"][0];
	            cramp_varr[i+2] = rel["color"][1];
	            cramp_varr[i+3] = rel["color"][2];
	        }

	        pdata.color_ramp_length = color_ramp_elems.length;
	    }
	    pdata.color_ramp.set(cramp_varr);
	};

	/**
	 * Generate buffers for batch, emitter mesh, particle system and material
	 * process particle from each emitter vertex
	 */
	exports.generate_emitter_particles_submesh = function(batch, emitter_mesh,
	        psystem, render) {

	    var pdata = batch.particles_data;
	    var tsr = render.world_tsr;

	    var pcount = psystem["settings"]["count"];
	    var time_start = psystem["settings"]["frame_start"] / m_time.get_framerate();
	    var time_end = psystem["settings"]["frame_end"] / m_time.get_framerate();
	    var lifetime = psystem["settings"]["lifetime"] / m_time.get_framerate();
	    var lifetime_random = psystem["settings"]["lifetime_random"];
	    var emit_from = psystem["settings"]["emit_from"];
	    var vel_factor_rand = psystem["settings"]["factor_random"];

	    if (psystem["settings"]["use_rotations"]) {
	        var ang_vel_mode = psystem["settings"]["angular_velocity_mode"];
	        var ang_vel_factor = psystem["settings"]["angular_velocity_factor"];
	    } else {
	        var ang_vel_mode = "NONE";
	        var ang_vel_factor = 0;
	    }

	    var is_rand_delay = psystem["settings"]["b4w_randomize_emission"];
	    var cyclic = psystem["settings"]["b4w_cyclic"];
	    
	    pdata.tilt = psystem["settings"]["billboard_tilt"];
	    pdata.tilt_rand = psystem["settings"]["billboard_tilt_random"];

	    init_particle_rand(psystem["seed"]);

	    var emitter_submesh = m_geom.extract_submesh_all_mats(emitter_mesh,
	            ["a_position", "a_tbn"], null, render);

	    var pos_tbn = distribute_positions_tbn(pcount, emit_from,
	            emitter_submesh);
	    var positions = pos_tbn[0];
	    var tbn = pos_tbn[1];

	    pdata.positions = new Float32Array(positions);
	    pdata.tbn = new Float32Array(tbn);
	    pdata.positions_cache = new Float32Array(positions.length);
	    pdata.tbn_cache = new Float32Array(tbn.length);

	    var delay_attrs = gen_delay_attrs(pcount, time_start, time_end,
	                                      is_rand_delay, cyclic);
	    pdata.delay_attrs = new Float32Array(delay_attrs);
	    // needed to restore original delays when using particles number factor
	    pdata.delay_attrs_masked = new Float32Array(delay_attrs);

	    if (pdata.use_world_space) {
	        pdata.emitter_tsr_snapshots = new Float32Array(delay_attrs.length * 8);
	        for (var i = 0; i < delay_attrs.length * 8; i++)
	            for (var j = 0; j < 8; j++)
	                pdata.emitter_tsr_snapshots[8 * i + j] = tsr[j];

	        pose_emitter_world(pdata, positions, tbn, tsr, positions, tbn);
	    }

	    var submesh = m_geom.init_submesh("EMITTER_PARTICLES");
	    var va_frame = m_util.create_empty_va_frame();
	    va_frame["a_position"] = positions;
	    va_frame["a_tbn"] = tbn;
	    submesh.va_frames[0] = va_frame;

	    batch.draw_mode = m_geom.DM_DYNAMIC_TRIANGLES;
	    submesh.indices = gen_bb_indices(pcount);
	    submesh.va_common["a_p_bb_vertex"] = m_geom.gen_bb_vertices(pcount);

	    submesh.base_length = positions.length/3;
	    var larr = gen_lifetimes(pcount, lifetime, lifetime_random);
	    submesh.va_common["a_p_data"] = gen_part_data(pcount, larr, delay_attrs);
	    submesh.va_common["a_p_vels"] =
	            gen_velocities(pcount, vel_factor_rand, ang_vel_mode,
	            ang_vel_factor);
	    pdata.p_data = new Float32Array(submesh.va_common["a_p_data"]);

	    return submesh;
	};

	/**
	 * Recalculate particles position/tbn in world space.
	 */
	function pose_emitter_world(pdata, positions, tbn, tsr,
	                            positions_new, tbn_new) {

	    var delay_attrs = pdata.delay_attrs;
	    var em_snapshots = pdata.emitter_tsr_snapshots;
	    var time = pdata.time;
	    var prev_time = pdata.prev_time;

	    var step = 4;

	    for (var j = 0; j < delay_attrs.length; j+=step) {
	        var delay = delay_attrs[j];

	        // looped timing
	        var need_emitter_pos = (time > prev_time && time >= delay && delay > prev_time)
	                || (time < prev_time && (delay > prev_time || time >= delay));

	        if (need_emitter_pos)
	            for (var k = 0; k < 8; k++) {
	                em_snapshots[8 * j + k]  = tsr[k];
	                _tsr_tmp[k] = tsr[k];
	            }
	        else
	            for (var k = 0; k < 8; k++)
	                _tsr_tmp[k] = em_snapshots[8 * j + k];

	        // positions
	        var pos = _vec3_tmp;
	        pos[0] = positions[3 * j];
	        pos[1] = positions[3 * j + 1];
	        pos[2] = positions[3 * j + 2];

	        m_tsr.transform_vec3(pos, _tsr_tmp, pos);

	        positions_new[3 * j]     = pos[0];
	        positions_new[3 * j + 1] = pos[1];
	        positions_new[3 * j + 2] = pos[2];

	        var cur_tbn = m_tbn.get_item(tbn, j, _tbn_tmp);

	        m_tbn.multiply_tsr(cur_tbn, _tsr_tmp, cur_tbn);

	        m_tbn.set_item(tbn_new, cur_tbn, j);

	        // same transform for the rest corners (billboard)
	        for (var k = 1; k < 4; k++) {
	            positions_new[3 * (j + k)]     = positions_new[3 * j];
	            positions_new[3 * (j + k) + 1] = positions_new[3 * j + 1];
	            positions_new[3 * (j + k) + 2] = positions_new[3 * j + 2];

	            m_tbn.set_item(tbn_new, cur_tbn, j + k);
	        }
	    }
	}

	function update_emitter_transform(obj, batches) {
	    for (var i = 0; i < batches.length; i++) {
	        var batch = batches[i];
	        var pdata = batch.particles_data;

	        if (!pdata || !pdata.use_world_space || batch.forked_batch)
	            continue;

	        var pcache = pdata.positions_cache;
	        var tbncache = pdata.tbn_cache;

	        var positions = pdata.positions;
	        var tbn = pdata.tbn;

	        pose_emitter_world(pdata, positions, tbn,
	                obj.render.world_tsr, pcache, tbncache);

	        pdata.need_buffers_update = true;
	    }
	}

	/**
	 * Initialize random number generator
	 *
	 * seed > 0 - use our random function (seed-deterministic behaviour)
	 * seed == 0 or undefined - use internal javascript random function
	 */
	function init_particle_rand(seed) {
	    if (seed) {
	        m_util.srand(seed);
	        _rand = function() {
	            return m_util.rand();
	        };
	    } else {
	        _rand = function() {
	            return Math.random();
	        };
	    }
	}

	function gen_bb_indices(pcount) {
	    var bbi = [];

	    for (var i = 0; i < pcount; i++) {
	        // CCW ?
	        bbi.push(4*i,4*i+2,4*i+1, 4*i,4*i+3,4*i+2);
	    }

	    var bb_indices = new Uint16Array(bbi);
	    return bb_indices;
	}

	function distribute_positions_tbn(pcount, emit_from, emitter_submesh) {
	    switch (emit_from) {
	    case "VERT":

	        var ecoords = emitter_submesh.va_frames[0]["a_position"];
	        var etbncoords = emitter_submesh.va_frames[0]["a_tbn"];

	        var pindices = gen_pindices(pcount, ecoords);
	        var positions = gen_positions(pindices, ecoords);
	        var tbn = gen_tbn(pindices, etbncoords);
	        break;
	    case "FACE":
	        var positions = [];
	        var tbn = [];

	        // TODO: get seed from particle system
	        var seed = [];
	        m_util.init_rand_r_seed(0, seed);
	        var rand_pos = m_geom.geometry_random_points(emitter_submesh, pcount, false, seed);
	        m_util.init_rand_r_seed(0, seed);
	        var rand_tbn = m_geom.geometry_random_points(emitter_submesh, pcount, true, seed);

	        tbn = m_tbn.create(rand_pos.length * 4);

	        for (var i = 0; i < rand_pos.length; i++) {

	            positions.push(rand_pos[i][0], rand_pos[i][1], rand_pos[i][2]);
	            positions.push(rand_pos[i][0], rand_pos[i][1], rand_pos[i][2]);
	            positions.push(rand_pos[i][0], rand_pos[i][1], rand_pos[i][2]);
	            positions.push(rand_pos[i][0], rand_pos[i][1], rand_pos[i][2]);

	            m_tbn.set_item(tbn, rand_tbn[i], 4 * i);
	            m_tbn.set_item(tbn, rand_tbn[i], 4 * i + 1);
	            m_tbn.set_item(tbn, rand_tbn[i], 4 * i + 2);
	            m_tbn.set_item(tbn, rand_tbn[i], 4 * i + 3);
	        }

	        positions = new Float32Array(positions);

	        break;
	    case "VOLUME":
	        m_util.panic("Particle emission from volume is not supported");
	        break;
	    default:
	        m_util.panic("Wrong emit from option");
	        break;
	    }

	    return [positions, tbn];
	}

	/**
	 * Generate particle indices for emitter vertex coordinates and normals
	 * pcount - total number of particles
	 * ecoords - possible locations (coordinates of emitter mesh vertices)
	 */
	function gen_pindices(pcount, ecoords) {
	    var vcount = ecoords.length/3;
	    var indices = [];

	    for (var i = 0; i < pcount; i++) {

	        /* get random vertex of emitter */
	        var vrand = Math.round((vcount - 1) * _rand());
	        indices.push(vrand);
	        indices.push(vrand);
	        indices.push(vrand);
	        indices.push(vrand);
	    }
	    return indices;
	}

	function gen_positions(indices, ecoords) {

	    var parr = [];

	    for (var i = 0; i < indices.length; i++) {

	        parr.push(ecoords[3*indices[i]]);
	        parr.push(ecoords[3*indices[i] + 1]);
	        parr.push(ecoords[3*indices[i] + 2]);
	    }

	    var positions = new Float32Array(parr);
	    return positions;
	}

	function gen_tbn(indices, etbncoords) {
	    var tbn = m_tbn.create(indices.length);

	    for (var i = 0; i < indices.length; i++) {
	        var cur_tbn = m_tbn.get_item(etbncoords, indices[i], _tbn_tmp);
	        m_tbn.set_item(tbn, cur_tbn, i);
	    }

	    return tbn;
	}

	function gen_delay_attrs(pcount, mindelay, maxdelay, random, cyclic) {
	    var darr = [];
	    var delayint = (maxdelay - mindelay)/pcount;

	    for (var i = 0; i < pcount; i++) {

	        var delay;
	        if (random) {
	            delay = delayint*i + DELAYRANDFACTOR * delayint * (0.5-_rand());
	        } else
	            delay = delayint*i;

	        if (!cyclic)
	            delay += mindelay;

	        darr.push(delay);
	        darr.push(delay);
	        darr.push(delay);
	        darr.push(delay);
	    }

	    var delay_attrs = new Float32Array(darr);

	    return delay_attrs;
	}

	function gen_lifetimes(pcount, lifetime, lifetime_random) {
	    var larr = [];
	    var delta = lifetime * lifetime_random;

	    for (var i = 0; i < pcount; i++) {

	        var delta_rand = delta*_rand();
	        larr.push(lifetime - delta_rand);
	        larr.push(lifetime - delta_rand);
	        larr.push(lifetime - delta_rand);
	        larr.push(lifetime - delta_rand);
	    }

	    return larr;
	}

	function gen_part_data(pcount, lifetimes, delay_attrs) {
	    var data = [];

	    for (var i = 0; i < pcount; i++) {
	        var random = Math.random();
	        data.push(lifetimes[i * 4], delay_attrs[i * 4], random);
	        data.push(lifetimes[i * 4 + 1], delay_attrs[i * 4 + 1], random);
	        data.push(lifetimes[i * 4 + 2], delay_attrs[i * 4 + 2], random);
	        data.push(lifetimes[i * 4 + 3], delay_attrs[i * 4 + 3], random);
	    }

	    return new Float32Array(data);
	}

	/**
	 * Generate array of particles'es linear and angular speed
	 * vec4(linear_x, linear_y, linear_z, angular)
	 */
	function gen_velocities(pcount, vel_factor_rand, ang_vel_mode, ang_vel_factor) {
	    var varr = [];
	    for (var i = 0; i < pcount; i++) {

	        var vvec = [_rand() - 0.5, _rand() - 0.5, _rand() - 0.5];
	        m_vec3.normalize(vvec, vvec);

	        varr.push(vel_factor_rand * vvec[0]);
	        varr.push(vel_factor_rand * vvec[1]);
	        varr.push(vel_factor_rand * vvec[2]);

	        switch(ang_vel_mode) {
	        case "NONE":
	            varr.push(0.0);
	            break;
	        // NOTE: "SPIN" renamed to "VELOCITY" in blender 2.63
	        case "SPIN":
	        case "VELOCITY":
	            varr.push(ang_vel_factor);
	            break;
	        case "RAND":
	            varr.push(ang_vel_factor*2*(_rand() - 0.5));
	            break;
	        default:
	            m_util.panic("Undefined velocity factor");
	        }

	        var last = varr.slice(-4);
	        for (var j = 0; j < 12; j++) {
	            varr.push(last[j % 4]);
	        }
	    }

	    var vels = new Float32Array(varr);
	    return vels;

	}

	exports.set_time = function(obj, psys_name, time) {
	    var scenes_data = obj.scenes_data;
	    for (var i = 0; i < scenes_data.length; i++) {
	        var batches = scenes_data[i].batches;
	        for (var j = 0; j < batches.length; j++) {
	            var pdata = batches[j].particles_data;

	            if (!pdata || pdata.name != psys_name || batches[j].forked_batch)
	                continue;

	            pdata.prev_time = pdata.time;
	            pdata.time = time;
	        }
	    }
	};

	/**
	 * Prepare buffer for lens flare
	 */
	exports.prepare_lens_flares = function(submesh) {

	    var base_length = submesh.base_length;
	    var sub_pos = submesh.va_frames[0]["a_position"];

	    var bb_dist_arr = [];
	    var bb_vert_arr = [];

	    for (var i = 0; i < base_length; i++) {

	        bb_vert_arr.push(sub_pos[3*i]);
	        bb_dist_arr.push(sub_pos[3*i + 1]);
	        bb_vert_arr.push(sub_pos[3*i + 2]);
	    }

	    bb_dist_arr = new Float32Array(bb_dist_arr);
	    bb_vert_arr = new Float32Array(bb_vert_arr);

	    submesh.va_common["a_lf_dist"] = bb_dist_arr;
	    submesh.va_common["a_lf_bb_vertex"] = bb_vert_arr;

	    return submesh;
	};

	exports.set_size = function(obj, psys_name, size) {
	    var scenes_data = obj.scenes_data;
	    for (var i = 0; i < scenes_data.length; i++) {
	        var batches = scenes_data[i].batches;
	        for (var j = 0; j < batches.length; j++) {
	            var pdata = batches[j].particles_data;

	            if (!pdata || pdata.name != psys_name)
	                continue;

	            pdata.size = size;
	        }
	    }
	};

	exports.set_normal_factor = function(obj, psys_name, nfactor) {
	    var scenes_data = obj.scenes_data;
	    for (var i = 0; i < scenes_data.length; i++) {
	        var batches = scenes_data[i].batches;
	        for (var j = 0; j < batches.length; j++) {
	            var pdata = batches[j].particles_data;

	            if (!pdata || pdata.name != psys_name)
	                continue;

	            pdata.nfactor = nfactor;
	        }
	    }
	};

	exports.get_normal_factor = function(obj, psys_name) {
	    var scenes_data = obj.scenes_data;
	    for (var i = 0; i < scenes_data.length; i++) {
	        var batches = scenes_data[i].batches;
	        for (var j = 0; j < batches.length; j++) {
	            var pdata = batches[j].particles_data;

	            if (!pdata || pdata.name != psys_name)
	                continue;

	            return pdata.nfactor;
	        }
	    }

	    return 0;
	};

	exports.set_factor = function(obj, psys_name, factor) {
	    var scenes_data = obj.scenes_data;
	    for (var i = 0; i < scenes_data.length; i++) {
	        var batches = scenes_data[i].batches;
	        for (var j = 0; j < batches.length; j++) {
	            var batch = batches[j];
	            var pdata = batch.particles_data;

	            if (!pdata || pdata.name != psys_name)
	                continue;

	            pdata.count_factor = factor;

	            var delay_attrs = pdata.delay_attrs;

	            if (factor == 1)
	                var delay_attrs_masked = delay_attrs;

	            else if (factor == 0) {
	                var inc = 4;
	                var delay_attrs_masked = pdata.delay_attrs_masked;

	                for (var k = 0; k < delay_attrs_masked.length; k+=inc) {
	                    delay_attrs_masked[k] = 10000;
	                    delay_attrs_masked[k+1] = delay_attrs_masked[k];
	                    delay_attrs_masked[k+2] = delay_attrs_masked[k];
	                    delay_attrs_masked[k+3] = delay_attrs_masked[k];
	                }
	            } else {
	                var step = 4 / factor;
	                var delay_attrs_masked = pdata.delay_attrs_masked;

	                 var ind = 0;
	                for (var k = 0; k < delay_attrs_masked.length; k+=4) {
	                    if (k >= ind) {
	                        delay_attrs_masked[k] = delay_attrs[k];
	                        ind += step;
	                    } else
	                        delay_attrs_masked[k] = 10000;

	                    delay_attrs_masked[k+1] = delay_attrs_masked[k];
	                    delay_attrs_masked[k+2] = delay_attrs_masked[k];
	                    delay_attrs_masked[k+3] = delay_attrs_masked[k];
	                }
	            }
	            var pbuf = batch.bufs_data;
	            var pointers = pbuf.pointers;
	            var pointer = pointers["a_p_data"];
	            if (pointer) {
	                var p_data = pdata.p_data;
	                for (var k = 0; k < p_data.length; k=k+3)
	                    p_data[k + 1] = delay_attrs_masked[Math.round(k / 3)];
	                m_geom.update_bufs_data_array(pbuf, "a_p_data", 3, p_data);
	            }
	        }
	    }
	};

	exports.update_start_pos = function(obj, trans, quats) {
	    var scenes_data = obj.scenes_data;
	    for (var i = 0; i < scenes_data.length; i++) {
	        var batches = scenes_data[i].batches;
	        for (var j = 0; j < batches.length; j++) {
	            var pdata = batches[j].particles_data;
	            if (!pdata || !pdata.use_world_space)
	                continue;

	            for (var k = 0; k < pdata.delay_attrs.length * 8; k++) {
	                pdata.emitter_tsr_snapshots[8 * k] = trans[0];
	                pdata.emitter_tsr_snapshots[8 * k + 1] = trans[1];
	                pdata.emitter_tsr_snapshots[8 * k + 2] = trans[2];
	                pdata.emitter_tsr_snapshots[8 * k + 3] = trans[3];
	                pdata.emitter_tsr_snapshots[8 * k + 4] = quats[0];
	                pdata.emitter_tsr_snapshots[8 * k + 5] = quats[1];
	                pdata.emitter_tsr_snapshots[8 * k + 6] = quats[2];
	                pdata.emitter_tsr_snapshots[8 * k + 7] = quats[3];
	            }
	        }
	    }
	};

	exports.update_particles_submesh = function(submesh, batch, pcount) {

	    submesh.va_common["a_tbn"] = m_tbn.create(4 * pcount);
	    m_tbn.identity(submesh.va_common["a_tbn"]);

	    if (batch.part_node_data) {
	        var node_data = [];
	        for (var i = 0; i < pcount; i++)
	            node_data.push(i, i, i, i);
	        submesh.va_common[batch.part_node_data.name] = new Float32Array(node_data);
	    }
	};

	exports.update_particles_objs_cache = function(obj) {
	    if (_particles_objs_cache.indexOf(obj) == -1)
	        _particles_objs_cache.push(obj);
	};

	exports.remove_obj_from_cache = function(obj) {
	    var ind = _particles_objs_cache.indexOf(obj);
	    if (ind != -1)
	        _particles_objs_cache.splice(ind, 1);
	};

	exports.cleanup = function() {
	    _particles_objs_cache.length = 0;
	};

	}

	var int_particles_factory = register("__particles", Int_particles);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	// "use strict";

	/**
	 * Physics worker Inter Process Communication API.
	 * @name ipc
	 * @namespace
	 * @exports exports as ipc
	 */
	function Int_IPC(ns, exports) {

	var m_util = int_util_factory(ns);
	var m_cont = int_container_factory(ns);

	/*
	 * Use Visual Incrementing script to simplify assignment of such numbers in VIM
	 * http://www.drchip.org/astronaut/vim/index.html#VISINCR
	 */
	var _wait_for_loading = true;
	// MAIN <- PHYSICS
	exports.IN_LOADED                = 0 ;
	exports.IN_COLLISION             = 1 ;
	exports.IN_COLLISION_POS_NORM    = 2 ;
	exports.IN_COLLISION_IMPULSE     = 3 ;
	exports.IN_ERROR                 = 4 ;
	exports.IN_FBMSG                 = 5 ;
	exports.IN_FLOATER_BOB_TRANSFORM = 6 ;
	exports.IN_LOG                   = 7 ;
	exports.IN_PROP_OFFSET           = 8 ;
	exports.IN_RAY_HIT               = 9 ;
	exports.IN_RAY_HIT_POS_NORM      = 10;
	exports.IN_REMOVE_RAY_TEST       = 11;
	exports.IN_TRANSFORM             = 12;
	exports.IN_VEHICLE_SPEED         = 13;
	exports.IN_PING                  = 14;
	exports.IN_FPS                   = 15;
	exports.IN_DEBUG_STATS           = 16;

	var IN_COLLISION          = exports.IN_COLLISION;
	var IN_COLLISION_POS_NORM = exports.IN_COLLISION_POS_NORM;
	var IN_PROP_OFFSET        = exports.IN_PROP_OFFSET;
	var IN_RAY_HIT            = exports.IN_RAY_HIT;
	var IN_RAY_HIT_POS_NORM   = exports.IN_RAY_HIT_POS_NORM;
	var IN_TRANSFORM          = exports.IN_TRANSFORM;

	// MAIN -> PHYSICS
	exports.OUT_INIT                              = 100;
	exports.OUT_ACTIVATE                          = 101;
	exports.OUT_ADD_BOAT_BOB                      = 102;
	exports.OUT_ADD_CAR_WHEEL                     = 103;
	exports.OUT_ADD_FLOATER_BOB                   = 104;
	exports.OUT_APPEND_BOUNDING_BODY              = 105;
	exports.OUT_APPEND_BOAT                       = 106;
	exports.OUT_APPEND_CAR                        = 107;
	exports.OUT_APPEND_CHARACTER                  = 108;
	exports.OUT_APPEND_COLLISION_TEST             = 109;
	exports.OUT_APPEND_CONSTRAINT                 = 110;
	exports.OUT_APPEND_FLOATER                    = 111;
	exports.OUT_APPEND_GHOST_MESH_BODY            = 112;
	exports.OUT_APPEND_STATIC_MESH_BODY           = 113;
	exports.OUT_APPEND_WATER                      = 114;
	exports.OUT_REMOVE_BODY                       = 115;
	exports.OUT_APPLY_CENTRAL_FORCE               = 116;
	exports.OUT_APPLY_COLLISION_IMPULSE_TEST      = 117;
	exports.OUT_APPLY_TORQUE                      = 118;
	exports.OUT_CHARACTER_JUMP                    = 119;
	exports.OUT_CHARACTER_ROTATION_INCREMENT      = 120;
	exports.OUT_CLEAR_COLLISION_IMPULSE_TEST      = 121;
	exports.OUT_DISABLE_SIMULATION                = 122;
	exports.OUT_ENABLE_SIMULATION                 = 123;
	exports.OUT_PAUSE                             = 124;
	exports.OUT_APPEND_RAY_TEST                   = 125;
	exports.OUT_REMOVE_RAY_TEST                   = 126;
	exports.OUT_CHANGE_RAY_TEST_FROM_TO           = 127;
	exports.OUT_REMOVE_COLLISION_TEST             = 128;
	exports.OUT_REMOVE_CONSTRAINT                 = 129;
	exports.OUT_RESUME                            = 130;
	exports.OUT_SET_CHARACTER_FLY_VELOCITY        = 131;
	exports.OUT_SET_CHARACTER_HOR_ROTATION        = 132;
	exports.OUT_SET_CHARACTER_MOVE_DIR            = 133;
	exports.OUT_SET_CHARACTER_MOVE_TYPE           = 134;
	exports.OUT_SET_CHARACTER_ROTATION            = 135;
	exports.OUT_SET_CHARACTER_RUN_VELOCITY        = 136;
	exports.OUT_SET_CHARACTER_VERT_ROTATION       = 137;
	exports.OUT_SET_CHARACTER_WALK_VELOCITY       = 138;
	exports.OUT_SET_GRAVITY                       = 139;
	exports.OUT_SET_LINEAR_VELOCITY               = 140;
	exports.OUT_SET_TRANSFORM                     = 141;
	exports.OUT_SET_WATER_TIME                    = 142;
	exports.OUT_ADD_WATER_WRAPPER                 = 143;
	exports.OUT_UPDATE_BOAT_CONTROLS              = 144;
	exports.OUT_UPDATE_CAR_CONTROLS               = 145;
	exports.OUT_PING                              = 146;
	exports.OUT_DEBUG                             = 147;
	exports.OUT_UPDATE_WORLD                      = 148;
	exports.OUT_SET_ANGULAR_VELOCITY              = 149;
	exports.OUT_SET_CHARACTER_VERT_MOVE_DIR_ANGLE = 150;

	var OUT_SET_TRANSFORM = exports.OUT_SET_TRANSFORM;

	var _worker_listeners = b4w.worker_listeners;
	var _worker_namespaces = b4w.worker_namespaces;

	var _msg_cache_IN_TRANSFORM = {
	    msg_id:   IN_TRANSFORM,

	    body_id:  0,
	    time:     0,
	    trans:    new Float32Array(3),
	    quat:     new Float32Array(4),
	    linvel:   new Float32Array(3),
	    angvel:   new Float32Array(3),

	    len:      0
	};

	var _msg_cache_IN_PROP_OFFSET = {
	    msg_id:               IN_PROP_OFFSET,

	    chassis_hull_body_id: 0,
	    prop_ind:             0,
	    trans:                new Float32Array(3),
	    quat:                 new Float32Array(4),

	    len:                  0
	};

	var _msg_cache_IN_RAY_HIT = {
	    msg_id:      IN_RAY_HIT,

	    id:          0,
	    body_id_hit: 0,
	    hit_fract:   0,
	    hit_time:    0,

	    len:         0
	};

	var _msg_cache_IN_RAY_HIT_POS_NORM = {
	    msg_id:      IN_RAY_HIT_POS_NORM,

	    id:          0,
	    body_id_hit: 0,
	    hit_fract:   0,
	    hit_time:    0,
	    hit_pos:     new Float32Array(3),
	    hit_norm:    new Float32Array(3),

	    len:         0
	};

	var _msg_cache_IN_COLLISION = {
	    msg_id:     IN_COLLISION,

	    body_id_a:  0,
	    body_id_b:  0,
	    result:     0,

	    len:        0
	};

	var _msg_cache_IN_COLLISION_POS_NORM = {
	    msg_id:     IN_COLLISION_POS_NORM,

	    body_id_a:  0,
	    body_id_b:  0,
	    result:     0,
	    coll_point: new Float32Array(3),
	    coll_norm:  new Float32Array(3),
	    coll_dist:  0,

	    len:        0
	};

	var _msg_cache_OUT_SET_TRANSFORM = {
	    msg_id:  OUT_SET_TRANSFORM,

	    body_id: 0,
	    trans:   new Float32Array(3),
	    quat:    new Float32Array(4),

	    len:     0
	};

	var _msg_cache_list = [
	    _msg_cache_IN_TRANSFORM,
	    _msg_cache_IN_PROP_OFFSET,
	    _msg_cache_IN_RAY_HIT,
	    _msg_cache_IN_RAY_HIT_POS_NORM,
	    _msg_cache_IN_COLLISION,
	    _msg_cache_IN_COLLISION_POS_NORM,
	    _msg_cache_OUT_SET_TRANSFORM
	];


	exports.create_worker = function(path, fallback) {
	    var worker = {
	        is_main: path ? true : false,
	        web_worker: null,
	        buf_arr: [],
	        fb_worker_ns: ""
	    };

	    if (fallback) {
	        // TODO: check (ES6 MODULES)
	        // require here because it's not availabe in workers
	        // (e.g. due to obfuscation)
	        // var m_util = require("__util");
	        // var m_cont = require("__container");


	        var web_worker_fallback = {
	            addEventListener: function(type, listener, useCapture) {
	                if (type != "message")
	                    m_util.panic("Wrong web worker event");

	                set_fallback_listener(worker.fb_worker_ns, worker.is_main,
	                        listener);
	            },

	            removeEventListener: function(type, listener, useCapture) {
	                if (type != "message")
	                    m_util.panic("Wrong web worker event");

	                set_fallback_listener(worker.fb_worker_ns, worker.is_main, null);
	            },

	            postMessage: function(msg, msg2) {
	                var listener = find_fallback_listener(worker.fb_worker_ns,
	                        !worker.is_main);
	                listener({"data": msg});
	            },

	            terminate: function() {
	                for (var i = 0; i < _worker_namespaces.length; i+=2)
	                    if (_worker_namespaces[i+1] == worker.fb_worker_ns) {
	                        _worker_listeners.splice(i, 2);
	                        _worker_namespaces.splice(i, 2);
	                        return;
	                    }
	            }
	        };

	        worker.web_worker = web_worker_fallback;

	        if (worker.is_main) {
	            var main_ns = b4w.get_namespace(require);
	            var worker_ns = m_util.unique_name(main_ns + "_worker");

	            _worker_namespaces.push(main_ns);
	            _worker_namespaces.push(worker_ns);

	            _worker_listeners.push(null);
	            _worker_listeners.push(null);

	            worker.fb_worker_ns = worker_ns;

	            var uranium_js = m_cont.find_script(path);
	            if (uranium_js) {
	                // just register in the new namespace
	                if (_wait_for_loading)
	                    uranium_js.addEventListener("load", function() {
	                        b4w.require("__bindings", worker.fb_worker_ns);
	                    }, false);
	                else {
	                    b4w.cleanup("__bindings", worker.fb_worker_ns);
	                    b4w.cleanup("__ipc", worker.fb_worker_ns);
	                    b4w.require("__bindings", worker.fb_worker_ns);
	                }
	            } else {
	                // load and register
	                uranium_js = document.createElement("script");

	                uranium_js.src = path;
	                uranium_js.defer = "defer";
	                uranium_js.async = "async";
	                uranium_js.addEventListener("load", function() {
	                    _wait_for_loading = false;
	                    b4w.require("__bindings", worker.fb_worker_ns);
	                }, false);

	                document.head.appendChild(uranium_js);
	            }
	        } else {
	            worker.fb_worker_ns = b4w.get_namespace(require);
	        }
	    } else {
	        if (path)
	            worker.web_worker = new Worker(path);
	        else
	            worker.web_worker = self;
	    }

	    return worker;
	};

	function set_fallback_listener(worker_ns, is_main, listener) {
	    for (var i = 0; i < _worker_namespaces.length; i+=2)
	        if (_worker_namespaces[i+1] == worker_ns)
	            _worker_listeners[i + Number(!is_main)] = listener;
	}

	function find_fallback_listener(worker_ns, is_main) {
	    for (var i = 0; i < _worker_namespaces.length; i+=2)
	        if (_worker_namespaces[i+1] == worker_ns)
	            return _worker_listeners[i + Number(!is_main)];

	    return null;
	}

	exports.attach_handler = function(worker, process_message_cb) {

	    assign_msg_cache_length(_msg_cache_list);

	    var preprocess_message_cb = function(event_data) {

	        if (event_data.constructor == ArrayBuffer) {
	            event_data = new Float32Array(event_data);
	        } else if (event_data[0].constructor == ArrayBuffer) {
	            for (var i = 0; i < event_data.length; i++)
	                preprocess_message_cb(event_data[i]);
	            return;
	        }

	        var msg_id = event_data[0] | 0;

	        switch (msg_id) {
	        case IN_TRANSFORM:
	            var data = _msg_cache_IN_TRANSFORM;

	            data.body_id   = event_data[1 ] | 0;
	            data.time      = event_data[2 ];
	            data.trans[0]  = event_data[3 ];
	            data.trans[1]  = event_data[4 ];
	            data.trans[2]  = event_data[5 ];
	            data.quat[0]   = event_data[6 ];
	            data.quat[1]   = event_data[7 ];
	            data.quat[2]   = event_data[8 ];
	            data.quat[3]   = event_data[9 ];
	            data.linvel[0] = event_data[10];
	            data.linvel[1] = event_data[11];
	            data.linvel[2] = event_data[12];
	            data.angvel[0] = event_data[13];
	            data.angvel[1] = event_data[14];
	            data.angvel[2] = event_data[15];
	            break;
	        case IN_PROP_OFFSET:
	            var data = _msg_cache_IN_PROP_OFFSET;

	            data.chassis_hull_body_id = event_data[1] | 0;
	            data.prop_ind             = event_data[2] | 0;
	            data.trans[0]             = event_data[3];
	            data.trans[1]             = event_data[4];
	            data.trans[2]             = event_data[5];
	            data.quat[0]              = event_data[6];
	            data.quat[1]              = event_data[7];
	            data.quat[2]              = event_data[8];
	            data.quat[3]              = event_data[9];
	            break;
	        case IN_RAY_HIT:
	            var data = _msg_cache_IN_RAY_HIT;

	            data.id          = event_data[1] | 0;
	            data.body_id_hit = event_data[2] | 0;
	            data.hit_fract   = event_data[3];
	            data.hit_time    = event_data[4];

	            break;
	        case IN_RAY_HIT_POS_NORM:
	            var data = _msg_cache_IN_RAY_HIT_POS_NORM;

	            data.id          = event_data[ 1] | 0;
	            data.body_id_hit = event_data[ 2] | 0;
	            data.hit_fract   = event_data[ 3];
	            data.hit_time    = event_data[ 4];
	            data.hit_pos[0]  = event_data[ 5];
	            data.hit_pos[1]  = event_data[ 6];
	            data.hit_pos[2]  = event_data[ 7];
	            data.hit_norm[0] = event_data[ 8];
	            data.hit_norm[1] = event_data[ 9];
	            data.hit_norm[2] = event_data[10];

	            break;
	        case IN_COLLISION:
	            var data = _msg_cache_IN_COLLISION;

	            data.body_id_a     =   event_data[1] | 0;
	            data.body_id_b     =   event_data[2] | 0;
	            data.result        = !!event_data[3];
	            break;
	        case IN_COLLISION_POS_NORM:
	            var data = _msg_cache_IN_COLLISION_POS_NORM;

	            data.body_id_a     =   event_data[ 1] | 0;
	            data.body_id_b     =   event_data[ 2] | 0;
	            data.result        = !!event_data[ 3];
	            data.coll_point[0] =   event_data[ 4];
	            data.coll_point[1] =   event_data[ 5];
	            data.coll_point[2] =   event_data[ 6];
	            data.coll_norm[0]  =   event_data[ 7];
	            data.coll_norm[1]  =   event_data[ 8];
	            data.coll_norm[2]  =   event_data[ 9];
	            data.coll_dist     =   event_data[10];
	            break;
	        case OUT_SET_TRANSFORM:
	            var data = _msg_cache_OUT_SET_TRANSFORM;

	            data.body_id  = event_data[1] | 0;
	            data.trans[0] = event_data[2];
	            data.trans[1] = event_data[3];
	            data.trans[2] = event_data[4];
	            data.quat[0]  = event_data[5];
	            data.quat[1]  = event_data[6];
	            data.quat[2]  = event_data[7];
	            data.quat[3]  = event_data[8];
	            break;
	        default:
	            var data = event_data;
	            break;
	        }

	        process_message_cb(worker, msg_id, data);
	    };

	    worker.web_worker.addEventListener("message", function(event) {
	        preprocess_message_cb(event.data);
	    }, false);
	};

	function assign_msg_cache_length(msg_cache_list) {

	    for (var i = 0; i < msg_cache_list.length; i++) {
	        var cache = msg_cache_list[i];
	        var len = 0;

	        for (var j in cache) {
	            var prop = cache[j];

	            switch (prop.constructor) {
	            case Float32Array:
	                len += prop.length;
	                break;
	            case Number:
	                len += 1;
	                break;
	            default:
	                break;
	            }
	        }

	        // exclude "len" itself
	        len -= 1;

	        cache.len = len;
	    }
	}

	exports.cleanup = function() {
	};

	/**
	 * Cached message post.
	 * messages with same id must have same length
	 * @methodOf physics
	 */
	exports.post_msg = function(worker, msg_id) {

	    // not initialized for worker warm-up
	    if (!worker)
	        return;

	    switch (msg_id) {
	    case IN_TRANSFORM:
	        var data = _msg_cache_IN_TRANSFORM;
	        var msg = new Float32Array(data.len);

	        msg[0 ] = data.msg_id;
	        msg[1 ] = data.body_id;
	        msg[2 ] = data.time;
	        msg[3 ] = data.trans[0];
	        msg[4 ] = data.trans[1];
	        msg[5 ] = data.trans[2];
	        msg[6 ] = data.quat[0];
	        msg[7 ] = data.quat[1];
	        msg[8 ] = data.quat[2];
	        msg[9 ] = data.quat[3];
	        msg[10] = data.linvel[0];
	        msg[11] = data.linvel[1];
	        msg[12] = data.linvel[2];
	        msg[13] = data.angvel[0];
	        msg[14] = data.angvel[1];
	        msg[15] = data.angvel[2];

	        worker.buf_arr.push(msg.buffer);
	        break;
	    case IN_PROP_OFFSET:
	        var data = _msg_cache_IN_PROP_OFFSET;
	        var msg = new Float32Array(data.len);

	        msg[0] = data.msg_id;
	        msg[1] = data.chassis_hull_body_id;
	        msg[2] = data.prop_ind;
	        msg[3] = data.trans[0];
	        msg[4] = data.trans[1];
	        msg[5] = data.trans[2];
	        msg[6] = data.quat[0];
	        msg[7] = data.quat[1];
	        msg[8] = data.quat[2];
	        msg[9] = data.quat[3];

	        worker.buf_arr.push(msg.buffer);
	        break;
	    case IN_RAY_HIT:
	        var data = _msg_cache_IN_RAY_HIT;
	        var msg = new Float32Array(data.len);

	        msg[0] = data.msg_id;
	        msg[1] = data.id;
	        msg[2] = data.body_id_hit;
	        msg[3] = data.hit_fract;
	        msg[4] = data.hit_time;

	        worker.buf_arr.push(msg.buffer);
	        break;
	    case IN_RAY_HIT_POS_NORM:
	        var data = _msg_cache_IN_RAY_HIT_POS_NORM;
	        var msg = new Float32Array(data.len);

	        msg[ 0] = data.msg_id;
	        msg[ 1] = data.id;
	        msg[ 2] = data.body_id_hit;
	        msg[ 3] = data.hit_fract;
	        msg[ 4] = data.hit_time;
	        msg[ 5] = data.hit_pos[0];
	        msg[ 6] = data.hit_pos[1];
	        msg[ 7] = data.hit_pos[2];
	        msg[ 8] = data.hit_norm[0];
	        msg[ 9] = data.hit_norm[1];
	        msg[10] = data.hit_norm[2];

	        worker.buf_arr.push(msg.buffer);
	        break;
	    case IN_COLLISION:
	        var data = _msg_cache_IN_COLLISION;
	        var msg = new Float32Array(data.len);

	        msg[0] = data.msg_id;
	        msg[1] = data.body_id_a;
	        msg[2] = data.body_id_b;
	        msg[3] = data.result;

	        worker.buf_arr.push(msg.buffer);
	        break;
	    case IN_COLLISION_POS_NORM:
	        var data = _msg_cache_IN_COLLISION_POS_NORM;
	        var msg = new Float32Array(data.len);

	        msg[ 0] = data.msg_id;
	        msg[ 1] = data.body_id_a;
	        msg[ 2] = data.body_id_b;
	        msg[ 3] = data.result;
	        msg[ 4] = data.coll_point[0];
	        msg[ 5] = data.coll_point[1];
	        msg[ 6] = data.coll_point[2];
	        msg[ 7] = data.coll_norm[0];
	        msg[ 8] = data.coll_norm[1];
	        msg[ 9] = data.coll_norm[2];
	        msg[10] = data.coll_dist;

	        worker.buf_arr.push(msg.buffer);
	        break;
	    case OUT_SET_TRANSFORM:
	        var data = _msg_cache_OUT_SET_TRANSFORM;
	        var msg = new Float32Array(data.len);

	        msg[0] = data.msg_id;
	        msg[1] = data.body_id;
	        msg[2] = data.trans[0];
	        msg[3] = data.trans[1];
	        msg[4] = data.trans[2];
	        msg[5] = data.quat[0];
	        msg[6] = data.quat[1];
	        msg[7] = data.quat[2];
	        msg[8] = data.quat[3];

	        worker.buf_arr.push(msg.buffer);
	        break;
	    default:
	        var msg = [];
	        for (var i = 1; i < arguments.length; i++)
	            msg.push(arguments[i]);
	        worker.web_worker.postMessage(msg);
	        break;
	    }
	};

	exports.post_msg_arr = function(worker) {
	    if (!worker || !worker.buf_arr.length)
	        return;

	    worker.web_worker.postMessage(worker.buf_arr);

	    worker.buf_arr.length = 0;
	};

	exports.get_msg_cache = function(msg_id) {
	    switch (msg_id) {
	    case IN_TRANSFORM:
	        return _msg_cache_IN_TRANSFORM;
	    case IN_PROP_OFFSET:
	        return _msg_cache_IN_PROP_OFFSET;
	    case IN_RAY_HIT:
	        return _msg_cache_IN_RAY_HIT;
	    case IN_RAY_HIT_POS_NORM:
	        return _msg_cache_IN_RAY_HIT_POS_NORM;
	    case IN_COLLISION:
	        return _msg_cache_IN_COLLISION;
	    case IN_COLLISION_POS_NORM:
	        return _msg_cache_IN_COLLISION_POS_NORM;
	    case OUT_SET_TRANSFORM:
	        return _msg_cache_OUT_SET_TRANSFORM;
	    default:
	        return null;
	    }
	};

	exports.terminate = function(worker) {
	    worker.web_worker.terminate();
	    worker.web_worker = null;
	};

	exports.is_active = function(worker) {
	    return !!worker.web_worker;
	};

	exports.is_fallback = function(worker) {
	    return !!worker.fb_worker_ns;
	};

	}

	var int_ipc_factory = register("__ipc", Int_IPC);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Head-up display control module.
	 * @name hud
	 * @namespace
	 * @exports exports as hud
	 */
	function Int_HUD(ns, exports) {

	var m_graph = int_graph_factory(ns);
	var m_subs  = int_subscene_factory(ns);

	var START_POINT_X = 30;
	var START_POINT_Y = 80;
	var LINE_WIDTH = 20;
	var OFFSETS = [5, 30, 4, 10, 5, 3, 5];

	var _canvas_context = null;

	// row,column
	var _carriage = [0, 0];

	exports.init = function(canvas_elem) {
	    var ctx = canvas_elem.getContext("2d");

	    set_style(ctx);

	    _canvas_context = ctx;
	    return ctx;
	};

	function set_style(ctx) {
	    ctx.font = 'bold 15px Courier New';
	    ctx.textBaseline = 'middle';
	    ctx.shadowBlur = 0;
	    ctx.shadowColor = null;
	}

	exports.update_dim = function() {
	    if (_canvas_context)
	        set_style(_canvas_context);
	};

	exports.reset = function() {
	    var ctx = _canvas_context;
	    if (!ctx)
	        return;

	    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
	    ctx.fillStyle = 'rgba(0,0,0,0.5)';
	    ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);

	    reset_carriage();
	};

	exports.show_debug_info = function(scenes, elapsed) {

	    var ctx = _canvas_context;
	    if (!ctx)
	        return;

	    ctx.textAlign = 'left';
	    ctx.fillStyle = 'rgba(0,255,0,255)';

	    print(" FPS", (1/elapsed).toFixed(2));
	    new_line();

	    var sum_bundles = 0;
	    var sum_rcalls = 0;
	    var sum_rtimes = 0;

	    for (var i = 0; i < scenes.length; i++) {
	        var sum = show_debug_info_scene(scenes[i]);
	        sum_bundles += sum[0];
	        sum_rcalls += sum[1];
	        sum_rtimes += sum[2];
	        new_line();
	    }

	    print(" ----------------------------------------------------------------");
	    print("    ", "TOTAL ACTIVE", "", "", sum_rcalls, "of", sum_bundles, "  ",
	            sum_rtimes.toFixed(3));
	};

	function show_debug_info_scene(scene) {

	    print(" SCENE \"" + scene["name"] + "\"");
	    print(" Active                 Subscene   Lamps   Size   RenderCalls   Time");

	    if (!scene._render) {
	        print("No INFO");
	        return;
	    }


	    //print("subscenes", graph.length, "(act/pass/fict type size batches calls lights):"); 

	    var sum_bundles = 0;
	    var sum_rcalls = 0;
	    var sum_rtimes = 0;

	    var graph = scene._render.graph;
	    m_graph.traverse(graph, function(node, attr) {
	        var subs = attr;

	        // fictional type
	        if (subs.type == m_subs.SINK)
	            return;

	        var size = Math.round(subs.camera.width) + "x" + Math.round(subs.camera.height);

	        var bundles = 0;
	        for (var i = 0; i < subs.draw_data.length; i++)
	            bundles += subs.draw_data[i].bundles.length;

	        var rcalls = subs.debug_render_calls;

	        if (subs.type == m_subs.MAIN_CUBE_REFLECT ||
	                subs.type == m_subs.MAIN_CUBE_REFLECT_BLEND)
	            bundles *= 6;

	        // active/passive
	        var is_active = subs.do_render && !subs.force_do_not_render;

	        var render_time = is_active ? subs.debug_render_time : 0;

	        // NOTE: clear render time for non-enqueued subscenes, BTW they 
	        // shouldn't be active if they're not rendered
	        if (!subs.enqueue)
	            subs.debug_render_time = 0;

	        var activity_prefix = is_active ? " (\u2713)" : " (\u2715)";
	        var label = m_subs.subs_label(subs);
	        print(activity_prefix, label, subs.num_lights, size, rcalls, "of",
	                bundles, "  ", render_time.toFixed(3));

	        subs.debug_render_calls = 0;
	        sum_bundles += bundles;

	        if (is_active) {
	            sum_rcalls += rcalls;
	            sum_rtimes += render_time;
	        }
	    });

	    return [sum_bundles, sum_rcalls, sum_rtimes];
	}

	function reset_carriage() {
	    _carriage[0] = 0;
	    _carriage[1] = 0;
	}

	function new_line() {
	    _carriage[0]++;
	}

	exports.print = function() {
	    var ctx = _canvas_context;
	    if (!ctx)
	        return;

	    ctx.textAlign = 'left';
	    ctx.fillStyle = 'rgba(0,255,0,255)';

	    print.apply(Math, arguments);
	};

	/**
	 * Print a line.
	 * Uses global context and carriage.
	 */
	function print() {

	    var x = START_POINT_X;
	    var y = START_POINT_Y + _carriage[0] * LINE_WIDTH;

	    var text = arguments[0];
	    for (var i = 1; i < arguments.length; i++) {
	        var arg = arguments[i];
	        var num_spaces = OFFSETS[i] - String(arg).length;
	        text += spaces(num_spaces) + arguments[i];
	    }

	    new_line();

	    _canvas_context.fillText(text, x, y);
	}

	function spaces(n) {

	    var s = "";
	    for (var i = 0; i < n; i++) {
	        s += " ";    
	    }
	    return s;
	}

	/**
	 * @see http://www.html5canvastutorials.com/tutorials/html5-canvas-wrap-text-tutorial/
	 */
	exports.plot_array = function(header, slot, arr, arg_min, arg_max,
	        val_min, val_max) {

	    var ctx = _canvas_context;
	    if (!ctx)
	        return;

	    var box = create_strip_box(slot);
	    box_split_v(box, 4, 5, box);

	    ctx.textAlign = 'center';
	    ctx.fillStyle = '#00FF00';
	    _canvas_context.fillText(header, box_mid_h(box), box.y - 10);

	    ctx.strokeStyle = '#00FF00';
	    ctx.lineWidth = 0.5;

	    ctx.beginPath();

	    ctx.moveTo(box.x, box.y);
	    ctx.lineTo(box.x + box.w, box.y);
	    ctx.lineTo(box.x + box.w, box.y + box.h);
	    ctx.lineTo(box.x, box.y + box.h);
	    ctx.closePath();

	    ctx.stroke();


	    if (!val_min && !val_max) {
	        // TODO: proper calc
	        val_min = 1000000;
	        val_max =-1000000;

	        for (var i = 0; i < arr.length; i++) {
	            val_min = Math.min(val_min, arr[i]);
	            val_max = Math.max(val_max, arr[i]);
	        }
	    }

	    ctx.textAlign = "right";
	    _canvas_context.fillText(String(val_min), box.x - 10, box.y + box.h);
	    _canvas_context.fillText(String(val_max), box.x - 10, box.y);

	    ctx.textAlign = "center";
	    _canvas_context.fillText(String(arg_min), box.x, box.y + box.h + 15);
	    _canvas_context.fillText(String(arg_max), box.x + box.w, box.y + box.h + 15);


	    ctx.strokeStyle = '#FF0000';
	    ctx.lineWidth = 1.5;

	    ctx.beginPath();

	    var dx = box.w / (arr.length - 1);
	    var dy = box.h / (val_max - val_min);

	    for (var i = 0; i < arr.length; i++) {
	        var x = box.x + dx * i;
	        var y = (box.y + box.h) - (arr[i] - val_min) * dy;

	        if (i == 0)
	            ctx.moveTo(x, y);
	        else
	            ctx.lineTo(x, y);
	    }
	    ctx.stroke();
	};

	function box_create() {
	    return {
	        x : 0,
	        y : 0,
	        w : 0,
	        h : 0
	    }
	}

	function box_set(x, y, w, h, dest) {
	    dest.x = x;
	    dest.y = y;
	    dest.w = w;
	    dest.h = h;

	    return dest;
	}

	function box_split_h(box, part, parts, dest) {
	    var dw = box.w / parts;

	    dest.x = box.x + dw * part;
	    dest.y = box.y;
	    dest.w = dw;
	    dest.h = box.h;

	    return dest;
	}

	function box_split_v(box, part, parts, dest) {
	    var dh = box.h / parts;

	    dest.x = box.x;
	    dest.y = box.y + dh * part;
	    dest.w = box.w;
	    dest.h = dh;

	    return dest;
	}

	function box_trim_h(box, ratio, dest) {
	    var dw = box.w * ratio;
	    dest.x = box.x + dw;
	    dest.y = box.y;
	    dest.w = box.w - 2 * dw;
	    dest.h = box.h;

	    return dest;
	}

	function box_trim_v(box, ratio, dest) {
	    var dh = box.h * ratio;

	    dest.x = box.x;
	    dest.y = box.y + dh;
	    dest.w = box.w;
	    dest.h = box.h - 2 * dh;

	    return dest;
	}

	function box_mid_h(box) {
	    return box.x + box.w / 2;
	}

	function create_strip_box(slot) {

	    var ctx = _canvas_context;

	    var box = box_create();

	    box_set(0, 0, ctx.canvas.width, ctx.canvas.height, box);
	    box_trim_h(box, 0.01, box);
	    box_trim_v(box, 0.02, box);
	    box_split_h(box, slot, 8, box);
	    box_trim_h(box, 0.02, box);

	    return box;
	}

	exports.draw_mixer_strip = function(id, is_active, slot, params, active_param,
	        mute, solo) {
	    var ctx = _canvas_context;
	    if (!ctx)
	        return;

	    ctx.textAlign = "center";
	    ctx.fillStyle = "#00FF00";
	    ctx.font = 'bold 12px Courier';

	    var box_strip = create_strip_box(slot);

	    var strip_title = is_active ? "[" + id + "]" : id;
	    _canvas_context.fillText(strip_title, box_mid_h(box_strip), box_strip.y);

	    if (mute >= 0)
	        _canvas_context.fillText(mute ? "[M]" : "[ ]", box_mid_h(box_strip) - 15, box_strip.y + 30);

	    if (solo >= 0)
	        _canvas_context.fillText(solo ? "[S]" : "[ ]", box_mid_h(box_strip) + 15, box_strip.y + 30);

	    var box_param = box_create();

	    for (var i = 0; i < params.length; i++) {
	        var param = params[i];
	        
	        var is_volume = (param[0] == "VOLUME");

	        if (is_volume)
	            box_set(box_strip.x, box_strip.y + 350,
	                    box_strip.w, 250, box_param);
	        else
	            box_set(box_strip.x, box_strip.y + 50 + 50 * i,
	                    box_strip.w, box_strip.h, box_param);

	        draw_param_bar(ctx, is_volume, box_param, param, i == active_param);
	    }
	};

	function draw_param_bar(ctx, vertical, box, param, is_active) {

	    var name = param[0];
	    var value = param[1];
	    var min = param[2];
	    var max = param[3];
	    var steps = param[4];
	    var is_log = param[5];

	    var step = (max - min) / steps;

	    if (step < 1)
	        var digits = Math.floor(1 / step - 0.00001).toFixed(0).length;
	    else
	        var digits = 0;

	    if (is_log)
	        var val_pos_factor = Math.log(value / min) / Math.log(max/min);
	    else
	        var val_pos_factor = (value - min) / (max - min);

	    ctx.textAlign = "center";

	    if (is_active)
	        ctx.fillText("["+name+"]", box_mid_h(box), box.y);
	    else
	        ctx.fillText(name, box_mid_h(box), box.y);

	    ctx.strokeStyle = "#00FF00";

	    if (vertical)
	        ctx.lineWidth = 3;
	    else
	        ctx.lineWidth = 1;

	    if (vertical) {
	        ctx.textAlign = "right";
	        ctx.fillText(max.toFixed(digits), box_mid_h(box)-10, box.y + 15);

	        ctx.textAlign = "right";
	        ctx.fillText(min.toFixed(digits), box_mid_h(box)-10, box.y + box.h - 15);
	    } else {
	        ctx.textAlign = "right";
	        ctx.fillText(min.toFixed(digits), box.x+28, box.y + 15);

	        ctx.textAlign = "left";
	        ctx.fillText(max.toFixed(digits), box.x+box.w-28, box.y + 15);
	    }

	    ctx.beginPath();

	    if (vertical) {
	        var val_pos_y = box.y + 15 + (box.h - 30) * (1 - val_pos_factor);

	        ctx.moveTo(box_mid_h(box), box.y + 15);
	        ctx.lineTo(box_mid_h(box), box.y + box.h - 15);

	        ctx.moveTo(box_mid_h(box) - 5, box.y + 15);
	        ctx.lineTo(box_mid_h(box) + 5, box.y + 15);

	        ctx.moveTo(box_mid_h(box) - 5, box.y + box.h - 15);
	        ctx.lineTo(box_mid_h(box) + 5, box.y + box.h - 15);

	        ctx.moveTo(box_mid_h(box) - 5, val_pos_y);
	        ctx.lineTo(box_mid_h(box) + 5, val_pos_y);
	    } else {
	        var val_pos_x = box.x + 30 + (box.w - 60) * val_pos_factor;

	        ctx.moveTo(box.x + 30, box.y + 15);
	        ctx.lineTo(box.x + box.w - 30, box.y + 15);

	        ctx.moveTo(box.x + 30, box.y + 15 - 5);
	        ctx.lineTo(box.x + 30, box.y + 15 + 5);

	        ctx.moveTo(box.x + box.w - 30, box.y + 15 - 5);
	        ctx.lineTo(box.x + box.w - 30, box.y + 15 + 5);

	        ctx.moveTo(val_pos_x, box.y + 15 - 5);
	        ctx.lineTo(val_pos_x, box.y + 15 + 5);
	    }

	    ctx.stroke();

	    // NOTE: temporary hack to append bandwidth in octaves
	    if (name == "EQ_Q") {
	        // see http://www.sengpielaudio.com/calculator-bandwidth.htm
	        var Q = value;
	        var Y = 1 + 1 / (2*Q*Q) + Math.sqrt((2 + 1/(Q*Q)) * (2 + 1/(Q*Q)) / 4 - 1);
	        var N = Math.log(Y) / Math.log(2);

	        if (vertical) {
	            ctx.textAlign = "left";
	            ctx.fillText(value.toFixed(digits), box_mid_h(box) + 10, val_pos_y);

	            ctx.textAlign = "left";
	            ctx.fillText("("+N.toFixed(digits+1)+")", box_mid_h(box) + 10, val_pos_y + 10);
	        } else {
	            ctx.textAlign = "right";
	            ctx.fillText(value.toFixed(digits), val_pos_x, box.y + 30);

	            ctx.textAlign = "left";
	            ctx.fillText("("+N.toFixed(digits+1)+")", val_pos_x, box.y + 30);
	        }
	    } else {
	        if (vertical) {
	            ctx.textAlign = "left";
	            ctx.fillText(value.toFixed(digits), box_mid_h(box) + 10, val_pos_y);
	        } else {
	            ctx.textAlign = "center";
	            ctx.fillText(value.toFixed(digits), val_pos_x, box.y + 30);
	        }
	    }

	}

	}

	var int_hud_factory = register("__hud", Int_HUD);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Input devices internal API.
	 *
	 * @name input
	 * @namespace
	 * @exports exports as input
	 */
	function Int_input(ns, exports) {

	var m_compat = int_compat_factory(ns);
	var m_cont  = int_container_factory(ns);
	var m_cfg   = int_config_factory(ns);
	var m_mat4  = mat4_factory(ns);
	var m_print = print_factory(ns);
	var m_tsr   = int_tsr_factory(ns);
	var m_quat  = quat_factory(ns);
	var m_util  = int_util_factory(ns);
	var m_vec3  = vec3_factory(ns);
	var m_vec4  = vec4_factory(ns);

	var cfg_def = m_cfg.defaults;
	var cfg_hmdp = m_cfg.hmd_params;

	var _tsr_tmp = m_tsr.create();
	var _tsr_tmp2 = m_tsr.create();
	var _mat4_tmp = m_mat4.create();

	var DEVICE_GYRO = 10;
	var DEVICE_HMD = 20;
	var DEVICE_MOUSE = 30;
	var DEVICE_KEYBOARD = 40;
	var DEVICE_TOUCH = 50;
	var DEVICE_GAMEPAD0 = 60;
	var DEVICE_GAMEPAD1 = 70;
	var DEVICE_GAMEPAD2 = 80;
	var DEVICE_GAMEPAD3 = 90;

	exports.DEVICE_GYRO = DEVICE_GYRO;
	exports.DEVICE_HMD = DEVICE_HMD;
	exports.DEVICE_MOUSE = DEVICE_MOUSE;
	exports.DEVICE_KEYBOARD = DEVICE_KEYBOARD;
	exports.DEVICE_TOUCH = DEVICE_TOUCH;
	exports.DEVICE_GAMEPAD0 = DEVICE_GAMEPAD0;
	exports.DEVICE_GAMEPAD1 = DEVICE_GAMEPAD1;
	exports.DEVICE_GAMEPAD2 = DEVICE_GAMEPAD2;
	exports.DEVICE_GAMEPAD3 = DEVICE_GAMEPAD3;

	var HMD_NON_WEBVR = 1 << 0;
	var HMD_WEBVR_DESKTOP = 1 << 1;
	var HMD_WEBVR_MOBILE = 1 << 2;
	var HMD_WEBVR1 = 1 << 3;
	var HMD_WEBVR1_1 = 1 << 4;

	exports.HMD_WEBVR_DESKTOP = HMD_WEBVR_DESKTOP;
	exports.HMD_WEBVR_MOBILE = HMD_WEBVR_MOBILE;
	exports.HMD_NON_WEBVR = HMD_NON_WEBVR;
	exports.HMD_WEBVR1 = HMD_WEBVR1;
	exports.HMD_WEBVR1_1 = HMD_WEBVR1_1;

	var HMD_WEBVR_TYPE = 0;
	var HMD_ORIENTATION_QUAT = 10;
	var HMD_POSITION = 20;
	var HMD_FOV_LEFT = 21;
	var HMD_FOV_RIGHT = 22;
	var HMD_EYE_DISTANCE = 23;
	var HMD_DISTORTION = 24;
	var HMD_BASELINE_DIST = 25;
	var HMD_SCREEN_LENS_DIST = 26;
	var HMD_SCREEN_WIDTH = 27;
	var HMD_SCREEN_HEIGHT = 28;
	var HMD_BEVEL_SIZE = 29;
	var HMD_PROJ_LEFT = 30;
	var HMD_PROJ_RIGHT = 31;
	var MOUSE_LOCATION = 40;
	var MOUSE_LOCATION_PL = 41;
	var MOUSE_DOWN_WHICH = 50;
	var MOUSE_UP_WHICH = 60;
	var MOUSE_WHEEL = 70;
	var KEYBOARD_UP = 80;
	var KEYBOARD_DOWN = 90;
	var KEYBOARD_DOWN_MODIFIED = 91;
	var TOUCH_START = 100;
	var TOUCH_MOVE = 110;
	var TOUCH_END = 120;
	var GYRO_ORIENTATION_QUAT = 130;
	var GYRO_ORIENTATION_ANGLES = 140;
	var DEVICE_ORIENTATION = 141;

	exports.HMD_WEBVR_TYPE = HMD_WEBVR_TYPE;
	exports.HMD_ORIENTATION_QUAT = HMD_ORIENTATION_QUAT;
	exports.HMD_POSITION = HMD_POSITION;
	exports.HMD_FOV_LEFT = HMD_FOV_LEFT;
	exports.HMD_FOV_RIGHT = HMD_FOV_RIGHT;
	exports.HMD_EYE_DISTANCE = HMD_EYE_DISTANCE;
	exports.HMD_DISTORTION = HMD_DISTORTION;
	exports.HMD_BASELINE_DIST = HMD_BASELINE_DIST;
	exports.HMD_SCREEN_LENS_DIST = HMD_SCREEN_LENS_DIST;
	exports.HMD_SCREEN_WIDTH = HMD_SCREEN_WIDTH;
	exports.HMD_SCREEN_HEIGHT = HMD_SCREEN_HEIGHT;
	exports.HMD_BEVEL_SIZE = HMD_BEVEL_SIZE;
	exports.HMD_PROJ_LEFT = HMD_PROJ_LEFT;
	exports.HMD_PROJ_RIGHT = HMD_PROJ_RIGHT;

	exports.MOUSE_LOCATION = MOUSE_LOCATION;
	exports.MOUSE_LOCATION_PL = MOUSE_LOCATION_PL;
	exports.MOUSE_DOWN_WHICH = MOUSE_DOWN_WHICH;
	exports.MOUSE_UP_WHICH = MOUSE_UP_WHICH;
	exports.MOUSE_WHEEL = MOUSE_WHEEL;
	exports.KEYBOARD_UP = KEYBOARD_UP;
	exports.KEYBOARD_DOWN = KEYBOARD_DOWN;
	exports.KEYBOARD_DOWN_MODIFIED = KEYBOARD_DOWN_MODIFIED;
	exports.TOUCH_START = TOUCH_START;
	exports.TOUCH_MOVE = TOUCH_MOVE;
	exports.TOUCH_END = TOUCH_END;
	exports.GYRO_ORIENTATION_QUAT = GYRO_ORIENTATION_QUAT;
	exports.GYRO_ORIENTATION_ANGLES = GYRO_ORIENTATION_ANGLES;

	exports.GMPD_BUTTON_0 = 300;
	exports.GMPD_BUTTON_1 = 301;
	exports.GMPD_BUTTON_2 = 302;
	exports.GMPD_BUTTON_3 = 303;
	exports.GMPD_BUTTON_4 = 304;
	exports.GMPD_BUTTON_5 = 305;
	exports.GMPD_BUTTON_6 = 306;
	exports.GMPD_BUTTON_7 = 307;
	exports.GMPD_BUTTON_8 = 308;
	exports.GMPD_BUTTON_9 = 309;
	exports.GMPD_BUTTON_10 = 310;
	exports.GMPD_BUTTON_11 = 311;
	exports.GMPD_BUTTON_12 = 312;
	exports.GMPD_BUTTON_13 = 313;
	exports.GMPD_BUTTON_14 = 314;
	exports.GMPD_BUTTON_15 = 315;
	exports.GMPD_BUTTON_16 = 316;
	exports.GMPD_BUTTON_17 = 317;
	exports.GMPD_BUTTON_18 = 318;
	exports.GMPD_BUTTON_19 = 319;
	exports.GMPD_BUTTON_20 = 320;
	exports.GMPD_BUTTON_21 = 321;
	exports.GMPD_BUTTON_22 = 322;
	exports.GMPD_BUTTON_23 = 323;
	exports.GMPD_BUTTON_24 = 324;
	exports.GMPD_BUTTON_25 = 325;

	exports.GMPD_TRACKPAD_BUTTON = 300;
	exports.GMPD_TRIGGER_BUTTON = 301;
	exports.GMPD_GRIPS_BUTTON = 302;
	exports.GMPD_MENU_BUTTON = 303;

	exports.GMPD_AXIS_0 = 326;
	exports.GMPD_AXIS_1 = 327;
	exports.GMPD_AXIS_2 = 328;
	exports.GMPD_AXIS_3 = 329;
	exports.GMPD_AXIS_4 = 330;
	exports.GMPD_AXIS_5 = 331;
	exports.GMPD_AXIS_6 = 332;
	exports.GMPD_AXIS_7 = 333;
	exports.GMPD_AXIS_8 = 334;
	exports.GMPD_AXIS_9 = 335;
	exports.GMPD_AXIS_10 = 336;
	exports.GMPD_AXIS_11 = 337;

	var GMPD_AXIS_OFFSET = 326;
	var GMPD_BTNS_OFFSET = 300;

	var _quat_tmp = m_quat.create();
	var _quat_tmp2 = m_quat.create();
	var _vec3_tmp = m_vec3.create();

	// callbacks buffers
	var _location = new Float32Array(2);
	var _angles = m_vec3.create();
	var _quat = m_quat.create();

	var _exist_touch = "ontouchstart" in document.documentElement;

	var _devices = [];

	var WHEEL_DELTA_MULT = 100;
	// this means about a 20-fold scroll action if Chrome event values are 
	// considered as a base
	var WHEEL_DELTA_LIMIT = 2000; 

	/**
	 * add:
	 *      "global" variable:
	 *          var TYPE_[device_name] = [freed_number];
	 *          exports.TYPE_[device_name] = TYPE_[device_name];
	 *      into function:
	 *          init_device:
	 *              var device = { ...
	 *                  [need_field]: [init_value]
	 *              ... }
	 *          update:
	 *              case TYPE_[device_name]:
	 *                  [every frame updating logic]
	 *          reset_device:
	 *              case TYPE_[device_name]:
	 *                  [semantic reset device state]
	 *      some stuff to functions:
	 *          hardware data:
	 *              attach_param_cb
	 *              detach_param_cb
	 *              get_value_param/get_vector_param
	 *          users config:
	 *              set_config/get_config
	 */

	exports.can_use_device = can_use_device;
	function can_use_device(type) {
	    var is_mobile = m_compat.detect_mobile();
	    if (type == DEVICE_HMD && !navigator.getVRDevices &&
	            !navigator.getVRDisplays && !(is_mobile && check_fullscreen()) ||
	            type == DEVICE_GYRO && !(is_mobile && window.DeviceOrientationEvent))
	        return false;
	    else
	        return true;
	}

	function init_device(type, element) {
	    if (!can_use_device(type))
	        return null;

	    var device = {
	        type: type,

	        // Is device registered for listening statement changes?
	        registered: false,

	        // gyro callbacks
	        orientation_quat_cb_list: [],
	        orientation_angles_cb_list: [],

	        // mouse callbacks
	        mouse_down_which_cb_list: [],
	        mouse_location_cb_list: [],
	        mouse_up_which_cb_list: [],
	        mouse_wheel_cb_list: [],

	        // keyboard callbacks
	        keyboard_down_cb_list: [],
	        keyboard_down_mod_cb_list: [],
	        keyboard_up_cb_list: [],

	        // touch callbacks
	        touch_start_cb_list: [],
	        touch_move_cb_list: [],
	        touch_end_cb_list: [],

	        element: element,
	        prevent_default: true,
	        registered_event_listeners: [],

	        mouse_location: new Float32Array(2),
	        mouse_which: 0,

	        // HMD properties
	        distortion_coefs           : new Float32Array(2),
	        chromatic_aberration_coefs : new Float32Array(4),
	        // WebVR properties
	        registered_cb: null,
	        webvr_hmd_device: null,
	        webvr_sensor_devices: null,
	        // WebVR 1.0 properties
	        webvr_display: null,
	        orientation: m_quat.create(),
	        position: m_vec3.create(),

	        // WebVR 1.1 properties
	        frame_data: window.VRFrameData? new VRFrameData(): null,
	        standing_tsr: m_tsr.create(),

	        // non-WebVR HMD properties
	        fov_left                   : new Float32Array(4),
	        fov_right                  : new Float32Array(4),
	        inter_lens_dist            : 0.0,
	        base_line_dist             : 0.0,
	        screen_to_lens_dist        : 0.0,

	        // mobile properties
	        width_dist                 : 0.0,
	        height_dist                : 0.0,
	        bevel_size                 : 0.0,

	        // gamepad properties
	        gamepad_btns               : [],
	        gamepad_axes               : [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
	        gamepad_prev_axes          : [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
	        gamepad_mapping            : []

	    };

	    // default value
	    device.fov_left[0] = device.fov_left[1] = device.fov_left[2] = device.fov_left[3] = Math.PI/4;
	    device.fov_right[0] = device.fov_right[1] = device.fov_right[2] = device.fov_right[3] = Math.PI/4;

	    if (type == DEVICE_MOUSE || type == DEVICE_KEYBOARD || type == DEVICE_TOUCH) {
	        device.registered = Boolean(element);
	        if (type == DEVICE_TOUCH)
	            // HACK: fix touch events issue on some mobile devices
	            document.addEventListener("touchstart", function(){});
	        else if (type == DEVICE_KEYBOARD)
	            device.prevent_default = false;
	    } else if (type == DEVICE_GYRO)
	        device.registered = true;
	    else if (type == DEVICE_HMD)
	        request_register_device(device);

	    return device;
	}

	exports.init = function() {
	    if (cfg_def.stereo == "HMD" || (cfg_def.stereo == "NONE" && cfg_def.is_mobile_device)) {
	        var device = get_device_by_type_element(DEVICE_HMD);
	        if (device) {
	            // WebVR 1.1
	            // NOTE: examples of usage onvrdisplayconnect/onvrdisplaydisconnect
	            // events are not provided by contributers of WebVR specification yet.
	            // TODO: add onvrdisplaydisconnect handler
	            // See https://w3c.github.io/webvr/#interface-vrdisplayevent
	            document.addEventListener("onvrdisplayconnect", function(event) {
	                device.webvr_display = event.display;
	                device.registered = true;
	                device.webvr_display.getFrameData(device.frame_data);
	            });
	        }
	    }
	};

	exports.get_device_by_type_element = get_device_by_type_element;
	function get_device_by_type_element(type, element) {
	    if (type == DEVICE_GYRO || type == DEVICE_HMD)
	        element = window;
	    else if (!element)
	        if (type == DEVICE_KEYBOARD)
	            element = document;
	        else
	            element = m_cont.get_container();

	    for (var i = 0; i < _devices.length; i++)
	        if (_devices[i].type == type && _devices[i].element == element)
	            return _devices[i];

	    var device = init_device(type, element);

	    if (type == DEVICE_GAMEPAD0 || type == DEVICE_GAMEPAD1 ||
	            type == DEVICE_GAMEPAD2 || type == DEVICE_GAMEPAD3)
	        set_gamepad_mapping(device);

	    if (device)
	        _devices.push(device);
	    return device;
	}

	exports.request_register_device = request_register_device;
	function request_register_device(device) {
	    if (device.type == DEVICE_HMD) {
	        if (navigator.getVRDisplays) {
	            navigator.getVRDisplays().then(
	                function (displays) {
	                    if (displays.length > 0) {
	                        device.webvr_display = displays[0];
	                        device.registered = true;
	                        device.webvr_display.getFrameData(device.frame_data);

	                        if (device.registered_cb)
	                            device.registered_cb();
	                    }
	                }, function(error) {
	                    m_print.error_once("WebVR displays are not found.");
	                    device.registered = false;
	                }
	            );
	            // NOTE: don't do distortion correction, it will be done by browser
	        } else if (navigator.getVRDevices) {
	            navigator.getVRDevices().then(
	                function(webvr_devices) {
	                    setup_webvr_devices(device, webvr_devices);
	                    if (webvr_devices.length)
	                        device.registered = true;

	                        if (device.registered_cb)
	                            device.registered_cb();
	                }, function(error) {
	                    m_print.error_once("WebVR devices are not found.");
	                    device.registered = false;
	                }
	            );

	            setup_distortion_coef(device, cfg_hmdp["webvr"]);
	        } else {
	            setup_nonwebvr_hmd_device(device);
	            device.registered = true;
	        }
	    }
	}

	function set_gamepad_mapping(device) {
	    device.gamepad_mapping.push(exports.GMPD_BUTTON_0, exports.GMPD_BUTTON_1,
	            exports.GMPD_BUTTON_2, exports.GMPD_BUTTON_3, exports.GMPD_BUTTON_4,
	            exports.GMPD_BUTTON_5, exports.GMPD_BUTTON_6, exports.GMPD_BUTTON_7,
	            exports.GMPD_BUTTON_8, exports.GMPD_BUTTON_9, exports.GMPD_BUTTON_10,
	            exports.GMPD_BUTTON_11, exports.GMPD_BUTTON_12, exports.GMPD_BUTTON_13,
	            exports.GMPD_BUTTON_14, exports.GMPD_BUTTON_15, exports.GMPD_BUTTON_16,
	            exports.GMPD_BUTTON_17, exports.GMPD_BUTTON_18, exports.GMPD_BUTTON_19,
	            exports.GMPD_BUTTON_20, exports.GMPD_BUTTON_21, exports.GMPD_BUTTON_22,
	            exports.GMPD_BUTTON_23, exports.GMPD_BUTTON_24, exports.GMPD_BUTTON_25,
	            exports.GMPD_AXIS_0, exports.GMPD_AXIS_1, exports.GMPD_AXIS_2,
	            exports.GMPD_AXIS_3, exports.GMPD_AXIS_4, exports.GMPD_AXIS_5,
	            exports.GMPD_AXIS_6, exports.GMPD_AXIS_7, exports.GMPD_AXIS_8,
	            exports.GMPD_AXIS_9, exports.GMPD_AXIS_10, exports.GMPD_AXIS_11);
	}

	exports.switch_prevent_default = function(device, prevent_default) {
	    device.prevent_default = prevent_default;
	};

	function setup_nonwebvr_hmd_device(device) {
	    var device_params = cfg_hmdp["nonwebvr"];
	    device.width_dist = device_params.width_dist;
	    device.height_dist = device_params.height_dist;
	    device.bevel_size = device_params.bevel_size;

	    setup_distortion_coef(device, device_params);

	    device.inter_lens_dist = device_params.inter_lens_dist;
	    device.base_line_dist = device_params.base_line_dist;
	    device.screen_to_lens_dist = device_params.screen_to_lens_dist;

	    update_nonwebvr_fov(device);
	}

	function setup_distortion_coef(device, device_params) {
	    device.distortion_coefs[0] = device_params.distortion_coefs[0],
	    device.distortion_coefs[1] = device_params.distortion_coefs[1];

	    device.chromatic_aberration_coefs[0] = device_params.chromatic_aberration_coefs[0];
	    device.chromatic_aberration_coefs[1] = device_params.chromatic_aberration_coefs[1];
	    device.chromatic_aberration_coefs[2] = device_params.chromatic_aberration_coefs[2];
	    device.chromatic_aberration_coefs[3] = device_params.chromatic_aberration_coefs[3];
	}

	function update_nonwebvr_fov(device) {
	    var inner_dist  = device.inter_lens_dist / 2;
	 
	    var inner_tang = inner_dist / device.screen_to_lens_dist;
	    var inner_angle = Math.atan(inner_tang * cfg_hmdp["nonwebvr"].distor_scale);
	    var outer_angle = inner_angle;
	    var bottom_angle = inner_angle;
	    var top_angle = inner_angle;

	    // NOTE: PI/3...I don't know why
	    if (top_angle)
	        device.fov_left[0] = device.fov_right[0] = Math.min(top_angle, Math.PI/3);
	    if (inner_angle)
	        device.fov_left[1] = device.fov_right[3] = Math.min(inner_angle, Math.PI/3);
	    if (bottom_angle)
	        device.fov_left[2] = device.fov_right[2] = Math.min(bottom_angle, Math.PI/3);
	    if (outer_angle)
	        device.fov_left[3] = device.fov_right[1] = Math.min(outer_angle, Math.PI/3);
	}

	function setup_webvr_devices(device, webvr_devices) {
	    var webvr_hmd_devices = webvr_devices.filter(function(device) {
	        return device instanceof HMDVRDevice;
	    });

	    var webvr_hmd_device = null;
	    if (webvr_hmd_devices.length) {
	        // get first hmd device
	        webvr_hmd_device = webvr_hmd_devices[0];
	    }

	    var webvr_sensor_devices = null;
	    if (webvr_hmd_device) {
	        webvr_sensor_devices = webvr_devices.filter(function(webvr_device) {
	            return webvr_device.deviceName.toLowerCase().indexOf("oculus") !== -1 &&
	                    webvr_device.hardwareUnitId == webvr_hmd_device.hardwareUnitId &&
	                    webvr_device instanceof PositionSensorVRDevice;
	        });
	    }

	    device.webvr_hmd_device = webvr_hmd_device;
	    device.webvr_sensor_devices = webvr_sensor_devices;
	}

	exports.reset_device = reset_device;
	function reset_device(device) {
	    switch (device.type) {
	    case DEVICE_HMD:
	        if (device.registered)
	            if (device.webvr_display)
	                device.webvr_display.resetPose();
	            else if (device.webvr_sensor_devices)
	                for (var i = 0; i < device.webvr_sensor_devices.length; i++) {
	                    var webvr_device = device.webvr_sensor_devices[i];
	                    webvr_device.resetSensor();
	                }
	        break;
	    default:
	        m_print.error("reset_device() is undefined for device: ", device.type);
	        return;
	    }
	}

	function get_fov(device, eye, dest) {
	    switch (device.type) {
	    case DEVICE_HMD:
	        var type = get_value_param(device, HMD_WEBVR_TYPE);
	        if (type & HMD_NON_WEBVR) {
	            if (eye == "left")
	                var fov = device.fov_left;
	            else
	                var fov = device.fov_right;

	            m_vec4.copy(fov, dest);
	        } else {
	            var webvr_display = device.webvr_display || device.webvr_hmd_device;
	            if (webvr_display) {
	                var param = webvr_display.getEyeParameters(eye);
	                var fov = param.fieldOfView || param.currentFieldOfView;
	                // It seems param.fieldOfView can be null in last version of Chromium
	                // despite of https://w3c.github.io/webvr/spec/1.1/#interface-vreyeparameters
	                if (fov) {
	                    dest[0] = m_util.deg_to_rad(fov["upDegrees"]);
	                    dest[1] = m_util.deg_to_rad(fov["rightDegrees"]);
	                    dest[2] = m_util.deg_to_rad(fov["downDegrees"]);
	                    dest[3] = m_util.deg_to_rad(fov["leftDegrees"]);
	                } else {
	                    if (type & HMD_WEBVR1_1) {
	                        var proj_mat = _mat4_tmp;
	                        if (eye == "left")
	                            m_mat4.copy(device.frame_data.leftProjectionMatrix, proj_mat);
	                        else
	                            m_mat4.copy(device.frame_data.rightProjectionMatrix, proj_mat);
	                        // var inv_proj_mat = m_mat4.invert(proj_mat, proj_mat);
	                        // var right_top_near = m_vec3.transformMat4([1, 1, -1], inv_proj_mat, _vec3_tmp);

	                        dest[0] = Math.atan(- _vec3_tmp[1] / _vec3_tmp[2]);
	                        dest[1] = Math.atan(- _vec3_tmp[0] / _vec3_tmp[2]);
	                        // var left_down_near = m_vec3.transformMat4([-1, -1, -1], inv_proj_mat, _vec3_tmp);
	                        dest[2] = Math.atan(_vec3_tmp[1] / _vec3_tmp[2]);
	                        dest[3] = Math.atan(_vec3_tmp[0] / _vec3_tmp[2]);
	                    }
	                }
	            }
	        }
	        break;
	    default:
	        m_print.error("fov is undefined for device: ", device.type);
	        break;
	    }

	    return dest;
	}

	function get_proj(device, eye, dest) {
	    switch (device.type) {
	    case DEVICE_HMD:
	        var webvr_display = device.webvr_display;
	        if (webvr_display) {
	            if (eye == "left")
	                m_mat4.copy(device.frame_data.leftProjectionMatrix, dest);
	            else if (eye == "right")
	                m_mat4.copy(device.frame_data.rightProjectionMatrix, dest);
	            else
	                m_print.error("Unknown type of eye: ", eye);
	        }
	        break;
	    default:
	        m_print.error("Projection matrix is undefined for device: ", device.type);
	        break;
	    }
	    return dest;
	}

	//==============================================================================
	//                        sync:  get_value_param
	//                               get_vector_param
	//                        async: attach_param_cb
	//                               detach_param_cb
	//==============================================================================

	exports.get_vector_param = function(device, param, dest) {
	    switch(param) {
	    case HMD_ORIENTATION_QUAT:
	        return get_orientation_quat(device, dest);
	    case HMD_POSITION:
	        return get_position(device, dest);
	    case HMD_FOV_LEFT:
	        return get_fov(device, "left", dest);
	    case HMD_FOV_RIGHT:
	        return get_fov(device, "right", dest);
	    case HMD_PROJ_LEFT:
	        return get_proj(device, "left", dest);
	    case HMD_PROJ_RIGHT:
	        return get_proj(device, "right", dest);
	    case MOUSE_LOCATION:
	    case MOUSE_LOCATION_PL:
	        dest[0] = device.mouse_location[0];
	        dest[1] = device.mouse_location[1];
	        return dest;
	    }
	};

	exports.get_value_param = get_value_param;
	function get_value_param(device, param) {
	    switch(param) {
	    case HMD_WEBVR_TYPE:
	        var type = 0;
	        if (navigator.getVRDisplays) {
	            type |= HMD_WEBVR1;
	            if (device.frame_data)
	                type |= HMD_WEBVR1_1;
	        }
	        if (navigator.getVRDevices) {
	            if (cfg_def.is_mobile_device)
	                type |= HMD_WEBVR_MOBILE;
	            else
	                type |= HMD_WEBVR_DESKTOP;
	        }
	        type = type || HMD_NON_WEBVR;
	        return type;
	    case HMD_EYE_DISTANCE:
	        var webvr_display = device.webvr_display || device.webvr_hmd_device;
	        if (webvr_display) {
	            var param_left = webvr_display.getEyeParameters("left");
	            var param_right = webvr_display.getEyeParameters("right");
	            if (device.webvr_display) {
	                // NOTE: using WebVR 1.*
	                return param_right["offset"][0] - param_left["offset"][0];
	            } else {
	                // NOTE: using WebVR
	                return param_right.eyeTranslation["x"] - param_left.eyeTranslation["x"];
	            }
	        } else
	            return device.inter_lens_dist;
	    }
	}

	exports.set_config = function(device, config, value) {
	    switch(device.type) {
	    case DEVICE_HMD:
	        if (get_value_param(device, HMD_WEBVR_TYPE) & HMD_WEBVR1)
	            break;
	        switch(config) {
	        case HMD_DISTORTION:
	            device.distortion_coefs[0] = value[0];
	            device.distortion_coefs[1] = value[1];
	            break;
	        case HMD_EYE_DISTANCE:
	            device.inter_lens_dist = value;
	            update_nonwebvr_fov(device);
	            break;
	        case HMD_BASELINE_DIST:
	            device.base_line_dist = value;
	            update_nonwebvr_fov(device);
	            break;
	        case HMD_SCREEN_LENS_DIST:
	            device.screen_to_lens_dist = value;
	            update_nonwebvr_fov(device);
	            break;
	        case HMD_SCREEN_WIDTH:
	            device.width_dist = value;
	            update_nonwebvr_fov(device);
	            break;
	        case HMD_SCREEN_HEIGHT:
	            device.height_dist = value;
	            update_nonwebvr_fov(device);
	            break;
	        case HMD_BEVEL_SIZE:
	            device.bevel_size = value;
	            update_nonwebvr_fov(device);
	            break;
	        }
	        break;
	    case DEVICE_GAMEPAD0:
	    case DEVICE_GAMEPAD1:
	    case DEVICE_GAMEPAD2:
	    case DEVICE_GAMEPAD3:
	        device.gamepad_mapping[config] = value;
	        break;
	    }
	};

	exports.get_gamepad_btn_value = function(device, btn) {
	    var real_btn = btn - GMPD_BTNS_OFFSET;
	    if (real_btn < device.gamepad_btns.length)
	        return device.gamepad_btns[get_gamepad_btn_key(device, real_btn) -
	                GMPD_BTNS_OFFSET];
	    else
	        return false;
	};

	exports.get_gamepad_axis_value = function(device, btn) {
	    var real_axis = btn - GMPD_BTNS_OFFSET;
	    if (btn - GMPD_AXIS_OFFSET < device.gamepad_axes.length) {
	        return device.gamepad_axes[get_gamepad_btn_key(device, real_axis) -
	                GMPD_AXIS_OFFSET];
	    } else
	        return 0;
	};

	exports.get_gamepad_position = function(device, dest) {
	    dest.set(device.position);
	    return dest;
	};

	exports.get_gamepad_orientation = function(device, dest) {
	    dest.set(device.orientation);
	    return dest;
	};

	exports.update = function(timeline) {
	    var gamepads = navigator.getGamepads ? navigator.getGamepads() :
	            (navigator.webkitGetGamepads ? navigator.webkitGetGamepads : []);
	    for (var i = 0; i < _devices.length; i++) {
	        var device = _devices[i];
	        switch(device.type) {
	        case DEVICE_GAMEPAD0:
	            clear_gamepad_device(device);
	            update_gamepad_device(gamepads[0], device);
	            break;
	        case DEVICE_GAMEPAD1:
	            clear_gamepad_device(device);
	            update_gamepad_device(gamepads[1], device);
	            break;
	        case DEVICE_GAMEPAD2:
	            clear_gamepad_device(device);
	            update_gamepad_device(gamepads[2], device);
	            break;
	        case DEVICE_GAMEPAD3:
	            clear_gamepad_device(device);
	            update_gamepad_device(gamepads[3], device);
	            break;
	        case DEVICE_HMD:
	            update_hmd(device, timeline);
	            break;
	        }
	    }
	};

	function update_hmd(device, timeline) {
	    if (device.webvr_display) {
	        // NOTE: update position and orientation only one time per frame
	        // to prevent strange behavior of WebVR API 1.0
	        var display = device.webvr_display;
	        // var capabilities = display.capabilities;

	        if (device.frame_data && display.getFrameData(device.frame_data)) {
	            var webvr_pose = device.frame_data.pose;

	            // NOTE: we just take offset between eyes
	            var l_trans = m_util.matrix_to_trans(device.frame_data.leftViewMatrix, _vec3_tmp);
	            device.inter_lens_dist = 2 * m_vec3.length(l_trans);
	        } else
	            var webvr_pose = display.getPose();

	        if (webvr_pose) {
	            var rot_X_quat = m_quat.setAxisAngle(m_util.AXIS_X, Math.PI / 2, _quat_tmp);

	            if (display["stageParameters"] &&
	                    display["stageParameters"]["sittingToStandingTransform"]) {
	                var standing_tsr = m_tsr.from_mat4(
	                        display["stageParameters"]["sittingToStandingTransform"],
	                        _tsr_tmp);

	                m_tsr.identity(_tsr_tmp2);
	                var rot_X_tsr = m_tsr.set_quat(rot_X_quat, _tsr_tmp2);

	                standing_tsr = m_tsr.multiply(rot_X_tsr, standing_tsr, device.standing_tsr);
	            } else {
	                m_tsr.identity(_tsr_tmp);
	                var standing_tsr = m_tsr.set_quat(rot_X_quat, device.standing_tsr);
	            }

	            // capabilities.hasOrientation is undefined in the last version of Chromium
	            // despite of https://w3c.github.io/webvr/spec/1.1/#interface-vrdisplaycapabilities
	            if (webvr_pose.orientation)
	                m_tsr.transform_quat(webvr_pose.orientation, standing_tsr,
	                        device.orientation);

	            // don't use capabilities.hasPosition bcz it may be undefined
	            // in the future like capabilities.hasOrientation.
	            if (webvr_pose.position)
	                m_tsr.transform_vec3(webvr_pose.position, standing_tsr,
	                        device.position);
	        }
	    }
	}

	function update_gamepad_device(gamepad, device) {
	    if (gamepad) {
	        for (var i = 0; i < gamepad["buttons"].length; i++) {
	            device.gamepad_btns[i] = gamepad["buttons"][i]["value"] ||
	                    +gamepad["buttons"][i]["pressed"];
	        }

	        if (gamepad["axes"])
	            for (var i = 0; i < gamepad["axes"].length; i++)
	                device.gamepad_axes[i] = gamepad["axes"][i];

	        var pose = gamepad["pose"];
	        if (pose) {
	            var hmd_device = get_device_by_type_element(DEVICE_HMD);
	            var standing_tsr = hmd_device.standing_tsr;
	            if (pose["position"])
	                m_tsr.transform_vec3(pose["position"], standing_tsr,
	                        device.position);

	            if (pose["orientation"])
	                m_tsr.transform_quat(pose["orientation"], standing_tsr,
	                        device.orientation);
	        }
	    }
	}

	function clear_gamepad_device(device) {
	    for (var i = 0; i < device.gamepad_btns; i++)
	        device.gamepad_btns[i] = 0;
	    for (var i = 0; i < device.gamepad_axes.length; i++) {
	        device.gamepad_prev_axes[i] = device.gamepad_axes[i];
	        device.gamepad_axes[i] = 0;
	    }

	    device.position.set(m_util.VEC3_IDENT);
	    device.orientation.set(m_util.QUAT4_IDENT);
	}

	exports.attach_param_cb = function(device, param, cb) {
	    switch(param) {
	    case GYRO_ORIENTATION_QUAT:
	        device.orientation_quat_cb_list.push(cb);
	        param = DEVICE_ORIENTATION;
	        break;
	    case GYRO_ORIENTATION_ANGLES:
	        device.orientation_angles_cb_list.push(cb);
	        param = DEVICE_ORIENTATION;
	        break;
	    case MOUSE_DOWN_WHICH:
	        device.mouse_down_which_cb_list.push(cb);
	        break;
	    case MOUSE_LOCATION:
	    case MOUSE_LOCATION_PL:
	        device.mouse_location_cb_list.push(cb);
	        break;
	    case MOUSE_UP_WHICH:
	        device.mouse_up_which_cb_list.push(cb);
	        break;
	    case MOUSE_WHEEL:
	        device.mouse_wheel_cb_list.push(cb);
	        break;
	    case KEYBOARD_DOWN:
	        device.keyboard_down_cb_list.push(cb);
	        break;
	    case KEYBOARD_DOWN_MODIFIED:
	        device.keyboard_down_mod_cb_list.push(cb);
	        param = KEYBOARD_DOWN;
	        break;
	    case KEYBOARD_UP:
	        device.keyboard_up_cb_list.push(cb);
	        break;
	    case TOUCH_START:
	        device.touch_start_cb_list.push(cb);
	        break;
	    case TOUCH_MOVE:
	        device.touch_move_cb_list.push(cb);
	        break;
	    case TOUCH_END:
	        device.touch_end_cb_list.push(cb);
	        break;
	    }

	    if (device.registered_event_listeners.indexOf(param) == -1) {
	        device.registered_event_listeners.push(param);
	        if (device.registered)
	            register_event_listener(device, param);
	    }
	};

	function replace_cb_with_null(cb_list, cb) {
	    var cb_index = cb_list.indexOf(cb);
	    if (cb_index >= 0)
	        cb_list[cb_index] = null;
	}

	function is_null(x) {
	    return x === null;
	}

	exports.detach_param_cb = function(device, param, cb) {
	    unregister_event_listener(device, param, cb, false);
	};


	function unregister_event_listener(device, param, cb, force) {
	    switch(param) {
	    case GYRO_ORIENTATION_QUAT:
	        cb && replace_cb_with_null(device.orientation_quat_cb_list, cb);
	        if (force || (device.orientation_angles_cb_list.every(is_null) &&
	                device.orientation_quat_cb_list.every(is_null))) {
	            device.orientation_quat_cb_list.length = 0;
	            device.orientation_angles_cb_list.length = 0;

	            param = DEVICE_ORIENTATION;
	            var param_index = device.registered_event_listeners.indexOf(param);
	            if (param_index >= 0) {
	                device.registered_event_listeners.splice(param_index, 1);
	                device.element.removeEventListener("deviceorientation", device_orientation_cb, false);
	            }
	        }
	        break;
	    case GYRO_ORIENTATION_ANGLES:
	        cb && replace_cb_with_null(device.orientation_angles_cb_list, cb);
	        if (force || (device.orientation_angles_cb_list.every(is_null) &&
	                device.orientation_quat_cb_list.every(is_null))) {
	            device.orientation_quat_cb_list.length = 0;
	            device.orientation_angles_cb_list.length = 0;

	            param = DEVICE_ORIENTATION;
	            var param_index = device.registered_event_listeners.indexOf(param);
	            if (param_index >= 0) {
	                device.registered_event_listeners.splice(param_index, 1);
	                device.element.removeEventListener("deviceorientation", device_orientation_cb, false);
	            }
	        }
	        break;
	    case MOUSE_DOWN_WHICH:
	        cb && replace_cb_with_null(device.mouse_down_which_cb_list, cb);
	        if (force || device.mouse_down_which_cb_list.every(is_null)) {
	            device.mouse_down_which_cb_list.length = 0;

	            var param_index = device.registered_event_listeners.indexOf(param);
	            if (param_index >= 0) {
	                device.registered_event_listeners.splice(param_index, 1);
	                device.element.removeEventListener("mousedown", mouse_down_cb, false);
	            }
	        }
	        break;
	    case MOUSE_LOCATION:
	        cb && replace_cb_with_null(device.mouse_location_cb_list, cb);
	        if (force || device.mouse_location_cb_list.every(is_null)) {
	            device.mouse_location_cb_list.length = 0;

	            var param_index = device.registered_event_listeners.indexOf(param);
	            if (param_index >= 0) {
	                device.registered_event_listeners.splice(param_index, 1);
	                device.element.removeEventListener("mousemove", mouse_move_cb, false);
	            }
	        }
	        break;
	    case MOUSE_LOCATION_PL:
	        cb && replace_cb_with_null(device.mouse_location_cb_list, cb);
	        if (force || device.mouse_location_cb_list.every(is_null)) {
	            device.mouse_location_cb_list.length = 0;

	            var param_index = device.registered_event_listeners.indexOf(param);
	            if (param_index >= 0) {
	                device.registered_event_listeners.splice(param_index, 1);
	                device.element.removeEventListener("mousemove", pointerlock_cb, false);
	            }
	        }
	        break;
	    case MOUSE_UP_WHICH:
	        cb && replace_cb_with_null(device.mouse_up_which_cb_list, cb);
	        if (force || device.mouse_up_which_cb_list.every(is_null)) {
	            device.mouse_up_which_cb_list.length = 0;

	            var param_index = device.registered_event_listeners.indexOf(param);
	            if (param_index >= 0) {
	                device.registered_event_listeners.splice(param_index, 1);
	                device.element.removeEventListener("mouseout", mouse_out_cb, false);
	                device.element.removeEventListener("mouseup", mouse_up_cb, false);
	            }
	            break;
	        }
	        break;
	    case MOUSE_WHEEL:
	        cb && replace_cb_with_null(device.mouse_wheel_cb_list, cb);
	        if (force || device.mouse_wheel_cb_list.every(is_null)) {
	            device.mouse_wheel_cb_list.length = 0;

	            var param_index = device.registered_event_listeners.indexOf(param);
	            if (param_index >= 0) {
	                device.registered_event_listeners.splice(param_index, 1);
	                device.element.removeEventListener("wheel", mouse_wheel_cb, false);
	            }
	        }
	        break;
	    case KEYBOARD_DOWN:
	        cb && replace_cb_with_null(device.keyboard_down_cb_list, cb);
	        if (force || device.keyboard_down_cb_list.every(is_null)) {
	            device.keyboard_down_cb_list.length = 0;

	            var param_index = device.registered_event_listeners.indexOf(param);
	            if (param_index >= 0) {
	                device.registered_event_listeners.splice(param_index, 1);
	                device.element.removeEventListener("keydown", keyboard_down_cb, false);
	            }
	        }
	        break;
	    case KEYBOARD_UP:
	        cb && replace_cb_with_null(device.keyboard_up_cb_list, cb);
	        if (force || device.keyboard_up_cb_list.every(is_null)) {
	            device.keyboard_up_cb_list.length = 0;

	            var param_index = device.registered_event_listeners.indexOf(param);
	            if (param_index >= 0) {
	                device.registered_event_listeners.splice(param_index, 1);
	                device.element.removeEventListener("keyup", keyboard_up_cb, false);
	            }
	        }
	        break;
	    case TOUCH_START:
	        cb && replace_cb_with_null(device.touch_start_cb_list, cb);
	        if (force || device.touch_start_cb_list.every(is_null)) {
	            device.touch_start_cb_list.length = 0;

	            var param_index = device.registered_event_listeners.indexOf(param);
	            if (param_index >= 0) {
	                device.registered_event_listeners.splice(param_index, 1);
	                device.element.removeEventListener("touchstart", touch_start_cb, false);
	            }
	        }
	        break;
	    case TOUCH_MOVE:
	        cb && replace_cb_with_null(device.touch_move_cb_list, cb);
	        if (force || device.touch_move_cb_list.every(is_null)) {
	            device.touch_move_cb_list.length = 0;

	            var param_index = device.registered_event_listeners.indexOf(param);
	            if (param_index >= 0) {
	                device.registered_event_listeners.splice(param_index, 1);
	                device.element.removeEventListener("touchmove", touch_move_cb, false);
	            }
	        }
	        break;
	    case TOUCH_END:
	        cb && replace_cb_with_null(device.touch_end_cb_list, cb);
	        if (force || device.touch_end_cb_list.every(is_null)) {
	            device.touch_end_cb_list.length = 0;

	            var param_index = device.registered_event_listeners.indexOf(param);
	            if (param_index >= 0) {
	                device.registered_event_listeners.splice(param_index, 1);
	                device.element.removeEventListener("touchend", touch_end_cb, false);
	            }
	        }
	        break;
	    }
	}

	function is_ios() {
	    return /iPad|iPhone|iPod/.test(navigator.platform);
	}

	function register_event_listener(device, event_name) {
	    switch (event_name) {
	    case MOUSE_DOWN_WHICH:
	        if (!is_ios())
	            device.element.addEventListener("mousedown", mouse_down_cb, false);
	        break;
	    case MOUSE_LOCATION:
	        device.element.addEventListener("mousemove", mouse_move_cb, false);
	        break;
	    case MOUSE_LOCATION_PL:
	        device.element.addEventListener("mousemove", pointerlock_cb, false);
	        break;
	    case MOUSE_UP_WHICH:
	        if (!is_ios()) {
	            if (device.element != window)
	                device.element.addEventListener("mouseout", mouse_out_cb, false);
	            device.element.addEventListener("mouseup", mouse_up_cb, false);
	        }
	        break;
	    case MOUSE_WHEEL:
	        device.element.addEventListener("wheel", mouse_wheel_cb, false);
	        break;
	    case KEYBOARD_DOWN:
	        device.element.addEventListener("keydown", keyboard_down_cb, false);
	        break;
	    case KEYBOARD_UP:
	        device.element.addEventListener("keyup", keyboard_up_cb, false);
	        break;
	    case TOUCH_START:
	        device.element.addEventListener("touchstart", touch_start_cb, false);
	        break;
	    case TOUCH_MOVE:
	        device.element.addEventListener("touchmove", touch_move_cb, false);
	        break;
	    case TOUCH_END:
	        device.element.addEventListener("touchend", touch_end_cb, false);
	        break;
	    case DEVICE_ORIENTATION:
	        device.element.addEventListener("deviceorientation", device_orientation_cb, false);
	        break;
	    }
	}

	function get_orientation_quat(device, dest) {
	    switch (device.type) {
	    case DEVICE_HMD:
	        m_vec3.copy(m_util.QUAT4_IDENT, dest);
	        if (device.webvr_display) {
	            dest[0] = device.orientation[0];
	            dest[1] = device.orientation[1];
	            dest[2] = device.orientation[2];
	            dest[3] = device.orientation[3];
	            
	        } else if (device.webvr_sensor_devices) {
	            for (var i = 0; i < device.webvr_sensor_devices.length; i++) {
	                var webvr_sensor_device = device.webvr_sensor_devices[i];
	                var webvr_state = webvr_sensor_device.getState &&
	                        webvr_sensor_device.getState() ||
	                        webvr_sensor_device.getImmediateState &&
	                        webvr_sensor_device.getImmediateState();
	                if (webvr_state.orientation) {
	                    dest[0] = webvr_state.orientation["x"];
	                    dest[1] = webvr_state.orientation["y"];
	                    dest[2] = webvr_state.orientation["z"];
	                    dest[3] = webvr_state.orientation["w"];
	                }
	            }
	        }

	        return dest;
	    default:
	        m_print.error("orientation_quat is undefined for device: ", device.type);
	        return dest;
	    }
	}

	function get_position(device, dest) {
	    switch (device.type) {
	    case DEVICE_HMD:
	        m_vec3.copy(m_util.VEC3_UNIT, dest);
	        if (device.webvr_display) {
	            dest[0] = device.position[0];
	            dest[1] = device.position[1];
	            dest[2] = device.position[2];
	        } else if (device.webvr_sensor_devices) {
	            for (var i = 0; i < device.webvr_sensor_devices.length; i++) {
	                var webvr_sensor_device = device.webvr_sensor_devices[i];
	                var webvr_state = webvr_sensor_device.getState &&
	                        webvr_sensor_device.getState() ||
	                        webvr_sensor_device.getImmediateState &&
	                        webvr_sensor_device.getImmediateState();

	                if (webvr_state.position) {
	                    dest[0] = webvr_state.position["x"];
	                    dest[1] = -webvr_state.position["z"];
	                    dest[2] = webvr_state.position["y"];
	                }
	            }
	        }
	        return dest;
	    default:
	        m_print.error("position is undefined for device: ", device.type);
	        return dest;
	    }
	}

	exports.gyro_angles_to_quat = gyro_angles_to_quat;
	function gyro_angles_to_quat(angles, dest) {
	    // NOTE: Euler rotation sequence for deviceorientation event is ZXY
	    // see http://w3c.github.io/deviceorientation/spec-source-orientation.html
	    m_util.ordered_angles_to_quat(angles, m_util.ZXY, dest);

	    // NOTE: window.orientation deprecated
	    // see https://developer.mozilla.org/en-US/docs/Web/API/Window/orientation
	    // NOTE: use window["screen"] and ignore obfuscation
	    if ("orientation" in window)
	        var screen_orient = m_util.deg_to_rad(window["orientation"]);
	    else if ("orientation" in window["screen"])
	        var screen_orient = m_util.deg_to_rad(window["screen"]["orientation"]["angle"]);
	    else
	        var screen_orient = 0;

	    var screen_quat = m_quat.setAxisAngle(m_util.AXIS_MZ,
	            screen_orient, _quat_tmp2);
	    m_quat.multiply(dest, screen_quat, dest);
	    return dest;
	}

	function device_orientation_cb(event) {
	    var euler_angles = _vec3_tmp;

	    // https://www.w3.org/TR/orientation-event/#deviceorientation
	    // alpha, beta, gamma might be null
	    if (event.alpha === null || event.beta === null || event.gamma === null)
	        euler_angles[0] = euler_angles[1] = euler_angles[2] = 0.0;
	    else {
	        euler_angles[0] = m_util.deg_to_rad(event.alpha);
	        euler_angles[1] = m_util.deg_to_rad(event.beta);
	        euler_angles[2] = m_util.deg_to_rad(event.gamma);
	    }
	    var device = get_device_by_type_element(DEVICE_GYRO, event.currentTarget);
	    for (var i = 0; i < device.orientation_angles_cb_list.length; i++) {
	        var cb = device.orientation_angles_cb_list[i];
	        if (cb) {
	            m_vec3.copy(euler_angles, _angles);
	            cb(_angles);
	        }
	    }

	    if (device.orientation_quat_cb_list.length) {
	        // Angles are changed. Recalculate quaternion.
	        var quaternion = gyro_angles_to_quat(euler_angles, _quat_tmp);

	        for (var i = 0; i < device.orientation_quat_cb_list.length; i++) {
	            var cb = device.orientation_quat_cb_list[i];
	            if (cb) {
	                m_quat.copy(quaternion, _quat);
	                cb(_quat);
	            }
	        }
	    }

	    // remove unused callbacks
	    for (var i = 0; i < device.orientation_quat_cb_list.length; i++)
	        if (!device.orientation_quat_cb_list[i])
	            device.orientation_quat_cb_list.splice(i, 1);
	    for (var i = 0; i < device.orientation_angles_cb_list.length; i++)
	        if (!device.orientation_angles_cb_list[i])
	            device.orientation_angles_cb_list.splice(i, 1);
	}

	function update_device(device, event) {
	    switch (device.type) {
	    case DEVICE_MOUSE:
	        device.mouse_location[0] = event.clientX;
	        device.mouse_location[1] = event.clientY;
	        device.mouse_which = event.which;
	        break;
	    }
	}

	function mouse_move_cb(event) {
	    if (_exist_touch) {
	        // optimization for Chrome
	        // See https://developer.mozilla.org/en-US/docs/Web/API/InputDeviceCapabilities
	        if (event.sourceCapabilities && event.sourceCapabilities.firesTouchEvents)
	            return;

	        // optimization for Firefox
	        // See https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/mozInputSource
	        // event.mozInputSource == 5 means that the event was generated by touch.
	        if (event.mozInputSource == 5)
	            return;
	    }

	    var device = get_device_by_type_element(DEVICE_MOUSE, event.currentTarget);
	    update_device(device, event);

	    for (var i = 0; i < device.mouse_location_cb_list.length; i++) {
	        var cb = device.mouse_location_cb_list[i];
	        if (cb) {
	            _location[0] = event.clientX;
	            _location[1] = event.clientY;
	            cb(_location);
	        }
	    }

	    if (device.prevent_default)
	        event.preventDefault();

	    // remove unused callbacks
	    for (var i = 0; i < device.mouse_location_cb_list.length; i++)
	        if (!device.mouse_location_cb_list[i])
	            device.mouse_location_cb_list.splice(i, 1);
	}

	function pointerlock_cb(event) {
	    if (_exist_touch) {
	        if (event.sourceCapabilities && event.sourceCapabilities.firesTouchEvents)
	            return;
	        if (event.mozInputSource == 5)
	            return;
	    }
	    var device = get_device_by_type_element(DEVICE_MOUSE, event.currentTarget);
	    update_device(device, event);

	    for (var i = 0; i < device.mouse_location_cb_list.length; i++) {
	        var cb = device.mouse_location_cb_list[i];
	        if (cb) {
	            if (typeof event.movementX == "number") {
	                var mx = event.movementX;
	                var my = event.movementY;
	            } else if (typeof event.webkitMovementX == "number") {
	                var mx = event.webkitMovementX;
	                var my = event.webkitMovementY;
	            } else if (typeof event.mozMovementX == "number") {
	                var mx = event.mozMovementX;
	                var my = event.mozMovementY;
	            } else {
	                var mx = 0;
	                var my = 0;
	            }
	            _location[0] = mx;
	            _location[1] = my;
	            cb(_location);
	        }
	    }

	    if (device.prevent_default)
	        event.preventDefault();

	    // remove unused callbacks
	    for (var i = 0; i < device.mouse_location_cb_list.length; i++)
	        if (!device.mouse_location_cb_list[i])
	            device.mouse_location_cb_list.splice(i, 1);
	}

	function mouse_down_cb(event) {
	    if (_exist_touch) {
	        // optimization for Chrome
	        // See https://developer.mozilla.org/en-US/docs/Web/API/InputDeviceCapabilities
	        if (event.sourceCapabilities && event.sourceCapabilities.firesTouchEvents)
	            return;

	        // optimization for Firefox
	        // See https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/mozInputSource
	        // event.mozInputSource == 5 means that the event was generated by touch.
	        if (event.mozInputSource == 5)
	            return;
	    }

	    var device = get_device_by_type_element(DEVICE_MOUSE, event.currentTarget);
	    update_device(device, event);
	    for (var i = 0; i < device.mouse_down_which_cb_list.length; i++) {
	        var cb = device.mouse_down_which_cb_list[i];
	        if (cb)
	            cb(event.which);
	    }

	    if (device.prevent_default) {
	        // need to set focus for keyboard events if the engine works inside an iframe
	        if (window.frameElement)
	            window.frameElement.focus();
	        event.preventDefault();
	    }

	    // remove unused callbacks
	    for (var i = 0; i < device.mouse_down_which_cb_list.length; i++)
	        if (!device.mouse_down_which_cb_list[i])
	            device.mouse_down_which_cb_list.splice(i, 1);
	}

	function mouse_out_cb(event) {
	    if (!m_cont.is_child(event.relatedTarget) && event.which)
	        mouse_up_cb(event);
	}

	function mouse_up_cb(event) {
	    if (_exist_touch) {
	        // optimization for Chrome
	        // See https://developer.mozilla.org/en-US/docs/Web/API/InputDeviceCapabilities
	        if (event.sourceCapabilities && event.sourceCapabilities.firesTouchEvents)
	            return;

	        // optimization for Firefox
	        // See https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/mozInputSource
	        // event.mozInputSource == 5 means that the event was generated by touch.
	        if (event.mozInputSource == 5)
	            return;
	    }

	    var device = get_device_by_type_element(DEVICE_MOUSE, event.currentTarget);
	    update_device(device, event);

	    for (var i = 0; i < device.mouse_up_which_cb_list.length; i++) {
	        var cb = device.mouse_up_which_cb_list[i];
	        if (cb)
	            cb(event.which);
	    }

	    if (device.prevent_default)
	        event.preventDefault();

	    // remove unused callbacks
	    for (var i = 0; i < device.mouse_up_which_cb_list.length; i++)
	        if (!device.mouse_up_which_cb_list[i])
	            device.mouse_up_which_cb_list.splice(i, 1);
	}

	function normalized_wheel_delta(event) {

	    var delta = 0;

	    if (event.wheelDelta) {
	        if (event.wheelDelta % 120 == 0)
	            delta = event.wheelDelta / 120;
	        else
	            delta = m_util.sign(event.wheelDelta);
	    } else if (event.deltaY) {
	        if (event.deltaY % 3 == 0)
	            delta = -event.deltaY / 3;
	        else
	            delta = -m_util.sign(event.deltaY);
	    }

	    return m_util.clamp(WHEEL_DELTA_MULT * delta, -WHEEL_DELTA_LIMIT, WHEEL_DELTA_LIMIT);
	}

	function mouse_wheel_cb(event) {
	    var device = get_device_by_type_element(DEVICE_MOUSE, event.currentTarget);
	    for (var i = 0; i < device.mouse_wheel_cb_list.length; i++) {
	        var cb = device.mouse_wheel_cb_list[i];
	        if (cb)
	            cb(normalized_wheel_delta(event));
	    }

	    if (device.prevent_default)
	        event.preventDefault();

	    // remove unused callbacks
	    for (var i = 0; i < device.mouse_wheel_cb_list.length; i++)
	        if (!device.mouse_wheel_cb_list[i])
	            device.mouse_wheel_cb_list.splice(i, 1);
	}

	function keyboard_down_cb(event) {
	    var device = get_device_by_type_element(DEVICE_KEYBOARD, event.currentTarget);

	    var cb_list = event.ctrlKey || event.altKey || event.metaKey?
	            device.keyboard_down_mod_cb_list:
	            device.keyboard_down_cb_list;

	    for (var i = 0; i < cb_list.length; i++) {
	        var cb = cb_list[i];
	        if (cb)
	            cb(event.keyCode);
	        else
	            // remove unused callbacks
	            cb_list.splice(i--, 1);
	    }

	    if (device.prevent_default)
	        event.preventDefault();
	}

	function keyboard_up_cb(event) {
	    var device = get_device_by_type_element(DEVICE_KEYBOARD, event.currentTarget);
	    for (var i = 0; i < device.keyboard_up_cb_list.length; i++) {
	        var cb = device.keyboard_up_cb_list[i];
	        if (cb)
	            cb(event.keyCode);
	    }

	    if (device.prevent_default)
	        event.preventDefault();

	    // remove unused callbacks
	    for (var i = 0; i < device.keyboard_up_cb_list.length; i++)
	        if (!device.keyboard_up_cb_list[i])
	            device.keyboard_up_cb_list.splice(i, 1);
	}

	function touch_start_cb(event) {
	    var device = get_device_by_type_element(DEVICE_TOUCH, event.currentTarget);
	    for (var i = 0; i < device.touch_start_cb_list.length; i++) {
	        var cb = device.touch_start_cb_list[i];
	        if (cb)
	            cb(event.targetTouches);
	    }

	    // if (device.prevent_default)
	    //     event.preventDefault();

	    // remove unused callbacks
	    for (var i = 0; i < device.touch_start_cb_list.length; i++)
	        if (!device.touch_start_cb_list[i])
	            device.touch_start_cb_list.splice(i, 1);
	}

	function touch_move_cb(event) {
	    var device = get_device_by_type_element(DEVICE_TOUCH, event.currentTarget);
	    for (var i = 0; i < device.touch_move_cb_list.length; i++) {
	        var cb = device.touch_move_cb_list[i];
	        if (cb)
	            cb(event.targetTouches);
	    }

	    if (device.prevent_default)
	        event.preventDefault();

	    // remove unused callbacks
	    for (var i = 0; i < device.touch_move_cb_list.length; i++)
	        if (!device.touch_move_cb_list[i])
	            device.touch_move_cb_list.splice(i, 1);
	}

	function touch_end_cb(event) {
	    var device = get_device_by_type_element(DEVICE_TOUCH, event.currentTarget);
	    for (var i = 0; i < device.touch_end_cb_list.length; i++) {
	        var cb = device.touch_end_cb_list[i];
	        if (cb)
	            cb(event.targetTouches);
	    }

	    // if (device.prevent_default)
	    //     event.preventDefault();

	    // remove unused callbacks
	    for (var i = 0; i < device.touch_end_cb_list.length; i++)
	        if (!device.touch_end_cb_list[i])
	            device.touch_end_cb_list.splice(i, 1);
	}

	exports.cleanup = function() {
	    for (var i = 0; i < _devices.length; i++) {
	        var device = _devices[i];

	        for (var j = 0; j < device.registered_event_listeners.length; j++) {
	            var param = device.registered_event_listeners[j];
	            unregister_event_listener(device, param, null, true);
	        }
	    }

	    _devices.length = 0;
	};

	exports.get_pressed_gmpd_btn = function(gamepad_id) {
	    var type = get_gmpd_type_by_id(gamepad_id);
	    var device = get_device_by_type_element(type);
	    for (var i = 0; i < device.gamepad_btns.length; i++)
	        if (device.gamepad_btns[i])
	            return i + GMPD_BTNS_OFFSET;
	    return -1;
	};

	exports.get_moved_gmpd_axis = function(gamepad_id) {
	    var type = get_gmpd_type_by_id(gamepad_id);
	    var device = get_device_by_type_element(type);
	    for (var i = 0; i < device.gamepad_axes.length; i++)
	        if (device.gamepad_prev_axes[i] - device.gamepad_axes[i])
	            return i + GMPD_AXIS_OFFSET;
	    return -1;
	};

	function get_gmpd_type_by_id(gamepad_id) {
	    switch(gamepad_id) {
	    case 0:
	        var type = DEVICE_GAMEPAD0;
	        break;
	    case 1:
	        var type = DEVICE_GAMEPAD1;
	        break;
	    case 2:
	        var type = DEVICE_GAMEPAD2;
	        break;
	    case 3:
	        var type = DEVICE_GAMEPAD3;
	        break;
	    default:
	        var type = DEVICE_GAMEPAD0;
	    }
	    return type;
	}

	function get_gamepad_btn_key(device, btn) {
	    return device.gamepad_mapping[btn];
	}

	exports.get_first_gmpd_id = function() {
	    var gamepads = navigator.getGamepads ? navigator.getGamepads() :
	            (navigator.webkitGetGamepads ? navigator.webkitGetGamepads : []);
	    for (var i = 0; i < gamepads.length; i++)
	        if (gamepads[i])
	            return i;
	    return 0;
	};

	exports.get_webvr_display = function() {
	    var hmd_device = get_device_by_type_element(DEVICE_HMD);
	    return hmd_device && hmd_device.webvr_display;
	};

	function enable_pointerlock(sensor) {
	    var elem = sensor.element;
	    var pointerlock_change = function() {
	        if (document.pointerLockElement === elem ||
	                document.webkitPointerLockElement === elem ||
	                document.mozPointerLockElement === elem) {
	            sensor.value = 1;
	        } else {
	            sensor.value = 0;
	            document.removeEventListener("pointerlockchange", pointerlock_change, false);
	            document.removeEventListener("webkitpointerlockchange", pointerlock_change, false);
	            document.removeEventListener("mozpointerlockchange", pointerlock_change, false);
	        }
	    };

	    document.addEventListener("pointerlockchange", pointerlock_change, false);
	    document.addEventListener("webkitpointerlockchange", pointerlock_change, false);
	    document.addEventListener("mozpointerlockchange", pointerlock_change, false);

	    var request_plock = elem.requestPointerLock ||
	            elem.webkitRequestPointerLock || elem.mozRequestPointerLock;

	    if (typeof request_plock === "function")
	        request_plock.apply(elem);
	}

	exports.activate_pointerlock = function(sensor) {
	    var elem = sensor.element;
	    var request_pointer_lock = function(e) {
	        if (!sensor.value)
	            enable_pointerlock(sensor);
	    };
	    elem.addEventListener("mousedown", request_pointer_lock, false);
	};

	exports.add_click_listener = function(element, callback) {
	    if (cfg_def.is_mobile_device)
	        element.addEventListener("touchend", callback);
	    else
	        element.addEventListener("mouseup", callback);
	};

	exports.remove_click_listener = function(element, callback) {
	    if (cfg_def.is_mobile_device)
	        element.removeEventListener("touchend", callback);
	    else
	        element.removeEventListener("mouseup", callback);
	};

	exports.check_fullscreen = check_fullscreen;
	function check_fullscreen() {
	    var fullscreenEnabled = window.document.fullscreenEnabled ||
	                            window.document.mozFullScreenEnabled ||
	                            window.document.msFullscreenEnabled ||
	                            window.document.webkitFullscreenEnabled;

	    if (fullscreenEnabled)
	        return true;

	    return false;
	}

	}

	var int_input_factory = register("__input", Int_input);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Prerender module, perform culling/lod stuff.
	 * @name prerender
	 * @namespace
	 * @exports exports as scenes
	 */
	function Int_prerender(ns, exports) {

	var m_debug    = int_debug_factory(ns);
	var m_geom     = int_geometry_factory(ns);
	var m_obj      = int_objects_factory(ns);
	var m_render   = int_renderer_factory(ns);
	var m_subs     = int_subscene_factory(ns);
	var m_tsr      = int_tsr_factory(ns);
	var m_util     = int_util_factory(ns);
	var m_vec3     = vec3_factory(ns);

	var USE_FRUSTUM_CULLING = true;

	var SUBS_UPDATE_DO_RENDER = [
	    m_subs.MAIN_OPAQUE,
	    m_subs.MAIN_BLEND,
	    m_subs.MAIN_PLANE_REFLECT,
	    m_subs.MAIN_CUBE_REFLECT,
	    m_subs.MAIN_PLANE_REFLECT_BLEND,
	    m_subs.MAIN_CUBE_REFLECT_BLEND,
	    m_subs.MAIN_GLOW,
	    m_subs.MAIN_XRAY,
	    m_subs.SHADOW_CAST,
	    m_subs.SHADOW_RECEIVE,
	    m_subs.OUTLINE_MASK,
	    m_subs.DEBUG_VIEW,
	    m_subs.COLOR_PICKING,
	    m_subs.COLOR_PICKING_XRAY
	];

	var _vec3_tmp = new Float32Array(3);

	/**
	 * Set do_render flag for subscenes/bundles
	 */
	exports.prerender_subs = function(subs) {

	    if (SUBS_UPDATE_DO_RENDER.indexOf(subs.type) > -1) {
	        var has_render_bundles = false;
	        var is_cube_subs = subs.type == m_subs.MAIN_CUBE_REFLECT
	                        || subs.type == m_subs.MAIN_CUBE_REFLECT_BLEND;

	        var draw_data = subs.draw_data;

	        for (var i = 0; i < draw_data.length; i++) {

	            var ddata = draw_data[i];
	            var bundles = ddata.bundles;
	            var draw_data_do_render = false;

	            for (var j = 0; j < bundles.length; j++) {
	                var bundle = bundles[j];
	                var batch = bundle.batch;

	                if (is_cube_subs) {
	                    for (var k = 0; k < 6; k++) {
	                        subs.camera.frustum_planes = subs.cube_cam_frustums[k];
	                        bundle.do_render_cube[k] = prerender_bundle(bundle, subs);
	                        if (bundle.do_render_cube[k]) {
	                            has_render_bundles = true;
	                            draw_data_do_render = true;
	                            update_particles_buffers(batch);
	                        }
	                    }
	                } else {
	                    bundle.do_render = prerender_bundle(bundle, subs);
	                    if (bundle.do_render) {
	                        has_render_bundles = true;
	                        draw_data_do_render = true;
	                        update_particles_buffers(batch);
	                    }
	                }
	                if (subs.need_perm_uniforms_update)
	                    batch.shader.need_uniforms_update = true;

	                if (bundle.do_render) {
	                    var cam = subs.camera;
	                    var cam_pos = m_tsr.get_trans(cam.world_tsr, _vec3_tmp);
	                    var z_index = get_z_index(bundle, cam_pos);
	                    bundle.z_index = z_index;
	                } else {
	                    bundle.z_index = Infinity;
	                }
	            }
	            sort_bundles(bundles);
	            if (bundles.length > 0)
	                draw_data.z_index = bundles[0];
	            ddata.do_render = draw_data_do_render;
	        }
	        subs.need_perm_uniforms_update = false;

	        switch (subs.type) {
	        case m_subs.DEBUG_VIEW:
	            // NOTE: debug view subs rendered optionally
	            break;
	        default:
	            // prevent bugs when blend is only one rendered
	            if (subs.type == m_subs.MAIN_OPAQUE || subs.type == m_subs.SHADOW_RECEIVE 
	                    || subs.type == m_subs.MAIN_GLOW || subs.type == m_subs.MAIN_PLANE_REFLECT
	                    || subs.type == m_subs.MAIN_CUBE_REFLECT || has_render_bundles)
	                subs.do_render = true;
	            else {
	                // clear subscene if it switches "do_render" flag to false
	                if (subs.do_render)
	                    m_render.clear(subs);
	                subs.do_render = false;
	            }
	            break;
	        }

	    } else if (subs.need_perm_uniforms_update) {
	        var draw_data = subs.draw_data;
	        for (var i = 0; i < draw_data.length; i++) {
	            var bundles = draw_data[i].bundles;
	            for (var j = 0; j < bundles.length; j++) {
	                var bundle = bundles[j];
	                var batch = bundle.batch;

	                    batch.shader.need_uniforms_update = true;
	            }
	        }
	        subs.need_perm_uniforms_update = false;
	    }

	    if (subs.need_draw_data_sort)
	        m_subs.sort_draw_data(subs);
	};

	function sort_bundles(bundles) {
	    bundles.sort(sort_fun);
	}

	function sort_fun(a, b) {
	    return a.z_index - b.z_index;
	}

	function get_z_index(bundle, cam_pos) {
	    if (bundle.world_bounds) {
	        var bs = bundle.world_bounds.bs;

	        // Return z_index heuristically.
	        // CHECK: Why do we use exacly this expression?
	        return m_vec3.squaredDistance(bs.center, cam_pos) + bs.radius * bs.radius;
	    } else {
	        return Infinity;
	    }
	}

	/**
	 * Calculate LOD visibility and cull out-of-frustum/subscene-specific bundles.
	 * @returns {boolean} do_render flag for bundle
	 */
	function prerender_bundle(bundle, subs) {

	    var obj_render = bundle.obj_render;

	    obj_render.is_visible = false;

	    if (obj_render.hide)
	        return false;

	    var cam = subs.camera;

	    if (subs.type == m_subs.SHADOW_CAST)
	        var eye = cam.lod_eye;
	    else
	        var eye = m_tsr.get_trans(cam.world_tsr, _vec3_tmp);

	    var batch = bundle.batch;

	    if (!m_obj.update_lod_visibility(batch, obj_render, eye))
	        return false;

	    obj_render.is_visible = true;

	    if (subs.type == m_subs.DEBUG_VIEW)
	        if (subs.debug_view_mode == m_debug.DV_BOUNDINGS)
	            return batch.debug_sphere;
	        else
	            return !batch.debug_sphere;

	    if (subs.type == m_subs.OUTLINE_MASK && obj_render.outline_intensity == 0)
	        return false;

	    if (!(batch.do_not_cull || !bundle.world_bounds) && USE_FRUSTUM_CULLING &&
	            is_out_of_frustum(cam.frustum_planes, bundle.world_bounds.bs, 
	            bundle.world_bounds.be, batch.use_be))
	        return false;

	    return true;
	}

	function is_out_of_frustum(planes, bs, be, use_be) {

	    // optimization - check sphere first
	    var pt = bs.center;
	    if (m_util.sphere_is_out_of_frustum(pt, planes, bs.radius))
	        return true;
	    else if (!use_be)
	        return false;

	    var axis_x = be.axis_x;
	    var axis_y = be.axis_y;
	    var axis_z = be.axis_z;
	    pt = be.center;
	    var is_out = m_util.ellipsoid_is_out_of_frustum(pt, planes,
	                                                      axis_x, axis_y, axis_z);
	    return is_out;
	}

	function update_particles_buffers(batch) {
	    // NOTE: update buffers only for visible bundles
	    var pdata = batch.particles_data;
	    if (!(pdata && pdata.need_buffers_update))
	        return;

	    var pbuf = batch.bufs_data;
	    m_geom.make_dynamic(pbuf);

	    var pointers = pbuf.pointers;

	    var pos_offset = pointers["a_position"].offset;
	    m_geom.vbo_source_data_set_attr(pbuf.vbo_source_data, "a_position", 
	            pdata.positions_cache, pos_offset);

	    var tbn_offset = pointers["a_tbn"].offset;
	    m_geom.vbo_source_data_set_attr(pbuf.vbo_source_data, "a_tbn", 
	            pdata.tbn_cache, tbn_offset);

	    m_geom.update_gl_buffers(pbuf);
	}

	}

	var int_prerender_factory = register("__prerender", Int_prerender);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Generates submeshes with primitive geometry.
	 * @name primitives
	 * @namespace
	 * @exports exports as primitives
	 */
	function Int_primitives(ns, exports) {

	var m_cfg   = int_config_factory(ns);
	var m_geom  = int_geometry_factory(ns);
	var m_tbn   = int_tbn_factory(ns);
	var m_util  = int_util_factory(ns);

	var cfg_def  = m_cfg.defaults;

	exports.generate_line = function() {
	    var submesh = m_geom.init_submesh("LINE");

	    var va_frame = m_util.create_empty_va_frame();
	    va_frame["a_position"] = new Float32Array(3);
	    va_frame["a_direction"] = new Float32Array(3);

	    submesh.va_frames[0] = va_frame;
	    submesh.indices = new Uint32Array(1);
	    submesh.base_length = 1;

	    return submesh;
	};

	exports.generate_plane = function(x_size, y_size) {
	    var grid_submesh = generate_grid(2, 2, x_size, y_size);
	    grid_submesh.name = "PLANE";

	    return grid_submesh;
	};

	exports.generate_grid = generate_grid;
	/**
	 * Subdivisions and size are from the blender
	 * @methodOf primitives
	 */
	function generate_grid(x_subdiv, y_subdiv, x_size, y_size) {

	    var indices   = [];
	    var positions = [];
	    var texcoords = [];
	    var tbn_count = x_subdiv * y_subdiv;

	    var delta_x = (2 * x_size) / (x_subdiv - 1);
	    var delta_y = (2 * y_size) / (y_subdiv - 1);

	    for (var i = 0; i < x_subdiv; i++) {

	        var x = -x_size + i * delta_x;

	        for (var j = 0; j < y_subdiv; j++) {

	            var y = -y_size + j * delta_y;

	            positions.push(x, y, 0);

	            texcoords.push(i / (x_subdiv - 1), j / (y_subdiv -1));

	            if (i && j) {
	                var idx0 = i * y_subdiv + j;
	                var idx1 = idx0 - 1;
	                var idx2 = (i - 1) * y_subdiv + j;
	                var idx3 = idx2 - 1;
	                indices.push(idx0, idx1, idx2);
	                indices.push(idx1, idx3, idx2);
	            }
	        }
	    }

	    // construct submesh

	    var va_frame = m_util.create_empty_va_frame();

	    va_frame["a_position"] = new Float32Array(positions);
	    va_frame["a_tbn"] = m_tbn.create(tbn_count);

	    var submesh = m_geom.init_submesh("GRID_PLANE");

	    submesh.va_frames[0] = va_frame;
	    submesh.va_common["a_texcoord"] = new Float32Array(texcoords);
	    submesh.indices = new Uint32Array(indices);
	    submesh.base_length = positions.length/3;

	    return submesh;
	}

	/**
	 * Extract water submesh
	 */
	exports.generate_cascaded_grid = function(num_cascads, subdivs, detailed_dist) {

	    var min_casc_size = detailed_dist / Math.pow(2, num_cascads - 1);
	    var x_size   = min_casc_size;
	    var y_size   = min_casc_size;

	    var x_subdiv = subdivs + 1;
	    var y_subdiv = subdivs + 1;

	    var indices      = [];
	    var positions    = [];
	    var tbn_count    = 0;

	    var prev_x = 0;
	    var prev_y = 0;

	    var last_added_ind = -1;

	    function is_merged_vertex(i, j) {
	        if ( (i % 2 == 1 && (j == 0 || j == y_subdiv - 1)) ||
	             (j % 2 == 1 && (i == 0 || i == x_subdiv - 1)) )
	            return true;
	        else
	            return false;
	    }

	    var prev_utmost_verts = []; // prev cascad utmost verts (x, y, ind)

	    for (var c = 0; c < num_cascads; c++) {

	        var delta_x = (2 * x_size) / (x_subdiv - 1);
	        var delta_y = (2 * y_size) / (y_subdiv - 1);

	        var cur_utmost_verts  = []; // current cascad utmost verts (x, y, ind)
	        var casc_indices      = []; // current cascad indices
	        for (var i = 0; i < x_subdiv; i++) {

	            var x = -x_size + i * delta_x;

	            var indices_in_row = [];

	            for (var j = 0; j < y_subdiv; j++) {

	                var y = -y_size + j * delta_y;

	                // process vertices only otside previous cascad
	                if (!(x > -prev_x && x < prev_x &&
	                      y > -prev_y && y < prev_y)) {

	                    var coinciding_ind = null;

	                    // check if there exist a vertex with the same coords
	                    for (var k = 0; k < prev_utmost_verts.length; k+=3) {
	                        if (x == prev_utmost_verts[k] && y == prev_utmost_verts[k+1]) {
	                            coinciding_ind = prev_utmost_verts[k+2];
	                            break;
	                        }
	                    }

	                    if (coinciding_ind !== null) {
	                        var idx0 = coinciding_ind;
	                    } else
	                        var idx0 = last_added_ind + 1;

	                    // push to positions array if needed
	                    if ( !is_merged_vertex(i, j) ) {
	                        if (coinciding_ind == null) {
	                            if ((j == 0 || j == y_subdiv - 1 ||
	                                 i == 0 || i == x_subdiv - 1)) {

	                                if (c == num_cascads - 1)
	                                    var cascad_step = delta_x;
	                                else
	                                    var cascad_step = 2 * delta_x;

	                                cur_utmost_verts.push(x, y, idx0);
	                            } else
	                                var cascad_step = delta_x;
	                            positions.push(x, y, cascad_step);
	                            tbn_count++;
	                            last_added_ind++; 
	                        }
	                        indices_in_row.push(idx0);
	                    } else {
	                        indices_in_row.push(-2); // is odd utmost
	                        
	                    }

	                    if (i && j) {
	                        // for not utmost vertices
	                        if ( i == 1 ) {
	                            // 2-nd column 
	                            if (is_merged_vertex(i-1, j)) {
	                                if ( j > 1) {
	                                    var idx1 = idx0 - 1;
	                                    var idx2 = casc_indices[i-1][j+1];
	                                    var idx3 = idx2 - 1;
	                                    indices.push(idx3, idx1, idx0);
	                                    indices.push(idx2, idx3, idx0);
	                                } else {
	                                    var idx2 = casc_indices[i-1][j+1];
	                                    var idx3 = idx2 - 1;
	                                    indices.push(idx2, idx3, idx0);
	                                }
	                            } else if (!is_merged_vertex(i, j)) {
	                                var idx1 = idx0 - 1;
	                                var idx2 = casc_indices[i-1][j];
	                                indices.push(idx2, idx1, idx0);
	                            }
	                        } else if ( i == x_subdiv - 1 ) {
	                            // last column
	                            if (!is_merged_vertex(i, j)) {
	                                if (j == y_subdiv - 1) {
	                                    // build lower-right corner
	                                    var idx1 = idx0 - 1;
	                                    var idx2 = casc_indices[i-1][j-1];
	                                    var idx3 = casc_indices[i-2][j];
	                                    indices.push(idx2, idx1, idx0);
	                                    indices.push(idx3, idx2, idx0);
	                                } else {
	                                    var idx1 = idx0 - 1;
	                                    var idx2 = casc_indices[i-1][j];
	                                    var idx3 = idx2 - 1;
	                                    var idx4 = idx2 + 1;
	                                    indices.push(idx3, idx1, idx0);
	                                    indices.push(idx2, idx3, idx0);
	                                    indices.push(idx4, idx2, idx0);
	                                    if (j == 2) {
	                                        // build upper-right corner
	                                        idx4 = casc_indices[i-2][j-2];
	                                        indices.push(idx3, idx4, idx1);
	                                    }
	                                }
	                            }
	                        } else if ( j == 1 ) {
	                            // 2-nd row
	                            if (!is_merged_vertex(i, j-1)) {
	                                var idx1 = indices_in_row[j-1];
	                                var idx2 = casc_indices[i-1][j];
	                                var idx3 = casc_indices[i-2][j-1];
	                                indices.push(idx2, idx1, idx0);
	                                indices.push(idx2, idx3, idx1);
	                            } else {
	                                var idx1 = casc_indices[i-1][j];
	                                var idx2 = casc_indices[i-1][j-1];
	                                indices.push(idx1, idx2, idx0);
	                            }
	                        } else if ( j == y_subdiv - 1 ) {
	                            // last row
	                            if (!is_merged_vertex(i, j)) {
	                                var idx1 = indices_in_row[j-1];
	                                var idx2 = casc_indices[i-1][j-1];
	                                var idx3 = casc_indices[i-2][j];
	                                indices.push(idx2, idx1, idx0);
	                                indices.push(idx3, idx2, idx0);
	                            }
	                        } else if (casc_indices[i-1][j]   != -1
	                                && casc_indices[i-1][j-1] != -1
	                                && indices_in_row[j-1]     != -1) {

	                            var idx1 = indices_in_row[j-1];
	                            var idx2 = casc_indices[i-1][j];
	                            var idx3 = casc_indices[i-1][j-1];
	                            indices.push(idx2, idx1, idx0);
	                            indices.push(idx2, idx3, idx1);
	                            if (j == y_subdiv - 2 && is_merged_vertex(i, j+1)) {
	                                var idx4 = casc_indices[i-1][j+1];
	                                indices.push(idx4, idx2, idx0);
	                            }
	                        } else if (j == y_subdiv - 2 && is_merged_vertex(i, j+1)) {
	                                var idx2 = casc_indices[i-1][j];
	                                var idx4 = casc_indices[i-1][j+1];
	                                indices.push(idx4, idx2, idx0);
	                        }
	                    }
	                } else {
	                    indices_in_row.push(-1);
	                    
	                }
	            }
	            casc_indices.push(indices_in_row);

	        }
	        prev_utmost_verts = cur_utmost_verts;

	        prev_x =  x_size;
	        prev_y =  y_size;

	        x_size *= 2;
	        y_size *= 2;
	    }

	    // generate outer cascad from 8 vertices [Optional]
	    var required_mesh_size = 20000;
	    if (prev_x < required_mesh_size) {

	        var casc_step = -(2 * prev_x) / (x_subdiv - 1);

	        positions.push(-required_mesh_size, -required_mesh_size, casc_step);
	        positions.push(-required_mesh_size,  required_mesh_size, casc_step);
	        positions.push(-prev_x, -prev_y, casc_step);
	        positions.push(-prev_x,  prev_y, casc_step);
	        positions.push( required_mesh_size, -required_mesh_size, casc_step);
	        positions.push( required_mesh_size,  required_mesh_size, casc_step);
	        positions.push( prev_x, -prev_y, casc_step);
	        positions.push( prev_x,  prev_y, casc_step);

	        var idx0 = last_added_ind + 1;
	        indices.push(idx0 + 1, idx0 + 2, idx0 + 3,
	                     idx0 + 1, idx0 + 0, idx0 + 2,
	                     idx0 + 2, idx0 + 4, idx0 + 6,
	                     idx0 + 2, idx0 + 0, idx0 + 4,
	                     idx0 + 1, idx0 + 7, idx0 + 5,
	                     idx0 + 1, idx0 + 3, idx0 + 7,
	                     idx0 + 7, idx0 + 4, idx0 + 5,
	                     idx0 + 6, idx0 + 4, idx0 + 7);

	        tbn_count += 8;
	    }

	    // construct submesh
	    var va_frame = m_util.create_empty_va_frame();

	    va_frame["a_position"] = new Float32Array(positions);
	    va_frame["a_tbn"] = m_tbn.create(tbn_count);

	    // CHECK: why should we do next line?
	    m_tbn.multiply_quat(va_frame["a_tbn"], [0.707, 0, 0, 0.707], va_frame["a_tbn"]);

	    var submesh = m_geom.init_submesh("MULTIGRID_PLANE");

	    submesh.va_frames[0] = va_frame;
	    submesh.indices = new Uint32Array(indices);
	    submesh.base_length = positions.length/3;

	    // debug wireframe mode
	    if (cfg_def.water_wireframe_debug) {
	        m_geom.submesh_drop_indices(submesh, 1, true);
	        va_frame["a_polyindex"]  = m_geom.extract_polyindices(submesh);
	    }

	    return submesh;
	};

	/**
	 * Generate submesh for shadeless rendering (w/o normals)
	 * verts must be CCW if you look at the front face of triangle
	 */
	exports.generate_from_triangles = function(verts) {
	    var len = verts.length;
	    if (len % 3)
	        m_util.panic("Wrong array");

	    var indices   = [];
	    var positions = [];

	    for (var i = 0; i < len; i+=3) {
	        var v1 = verts[i];
	        var v2 = verts[i+1];
	        var v3 = verts[i+2];

	        add_vec3_to_array(v1, positions);
	        add_vec3_to_array(v2, positions);
	        add_vec3_to_array(v3, positions);

	        indices.push(i, i+1, i+2);
	    }

	    // construct submesh

	    var va_frame = m_util.create_empty_va_frame();

	    va_frame["a_position"] = new Float32Array(positions);

	    var submesh = m_geom.init_submesh("FROM_TRIANGLES");

	    submesh.va_frames[0] = va_frame;
	    submesh.indices = new Uint32Array(indices);
	    submesh.base_length = positions.length/3;

	    return submesh;
	};

	exports.generate_from_quads = generate_from_quads; 
	/**
	 * Generate submesh for shadeless rendering (w/o normals).
	 * verts must be CCW if you look at the front face of quad
	 * @methodOf primitives
	 */
	function generate_from_quads(verts) {


	    var len = verts.length;
	    if (len % 4)
	        m_util.panic("Wrong array");

	    var indices   = [];
	    var positions = [];

	    for (var i = 0; i < len; i+=4) {
	        var v1 = verts[i];
	        var v2 = verts[i+1];
	        var v3 = verts[i+2];
	        var v4 = verts[i+3];

	        add_vec3_to_array(v1, positions);
	        add_vec3_to_array(v2, positions);
	        add_vec3_to_array(v3, positions);
	        add_vec3_to_array(v4, positions);

	        indices.push(i, i+1, i+2);
	        indices.push(i, i+2, i+3);
	    }

	    // construct submesh

	    var va_frame = m_util.create_empty_va_frame();

	    va_frame["a_position"] = new Float32Array(positions);
	    // CHECK: probably there should be non-init tbn
	    va_frame["a_tbn"] = m_tbn.create(len / 4);

	    var submesh = m_geom.init_submesh("FROM_QUADS");

	    submesh.va_frames[0] = va_frame;
	    submesh.indices = new Uint32Array(indices);
	    submesh.base_length = positions.length/3;

	    return submesh;
	}

	/**
	 * Generate frustum submesh from submesh corners.
	 * <p>NOTE1: corners must be near and far planes
	 * <p>NOTE2: near plane - CCW, far plane - CW (from viewer point)
	 * <p>NOTE3: left buttom vertex of near and far plane are joined
	 */
	exports.generate_frustum = function(corners) {

	    corners = m_util.vectorize(corners, []); 

	    // TODO: implement simple method to generate frustum geometry
	    var quads = [];

	    // near quad
	    quads.push(corners[0], corners[1], corners[2], corners[3]);

	    // left quad
	    quads.push(corners[0], corners[3], corners[5], corners[4]);
	    // top quad
	    quads.push(corners[3], corners[2], corners[6], corners[5]);
	    // right quad
	    quads.push(corners[1], corners[7], corners[6], corners[2]);
	    // buttom quad
	    quads.push(corners[0], corners[4], corners[7], corners[1]);

	    // far quad
	    quads.push(corners[4], corners[5], corners[6], corners[7]);

	    var submesh = generate_from_quads(quads);
	    submesh.name = "FRUSTUM";

	    return submesh;
	};

	exports.generate_fullscreen_tri = function() {

	    var submesh = m_geom.init_submesh("FULLSCREEN_TRI");

	    var va_frame = m_util.create_empty_va_frame();
	    va_frame["a_position"] = new Float32Array([0, 0, 1, 0, 0, 1]);

	    submesh.va_frames[0] = va_frame;
	    submesh.indices = new Uint32Array([0, 1, 2]);
	    submesh.base_length = 3;

	    return submesh;
	};

	exports.generate_fullscreen_quad = function() {

	    var submesh = m_geom.init_submesh("FULLSCREEN_QUAD");

	    var va_frame = m_util.create_empty_va_frame();
	    va_frame["a_position"] = new Float32Array([-1,  1, 1,  1, -1, -1, 1, -1]);

	    submesh.va_frames[0] = va_frame;
	    submesh.indices = new Uint32Array([0, 2, 1, 1, 2, 3]);
	    submesh.base_length = 4;

	    return submesh;
	};

	exports.generate_billboard = function() {

	    var submesh = m_geom.init_submesh("BILLBOARD");

	    var va_frame = m_util.create_empty_va_frame();
	    va_frame["a_bb_vertex"] = m_geom.gen_bb_vertices(1);

	    submesh.va_frames[0] = va_frame;
	    submesh.indices = new Uint32Array([0, 2, 1, 0, 3, 2]);
	    submesh.base_length = 4;

	    return submesh;
	};

	/**
	 * Return uv sphere submesh
	 *
	 * size - sphere radius
	 */
	exports.generate_uv_sphere = function(segments, rings, size, center, 
	        use_smooth, use_wireframe) {
	    var submesh = m_geom.init_submesh("UV_SPHERE");

	    var x, y;
	    
	    var positions = [];
	    var grid_positions = [];
	    var indices = [];

	    for (y = 0; y <= rings; y++) {
	        for (x = 0; x <= segments; x++) {

	            var u = x / segments;
	            var v = y / rings;

	            var xpos = -size * Math.cos(u * 2*Math.PI) * Math.sin(v * Math.PI);
	            var ypos = size * Math.cos(v * Math.PI);
	            var zpos = size * Math.sin(u * 2*Math.PI) * Math.sin(v * Math.PI);

	            // clamp near-zero values to improve TBN smoothing quality
	            if (use_smooth) {
	                var edge = 0.00001;
	                xpos = (Math.abs(xpos) < edge) ? 0 : xpos;
	                ypos = (Math.abs(ypos) < edge) ? 0 : ypos;
	                zpos = (Math.abs(zpos) < edge) ? 0 : zpos;
	            }

	            grid_positions.push(xpos + center[0], ypos + center[1], 
	                    zpos + center[2]);
	        }
	    }

	    var v_index = 0;
	    for (y = 0; y < rings; y++) {
	        for (x = 0; x < segments; x++) {

	            var v1 = extract_vec3(grid_positions, (segments+1)*y + x + 1);
	            var v2 = extract_vec3(grid_positions, (segments+1)*y + x);
	            var v3 = extract_vec3(grid_positions, (segments+1)*(y + 1) + x);
	            var v4 = extract_vec3(grid_positions, (segments+1)*(y + 1) + x + 1);
	            
	            // upper pole
	            if (Math.abs(v1[1]) == (size + center[1])) {

	                add_vec3_to_array(v1, positions);
	                add_vec3_to_array(v3, positions);
	                add_vec3_to_array(v4, positions);

	                if (use_wireframe)
	                    indices.push(v_index, v_index+1, v_index+1, v_index+2, 
	                            v_index+2, v_index);
	                else
	                    indices.push(v_index, v_index+1, v_index+2);
	                v_index += 3;

	            // lower pole
	            } else if (Math.abs(v3[1]) == (size + center[1])) {
	                add_vec3_to_array(v1, positions);
	                add_vec3_to_array(v2, positions);
	                add_vec3_to_array(v3, positions);

	                if (use_wireframe)
	                    indices.push(v_index, v_index+1, v_index+1, v_index+2, 
	                            v_index+2, v_index);
	                else
	                    indices.push(v_index, v_index+1, v_index+2);
	                v_index += 3;

	            } else {
	                add_vec3_to_array(v1, positions);
	                add_vec3_to_array(v2, positions);
	                add_vec3_to_array(v3, positions);
	                add_vec3_to_array(v4, positions);

	                if (use_wireframe) {
	                    indices.push(v_index, v_index+1);
	                    indices.push(v_index+1, v_index+2);
	                    indices.push(v_index+2, v_index+3);
	                    indices.push(v_index+3, v_index);
	                } else {
	                    indices.push(v_index, v_index+1, v_index+2);
	                    indices.push(v_index, v_index+2, v_index+3);
	                }

	                v_index += 4;
	            }
	        }
	    }

	    // construct submesh

	    var va_frame = {};

	    va_frame["a_position"] = positions;

	    if (use_wireframe) {
	        va_frame["a_tbn"] = m_tbn.create();
	    } else {

	        var shared_indices = m_geom.calc_shared_indices(indices, 
	                grid_positions, positions);

	        var normals = m_geom.calc_normals(indices, positions, 
	                shared_indices);
	        va_frame["a_tbn"] = m_tbn.from_norm_tan(normals);
	    }

	    submesh.va_frames[0] = va_frame;
	    submesh.indices = indices;
	    submesh.base_length = positions.length/3;

	    return submesh;
	};

	/**
	 * Position in vectors, not values
	 */
	function extract_vec3(array, position) {
	    var offset = position*3;
	    var x = array[offset];
	    var y = array[offset+1];
	    var z = array[offset+2];

	    return [x,y,z];
	}

	function add_vec3_to_array(vec, array) {
	    array.push(vec[0], vec[1], vec[2]);
	}

	exports.generate_index = function(num) {

	    var submesh = m_geom.init_submesh("INDEX");

	    var va_frame = m_util.create_empty_va_frame();
	    va_frame["a_index"] = new Float32Array(num * 3);
	    var indices = new Uint16Array(num * 3);
	    for (var i = 0; i < num * 3; i++) {
	        va_frame["a_index"][i] = i;
	        indices[i] = i;
	    }

	    submesh.va_frames[0] = va_frame;
	    submesh.indices = indices;
	    submesh.base_length = num * 3;

	    return submesh;
	};

	}

	var int_primitives_factory = register("__primitives", Int_primitives);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Auto-generated module: Pako inflate (pako_inflate.js) library for
	 * decompressing .gz files.
	 * @name pako_inflate
	 * @namespace
	 * @exports exports as pako_inflate
	 */
	function Pako_inflate(ns, exports) {

	// NOTE: added to get rid of some gcc warnings
	var module, define, global, pako_require;

	/* pako 1.0.5 nodeca/pako */(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f();}else if(typeof define==="function"&&define.amd){}else{var g;if(typeof window!=="undefined"){g=window;}else if(typeof global!=="undefined"){g=global;}else if(typeof self!=="undefined"){g=self;}else{g=this;}g.pako = f();}})(function(){return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof pako_require=="function"&&pako_require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r);}return n[o].exports}var i=typeof pako_require=="function"&&pako_require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(pako_require,module,exports){
	'use strict';


	var TYPED_OK =  (typeof Uint8Array !== 'undefined') &&
	                (typeof Uint16Array !== 'undefined') &&
	                (typeof Int32Array !== 'undefined');


	exports.assign = function (obj /*from1, from2, from3, ...*/) {
	  var sources = Array.prototype.slice.call(arguments, 1);
	  while (sources.length) {
	    var source = sources.shift();
	    if (!source) { continue; }

	    if (typeof source !== 'object') {
	      throw new TypeError(source + 'must be non-object');
	    }

	    for (var p in source) {
	      if (source.hasOwnProperty(p)) {
	        obj[p] = source[p];
	      }
	    }
	  }

	  return obj;
	};


	// reduce buffer size, avoiding mem copy
	exports.shrinkBuf = function (buf, size) {
	  if (buf.length === size) { return buf; }
	  if (buf.subarray) { return buf.subarray(0, size); }
	  buf.length = size;
	  return buf;
	};


	var fnTyped = {
	  arraySet: function (dest, src, src_offs, len, dest_offs) {
	    if (src.subarray && dest.subarray) {
	      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
	      return;
	    }
	    // Fallback to ordinary array
	    for (var i = 0; i < len; i++) {
	      dest[dest_offs + i] = src[src_offs + i];
	    }
	  },
	  // Join array of chunks to single array.
	  flattenChunks: function (chunks) {
	    var i, l, len, pos, chunk, result;

	    // calculate data length
	    len = 0;
	    for (i = 0, l = chunks.length; i < l; i++) {
	      len += chunks[i].length;
	    }

	    // join chunks
	    result = new Uint8Array(len);
	    pos = 0;
	    for (i = 0, l = chunks.length; i < l; i++) {
	      chunk = chunks[i];
	      result.set(chunk, pos);
	      pos += chunk.length;
	    }

	    return result;
	  }
	};

	var fnUntyped = {
	  arraySet: function (dest, src, src_offs, len, dest_offs) {
	    for (var i = 0; i < len; i++) {
	      dest[dest_offs + i] = src[src_offs + i];
	    }
	  },
	  // Join array of chunks to single array.
	  flattenChunks: function (chunks) {
	    return [].concat.apply([], chunks);
	  }
	};


	// Enable/Disable typed arrays use, for testing
	//
	exports.setTyped = function (on) {
	  if (on) {
	    exports.Buf8  = Uint8Array;
	    exports.Buf16 = Uint16Array;
	    exports.Buf32 = Int32Array;
	    exports.assign(exports, fnTyped);
	  } else {
	    exports.Buf8  = Array;
	    exports.Buf16 = Array;
	    exports.Buf32 = Array;
	    exports.assign(exports, fnUntyped);
	  }
	};

	exports.setTyped(TYPED_OK);

	},{}],2:[function(pako_require,module,exports){
	// String encode/decode helpers
	'use strict';


	var utils = pako_require('./common');


	// Quick check if we can use fast array to bin string conversion
	//
	// - apply(Array) can fail on Android 2.2
	// - apply(Uint8Array) can fail on iOS 5.1 Safary
	//
	var STR_APPLY_OK = true;
	var STR_APPLY_UIA_OK = true;

	try { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }
	try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }


	// Table with utf8 lengths (calculated by first byte of sequence)
	// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
	// because max possible codepoint is 0x10ffff
	var _utf8len = new utils.Buf8(256);
	for (var q = 0; q < 256; q++) {
	  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
	}
	_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


	// convert string to array (typed, when possible)
	exports.string2buf = function (str) {
	  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

	  // count binary size
	  for (m_pos = 0; m_pos < str_len; m_pos++) {
	    c = str.charCodeAt(m_pos);
	    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
	      c2 = str.charCodeAt(m_pos + 1);
	      if ((c2 & 0xfc00) === 0xdc00) {
	        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
	        m_pos++;
	      }
	    }
	    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
	  }

	  // allocate buffer
	  buf = new utils.Buf8(buf_len);

	  // convert
	  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
	    c = str.charCodeAt(m_pos);
	    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
	      c2 = str.charCodeAt(m_pos + 1);
	      if ((c2 & 0xfc00) === 0xdc00) {
	        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
	        m_pos++;
	      }
	    }
	    if (c < 0x80) {
	      /* one byte */
	      buf[i++] = c;
	    } else if (c < 0x800) {
	      /* two bytes */
	      buf[i++] = 0xC0 | (c >>> 6);
	      buf[i++] = 0x80 | (c & 0x3f);
	    } else if (c < 0x10000) {
	      /* three bytes */
	      buf[i++] = 0xE0 | (c >>> 12);
	      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
	      buf[i++] = 0x80 | (c & 0x3f);
	    } else {
	      /* four bytes */
	      buf[i++] = 0xf0 | (c >>> 18);
	      buf[i++] = 0x80 | (c >>> 12 & 0x3f);
	      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
	      buf[i++] = 0x80 | (c & 0x3f);
	    }
	  }

	  return buf;
	};

	// Helper (used in 2 places)
	function buf2binstring(buf, len) {
	  // use fallback for big arrays to avoid stack overflow
	  if (len < 65537) {
	    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {
	      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
	    }
	  }

	  var result = '';
	  for (var i = 0; i < len; i++) {
	    result += String.fromCharCode(buf[i]);
	  }
	  return result;
	}


	// Convert byte array to binary string
	exports.buf2binstring = function (buf) {
	  return buf2binstring(buf, buf.length);
	};


	// Convert binary string (typed, when possible)
	exports.binstring2buf = function (str) {
	  var buf = new utils.Buf8(str.length);
	  for (var i = 0, len = buf.length; i < len; i++) {
	    buf[i] = str.charCodeAt(i);
	  }
	  return buf;
	};


	// convert array to string
	exports.buf2string = function (buf, max) {
	  var i, out, c, c_len;
	  var len = max || buf.length;

	  // Reserve max possible length (2 words per char)
	  // NB: by unknown reasons, Array is significantly faster for
	  //     String.fromCharCode.apply than Uint16Array.
	  var utf16buf = new Array(len * 2);

	  for (out = 0, i = 0; i < len;) {
	    c = buf[i++];
	    // quick process ascii
	    if (c < 0x80) { utf16buf[out++] = c; continue; }

	    c_len = _utf8len[c];
	    // skip 5 & 6 byte codes
	    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }

	    // apply mask on first byte
	    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
	    // join the rest
	    while (c_len > 1 && i < len) {
	      c = (c << 6) | (buf[i++] & 0x3f);
	      c_len--;
	    }

	    // terminated by end of string?
	    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

	    if (c < 0x10000) {
	      utf16buf[out++] = c;
	    } else {
	      c -= 0x10000;
	      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
	      utf16buf[out++] = 0xdc00 | (c & 0x3ff);
	    }
	  }

	  return buf2binstring(utf16buf, out);
	};


	// Calculate max possible position in utf8 buffer,
	// that will not break sequence. If that's not possible
	// - (very small limits) return max size as is.
	//
	// buf[] - utf8 bytes array
	// max   - length limit (mandatory);
	exports.utf8border = function (buf, max) {
	  var pos;

	  max = max || buf.length;
	  if (max > buf.length) { max = buf.length; }

	  // go back from last position, until start of sequence found
	  pos = max - 1;
	  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

	  // Fuckup - very small and broken sequence,
	  // return max, because we should return something anyway.
	  if (pos < 0) { return max; }

	  // If we came to start of buffer - that means vuffer is too small,
	  // return max too.
	  if (pos === 0) { return max; }

	  return (pos + _utf8len[buf[pos]] > max) ? pos : max;
	};

	},{"./common":1}],3:[function(pako_require,module,exports){
	'use strict';

	// Note: adler32 takes 12% for level 0 and 2% for level 6.
	// It doesn't worth to make additional optimizationa as in original.
	// Small size is preferable.

	// (C) 1995-2013 Jean-loup Gailly and Mark Adler
	// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
	//
	// This software is provided 'as-is', without any express or implied
	// warranty. In no event will the authors be held liable for any damages
	// arising from the use of this software.
	//
	// Permission is granted to anyone to use this software for any purpose,
	// including commercial applications, and to alter it and redistribute it
	// freely, subject to the following restrictions:
	//
	// 1. The origin of this software must not be misrepresented; you must not
	//   claim that you wrote the original software. If you use this software
	//   in a product, an acknowledgment in the product documentation would be
	//   appreciated but is not required.
	// 2. Altered source versions must be plainly marked as such, and must not be
	//   misrepresented as being the original software.
	// 3. This notice may not be removed or altered from any source distribution.

	function adler32(adler, buf, len, pos) {
	  var s1 = (adler & 0xffff) |0,
	      s2 = ((adler >>> 16) & 0xffff) |0,
	      n = 0;

	  while (len !== 0) {
	    // Set limit ~ twice less than 5552, to keep
	    // s2 in 31-bits, because we force signed ints.
	    // in other case %= will fail.
	    n = len > 2000 ? 2000 : len;
	    len -= n;

	    do {
	      s1 = (s1 + buf[pos++]) |0;
	      s2 = (s2 + s1) |0;
	    } while (--n);

	    s1 %= 65521;
	    s2 %= 65521;
	  }

	  return (s1 | (s2 << 16)) |0;
	}


	module.exports = adler32;

	},{}],4:[function(pako_require,module,exports){
	'use strict';

	// (C) 1995-2013 Jean-loup Gailly and Mark Adler
	// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
	//
	// This software is provided 'as-is', without any express or implied
	// warranty. In no event will the authors be held liable for any damages
	// arising from the use of this software.
	//
	// Permission is granted to anyone to use this software for any purpose,
	// including commercial applications, and to alter it and redistribute it
	// freely, subject to the following restrictions:
	//
	// 1. The origin of this software must not be misrepresented; you must not
	//   claim that you wrote the original software. If you use this software
	//   in a product, an acknowledgment in the product documentation would be
	//   appreciated but is not required.
	// 2. Altered source versions must be plainly marked as such, and must not be
	//   misrepresented as being the original software.
	// 3. This notice may not be removed or altered from any source distribution.

	module.exports = {

	  /* Allowed flush values; see deflate() and inflate() below for details */
	  Z_NO_FLUSH:         0,
	  Z_PARTIAL_FLUSH:    1,
	  Z_SYNC_FLUSH:       2,
	  Z_FULL_FLUSH:       3,
	  Z_FINISH:           4,
	  Z_BLOCK:            5,
	  Z_TREES:            6,

	  /* Return codes for the compression/decompression functions. Negative values
	  * are errors, positive values are used for special but normal events.
	  */
	  Z_OK:               0,
	  Z_STREAM_END:       1,
	  Z_NEED_DICT:        2,
	  Z_ERRNO:           -1,
	  Z_STREAM_ERROR:    -2,
	  Z_DATA_ERROR:      -3,
	  //Z_MEM_ERROR:     -4,
	  Z_BUF_ERROR:       -5,
	  //Z_VERSION_ERROR: -6,

	  /* compression levels */
	  Z_NO_COMPRESSION:         0,
	  Z_BEST_SPEED:             1,
	  Z_BEST_COMPRESSION:       9,
	  Z_DEFAULT_COMPRESSION:   -1,


	  Z_FILTERED:               1,
	  Z_HUFFMAN_ONLY:           2,
	  Z_RLE:                    3,
	  Z_FIXED:                  4,
	  Z_DEFAULT_STRATEGY:       0,

	  /* Possible values of the data_type field (though see inflate()) */
	  Z_BINARY:                 0,
	  Z_TEXT:                   1,
	  //Z_ASCII:                1, // = Z_TEXT (deprecated)
	  Z_UNKNOWN:                2,

	  /* The deflate compression method */
	  Z_DEFLATED:               8
	  //Z_NULL:                 null // Use -1 or null inline, depending on var type
	};

	},{}],5:[function(pako_require,module,exports){
	'use strict';

	// Note: we can't get significant speed boost here.
	// So write code to minimize size - no pregenerated tables
	// and array tools dependencies.

	// (C) 1995-2013 Jean-loup Gailly and Mark Adler
	// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
	//
	// This software is provided 'as-is', without any express or implied
	// warranty. In no event will the authors be held liable for any damages
	// arising from the use of this software.
	//
	// Permission is granted to anyone to use this software for any purpose,
	// including commercial applications, and to alter it and redistribute it
	// freely, subject to the following restrictions:
	//
	// 1. The origin of this software must not be misrepresented; you must not
	//   claim that you wrote the original software. If you use this software
	//   in a product, an acknowledgment in the product documentation would be
	//   appreciated but is not required.
	// 2. Altered source versions must be plainly marked as such, and must not be
	//   misrepresented as being the original software.
	// 3. This notice may not be removed or altered from any source distribution.

	// Use ordinary array, since untyped makes no boost here
	function makeTable() {
	  var c, table = [];

	  for (var n = 0; n < 256; n++) {
	    c = n;
	    for (var k = 0; k < 8; k++) {
	      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
	    }
	    table[n] = c;
	  }

	  return table;
	}

	// Create table on load. Just 255 signed longs. Not a problem.
	var crcTable = makeTable();


	function crc32(crc, buf, len, pos) {
	  var t = crcTable,
	      end = pos + len;

	  crc ^= -1;

	  for (var i = pos; i < end; i++) {
	    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
	  }

	  return (crc ^ (-1)); // >>> 0;
	}


	module.exports = crc32;

	},{}],6:[function(pako_require,module,exports){
	'use strict';

	// (C) 1995-2013 Jean-loup Gailly and Mark Adler
	// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
	//
	// This software is provided 'as-is', without any express or implied
	// warranty. In no event will the authors be held liable for any damages
	// arising from the use of this software.
	//
	// Permission is granted to anyone to use this software for any purpose,
	// including commercial applications, and to alter it and redistribute it
	// freely, subject to the following restrictions:
	//
	// 1. The origin of this software must not be misrepresented; you must not
	//   claim that you wrote the original software. If you use this software
	//   in a product, an acknowledgment in the product documentation would be
	//   appreciated but is not required.
	// 2. Altered source versions must be plainly marked as such, and must not be
	//   misrepresented as being the original software.
	// 3. This notice may not be removed or altered from any source distribution.

	function GZheader() {
	  /* true if compressed data believed to be text */
	  this.text       = 0;
	  /* modification time */
	  this.time       = 0;
	  /* extra flags (not used when writing a gzip file) */
	  this.xflags     = 0;
	  /* operating system */
	  this.os         = 0;
	  /* pointer to extra field or Z_NULL if none */
	  this.extra      = null;
	  /* extra field length (valid if extra != Z_NULL) */
	  this.extra_len  = 0; // Actually, we don't need it in JS,
	                       // but leave for few code modifications

	  //
	  // Setup limits is not necessary because in js we should not preallocate memory
	  // for inflate use constant limit in 65536 bytes
	  //

	  /* space at extra (only when reading header) */
	  // this.extra_max  = 0;
	  /* pointer to zero-terminated file name or Z_NULL */
	  this.name       = '';
	  /* space at name (only when reading header) */
	  // this.name_max   = 0;
	  /* pointer to zero-terminated comment or Z_NULL */
	  this.comment    = '';
	  /* space at comment (only when reading header) */
	  // this.comm_max   = 0;
	  /* true if there was or will be a header crc */
	  this.hcrc       = 0;
	  /* true when done reading gzip header (not used when writing a gzip file) */
	  this.done       = false;
	}

	module.exports = GZheader;

	},{}],7:[function(pako_require,module,exports){
	'use strict';

	// (C) 1995-2013 Jean-loup Gailly and Mark Adler
	// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
	//
	// This software is provided 'as-is', without any express or implied
	// warranty. In no event will the authors be held liable for any damages
	// arising from the use of this software.
	//
	// Permission is granted to anyone to use this software for any purpose,
	// including commercial applications, and to alter it and redistribute it
	// freely, subject to the following restrictions:
	//
	// 1. The origin of this software must not be misrepresented; you must not
	//   claim that you wrote the original software. If you use this software
	//   in a product, an acknowledgment in the product documentation would be
	//   appreciated but is not required.
	// 2. Altered source versions must be plainly marked as such, and must not be
	//   misrepresented as being the original software.
	// 3. This notice may not be removed or altered from any source distribution.

	// See state defs from inflate.js
	var BAD = 30;       /* got a data error -- remain here until reset */
	var TYPE = 12;      /* i: waiting for type bits, including last-flag bit */

	/*
	   Decode literal, length, and distance codes and write out the resulting
	   literal and match bytes until either not enough input or output is
	   available, an end-of-block is encountered, or a data error is encountered.
	   When large enough input and output buffers are supplied to inflate(), for
	   example, a 16K input buffer and a 64K output buffer, more than 95% of the
	   inflate execution time is spent in this routine.

	   Entry assumptions:

	        state.mode === LEN
	        strm.avail_in >= 6
	        strm.avail_out >= 258
	        start >= strm.avail_out
	        state.bits < 8

	   On return, state.mode is one of:

	        LEN -- ran out of enough output space or enough available input
	        TYPE -- reached end of block code, inflate() to interpret next block
	        BAD -- error in block data

	   Notes:

	    - The maximum input bits used by a length/distance pair is 15 bits for the
	      length code, 5 bits for the length extra, 15 bits for the distance code,
	      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
	      Therefore if strm.avail_in >= 6, then there is enough input to avoid
	      checking for available input while decoding.

	    - The maximum bytes that a single length/distance pair can output is 258
	      bytes, which is the maximum length that can be coded.  inflate_fast()
	      requires strm.avail_out >= 258 for each loop to avoid checking for
	      output space.
	 */
	module.exports = function inflate_fast(strm, start) {
	  var state;
	  var _in;                    /* local strm.input */
	  var last;                   /* have enough input while in < last */
	  var _out;                   /* local strm.output */
	  var beg;                    /* inflate()'s initial strm.output */
	  var end;                    /* while out < end, enough space available */
	//#ifdef INFLATE_STRICT
	  var dmax;                   /* maximum distance from zlib header */
	//#endif
	  var wsize;                  /* window size or zero if not using window */
	  var whave;                  /* valid bytes in the window */
	  var wnext;                  /* window write index */
	  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
	  var s_window;               /* allocated sliding window, if wsize != 0 */
	  var hold;                   /* local strm.hold */
	  var bits;                   /* local strm.bits */
	  var lcode;                  /* local strm.lencode */
	  var dcode;                  /* local strm.distcode */
	  var lmask;                  /* mask for first level of length codes */
	  var dmask;                  /* mask for first level of distance codes */
	  var here;                   /* retrieved table entry */
	  var op;                     /* code bits, operation, extra bits, or */
	                              /*  window position, window bytes to copy */
	  var len;                    /* match length, unused bytes */
	  var dist;                   /* match distance */
	  var from;                   /* where to copy match from */
	  var from_source;


	  var input, output; // JS specific, because we have no pointers

	  /* copy state to local variables */
	  state = strm.state;
	  //here = state.here;
	  _in = strm.next_in;
	  input = strm.input;
	  last = _in + (strm.avail_in - 5);
	  _out = strm.next_out;
	  output = strm.output;
	  beg = _out - (start - strm.avail_out);
	  end = _out + (strm.avail_out - 257);
	//#ifdef INFLATE_STRICT
	  dmax = state.dmax;
	//#endif
	  wsize = state.wsize;
	  whave = state.whave;
	  wnext = state.wnext;
	  s_window = state.window;
	  hold = state.hold;
	  bits = state.bits;
	  lcode = state.lencode;
	  dcode = state.distcode;
	  lmask = (1 << state.lenbits) - 1;
	  dmask = (1 << state.distbits) - 1;


	  /* decode literals and length/distances until end-of-block or not enough
	     input data or output space */

	  top:
	  do {
	    if (bits < 15) {
	      hold += input[_in++] << bits;
	      bits += 8;
	      hold += input[_in++] << bits;
	      bits += 8;
	    }

	    here = lcode[hold & lmask];

	    dolen:
	    for (;;) { // Goto emulation
	      op = here >>> 24/*here.bits*/;
	      hold >>>= op;
	      bits -= op;
	      op = (here >>> 16) & 0xff/*here.op*/;
	      if (op === 0) {                          /* literal */
	        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
	        //        "inflate:         literal '%c'\n" :
	        //        "inflate:         literal 0x%02x\n", here.val));
	        output[_out++] = here & 0xffff/*here.val*/;
	      }
	      else if (op & 16) {                     /* length base */
	        len = here & 0xffff/*here.val*/;
	        op &= 15;                           /* number of extra bits */
	        if (op) {
	          if (bits < op) {
	            hold += input[_in++] << bits;
	            bits += 8;
	          }
	          len += hold & ((1 << op) - 1);
	          hold >>>= op;
	          bits -= op;
	        }
	        //Tracevv((stderr, "inflate:         length %u\n", len));
	        if (bits < 15) {
	          hold += input[_in++] << bits;
	          bits += 8;
	          hold += input[_in++] << bits;
	          bits += 8;
	        }
	        here = dcode[hold & dmask];

	        dodist:
	        for (;;) { // goto emulation
	          op = here >>> 24/*here.bits*/;
	          hold >>>= op;
	          bits -= op;
	          op = (here >>> 16) & 0xff/*here.op*/;

	          if (op & 16) {                      /* distance base */
	            dist = here & 0xffff/*here.val*/;
	            op &= 15;                       /* number of extra bits */
	            if (bits < op) {
	              hold += input[_in++] << bits;
	              bits += 8;
	              if (bits < op) {
	                hold += input[_in++] << bits;
	                bits += 8;
	              }
	            }
	            dist += hold & ((1 << op) - 1);
	//#ifdef INFLATE_STRICT
	            if (dist > dmax) {
	              strm.msg = 'invalid distance too far back';
	              state.mode = BAD;
	              break top;
	            }
	//#endif
	            hold >>>= op;
	            bits -= op;
	            //Tracevv((stderr, "inflate:         distance %u\n", dist));
	            op = _out - beg;                /* max distance in output */
	            if (dist > op) {                /* see if copy from window */
	              op = dist - op;               /* distance back in window */
	              if (op > whave) {
	                if (state.sane) {
	                  strm.msg = 'invalid distance too far back';
	                  state.mode = BAD;
	                  break top;
	                }

	// (!) This block is disabled in zlib defailts,
	// don't enable it for binary compatibility
	//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
	//                if (len <= op - whave) {
	//                  do {
	//                    output[_out++] = 0;
	//                  } while (--len);
	//                  continue top;
	//                }
	//                len -= op - whave;
	//                do {
	//                  output[_out++] = 0;
	//                } while (--op > whave);
	//                if (op === 0) {
	//                  from = _out - dist;
	//                  do {
	//                    output[_out++] = output[from++];
	//                  } while (--len);
	//                  continue top;
	//                }
	//#endif
	              }
	              from = 0; // window index
	              from_source = s_window;
	              if (wnext === 0) {           /* very common case */
	                from += wsize - op;
	                if (op < len) {         /* some from window */
	                  len -= op;
	                  do {
	                    output[_out++] = s_window[from++];
	                  } while (--op);
	                  from = _out - dist;  /* rest from output */
	                  from_source = output;
	                }
	              }
	              else if (wnext < op) {      /* wrap around window */
	                from += wsize + wnext - op;
	                op -= wnext;
	                if (op < len) {         /* some from end of window */
	                  len -= op;
	                  do {
	                    output[_out++] = s_window[from++];
	                  } while (--op);
	                  from = 0;
	                  if (wnext < len) {  /* some from start of window */
	                    op = wnext;
	                    len -= op;
	                    do {
	                      output[_out++] = s_window[from++];
	                    } while (--op);
	                    from = _out - dist;      /* rest from output */
	                    from_source = output;
	                  }
	                }
	              }
	              else {                      /* contiguous in window */
	                from += wnext - op;
	                if (op < len) {         /* some from window */
	                  len -= op;
	                  do {
	                    output[_out++] = s_window[from++];
	                  } while (--op);
	                  from = _out - dist;  /* rest from output */
	                  from_source = output;
	                }
	              }
	              while (len > 2) {
	                output[_out++] = from_source[from++];
	                output[_out++] = from_source[from++];
	                output[_out++] = from_source[from++];
	                len -= 3;
	              }
	              if (len) {
	                output[_out++] = from_source[from++];
	                if (len > 1) {
	                  output[_out++] = from_source[from++];
	                }
	              }
	            }
	            else {
	              from = _out - dist;          /* copy direct from output */
	              do {                        /* minimum length is three */
	                output[_out++] = output[from++];
	                output[_out++] = output[from++];
	                output[_out++] = output[from++];
	                len -= 3;
	              } while (len > 2);
	              if (len) {
	                output[_out++] = output[from++];
	                if (len > 1) {
	                  output[_out++] = output[from++];
	                }
	              }
	            }
	          }
	          else if ((op & 64) === 0) {          /* 2nd level distance code */
	            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
	            continue dodist;
	          }
	          else {
	            strm.msg = 'invalid distance code';
	            state.mode = BAD;
	            break top;
	          }

	          break; // need to emulate goto via "continue"
	        }
	      }
	      else if ((op & 64) === 0) {              /* 2nd level length code */
	        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
	        continue dolen;
	      }
	      else if (op & 32) {                     /* end-of-block */
	        //Tracevv((stderr, "inflate:         end of block\n"));
	        state.mode = TYPE;
	        break top;
	      }
	      else {
	        strm.msg = 'invalid literal/length code';
	        state.mode = BAD;
	        break top;
	      }

	      break; // need to emulate goto via "continue"
	    }
	  } while (_in < last && _out < end);

	  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
	  len = bits >> 3;
	  _in -= len;
	  bits -= len << 3;
	  hold &= (1 << bits) - 1;

	  /* update state and return */
	  strm.next_in = _in;
	  strm.next_out = _out;
	  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
	  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
	  state.hold = hold;
	  state.bits = bits;
	  return;
	};

	},{}],8:[function(pako_require,module,exports){
	'use strict';

	// (C) 1995-2013 Jean-loup Gailly and Mark Adler
	// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
	//
	// This software is provided 'as-is', without any express or implied
	// warranty. In no event will the authors be held liable for any damages
	// arising from the use of this software.
	//
	// Permission is granted to anyone to use this software for any purpose,
	// including commercial applications, and to alter it and redistribute it
	// freely, subject to the following restrictions:
	//
	// 1. The origin of this software must not be misrepresented; you must not
	//   claim that you wrote the original software. If you use this software
	//   in a product, an acknowledgment in the product documentation would be
	//   appreciated but is not required.
	// 2. Altered source versions must be plainly marked as such, and must not be
	//   misrepresented as being the original software.
	// 3. This notice may not be removed or altered from any source distribution.

	var utils         = pako_require('../utils/common');
	var adler32       = pako_require('./adler32');
	var crc32         = pako_require('./crc32');
	var inflate_fast  = pako_require('./inffast');
	var inflate_table = pako_require('./inftrees');

	var CODES = 0;
	var LENS = 1;
	var DISTS = 2;

	/* Public constants ==========================================================*/
	/* ===========================================================================*/


	/* Allowed flush values; see deflate() and inflate() below for details */
	//var Z_NO_FLUSH      = 0;
	//var Z_PARTIAL_FLUSH = 1;
	//var Z_SYNC_FLUSH    = 2;
	//var Z_FULL_FLUSH    = 3;
	var Z_FINISH        = 4;
	var Z_BLOCK         = 5;
	var Z_TREES         = 6;


	/* Return codes for the compression/decompression functions. Negative values
	 * are errors, positive values are used for special but normal events.
	 */
	var Z_OK            = 0;
	var Z_STREAM_END    = 1;
	var Z_NEED_DICT     = 2;
	//var Z_ERRNO         = -1;
	var Z_STREAM_ERROR  = -2;
	var Z_DATA_ERROR    = -3;
	var Z_MEM_ERROR     = -4;
	var Z_BUF_ERROR     = -5;
	//var Z_VERSION_ERROR = -6;

	/* The deflate compression method */
	var Z_DEFLATED  = 8;


	/* STATES ====================================================================*/
	/* ===========================================================================*/


	var    HEAD = 1;       /* i: waiting for magic header */
	var    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
	var    TIME = 3;       /* i: waiting for modification time (gzip) */
	var    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
	var    EXLEN = 5;      /* i: waiting for extra length (gzip) */
	var    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
	var    NAME = 7;       /* i: waiting for end of file name (gzip) */
	var    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
	var    HCRC = 9;       /* i: waiting for header crc (gzip) */
	var    DICTID = 10;    /* i: waiting for dictionary check value */
	var    DICT = 11;      /* waiting for inflateSetDictionary() call */
	var        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
	var        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
	var        STORED = 14;    /* i: waiting for stored size (length and complement) */
	var        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
	var        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
	var        TABLE = 17;     /* i: waiting for dynamic block table lengths */
	var        LENLENS = 18;   /* i: waiting for code length code lengths */
	var        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
	var            LEN_ = 20;      /* i: same as LEN below, but only first time in */
	var            LEN = 21;       /* i: waiting for length/lit/eob code */
	var            LENEXT = 22;    /* i: waiting for length extra bits */
	var            DIST = 23;      /* i: waiting for distance code */
	var            DISTEXT = 24;   /* i: waiting for distance extra bits */
	var            MATCH = 25;     /* o: waiting for output space to copy string */
	var            LIT = 26;       /* o: waiting for output space to write literal */
	var    CHECK = 27;     /* i: waiting for 32-bit check value */
	var    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
	var    DONE = 29;      /* finished check, done -- remain here until reset */
	var    BAD = 30;       /* got a data error -- remain here until reset */
	var    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
	var    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */

	/* ===========================================================================*/



	var ENOUGH_LENS = 852;
	var ENOUGH_DISTS = 592;
	//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

	var MAX_WBITS = 15;
	/* 32K LZ77 window */
	var DEF_WBITS = MAX_WBITS;


	function zswap32(q) {
	  return  (((q >>> 24) & 0xff) +
	          ((q >>> 8) & 0xff00) +
	          ((q & 0xff00) << 8) +
	          ((q & 0xff) << 24));
	}


	function InflateState() {
	  this.mode = 0;             /* current inflate mode */
	  this.last = false;          /* true if processing last block */
	  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
	  this.havedict = false;      /* true if dictionary provided */
	  this.flags = 0;             /* gzip header method and flags (0 if zlib) */
	  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
	  this.check = 0;             /* protected copy of check value */
	  this.total = 0;             /* protected copy of output count */
	  // TODO: may be {}
	  this.head = null;           /* where to save gzip header information */

	  /* sliding window */
	  this.wbits = 0;             /* log base 2 of requested window size */
	  this.wsize = 0;             /* window size or zero if not using window */
	  this.whave = 0;             /* valid bytes in the window */
	  this.wnext = 0;             /* window write index */
	  this.window = null;         /* allocated sliding window, if needed */

	  /* bit accumulator */
	  this.hold = 0;              /* input bit accumulator */
	  this.bits = 0;              /* number of bits in "in" */

	  /* for string and stored block copying */
	  this.length = 0;            /* literal or length of data to copy */
	  this.offset = 0;            /* distance back to copy string from */

	  /* for table and code decoding */
	  this.extra = 0;             /* extra bits needed */

	  /* fixed and dynamic code tables */
	  this.lencode = null;          /* starting table for length/literal codes */
	  this.distcode = null;         /* starting table for distance codes */
	  this.lenbits = 0;           /* index bits for lencode */
	  this.distbits = 0;          /* index bits for distcode */

	  /* dynamic table building */
	  this.ncode = 0;             /* number of code length code lengths */
	  this.nlen = 0;              /* number of length code lengths */
	  this.ndist = 0;             /* number of distance code lengths */
	  this.have = 0;              /* number of code lengths in lens[] */
	  this.next = null;              /* next available space in codes[] */

	  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */
	  this.work = new utils.Buf16(288); /* work area for code table building */

	  /*
	   because we don't have pointers in js, we use lencode and distcode directly
	   as buffers so we don't need codes
	  */
	  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
	  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
	  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
	  this.sane = 0;                   /* if false, allow invalid distance too far */
	  this.back = 0;                   /* bits back of last unprocessed length/lit */
	  this.was = 0;                    /* initial length of match */
	}

	function inflateResetKeep(strm) {
	  var state;

	  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
	  state = strm.state;
	  strm.total_in = strm.total_out = state.total = 0;
	  strm.msg = ''; /*Z_NULL*/
	  if (state.wrap) {       /* to support ill-conceived Java test suite */
	    strm.adler = state.wrap & 1;
	  }
	  state.mode = HEAD;
	  state.last = 0;
	  state.havedict = 0;
	  state.dmax = 32768;
	  state.head = null/*Z_NULL*/;
	  state.hold = 0;
	  state.bits = 0;
	  //state.lencode = state.distcode = state.next = state.codes;
	  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
	  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);

	  state.sane = 1;
	  state.back = -1;
	  //Tracev((stderr, "inflate: reset\n"));
	  return Z_OK;
	}

	function inflateReset(strm) {
	  var state;

	  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
	  state = strm.state;
	  state.wsize = 0;
	  state.whave = 0;
	  state.wnext = 0;
	  return inflateResetKeep(strm);

	}

	function inflateReset2(strm, windowBits) {
	  var wrap;
	  var state;

	  /* get the state */
	  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
	  state = strm.state;

	  /* extract wrap request from windowBits parameter */
	  if (windowBits < 0) {
	    wrap = 0;
	    windowBits = -windowBits;
	  }
	  else {
	    wrap = (windowBits >> 4) + 1;
	    if (windowBits < 48) {
	      windowBits &= 15;
	    }
	  }

	  /* set number of window bits, free window if different */
	  if (windowBits && (windowBits < 8 || windowBits > 15)) {
	    return Z_STREAM_ERROR;
	  }
	  if (state.window !== null && state.wbits !== windowBits) {
	    state.window = null;
	  }

	  /* update state and reset the rest of it */
	  state.wrap = wrap;
	  state.wbits = windowBits;
	  return inflateReset(strm);
	}

	function inflateInit2(strm, windowBits) {
	  var ret;
	  var state;

	  if (!strm) { return Z_STREAM_ERROR; }
	  //strm.msg = Z_NULL;                 /* in case we return an error */

	  state = new InflateState();

	  //if (state === Z_NULL) return Z_MEM_ERROR;
	  //Tracev((stderr, "inflate: allocated\n"));
	  strm.state = state;
	  state.window = null/*Z_NULL*/;
	  ret = inflateReset2(strm, windowBits);
	  if (ret !== Z_OK) {
	    strm.state = null/*Z_NULL*/;
	  }
	  return ret;
	}

	function inflateInit(strm) {
	  return inflateInit2(strm, DEF_WBITS);
	}


	/*
	 Return state with length and distance decoding tables and index sizes set to
	 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
	 If BUILDFIXED is defined, then instead this routine builds the tables the
	 first time it's called, and returns those tables the first time and
	 thereafter.  This reduces the size of the code by about 2K bytes, in
	 exchange for a little execution time.  However, BUILDFIXED should not be
	 used for threaded applications, since the rewriting of the tables and virgin
	 may not be thread-safe.
	 */
	var virgin = true;

	var lenfix, distfix; // We have no pointers in JS, so keep tables separate

	function fixedtables(state) {
	  /* build fixed huffman tables if first call (may not be thread safe) */
	  if (virgin) {
	    var sym;

	    lenfix = new utils.Buf32(512);
	    distfix = new utils.Buf32(32);

	    /* literal/length table */
	    sym = 0;
	    while (sym < 144) { state.lens[sym++] = 8; }
	    while (sym < 256) { state.lens[sym++] = 9; }
	    while (sym < 280) { state.lens[sym++] = 7; }
	    while (sym < 288) { state.lens[sym++] = 8; }

	    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });

	    /* distance table */
	    sym = 0;
	    while (sym < 32) { state.lens[sym++] = 5; }

	    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });

	    /* do this just once */
	    virgin = false;
	  }

	  state.lencode = lenfix;
	  state.lenbits = 9;
	  state.distcode = distfix;
	  state.distbits = 5;
	}


	/*
	 Update the window with the last wsize (normally 32K) bytes written before
	 returning.  If window does not exist yet, create it.  This is only called
	 when a window is already in use, or when output has been written during this
	 inflate call, but the end of the deflate stream has not been reached yet.
	 It is also called to create a window for dictionary data when a dictionary
	 is loaded.

	 Providing output buffers larger than 32K to inflate() should provide a speed
	 advantage, since only the last 32K of output is copied to the sliding window
	 upon return from inflate(), and since all distances after the first 32K of
	 output will fall in the output data, making match copies simpler and faster.
	 The advantage may be dependent on the size of the processor's data caches.
	 */
	function updatewindow(strm, src, end, copy) {
	  var dist;
	  var state = strm.state;

	  /* if it hasn't been done already, allocate space for the window */
	  if (state.window === null) {
	    state.wsize = 1 << state.wbits;
	    state.wnext = 0;
	    state.whave = 0;

	    state.window = new utils.Buf8(state.wsize);
	  }

	  /* copy state->wsize or less output bytes into the circular window */
	  if (copy >= state.wsize) {
	    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
	    state.wnext = 0;
	    state.whave = state.wsize;
	  }
	  else {
	    dist = state.wsize - state.wnext;
	    if (dist > copy) {
	      dist = copy;
	    }
	    //zmemcpy(state->window + state->wnext, end - copy, dist);
	    utils.arraySet(state.window, src, end - copy, dist, state.wnext);
	    copy -= dist;
	    if (copy) {
	      //zmemcpy(state->window, end - copy, copy);
	      utils.arraySet(state.window, src, end - copy, copy, 0);
	      state.wnext = copy;
	      state.whave = state.wsize;
	    }
	    else {
	      state.wnext += dist;
	      if (state.wnext === state.wsize) { state.wnext = 0; }
	      if (state.whave < state.wsize) { state.whave += dist; }
	    }
	  }
	  return 0;
	}

	function inflate(strm, flush) {
	  var state;
	  var input, output;          // input/output buffers
	  var next;                   /* next input INDEX */
	  var put;                    /* next output INDEX */
	  var have, left;             /* available input and output */
	  var hold;                   /* bit buffer */
	  var bits;                   /* bits in bit buffer */
	  var _in, _out;              /* save starting available input and output */
	  var copy;                   /* number of stored or match bytes to copy */
	  var from;                   /* where to copy match bytes from */
	  var from_source;
	  var here = 0;               /* current decoding table entry */
	  var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
	  //var last;                   /* parent table entry */
	  var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
	  var len;                    /* length to copy for repeats, bits to drop */
	  var ret;                    /* return code */
	  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */
	  var opts;

	  var n; // temporary var for NEED_BITS

	  var order = /* permutation of code lengths */
	    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];


	  if (!strm || !strm.state || !strm.output ||
	      (!strm.input && strm.avail_in !== 0)) {
	    return Z_STREAM_ERROR;
	  }

	  state = strm.state;
	  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


	  //--- LOAD() ---
	  put = strm.next_out;
	  output = strm.output;
	  left = strm.avail_out;
	  next = strm.next_in;
	  input = strm.input;
	  have = strm.avail_in;
	  hold = state.hold;
	  bits = state.bits;
	  //---

	  _in = have;
	  _out = left;
	  ret = Z_OK;

	  inf_leave: // goto emulation
	  for (;;) {
	    switch (state.mode) {
	    case HEAD:
	      if (state.wrap === 0) {
	        state.mode = TYPEDO;
	        break;
	      }
	      //=== NEEDBITS(16);
	      while (bits < 16) {
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	      }
	      //===//
	      if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
	        state.check = 0/*crc32(0L, Z_NULL, 0)*/;
	        //=== CRC2(state.check, hold);
	        hbuf[0] = hold & 0xff;
	        hbuf[1] = (hold >>> 8) & 0xff;
	        state.check = crc32(state.check, hbuf, 2, 0);
	        //===//

	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	        state.mode = FLAGS;
	        break;
	      }
	      state.flags = 0;           /* expect zlib header */
	      if (state.head) {
	        state.head.done = false;
	      }
	      if (!(state.wrap & 1) ||   /* check if zlib header allowed */
	        (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
	        strm.msg = 'incorrect header check';
	        state.mode = BAD;
	        break;
	      }
	      if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
	        strm.msg = 'unknown compression method';
	        state.mode = BAD;
	        break;
	      }
	      //--- DROPBITS(4) ---//
	      hold >>>= 4;
	      bits -= 4;
	      //---//
	      len = (hold & 0x0f)/*BITS(4)*/ + 8;
	      if (state.wbits === 0) {
	        state.wbits = len;
	      }
	      else if (len > state.wbits) {
	        strm.msg = 'invalid window size';
	        state.mode = BAD;
	        break;
	      }
	      state.dmax = 1 << len;
	      //Tracev((stderr, "inflate:   zlib header ok\n"));
	      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
	      state.mode = hold & 0x200 ? DICTID : TYPE;
	      //=== INITBITS();
	      hold = 0;
	      bits = 0;
	      //===//
	      break;
	    case FLAGS:
	      //=== NEEDBITS(16); */
	      while (bits < 16) {
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	      }
	      //===//
	      state.flags = hold;
	      if ((state.flags & 0xff) !== Z_DEFLATED) {
	        strm.msg = 'unknown compression method';
	        state.mode = BAD;
	        break;
	      }
	      if (state.flags & 0xe000) {
	        strm.msg = 'unknown header flags set';
	        state.mode = BAD;
	        break;
	      }
	      if (state.head) {
	        state.head.text = ((hold >> 8) & 1);
	      }
	      if (state.flags & 0x0200) {
	        //=== CRC2(state.check, hold);
	        hbuf[0] = hold & 0xff;
	        hbuf[1] = (hold >>> 8) & 0xff;
	        state.check = crc32(state.check, hbuf, 2, 0);
	        //===//
	      }
	      //=== INITBITS();
	      hold = 0;
	      bits = 0;
	      //===//
	      state.mode = TIME;
	      /* falls through */
	    case TIME:
	      //=== NEEDBITS(32); */
	      while (bits < 32) {
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	      }
	      //===//
	      if (state.head) {
	        state.head.time = hold;
	      }
	      if (state.flags & 0x0200) {
	        //=== CRC4(state.check, hold)
	        hbuf[0] = hold & 0xff;
	        hbuf[1] = (hold >>> 8) & 0xff;
	        hbuf[2] = (hold >>> 16) & 0xff;
	        hbuf[3] = (hold >>> 24) & 0xff;
	        state.check = crc32(state.check, hbuf, 4, 0);
	        //===
	      }
	      //=== INITBITS();
	      hold = 0;
	      bits = 0;
	      //===//
	      state.mode = OS;
	      /* falls through */
	    case OS:
	      //=== NEEDBITS(16); */
	      while (bits < 16) {
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	      }
	      //===//
	      if (state.head) {
	        state.head.xflags = (hold & 0xff);
	        state.head.os = (hold >> 8);
	      }
	      if (state.flags & 0x0200) {
	        //=== CRC2(state.check, hold);
	        hbuf[0] = hold & 0xff;
	        hbuf[1] = (hold >>> 8) & 0xff;
	        state.check = crc32(state.check, hbuf, 2, 0);
	        //===//
	      }
	      //=== INITBITS();
	      hold = 0;
	      bits = 0;
	      //===//
	      state.mode = EXLEN;
	      /* falls through */
	    case EXLEN:
	      if (state.flags & 0x0400) {
	        //=== NEEDBITS(16); */
	        while (bits < 16) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        state.length = hold;
	        if (state.head) {
	          state.head.extra_len = hold;
	        }
	        if (state.flags & 0x0200) {
	          //=== CRC2(state.check, hold);
	          hbuf[0] = hold & 0xff;
	          hbuf[1] = (hold >>> 8) & 0xff;
	          state.check = crc32(state.check, hbuf, 2, 0);
	          //===//
	        }
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	      }
	      else if (state.head) {
	        state.head.extra = null/*Z_NULL*/;
	      }
	      state.mode = EXTRA;
	      /* falls through */
	    case EXTRA:
	      if (state.flags & 0x0400) {
	        copy = state.length;
	        if (copy > have) { copy = have; }
	        if (copy) {
	          if (state.head) {
	            len = state.head.extra_len - state.length;
	            if (!state.head.extra) {
	              // Use untyped array for more conveniend processing later
	              state.head.extra = new Array(state.head.extra_len);
	            }
	            utils.arraySet(
	              state.head.extra,
	              input,
	              next,
	              // extra field is limited to 65536 bytes
	              // - no need for additional size check
	              copy,
	              /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
	              len
	            );
	            //zmemcpy(state.head.extra + len, next,
	            //        len + copy > state.head.extra_max ?
	            //        state.head.extra_max - len : copy);
	          }
	          if (state.flags & 0x0200) {
	            state.check = crc32(state.check, input, copy, next);
	          }
	          have -= copy;
	          next += copy;
	          state.length -= copy;
	        }
	        if (state.length) { break inf_leave; }
	      }
	      state.length = 0;
	      state.mode = NAME;
	      /* falls through */
	    case NAME:
	      if (state.flags & 0x0800) {
	        if (have === 0) { break inf_leave; }
	        copy = 0;
	        do {
	          // TODO: 2 or 1 bytes?
	          len = input[next + copy++];
	          /* use constant limit because in js we should not preallocate memory */
	          if (state.head && len &&
	              (state.length < 65536 /*state.head.name_max*/)) {
	            state.head.name += String.fromCharCode(len);
	          }
	        } while (len && copy < have);

	        if (state.flags & 0x0200) {
	          state.check = crc32(state.check, input, copy, next);
	        }
	        have -= copy;
	        next += copy;
	        if (len) { break inf_leave; }
	      }
	      else if (state.head) {
	        state.head.name = null;
	      }
	      state.length = 0;
	      state.mode = COMMENT;
	      /* falls through */
	    case COMMENT:
	      if (state.flags & 0x1000) {
	        if (have === 0) { break inf_leave; }
	        copy = 0;
	        do {
	          len = input[next + copy++];
	          /* use constant limit because in js we should not preallocate memory */
	          if (state.head && len &&
	              (state.length < 65536 /*state.head.comm_max*/)) {
	            state.head.comment += String.fromCharCode(len);
	          }
	        } while (len && copy < have);
	        if (state.flags & 0x0200) {
	          state.check = crc32(state.check, input, copy, next);
	        }
	        have -= copy;
	        next += copy;
	        if (len) { break inf_leave; }
	      }
	      else if (state.head) {
	        state.head.comment = null;
	      }
	      state.mode = HCRC;
	      /* falls through */
	    case HCRC:
	      if (state.flags & 0x0200) {
	        //=== NEEDBITS(16); */
	        while (bits < 16) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        if (hold !== (state.check & 0xffff)) {
	          strm.msg = 'header crc mismatch';
	          state.mode = BAD;
	          break;
	        }
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	      }
	      if (state.head) {
	        state.head.hcrc = ((state.flags >> 9) & 1);
	        state.head.done = true;
	      }
	      strm.adler = state.check = 0;
	      state.mode = TYPE;
	      break;
	    case DICTID:
	      //=== NEEDBITS(32); */
	      while (bits < 32) {
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	      }
	      //===//
	      strm.adler = state.check = zswap32(hold);
	      //=== INITBITS();
	      hold = 0;
	      bits = 0;
	      //===//
	      state.mode = DICT;
	      /* falls through */
	    case DICT:
	      if (state.havedict === 0) {
	        //--- RESTORE() ---
	        strm.next_out = put;
	        strm.avail_out = left;
	        strm.next_in = next;
	        strm.avail_in = have;
	        state.hold = hold;
	        state.bits = bits;
	        //---
	        return Z_NEED_DICT;
	      }
	      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
	      state.mode = TYPE;
	      /* falls through */
	    case TYPE:
	      if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
	      /* falls through */
	    case TYPEDO:
	      if (state.last) {
	        //--- BYTEBITS() ---//
	        hold >>>= bits & 7;
	        bits -= bits & 7;
	        //---//
	        state.mode = CHECK;
	        break;
	      }
	      //=== NEEDBITS(3); */
	      while (bits < 3) {
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	      }
	      //===//
	      state.last = (hold & 0x01)/*BITS(1)*/;
	      //--- DROPBITS(1) ---//
	      hold >>>= 1;
	      bits -= 1;
	      //---//

	      switch ((hold & 0x03)/*BITS(2)*/) {
	      case 0:                             /* stored block */
	        //Tracev((stderr, "inflate:     stored block%s\n",
	        //        state.last ? " (last)" : ""));
	        state.mode = STORED;
	        break;
	      case 1:                             /* fixed block */
	        fixedtables(state);
	        //Tracev((stderr, "inflate:     fixed codes block%s\n",
	        //        state.last ? " (last)" : ""));
	        state.mode = LEN_;             /* decode codes */
	        if (flush === Z_TREES) {
	          //--- DROPBITS(2) ---//
	          hold >>>= 2;
	          bits -= 2;
	          //---//
	          break inf_leave;
	        }
	        break;
	      case 2:                             /* dynamic block */
	        //Tracev((stderr, "inflate:     dynamic codes block%s\n",
	        //        state.last ? " (last)" : ""));
	        state.mode = TABLE;
	        break;
	      case 3:
	        strm.msg = 'invalid block type';
	        state.mode = BAD;
	      }
	      //--- DROPBITS(2) ---//
	      hold >>>= 2;
	      bits -= 2;
	      //---//
	      break;
	    case STORED:
	      //--- BYTEBITS() ---// /* go to byte boundary */
	      hold >>>= bits & 7;
	      bits -= bits & 7;
	      //---//
	      //=== NEEDBITS(32); */
	      while (bits < 32) {
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	      }
	      //===//
	      if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
	        strm.msg = 'invalid stored block lengths';
	        state.mode = BAD;
	        break;
	      }
	      state.length = hold & 0xffff;
	      //Tracev((stderr, "inflate:       stored length %u\n",
	      //        state.length));
	      //=== INITBITS();
	      hold = 0;
	      bits = 0;
	      //===//
	      state.mode = COPY_;
	      if (flush === Z_TREES) { break inf_leave; }
	      /* falls through */
	    case COPY_:
	      state.mode = COPY;
	      /* falls through */
	    case COPY:
	      copy = state.length;
	      if (copy) {
	        if (copy > have) { copy = have; }
	        if (copy > left) { copy = left; }
	        if (copy === 0) { break inf_leave; }
	        //--- zmemcpy(put, next, copy); ---
	        utils.arraySet(output, input, next, copy, put);
	        //---//
	        have -= copy;
	        next += copy;
	        left -= copy;
	        put += copy;
	        state.length -= copy;
	        break;
	      }
	      //Tracev((stderr, "inflate:       stored end\n"));
	      state.mode = TYPE;
	      break;
	    case TABLE:
	      //=== NEEDBITS(14); */
	      while (bits < 14) {
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	      }
	      //===//
	      state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
	      //--- DROPBITS(5) ---//
	      hold >>>= 5;
	      bits -= 5;
	      //---//
	      state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
	      //--- DROPBITS(5) ---//
	      hold >>>= 5;
	      bits -= 5;
	      //---//
	      state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
	      //--- DROPBITS(4) ---//
	      hold >>>= 4;
	      bits -= 4;
	      //---//
	//#ifndef PKZIP_BUG_WORKAROUND
	      if (state.nlen > 286 || state.ndist > 30) {
	        strm.msg = 'too many length or distance symbols';
	        state.mode = BAD;
	        break;
	      }
	//#endif
	      //Tracev((stderr, "inflate:       table sizes ok\n"));
	      state.have = 0;
	      state.mode = LENLENS;
	      /* falls through */
	    case LENLENS:
	      while (state.have < state.ncode) {
	        //=== NEEDBITS(3);
	        while (bits < 3) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
	        //--- DROPBITS(3) ---//
	        hold >>>= 3;
	        bits -= 3;
	        //---//
	      }
	      while (state.have < 19) {
	        state.lens[order[state.have++]] = 0;
	      }
	      // We have separate tables & no pointers. 2 commented lines below not needed.
	      //state.next = state.codes;
	      //state.lencode = state.next;
	      // Switch to use dynamic table
	      state.lencode = state.lendyn;
	      state.lenbits = 7;

	      opts = { bits: state.lenbits };
	      ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
	      state.lenbits = opts.bits;

	      if (ret) {
	        strm.msg = 'invalid code lengths set';
	        state.mode = BAD;
	        break;
	      }
	      //Tracev((stderr, "inflate:       code lengths ok\n"));
	      state.have = 0;
	      state.mode = CODELENS;
	      /* falls through */
	    case CODELENS:
	      while (state.have < state.nlen + state.ndist) {
	        for (;;) {
	          here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
	          here_bits = here >>> 24;
	          here_op = (here >>> 16) & 0xff;
	          here_val = here & 0xffff;

	          if ((here_bits) <= bits) { break; }
	          //--- PULLBYTE() ---//
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	          //---//
	        }
	        if (here_val < 16) {
	          //--- DROPBITS(here.bits) ---//
	          hold >>>= here_bits;
	          bits -= here_bits;
	          //---//
	          state.lens[state.have++] = here_val;
	        }
	        else {
	          if (here_val === 16) {
	            //=== NEEDBITS(here.bits + 2);
	            n = here_bits + 2;
	            while (bits < n) {
	              if (have === 0) { break inf_leave; }
	              have--;
	              hold += input[next++] << bits;
	              bits += 8;
	            }
	            //===//
	            //--- DROPBITS(here.bits) ---//
	            hold >>>= here_bits;
	            bits -= here_bits;
	            //---//
	            if (state.have === 0) {
	              strm.msg = 'invalid bit length repeat';
	              state.mode = BAD;
	              break;
	            }
	            len = state.lens[state.have - 1];
	            copy = 3 + (hold & 0x03);//BITS(2);
	            //--- DROPBITS(2) ---//
	            hold >>>= 2;
	            bits -= 2;
	            //---//
	          }
	          else if (here_val === 17) {
	            //=== NEEDBITS(here.bits + 3);
	            n = here_bits + 3;
	            while (bits < n) {
	              if (have === 0) { break inf_leave; }
	              have--;
	              hold += input[next++] << bits;
	              bits += 8;
	            }
	            //===//
	            //--- DROPBITS(here.bits) ---//
	            hold >>>= here_bits;
	            bits -= here_bits;
	            //---//
	            len = 0;
	            copy = 3 + (hold & 0x07);//BITS(3);
	            //--- DROPBITS(3) ---//
	            hold >>>= 3;
	            bits -= 3;
	            //---//
	          }
	          else {
	            //=== NEEDBITS(here.bits + 7);
	            n = here_bits + 7;
	            while (bits < n) {
	              if (have === 0) { break inf_leave; }
	              have--;
	              hold += input[next++] << bits;
	              bits += 8;
	            }
	            //===//
	            //--- DROPBITS(here.bits) ---//
	            hold >>>= here_bits;
	            bits -= here_bits;
	            //---//
	            len = 0;
	            copy = 11 + (hold & 0x7f);//BITS(7);
	            //--- DROPBITS(7) ---//
	            hold >>>= 7;
	            bits -= 7;
	            //---//
	          }
	          if (state.have + copy > state.nlen + state.ndist) {
	            strm.msg = 'invalid bit length repeat';
	            state.mode = BAD;
	            break;
	          }
	          while (copy--) {
	            state.lens[state.have++] = len;
	          }
	        }
	      }

	      /* handle error breaks in while */
	      if (state.mode === BAD) { break; }

	      /* check for end-of-block code (better have one) */
	      if (state.lens[256] === 0) {
	        strm.msg = 'invalid code -- missing end-of-block';
	        state.mode = BAD;
	        break;
	      }

	      /* build code tables -- note: do not change the lenbits or distbits
	         values here (9 and 6) without reading the comments in inftrees.h
	         concerning the ENOUGH constants, which depend on those values */
	      state.lenbits = 9;

	      opts = { bits: state.lenbits };
	      ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
	      // We have separate tables & no pointers. 2 commented lines below not needed.
	      // state.next_index = opts.table_index;
	      state.lenbits = opts.bits;
	      // state.lencode = state.next;

	      if (ret) {
	        strm.msg = 'invalid literal/lengths set';
	        state.mode = BAD;
	        break;
	      }

	      state.distbits = 6;
	      //state.distcode.copy(state.codes);
	      // Switch to use dynamic table
	      state.distcode = state.distdyn;
	      opts = { bits: state.distbits };
	      ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
	      // We have separate tables & no pointers. 2 commented lines below not needed.
	      // state.next_index = opts.table_index;
	      state.distbits = opts.bits;
	      // state.distcode = state.next;

	      if (ret) {
	        strm.msg = 'invalid distances set';
	        state.mode = BAD;
	        break;
	      }
	      //Tracev((stderr, 'inflate:       codes ok\n'));
	      state.mode = LEN_;
	      if (flush === Z_TREES) { break inf_leave; }
	      /* falls through */
	    case LEN_:
	      state.mode = LEN;
	      /* falls through */
	    case LEN:
	      if (have >= 6 && left >= 258) {
	        //--- RESTORE() ---
	        strm.next_out = put;
	        strm.avail_out = left;
	        strm.next_in = next;
	        strm.avail_in = have;
	        state.hold = hold;
	        state.bits = bits;
	        //---
	        inflate_fast(strm, _out);
	        //--- LOAD() ---
	        put = strm.next_out;
	        output = strm.output;
	        left = strm.avail_out;
	        next = strm.next_in;
	        input = strm.input;
	        have = strm.avail_in;
	        hold = state.hold;
	        bits = state.bits;
	        //---

	        if (state.mode === TYPE) {
	          state.back = -1;
	        }
	        break;
	      }
	      state.back = 0;
	      for (;;) {
	        here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
	        here_bits = here >>> 24;
	        here_op = (here >>> 16) & 0xff;
	        here_val = here & 0xffff;

	        if (here_bits <= bits) { break; }
	        //--- PULLBYTE() ---//
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	        //---//
	      }
	      if (here_op && (here_op & 0xf0) === 0) {
	        last_bits = here_bits;
	        last_op = here_op;
	        last_val = here_val;
	        for (;;) {
	          here = state.lencode[last_val +
	                  ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
	          here_bits = here >>> 24;
	          here_op = (here >>> 16) & 0xff;
	          here_val = here & 0xffff;

	          if ((last_bits + here_bits) <= bits) { break; }
	          //--- PULLBYTE() ---//
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	          //---//
	        }
	        //--- DROPBITS(last.bits) ---//
	        hold >>>= last_bits;
	        bits -= last_bits;
	        //---//
	        state.back += last_bits;
	      }
	      //--- DROPBITS(here.bits) ---//
	      hold >>>= here_bits;
	      bits -= here_bits;
	      //---//
	      state.back += here_bits;
	      state.length = here_val;
	      if (here_op === 0) {
	        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
	        //        "inflate:         literal '%c'\n" :
	        //        "inflate:         literal 0x%02x\n", here.val));
	        state.mode = LIT;
	        break;
	      }
	      if (here_op & 32) {
	        //Tracevv((stderr, "inflate:         end of block\n"));
	        state.back = -1;
	        state.mode = TYPE;
	        break;
	      }
	      if (here_op & 64) {
	        strm.msg = 'invalid literal/length code';
	        state.mode = BAD;
	        break;
	      }
	      state.extra = here_op & 15;
	      state.mode = LENEXT;
	      /* falls through */
	    case LENEXT:
	      if (state.extra) {
	        //=== NEEDBITS(state.extra);
	        n = state.extra;
	        while (bits < n) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
	        //--- DROPBITS(state.extra) ---//
	        hold >>>= state.extra;
	        bits -= state.extra;
	        //---//
	        state.back += state.extra;
	      }
	      //Tracevv((stderr, "inflate:         length %u\n", state.length));
	      state.was = state.length;
	      state.mode = DIST;
	      /* falls through */
	    case DIST:
	      for (;;) {
	        here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
	        here_bits = here >>> 24;
	        here_op = (here >>> 16) & 0xff;
	        here_val = here & 0xffff;

	        if ((here_bits) <= bits) { break; }
	        //--- PULLBYTE() ---//
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	        //---//
	      }
	      if ((here_op & 0xf0) === 0) {
	        last_bits = here_bits;
	        last_op = here_op;
	        last_val = here_val;
	        for (;;) {
	          here = state.distcode[last_val +
	                  ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
	          here_bits = here >>> 24;
	          here_op = (here >>> 16) & 0xff;
	          here_val = here & 0xffff;

	          if ((last_bits + here_bits) <= bits) { break; }
	          //--- PULLBYTE() ---//
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	          //---//
	        }
	        //--- DROPBITS(last.bits) ---//
	        hold >>>= last_bits;
	        bits -= last_bits;
	        //---//
	        state.back += last_bits;
	      }
	      //--- DROPBITS(here.bits) ---//
	      hold >>>= here_bits;
	      bits -= here_bits;
	      //---//
	      state.back += here_bits;
	      if (here_op & 64) {
	        strm.msg = 'invalid distance code';
	        state.mode = BAD;
	        break;
	      }
	      state.offset = here_val;
	      state.extra = (here_op) & 15;
	      state.mode = DISTEXT;
	      /* falls through */
	    case DISTEXT:
	      if (state.extra) {
	        //=== NEEDBITS(state.extra);
	        n = state.extra;
	        while (bits < n) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
	        //--- DROPBITS(state.extra) ---//
	        hold >>>= state.extra;
	        bits -= state.extra;
	        //---//
	        state.back += state.extra;
	      }
	//#ifdef INFLATE_STRICT
	      if (state.offset > state.dmax) {
	        strm.msg = 'invalid distance too far back';
	        state.mode = BAD;
	        break;
	      }
	//#endif
	      //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
	      state.mode = MATCH;
	      /* falls through */
	    case MATCH:
	      if (left === 0) { break inf_leave; }
	      copy = _out - left;
	      if (state.offset > copy) {         /* copy from window */
	        copy = state.offset - copy;
	        if (copy > state.whave) {
	          if (state.sane) {
	            strm.msg = 'invalid distance too far back';
	            state.mode = BAD;
	            break;
	          }
	// (!) This block is disabled in zlib defailts,
	// don't enable it for binary compatibility
	//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
	//          Trace((stderr, "inflate.c too far\n"));
	//          copy -= state.whave;
	//          if (copy > state.length) { copy = state.length; }
	//          if (copy > left) { copy = left; }
	//          left -= copy;
	//          state.length -= copy;
	//          do {
	//            output[put++] = 0;
	//          } while (--copy);
	//          if (state.length === 0) { state.mode = LEN; }
	//          break;
	//#endif
	        }
	        if (copy > state.wnext) {
	          copy -= state.wnext;
	          from = state.wsize - copy;
	        }
	        else {
	          from = state.wnext - copy;
	        }
	        if (copy > state.length) { copy = state.length; }
	        from_source = state.window;
	      }
	      else {                              /* copy from output */
	        from_source = output;
	        from = put - state.offset;
	        copy = state.length;
	      }
	      if (copy > left) { copy = left; }
	      left -= copy;
	      state.length -= copy;
	      do {
	        output[put++] = from_source[from++];
	      } while (--copy);
	      if (state.length === 0) { state.mode = LEN; }
	      break;
	    case LIT:
	      if (left === 0) { break inf_leave; }
	      output[put++] = state.length;
	      left--;
	      state.mode = LEN;
	      break;
	    case CHECK:
	      if (state.wrap) {
	        //=== NEEDBITS(32);
	        while (bits < 32) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          // Use '|' insdead of '+' to make sure that result is signed
	          hold |= input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        _out -= left;
	        strm.total_out += _out;
	        state.total += _out;
	        if (_out) {
	          strm.adler = state.check =
	              /*UPDATE(state.check, put - _out, _out);*/
	              (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));

	        }
	        _out = left;
	        // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
	        if ((state.flags ? hold : zswap32(hold)) !== state.check) {
	          strm.msg = 'incorrect data check';
	          state.mode = BAD;
	          break;
	        }
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	        //Tracev((stderr, "inflate:   check matches trailer\n"));
	      }
	      state.mode = LENGTH;
	      /* falls through */
	    case LENGTH:
	      if (state.wrap && state.flags) {
	        //=== NEEDBITS(32);
	        while (bits < 32) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        if (hold !== (state.total & 0xffffffff)) {
	          strm.msg = 'incorrect length check';
	          state.mode = BAD;
	          break;
	        }
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	        //Tracev((stderr, "inflate:   length matches trailer\n"));
	      }
	      state.mode = DONE;
	      /* falls through */
	    case DONE:
	      ret = Z_STREAM_END;
	      break inf_leave;
	    case BAD:
	      ret = Z_DATA_ERROR;
	      break inf_leave;
	    case MEM:
	      return Z_MEM_ERROR;
	    case SYNC:
	      /* falls through */
	    default:
	      return Z_STREAM_ERROR;
	    }
	  }

	  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

	  /*
	     Return from inflate(), updating the total counts and the check value.
	     If there was no progress during the inflate() call, return a buffer
	     error.  Call updatewindow() to create and/or update the window state.
	     Note: a memory error from inflate() is non-recoverable.
	   */

	  //--- RESTORE() ---
	  strm.next_out = put;
	  strm.avail_out = left;
	  strm.next_in = next;
	  strm.avail_in = have;
	  state.hold = hold;
	  state.bits = bits;
	  //---

	  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
	                      (state.mode < CHECK || flush !== Z_FINISH))) {
	    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
	      state.mode = MEM;
	      return Z_MEM_ERROR;
	    }
	  }
	  _in -= strm.avail_in;
	  _out -= strm.avail_out;
	  strm.total_in += _in;
	  strm.total_out += _out;
	  state.total += _out;
	  if (state.wrap && _out) {
	    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
	      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
	  }
	  strm.data_type = state.bits + (state.last ? 64 : 0) +
	                    (state.mode === TYPE ? 128 : 0) +
	                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
	  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
	    ret = Z_BUF_ERROR;
	  }
	  return ret;
	}

	function inflateEnd(strm) {

	  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
	    return Z_STREAM_ERROR;
	  }

	  var state = strm.state;
	  if (state.window) {
	    state.window = null;
	  }
	  strm.state = null;
	  return Z_OK;
	}

	function inflateGetHeader(strm, head) {
	  var state;

	  /* check state */
	  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
	  state = strm.state;
	  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }

	  /* save header structure */
	  state.head = head;
	  head.done = false;
	  return Z_OK;
	}

	function inflateSetDictionary(strm, dictionary) {
	  var dictLength = dictionary.length;

	  var state;
	  var dictid;
	  var ret;

	  /* check state */
	  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }
	  state = strm.state;

	  if (state.wrap !== 0 && state.mode !== DICT) {
	    return Z_STREAM_ERROR;
	  }

	  /* check for correct dictionary identifier */
	  if (state.mode === DICT) {
	    dictid = 1; /* adler32(0, null, 0)*/
	    /* dictid = adler32(dictid, dictionary, dictLength); */
	    dictid = adler32(dictid, dictionary, dictLength, 0);
	    if (dictid !== state.check) {
	      return Z_DATA_ERROR;
	    }
	  }
	  /* copy dictionary to window using updatewindow(), which will amend the
	   existing dictionary if appropriate */
	  ret = updatewindow(strm, dictionary, dictLength, dictLength);
	  if (ret) {
	    state.mode = MEM;
	    return Z_MEM_ERROR;
	  }
	  state.havedict = 1;
	  // Tracev((stderr, "inflate:   dictionary set\n"));
	  return Z_OK;
	}

	exports.inflateReset = inflateReset;
	exports.inflateReset2 = inflateReset2;
	exports.inflateResetKeep = inflateResetKeep;
	exports.inflateInit = inflateInit;
	exports.inflateInit2 = inflateInit2;
	exports.inflate = inflate;
	exports.inflateEnd = inflateEnd;
	exports.inflateGetHeader = inflateGetHeader;
	exports.inflateSetDictionary = inflateSetDictionary;
	exports.inflateInfo = 'pako inflate (from Nodeca project)';

	/* Not implemented
	exports.inflateCopy = inflateCopy;
	exports.inflateGetDictionary = inflateGetDictionary;
	exports.inflateMark = inflateMark;
	exports.inflatePrime = inflatePrime;
	exports.inflateSync = inflateSync;
	exports.inflateSyncPoint = inflateSyncPoint;
	exports.inflateUndermine = inflateUndermine;
	*/

	},{"../utils/common":1,"./adler32":3,"./crc32":5,"./inffast":7,"./inftrees":9}],9:[function(pako_require,module,exports){
	'use strict';

	// (C) 1995-2013 Jean-loup Gailly and Mark Adler
	// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
	//
	// This software is provided 'as-is', without any express or implied
	// warranty. In no event will the authors be held liable for any damages
	// arising from the use of this software.
	//
	// Permission is granted to anyone to use this software for any purpose,
	// including commercial applications, and to alter it and redistribute it
	// freely, subject to the following restrictions:
	//
	// 1. The origin of this software must not be misrepresented; you must not
	//   claim that you wrote the original software. If you use this software
	//   in a product, an acknowledgment in the product documentation would be
	//   appreciated but is not required.
	// 2. Altered source versions must be plainly marked as such, and must not be
	//   misrepresented as being the original software.
	// 3. This notice may not be removed or altered from any source distribution.

	var utils = pako_require('../utils/common');

	var MAXBITS = 15;
	var ENOUGH_LENS = 852;
	var ENOUGH_DISTS = 592;
	//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

	var CODES = 0;
	var LENS = 1;
	var DISTS = 2;

	var lbase = [ /* Length codes 257..285 base */
	  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
	  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
	];

	var lext = [ /* Length codes 257..285 extra */
	  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
	  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
	];

	var dbase = [ /* Distance codes 0..29 base */
	  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
	  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
	  8193, 12289, 16385, 24577, 0, 0
	];

	var dext = [ /* Distance codes 0..29 extra */
	  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
	  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
	  28, 28, 29, 29, 64, 64
	];

	module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)
	{
	  var bits = opts.bits;
	      //here = opts.here; /* table entry for duplication */

	  var len = 0;               /* a code's length in bits */
	  var sym = 0;               /* index of code symbols */
	  var min = 0, max = 0;          /* minimum and maximum code lengths */
	  var root = 0;              /* number of index bits for root table */
	  var curr = 0;              /* number of index bits for current table */
	  var drop = 0;              /* code bits to drop for sub-table */
	  var left = 0;                   /* number of prefix codes available */
	  var used = 0;              /* code entries in table used */
	  var huff = 0;              /* Huffman code */
	  var incr;              /* for incrementing code, index */
	  var fill;              /* index for replicating entries */
	  var low;               /* low bits for current root entry */
	  var mask;              /* mask for low root bits */
	  var next;             /* next available space in table */
	  var base = null;     /* base value table to use */
	  var base_index = 0;
	//  var shoextra;    /* extra bits table to use */
	  var end;                    /* use base and extra for symbol > end */
	  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
	  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
	  var extra = null;
	  var extra_index = 0;

	  var here_bits, here_op, here_val;

	  /*
	   Process a set of code lengths to create a canonical Huffman code.  The
	   code lengths are lens[0..codes-1].  Each length corresponds to the
	   symbols 0..codes-1.  The Huffman code is generated by first sorting the
	   symbols by length from short to long, and retaining the symbol order
	   for codes with equal lengths.  Then the code starts with all zero bits
	   for the first code of the shortest length, and the codes are integer
	   increments for the same length, and zeros are appended as the length
	   increases.  For the deflate format, these bits are stored backwards
	   from their more natural integer increment ordering, and so when the
	   decoding tables are built in the large loop below, the integer codes
	   are incremented backwards.

	   This routine assumes, but does not check, that all of the entries in
	   lens[] are in the range 0..MAXBITS.  The caller must assure this.
	   1..MAXBITS is interpreted as that code length.  zero means that that
	   symbol does not occur in this code.

	   The codes are sorted by computing a count of codes for each length,
	   creating from that a table of starting indices for each length in the
	   sorted table, and then entering the symbols in order in the sorted
	   table.  The sorted table is work[], with that space being provided by
	   the caller.

	   The length counts are used for other purposes as well, i.e. finding
	   the minimum and maximum length codes, determining if there are any
	   codes at all, checking for a valid set of lengths, and looking ahead
	   at length counts to determine sub-table sizes when building the
	   decoding tables.
	   */

	  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
	  for (len = 0; len <= MAXBITS; len++) {
	    count[len] = 0;
	  }
	  for (sym = 0; sym < codes; sym++) {
	    count[lens[lens_index + sym]]++;
	  }

	  /* bound code lengths, force root to be within code lengths */
	  root = bits;
	  for (max = MAXBITS; max >= 1; max--) {
	    if (count[max] !== 0) { break; }
	  }
	  if (root > max) {
	    root = max;
	  }
	  if (max === 0) {                     /* no symbols to code at all */
	    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
	    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
	    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
	    table[table_index++] = (1 << 24) | (64 << 16) | 0;


	    //table.op[opts.table_index] = 64;
	    //table.bits[opts.table_index] = 1;
	    //table.val[opts.table_index++] = 0;
	    table[table_index++] = (1 << 24) | (64 << 16) | 0;

	    opts.bits = 1;
	    return 0;     /* no symbols, but wait for decoding to report error */
	  }
	  for (min = 1; min < max; min++) {
	    if (count[min] !== 0) { break; }
	  }
	  if (root < min) {
	    root = min;
	  }

	  /* check for an over-subscribed or incomplete set of lengths */
	  left = 1;
	  for (len = 1; len <= MAXBITS; len++) {
	    left <<= 1;
	    left -= count[len];
	    if (left < 0) {
	      return -1;
	    }        /* over-subscribed */
	  }
	  if (left > 0 && (type === CODES || max !== 1)) {
	    return -1;                      /* incomplete set */
	  }

	  /* generate offsets into symbol table for each length for sorting */
	  offs[1] = 0;
	  for (len = 1; len < MAXBITS; len++) {
	    offs[len + 1] = offs[len] + count[len];
	  }

	  /* sort symbols by length, by symbol order within each length */
	  for (sym = 0; sym < codes; sym++) {
	    if (lens[lens_index + sym] !== 0) {
	      work[offs[lens[lens_index + sym]]++] = sym;
	    }
	  }

	  /*
	   Create and fill in decoding tables.  In this loop, the table being
	   filled is at next and has curr index bits.  The code being used is huff
	   with length len.  That code is converted to an index by dropping drop
	   bits off of the bottom.  For codes where len is less than drop + curr,
	   those top drop + curr - len bits are incremented through all values to
	   fill the table with replicated entries.

	   root is the number of index bits for the root table.  When len exceeds
	   root, sub-tables are created pointed to by the root entry with an index
	   of the low root bits of huff.  This is saved in low to check for when a
	   new sub-table should be started.  drop is zero when the root table is
	   being filled, and drop is root when sub-tables are being filled.

	   When a new sub-table is needed, it is necessary to look ahead in the
	   code lengths to determine what size sub-table is needed.  The length
	   counts are used for this, and so count[] is decremented as codes are
	   entered in the tables.

	   used keeps track of how many table entries have been allocated from the
	   provided *table space.  It is checked for LENS and DIST tables against
	   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
	   the initial root table size constants.  See the comments in inftrees.h
	   for more information.

	   sym increments through all symbols, and the loop terminates when
	   all codes of length max, i.e. all codes, have been processed.  This
	   routine permits incomplete codes, so another loop after this one fills
	   in the rest of the decoding tables with invalid code markers.
	   */

	  /* set up for code type */
	  // poor man optimization - use if-else instead of switch,
	  // to avoid deopts in old v8
	  if (type === CODES) {
	    base = extra = work;    /* dummy value--not used */
	    end = 19;

	  } else if (type === LENS) {
	    base = lbase;
	    base_index -= 257;
	    extra = lext;
	    extra_index -= 257;
	    end = 256;

	  } else {                    /* DISTS */
	    base = dbase;
	    extra = dext;
	    end = -1;
	  }

	  /* initialize opts for loop */
	  huff = 0;                   /* starting code */
	  sym = 0;                    /* starting code symbol */
	  len = min;                  /* starting code length */
	  next = table_index;              /* current table to fill in */
	  curr = root;                /* current table index bits */
	  drop = 0;                   /* current bits to drop from code for index */
	  low = -1;                   /* trigger new sub-table when len > root */
	  used = 1 << root;          /* use root table entries */
	  mask = used - 1;            /* mask for comparing low */

	  /* check available table space */
	  if ((type === LENS && used > ENOUGH_LENS) ||
	    (type === DISTS && used > ENOUGH_DISTS)) {
	    return 1;
	  }

	  /* process all codes and make table entries */
	  for (;;) {
	    /* create table entry */
	    here_bits = len - drop;
	    if (work[sym] < end) {
	      here_op = 0;
	      here_val = work[sym];
	    }
	    else if (work[sym] > end) {
	      here_op = extra[extra_index + work[sym]];
	      here_val = base[base_index + work[sym]];
	    }
	    else {
	      here_op = 32 + 64;         /* end of block */
	      here_val = 0;
	    }

	    /* replicate for those indices with low len bits equal to huff */
	    incr = 1 << (len - drop);
	    fill = 1 << curr;
	    min = fill;                 /* save offset to next table */
	    do {
	      fill -= incr;
	      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
	    } while (fill !== 0);

	    /* backwards increment the len-bit code huff */
	    incr = 1 << (len - 1);
	    while (huff & incr) {
	      incr >>= 1;
	    }
	    if (incr !== 0) {
	      huff &= incr - 1;
	      huff += incr;
	    } else {
	      huff = 0;
	    }

	    /* go to next symbol, update count, len */
	    sym++;
	    if (--count[len] === 0) {
	      if (len === max) { break; }
	      len = lens[lens_index + work[sym]];
	    }

	    /* create new sub-table if needed */
	    if (len > root && (huff & mask) !== low) {
	      /* if first time, transition to sub-tables */
	      if (drop === 0) {
	        drop = root;
	      }

	      /* increment past last table */
	      next += min;            /* here min is 1 << curr */

	      /* determine length of next table */
	      curr = len - drop;
	      left = 1 << curr;
	      while (curr + drop < max) {
	        left -= count[curr + drop];
	        if (left <= 0) { break; }
	        curr++;
	        left <<= 1;
	      }

	      /* check for enough space */
	      used += 1 << curr;
	      if ((type === LENS && used > ENOUGH_LENS) ||
	        (type === DISTS && used > ENOUGH_DISTS)) {
	        return 1;
	      }

	      /* point entry in root table to sub-table */
	      low = huff & mask;
	      /*table.op[low] = curr;
	      table.bits[low] = root;
	      table.val[low] = next - opts.table_index;*/
	      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
	    }
	  }

	  /* fill in remaining table entry if code is incomplete (guaranteed to have
	   at most one remaining entry, since if the code is incomplete, the
	   maximum code length that was allowed to get this far is one bit) */
	  if (huff !== 0) {
	    //table.op[next + huff] = 64;            /* invalid code marker */
	    //table.bits[next + huff] = len - drop;
	    //table.val[next + huff] = 0;
	    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
	  }

	  /* set return parameters */
	  //opts.table_index += used;
	  opts.bits = root;
	  return 0;
	};

	},{"../utils/common":1}],10:[function(pako_require,module,exports){
	'use strict';

	// (C) 1995-2013 Jean-loup Gailly and Mark Adler
	// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
	//
	// This software is provided 'as-is', without any express or implied
	// warranty. In no event will the authors be held liable for any damages
	// arising from the use of this software.
	//
	// Permission is granted to anyone to use this software for any purpose,
	// including commercial applications, and to alter it and redistribute it
	// freely, subject to the following restrictions:
	//
	// 1. The origin of this software must not be misrepresented; you must not
	//   claim that you wrote the original software. If you use this software
	//   in a product, an acknowledgment in the product documentation would be
	//   appreciated but is not required.
	// 2. Altered source versions must be plainly marked as such, and must not be
	//   misrepresented as being the original software.
	// 3. This notice may not be removed or altered from any source distribution.

	module.exports = {
	  2:      'need dictionary',     /* Z_NEED_DICT       2  */
	  1:      'stream end',          /* Z_STREAM_END      1  */
	  0:      '',                    /* Z_OK              0  */
	  '-1':   'file error',          /* Z_ERRNO         (-1) */
	  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
	  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
	  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
	  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
	  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
	};

	},{}],11:[function(pako_require,module,exports){
	'use strict';

	// (C) 1995-2013 Jean-loup Gailly and Mark Adler
	// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
	//
	// This software is provided 'as-is', without any express or implied
	// warranty. In no event will the authors be held liable for any damages
	// arising from the use of this software.
	//
	// Permission is granted to anyone to use this software for any purpose,
	// including commercial applications, and to alter it and redistribute it
	// freely, subject to the following restrictions:
	//
	// 1. The origin of this software must not be misrepresented; you must not
	//   claim that you wrote the original software. If you use this software
	//   in a product, an acknowledgment in the product documentation would be
	//   appreciated but is not required.
	// 2. Altered source versions must be plainly marked as such, and must not be
	//   misrepresented as being the original software.
	// 3. This notice may not be removed or altered from any source distribution.

	function ZStream() {
	  /* next input byte */
	  this.input = null; // JS specific, because we have no pointers
	  this.next_in = 0;
	  /* number of bytes available at input */
	  this.avail_in = 0;
	  /* total number of input bytes read so far */
	  this.total_in = 0;
	  /* next output byte should be put there */
	  this.output = null; // JS specific, because we have no pointers
	  this.next_out = 0;
	  /* remaining free space at output */
	  this.avail_out = 0;
	  /* total number of bytes output so far */
	  this.total_out = 0;
	  /* last error message, NULL if no error */
	  this.msg = ''/*Z_NULL*/;
	  /* not visible by applications */
	  this.state = null;
	  /* best guess about the data type: binary or text */
	  this.data_type = 2/*Z_UNKNOWN*/;
	  /* adler32 value of the uncompressed data */
	  this.adler = 0;
	}

	module.exports = ZStream;

	},{}],"/lib/inflate.js":[function(pako_require,module,exports){
	'use strict';


	var zlib_inflate = pako_require('./zlib/inflate');
	var utils        = pako_require('./utils/common');
	var strings      = pako_require('./utils/strings');
	var c            = pako_require('./zlib/constants');
	var msg          = pako_require('./zlib/messages');
	var ZStream      = pako_require('./zlib/zstream');
	var GZheader     = pako_require('./zlib/gzheader');

	var toString = Object.prototype.toString;

	/**
	 * class Inflate
	 *
	 * Generic JS-style wrapper for zlib calls. If you don't need
	 * streaming behaviour - use more simple functions: [[inflate]]
	 * and [[inflateRaw]].
	 **/

	/* internal
	 * inflate.chunks -> Array
	 *
	 * Chunks of output data, if [[Inflate#onData]] not overriden.
	 **/

	/**
	 * Inflate.result -> Uint8Array|Array|String
	 *
	 * Uncompressed result, generated by default [[Inflate#onData]]
	 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
	 * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you
	 * push a chunk with explicit flush (call [[Inflate#push]] with
	 * `Z_SYNC_FLUSH` param).
	 **/

	/**
	 * Inflate.err -> Number
	 *
	 * Error code after inflate finished. 0 (Z_OK) on success.
	 * Should be checked if broken data possible.
	 **/

	/**
	 * Inflate.msg -> String
	 *
	 * Error message, if [[Inflate.err]] != 0
	 **/


	/**
	 * new Inflate(options)
	 * - options (Object): zlib inflate options.
	 *
	 * Creates new inflator instance with specified params. Throws exception
	 * on bad params. Supported options:
	 *
	 * - `windowBits`
	 * - `dictionary`
	 *
	 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
	 * for more information on these.
	 *
	 * Additional options, for internal needs:
	 *
	 * - `chunkSize` - size of generated data chunks (16K by default)
	 * - `raw` (Boolean) - do raw inflate
	 * - `to` (String) - if equal to 'string', then result will be converted
	 *   from utf8 to utf16 (javascript) string. When string output requested,
	 *   chunk length can differ from `chunkSize`, depending on content.
	 *
	 * By default, when no options set, autodetect deflate/gzip data format via
	 * wrapper header.
	 *
	 * ##### Example:
	 *
	 * ```javascript
	 * var pako = pako_require('pako')
	 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
	 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
	 *
	 * var inflate = new pako.Inflate({ level: 3});
	 *
	 * inflate.push(chunk1, false);
	 * inflate.push(chunk2, true);  // true -> last chunk
	 *
	 * if (inflate.err) { throw new Error(inflate.err); }
	 *
	 * console.log(inflate.result);
	 * ```
	 **/
	function Inflate(options) {
	  if (!(this instanceof Inflate)) return new Inflate(options);

	  this.options = utils.assign({
	    chunkSize: 16384,
	    windowBits: 0,
	    to: ''
	  }, options || {});

	  var opt = this.options;

	  // Force window size for `raw` data, if not set directly,
	  // because we have no header for autodetect.
	  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
	    opt.windowBits = -opt.windowBits;
	    if (opt.windowBits === 0) { opt.windowBits = -15; }
	  }

	  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
	  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
	      !(options && options.windowBits)) {
	    opt.windowBits += 32;
	  }

	  // Gzip header has no info about windows size, we can do autodetect only
	  // for deflate. So, if window size not set, force it to max when gzip possible
	  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
	    // bit 3 (16) -> gzipped data
	    // bit 4 (32) -> autodetect gzip/deflate
	    if ((opt.windowBits & 15) === 0) {
	      opt.windowBits |= 15;
	    }
	  }

	  this.err    = 0;      // error code, if happens (0 = Z_OK)
	  this.msg    = '';     // error message
	  this.ended  = false;  // used to avoid multiple onEnd() calls
	  this.chunks = [];     // chunks of compressed data

	  this.strm   = new ZStream();
	  this.strm.avail_out = 0;

	  var status  = zlib_inflate.inflateInit2(
	    this.strm,
	    opt.windowBits
	  );

	  if (status !== c.Z_OK) {
	    throw new Error(msg[status]);
	  }

	  this.header = new GZheader();

	  zlib_inflate.inflateGetHeader(this.strm, this.header);
	}

	/**
	 * Inflate#push(data[, mode]) -> Boolean
	 * - data (Uint8Array|Array|ArrayBuffer|String): input data
	 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
	 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` meansh Z_FINISH.
	 *
	 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
	 * new output chunks. Returns `true` on success. The last data block must have
	 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
	 * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you
	 * can use mode Z_SYNC_FLUSH, keeping the decompression context.
	 *
	 * On fail call [[Inflate#onEnd]] with error code and return false.
	 *
	 * We strongly recommend to use `Uint8Array` on input for best speed (output
	 * format is detected automatically). Also, don't skip last param and always
	 * use the same type in your code (boolean or number). That will improve JS speed.
	 *
	 * For regular `Array`-s make sure all elements are [0..255].
	 *
	 * ##### Example
	 *
	 * ```javascript
	 * push(chunk, false); // push one of data chunks
	 * ...
	 * push(chunk, true);  // push last chunk
	 * ```
	 **/
	Inflate.prototype.push = function (data, mode) {
	  var strm = this.strm;
	  var chunkSize = this.options.chunkSize;
	  var dictionary = this.options.dictionary;
	  var status, _mode;
	  var next_out_utf8, tail, utf8str;
	  var dict;

	  // Flag to properly process Z_BUF_ERROR on testing inflate call
	  // when we check that all output data was flushed.
	  var allowBufError = false;

	  if (this.ended) { return false; }
	  _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);

	  // Convert data if needed
	  if (typeof data === 'string') {
	    // Only binary strings can be decompressed on practice
	    strm.input = strings.binstring2buf(data);
	  } else if (toString.call(data) === '[object ArrayBuffer]') {
	    strm.input = new Uint8Array(data);
	  } else {
	    strm.input = data;
	  }

	  strm.next_in = 0;
	  strm.avail_in = strm.input.length;

	  do {
	    if (strm.avail_out === 0) {
	      strm.output = new utils.Buf8(chunkSize);
	      strm.next_out = 0;
	      strm.avail_out = chunkSize;
	    }

	    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);    /* no bad return value */

	    if (status === c.Z_NEED_DICT && dictionary) {
	      // Convert data if needed
	      if (typeof dictionary === 'string') {
	        dict = strings.string2buf(dictionary);
	      } else if (toString.call(dictionary) === '[object ArrayBuffer]') {
	        dict = new Uint8Array(dictionary);
	      } else {
	        dict = dictionary;
	      }

	      status = zlib_inflate.inflateSetDictionary(this.strm, dict);

	    }

	    if (status === c.Z_BUF_ERROR && allowBufError === true) {
	      status = c.Z_OK;
	      allowBufError = false;
	    }

	    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
	      this.onEnd(status);
	      this.ended = true;
	      return false;
	    }

	    if (strm.next_out) {
	      if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {

	        if (this.options.to === 'string') {

	          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

	          tail = strm.next_out - next_out_utf8;
	          utf8str = strings.buf2string(strm.output, next_out_utf8);

	          // move tail
	          strm.next_out = tail;
	          strm.avail_out = chunkSize - tail;
	          if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }

	          this.onData(utf8str);

	        } else {
	          this.onData(utils.shrinkBuf(strm.output, strm.next_out));
	        }
	      }
	    }

	    // When no more input data, we should check that internal inflate buffers
	    // are flushed. The only way to do it when avail_out = 0 - run one more
	    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.
	    // Here we set flag to process this error properly.
	    //
	    // NOTE. Deflate does not return error in this case and does not needs such
	    // logic.
	    if (strm.avail_in === 0 && strm.avail_out === 0) {
	      allowBufError = true;
	    }

	  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);

	  if (status === c.Z_STREAM_END) {
	    _mode = c.Z_FINISH;
	  }

	  // Finalize on the last chunk.
	  if (_mode === c.Z_FINISH) {
	    status = zlib_inflate.inflateEnd(this.strm);
	    this.onEnd(status);
	    this.ended = true;
	    return status === c.Z_OK;
	  }

	  // callback interim results if Z_SYNC_FLUSH.
	  if (_mode === c.Z_SYNC_FLUSH) {
	    this.onEnd(c.Z_OK);
	    strm.avail_out = 0;
	    return true;
	  }

	  return true;
	};


	/**
	 * Inflate#onData(chunk) -> Void
	 * - chunk (Uint8Array|Array|String): ouput data. Type of array depends
	 *   on js engine support. When string output requested, each chunk
	 *   will be string.
	 *
	 * By default, stores data blocks in `chunks[]` property and glue
	 * those in `onEnd`. Override this handler, if you need another behaviour.
	 **/
	Inflate.prototype.onData = function (chunk) {
	  this.chunks.push(chunk);
	};


	/**
	 * Inflate#onEnd(status) -> Void
	 * - status (Number): inflate status. 0 (Z_OK) on success,
	 *   other if not.
	 *
	 * Called either after you tell inflate that the input stream is
	 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
	 * or if an error happened. By default - join collected chunks,
	 * free memory and fill `results` / `err` properties.
	 **/
	Inflate.prototype.onEnd = function (status) {
	  // On success - join
	  if (status === c.Z_OK) {
	    if (this.options.to === 'string') {
	      // Glue & convert here, until we teach pako to send
	      // utf8 alligned strings to onData
	      this.result = this.chunks.join('');
	    } else {
	      this.result = utils.flattenChunks(this.chunks);
	    }
	  }
	  this.chunks = [];
	  this.err = status;
	  this.msg = this.strm.msg;
	};


	/**
	 * inflate(data[, options]) -> Uint8Array|Array|String
	 * - data (Uint8Array|Array|String): input data to decompress.
	 * - options (Object): zlib inflate options.
	 *
	 * Decompress `data` with inflate/ungzip and `options`. Autodetect
	 * format via wrapper header by default. That's why we don't provide
	 * separate `ungzip` method.
	 *
	 * Supported options are:
	 *
	 * - windowBits
	 *
	 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
	 * for more information.
	 *
	 * Sugar (options):
	 *
	 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
	 *   negative windowBits implicitly.
	 * - `to` (String) - if equal to 'string', then result will be converted
	 *   from utf8 to utf16 (javascript) string. When string output requested,
	 *   chunk length can differ from `chunkSize`, depending on content.
	 *
	 *
	 * ##### Example:
	 *
	 * ```javascript
	 * var pako = pako_require('pako')
	 *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])
	 *   , output;
	 *
	 * try {
	 *   output = pako.inflate(input);
	 * } catch (err)
	 *   console.log(err);
	 * }
	 * ```
	 **/
	function inflate(input, options) {
	  var inflator = new Inflate(options);

	  inflator.push(input, true);

	  // That will never happens, if you don't cheat with options :)
	  if (inflator.err) { throw inflator.msg || msg[inflator.err]; }

	  return inflator.result;
	}


	/**
	 * inflateRaw(data[, options]) -> Uint8Array|Array|String
	 * - data (Uint8Array|Array|String): input data to decompress.
	 * - options (Object): zlib inflate options.
	 *
	 * The same as [[inflate]], but creates raw data, without wrapper
	 * (header and adler32 crc).
	 **/
	function inflateRaw(input, options) {
	  options = options || {};
	  options.raw = true;
	  return inflate(input, options);
	}


	/**
	 * ungzip(data[, options]) -> Uint8Array|Array|String
	 * - data (Uint8Array|Array|String): input data to decompress.
	 * - options (Object): zlib inflate options.
	 *
	 * Just shortcut to [[inflate]], because it autodetects format
	 * by header.content. Done for convenience.
	 **/


	exports.Inflate = Inflate;
	exports.inflate = inflate;
	exports.inflateRaw = inflateRaw;
	exports.ungzip  = inflate;

	},{"./utils/common":1,"./utils/strings":2,"./zlib/constants":4,"./zlib/gzheader":6,"./zlib/inflate":8,"./zlib/messages":10,"./zlib/zstream":11}]},{},[])("/lib/inflate.js")
	});

	exports.inflate = window.pako.inflate;

	}

	var pako_inflate_factory = register("pako_inflate", Pako_inflate);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Sound effects internal API.
	 * @name sfx
	 * @namespace
	 * @exports exports as sfx
	 */
	function Int_SFX(ns, exports) {

	var m_cfg   = int_config_factory(ns);
	var m_print = print_factory(ns);
	var m_quat  = quat_factory(ns);
	var m_time  = int_time_factory(ns);
	var m_tsr   = int_tsr_factory(ns);
	var m_util  = int_util_factory(ns);
	var m_vec3  = vec3_factory(ns);

	var cfg_def = m_cfg.defaults;
	var cfg_sfx = m_cfg.sfx;

	var DOPPLER_SMOOTH_PERIOD = 0.3;

	var SPKSTATE_UNDEFINED  = 10;
	var SPKSTATE_PLAY       = 20;
	var SPKSTATE_STOP       = 30;
	var SPKSTATE_PAUSE      = 40;
	var SPKSTATE_FINISH     = 50;

	var SCHED_PARAM_LOOPS = 5;
	var SCHED_PARAM_ANTICIPATE_TIME = 3.0;

	var _vec3_tmp = new Float32Array(3);
	var _vec3_tmp2 = new Float32Array(3);
	var _quat_tmp = m_quat.create();

	// permanent vars
	var _supported_audio = [];
	var _supported_video = [];
	var _wa = null;

	// per-loaded-scene vars
	var _active_scene = null;
	var _speaker_objects = [];

	var _seed_tmp = [1];

	var _playlist = null;

	// audio source types
	exports.AST_NONE         = 10;
	exports.AST_ARRAY_BUFFER = 20;
	exports.AST_HTML_ELEMENT = 30;

	exports.create_sfx = function() {
	    var sfx = {
	        uuid: -1,
	        filepath: "",

	        behavior: "NONE",
	        muted: false,

	        volume: 1,
	        pitch: 1,
	        attenuation: 1,
	        dist_ref: 1,
	        dist_max: 10000,

	        cone_angle_inner: 360,
	        cone_angle_outer: 360,
	        cone_volume_outer: 1,

	        autoplay: false,
	        cyclic: false,

	        loop: false,

	        // buffer time
	        loop_start: 0,
	        loop_end: 0,

	        delay: 0,
	        delay_random: 0,

	        volume_random: 0,
	        pitch_random: 0,
	        fade_in: 0,
	        fade_out: 0,

	        start_time: 0,
	        pause_time: 0,
	        buf_offset: 0,
	        duration: 0,
	        vp_rand_end_time: 0,

	        base_seed: 1,

	        src: null,

	        // initial state
	        state: SPKSTATE_UNDEFINED,

	        last_position: new Float32Array(3),
	        velocity: new Float32Array(3),

	        enable_doppler: false,
	        last_doppler_shift: 1,

	        // for BACKGROUND_MUSIC
	        bgm_start_timeout: -1,
	        bgm_stop_timeout: -1,

	        duck_time: 0,

	        // nodes
	        proc_chain_in: null,    
	        source_node: null,
	        source_node2: null,
	        panner_node: null,
	        filter_node: null,
	        gain_node: null,
	        fade_gain_node: null,
	        rand_gain_node: null,

	        update_counter: 0
	    };

	    return sfx;
	};


	/**
	 * Initialize sound effects module
	 */
	exports.init = function() {
	    // NOTE: DOM Exception 5 if not found
	    var audio = document.createElement("audio");
	    var video = document.createElement("video");
	    // do not detect codecs here, simply follow the rules:
	    // ogg - vorbis
	    // mp3 - mp3
	    // mp4 - aac
	    if (audio.canPlayType) {
	        if (audio.canPlayType("audio/ogg") != "") {
	            _supported_audio.push("ogg");
	            _supported_audio.push("ogv");
	            _supported_audio.push("oga");
	        }
	        if (audio.canPlayType("audio/mpeg") != "")
	            _supported_audio.push("mp3");
	        if (audio.canPlayType("audio/mp4") != "") {
	            _supported_audio.push("mp4");
	            _supported_audio.push("m4v");
	            _supported_audio.push("m4a");
	        }
	        if (audio.canPlayType("audio/webm") != "")
	            _supported_audio.push("webm");
	    }

	    if (video.canPlayType) {
	        if (video.canPlayType("video/ogg") != "") {
	            _supported_video.push("ogv");
	            _supported_video.push("ogg");
	            _supported_video.push("oga");
	        }
	        if (video.canPlayType("video/mp4") != "") {
	            _supported_video.push("m4v");
	            _supported_video.push("mp4");
	        }
	        if (video.canPlayType("video/webm") != "")
	            _supported_video.push("webm");
	        if (video.canPlayType("video/mpeg") != "")
	            _supported_video.push("mp3");
	    }
	};

	exports.attach_scene_sfx = function(scene) {

	    // NOTE: register context once and reuse for all loaded scenes to prevent
	    // out-of-resources error due to Chromium context leaks
	    if (cfg_sfx.webaudio && !_wa) {
	        _wa = create_wa_context();
	        if (_wa)
	            m_print.log("%cINIT WEBAUDIO: " + _wa.sampleRate + "Hz", "color: #00a");
	    }

	    if (_wa) {
	        var scene_sfx = {
	            listener_last_eye : new Float32Array(3),
	            listener_velocity : new Float32Array(3),
	            update_counter: 0
	        };

	        var gnode = _wa.createGain();
	        var fade_gnode = _wa.createGain();

	        scene_sfx.gain_node = gnode;
	        scene_sfx.fade_gain_node = fade_gnode;

	        gnode.connect(fade_gnode);
	        fade_gnode.connect(_wa.destination);

	        if (scene["b4w_enable_dynamic_compressor"]) {
	            var compressor = _wa.createDynamicsCompressor();

	            var dcs = scene["b4w_dynamic_compressor_settings"];

	            compressor.threshold.value = dcs["threshold"];
	            compressor.knee.value = dcs["knee"];
	            compressor.ratio.value = dcs["ratio"];
	            compressor.attack.value = dcs["attack"];
	            compressor.release.value = dcs["release"];

	            compressor.connect(gnode);
	            scene_sfx.compressor_node = compressor;
	            scene_sfx.proc_chain_in = compressor;
	        } else {
	            scene_sfx.compressor_node = null;
	            scene_sfx.proc_chain_in = gnode;
	        }

	        switch (scene["audio_distance_model"]) {
	        case "INVERSE":
	        case "INVERSE_CLAMPED":
	            scene_sfx.distance_model = "inverse";
	            break;
	        case "LINEAR":
	        case "LINEAR_CLAMPED":
	            scene_sfx.distance_model = "linear";
	            break;
	        case "EXPONENT":
	        case "EXPONENT_CLAMPED":
	            scene_sfx.distance_model = "exponential";
	            break;
	        case "NONE":
	            scene_sfx.distance_model = "none";
	            break;
	        default:
	            m_util.panic("Wrong audio distance model");
	        }

	        scene_sfx.doppler_factor = scene["audio_doppler_factor"];
	        scene_sfx.speed_of_sound = scene["audio_doppler_speed"];

	        scene_sfx.muted = false;
	        scene_sfx.volume = scene["audio_volume"];
	        gnode.gain.value = calc_gain(scene_sfx);
	        scene_sfx.duck_time = 0;
	    } else
	        var scene_sfx = null;

	    scene._sfx = scene_sfx;
	};

	function create_wa_context() {

	    var AudioContext = window.AudioContext || window.webkitAudioContext;
	    if (AudioContext) {
	        try {
	            var ctx = new AudioContext();
	        } catch (e) {
	            m_print.error("Unable to initialize AudioContext: \"" + e + "\". The audio is disabled.");
	            return null;
	        }

	        // simple WebAudio version check
	        if (ctx.createGain) {
	            return ctx;
	        } else {
	            m_print.warn("deprecated WebAudio implementation");
	            return null;
	        }
	    } else {
	        m_print.warn("WebAudio is not supported");
	        return null;
	    }
	}


	exports.set_active_scene = function(scene) {
	    _active_scene = scene;
	};

	exports.detect_audio_container = function(extension) {
	    if (!extension)
	        extension = "ogg";

	    // only one fallback required in most cases

	    // requested hint is supported
	    if (_supported_audio.indexOf(extension) > -1)
	        return extension;
	    else if (_supported_audio.indexOf("m4a") > -1)
	        return "m4a";
	    else if (_supported_audio.indexOf("oga") > -1)
	        return "oga";
	    else
	        return "";
	};

	exports.detect_video_container = function(extension) {
	    if (!extension)
	        extension = "webm";

	    // only one fallback required in most cases

	    // requested hint is supported
	    if (_supported_video.indexOf(extension) > -1)
	        return extension;
	    else if (_supported_video.indexOf("m4v") > -1)
	        return "m4v";
	    else if (_supported_video.indexOf("webm") > -1)
	        return "webm";
	    else
	        return "";
	};

	/**
	 * Update speaker object from bpy_object, adding some properties
	 */
	exports.update_object = function(bpy_obj, obj) {

	    var speaker = bpy_obj["data"];
	    var sfx = obj.sfx;

	    if (!bpy_obj["data"]["sound"])
	        return;

	    sfx.uuid = bpy_obj["data"]["sound"]["uuid"];
	    sfx.filepath = bpy_obj["data"]["sound"]["filepath"];

	    switch (speaker["b4w_behavior"]) {
	    case "POSITIONAL":
	    case "BACKGROUND_SOUND":
	        sfx.behavior = _wa ? speaker["b4w_behavior"] : "NONE";
	        break;
	    case "BACKGROUND_MUSIC":
	        sfx.behavior = _wa ? (check_media_element_node() && !cfg_def.chrome_html_bkg_music_hack ?
	                "BACKGROUND_MUSIC" : "BACKGROUND_SOUND") : "NONE";
	        break;
	    default:
	        m_util.panic("Wrong speaker behavior");
	        break;
	    }

	    // NOTE: temporary compatibility actions: allow speakers without sound
	    if (!speaker["sound"])
	        sfx.behavior = "NONE";

	    sfx.enable_doppler = speaker["b4w_enable_doppler"];

	    sfx.muted = speaker["muted"];
	    sfx.volume = speaker["volume"];
	    sfx.pitch = speaker["pitch"];

	    sfx.attenuation = speaker["attenuation"];
	    sfx.dist_ref = speaker["distance_reference"];
	    sfx.dist_max = speaker["distance_max"] || 10000; // spec def
	    sfx.cone_angle_inner = speaker["cone_angle_inner"];
	    sfx.cone_angle_outer = speaker["cone_angle_outer"];
	    sfx.cone_volume_outer = speaker["cone_volume_outer"];
	    sfx.autoplay = speaker["b4w_auto_play"];
	    sfx.cyclic = speaker["b4w_cyclic_play"];
	    sfx.loop = speaker["b4w_loop"];
	    sfx.loop_start = speaker["b4w_loop_start"];
	    sfx.loop_end = speaker["b4w_loop_end"];

	    sfx.delay = speaker["b4w_delay"];
	    sfx.delay_random = speaker["b4w_delay_random"];

	    sfx.volume_random = speaker["b4w_volume_random"];
	    sfx.pitch_random = speaker["b4w_pitch_random"];
	    sfx.fade_in = speaker["b4w_fade_in"];
	    sfx.fade_out = speaker["b4w_fade_out"];

	    _speaker_objects.push(obj);
	};

	function check_media_element_node() {
	    if (window.MediaElementAudioSourceNode) {
	        return true;
	    } else {
	        m_print.warn("MediaElementAudioSourceNode not found");
	        return false;
	    }
	}

	/**
	 * Returns audio source type for given object (AST_*)
	 * @param {Object3D} obj Object 3D
	 */
	exports.source_type = function(obj) {
	    if (obj.type != "SPEAKER")
	        m_util.panic("Wrong object type");

	    switch (obj.sfx.behavior) {
	    case "POSITIONAL":
	        return exports.AST_ARRAY_BUFFER;
	    case "BACKGROUND_SOUND":
	        return exports.AST_ARRAY_BUFFER;
	    case "BACKGROUND_MUSIC":
	        return exports.AST_HTML_ELEMENT;
	    case "NONE":
	        return exports.AST_NONE;
	    default:
	        m_util.panic("Wrong speaker behavior");
	    }
	};

	/**
	 * Updates speaker object with loaded sound data
	 * @param {Object3D} obj Object 3D
	 * @param {ArrayBuffer|HTMLAudioElement} sound_data Sound Data
	 */
	exports.update_spkobj = function(obj, sound_data) {

	    var sfx = obj.sfx;

	    switch (sfx.behavior) {
	    case "POSITIONAL":
	    case "BACKGROUND_SOUND":
	    case "BACKGROUND_MUSIC":
	        sfx.src = sound_data;
	        // TODO: prepare audio graph here
	        break;
	    case "NONE":
	        break;
	    default:
	        m_util.panic("Wrong speaker behavior");
	    }
	};

	/**
	 * HACK: Initialize WebAudio context for iOS mobile devices
	 */
	exports.play_empty_sound = function() {
	    var source = _wa.createBufferSource();
	    source.buffer = _wa.createBuffer(1, 22050, 22050);
	    source.connect(_wa.destination);
	    source.start(0);
	};

	exports.decode_audio_data = function(arr_buf, decode_cb, fail_cb) {
	    if (_wa)
	        _wa.decodeAudioData(arr_buf, decode_cb, fail_cb);
	    else
	        fail_cb();
	};

	/**
	 * NOTE: may be buggy
	 */
	exports.speaker_remove = function(obj) {
	    stop(obj);

	    obj.sfx = null;
	    _speaker_objects.splice(_speaker_objects.indexOf(obj), 1);
	};

	/**
	 * Perform module cleanup
	 */
	exports.cleanup = function() {

	    for (var i = 0; i < _speaker_objects.length; i++) {
	        var obj = _speaker_objects[i];
	        var sfx = obj.sfx;
	        if (sfx.behavior == "BACKGROUND_MUSIC") {
	            var audio_el = sfx.src;
	            if (audio_el)
	                audio_el.pause();
	        } else {
	            if (sfx.source_node)
	                sfx.source_node.disconnect();
	            if (sfx.source_node2)
	                sfx.source_node2.disconnect();
	        }
	    }

	    if (_active_scene && _active_scene._sfx) {
	        var scene_sfx = _active_scene._sfx;
	        scene_sfx.listener_last_eye[0] = 0;
	        scene_sfx.listener_last_eye[1] = 0;
	        scene_sfx.listener_last_eye[2] = 0;
	        scene_sfx.listener_velocity[0] = 0;
	        scene_sfx.listener_velocity[1] = 0;
	        scene_sfx.listener_velocity[2] = 0;
	    }

	    _active_scene = null;
	    _speaker_objects.splice(0);
	    _playlist = null;
	};


	/**
	 * Update speaker objects used by module
	 * executed every frame
	 * @param {number} elapsed Number of float seconds since previous execution
	 */
	exports.update = function(timeline, elapsed) {

	    if (!_wa || _speaker_objects.length == 0)
	        return;

	    for (var i = 0; i < _speaker_objects.length; i++) {
	        var obj = _speaker_objects[i];
	        var sfx = obj.sfx;
	        var source = sfx.source_node;

	        var curr_time = _wa.currentTime;

	        // finish state may be already set by onended handler
	        if (!sfx.loop && sfx.state == SPKSTATE_PLAY && sfx.duration &&
	                (sfx.start_time + sfx.duration < curr_time) &&
	                (sfx.behavior == "BACKGROUND_MUSIC" ||
	                 // if onended is not supported
	                 (source && !m_util.isdef(source.onended))))
	            sfx.state = SPKSTATE_FINISH;

	        // handle restarts
	        if (sfx.cyclic && sfx.state == SPKSTATE_FINISH)
	            play_def(obj);

	        // handle volume pitch randomization
	        if (sfx.state == SPKSTATE_PLAY && (sfx.vp_rand_end_time - curr_time) <
	                SCHED_PARAM_ANTICIPATE_TIME)
	            schedule_volume_pitch_random(sfx);
	    }

	    // handle playlist
	    if (_playlist && _playlist.speakers.length && (_playlist.active == -1 
	            || timeline > _playlist.active_start_time 
	            + _playlist.durations[_playlist.active]))
	        playlist_switch_next(_playlist, timeline);
	};

	function playlist_switch_next(playlist, timeline) {
	    if (playlist.active > -1)
	        stop(playlist.speakers[playlist.active]);

	    if (playlist.active == -1 && playlist.random) {
	        var next = Math.round(Math.random() * (playlist.speakers.length - 1));
	    } else if (playlist.random) {
	        var advance = 1 + Math.round(Math.random() * (playlist.speakers.length - 2));
	        var next = (playlist.active + advance) % playlist.speakers.length;
	    } else
	        var next = (playlist.active + 1) % playlist.speakers.length;

	    play_def(playlist.speakers[next]);

	    playlist.active = next;
	    playlist.active_start_time = timeline;
	}

	exports.play = play;
	function play(obj, when, duration) {

	    var sfx = obj.sfx;

	    if (sfx.behavior == "NONE")
	        return;

	    var loop = sfx.loop;
	    var playrate = sfx.pitch;

	    // not ready or too late
	    if (!(sfx.src && (loop || duration >= 0)))
	        return;

	    // initialize random sequence
	    sfx.base_seed = Math.floor(50000 * Math.random());

	    var start_time = _wa.currentTime + when;
	    start_time = Math.max(0.0, start_time);

	    sfx.start_time = start_time;

	    sfx.state = SPKSTATE_PLAY;

	    var scene_sfx = _active_scene._sfx;

	    // correct behavior if distance model is configured to none
	    if (sfx.behavior == "POSITIONAL" &&
	            scene_sfx.distance_model == "none")
	        sfx.behavior = "BACKGROUND_SOUND";

	    update_proc_chain(obj, _active_scene._sfx);

	    if (sfx.behavior == "POSITIONAL" ||
	            sfx.behavior == "BACKGROUND_SOUND") {

	        var source = _wa.createBufferSource();

	        source.buffer = sfx.src;
	        source.playbackRate.value = playrate;

	        if (loop) {
	            // switch off previous node graph
	            if (sfx.source_node)
	                sfx.source_node.disconnect();
	            if (sfx.source_node2)
	                sfx.source_node2.disconnect();

	            source.loop = true;
	            source.loopStart = sfx.loop_start;
	            source.loopEnd = sfx.loop_end;

	            if (sfx.loop_end) {
	                var source2 = _wa.createBufferSource();
	                source2.buffer = sfx.src;
	                source2.playbackRate.value = playrate;
	                sfx.source_node2 = source2;
	                source2.connect(sfx.proc_chain_in);
	            }

	            source.start(start_time);

	            // NOTE: loop count
	            sfx.duration = 0;
	        } else {
	            var buf_dur = source.buffer ? source.buffer.duration : 0;

	            if (duration > buf_dur) {
	                var to = start_time + duration + sfx.fade_out;

	                source.loop = true;

	                source.start(start_time);
	                source.stop(to);

	                sfx.duration = duration;
	            } else {
	                source.loop = false;
	                source.start(start_time);

	                sfx.duration = buf_dur;
	            }
	        }

	        source.connect(sfx.proc_chain_in);
	        sfx.source_node = source;

	        schedule_onended(sfx);
	        reset_volume_pitch_random(sfx);
	        schedule_volume_pitch_random(sfx);

	    } else if (sfx.behavior == "BACKGROUND_MUSIC") {

	        m_time.clear_timeout(sfx.bgm_start_timeout);
	        m_time.clear_timeout(sfx.bgm_stop_timeout);

	        var start_cb = function() {
	            fire_audio_element(obj);
	        };

	        if (when == 0)
	            start_cb();
	        else
	            sfx.bgm_start_timeout = m_time.set_timeout(start_cb, when * 1000);

	        if (loop) {
	            sfx.duration = 0;
	        } else {
	            var el_dur = get_duration(obj);
	            sfx.duration = el_dur;
	        }
	    }

	    schedule_fades(sfx, start_time);
	}

	/**
	 * Update WA processing chain (routing graph) for given speaker.
	 * uses _vec3_tmp
	 */
	function update_proc_chain(obj, scene_sfx) {

	    var sfx = obj.sfx;

	    if (sfx.proc_chain_in)
	        return;

	    var pos = m_tsr.get_trans_view(obj.render.world_tsr);
	    var quat = m_tsr.get_quat_view(obj.render.world_tsr);

	    if (cfg_sfx.mix_mode) {
	        var filter_node = _wa.createBiquadFilter();
	        filter_node.type = "peaking";
	    } else
	        var filter_node = null;

	    // mandatory fade-in/out gain node
	    var fade_gnode = _wa.createGain();

	    switch (sfx.behavior) {
	    // panner->filter->gain->fade->rand
	    case "POSITIONAL":
	        var ap = _wa.createPanner();
	        
	        // default HRTF panning gives too much volume gain
	        
	        if (typeof ap.panningModel != "string") {
	            // old spec
	            ap.panningModel = ap.EQUALPOWER;
	            ap.distanceModel = ap.INVERSE_DISTANCE;
	        } else {
	            // new spec
	            ap.panningModel = "equalpower";
	            ap.distanceModel = scene_sfx.distance_model;
	        }


	        ap.setPosition(pos[0], pos[1], pos[2]);
	        m_vec3.copy(pos, sfx.last_position);

	        var orient = _vec3_tmp;
	        m_util.quat_to_dir(quat, m_util.AXIS_MZ, orient);
	        ap.setOrientation(orient[0], orient[1], orient[2]);

	        ap.refDistance = sfx.dist_ref;
	        ap.maxDistance = sfx.dist_max;
	        ap.rolloffFactor = sfx.attenuation;

	        ap.coneInnerAngle = sfx.cone_angle_inner;
	        ap.coneOuterAngle = sfx.cone_angle_outer;
	        ap.coneOuterGain = sfx.cone_volume_outer;

	        var gnode = _wa.createGain();
	        gnode.gain.value = calc_gain(sfx);

	        if (filter_node) {
	            ap.connect(filter_node);
	            filter_node.connect(gnode);
	        } else {
	            ap.connect(gnode);
	        }

	        gnode.connect(fade_gnode);

	        sfx.proc_chain_in = ap;

	        // optional volume randomization gain node
	        if (sfx.volume_random) {
	            var rand_gnode = _wa.createGain();
	            fade_gnode.connect(rand_gnode);
	            rand_gnode.connect(scene_sfx.proc_chain_in);
	        } else {
	            var rand_gnode = null;
	            fade_gnode.connect(scene_sfx.proc_chain_in);
	        }

	        break;
	    // filter->gain->fade->rand
	    case "BACKGROUND_SOUND":
	        var ap = null;

	        var gnode = _wa.createGain();
	        gnode.gain.value = calc_gain(sfx);

	        if (filter_node) {
	            sfx.proc_chain_in = filter_node;
	            filter_node.connect(gnode);
	        } else {
	            sfx.proc_chain_in = gnode;
	        }

	        gnode.connect(fade_gnode);

	        // optional volume randomization gain node
	        if (sfx.volume_random) {
	            var rand_gnode = _wa.createGain();
	            fade_gnode.connect(rand_gnode);
	            rand_gnode.connect(scene_sfx.proc_chain_in);
	        } else {
	            var rand_gnode = null;
	            fade_gnode.connect(scene_sfx.proc_chain_in);
	        }

	        break;
	    // filter->gain->fade
	    case "BACKGROUND_MUSIC":
	        var ap = null;
	        var rand_gnode = null;

	        var gnode = _wa.createGain();
	        gnode.gain.value = calc_gain(sfx);

	        if (filter_node) {
	            sfx.proc_chain_in = filter_node;
	            filter_node.connect(gnode);
	        } else {
	            sfx.proc_chain_in = gnode;
	        }

	        gnode.connect(fade_gnode);

	        fade_gnode.connect(scene_sfx.proc_chain_in);

	        break;
	    }

	    sfx.panner_node = ap;
	    sfx.filter_node = filter_node;
	    sfx.gain_node = gnode;
	    sfx.fade_gain_node = fade_gnode;
	    sfx.rand_gain_node = rand_gnode;
	}

	exports.play_def = play_def;
	function play_def(obj) {
	    var sfx = obj.sfx;

	    var duration = sfx.duration;
	    var delay = sfx.delay + sfx.delay_random * Math.random();
	    play(obj, delay, duration);
	}

	function schedule_onended(sfx) {
	    var source = sfx.source_node2 || sfx.source_node;

	    // NOTE: may affect pause/resume behavior if not supported
	    if (m_util.isdef(source.onended))
	        source.onended = function() {
	            sfx.state = SPKSTATE_FINISH;
	        };
	}

	function reset_volume_pitch_random(sfx) {
	    if (sfx.volume_random)
	        sfx.rand_gain_node.gain.cancelScheduledValues(sfx.start_time);

	    if (sfx.pitch_random) {
	        sfx.source_node.playbackRate.cancelScheduledValues(sfx.start_time);
	        if (sfx.source_node2)
	            sfx.source_node2.playbackRate.cancelScheduledValues(sfx.start_time);
	    }

	    sfx.vp_rand_end_time = sfx.start_time;
	}

	function schedule_volume_pitch_random(sfx) {

	    // optimization
	    if (!(sfx.volume_random || sfx.pitch_random))
	        return;

	    var rand_gnode = sfx.rand_gain_node;
	    var source = sfx.source_node;

	    var buf_dur = source.buffer ? source.buffer.duration : 0;
	    if (!buf_dur)
	        return;

	    var time = sfx.start_time;

	    // deterministic randomization for pitch only
	    _seed_tmp[0] = sfx.base_seed;

	    for (var cnt = 0; cnt < SCHED_PARAM_LOOPS; ) {
	        var playrate = sfx.pitch + sfx.pitch_random * m_util.rand_r(_seed_tmp);

	        if (time >= sfx.vp_rand_end_time) {
	            if (sfx.volume_random) {
	                var gain = 1 - m_util.clamp(sfx.volume_random, 0, 1) * Math.random();
	                rand_gnode.gain.setValueAtTime(gain, time);
	            }

	            if (sfx.pitch_random) {
	                source.playbackRate.setValueAtTime(playrate, time);
	                if (sfx.source_node2)
	                    sfx.source_node2.playbackRate.setValueAtTime(playrate, time);
	            }

	            cnt++;
	        }

	        time += buf_dur / playrate;
	    }

	    sfx.vp_rand_end_time = (time - 0.001);
	}

	function schedule_fades(sfx, from_time) {

	    // optimization
	    if (!(sfx.fade_in || sfx.fade_out))
	        return;

	    var fade_gnode = sfx.fade_gain_node;

	    // also clears scheduled ducks
	    fade_gnode.gain.cancelScheduledValues(from_time);

	    if (sfx.fade_in) {
	        fade_gnode.gain.setValueAtTime(0, from_time);
	        fade_gnode.gain.linearRampToValueAtTime(1, from_time + sfx.fade_in);
	    } else {
	        // clear possible duck or fade-out from previous iteraion
	        fade_gnode.gain.setValueAtTime(1, from_time);
	    }

	    if (sfx.fade_out && !sfx.loop) {
	        // NOTE: requires longer sound, e.g. not working in case of non-loop single shot sound
	        fade_gnode.gain.setValueAtTime(1, from_time + sfx.duration);
	        fade_gnode.gain.linearRampToValueAtTime(0, from_time + sfx.duration +
	                sfx.fade_out);
	    }
	}

	function fire_audio_element(obj) {
	    var sfx = obj.sfx;
	    var audio = sfx.src;
	    if (audio) {
	        // volume will be controlled by gain node
	        audio.volume = 1.0;
	        audio.loop = sfx.loop;

	        // NOTE: audio element will be invalidated after construction execution,
	        // so use previous MediaElementSourceNode
	        sfx.source_node = sfx.source_node ||
	                _wa.createMediaElementSource(audio);

	        sfx.source_node.connect(sfx.proc_chain_in);

	        if (sfx.state == SPKSTATE_PLAY) {
	            if (audio.currentTime)
	                audio.currentTime = 0;
	            audio.play();
	        }
	    }
	}

	function stop_audio_element(obj) {
	    var sfx = obj.sfx;
	    var audio = sfx.src;
	    if (audio) {
	        // exact sequence
	        if (audio.currentTime)
	            audio.currentTime = 0;
	        audio.pause();
	    }
	}

	exports.stop = stop;
	/**
	 * Stop to play from given speaker
	 * @param sobj Object 3D
	 * @methodOf sfx
	 */
	function stop(sobj) {
	    if (sobj.type != "SPEAKER")
	        m_util.panic("Wrong object type");

	    var sfx = sobj.sfx;

	    if (sfx.state == SPKSTATE_FINISH) {
	        sfx.state = SPKSTATE_STOP;
	        return;
	    } else if (sfx.state != SPKSTATE_PLAY && sfx.state != SPKSTATE_PAUSE)
	        return;

	    var fade_gnode = sfx.fade_gain_node;
	    var current_time = _wa.currentTime;

	    if (sfx.fade_out) {
	        fade_gnode.gain.setValueAtTime(fade_gnode.gain.value, current_time);
	        fade_gnode.gain.linearRampToValueAtTime(0, current_time + sfx.fade_out);
	    }

	    if (sfx.behavior == "BACKGROUND_MUSIC") {
	        var audio_el = sfx.src;
	        if (audio_el) {
	            var stop_cb = function() {
	                stop_audio_element(sobj);
	            };

	            m_time.clear_timeout(sfx.bgm_start_timeout);
	            m_time.clear_timeout(sfx.bgm_stop_timeout);

	            sfx.bgm_stop_timeout = m_time.set_timeout(stop_cb,
	                    sfx.fade_out * 1000);
	        }
	    } else {
	        var source = sfx.source_node;

	        // NOTE: suppress ended event in Firefox fired even after disconnect
	        source.onended = function(){};

	        // NOTE: condition to fix issue with double stop() for loop-range speakers
	        if (sfx.duration < source.buffer.duration) {
	            if (sfx.fade_out && sfx.state == SPKSTATE_PLAY) {
	                source.stop(current_time + sfx.fade_out);
	            } else if (sfx.state == SPKSTATE_PLAY) {
	                source.stop(0);
	                source.disconnect();
	            }
	        } else {
	            // just disconnect, no fade-out
	            source.disconnect();
	        }

	        sfx.start_time = 0;
	        sfx.pause_time = 0;
	        sfx.buf_offset = 0;
	    }

	    sfx.state = SPKSTATE_STOP;
	}

	exports.is_playing = is_playing;
	function is_playing(obj) {
	    return (obj.sfx.state == SPKSTATE_PLAY);
	}

	exports.speaker_pause = speaker_pause;
	/**
	 * Pause speaker.
	 * @param obj Speaker object ID
	 */
	function speaker_pause(obj) {

	    var sfx = obj.sfx;

	    if (sfx.state != SPKSTATE_PLAY)
	        return;

	    var current_time = _wa.currentTime;
	    sfx.pause_time = current_time;

	    if (sfx.behavior == "BACKGROUND_MUSIC") {
	        var audio_el = sfx.src;
	        if (audio_el)
	            audio_el.pause();
	    } else {
	        if (current_time > sfx.start_time)
	            sfx.buf_offset = calc_buf_offset(sfx, current_time);
	        else
	            sfx.buf_offset = 0;

	        // NOTE: suppress ended event in Firefox fired even after disconnect
	        sfx.source_node.onended = function(){};
	        sfx.source_node.stop(0);
	        sfx.source_node.disconnect();

	        reset_volume_pitch_random(sfx);
	    }

	    sfx.state = SPKSTATE_PAUSE;
	}

	function calc_buf_offset(sfx, current_time) {

	    _seed_tmp[0] = sfx.base_seed;
	    var buf_dur = sfx.source_node.buffer.duration;
	    var time = sfx.start_time;
	    var playrate;

	    while (time < current_time) {
	        playrate = sfx.pitch + sfx.pitch_random * m_util.rand_r(_seed_tmp);
	        time += buf_dur / playrate;
	    }

	    return (buf_dur / playrate - (time - current_time)) * playrate;
	}

	exports.speaker_resume = speaker_resume;
	/**
	 * Resume speaker.
	 * @param obj Speaker object ID
	 */
	function speaker_resume(obj) {

	    var sfx = obj.sfx;

	    if (sfx.state != SPKSTATE_PAUSE)
	        return;

	    var current_time = _wa.currentTime;
	    sfx.start_time += (current_time - sfx.pause_time);

	    if (sfx.behavior == "BACKGROUND_MUSIC") {
	        var audio_el = sfx.src;
	        audio_el.play();
	    } else {
	        update_source_node(obj);
	        sfx.vp_rand_end_time = current_time;

	        var source = sfx.source_node;

	        schedule_onended(sfx);

	        source.start(sfx.start_time, sfx.buf_offset);

	        schedule_volume_pitch_random(sfx);
	    }
	    
	    schedule_fades(sfx, sfx.start_time);
	    sfx.state = SPKSTATE_PLAY;
	}

	function update_source_node(obj) {
	    var sfx = obj.sfx;

	    var source = _wa.createBufferSource();

	    source.loop = sfx.source_node.loop;
	    source.loopStart = sfx.source_node.loopStart;
	    source.loopEnd = sfx.source_node.loopEnd;
	    source.buffer = sfx.source_node.buffer;
	    source.playbackRate.value = sfx.source_node.playbackRate.value;

	    source.connect(sfx.proc_chain_in);

	    sfx.source_node = source;

	    if (sfx.source_node2) {
	        var source2 = _wa.createBufferSource();

	        source2.loop = sfx.source_node2.loop;
	        source2.buffer = sfx.source_node2.buffer;
	        source2.playbackRate.value = sfx.source_node2.playbackRate.value;

	        source2.connect(sfx.proc_chain_in);

	        sfx.source_node2 = source2;
	    }
	}

	exports.loop_stop = function(obj, when, wait) {
	    var sfx = obj.sfx;

	    var source2 = sfx.source_node2;

	    if (spk_is_active(obj) && (sfx.behavior == "POSITIONAL" ||
	                sfx.behavior == "BACKGROUND_SOUND") && source2) {

	        var start_time = _wa.currentTime + when;

	        sfx.source_node.stop(start_time);
	        source2.start(start_time, sfx.loop_end);
	    }
	};


	exports.playrate = function(obj, playrate) {
	    var sfx = obj.sfx;

	    sfx.pitch = playrate;

	    if (spk_is_active(obj) && (sfx.behavior == "POSITIONAL" ||
	                sfx.behavior == "BACKGROUND_SOUND")) {
	        sfx.source_node.playbackRate.value = playrate;
	        if (sfx.source_node2)
	            sfx.source_node2.playbackRate.value = playrate;
	        reset_volume_pitch_random(sfx);
	        schedule_volume_pitch_random(sfx);
	    }

	    // TODO: Consider BACKGROUND_MUSIC implementation
	};

	exports.get_playrate = function(obj) {
	    return obj.sfx.pitch;
	};


	exports.cyclic = function(obj, cyclic) {
	    obj.sfx.cyclic = Boolean(cyclic);
	};

	exports.is_autoplay = function(obj) {
	    return obj.sfx.autoplay;
	};

	exports.is_cyclic = function(obj) {
	    return obj.sfx.cyclic;
	};

	/**
	 * Update listener position, orientation and velocity/doppler.
	 */
	exports.listener_update_transform = function(scene, trans, quat, elapsed, upd_cnt) {
	    var scene_sfx = scene._sfx;
	    if (!scene_sfx)
	        return;

	    var front = _vec3_tmp;
	    front[0] = 0;
	    front[1] = 0;
	    front[2] =-1;
	    m_vec3.transformQuat(front, quat, front);

	    var up = _vec3_tmp2;
	    up[0] = 0;
	    up[1] = 1;
	    up[2] = 0;
	    m_vec3.transformQuat(up, quat, up);

	    var listener = _wa.listener;
	    listener.setPosition(trans[0], trans[1], trans[2]);
	    listener.setOrientation(front[0], front[1], front[2], up[0], up[1], up[2]);

	    if (elapsed && scene_sfx.update_counter != upd_cnt) {
	        // ignore velocity calculation after stride
	        if (!scene_sfx.listener_stride) {
	            var vel = scene_sfx.listener_velocity;

	            vel[0] = (trans[0] - scene_sfx.listener_last_eye[0])/elapsed;
	            vel[1] = (trans[1] - scene_sfx.listener_last_eye[1])/elapsed;
	            vel[2] = (trans[2] - scene_sfx.listener_last_eye[2])/elapsed;

	            m_vec3.copy(trans, scene_sfx.listener_last_eye);

	            for (var i = 0; i < _speaker_objects.length; i++) {
	                var obj = _speaker_objects[i];
	                var sfx = obj.sfx;

	                if (spk_is_active(obj) && sfx.behavior == "POSITIONAL" &&
	                            sfx.enable_doppler)
	                    calc_doppler(sfx, scene_sfx, elapsed);
	            }
	        } else {
	            scene_sfx.listener_stride = false;
	            m_vec3.copy(trans, scene_sfx.listener_last_eye);
	        }

	        scene_sfx.update_counter = upd_cnt;
	    } else
	        // e.g during initialization
	        m_vec3.copy(trans, scene_sfx.listener_last_eye);
	};

	function calc_doppler(sfx, scene_sfx, elapsed) {
	    var doppler_shift = 1;
	    var doppler_factor = scene_sfx.doppler_factor;

	    if (doppler_factor > 0) {
	        var speed_of_sound = scene_sfx.speed_of_sound;

	        // optimization
	        if (m_vec3.dot(sfx.velocity, sfx.velocity) != 0 ||
	                m_vec3.dot(scene_sfx.listener_velocity,
	                scene_sfx.listener_velocity) != 0) {

	            var spk_to_listener = m_vec3.subtract(sfx.last_position,
	                    scene_sfx.listener_last_eye, _vec3_tmp);

	            var dist = m_vec3.length(spk_to_listener);

	            var listener_proj = m_vec3.dot(spk_to_listener,
	                    scene_sfx.listener_velocity) / dist;
	            var spk_proj = m_vec3.dot(spk_to_listener, sfx.velocity) / dist;

	            listener_proj = -listener_proj;
	            spk_proj = -spk_proj;

	            var scaled_speed_of_sound = speed_of_sound / doppler_factor;
	            listener_proj = Math.min(listener_proj, scaled_speed_of_sound);
	            spk_proj = Math.min(spk_proj, scaled_speed_of_sound);

	            doppler_shift = ((speed_of_sound - doppler_factor * listener_proj) /
	                    (speed_of_sound - doppler_factor * spk_proj));

	            // avoid illegal values
	            if (!isFinite(doppler_shift))
	                doppler_shift = 0.0;

	            // limit the pitch shifting to 4 octaves up and 3 octaves down.
	            doppler_shift = Math.min(doppler_shift, 16);
	            doppler_shift = Math.max(doppler_shift, 0.125);

	            doppler_shift = m_util.smooth(doppler_shift, sfx.last_doppler_shift,
	                    elapsed, DOPPLER_SMOOTH_PERIOD);

	            sfx.source_node.playbackRate.value = doppler_shift;

	            sfx.last_doppler_shift = doppler_shift;
	        }
	    }
	}


	exports.listener_stride = function() {
	    var scene_sfx = _active_scene._sfx;

	    if (!scene_sfx)
	        return;

	    scene_sfx.listener_stride = true;
	};

	/**
	 * Update speaker position, orientation and velocity/doppler.
	 * uses _vec3_tmp _vec3_tmp2 _quat_tmp
	 */
	exports.speaker_update_transform = function(obj, elapsed, upd_cnt) {

	    var sfx = obj.sfx;

	    if (!(spk_is_active(obj) && sfx.behavior == "POSITIONAL"))
	        return;

	    var pos = m_tsr.get_trans(obj.render.world_tsr, _vec3_tmp);
	    var quat = m_tsr.get_quat(obj.render.world_tsr, _quat_tmp);
	    var panner = sfx.panner_node;
	    panner.setPosition(pos[0], pos[1], pos[2]);

	    var orient = _vec3_tmp2;
	    m_util.quat_to_dir(quat, m_util.AXIS_MZ, orient);
	    panner.setOrientation(orient[0], orient[1], orient[2]);

	    if (!sfx.enable_doppler)
	        return;

	    var lpos = sfx.last_position;

	    if (elapsed && sfx.update_counter != upd_cnt) {
	        // ignore velocity calculation after stride
	        if (!sfx.stride) {
	            var vel = sfx.velocity;
	            vel[0] = (pos[0] - lpos[0]) / elapsed;
	            vel[1] = (pos[1] - lpos[1]) / elapsed;
	            vel[2] = (pos[2] - lpos[2]) / elapsed;
	            m_vec3.copy(pos, lpos);
	            calc_doppler(sfx, _active_scene._sfx, elapsed);
	        } else {
	            m_vec3.copy(pos, lpos);
	            sfx.stride = false;
	        }

	        sfx.update_counter = upd_cnt;
	    } else
	        m_vec3.copy(pos, lpos);
	};

	exports.speaker_stride = function(obj) {
	    var sfx = obj.sfx;

	    if (spk_is_active(obj) && sfx.behavior == "POSITIONAL" &&
	            sfx.enable_doppler)
	        sfx.stride = true;
	};

	exports.get_spk_behavior = function(obj) {
	    return obj.sfx.behavior;
	};

	exports.check_active_speakers = function() {
	    for (var i = 0; i < _speaker_objects.length; i++)
	        if (spk_is_active(_speaker_objects[i]))
	            return true;

	    return false;
	};

	function spk_is_active(obj) {

	    var sfx = obj.sfx;

	    if (sfx && (sfx.state == SPKSTATE_PLAY ||
	                sfx.state == SPKSTATE_PAUSE ||
	                sfx.state == SPKSTATE_STOP ||
	                sfx.state == SPKSTATE_FINISH))
	        return true;
	    else
	        return false;
	}

	/**
	 * Calculate source node gain value.
	 */
	function calc_gain(sfx) {
	    var volume = sfx.muted ? 0 : sfx.volume;
	    return volume;
	}

	exports.set_master_volume = function(volume) {
	    var scene_sfx = _active_scene._sfx;
	    if (scene_sfx) {
	        scene_sfx.volume = volume;
	        if (_wa)
	            scene_sfx.gain_node.gain.value = calc_gain(scene_sfx);
	    }
	};

	exports.get_master_volume = function() {
	    var scene_sfx = _active_scene._sfx;
	    if (scene_sfx)
	        return scene_sfx.volume;
	    else
	        return 0;
	};

	exports.set_volume = function(obj, volume) {
	    var sfx = obj.sfx;

	    sfx.volume = volume;

	    if (spk_is_active(obj))
	        sfx.gain_node.gain.value = calc_gain(sfx);
	};

	exports.get_volume = function(obj) {
	    return obj.sfx.volume;
	};

	exports.mute = function(obj, muted) {
	    obj.sfx.muted = Boolean(muted);

	    if (spk_is_active(obj))
	        obj.sfx.gain_node.gain.value = calc_gain(obj.sfx);
	};

	exports.is_muted = function(obj) {
	    return obj.sfx.muted;
	};

	exports.mute_master = function(muted) {
	    var scene_sfx = _active_scene._sfx;
	    if (scene_sfx) {
	        scene_sfx.muted = Boolean(muted);
	        if (_wa)
	            scene_sfx.gain_node.gain.value = calc_gain(scene_sfx);
	    }
	};

	exports.is_master_muted = function() {
	    var scene_sfx = _active_scene._sfx;
	    if (scene_sfx)
	        return scene_sfx.muted;
	    else
	        return false;
	};

	exports.get_speaker_objects = function() {
	    return _speaker_objects;
	};

	exports.pause = function() {
	    for (var i = 0; i < _speaker_objects.length; i++)
	        speaker_pause(_speaker_objects[i]);
	};

	exports.resume = function() {
	    for (var i = 0; i < _speaker_objects.length; i++)
	        speaker_resume(_speaker_objects[i]);
	};

	exports.set_compressor_params = function(scene, params) {
	    // silently ignore
	    if (!(scene._sfx && scene._sfx.compressor_node))
	        return;

	    var compressor = scene._sfx.compressor_node;

	    compressor.threshold.value = params["threshold"];
	    compressor.knee.value = params["knee"];
	    compressor.ratio.value = params["ratio"];
	    compressor.attack.value = params["attack"];
	    compressor.release.value = params["release"];
	};

	exports.get_compressor_params = function(scene) {
	    if (!(scene._sfx && scene._sfx.compressor_node))
	        return null;

	    var compressor = scene._sfx.compressor_node;

	    var params = {
	        "threshold" : compressor.threshold.value,
	        "knee" : compressor.knee.value,
	        "ratio" : compressor.ratio.value,
	        "attack" : compressor.attack.value,
	        "release" : compressor.release.value
	    };

	    return params;
	};

	exports.duck = function(obj, value, time) {
	    if (!spk_is_active(obj))
	        return;

	    var sfx = obj.sfx;

	    var fade_gnode = sfx.fade_gain_node;

	    var current_time = _wa.currentTime;

	    fade_gnode.gain.setValueAtTime(fade_gnode.gain.value, current_time);
	    fade_gnode.gain.linearRampToValueAtTime(value, current_time + time);

	    sfx.duck_time = time;
	};

	exports.unduck = function(obj) {
	    if (!spk_is_active(obj))
	        return;

	    var sfx = obj.sfx;

	    var fade_gnode = sfx.fade_gain_node;

	    var current_time = _wa.currentTime;

	    fade_gnode.gain.setValueAtTime(fade_gnode.gain.value, current_time);
	    fade_gnode.gain.linearRampToValueAtTime(1, current_time + sfx.duck_time);

	    sfx.duck_time = 0;
	};

	exports.duck_master = function(value, time) {
	    if (!_wa)
	        return;

	    var scene_sfx = _active_scene._sfx;
	    var fade_gnode = scene_sfx.fade_gain_node;

	    var current_time = _wa.currentTime;

	    fade_gnode.gain.setValueAtTime(fade_gnode.gain.value, current_time);
	    fade_gnode.gain.linearRampToValueAtTime(value, current_time + time);

	    scene_sfx.duck_time = time;
	};

	exports.unduck_master = function() {
	    if (!_wa)
	        return;

	    var scene_sfx = _active_scene._sfx;
	    var fade_gnode = scene_sfx.fade_gain_node;

	    var current_time = _wa.currentTime;

	    fade_gnode.gain.setValueAtTime(fade_gnode.gain.value, current_time);
	    fade_gnode.gain.linearRampToValueAtTime(1, current_time + scene_sfx.duck_time);

	    scene_sfx.duck_time = 0;
	};

	exports.apply_playlist = function(objs, delay, random) {

	    _playlist = {
	        active : -1,
	        active_start_time : 0,
	        random: random,
	        speakers : [],
	        durations: []
	    };

	    for (var i = 0; i < objs.length; i++) {
	        var obj = objs[i];

	        var duration = get_duration(obj);

	        if (duration == 0) {
	            m_print.warn("Ignoring speaker with zero duration: " + obj.name);
	            continue;
	        }

	        stop(obj);

	        var sfx = obj.sfx;
	        sfx.cyclic = false;

	        _playlist.speakers.push(obj);
	        _playlist.durations.push(duration + delay);
	    }
	};

	exports.get_duration = get_duration;
	function get_duration(obj) {

	    var sfx = obj.sfx;

	    if (sfx.behavior == "POSITIONAL" || sfx.behavior == "BACKGROUND_SOUND") {
	        var buffer = sfx.src;

	        if (buffer)
	            return buffer.duration;
	        else
	            return 0;
	    } else {
	        var audio = sfx.src;
	        if (audio)
	            return audio.duration;
	        else
	            return 0;
	    }
	}

	exports.clear_playlist = function() {
	    if (_playlist) {
	        var spks = _playlist.speakers;
	        for (var i = 0; i < spks.length; i++)
	            stop(spks[i]);
	    }
	    _playlist = null;
	};

	exports.get_positional_params = function(obj) {
	    var sfx = obj.sfx;
	    if (!sfx || sfx.behavior != "POSITIONAL")
	        return null;

	    var pos_params = {
	        "dist_ref": sfx.dist_ref,
	        "dist_max": sfx.dist_max,
	        "attenuation": sfx.attenuation
	    };

	    return pos_params;

	};

	exports.set_positional_params = function(obj, params) {
	    var sfx = obj.sfx;
	    if (!sfx || sfx.behavior != "POSITIONAL")
	        return;

	    sfx.dist_ref = params["dist_ref"];
	    sfx.dist_max = params["dist_max"];
	    sfx.attenuation = params["attenuation"];

	    var ap = sfx.panner_node;
	    if (ap) {
	        ap.refDistance = sfx.dist_ref;
	        ap.maxDistance = sfx.dist_max;
	        ap.rolloffFactor = sfx.attenuation;
	    }
	};

	exports.set_filter_params = function(obj, params) {
	    var sfx = obj.sfx;
	    if (!sfx || !sfx.filter_node)
	        return;

	    sfx.filter_node.frequency.value = params["freq"];
	    sfx.filter_node.Q.value = params["Q"];
	    sfx.filter_node.gain.value = params["gain"];
	};

	exports.get_filter_params = function(obj) {
	    var sfx = obj.sfx;
	    if (!sfx || !sfx.filter_node)
	        return null;

	    var params = {
	        "freq": sfx.filter_node.frequency.value,
	        "Q": sfx.filter_node.Q.value,
	        "gain": sfx.filter_node.gain.value
	    };

	    return params;
	};

	exports.get_filter_freq_response = function(obj, freq_arr, mag_arr, phase_arr) {
	    var sfx = obj.sfx;
	    if (!sfx || !sfx.filter_node)
	        return null;

	    sfx.filter_node.getFrequencyResponse(freq_arr, mag_arr, phase_arr);
	};

	exports.reset = function() {
	    _supported_audio.length = 0;
	    _supported_video.length = 0;
	    _wa = null;
	};

	}

	var int_sfx_factory = register("__sfx", Int_SFX);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	function Int_version(ns, exports) {

	var TYPE = "DEBUG";
	var DATE = null;
	var VERSION = null;
	var PREVENT_CACHE = "_b4w_ver_";

	exports.version = version;
	function version() {
	    if (TYPE == "DEBUG") {
	        var d = date();
	        return [parseInt(String(d.getFullYear()).slice(-2), 10), d.getMonth() + 1];
	    } else
	        return VERSION;
	}

	exports.version_str = function() {
	    var str = "";
	    var ver = version();

	    for (var i = 0; i < ver.length; i++) {
	        if (i == 1)
	            str += ver[i] < 10 ? "0" + ver[i] : ver[i];
	        else
	            str += ver[i];
	        if (i != ver.length - 1)
	            str += ".";
	    }

	    return str;
	};

	exports.type = function() {
	    return TYPE;
	};

	/**
	 * Return build date or current date for DEBUG version
	 */
	exports.date = date;
	function date() {
	    if (TYPE == "DEBUG")
	        return new Date();
	    else
	        return DATE;
	}

	/**
	 * Return build date or current date for DEBUG version represented as a string.
	 */
	exports.date_str = date_str;
	function date_str() {
	    var d = date();

	    var day = d.getDate();
	    day = day < 10 ? "0" + String(day) : String(day);

	    var month = d.getMonth() + 1;
	    month = month < 10 ? "0" + String(month) : String(month);

	    var year = String(d.getFullYear());

	    var hour = d.getHours();
	    hour = hour < 10 ? "0" + String(hour) : String(hour);

	    var minute = d.getMinutes();
	    minute = minute < 10 ? "0" + String(minute) : String(minute);

	    var second = d.getSeconds();
	    second = second < 10 ? "0" + String(second) : String(second);

	    // UNIX date +%d.%m.%Y\ %H:%M:%S
	    var date_str = day + "." + month + "." + year + " " + hour + ":" + 
	        minute + ":" + second;
	    return date_str;
	}

	exports.get_build_version = function() {
	    if (TYPE != "DEBUG")
	        return PREVENT_CACHE;

	    var ts = date_str();
	    // remove special symbols
	    ts = ts.split(" ").join("").split(":").join("").split(".").join("");
	    return ts;
	};

	}

	var int_version_factory = register("__version", Int_version);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Low-level resource loader.
	 *
	 * NOTE: setup Nginx /etc/nginx/mime.types:
	 * audio/ogg ogg;
	 * to prevent 206 partial content response
	 *
	 * @name assets
	 * @namespace
	 * @exports exports as assets
	 */
	function Int_assets(ns, exports) {

	var m_cfg     = int_config_factory(ns);
	var m_compat  = int_compat_factory(ns);
	var m_pako    = pako_inflate_factory(ns);
	var m_print   = print_factory(ns);
	var m_sfg     = int_sfx_factory(ns);
	var m_util    = int_util_factory(ns);
	var m_version = int_version_factory(ns);

	var cfg_def = m_cfg.defaults;
	var cfg_ldr = m_cfg.assets;

	// asset types
	exports.AT_ARRAYBUFFER       = 10;
	exports.AT_ARRAYBUFFER_ZIP   = 20;
	exports.AT_JSON              = 30;
	exports.AT_JSON_ZIP          = 40;
	exports.AT_TEXT              = 50;
	exports.AT_AUDIOBUFFER       = 60;
	exports.AT_IMAGE_ELEMENT     = 70;
	exports.AT_AUDIO_ELEMENT     = 80;
	exports.AT_VIDEO_ELEMENT     = 90;
	exports.AT_SEQ_VIDEO_ELEMENT = 100;

	// asset states: enqueued -> requested -> received
	var ASTATE_ENQUEUED = 10;
	var ASTATE_REQUESTED = 20;
	var ASTATE_RECEIVED = 30;
	var ASTATE_HALTED = 40;

	var _assets_queue = [];
	var _assets_pack_index = 0;

	// deprecated
	var _loaded_assets = {};

	var _arraybuffer_cache = {};
	var _img_cache = {};
	var _sound_cache = {};
	var _arraybuffer_sound_cache = {};

	function get_built_in_data() {
	    if (m_cfg.is_built_in_data())
	        return require(m_cfg.paths.built_in_data_module)["data"];
	    else
	        return null;
	}

	function FakeHttpRequest() {
	    var req = {
	        _source_url: null,
	        _parse_response: function(source) {
	            switch(req.responseType) {
	            case "json":
	            case "text":
	                return source;
	            case "arraybuffer":
	                var bin_str = atob(source);
	                var len = bin_str.length;

	                var arr_buffer = new Int8Array(len);
	                for (var i = 0; i < len; i++)
	                    arr_buffer[i] = bin_str.charCodeAt(i);
	                return arr_buffer.buffer;
	            default:
	                return source;
	            }
	        },

	        status: 0,
	        readyState: 0,
	        response: "",
	        responseType: "",
	        onreadystatechange: null,

	        overrideMimeType: function() {},
	        addEventListener: function() {},
	        open: function(method, url, async) {
	            req._source_url = url;
	            req.readyState = 1;
	        },
	        send: function() {
	            req.status = 404;
	            req.readyState = 4;
	            var bd = get_built_in_data();
	            if (bd && req._source_url in bd) {
	                req.status = 200;
	                if (bd[req._source_url])
	                    req.response = req._parse_response(bd[req._source_url]);
	            }
	            var get_type = {};
	            if (get_type.toString.call(req.onreadystatechange)
	                    === '[object Function]')
	                req.onreadystatechange();
	        }
	    };
	    return req;
	}

	/**
	 * Split path to head and extension: "123.txt" -> ["123", "txt"]
	 */
	exports.split_extension = function(path) {
	    var dot_split = path.split(".");

	    var head_ext = Array(2);

	    head_ext[0] = dot_split.slice(0, -1).join(".");
	    head_ext[1] = String(dot_split.slice(-1));

	    return head_ext;
	};

	/**
	 * Get text by sync request.
	 * @deprecated Any usage is strongly discouraged
	 */
	exports.get_text_sync = function(asset_uri) {
	    // check in cache
	    if (_loaded_assets[asset_uri])
	        return _loaded_assets[asset_uri];

	    if (cfg_ldr.prevent_caching)
	        var filepath = asset_uri + "?v=" + m_version.get_build_version();
	    else
	        var filepath = asset_uri;

	    var req = new XMLHttpRequest();
	    req.overrideMimeType("text/plain"); // to prevent "not well formed" error
	    req.open("GET", filepath, false);
	    req.send(null);

	    if (req.status == 200 || req.status == 0) {
	        var resp_text = req.responseText;
	        if (resp_text.length) {
	            // save in cache
	            _loaded_assets[asset_uri] = resp_text;
	            return resp_text;
	        } else
	            m_util.panic("Error XHR: responce is empty, GET " + asset_uri);
	    } else {
	        m_util.panic("Error XHR: " + req.status + ", GET " + asset_uri);
	    }
	};

	exports.cleanup = function() {
	    for (var i = 0; i < _assets_queue.length; i++)
	        _assets_queue[i].state = ASTATE_HALTED;
	    _assets_queue = [];
	    _assets_pack_index = 0;

	    // deprecated
	    _loaded_assets = {};
	};

	exports.enqueue = function(assets_pack, asset_cb, pack_cb, progress_cb, json_reviver) {
	    for (var i = 0; i < assets_pack.length; i++) {
	        var elem = assets_pack[i];

	        var asset = {
	            id: elem.id,
	            type: elem.type,
	            url: elem.url,
	            is_fetch: elem.is_fetch,
	            request_method: elem.request_method ? elem.request_method : "GET",
	            overwrite_header: elem.overwrite_header ? elem.overwrite_header : null,
	            post_data: elem.post_data ? elem.post_data : null,
	            param: elem.param ? elem.param : null,

	            state: ASTATE_ENQUEUED,

	            asset_cb: asset_cb || (function() {}),
	            pack_cb: pack_cb || (function() {}),
	            progress_cb: progress_cb || (function() {}),
	            json_reviver: json_reviver || null,

	            pack_index: _assets_pack_index
	        };

	        if (cfg_ldr.prevent_caching) {
	            var bd = get_built_in_data();
	            if (!(bd && asset.url in bd))
	                asset.url += "?v=" + m_version.get_build_version();
	        }

	        _assets_queue.push(asset);
	    }

	    request_assets(_assets_queue);
	    _assets_pack_index++;
	};

	/**
	 * Executed every frame
	 */
	exports.update = function() {
	    request_assets(_assets_queue);
	    handle_packs(_assets_queue);
	};

	function request_assets(queue) {

	    var req_cnt = 0;

	    for (var i = 0; i < queue.length; i++) {
	        var asset = queue[i];

	        if (asset.state === ASTATE_REQUESTED)
	            req_cnt++;

	        // check requests limit
	        if (req_cnt >= cfg_ldr.max_requests)
	            break;

	        // pass recently enqueued
	        if (asset.state !== ASTATE_ENQUEUED)
	            continue;

	        asset.state = ASTATE_REQUESTED;
	        req_cnt++;

	        switch (asset.type) {
	        case exports.AT_JSON_ZIP:
	        case exports.AT_ARRAYBUFFER:
	        case exports.AT_ARRAYBUFFER_ZIP:
	            request_arraybuffer(asset, "arraybuffer");
	            break;
	        case exports.AT_JSON:
	            request_arraybuffer(asset, "json");
	            break;
	        case exports.AT_TEXT:
	            request_arraybuffer(asset, "text");
	            break;
	        case exports.AT_AUDIOBUFFER:
	            request_audiobuffer(asset);
	            break;
	        case exports.AT_IMAGE_ELEMENT:
	            request_image(asset);
	            break;
	        case exports.AT_AUDIO_ELEMENT:
	            request_audio(asset);
	            break;
	        case exports.AT_VIDEO_ELEMENT:
	            request_video(asset);
	            break;
	        case exports.AT_SEQ_VIDEO_ELEMENT:
	            request_seq_video(asset);
	            break;
	        default:
	            m_util.panic("Wrong asset type: " + asset.type);
	            break;
	        }
	    }
	}

	function request_arraybuffer(asset, response_type) {
	    var filepath = asset.url.split("?v=")[0];
	    if (filepath in _arraybuffer_cache) {
	        if (response_type == "json")
	            asset.asset_cb(m_util.clone_object_r(_arraybuffer_cache[filepath]), asset.id, asset.type,
	                    asset.url, asset.param);
	        else
	            asset.asset_cb(_arraybuffer_cache[filepath], asset.id, asset.type,
	                    asset.url, asset.param);
	        return;
	    }
	    var bd = get_built_in_data();
	    if (bd && asset.url in bd)
	        var req = new FakeHttpRequest();
	    else
	        var req = new XMLHttpRequest();

	    var content_type = null;
	    if (asset.request_method == "GET") {
	        req.open("GET", asset.url, true);
	    } else if (asset.request_method == "POST") {
	        req.open("POST", asset.url, true);
	        switch (asset.type) {
	        case exports.AT_TEXT:
	            content_type = 'text/plain';
	            break;
	        case exports.AT_JSON:
	            content_type = 'application/json';
	            break;
	        }
	    }

	    if (asset.overwrite_header) {
	        for (var key in asset.overwrite_header) {
	            if (key == "Content-Type")
	                content_type = asset.overwrite_header[key];
	            else
	                req.setRequestHeader(key, asset.overwrite_header[key]);
	        }
	    }

	    if (content_type)
	        req.setRequestHeader("Content-Type", content_type);

	    if (response_type == "text") {
	        // to prevent "not well formed" error (GLSL)
	        req.overrideMimeType("text/plain");
	        req.responseType = "text";
	    } else if (response_type == "json") {
	        // NOTE: workaround, json response type not implemented in some browsers
	        //m_print.log("Apply json load workaround");
	        req.overrideMimeType("application/json");
	        req.responseType = "text";
	    } else
	        req.responseType = response_type;

	    req.onreadystatechange = function() {
	        if (asset.state != ASTATE_HALTED)
	            if (req.readyState == 4) {
	                if (req.status == 200 || req.status == 0) {
	                    var response = req.response;
	                    var empty_response = !response
	                        || (response_type == "arraybuffer" && response["byteLength"] == 0);
	                    if (!empty_response) {

	                        switch (asset.type) {
	                        case exports.AT_JSON_ZIP:
	                            try {
	                                response = m_pako.inflate(response, { to: "string" });
	                            } catch(e) {
	                                m_print.error(e + " (parsing gzipped file " + asset.url + ")");
	                                asset.asset_cb(null, asset.id, asset.type, asset.url, asset.param);
	                                return;
	                            }
	                        case exports.AT_JSON:
	                            try {
	                                response = JSON.parse(response, asset.json_reviver);
	                            } catch(e) {
	                                m_print.error(e + " (parsing JSON " + asset.url + ")");
	                                asset.asset_cb(null, asset.id, asset.type, asset.url, asset.param);
	                                return;
	                            }
	                            break;
	                        case exports.AT_ARRAYBUFFER_ZIP:
	                            try {
	                                response = m_pako.inflate(response).buffer;
	                            } catch(e) {
	                                m_print.error(e + " (parsing gzipped file " + asset.url + ")");
	                                asset.asset_cb(null, asset.id, asset.type, asset.url, asset.param);
	                                return;
	                            }
	                            break;
	                        }

	                        if (asset.is_fetch)
	                            if (asset.type == exports.AT_JSON || asset.type == exports.AT_JSON_ZIP)
	                                _arraybuffer_cache[filepath] = m_util.clone_object_r(response);
	                            else
	                                _arraybuffer_cache[filepath] = response;

	                        asset.asset_cb(response, asset.id, asset.type, asset.url, asset.param);
	                    } else {
	                        m_print.error("empty responce when trying to get " + asset.url);
	                        asset.asset_cb(null, asset.id, asset.type, asset.url, asset.param);
	                    }
	                } else {
	                    m_print.error(req.status + " when trying to get " + asset.url);
	                    asset.asset_cb(null, asset.id, asset.type, asset.url, asset.param);
	                }
	                asset.state = ASTATE_RECEIVED;
	            }
	    };

	    req.addEventListener("progress", function(e) {
	        // compute progress information if total size is known
	        if (e.lengthComputable)
	            asset.progress_cb(e.loaded / e.total);
	    }, false);

	    req.send(asset.post_data);
	}

	function request_audiobuffer(asset) {
	    var filepath = asset.url.split("?v=")[0];
	    if (filepath in _arraybuffer_sound_cache) {
	        asset.asset_cb(_arraybuffer_sound_cache[filepath], asset.id, asset.type,
	                asset.url, asset.param);
	        asset.state = ASTATE_RECEIVED;
	        return;
	    }
	    if (asset.request_method != "GET") {
	        m_util.panic("Unsupported request type for audio buffer");
	    }
	    var bd = get_built_in_data();
	    if (bd && asset.url in bd)
	        var req = new FakeHttpRequest();
	    else
	        var req = new XMLHttpRequest();

	    req.open("GET", asset.url, true);

	    req.responseType = "arraybuffer";

	    req.onreadystatechange = function() {
	        if (asset.state != ASTATE_HALTED)
	            if (req.readyState == 4) {
	                if (req.status == 200 || req.status == 0) {
	                    var response = req.response;
	                    if (response) {
	                        var decode_cb = function(audio_buffer) {
	                            asset.asset_cb(audio_buffer, asset.id, asset.type, asset.url, asset.param);
	                            asset.state = ASTATE_RECEIVED;
	                            if (asset.is_fetch) {
	                                var filepath = asset.url.split("?v=")[0];
	                                _arraybuffer_sound_cache[filepath] = audio_buffer;
	                            }
	                        };
	                        var fail_cb = function() {
	                            m_print.error("failed to decode " + asset.url);
	                            asset.asset_cb(null, asset.id, asset.type, asset.url, asset.param);
	                            asset.state = ASTATE_RECEIVED;
	                        };

	                        m_sfg.decode_audio_data(response, decode_cb, fail_cb);

	                    } else {
	                        m_print.error("empty responce when trying to get " + asset.url);
	                        asset.asset_cb(null, asset.id, asset.type, asset.url, asset.param);
	                        asset.state = ASTATE_RECEIVED;
	                    }
	                } else {
	                    m_print.error(req.status + " when trying to get " + asset.url);
	                    asset.asset_cb(null, asset.id, asset.type, asset.url, asset.param);
	                    asset.state = ASTATE_RECEIVED;
	                }
	            }
	    };

	    req.send();
	}

	function request_image(asset) {
	    var filepath = asset.url.split("?v=")[0];
	    if (filepath in _img_cache) {
	        asset.asset_cb(_img_cache[filepath], asset.id, asset.type, asset.url, asset.param);
	        asset.state = ASTATE_RECEIVED;
	        return;
	    }
	    if (asset.request_method != "GET") {
	        m_util.panic("Unsupported request type for image element");
	    }
	    var image = document.createElement("img");
	    if (cfg_def.allow_cors)
	        image.crossOrigin = "Anonymous";
	    image.onload = function() {
	        if (asset.state != ASTATE_HALTED) {
	            asset.asset_cb(image, asset.id, asset.type, asset.url, asset.param);
	            asset.state = ASTATE_RECEIVED;
	            if (asset.is_fetch) {
	                var filepath = asset.url.split("?v=")[0];
	                _img_cache[filepath] = image;
	            }
	        }
	    };
	    image.addEventListener("error", function() {
	        if (asset.state != ASTATE_HALTED) {
	            m_print.error("could not load image: " + asset.url);
	            asset.asset_cb(null, asset.id, asset.type, asset.url, asset.param);
	            asset.state = ASTATE_RECEIVED;
	        }
	    }, false);

	    var bd = get_built_in_data();
	    if (bd && asset.url in bd) {
	        if (bd[asset.url]) {
	            var img_mime_type = get_image_mime_type(asset.url);
	            image.src = "data:" + img_mime_type + ";base64," + bd[asset.url];
	        } else {
	            if (m_compat.is_ie11()) {
	                var e = document.createEvent("CustomEvent");
	                e.initCustomEvent("error", false, false, null);
	            } else
	                var e = new CustomEvent("error");
	            image.dispatchEvent(e);
	        }
	    } else
	        image.src = asset.url;
	}

	function request_audio(asset) {
	    var filepath = asset.url.split("?v=")[0];
	    if (filepath in _sound_cache) {
	        asset.asset_cb(_sound_cache[filepath], asset.id, asset.type,
	                asset.url, asset.param);
	        asset.state = ASTATE_RECEIVED;
	        return;
	    }
	    if (asset.request_method != "GET") {
	        m_util.panic("Unsupported request type for audio element");
	    }
	    var audio = document.createElement("audio");
	    if (cfg_def.allow_cors)
	        audio.crossOrigin = "Anonymous";

	    audio.addEventListener("loadeddata", function() {
	        if (asset.state != ASTATE_HALTED) {
	            asset.asset_cb(audio, asset.id, asset.type, asset.url, asset.param);
	            asset.state = ASTATE_RECEIVED;
	            if (asset.is_fetch) {
	                var filepath = asset.url.split("?v=")[0];
	                _sound_cache[filepath] = audio;
	            }
	        }
	    }, false);

	    audio.addEventListener("error", function() {
	        if (asset.state != ASTATE_HALTED) {
	            m_print.error("could not load sound: " + asset.url);
	            asset.asset_cb(null, asset.id, asset.type, asset.url, asset.param);
	            asset.state = ASTATE_RECEIVED;
	        }
	    }, false);

	    audio.addEventListener("stalled", function() {
	        if (asset.state != ASTATE_HALTED) {
	            m_print.error("could not load sound: " + asset.url);
	            asset.asset_cb(null, asset.id, asset.type, asset.url, asset.param);
	            asset.state = ASTATE_RECEIVED;
	        }
	    }, false);

	    var bd = get_built_in_data();
	    if (bd && asset.url in bd) {
	        if (bd[asset.url]) {
	            var snd_mime_type = get_sound_mime_type(asset.url);
	            audio.src = "data:" + snd_mime_type + ";base64," + bd[asset.url];
	            if (asset.state != ASTATE_HALTED) {
	                asset.asset_cb(audio, asset.id, asset.type, asset.url, asset.param);
	                asset.state = ASTATE_RECEIVED;
	            }

	        } else {
	            if (m_compat.is_ie11()) {
	                var e = document.createEvent("CustomEvent");
	                e.initCustomEvent("error", false, false, null);
	            } else
	                var e = new CustomEvent("error");
	            audio.dispatchEvent(e);
	        }
	    } else {
	        audio.src = asset.url;
	        if (cfg_def.is_mobile_device)
	            audio.load();
	    }

	    if (cfg_def.mobile_firefox_media_hack) {
	        audio.autoplay = true;
	        audio.pause();
	    }

	    // HACK: workaround for some garbage collector bug
	    setTimeout(function() {audio.some_prop_to_prevent_gc = 1;}, 5000);
	}

	function request_video(asset) {
	    var filepath = asset.url.split("?v=")[0];
	    if (filepath in _img_cache) {
	        asset.asset_cb(_img_cache[filepath], asset.id, asset.type, asset.url, asset.param);
	        asset.state = ASTATE_RECEIVED;
	        return;
	    }
	    if (asset.request_method != "GET") {
	        m_util.panic("Unsupported request type for video element");
	    }
	    var video = document.createElement("video");
	    video.muted = true;
	    // HACK: allow crossOrigin for mobile devices (Android Chrome bug)
	    if (cfg_def.allow_cors)
	        video.crossOrigin = "Anonymous";
	    video.addEventListener("loadeddata", function() {
	        video.removeEventListener("error", video_error_event, false);
	        if (asset.state != ASTATE_HALTED) {
	            asset.asset_cb(video, asset.id, asset.type, asset.url, asset.param);
	            asset.state = ASTATE_RECEIVED;
	            if (asset.is_fetch) {
	                var filepath = asset.url.split("?v=")[0];
	                _img_cache[filepath] = video;
	            }
	        }
	    }, false);

	    function video_error_event(e) {
	        if (asset.state != ASTATE_HALTED) {
	            m_print.error("could not load video: " + asset.url, asset.param);
	            asset.asset_cb(null, asset.id, asset.type, asset.url);
	            asset.state = ASTATE_RECEIVED;
	        }
	    }
	    video.addEventListener("error", video_error_event, false);

	    var bd = get_built_in_data();
	    if (bd && asset.url in bd) {
	        if (bd[asset.url]) {
	            var vid_mime_type = get_video_mime_type(asset.url);
	            video.src = "data:" + vid_mime_type + ";base64," + bd[asset.url];
	            if (asset.state != ASTATE_HALTED)
	                video.addEventListener("loadeddata", function() {
	                    asset.asset_cb(video, asset.id, asset.type, asset.url, asset.param);
	                    asset.state = ASTATE_RECEIVED;
	                }, false);
	        } else {
	            if (m_compat.is_ie11()) {
	                var e = document.createEvent("CustomEvent");
	                e.initCustomEvent("error", false, false, null);
	            } else
	                var e = new CustomEvent("error");
	            video.dispatchEvent(e);
	        }
	    } else {
	        video.src = asset.url;
	        if (cfg_def.is_mobile_device)
	            video.load();
	    }

	    if (cfg_def.mobile_firefox_media_hack || cfg_def.ipad_video_hack) {
	        video.autoplay = true;
	        video.pause();
	    }

	    // HACK: workaround for some garbage collector bug
	    setTimeout(function() {video.some_prop_to_prevent_gc = 1;}, 10000);
	}

	function request_seq_video(asset) {
	    var filepath = asset.url.split("?v=")[0];
	    if (filepath in _img_cache) {
	        asset.asset_cb(_img_cache[filepath], asset.id, asset.type, asset.url, asset.param);
	        asset.state = ASTATE_RECEIVED;
	        return;
	    }
	    if (asset.request_method != "GET") {
	        m_util.panic("Unsupported request type for seq video element");
	    }
	    var bd = get_built_in_data();
	    if (bd && asset.url in bd)
	        var req = new FakeHttpRequest();
	    else
	        var req = new XMLHttpRequest();

	    req.open("GET", asset.url, true);
	    req.responseType = "arraybuffer";

	    function load_cb(images) {
	        asset.asset_cb(images, asset.id, asset.type, asset.url, asset.param);
	        asset.state = ASTATE_RECEIVED;
	        if (asset.is_fetch) {
	            var filepath = asset.url.split("?v=")[0];
	            _img_cache[filepath] = images;
	        }
	    }

	    req.onreadystatechange = function() {
	    if (asset.state != ASTATE_HALTED)
	        if (req.readyState == 4) {
	            if (req.status == 200 || req.status == 0) {
	                var response = req.response;
	                if (response)
	                    parse_seq_video_file(response, load_cb);
	                else {
	                    m_print.error("empty responce when trying to get " + asset.url);
	                    asset.asset_cb(null, asset.id, asset.type, asset.url, asset.param);
	                    asset.state = ASTATE_RECEIVED;
	                }
	            } else {
	                m_print.error(req.status + " when trying to get " + asset.url);
	                asset.asset_cb(null, asset.id, asset.type, asset.url, asset.param);
	                asset.state = ASTATE_RECEIVED;
	            }
	        }
	    };
	    req.addEventListener("progress", function(e) {
	        // compute progress information if total size is known
	        if (e.lengthComputable)
	            asset.progress_cb(e.loaded / e.total);
	    }, false);

	    req.send();
	}

	function parse_seq_video_file(response, callback) {
	    var buffer = new Int32Array(response);
	    var seq_image_data = new Int8Array(response);
	    var number = buffer[3];
	    var data = {
	        images: [],
	        blobs: [],
	        fps: buffer[4]
	    };
	    var offset = 20;
	    for (var j = 0; j < number; j++) {
	        var size = buffer[offset/4];
	        var frame = seq_image_data.subarray(offset + 4, offset + 4 + size);
	        var blob = new Blob([frame], {type: "image/jpg"});
	        var image = document.createElement("img");
	        image.src = window.URL.createObjectURL(blob);
	        data.images.push(image);
	        // NOTE: IE HTML7007 message hack
	        data.blobs.push(blob);
	        offset +=size + 8 - size % 4;
	    }
	    // NOTE: wait for loading last image
	    image.onload = function() {
	        for (var i = 0; i < data.images.length; i++)
	            window.URL.revokeObjectURL(data.images[i].src);
	        delete data.blobs;
	        callback(data);
	    };
	}

	function get_image_mime_type(file_path) {
	    var ext = m_util.get_file_extension(file_path);
	    var mime_type = "image";
	    switch(ext.toLowerCase()) {
	    case "jpeg":
	    case "jpg":
	        mime_type += "/jpeg";
	        break;
	    case "png":
	        mime_type += "/png";
	        break;
	    }

	    return mime_type;
	}

	function get_sound_mime_type(file_path) {
	    var ext = m_util.get_file_extension(file_path);
	    var mime_type = "audio";
	    switch(ext.toLowerCase()) {
	    case "ogv":
	    case "ogg":
	        mime_type += "/ogg";
	        break;
	    case "mp3":
	        mime_type += "/mpeg";
	        break;
	    case "m4v":
	    case "mp4":
	        mime_type += "/mp4";
	        break;
	    case "webm":
	        mime_type += "/webm";
	        break;
	    }

	    return mime_type;
	}

	function get_video_mime_type(file_path) {
	    var ext = m_util.get_file_extension(file_path);
	    var mime_type = "video";
	    switch(ext.toLowerCase()) {
	    case "ogv":
	        mime_type += "/ogg";
	        break;
	    case "webm":
	        mime_type += "/webm";
	        break;
	    case "m4v":
	    case "mp4":
	        mime_type += "/mp4";
	        break;
	    }

	    return mime_type;
	}

	exports.check_image_extension = function(ext) {
	    if (ext == "png"
	            || ext == "jpg"
	            || ext == "jpeg"
	            || ext == "gif"
	            || ext == "bmp"
	            || ext == "dds"
	            || ext == "pvr")
	        return true;

	    return false;
	};

	/**
	 * Find loaded packs, exec callback and remove from queue
	 */
	function handle_packs(queue) {

	    var pack_first_index = 0;
	    var pack_cb_exec = true;

	    for (var i = 0; i < queue.length; i++) {
	        var asset = queue[i];
	        var asset_pack_first = queue[pack_first_index];

	        if (asset.pack_index === asset_pack_first.pack_index) {
	            if (asset.state !== ASTATE_RECEIVED)
	                pack_cb_exec = false;
	        } else {
	            if (pack_cb_exec) {
	                queue[i-1].pack_cb();
	                var spliced_count = i-pack_first_index;
	                queue.splice(pack_first_index, spliced_count);
	                i-=spliced_count;
	            }

	            pack_first_index = i;
	            pack_cb_exec = (queue[i].state === ASTATE_RECEIVED) ? true : false;
	        }

	        if ((i === (queue.length-1)) && pack_cb_exec) {
	            var last_asset = queue[i];
	            queue.splice(pack_first_index);
	            // Should be executed after splice. Possible enqueue in pack_cb
	            last_asset.pack_cb();
	        }
	    }
	}

	exports.clear_cache = function() {
	    _arraybuffer_cache = {};
	    _img_cache = {};
	    _sound_cache = {};
	    _arraybuffer_sound_cache = {};
	};

	}

	var int_assets_factory = register("__assets", Int_assets);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Shaders internal API.
	 * @name shaders
	 * @namespace
	 * @exports exports as shaders
	 */
	function Int_shaders(ns, exports) {

	var m_assets = int_assets_factory(ns);
	var m_cfg    = int_config_factory(ns);
	var m_debug  = int_debug_factory(ns);
	var m_print  = print_factory(ns);
	var m_util   = int_util_factory(ns);

	var cfg_def = m_cfg.defaults;
	var cfg_lim = m_cfg.context_limits;
	var cfg_pth = m_cfg.paths;

	var DEBUG_INCOMPATIBLE_DIRECTIVES = false;

	var _compiled_shaders = {};
	var _shader_ast_cache = {};
	var _shader_texts = null;
	var _vars_cache = {};

	var SHADERS = ["anchors.glslf",
	    "anchors.glslv",
	    "color_id.glslf",
	    "color_id.glslv",
	    "shadow.glslf",
	    "shadow.glslv",
	    "error.glslf",
	    "error.glslv",
	    "grass_map.glslf",
	    "grass_map.glslv",
	    "halo.glslf",
	    "halo.glslv",
	    "line.glslf",
	    "line.glslv",
	    "main.glslf",
	    "main.glslv",
	    "main_stack.glslf",
	    "particle_system.glslf",
	    "particle_system_stack.glslf",
	    "particle_system.glslv",
	    "proc_skybox.glslf",
	    "skybox.glslv",
	    "lens_flares.glslf",
	    "lens_flares.glslv",
	    "sky.glslf",
	    "sky.glslv",
	    "water.glslf",
	    "water.glslv",
	    "tex_skybox.glslf",
	    "debug_view.glslf",
	    "debug_view.glslv",
	    "node_skybox.glslf",
	    "irradiance_skybox.glslf",
	    "r_convolution_skybox.glslf",

	    "postprocessing/antialiasing.glslf",
	    "postprocessing/bloom_combine.glslf",
	    "postprocessing/coc.glslf",
	    "postprocessing/compositing.glslf",
	    "postprocessing/depth_pack.glslf",
	    "postprocessing/dof.glslf",
	    "postprocessing/glow.glslf",
	    "postprocessing/god_rays.glslf",
	    "postprocessing/god_rays.glslv",
	    "postprocessing/god_rays_combine.glslf",
	    "postprocessing/luminance.glslf",
	    "postprocessing/luminance_av.glslf",
	    "postprocessing/luminance_truncated.glslf",
	    "postprocessing/motion_blur.glslf",
	    "postprocessing/outline.glslf",
	    "postprocessing/performance.glslf",
	    "postprocessing/postprocessing.glslf",
	    "postprocessing/postprocessing.glslv",
	    "postprocessing/smaa.glslf",
	    "postprocessing/smaa.glslv",
	    "postprocessing/ssao.glslf",
	    "postprocessing/ssao_blur.glslf",
	    "postprocessing/stereo.glslf",
	    "postprocessing/precompute_brdf.glslf",
	    //"postprocessing/velocity.glslf",

	    "include/blending.glslf",
	    "include/caustics.glslf",
	    "include/color_util.glslf",
	    "include/coverage.glslf",
	    "include/depth_fetch.glslf",
	    "include/dynamic_grass.glslv",
	    "include/environment.glslf",
	    "include/fog.glslf",
	    "include/fxaa.glslf",
	    "include/halo_color.glslf",
	    "include/lighting_nodes.glslf",
	    "include/math.glslv",
	    "include/mirror.glslf",
	    "include/nodes.glslf",
	    "include/nodes.glslv",
	    "include/pack.glslf",
	    "include/particles.glslv",
	    "include/particles_nodes.glslf",
	    "include/particles_nodes.glslv",
	    "include/precision_statement.glslf",
	    "include/procedural.glslf",
	    "include/refraction.glslf",
	    "include/scale_texcoord.glslv",
	    "include/shadow.glslf",
	    "include/shadow.glslv",
	    "include/skin.glslv",
	    "include/sky_blending.glslf",
	    "include/std.glsl",
	    "include/to_world.glslv",
	    "include/wind_bending.glslv"];

	var DEBUG_COMPILATION_UNIQUENESS = false;

	var VALID = 0;
	var INVALID_TEX_IMAGE_UNITS = 1 << 0;
	var INVALID_F_UNIFORM_VECTORS = 1 << 1;
	var INVALID_V_UNIFORM_VECTORS = 1 << 2;
	var INVALID_VERTEX_ATTRIBS = 1 << 3;
	var INVALID_VARYING_VECTORS = 1 << 4;
	var COMPILATION_ERROR = 1 << 5;

	exports.VALID = VALID;
	exports.INVALID_TEX_IMAGE_UNITS = INVALID_TEX_IMAGE_UNITS;
	exports.INVALID_F_UNIFORM_VECTORS = INVALID_F_UNIFORM_VECTORS;
	exports.INVALID_V_UNIFORM_VECTORS = INVALID_V_UNIFORM_VECTORS;
	exports.INVALID_VERTEX_ATTRIBS = INVALID_VERTEX_ATTRIBS;
	exports.INVALID_VARYING_VECTORS = INVALID_VARYING_VECTORS;
	exports.COMPILATION_ERROR = COMPILATION_ERROR;

	var SAMPLER_EXPR = /(?:^|[^a-zA-Z_])uniform.*?(sampler2D|samplerCube)(?=\s)(.*?\[\s*([0-9]*)\s*\])?/;
	var UNIFORM_EXPR = /(?:^|[^a-zA-Z_])(uniform)(?=\s)\s*(float|vec2|vec3|vec4|ivec2|ivec3|ivec4|bvec2|bvec3|bvec4|mat2|mat3|mat4|sampler2D|samplerCube)\s*(.*?\[\s*([0-9]*)\s*\])?/;
	var IN_EXPR = /(?:^|[^a-zA-Z_])(in)(?=\s)\s*(float|vec2|vec3|vec4|mat2|mat3|mat4)\s*(.*?\[\s*([0-9]*)\s*\])?/;
	var VARYING_EXPR = /(?:^|[^a-zA-Z_])(varying)(?=\s)\s*(float|vec2|vec3|vec4|mat2|mat3|mat4)\s*(.*?\[\s*([0-9]*)\s*\])?/;
	var DISCARD_EXPR = /(?:\W|^)discard(\W|$)/;

	// 15 === 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3
	var FILLED_ROW_FLAGS = 15;

	var _ivec2_tmp = new Int16Array(2);

	var _varying_buffer = null;
	var _fragment_uniform_buffer = null;
	var _vertex_uniform_buffer = null;
	var _top_non_filled_row = 0;
	var _bottom_non_filled_row = 0;

	var _debug_hash_codes = [];

	var _gl = null;

	var _shaders_loaded = false;

	/**
	 * Setup WebGL context
	 * @param gl WebGL context
	 */
	exports.setup_context = function(gl) {
	    _gl = gl;
	};

	exports.init_shaders_info = init_shaders_info;
	function init_shaders_info() {
	    var shaders_info = {
	        vert: "",
	        frag: "",
	        directives: [],
	        node_elements: [],
	        status: VALID,
	        attribute_count: 0,
	        texture_count: 0
	    };

	    return shaders_info;
	}

	exports.clone_shaders_info = clone_shaders_info;
	function clone_shaders_info(shaders_info) {
	    var shaders_info_new = init_shaders_info();

	    shaders_info_new.vert = shaders_info.vert;
	    shaders_info_new.frag = shaders_info.frag;

	    shaders_info_new.directives = m_util.clone_object_r(shaders_info.directives);
	    shaders_info_new.node_elements = m_util.clone_object_r(shaders_info.node_elements);

	    shaders_info_new.status = shaders_info.status;
	    shaders_info_new.attribute_count = shaders_info.attribute_count;
	    shaders_info_new.texture_count = shaders_info.texture_count;

	    return shaders_info_new;
	}

	exports.set_directive = set_directive;
	/**
	 * Override existing directive for Shaders Info object.
	 * @methodOf shaders
	 * @param shaders_info Shaders Info Object
	 * @param {string} name Directive name
	 * @param value Directive value, specify string to set from another directive
	 */
	function set_directive(shaders_info, name, value) {
	    var dirs = shaders_info.directives;

	    // another directive
	    if (typeof value == "string") {
	        var dir = get_directive(shaders_info, value);
	        if (dir)
	            value = dir[1];
	    } else 
	        // NOTE: for integer values passed as is
	        value = String(value);

	    // update existing directive
	    for (var i = 0; i < dirs.length; i++)
	        if (dirs[i][0] == name) {
	            dirs[i][1] = value;
	            return;
	        }

	    if (DEBUG_INCOMPATIBLE_DIRECTIVES)
	        m_print.error("Incompatible directive '" + name + "' was set for shaders " 
	                + shaders_info.vert + "/" + shaders_info.frag + ".");
	}

	exports.get_directive = get_directive;
	/**
	 * Get [directive_name, directive_value] pair.
	 * @methodOf shaders
	 * @param shaders_info Shaders Info Object
	 * @param {string} name Directive name
	 */
	function get_directive(shaders_info, name) {
	    var dirs = shaders_info.directives;

	    for (var i = 0; i < dirs.length; i++)
	        if (dirs[i][0] == name)
	            return dirs[i];

	    // not found
	    return false;
	}

	function get_shader_default_vars(vert_name, frag_name) {
	    var pair_id = vert_name + frag_name;
	    
	    if (!(pair_id in _vars_cache)) {
	        var vert_ast = get_shader_ast(cfg_pth.shaders_path, vert_name);
	        var frag_ast = get_shader_ast(cfg_pth.shaders_path, frag_name);

	        var vert_vars = collect_vars(vert_ast);
	        var frag_vars = collect_vars(frag_ast);

	        for (var var_name in frag_vars)
	            vert_vars[var_name] = frag_vars[var_name];

	        var var_dirs = [];
	        for (var var_name in vert_vars)
	            var_dirs.push([var_name, vert_vars[var_name]]);

	        _vars_cache[pair_id] = var_dirs;
	    }
	    return _vars_cache[pair_id];
	}

	/**
	 * Set default directives according to shader names
	 */
	exports.set_default_directives = function(sinfo) {

	    sinfo.directives = m_util.clone_object_r(get_shader_default_vars(sinfo.vert, sinfo.frag));
	    set_directive(sinfo, "PRECISION", m_cfg.defaults.precision);

	    if (m_cfg.defaults.precision == "highp")
	        set_directive(sinfo, "EPSILON", glsl_value(0.000001));
	    else
	        set_directive(sinfo, "EPSILON", glsl_value(0.0001));

	    set_directive(sinfo, "CONSTANTS_HACK", cfg_def.shader_constants_hack | 0);

	    set_directive(sinfo, "SRGB", cfg_def.srgb_type);

	    set_directive(sinfo, "COMPARED_MODE", cfg_def.compared_mode_depth | 0);

	    return;
	};

	/**
	 * Return vertex shader name from shader info
	 */
	exports.get_vname = function(sinfo) {
	    return sinfo.vert;
	};

	/**
	 * Return fragment shader name from shader info
	 */
	exports.get_fname = function(sinfo) {
	    return sinfo.frag;
	};

	exports.get_compiled_shader = get_compiled_shader;
	/**
	 * Compile, return and cache GL shader object from shader_id
	 * @methodOf shaders
	 */
	function get_compiled_shader(shaders_info) {
	    var shader_id = JSON.stringify(shaders_info.vert) +
	            JSON.stringify(shaders_info.frag) +
	            JSON.stringify(shaders_info.directives) +
	            JSON.stringify(shaders_info.node_elements);

	    var compiled_shader = _compiled_shaders[shader_id];
	    if (compiled_shader)
	        return compiled_shader;

	    // retrieve filenames of shaders
	    var vshader = shaders_info.vert;
	    var fshader = shaders_info.frag;

	    // load the code
	    var vshader_ast = get_shader_ast(cfg_pth.shaders_path, vshader);
	    var fshader_ast = get_shader_ast(cfg_pth.shaders_path, fshader);
	    if (!vshader_ast || !fshader_ast)
	        return null;

	    var vshader_text = preprocess_shader("vert", vshader_ast, shaders_info);
	    var fshader_text = preprocess_shader("frag", fshader_ast, shaders_info);

	    validate_shader_text(fshader_text, vshader_text, shaders_info);

	    if (shaders_info.status === VALID) {
	        // compile
	        _compiled_shaders[shader_id] = compiled_shader =
	            init_shader(_gl, vshader_text, fshader_text, shader_id, shaders_info);

	        var f_compile_fail = !_gl.getShaderParameter(compiled_shader.fshader,
	                _gl.COMPILE_STATUS);
	        var v_compile_fail = !_gl.getShaderParameter(compiled_shader.vshader,
	                _gl.COMPILE_STATUS);
	        var link_fail = !_gl.getProgramParameter(compiled_shader.program,
	                _gl.LINK_STATUS);

	        if (f_compile_fail)
	            m_debug.report_shader_compiling_error(compiled_shader.fshader,
	                    shader_id, fshader_text);
	        else if (v_compile_fail)
	            m_debug.report_shader_compiling_error(compiled_shader.vshader,
	                    shader_id, vshader_text);
	        else if (link_fail)
	            m_debug.report_shader_linking_error(compiled_shader.program,
	                    shader_id, vshader_text, fshader_text);

	        if (f_compile_fail || v_compile_fail || link_fail) {
	            shaders_info.status |= COMPILATION_ERROR;
	            compiled_shader = null;
	        }
	    } else
	        compiled_shader = null;

	    return compiled_shader;
	}

	function validate_shader_text(f_shader_text, v_shader_text, shaders_info) {
	    // TODO: use complex validation
	    var status = VALID;

	    var tex_count = get_interface_variables_count(f_shader_text, SAMPLER_EXPR);
	    shaders_info.texture_count = tex_count;
	    if (tex_count > cfg_lim.max_texture_image_units)
	        status |= INVALID_TEX_IMAGE_UNITS;

	    create_variable_buffers();

	    if (!check_uniforms_in_packing_limits(f_shader_text,
	            _fragment_uniform_buffer, cfg_lim.max_fragment_uniform_vectors))
	        status |= INVALID_F_UNIFORM_VECTORS;

	    if (!check_uniforms_in_packing_limits(v_shader_text,
	            _vertex_uniform_buffer, cfg_lim.max_vertex_uniform_vectors))
	        status |= INVALID_V_UNIFORM_VECTORS;

	    var attribute_count = get_attribute_count(v_shader_text);
	    shaders_info.attribute_count = attribute_count;
	    if (attribute_count > cfg_lim.max_vertex_attribs)
	        status |= INVALID_VERTEX_ATTRIBS;

	    if (!check_varyings_in_packing_limits(f_shader_text))
	        status |= INVALID_VARYING_VECTORS;

	    shaders_info.status = status;
	}

	function create_variable_buffers() {
	    if (!_varying_buffer)
	        _varying_buffer = new Uint32Array(cfg_lim.max_varying_vectors);

	    if (!_fragment_uniform_buffer)
	        _fragment_uniform_buffer = new Uint32Array(cfg_lim.max_fragment_uniform_vectors);

	    if (!_vertex_uniform_buffer)
	        _vertex_uniform_buffer = new Uint32Array(cfg_lim.max_vertex_uniform_vectors);
	}

	function sum(a, b) {
	    return a + b;
	}

	function get_interface_variables_count(shader_text, expr) {
	    var shader_list = shader_text.split(";");
	    var uniforms_list = shader_list.map(function(statement) {
	        var r = statement.match(expr);
	        return r && (r[3]? parseInt(r[3], 10): 1);
	    }).filter(function(decl) {
	        return decl;
	    });
	    return (uniforms_list || []).reduce(sum, 0);
	}

	function get_attribute_count(v_shader_text) {
	    if (cfg_def.webgl2) {
	        // remove function parameters potentially containing "in"
	        var v_shader_text_n = v_shader_text.replace(/(.*?)\([^()]*?\)(.*?)/g, "$1$2");
	        return (v_shader_text_n.match(/(?:^|[^a-zA-Z_])in(?=\s)/g) || []).length;
	    } else
	        return (v_shader_text.match(/(?:^|[^a-zA-Z_])attribute(?=\s)/g) || []).length;
	}

	function cmp_variables(a, b) {
	    var a_occupied_cols = get_occupied_cols(a.type);
	    var b_occupied_cols = get_occupied_cols(b.type);
	    var a_elems = a.array_size;
	    var b_elems = b.array_size;

	    if (a_occupied_cols > b_occupied_cols)
	        return -1;
	    else if (a_occupied_cols < b_occupied_cols)
	        return 1;
	    else if (a_elems > b_elems)
	        return -1;
	    else if (a_elems < b_elems)
	        return 1;
	    else
	        return 0;
	}

	function check_varyings_in_packing_limits(shader_text) {
	    if (cfg_def.webgl2) {
	        // remove function parameters potentially containing "in"
	        shader_text = shader_text.replace(/(.*?)\([^()]*?\)(.*?)/g, "$1$2");
	        var expr = IN_EXPR;
	    } else
	        var expr = VARYING_EXPR;

	    var shader_list = shader_text.split(";");
	    var variables = shader_list.map(function(statement) {
	        var r = statement.match(expr);
	        return r && {
	            type: r[2],
	            array_size: (r[4]? parseInt(r[4], 10): 1)
	        };
	    }).filter(function(decl) {
	        return decl;
	    });

	    return check_packing_limits(variables, _varying_buffer, cfg_lim.max_varying_vectors);
	}

	function check_uniforms_in_packing_limits(shader_text, buffer, max_uniforms) {
	    var shader_list = shader_text.split(";");
	    var variables = [];

	    for (var i = 0; i < shader_list.length; i++) {
	        var r = shader_list[i].match(UNIFORM_EXPR);
	        if (r)
	            variables.push({
	                type: r[2],
	                array_size: (r[4]? parseInt(r[4], 10): 1)
	            });
	    }

	    return check_packing_limits(variables, buffer, max_uniforms);
	}

	function check_packing_limits(variables, buffer, max_row_count) {
	    // 'variables' is list: [
	    //     {
	    //         type: one of {"float", "vec2", "vec3", "vec4", "mat2", "mat3", "mat4"}
	    //         array_size: size of array, for example, it is 3 for float[3], mat2[3]
	    //                 or 1 for float, mat2
	    // }, ..
	    // ]
	    if (!variables.length)
	        return true;

	    for (var i = 0; i < max_row_count; i++)
	        buffer[i] = 0;

	    _bottom_non_filled_row = max_row_count;

	    // NOTE: order variables according to GLSL 1.017 Appendix A, Section 7
	    variables.sort(cmp_variables);

	    var col3_top_non_filled_row = 0;
	    var col4_top_non_filled_row = 0;
	    var variable_number = 0;

	    function process_4_column_variables() {
	        while(variable_number < variables.length) {
	            var variable = variables[variable_number];
	            if (get_occupied_cols(variable.type) != 4)
	                break;

	            col4_top_non_filled_row += get_occupied_rows(variable.type) *
	                    variable.array_size;
	            variable_number++;
	        }

	        if (col4_top_non_filled_row > _bottom_non_filled_row)
	            return false;
	        _top_non_filled_row = col4_top_non_filled_row;

	        fill_variable_buffer(buffer, 0, col4_top_non_filled_row, 0, 4);
	        return true;
	    }

	    function process_3_column_variables() {
	        var col3_rows_count = 0;
	        while(variable_number < variables.length) {
	            var variable = variables[variable_number];
	            if (get_occupied_cols(variable.type) != 3)
	                break;
	            col3_rows_count += get_occupied_rows(variable.type) *
	                    variable.array_size;
	            variable_number++;
	        }

	        col3_top_non_filled_row = col4_top_non_filled_row + col3_rows_count;
	        if (col3_top_non_filled_row > _bottom_non_filled_row)
	            return false;

	        fill_variable_buffer(buffer, col4_top_non_filled_row, col3_rows_count, 0, 3);
	        return true;
	    }

	    function process_2_column_variables() {
	        var col2_available_rows_count = _bottom_non_filled_row -
	                col3_top_non_filled_row;
	        var available_cols_01_rows_count = col2_available_rows_count;
	        var available_cols_23_rows_count = col2_available_rows_count;
	        while(variable_number < variables.length) {
	            var variable = variables[variable_number];
	            if (get_occupied_cols(variable.type) != 2)
	                break;
	            var rows_count = get_occupied_rows(variable.type) * variable.array_size;
	            if (rows_count <= available_cols_01_rows_count)
	                available_cols_01_rows_count -= rows_count;
	            else if (rows_count <= available_cols_23_rows_count)
	                available_cols_23_rows_count -= rows_count;
	            else
	                return false;
	            variable_number++;
	        }

	        var used_cols_01_rows_count = col2_available_rows_count -
	                available_cols_01_rows_count;
	        var used_cols_23_rows_count = col2_available_rows_count -
	                available_cols_23_rows_count;

	        fill_variable_buffer(buffer, col3_top_non_filled_row, used_cols_01_rows_count, 0, 2);
	        fill_variable_buffer(buffer, _bottom_non_filled_row - used_cols_23_rows_count,
	                used_cols_23_rows_count, 2, 2);
	        return true;
	    }

	    function process_1_column_variables() {
	        while(variable_number < variables.length) {
	            var variable = variables[variable_number];

	            // get_occupied_cols(variable.type) == 1

	            var rows_count = get_occupied_rows(variable.type) * variable.array_size;

	            var smallest_column = -1;
	            var smallest_size = max_row_count + 1;
	            var top_row = -1;
	            for (var column = 0; column < 4; column++) {
	                var row_and_size = _ivec2_tmp;
	                row_and_size[0] = 0;
	                row_and_size[1] = 1;
	                if (search_optimal_row_and_size(buffer, column, rows_count, row_and_size)) {
	                    if (row_and_size[1] < smallest_size) {
	                        top_row = row_and_size[0];
	                        smallest_size = row_and_size[1];
	                        smallest_column = column;
	                    }
	                }
	            }

	            if (smallest_column < 0)
	                return false;

	            fill_variable_buffer(buffer, top_row, rows_count, smallest_column, 1);
	            variable_number++;
	        }
	        return true;
	    }

	    // NOTE: don't change call order
	    return process_4_column_variables() && process_3_column_variables() &&
	            process_2_column_variables() && process_1_column_variables();
	}

	function search_optimal_row_and_size(buffer, column, rows_count, dest) {
	    // update _top_non_filled_row, _bottom_non_filled_row
	    while (_top_non_filled_row < buffer.length &&
	            buffer[_top_non_filled_row] === FILLED_ROW_FLAGS)
	        _top_non_filled_row++;
	    while (_bottom_non_filled_row > 0 &&
	            buffer[_bottom_non_filled_row] === FILLED_ROW_FLAGS)
	        _bottom_non_filled_row--;

	    // check if buffer has enough freed 'cells'
	    if (_bottom_non_filled_row - _top_non_filled_row < rows_count)
	        return false;

	    var col_flags = 1 << column;
	    var top_fit_row = 0;
	    var smallest_fit_top = -1;
	    var smallest_fit_size = buffer.length + 1;
	    var found = false;

	    for (var i = _top_non_filled_row; i <= _bottom_non_filled_row; i++) {
	        var fit_row = i < _bottom_non_filled_row &&
	                !(buffer[i] & col_flags);
	        if (fit_row) {
	            if (!found) {
	                top_fit_row = i;
	                found = true;
	            }
	        } else {
	            if (found) {
	                var size = i - top_fit_row;
	                if (size >= rows_count && size < smallest_fit_size) {
	                    smallest_fit_size = size;
	                    smallest_fit_top = top_fit_row;
	                }
	            }
	            found = false;
	        }
	    }

	    if (smallest_fit_top < 0)
	        return false;

	    dest[0] = smallest_fit_top;
	    dest[1] = smallest_fit_size;
	    return true;
	}

	function fill_variable_buffer(buffer, row, rows_count, column, columns_count) {
	    var col_flags = 0;
	    for (var i = 0; i < columns_count; i++)
	        col_flags |= 1 << (column + i);
	    for (var i = 0; i < rows_count; i++)
	        buffer[row + i] |= col_flags;
	}

	/*
	 * Type is one of ["float","vec2","vec3","vec4","ivec2","ivec3",
	 * "ivec4","bvec2","bvec3","bvec4","mat2","mat3","mat4"]
	 */
	function get_occupied_rows(type) {
	    var rows = 0;
	    switch (type) {
	    case "mat4":
	        rows = 4;
	        break;
	    case "mat3":
	        rows = 3;
	        break;
	    case "mat2":
	        rows = 2;
	        break;
	    default:
	        rows = 1;
	        break;
	    }

	    return rows;
	}

	function get_occupied_cols(type) {
	    var cols = 0;
	    switch (type) {
	    case "mat4":
	    case "vec4":
	    case "ivec4":
	    case "bvec4":
	    // NOTE: mat2 occupies complete rows
	    case "mat2":
	        cols = 4;
	        break;
	    case "mat3":
	    case "vec3":
	    case "ivec3":
	    case "bvec3":
	        cols = 3;
	        break;
	    case "vec2":
	    case "ivec2":
	    case "bvec2":
	        cols = 2;
	        break;
	    default:
	        cols = 1;
	        break;
	    }

	    return cols;
	}

	/**
	 * Get shader AST.
	 * Uses _shader_ast_cache
	 */
	function get_shader_ast(dir, filename) {
	    var cache_id = dir + filename;

	    if (_shader_ast_cache[cache_id])
	        return _shader_ast_cache[cache_id];

	    if (!_shader_texts) {
	        var ast = require("shader_texts")[filename];
	        if (!ast)
	            return null;
	    } else {
	        var main_text = _shader_texts[filename];
	        if (!main_text)
	            return null;
	        var ast = get_gpp_parser().parse(main_text);
	    }

	    _shader_ast_cache[cache_id] = ast;

	    return ast;
	}

	/**
	 * @suppress {missingProperties}
	 */
	function get_gpp_parser() {
	    return require("__gpp_parser").parser;
	}

	function set_shader_texts(shader_name, shader_text) {
	    if (!_shader_texts)
	        _shader_texts = {};
	    _shader_texts[shader_name] = shader_text;
	}

	exports.load_shaders = function() {

	    _shaders_loaded = false;

	    if (!b4w.module_check("shader_texts")) {

	        var shader_assets = [];
	        var asset_type = m_assets.AT_TEXT;

	        for (var i = 0; i < SHADERS.length; i++) {
	            var shader_path = m_util.normpath_preserve_protocol(cfg_pth.shaders_path
	                    + SHADERS[i]);
	            shader_assets.push({id:SHADERS[i], type:asset_type, url:shader_path});
	        }

	        var asset_cb = function(shader_text, shader_name, type, url) {
	            set_shader_texts(shader_name, shader_text);
	        };

	        var pack_cb = function() {
	            _shaders_loaded = true;
	        };

	        if (shader_assets.length)
	            m_assets.enqueue(shader_assets, asset_cb, pack_cb);
	        else
	            m_print.error("Shaders have not been found.");
	    } else
	        _shaders_loaded = true;
	};

	exports.check_shaders_loaded = function() {
	    return _shaders_loaded;
	};

	function combine_dir_tokens(type, shaders_info) {
	    var dirs = {};

	    var dirs_arr = shaders_info.directives || [];
	    for (var i = 0; i < dirs_arr.length; i++)
	        dirs[dirs_arr[i][0]] = [dirs_arr[i][1]];

	    // define usage of the certain nodes
	    for (var i = 0; i < shaders_info.node_elements.length; i++)
	        dirs["USE_NODE_" + shaders_info.node_elements[i].id] = ["1"];

	    // glsl version directives
	    if (cfg_def.webgl2) {
	        dirs["GLSL1"] = ["0"];
	        dirs["GLSL3"] = ["1"];

	        dirs["GLSL_VERSION"] = ["300 es"];

	        dirs["GLSL_IN"] = ["in"];
	        dirs["GLSL_OUT"] = ["out"];

	        dirs["GLSL_OUT_FRAG_COLOR"] = ["glsl_out_frag_color"];

	        dirs["GLSL_TEXTURE"] = ["texture"];
	        dirs["GLSL_TEXTURE_CUBE"] = ["texture"];
	        dirs["GLSL_TEXTURE_PROJ"] = ["textureProj"];
	        dirs["GLSL_TEXTURE_LOD"] = ["textureLod"];
	        dirs["GLSL_TEXTURE_CUBE_LOD"] = ["textureLod"];
	    } else {
	        dirs["GLSL1"] = ["1"];
	        dirs["GLSL3"] = ["0"];
	        
	        dirs["GLSL_VERSION"] = ["100"];

	        dirs["GLSL_IN"] = (type == "vert") ? ["attribute"] : ["varying"];
	        dirs["GLSL_OUT"] = (type == "vert") ? ["varying"] : [""];

	        dirs["GLSL_OUT_FRAG_COLOR"] = ["gl_FragColor"];

	        dirs["GLSL_TEXTURE"] = ["texture2D"];
	        dirs["GLSL_TEXTURE_CUBE"] = ["textureCube"];
	        dirs["GLSL_TEXTURE_PROJ"] = ["texture2DProj"];
	        dirs["GLSL_TEXTURE_LOD"] = ["textureLod"];
	        if (cfg_def.texture_lod_available) {
	            dirs["GLSL_TEXTURE_LOD"] = ["texture2DLodEXT"];
	            dirs["GLSL_TEXTURE_CUBE_LOD"] = ["textureCubeLodEXT"];
	        } else {
	            dirs["GLSL_TEXTURE_LOD"] = ["texture2D"];
	            dirs["GLSL_TEXTURE_CUBE_LOD"] = ["textureCube"];
	        }
	    }

	    if (cfg_def.compared_mode_depth && !cfg_def.rgba_fallback_shadows)
	        dirs["GLSL_SMPLR2D_SHDW"] = ["sampler2DShadow"];
	    else
	        dirs["GLSL_SMPLR2D_SHDW"] = ["sampler2D"];

	    for (var dirname in dirs) {
	        if (dirs[dirname][0].constructor != String)
	            m_print.warn("Warning! The value of a directive '" + dirname + "' is not of type string.");
	    }

	    return dirs;
	}

	function collect_vars(ast) {
	    var vars = {};

	    // copypasted from tools/glsl/ast_traversal.js
	    function traverse_data(data, cb_before, cb_after) {
	        if (data instanceof Array)
	            traverse_array(data, cb_before, cb_after);
	        else if (data instanceof Object && data)
	            traverse_object(data, cb_before, cb_after);
	    }

	    function traverse_array(array_data, cb_before, cb_after) {
	        for (var i = 0; i < array_data.length; i++)
	            traverse_data(array_data[i], cb_before, cb_after);
	    }

	    function traverse_object(object_data, cb_before, cb_after) {
	        if (cb_before)
	            cb_before(object_data);
	        for (var prop in object_data)
	            traverse_data(object_data[prop], cb_before, cb_after);
	        if (cb_after)
	            cb_after(object_data);
	    }

	    var vars_cb = function(ast_node) {
	        if (ast_node.TYPE == "var")
	            vars[ast_node.NAME] = ast_node.TOKENS.join("");
	        else if (ast_node.TYPE == "include") {
	            var ast_inc = get_shader_ast(cfg_pth.shaders_path,
	                    cfg_pth.shaders_include_dir + ast_node.FILE);
	            traverse_data(ast_inc, vars_cb);
	        }
	    };
	    traverse_data(ast, vars_cb);

	    return vars;
	}

	function preprocess_shader(type, ast, shaders_info) {

	    var node_elements = shaders_info.node_elements;
	    
	    // output GLSL lines
	    var lines = [];

	    // set with predefined macros {"name": tokens}    
	    var dirs = combine_dir_tokens(type, shaders_info);
	    
	    // NOTE: always empty: not properly implemented,
	    // set with params for function-like macros {"name": params}
	    var fdirs = {};

	    var curr_file_stack = [shaders_info[type]];

	    var undefined_dirs = {};

	    var shader_nodes = {};

	    var usage_inputs = [];
	    for (var i in node_elements)
	        for (var j in node_elements[i].inputs)
	            usage_inputs.push(node_elements[i].inputs[j]);

	    var frag_glsl_out_declaration = false;

	    // entry element
	    process_group(ast);

	    var text = lines.join("\n");

	    var input_index = 0;
	    var output_index = 0;
	    var param_index = 0;

	    return text;

	    function process_group(elem) {
	        var parts = elem.PARTS;

	        for (var i = 0; i < parts.length; i++) {
	            var pelem = parts[i];
	            switch(pelem.TYPE) {
	            case "cond":
	                process_condition(pelem);
	                break;

	            case "include":
	                process_include(pelem);
	                break;
	            case "var":
	                break;
	            case "define":
	                process_define(pelem);
	                break;
	            case "error":
	                process_error(pelem);
	                break;
	            case "line":
	                // NOTE: do nothing
	                break;
	            case "pragma":
	                process_pragma(pelem);
	                break;
	            case "undef":
	                process_undef(pelem);
	                break;
	            case "warning":
	                process_warning(pelem);
	                break;
	            case "extension":
	                process_extension(pelem);
	                break;
	            case "version":
	                process_version(pelem);
	            case "#":
	                break;

	            case "node":
	                process_node(pelem);
	                break;
	            case "nodes_global":
	                process_nodes_global(node_elements);
	                break;
	            case "nodes_main":
	                process_nodes_main(node_elements);
	                break;

	            case "txt":
	                process_text_tokens(pelem.TOKENS);
	                break;
	            default:
	                m_util.panic("Unknown element type: " + pelem.TYPE);
	                break;
	            }
	        }
	    }

	    function process_condition(elem) {
	        var parts = elem.PARTS;

	        for (var i = 0; i < parts.length; i++) {
	            var pelem = parts[i];

	            switch(pelem.TYPE) {
	            case "if":
	            case "elif":
	                var expression = pelem.EXPRESSION;
	                var result = expression_result(expression);

	                if (result) {
	                    process_group(pelem.GROUP);
	                    return;
	                }
	                break;
	            case "else":
	                process_group(pelem.GROUP);
	                return;
	            case "ifdef":
	                if (pelem.NAME in dirs)
	                    process_group(pelem.GROUP);
	                break;
	            case "ifndef":
	                if (!(pelem.NAME in dirs))
	                    process_group(pelem.GROUP);
	                break;
	            }
	        }
	    }

	    // throws SyntaxError if not parsed
	    function expression_result(expression, node_dirs) {
	        var expr_list = expand_macro(expression, dirs, fdirs, true, node_dirs);
	        return eval_expression(expr_list);
	    }

	    function eval_expression(expr_list) {
	        var operand_stack = [];

	        for (var i = 0; i < expr_list.length; i++) {
	            if (!(expr_list[i] instanceof Object)) {
	                var operand = expr_list[i];

	                var expr_identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;

	                if (expr_identifier.test(operand)) {
	                    operand_stack.push(0);
	                    if (operand.indexOf("USE_NODE_") != 0) {
	                        var filename = curr_file_stack[curr_file_stack.length - 1];

	                        if (!(filename in undefined_dirs))
	                            undefined_dirs[filename] = [];

	                        if (undefined_dirs[filename].indexOf(operand) == -1) {
	                            undefined_dirs[filename].push(operand);
	                            m_print.error("Undefined directive '" + operand 
	                                    + "' in shader '" + filename 
	                                    + "'. Should it be defined with #var/#node_var or #define?");
	                        }
	                    }
	                } else
	                    operand_stack.push(parseFloat(expr_list[i]));
	            } else {
	                switch (expr_list[i].TYPE) {
	                case "conditional_expr":
	                    var falseExpression = operand_stack.pop();
	                    var trueExpression = operand_stack.pop();
	                    var condition = operand_stack.pop();
	                    if (condition)
	                        operand_stack.push(trueExpression);
	                    else
	                        operand_stack.push(falseExpression);
	                    break;
	                case "logical_or_expr":
	                    var result = operand_stack.pop();
	                    for (var j = 0; j < expr_list[i].PLACES -1; j++) {
	                        var operand = operand_stack.pop();
	                        result = result || operand;
	                    }
	                    operand_stack.push(result);
	                    break;
	                case "logical_and_expr":
	                    var result = operand_stack.pop();
	                    for (var j = 0; j < expr_list[i].PLACES -1; j++) {
	                        var operand = operand_stack.pop();
	                        result = result && operand;
	                    }
	                    operand_stack.push(result);
	                    break;
	                case "logical_bitor_expr":
	                    var result = operand_stack.pop();
	                    for (var j = 0; j < expr_list[i].PLACES - 1; j++)
	                      result |= operand_stack.pop();
	                    operand_stack.push(result);
	                    break;
	                case "logical_bitxor_expr":
	                    var result = operand_stack.pop();
	                    for (var j = 0; j < expr_list[i].PLACES - 1; j++)
	                      result ^= operand_stack.pop();
	                    operand_stack.push(result);
	                    break;
	                case "logical_bitand_expr":
	                    var result = operand_stack.pop();
	                    for (var j = 0; j < expr_list[i].PLACES - 1; j++)
	                      result &= operand_stack.pop();
	                    operand_stack.push(result);
	                    break;
	                case "equal_expr":
	                    var operand2 = operand_stack.pop();
	                    var operand1 = operand_stack.pop();
	                    operand_stack.push(operand1 == operand2);
	                    break;
	                case "non_equal_expr":
	                    var operand2 = operand_stack.pop();
	                    var operand1 = operand_stack.pop();
	                    operand_stack.push(operand1 != operand2);
	                    break;
	                case "le_expr":
	                    var operand2 = operand_stack.pop();
	                    var operand1 = operand_stack.pop();
	                    operand_stack.push(operand1 <= operand2);
	                    break;
	                case "ge_expr":
	                    var operand2 = operand_stack.pop();
	                    var operand1 = operand_stack.pop();
	                    operand_stack.push(operand1 >= operand2);
	                    break;
	                case "l_expr":
	                    var operand2 = operand_stack.pop();
	                    var operand1 = operand_stack.pop();
	                    operand_stack.push(operand1 < operand2);
	                    break;
	                case "g_expr":
	                    var operand2 = operand_stack.pop();
	                    var operand1 = operand_stack.pop();
	                    operand_stack.push(operand1 > operand2);
	                    break;
	                case "left_shift_expr":
	                    var operand1 = operand_stack.pop();
	                    var operand2 = operand_stack.pop();
	                    operand_stack.push(operand1 << operand2);
	                    break;
	                case "right_shift_expr":
	                    var operand1 = operand_stack.pop();
	                    var operand2 = operand_stack.pop();
	                    operand_stack.push(operand1 >> operand2);
	                    break;
	                case "add_expr":
	                    var operand1 = operand_stack.pop();
	                    var operand2 = operand_stack.pop();
	                    operand_stack.push(operand1 + operand2);
	                    break;
	                case "sub_expr":
	                    var operand1 = operand_stack.pop();
	                    var operand2 = operand_stack.pop();
	                    operand_stack.push(operand1 - operand2);
	                    break;
	                case "mul_expr":
	                    var operand1 = operand_stack.pop();
	                    var operand2 = operand_stack.pop();
	                    operand_stack.push(operand1 * operand2);
	                    break;
	                case "div_expr":
	                    var operand1 = operand_stack.pop();
	                    var operand2 = operand_stack.pop();
	                    operand_stack.push(operand1 / operand2);
	                    break;
	                case "mod_expr":
	                    var operand1 = operand_stack.pop();
	                    var operand2 = operand_stack.pop();
	                    operand_stack.push(operand1 % operand2);
	                    break;
	                case "pre_inc_expr":
	                case "post_inc_expr":
	                    var operand = operand_stack.pop();
	                    operand_stack.push(++operand);
	                    break;
	                case "pre_dec_expr":
	                case "post_dec_expr":
	                    var operand = operand_stack.pop();
	                    operand_stack.push(--operand);
	                    break;
	                case "positive_expr":
	                    var operand = operand_stack.pop();
	                    operand_stack.push(+operand);
	                    break;
	                case "negative_expr":
	                    var operand = operand_stack.pop();
	                    operand_stack.push(-operand);
	                    break;
	                case "one_compl_expr":
	                    var operand = operand_stack.pop();
	                    operand_stack.push(~operand);
	                    break;
	                case "logic_negative_expr":
	                    var operand = operand_stack.pop();
	                    operand_stack.push(!operand);
	                    break;
	                default:
	                    m_util.panic("Unknown operation type: " + expr_list[i].TYPE);
	                    break;
	                }
	            }
	        }
	        if (operand_stack.length == 1)
	            return operand_stack[0];
	        else
	            m_util.panic("Incorrect expression: " + expr_list.join(" "));
	    }

	    function process_include(elem) {
	        var file = elem.FILE;
	        var ast_inc = get_shader_ast(cfg_pth.shaders_path,
	                                     cfg_pth.shaders_include_dir + file);
	        curr_file_stack.push("include/" + file);
	        process_group(ast_inc);
	        curr_file_stack.pop();
	    }
	    function process_define(elem) {
	        var name = elem.NAME;
	        var tokens = elem.TOKENS;
	        dirs[name] = tokens;

	        // if (elem.PARAMS)
	        //     fdirs[name] = elem.PARAMS;
	    }
	    function process_error(elem) {
	        var tokens = elem.TOKENS;
	        m_util.panic("Shader error: #error " + tokens.join(" "));
	    }
	    function process_pragma(elem) {
	        // return back to shader
	        var name = elem.NAME;
	        var tokens = elem.TOKENS;
	        lines.push("#pragma " + name + " " + tokens.join(" "));
	    }
	    function process_undef(elem) {
	        var name = elem.NAME;
	        delete dirs[name];
	        // delete fdirs[name];
	    }
	    function process_warning(elem) {
	        var tokens = elem.TOKENS;
	        m_print.warn("Shader warning: #warning " + tokens.join(" "));
	    }
	    function process_extension(elem) {
	        var tokens = elem.TOKENS;
	        var token_list = expand_macro(tokens, dirs, fdirs, false);
	        lines.push("#extension " + token_list.join(" "));
	    }

	    function process_version(elem) {
	        var tokens = elem.TOKENS;
	        var token_list = expand_macro(tokens, dirs, fdirs, false);
	        lines.push("#version " + token_list.join(" "));
	    }

	    function process_node(elem) {
	        shader_nodes[elem.NAME] = elem;
	    }

	    function check_optional_node_param(nelem, decl, param_index) {

	        if (nelem.id == "PARTICLE_INFO" && decl.IS_OPTIONAL) {
	            if (dirs["PARTICLE_BATCH"] == 1) {
	                var node_param_usage = false;
	                switch(param_index) {
	                    case 0:
	                        node_param_usage = particle_output_usage(nelem.dirs, "PART_INFO_IND")
	                                || particle_output_usage(nelem.dirs, "PART_INFO_AGE")
	                                || particle_output_usage(nelem.dirs, "PART_INFO_LT")
	                                || particle_output_usage(nelem.dirs, "PART_INFO_SIZE");
	                        break;
	                    case 1:
	                        node_param_usage = particle_output_usage(nelem.dirs, "PART_INFO_LOC");
	                        break;
	                    case 2:
	                        node_param_usage = particle_output_usage(nelem.dirs, "PART_INFO_VEL");
	                        break;
	                    case 3:
	                        node_param_usage = particle_output_usage(nelem.dirs, "PART_INFO_A_VEL");
	                        break;
	                    case 4:
	                        node_param_usage = particle_output_usage(nelem.dirs, "PART_INFO_IND");
	                }
	                return node_param_usage;
	            }
	            return false;
	        }

	        return true;
	    }

	    function process_nodes_global(node_elements) {
	        for (var i = 0; i < node_elements.length; i++) {
	            var nelem = node_elements[i];

	            var node_parts = shader_nodes[nelem.id];

	            // ignore node not found in shader
	            if (!node_parts)
	                continue;

	            var param_index = 0;
	            for (var j = 0; j < node_parts.DECLARATIONS.length; j++) {
	                var decl = node_parts.DECLARATIONS[j];
	                if (decl.TYPE == "node_param") {
	                    if (check_optional_node_param(nelem, decl, param_index)) {

	                        var token_str = decl.QUALIFIER.join(" ") + " ";
	                        if (type == "vert")
	                            token_str += nelem.vparams[param_index];
	                        else if (type == "frag") {
	                            token_str += nelem.params[param_index];
	                            if (nelem.param_values[param_index] !== null)
	                                token_str += "=" + nelem.param_values[param_index];
	                        }
	                        token_str += ";";
	                        process_text_tokens(separate_tokens(token_str));
	                    }
	                    param_index++;
	                }
	            }
	        }
	    }

	    function combine_node_dir_tokens(node_parts, nelem) {
	        var filename = curr_file_stack[curr_file_stack.length - 1];

	        var node_dirs = process_node_vars(node_parts);
	        for (var i = 0; i < nelem.dirs.length; i++) {
	            var dir_name = nelem.dirs[i][0];
	            if (dir_name in node_dirs)
	                node_dirs[dir_name] = [nelem.dirs[i][1]];
	            else if (DEBUG_INCOMPATIBLE_DIRECTIVES)
	                m_print.error("Incompatible node directive '" + dir_name 
	                        + "' was set for node " + nelem.id + " in shader " 
	                        + filename + ".");
	        }

	        var node_out_index = 0;
	        for (var i = 0; i < node_parts.DECLARATIONS.length; i++) {
	            var decl = node_parts.DECLARATIONS[i];

	            if (decl.TYPE == "node_out") {
	                var new_name = nelem.outputs[node_out_index];
	                var use_out = usage_inputs.indexOf(new_name) > -1 | 0;
	                node_dirs["USE_OUT_" + decl.NAME] = [use_out];
	                node_out_index++;
	            }

	        }

	        return node_dirs;
	    }

	    function process_node_vars(node_parts) {
	        var vars = {};
	        for (var i = 0; i < node_parts.NODE_VARS.length; i++) {
	            var var_decl = node_parts.NODE_VARS[i];
	            vars[var_decl.NAME] = [var_decl.TOKENS.join("")];
	        }
	        return vars;
	    }

	    function process_nodes_main(node_elements) {
	        for (var i = 0; i < node_elements.length; i++) {
	            var nelem = node_elements[i];
	            var node_parts = shader_nodes[nelem.id];

	            // ignore node not found in shader
	            if (!node_parts)
	                continue;

	            var replaces = {};

	            input_index = 0;
	            output_index = 0;
	            param_index = 0;

	            var node_dirs = combine_node_dir_tokens(node_parts, nelem);
	            process_node_declaration(nelem, node_parts.DECLARATIONS, replaces, node_dirs);
	            lines.push("{");
	            process_node_statements(nelem, node_parts.STATEMENTS, replaces, node_dirs);
	            lines.push("}");
	        }
	    }

	    function process_node_declaration(nelem, declarations, replaces, node_dirs) {
	        for (var j = 0; j < declarations.length; j++) {
	            var decl = declarations[j];

	            switch (decl.TYPE) {
	            case "node_in":
	                var new_name = nelem.inputs[input_index];

	                // value != null for nonlinked inputs
	                if (nelem.input_values[input_index] !== null) {
	                    // NOTE: don't create variable for some shader nodes in
	                    //       case of using IS_OPTIONAL flag
	                    // MATERIAL_BEGIN: input_index === 3 --- normal_in
	                    // MATERIAL_BEGIN: input_index === 4 --- emit_intensity
	                    // MATERIAL_END: input_index === 3 --- reflect_factor
	                    // MATERIAL_END: input_index === 4 --- specular_alpha
	                    // MATERIAL_END: input_index === 5 --- alpha_in

	                    if ((nelem.id == "MATERIAL_BEGIN" && input_index === 3
	                            || !node_dirs["MATERIAL_EXT"] &&
	                            (nelem.id == "MATERIAL_BEGIN" && input_index === 4
	                            || nelem.id == "MATERIAL_END" && input_index === 3
	                            || nelem.id == "MATERIAL_END" && input_index === 4
	                            || nelem.id == "MATERIAL_END" && input_index === 5)
	                            || nelem.id == "TEXTURE_COLOR" || nelem.id == "TEXTURE_NORMAL")
	                            && decl.IS_OPTIONAL) {
	                        replaces[decl.NAME] = nelem.input_values[input_index];
	                        input_index++;
	                        continue;
	                    }

	                    var token_str = decl.QUALIFIER.join(" ") + " ";
	                    token_str += new_name + "=" + nelem.input_values[input_index] + ";";
	                    process_text_tokens(separate_tokens(token_str));
	                }
	                replaces[decl.NAME] = new_name;
	                input_index++;
	                break;
	            case "node_out":
	                var new_name = nelem.outputs[output_index];

	                if (!decl.IS_OPTIONAL || usage_inputs.indexOf(new_name) > -1) {
	                    var token_str = decl.QUALIFIER.join(" ") + " ";
	                    token_str += new_name + ";";
	                    process_text_tokens(separate_tokens(token_str));

	                    replaces[decl.NAME] = new_name;
	                }

	                output_index++;
	                break;
	            case "node_param":
	                if (type == "vert")
	                    var new_name = nelem.vparams[param_index];
	                else if (type == "frag")
	                    var new_name = nelem.params[param_index];

	                replaces[decl.NAME] = new_name;

	                param_index++;
	                break;
	            }
	        }
	        return replaces;
	    }

	    function process_node_statements(nelem, statements, replaces, node_dirs) {
	        for (var i = 0; i < statements.length; i++) {
	            var part = statements[i];

	            switch(part.TYPE) {
	            case "node_cond":
	                process_node_condition(nelem, part.PARTS, replaces, node_dirs);
	                break;
	            case "txt":
	                var tokens = [];
	                for (var k = 0; k < part.TOKENS.length; k++) {
	                    var tok = part.TOKENS[k];

	                    if (tok in replaces)
	                        tokens.push(replaces[tok]);
	                    else
	                        tokens.push(tok);
	                }
	                process_text_tokens(tokens, node_dirs);
	                break;
	            }
	        }
	    }

	    function process_node_condition(nelem, node_if_elements, replaces, node_dirs) {
	        for (var i = 0; i < node_if_elements.length; i++) {
	            var nielem = node_if_elements[i];

	            switch(nielem.TYPE) {
	            case "node_if":
	            case "node_elif":
	                var expression = nielem.EXPRESSION;
	                var result = expression_result(expression, node_dirs);
	                if (result) {
	                    process_node_statements(nelem, nielem.STATEMENTS, replaces, node_dirs);
	                    return;
	                }

	                break;
	            case "node_else":
	                process_node_statements(nelem, nielem.STATEMENTS, replaces, node_dirs);
	                return;
	            case "node_ifdef":
	                if (nielem.NAME in dirs || nielem.NAME in node_dirs)
	                    process_node_statements(nelem, nielem.STATEMENTS, replaces, node_dirs);
	                break;
	            case "node_ifndef":
	                if (!(nielem.NAME in dirs) && !(nielem.NAME in node_dirs))
	                    process_node_statements(nelem, nielem.STATEMENTS, replaces, node_dirs);
	                break;
	            }
	        }
	    }

	    function separate_tokens(str) {
	        // fractional number | identifier | one-symbol token excluding spaces
	        return str.match(/([\d]+\.[\d]+|[\w]+|[^\s])/g);
	    }

	    function process_text_tokens(tokens, node_dirs) {
	        tokens = preprocess_glsl_compat_tokens(tokens, type);

	        if (tokens.length) {
	            var token_list = expand_macro(tokens, dirs, fdirs, false, node_dirs);
	            lines.push(token_list.join(" "));
	        }
	    }

	    function preprocess_glsl_compat_tokens(tokens, type) {
	        // using standard gl_FragColor, so the corresponding interface 
	        // declaration isn't needed in GLSL ES 1.0
	        if (!cfg_def.webgl2 && type == "frag") {

	            var token_str = tokens.join(" ");

	            // remove the last part (or the whole row) of the GLSL_OUT 
	            // declaration if it's breaked in many rows
	            if (frag_glsl_out_declaration) {
	                if (token_str.match(/[^;]*;/)) {
	                    token_str = token_str.replace(/[^;]*;/, "");
	                    frag_glsl_out_declaration = false;
	                } else
	                    token_str = "";
	            }

	            // remove GLSL_OUT declaration on a single row
	            token_str = token_str.replace(/GLSL_OUT [^;]*;/g, "");


	            // remove the first part of the GLSL_OUT declaration if it's breaked 
	            // in many rows
	            if (token_str.match(/GLSL_OUT(?:$| [^;]*)/)) {
	                token_str = token_str.replace(/GLSL_OUT(?:$| [^;]*)/, "");
	                frag_glsl_out_declaration = true;
	            }

	            token_str = token_str.replace(/ {2,}/g, " ");
	            token_str = token_str.trim();

	            if (token_str)
	                tokens = token_str.split(" ");
	            else
	                tokens = [];
	        }

	        return tokens;
	    }

	    /**
	     * Analyze tokens and dirs and compose string
	     * @param empty_as_zero treat empty directive as zero or just ignore
	     * (#define ABC ... #if ABC => #if 0) vs (#define ABC ... #if ABC => #if ABC)
	     */
	    function expand_macro(tokens, dirs, fdirs, empty_as_zero, node_dirs) {
	        var result = [];
	        expand_macro_iter(tokens, dirs, fdirs, empty_as_zero, result, node_dirs);
	        return result;
	    }

	    function expand_macro_iter(tokens, dirs, fdirs, empty_as_zero, result, node_dirs) {
	        for (var i = 0; i < tokens.length; i++) {
	            var token = tokens[i];

	            if (node_dirs && token in node_dirs)
	                var new_tokens = node_dirs[token];
	            else if (token in dirs)
	                var new_tokens = dirs[token];
	            else {
	                result.push(token);
	                continue;            
	            }

	            if (new_tokens.length == 0 && empty_as_zero)
	                result.push(0);
	            else
	                expand_macro_iter(new_tokens, dirs, fdirs, empty_as_zero, result, node_dirs);
	        }
	    }
	}

	function init_shader(gl, vshader_text, fshader_text,
	                     shader_id, shaders_info) {

	    var vshader = compile_shader(gl, shader_id, vshader_text,
	        gl.VERTEX_SHADER, shaders_info);
	    var fshader = compile_shader(gl, shader_id, fshader_text,
	        gl.FRAGMENT_SHADER, shaders_info);

	    var program = gl.createProgram();

	    gl.attachShader(program, vshader);
	    gl.attachShader(program, fshader);
	    gl.linkProgram(program);

	    var compiled_shader = {
	        // save link to shader objects just to delete them during cleanup
	        vshader    : vshader,
	        fshader    : fshader,
	        program    : program,
	        attributes : {},
	        uniforms   : {},

	        permanent_uniform_setters : m_util.create_non_smi_array(),
	        permanent_sc_uniform_setters : m_util.create_non_smi_array(),
	        // speeds up access by uniform name
	        permanent_uniform_setters_table : {},
	        need_uniforms_update: true,
	        no_permanent_uniforms: false,

	        transient_uniform_setters : m_util.create_non_smi_array(),
	        transient_sc_uniform_setters : m_util.create_non_smi_array(),

	        // NOTE: for debug purposes
	        shaders_info: clone_shaders_info(shaders_info),

	        shader_id: shader_id,

	        has_discard: check_frag_discard(fshader_text),

	        cleanup_gl_data_on_unload: true
	    };

	    var att_count = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
	    for (var i = 0; i < att_count; i++) {
	        var att = gl.getActiveAttrib(program, i);
	        var att_name = att.name;
	        var att_loc = gl.getAttribLocation(program, att_name);

	        compiled_shader.attributes[att_name] = att_loc;
	    }

	    var uni_count = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
	    for (var i = 0; i < uni_count; i++) {
	        var uni = gl.getActiveUniform(program, i);
	        var uni_name = uni.name.split("[0]").join("");
	        var uni_loc = gl.getUniformLocation(program, uni_name);
	        compiled_shader.uniforms[uni_name] = uni_loc;
	    }

	    return compiled_shader;
	}

	function check_frag_discard(fshader_text) {
	    return Boolean(fshader_text.match(DISCARD_EXPR));
	}

	exports.debug_get_compilation_stats = function() {
	    return _debug_hash_codes;
	};

	function debug_compilation_uniqueness(shader_id, shader_text, shader_type, shaders_info) {

	    if (shader_type == _gl.VERTEX_SHADER)
	        var shader_filename = shaders_info.vert;
	    else
	        var shader_filename = shaders_info.frag;

	    var hc = m_util.hash_code_string(shader_text, 0);
	    var info = _debug_hash_codes[hc];

	    if (info) {
	        info.count++;
	    } else {
	        info = {
	            count: 1,
	            shader_filename: shader_filename,
	            hc: hc
	        };
	        _debug_hash_codes[hc] = info;
	    }
	}

	function compile_shader(gl, shader_id, shader_text, shader_type, shaders_info) {

	    if (DEBUG_COMPILATION_UNIQUENESS)
	        debug_compilation_uniqueness(shader_id, shader_text, shader_type, shaders_info);

	    var shader = gl.createShader(shader_type);
	    gl.shaderSource(shader, shader_text);
	    gl.compileShader(shader);

	    return shader;
	}

	exports.get_compiled_shaders = function() {
	    return _compiled_shaders;
	};

	exports.cleanup = cleanup;
	function cleanup() {
	    for (var shader_id in _compiled_shaders)
	        cleanup_shader(_compiled_shaders[shader_id]);

	    for (var id in _shader_ast_cache)
	        delete _shader_ast_cache[id];

	    for (var hc in _debug_hash_codes)
	        delete _debug_hash_codes[hc];

	    _varying_buffer = null;
	    _fragment_uniform_buffer = null;
	    _vertex_uniform_buffer = null;
	    _vars_cache = {};
	}

	exports.cleanup_shader = cleanup_shader;
	function cleanup_shader(shader) {
	    _gl.deleteProgram(shader.program);
	    _gl.deleteShader(shader.vshader);
	    _gl.deleteShader(shader.fshader);
	    delete _compiled_shaders[shader.shader_id];
	}

	exports.debug_shaders_info = function(shaders_info) {
	    var dirs = shaders_info.directives;
	    m_print.log("Shader: " + shaders_info.vert + " " + shaders_info.frag +
	            ", " + String(dirs.length) + " directives: ");
	    for (var i = 0; i < dirs.length; i++)
	        m_print.log("  " + dirs[i][0], dirs[i][1]);
	};

	/**
	 * dim = 0 - assign automatically
	 */
	exports.glsl_value = glsl_value;
	function glsl_value(value, dim) {
	    if (!dim && value.length)
	        dim = value.length;
	    else if (!dim)
	        dim = 1;

	    switch (dim) {
	    case 1:
	        return glsl_float(value);
	        break;
	    case 2:
	        return "vec2(" + glsl_float(value[0]) + "," + glsl_float(value[1]) + ")";
	        break;
	    case 3:
	        return "vec3(" + glsl_float(value[0]) + "," + glsl_float(value[1]) + "," +
	                glsl_float(value[2]) + ")";
	        break;
	    case 4:
	        return "vec4(" + glsl_float(value[0]) + "," + glsl_float(value[1]) + "," +
	                glsl_float(value[2]) + "," + glsl_float(value[3]) + ")";
	        break;
	    case 9:
	        return "mat3(" + glsl_float(value[0]) + "," + glsl_float(value[1]) + "," +
	                glsl_float(value[2]) + "," + glsl_float(value[3]) + "," +
	                glsl_float(value[4]) + "," + glsl_float(value[5]) + "," +
	                glsl_float(value[6]) + "," + glsl_float(value[7]) + "," +
	                glsl_float(value[8]) + ")";
	        break;
	    case 16:
	        return "mat4(" + glsl_float(value[0]) + "," + glsl_float(value[1]) + "," +
	                glsl_float(value[2]) + "," + glsl_float(value[3]) + "," +
	                glsl_float(value[4]) + "," + glsl_float(value[5]) + "," +
	                glsl_float(value[6]) + "," + glsl_float(value[7]) + "," +
	                glsl_float(value[8]) + "," + glsl_float(value[9]) + "," +
	                glsl_float(value[10]) + "," + glsl_float(value[11]) + "," +
	                glsl_float(value[12]) + "," + glsl_float(value[13]) + "," +
	                glsl_float(value[14]) + "," + glsl_float(value[15]) + ")";
	        break;
	    default:
	        m_util.panic("Wrong glsl value dimension");
	        break;
	    }
	}

	function glsl_float(value) {
	    return ((value % 1) ? String(value) : String(value) + ".0");
	}

	exports.check_uniform = function(shader, name) {
	    if (name in shader.uniforms)
	        return true;
	    else
	        return false;
	};

	function particle_output_usage(ndirs, dir) {
	    for (var i = 0; i < ndirs.length; i++)
	        if (ndirs[i][0] == dir)
	            return true;
	    return false;
	}

	exports.reset = function() {
	    _gl = null;
	};

	}

	var int_shaders_factory = register("__shaders", Int_shaders);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Rendering graph routines.
	 *
	 * Rendering graph consists of rendering subscenes, which in turn may have
	 * zero or more inputs and one or more outputs. All subscenes must be closed
	 * to last SINK element. SINK element is a fictional subscene without any outputs.
	 *
	 * @name scenegraph
	 * @namespace
	 * @exports exports as scenegraph
	 */
	function Int_scenegraph(ns, exports) {

	var m_batch  = int_batch_factory(ns);
	var m_cam    = int_camera_factory(ns);
	var m_cfg    = int_config_factory(ns);
	var m_debug  = int_debug_factory(ns);
	var m_graph  = int_graph_factory(ns);
	var m_render = int_renderer_factory(ns);
	var m_shaders = int_shaders_factory(ns);
	var m_subs   = int_subscene_factory(ns);
	var m_tex    = int_textures_factory(ns);
	var m_util   = int_util_factory(ns);

	var cfg_dbg = m_cfg.debug_subs;
	var cfg_def = m_cfg.defaults;
	var cfg_scs = m_cfg.scenes;

	var DEBUG_DISABLE_TEX_REUSE = false;
	var BLOOM_BLUR_SAMPLES = 5;

	var LEFT_ONLY_SUBS_TYPES = [m_subs.GRASS_MAP, m_subs.SHADOW_CAST,
	                            m_subs.MAIN_CUBE_REFLECT,
	                            m_subs.MAIN_CUBE_REFLECT_BLEND];
	/**
	 * Enforce uniqueness
	 */
	function enforce_slink_uniqueness(graph, depth_tex) {
	    var slinks = [];

	    // make inter-subscene slinks unique
	    m_graph.traverse_edges(graph, function(node1, node2, attr) {
	        var slink = attr;

	        if (slinks.indexOf(slink) > -1)
	            m_graph.replace_edge_attr(graph, node1, node2, slink,
	                    clone_slink(slink));
	        else
	            slinks.push(slink);
	    });

	    m_graph.traverse(graph, function(id, attr) {
	        var subs = attr;

	        // make internal slinks unique
	        for (var i = 0; i < subs.slinks_internal.length; i++) {
	            var slink = subs.slinks_internal[i];

	            if (!depth_tex && (subs.type == m_subs.MAIN_PLANE_REFLECT ||
	                    subs.type == m_subs.MAIN_CUBE_REFLECT ||
	                    subs.type == m_subs.MAIN_XRAY))
	                slink.use_renderbuffer = true;

	            if (slinks.indexOf(slink) > -1)
	                subs.slinks_internal[i] = clone_slink(slink);
	            else
	                slinks.push(slink);
	        }
	    });
	}

	/**
	 * Slinks compliance, etc
	 */
	function enforce_graph_consistency(graph, depth_tex) {
	    m_graph.traverse(graph, function(id, attr) {
	        var subs = attr;

	        // assign linear filtering to MOTION_BLUR accumulator
	        // if such subscene connected to ANTIALIASING
	        if (subs.type == m_subs.ANTIALIASING)
	            m_graph.traverse_inputs(graph, id, function(id_in, attr_in,
	                    attr_edge) {

	                var subs_in = attr_in;

	                if (subs_in.type == m_subs.MOTION_BLUR) {
	                    for (var i = 0; i < subs_in.slinks_internal.length; i++) {
	                        var slink_mb_int = subs_in.slinks_internal[i];
	                        slink_mb_int.min_filter = m_tex.TF_LINEAR;
	                        slink_mb_int.mag_filter = m_tex.TF_LINEAR;
	                    }
	                }
	            });

	        if (!depth_tex)
	            m_graph.traverse_inputs(graph, id, function(id_in, attr_in,
	                    attr_edge) {
	                var slink = attr_edge;
	                if (slink.from == "DEPTH")
	                    slink.use_renderbuffer = true;
	            });
	    });

	    m_graph.traverse(graph, function(id, attr) {
	        var dest = {};

	        combine_same_slinks(graph, id, dest);

	        for (var i in dest) {
	            var slinks = dest[i];

	            // select maximum quality min filter
	            var min_filt_slink = slinks[0];
	            for (var j = 0; j < slinks.length; j++) {
	                if (slinks[j].min_filter == m_tex.TF_LINEAR) {
	                    min_filt_slink = slinks[j];
	                    break;
	                }
	            }

	            // select maximum quality mag filter
	            var mag_filt_slink = slinks[0];
	            for (var j = 0; j < slinks.length; j++) {
	                if (slinks[j].mag_filter == m_tex.TF_LINEAR) {
	                    mag_filt_slink = slinks[j];
	                    break;
	                }
	            }

	            // select non-renderbuffer
	            var not_rb_slink = slinks[0];
	            for (var j = 0; j < slinks.length; j++) {
	                if (!slinks[j].use_renderbuffer) {
	                    not_rb_slink = slinks[j];
	                    break;
	                }
	            }

	            // assign values from selected slinks
	            for (var j = 0; j < slinks.length; j++) {
	                slinks[j].min_filter = min_filt_slink.min_filter;
	                slinks[j].mag_filter = mag_filt_slink.mag_filter;
	                slinks[j].use_renderbuffer = not_rb_slink.use_renderbuffer;
	            }
	        }

	    });
	}

	function combine_same_slinks(graph, id, dest) {

	    m_graph.traverse_inputs(graph, id, function(id_in, attr_in,
	            attr_edge) {
	        var slink = attr_edge;

	        // passive slink doesn't affect other
	        if (!slink.active)
	            return;

	        if (slink.from == slink.to) {
	            dest[slink.from] = dest[slink.from] || [];

	            if (dest[slink.from].indexOf(slink) == -1)
	                dest[slink.from].push(slink);

	            combine_same_slinks(graph, id_in, dest);
	        }
	    });

	    m_graph.traverse_outputs(graph, id, function(id_out, attr_out,
	            attr_edge) {
	        var slink = attr_edge;

	        // passive slink doesn't affect other
	        if (!slink.active)
	            return;

	        dest[slink.from] = dest[slink.from] || [];
	        if (dest[slink.from].indexOf(slink) == -1)
	            dest[slink.from].push(slink);
	    });

	    // special case: internal interchanges with output
	    var subs = m_graph.get_node_attr(graph, id);
	    if (subs.type == m_subs.MOTION_BLUR) {
	        for (var i = 0; i < subs.slinks_internal.length; i++) {
	            var slink = subs.slinks_internal[i];
	            dest[slink.from].push(slink);
	        }
	    }
	}


	exports.check_slink_tex_conn = function(slink) {
	    switch (slink.to) {
	    case "COLOR":
	    case "CUBEMAP":
	    case "DEPTH":
	    case "SCREEN":
	    case "OFFSCREEN":
	    case "RESOLVE":
	    case "COPY":
	    case "NONE":
	        return false;
	    default:
	        return true;
	    }
	};

	function process_subscene_links(graph) {
	    // disable texture reuse for some scenes
	    var FORCE_UNIQUE_TEXTURE_SUBS = [m_subs.MOTION_BLUR, m_subs.SMAA_RESOLVE,
	            m_subs.SMAA_NEIGHBORHOOD_BLENDING, m_subs.MAIN_PLANE_REFLECT,
	            m_subs.MAIN_CUBE_REFLECT, m_subs.PERFORMANCE];
	    if (!cfg_def.webgl2)
	        FORCE_UNIQUE_TEXTURE_SUBS.push(m_subs.AVERAGE_LUMINANCE);

	    var graph_sorted = m_graph.topsort(graph);
	    var tex_storage = [];

	    m_graph.traverse(graph_sorted, function(id, attr) {
	        var subs = attr;

	        // assign new (or unused) internal textures
	        for (var i = 0; i < subs.slinks_internal.length; i++) {
	            var slink = subs.slinks_internal[i];

	            if (FORCE_UNIQUE_TEXTURE_SUBS.indexOf(subs.type) > -1)
	                slink.unique_texture = true;

	            var tex = tex_aquire(tex_storage, slink,
	                    calc_slink_id(slink));

	            slink.texture = tex;
	            subs.textures_internal[i] = tex;
	        }

	        // release internal textures now
	        for (var i = 0; i < subs.textures_internal.length; i++) {
	            var tex = subs.textures_internal[i];
	            tex_dec_ref(tex_storage, tex);
	        }

	        // connect new (or unused) external textures
	        m_graph.traverse_outputs(graph_sorted, id, function(id_out, attr_out,
	                attr_edge) {
	            var slink = attr_edge;

	            if (slink.texture)
	                return;

	            if (FORCE_UNIQUE_TEXTURE_SUBS.indexOf(subs.type) > -1)
	                slink.unique_texture = true;
	            else {
	                var tex = find_nearest_tex(graph_sorted, id, slink.from);
	                if (tex && slink.active && !slink.texture) {
	                    tex_inc_ref(tex_storage, tex);
	                    slink.texture = tex;
	                    return;
	                }
	            }

	            tex = tex_aquire(tex_storage, slink, calc_slink_id(slink));
	            slink.texture = tex;
	        });

	        // release unused textures from previous subscenes
	        m_graph.traverse_inputs(graph_sorted, id, function(id_in, attr_in,
	                attr_edge) {
	            tex_dec_ref(tex_storage, attr_edge.texture);
	        });

	        // release unused non-connected textures
	        m_graph.traverse_outputs(graph_sorted, id, function(id_out, attr_out,
	                attr_edge) {
	            var slink = attr_edge;

	            if (slink.texture && slink.to == "NONE") {
	                tex_dec_ref(tex_storage, slink.texture);
	            }
	        });
	    });
	}

	function calc_slink_id(slink) {

	    var to = slink.to;
	    var active = slink.active;
	    var texture = slink.texture;

	    slink.to = "";
	    slink.active = false;
	    slink.texture = null;

	    var id = m_util.calc_variable_id(slink, 0);

	    slink.to = to;
	    slink.active = active;
	    slink.texture = texture;

	    return id;
	}

	function find_nearest_tex(graph, id, type) {

	    var tex = null;

	    m_graph.traverse_inputs(graph, id, function(id_in, attr_in,
	            attr_edge) {
	        var slink = attr_edge;

	        if (slink.active && slink.from == slink.to && slink.from == type &&
	                slink.texture) {
	            tex = slink.texture;
	            return true;
	        }
	    });

	    m_graph.traverse_outputs(graph, id, function(id_out, attr_out,
	            attr_edge) {
	        var slink = attr_edge;

	        if (slink.active && slink.from == type && slink.texture) {
	            tex = slink.texture;
	            return true;
	        }
	    });

	    return tex;
	}

	function tex_inc_ref(storage, tex) {
	    for (var i = 0; i < storage.length; i++) {
	        var item = storage[i];

	        if (item.tex === tex)
	            item.ref++;
	    }
	}

	function tex_dec_ref(storage, tex) {
	    for (var i = 0; i < storage.length; i++) {
	        var item = storage[i];

	        if (item.tex === tex && item.ref)
	            item.ref--;
	    }
	}

	function tex_aquire(storage, slink, slink_id) {
	    if (slink.parent_slink) {
	        tex_inc_ref(storage, slink.parent_slink.texture);
	        return slink.parent_slink.texture;
	    }

	    // a unique texture isn't presented in storage
	    if (slink.unique_texture)
	        return tex_create_for_slink(slink);

	    var storage_item_free = null;

	    // find first unused attachment
	    for (var i = 0; i < storage.length; i++) {
	        var item = storage[i];

	        if (item.id == slink_id && item.ref === 0) {
	            storage_item_free = item;
	            break;
	        }
	    }

	    if (storage_item_free && !(DEBUG_DISABLE_TEX_REUSE || cfg_def.firefox_tex_reuse_hack)) {
	        storage_item_free.ref++;
	        return storage_item_free.tex;
	    } else {
	        var tex = tex_create_for_slink(slink);
	        storage.push({
	            id: slink_id,
	            ref: 1,
	            tex: tex
	        });
	        return tex;
	    }
	}

	function tex_create_for_slink(slink) {
	    var size_x = slink.size_mult_x * slink.size;
	    var size_y = slink.size_mult_y * slink.size;
	    var use_comparison = slink.use_comparison;
	    var use_mipmap = slink.use_mipmap;

	    switch (slink.from) {
	    case "COLOR":
	        if (slink.use_renderbuffer) {
	            var tex = m_tex.create_texture(slink.multisample ?
	                    m_tex.TT_RB_RGBA_MS : m_tex.TT_RB_RGBA, use_comparison,
	                    use_mipmap);
	            m_tex.resize(tex, size_x, size_y);
	        } else {
	            var tex = m_tex.create_texture(m_tex.TT_RGBA_INT, use_comparison,
	                    use_mipmap);
	            m_tex.resize(tex, size_x, size_y);
	            m_tex.set_filters(tex, slink.min_filter, slink.mag_filter);
	        }
	        return tex;
	    case "DEPTH":
	        if (slink.use_renderbuffer) {
	            var tex = m_tex.create_texture(slink.multisample ?
	                    m_tex.TT_RB_DEPTH_MS : m_tex.TT_RB_DEPTH, use_comparison,
	                    use_mipmap);
	            m_tex.resize(tex, size_x, size_y);
	        } else {
	            var tex = m_tex.create_texture(m_tex.TT_DEPTH, use_comparison,
	                    use_mipmap);
	            m_tex.resize(tex, size_x, size_y);
	            m_tex.set_filters(tex, slink.min_filter, slink.mag_filter);
	        }
	        return tex;
	    case "CUBEMAP":
	        var tex = m_tex.create_cubemap_texture(size_x, use_mipmap);
	        return tex;
	    case "SCREEN":
	    case "NONE":
	        return null;
	    default:
	        m_util.panic("Wrong slink param: " + slink.from);
	    }
	}

	exports.traverse_slinks = traverse_slinks;
	/**
	 */
	function traverse_slinks(graph, callback) {

	    var exit = false;

	    // process slinks assigned as inter-subscene edges
	    m_graph.traverse_edges(graph, function(node1, node2, attr) {
	        var slink = attr;
	        if (!slink)
	            return;

	        var subs1 = m_graph.get_node_attr(graph, node1);
	        var subs2 = m_graph.get_node_attr(graph, node2);

	        if (callback(slink, false, subs1, subs2)) {
	            exit = true;
	            return true;
	        }
	    });

	    if (exit)
	        return;

	    // process internal slinks
	    m_graph.traverse(graph, function(node, attr) {
	        var subs = attr;

	        for (var i = 0; i < subs.slinks_internal.length; i++) {
	            var slink = subs.slinks_internal[i];

	            if (callback(slink, true, subs, null))
	                return true;
	        }
	    });
	}

	function assign_render_targets(graph) {
	    m_graph.traverse(graph, function(nid, subs) {
	        if (subs.type == m_subs.SINK)
	            return;

	        var cam = subs.camera;
	        m_graph.traverse_outputs(graph, nid, function(nid_out, subs_out,
	                slink) {
	        if (slink.texture)
	            if (slink.active && slink.texture) {
	                m_cam.set_attachment(cam, slink.from, slink.texture);

	                if (slink.from == slink.to && subs_out.camera)
	                    m_cam.set_attachment(subs_out.camera, slink.from, slink.texture);
	            }
	        });

	        for (var i = 0; i < subs.slinks_internal.length; i++) {
	            var slink_int = subs.slinks_internal[i];

	            if (slink_int.active && slink_int.from == slink_int.to) {
	                var tex = subs.textures_internal[i];
	                m_cam.set_attachment(cam, slink_int.from, tex);
	            }
	        }

	        if ((cam.color_attachment || cam.depth_attachment) && !cam.framebuffer)
	            cam.framebuffer = m_render.render_target_create(cam.color_attachment,
	                    cam.depth_attachment);
	    });

	    m_graph.traverse(graph, function(nid, subs) {
	        if (subs.type == m_subs.RESOLVE || subs.type == m_subs.COPY) {
	            var inputs = get_inputs(graph, subs);
	            var cam = subs.camera;
	            cam.framebuffer_prev = inputs[0].camera.framebuffer;
	        }
	    });
	}

	/**
	 * Prepare full-featured rendering graph for given scene render.
	 * @param {Object3D} sc_render Scene render object
	 * @param {Object3D} cam_scene_data Camera scene data
	 * @param {Object3D} cam_render Camera render object
	 * @param {boolean} render_to_textures Textures for offscreen rendering
	 * @returns Rendering graph
	 */
	exports.create_rendering_graph = function(sc_render, cam_scene_data,
	        cam_render, render_to_textures) {

	    var graph = m_graph.create();

	    // subscenes from previous level
	    var prev_level = [];
	    // currently populated level
	    var curr_level = [];

	    // shared
	    var shadow_subscenes      = [];
	    var shadow_links          = [];
	    var reflect_subscenes     = [];
	    var reflect_links         = [];
	    var cube_refl_subscenes   = [];
	    var cube_reflect_links    = [];
	    var sky_reflect_links     = [];

	    var num_lights      = sc_render.lamps_number;
	    var water_params    = sc_render.water_params;
	    var shore_smoothing = sc_render.shore_smoothing;
	    var soft_particles  = sc_render.soft_particles;
	    var ssao            = sc_render.ssao;
	    var god_rays        = sc_render.god_rays;
	    var refl_params     = sc_render.reflection_params;
	    var mat_params      = sc_render.materials_params;
	    var bloom_params    = sc_render.bloom_params;
	    var motion_blur     = sc_render.motion_blur;
	    var compositing     = sc_render.compositing;
	    var antialiasing    = sc_render.antialiasing;
	    var wls_params      = sc_render.world_light_set;
	    var wfs_params      = sc_render.world_fog_set;
	    var shadow_params   = sc_render.shadow_params;
	    var mb_params       = sc_render.mb_params;
	    var cc_params       = sc_render.cc_params;
	    var gr_params       = sc_render.god_rays_params;
	    var outline_params  = sc_render.outline_params;
	    var dof             = sc_render.dof;
	    var depth_tex       = sc_render.depth_tex;
	    var refractions     = sc_render.refractions;

	    var rtt = Boolean(render_to_textures.length);
	    var msaa = cfg_def.msaa_samples > 1;
	    cfg_def.reuse_depth_optimization = cfg_def.reuse_depth_optimization &&
	            Boolean(shadow_params) && !(msaa && ssao);
	    var reuse_depth_optimization = cfg_def.reuse_depth_optimization;

	    var slink_color_o = create_slink("COLOR", "COLOR", 1, 1, 1, true, true);
	    var slink_depth_o = create_slink("DEPTH", "DEPTH", 1, 1, 1, true, true);
	    if (msaa) {
	        var slink_depth_resolve_o = clone_slink(slink_depth_o);
	        slink_color_o.multisample = true;
	        slink_color_o.use_renderbuffer = true;
	        slink_depth_o.multisample = true;
	        slink_depth_o.use_renderbuffer = true;
	    }

	    var main_cam = cam_scene_data.cameras[0];

	    // dynamic grass
	    if (sc_render.dynamic_grass) {
	        var subs_grass_map = m_subs.create_subs_grass_map();

	        m_graph.append_node_attr(graph, subs_grass_map);

	        var tex_size = cfg_scs.grass_tex_size;

	        // NOTE: deprecated
	        subs_grass_map.camera.width = tex_size;
	        subs_grass_map.camera.height = tex_size;

	        var slink_grass_map_d = create_slink("DEPTH", "u_grass_map_depth",
	                tex_size, 1, 1, false, false);
	        if (!cfg_def.webgl2) {
	            slink_grass_map_d.min_filter = m_tex.TF_LINEAR;
	            slink_grass_map_d.mag_filter = m_tex.TF_LINEAR;
	        }

	        // NOTE: need to be optional?
	        var slink_grass_map_c = create_slink("COLOR", "u_grass_map_color",
	                tex_size, 1, 1, false, false);
	        slink_grass_map_c.min_filter = m_tex.TF_LINEAR;
	        slink_grass_map_c.mag_filter = m_tex.TF_LINEAR;
	    } else {
	        var subs_grass_map = null;
	        var slink_grass_map_d = null;
	        var slink_grass_map_c = null;
	    }

	    // shadow stuff
	    if (shadow_params) {
	        m_cam.update_camera_shadows(main_cam, shadow_params);

	        for (var j = 0; j < shadow_params.lamp_types.length; j++) {
	            var csm_num = shadow_params.csm_num;
	            for (var i = 0; i < csm_num; i++) {
	                var subs_shadow = m_subs.create_subs_shadow_cast(i, j, shadow_params, num_lights);
	                m_graph.append_node_attr(graph, subs_shadow);
	                shadow_subscenes.push(subs_shadow);

	                var tex_size = shadow_params.csm_resolution;

	                var cam = subs_shadow.camera;

	                // NOTE: shadow cameras used in LOD shadows calculations
	                cam_scene_data.shadow_cameras.push(cam);

	                cam.width = tex_size;
	                cam.height = tex_size;

	                subs_shadow.clear_color = true;

	                // NOTE: we use one lamp with csm or a lot of cast lamps
	                var index = j > 0 ? j : i;

	                if (cfg_def.rgba_fallback_shadows) {
	                    var color_slink = create_slink("COLOR", "u_shadow_map" + index,
	                                tex_size, 1, 1, false, false);
	                    shadow_links.push(color_slink);
	                    var shadow_depth = create_slink("DEPTH",
	                                "DEPTH", tex_size, 1, 1, false, false);
	                    shadow_depth.use_renderbuffer = true;
	                    subs_shadow.slinks_internal.push(shadow_depth);
	                } else {
	                    var depth_slink = create_slink("DEPTH", "u_shadow_map" + index,
	                                tex_size, 1, 1, false, false);
	                    if (cfg_def.compared_mode_depth) {
	                        depth_slink.min_filter = m_tex.TF_LINEAR;
	                        depth_slink.mag_filter = m_tex.TF_LINEAR;
	                        depth_slink.use_comparison = true;
	                    }
	                    shadow_links.push(depth_slink);

	                    if (m_debug.check_depth_only_issue() || cfg_def.shadows_color_slink_hack) {
	                        subs_shadow.slinks_internal.push(create_slink("COLOR",
	                                "COLOR", tex_size, 1, 1, false, false));
	                    }
	                }

	                if (subs_grass_map) {
	                    m_graph.append_edge_attr(graph, subs_grass_map, subs_shadow,
	                            slink_grass_map_d);
	                    m_graph.append_edge_attr(graph, subs_grass_map, subs_shadow,
	                            slink_grass_map_c);
	                }
	            }
	        }
	    }

	    // cube reflections
	    if (refl_params && refl_params.num_cube_refl && !rtt) {
	        for (var i = 0; i < refl_params.num_cube_refl; i++) {
	            var cam = m_cam.create_camera(m_cam.TYPE_PERSP);

	            cam.width = sc_render.cubemap_refl_size;
	            cam.height = sc_render.cubemap_refl_size;

	            m_cam.set_frustum(cam, Math.PI/2, 0.1, 100);
	            m_cam.set_projection(cam, false);

	            var subs_refl = m_subs.create_subs_main(m_subs.MAIN_CUBE_REFLECT, cam, false,
	                    water_params, num_lights, wfs_params, wls_params, null, sc_render.sun_exist);
	            subs_refl.cube_view_matrices = m_util.generate_inv_cubemap_matrices();

	            for (var j = 0; j < 6; j++)
	                subs_refl.cube_cam_frustums.push(m_cam.create_frustum_planes());

	            m_graph.append_node_attr(graph, subs_refl);

	            var slink_refl_c = create_slink("CUBEMAP", "u_cube_reflection",
	                                            sc_render.cubemap_refl_size, 1, 1,
	                                            false, false);
	            slink_refl_c.min_filter = m_tex.TF_LINEAR;
	            slink_refl_c.mag_filter = m_tex.TF_LINEAR;

	            cube_reflect_links.push(slink_refl_c);

	            if (!refl_params.has_reflexible) {
	                var slink_refl_s = create_slink("CUBEMAP", "u_sky_reflection",
	                                                sc_render.cubemap_refl_size, 1, 1, false);
	                slink_refl_s.use_mipmap = true;
	                slink_refl_s.min_filter = m_tex.TF_LINEAR_MIPMAP_LINEAR;
	                slink_refl_s.mag_filter = m_tex.TF_LINEAR;

	                sky_reflect_links.push(slink_refl_s);
	            }

	            if (subs_grass_map) {
	                m_graph.append_edge_attr(graph, subs_grass_map, subs_refl,
	                        slink_grass_map_d);
	                m_graph.append_edge_attr(graph, subs_grass_map, subs_refl,
	                        slink_grass_map_c);
	            }

	            if (refl_params.has_blend_reflexible) {
	                var subs_refl_blend = m_subs.create_subs_main(m_subs.MAIN_CUBE_REFLECT_BLEND, cam, false,
	                        water_params, num_lights, wfs_params, wls_params, null, sc_render.sun_exist);
	                subs_refl_blend.cube_view_matrices = subs_refl.cube_view_matrices;
	                subs_refl_blend.cube_cam_frustums = subs_refl.cube_cam_frustums;

	                m_graph.append_node_attr(graph, subs_refl_blend);
	                var slink_depth_refl = create_slink("DEPTH", "DEPTH",
	                                        sc_render.cubemap_refl_size, 1, 1,
	                                        false, false);
	                var slink_color_refl = create_slink("COLOR", "COLOR",
	                                        sc_render.cubemap_refl_size, 1, 1,
	                                        false, false);
	                m_graph.append_edge_attr(graph, subs_refl, subs_refl_blend, slink_depth_refl);
	                m_graph.append_edge_attr(graph, subs_refl, subs_refl_blend, slink_color_refl);

	                cube_refl_subscenes.push(subs_refl_blend);
	                refl_params.cube_refl_subs_blend.push(subs_refl_blend);

	                if (subs_grass_map) {
	                    m_graph.append_edge_attr(graph, subs_grass_map, subs_refl_blend,
	                            slink_grass_map_d);
	                    m_graph.append_edge_attr(graph, subs_grass_map, subs_refl_blend,
	                            slink_grass_map_c);
	                }
	            } else {
	                var slink_refl_d = create_slink("DEPTH", "DEPTH",
	                                                sc_render.cubemap_refl_size, 1,
	                                                1, false, false);
	                subs_refl.slinks_internal.push(slink_refl_d);
	                cube_refl_subscenes.push(subs_refl);
	            }
	            refl_params.cube_refl_subs.push(subs_refl);
	        }
	    }

	    // plane reflections
	    if (refl_params && refl_params.refl_plane_objs.length > 0 && !rtt) {
	        for (var j = 0; j < refl_params.refl_plane_objs.length; j++) {
	            var cam = m_cam.clone_camera(main_cam, true);

	            cam.reflection_plane = new Float32Array(4);
	            cam_scene_data.cameras.push(cam);

	            var subs_refl = m_subs.create_subs_main(m_subs.MAIN_PLANE_REFLECT, cam, false,
	                               water_params, num_lights, wfs_params, wls_params,
	                               null, sc_render.sun_exist);

	            m_graph.append_node_attr(graph, subs_refl);

	            var slink_refl_c = create_slink("COLOR", "u_plane_reflection", 1,
	                                            sc_render.plane_refl_size,
	                                            sc_render.plane_refl_size, true, true);
	            slink_refl_c.min_filter = m_tex.TF_LINEAR;
	            slink_refl_c.mag_filter = m_tex.TF_LINEAR;

	            reflect_links.push(slink_refl_c);

	            if (subs_grass_map) {
	                m_graph.append_edge_attr(graph, subs_grass_map, subs_refl,
	                        slink_grass_map_d);
	                m_graph.append_edge_attr(graph, subs_grass_map, subs_refl,
	                        slink_grass_map_c);
	            }

	            if (refl_params.has_blend_reflexible) {
	                var subs_refl_blend = m_subs.create_subs_main(m_subs.MAIN_PLANE_REFLECT_BLEND,
	                               cam, false, water_params, num_lights, wfs_params,
	                               wls_params, null, sc_render.sun_exist);

	                m_graph.append_node_attr(graph, subs_refl_blend);
	                var slink_depth_refl = create_slink("DEPTH", "DEPTH", 1,
	                                        sc_render.plane_refl_size,
	                                        sc_render.plane_refl_size, true, true);
	                var slink_color_refl = create_slink("COLOR", "COLOR", 1,
	                                        sc_render.plane_refl_size,
	                                        sc_render.plane_refl_size, true, true);
	                slink_color_refl.min_filter = m_tex.TF_NEAREST;
	                slink_color_refl.mag_filter = m_tex.TF_NEAREST;
	                m_graph.append_edge_attr(graph, subs_refl, subs_refl_blend, slink_depth_refl);
	                m_graph.append_edge_attr(graph, subs_refl, subs_refl_blend, slink_color_refl);

	                refl_params.plane_refl_subs_blend.push([subs_refl_blend]);
	                reflect_subscenes.push(subs_refl_blend);

	                if (subs_grass_map) {
	                    m_graph.append_edge_attr(graph, subs_grass_map, subs_refl_blend,
	                            slink_grass_map_d);
	                    m_graph.append_edge_attr(graph, subs_grass_map, subs_refl_blend,
	                            slink_grass_map_c);
	                }
	            } else {
	                var slink_refl_d = create_slink("DEPTH", "DEPTH", 1,
	                                    sc_render.plane_refl_size,
	                                    sc_render.plane_refl_size, true, true);

	                subs_refl.slinks_internal.push(slink_refl_d);
	                reflect_subscenes.push(subs_refl);
	            }

	            refl_params.plane_refl_subs.push([subs_refl]);
	        }
	    }

	    // depth
	    if (shadow_params) {
	        var cam_sh_receive = m_cam.clone_camera(main_cam, true);
	        cam_scene_data.cameras.push(cam_sh_receive);

	        var subs_receive = m_subs.create_subs_shadow_receive(graph, cam_sh_receive, num_lights);

	        m_graph.append_node_attr(graph, subs_receive);

	        subs_receive.self_shadow_normal_offset = shadow_params.self_shadow_normal_offset;

	        for (var i = 0; i < shadow_subscenes.length; i++) {
	            var subs_shadow = shadow_subscenes[i];
	            var slink_shadow = shadow_links[i];

	            m_graph.append_edge_attr(graph, subs_shadow, subs_receive, slink_shadow);
	        }

	        if (reuse_depth_optimization) {
	            var depth_slink = create_slink("DEPTH", "DEPTH", 1, 1, 1, true, true);
	            if (msaa) {
	                depth_slink.multisample = true;
	                depth_slink.use_renderbuffer = true;

	                var subs_res_shadow = m_subs.create_subs_resolve();
	                m_graph.append_node_attr(graph, subs_res_shadow);
	                var slink_resolve_shadow_c = create_slink("COLOR", "RESOLVE", 1, 1, 1,
	                        true, true);
	                slink_resolve_shadow_c.multisample = true;
	                slink_resolve_shadow_c.use_renderbuffer = true;
	                var slink_resolve_shadow_d = create_slink("DEPTH", "RESOLVE", 1, 1, 1,
	                        true, true);
	                slink_resolve_shadow_d.multisample = true;
	                slink_resolve_shadow_d.use_renderbuffer = true;
	                m_graph.append_edge_attr(graph, subs_receive, subs_res_shadow, slink_resolve_shadow_c);
	                m_graph.append_edge_attr(graph, subs_receive, subs_res_shadow, slink_resolve_shadow_d);
	            }
	        } else if (msaa) {
	            var depth_slink = create_slink("DEPTH", "DEPTH", 1, 1, 1, true, true);
	        } else if (cfg_def.rgba_fallback_shadows) {
	            var depth_slink = create_slink("DEPTH", "DEPTH", 1, 1, 1, true, true);
	            depth_slink.use_renderbuffer = true;
	        } else {
	            var depth_slink = slink_depth_o;
	        }

	        if (ssao) {
	            // ssao
	            var slink_depth_c = create_slink("COLOR", "u_color", 1, 1, 1, true, true);
	            var slink_depth_d = create_slink("DEPTH", "u_depth", 1, 1, 1, true, true);
	            var cam_ssao = m_cam.clone_camera(main_cam, true);
	            cam_scene_data.cameras.push(cam_ssao);

	            var ssao_params = sc_render.ssao_params;
	            var subs_ssao = m_subs.create_subs_ssao(cam_ssao, wfs_params, ssao_params);
	            m_graph.append_node_attr(graph, subs_ssao);

	            var slink_ssao = create_slink("COLOR", "u_ssao_mask", 1, 1, 1, true, true);

	            m_graph.append_edge_attr(graph, subs_receive, subs_ssao, slink_depth_c);
	            m_graph.append_edge_attr(graph, subs_receive, subs_ssao, slink_depth_d);

	            // ssao_blur
	            var cam_ssao_blur = m_cam.clone_camera(main_cam, true);
	            cam_scene_data.cameras.push(cam_ssao_blur);

	            var subs_ssao_blur = m_subs.create_subs_ssao_blur(cam_ssao_blur, ssao_params);
	            m_graph.append_node_attr(graph, subs_ssao_blur);

	            var slink_ssao_blur = create_slink("COLOR", "u_shadow_mask", 1, 1, 1, true, true);

	            m_graph.append_edge_attr(graph, subs_ssao, subs_ssao_blur, slink_ssao);
	            m_graph.append_edge_attr(graph, subs_receive, subs_ssao_blur, slink_depth_d);
	        }

	        if (subs_grass_map) {
	            m_graph.append_edge_attr(graph, subs_grass_map, subs_receive,
	                    slink_grass_map_d);
	            m_graph.append_edge_attr(graph, subs_grass_map, subs_receive,
	                    slink_grass_map_c);
	        }
	    } else
	        var subs_receive = null;

	    // main opaque
	    var subs_main_opaque = m_subs.create_subs_main(m_subs.MAIN_OPAQUE, main_cam,
	            !reuse_depth_optimization, water_params, num_lights, wfs_params,
	            wls_params, null, sc_render.sun_exist);

	    m_graph.append_node_attr(graph, subs_main_opaque);

	    if (shadow_params) {
	        if (reuse_depth_optimization) {
	            m_graph.append_edge_attr(graph, subs_receive, subs_main_opaque,
	                    depth_slink);
	        } else {
	            subs_receive.slinks_internal.push(depth_slink);
	        }
	    }

	    if (msaa) {
	        var subs_res_opaque = m_subs.create_subs_resolve();
	        m_graph.append_node_attr(graph, subs_res_opaque);

	        curr_level.push(subs_res_opaque);

	        var slink_resolve_in_c = create_slink("COLOR", "RESOLVE", 1, 1, 1,
	                true, true);
	        slink_resolve_in_c.multisample = true;
	        slink_resolve_in_c.use_renderbuffer = true;
	        var slink_resolve_in_d = create_slink("DEPTH", "RESOLVE", 1, 1, 1,
	                true, true);
	        slink_resolve_in_d.multisample = true;
	        slink_resolve_in_d.use_renderbuffer = true;
	        m_graph.append_edge_attr(graph, subs_main_opaque, subs_res_opaque, slink_resolve_in_c);
	        m_graph.append_edge_attr(graph, subs_main_opaque, subs_res_opaque, slink_resolve_in_d);
	    } else {
	        curr_level.push(subs_main_opaque);
	    }

	    if (subs_receive) {
	        if (slink_ssao)
	            m_graph.append_edge_attr(graph, subs_ssao_blur, subs_main_opaque, slink_ssao_blur);
	        else {
	            var shadow_mask_slink = create_slink("COLOR", "u_shadow_mask", 1, 1, 1, true, true);
	            m_graph.append_edge_attr(graph, reuse_depth_optimization && msaa?
	                    subs_res_shadow: subs_receive, subs_main_opaque,
	                    shadow_mask_slink);
	        }
	    }

	    if (subs_grass_map) {
	        m_graph.append_edge_attr(graph, subs_grass_map, subs_main_opaque,
	                slink_grass_map_d);
	        m_graph.append_edge_attr(graph, subs_grass_map, subs_main_opaque,
	                slink_grass_map_c);
	    }

	    if (reflect_subscenes.length) {
	        var num_refl_subs = reflect_subscenes.length;
	        for (var j = 0; j < num_refl_subs; j++) {
	            m_graph.append_edge_attr(graph,
	                                     reflect_subscenes[j], subs_main_opaque,
	                                     reflect_links[j]);
	        }
	    }

	    if (cube_refl_subscenes.length) {
	        for (var j = 0; j < cube_refl_subscenes.length; j++) {
	            m_graph.append_edge_attr(graph, cube_refl_subscenes[j], subs_main_opaque,
	                    cube_reflect_links[j]);
	        }
	    }

	    prev_level = curr_level;
	    curr_level = [];

	    if (!rtt && sc_render.color_picking) {
	        var is_color_sub_debug = cfg_dbg.enabled && (cfg_dbg.subs_type === m_subs.COLOR_PICKING ||
	                cfg_dbg.subs_type === m_subs.COLOR_PICKING_XRAY);
	        var cam = m_cam.clone_camera(main_cam, true);
	        if (!is_color_sub_debug)
	            cam.width = cam.height = 1;

	        // camera depends on bpy camera
	        cam_scene_data.cameras.push(cam);

	        var subs_color_picking = m_subs.create_subs_color_picking(cam, false, num_lights);
	        m_graph.append_node_attr(graph, subs_color_picking);

	        if (sc_render.xray) {
	            cam = m_cam.clone_camera(main_cam, true);
	            if (!is_color_sub_debug)
	                cam.width = cam.height = 1;

	            cam_scene_data.cameras.push(cam);
	            var subs_color_picking_xray = m_subs.create_subs_color_picking(cam, true, num_lights);
	            m_graph.append_node_attr(graph, subs_color_picking_xray);
	            var cp_slink_c = create_slink("COLOR", "COLOR", 1, 1, 1, is_color_sub_debug, true);
	            m_graph.append_edge_attr(graph, subs_color_picking,
	                                     subs_color_picking_xray, cp_slink_c);
	            var cp_slink_d = create_slink("DEPTH", "DEPTH", 1, 1, 1, is_color_sub_debug, true);
	            m_graph.append_edge_attr(graph, subs_color_picking,
	                                     subs_color_picking_xray, cp_slink_d);
	        }
	    } else
	        var subs_color_picking = null;

	    // refraction subscene
	    if ((mat_params.refractions || refractions) && !rtt) {
	        if (!msaa) {
	            if (cfg_def.ios_copy_tex_hack) {
	                var subs_refr = m_subs.create_subs_postprocessing("NONE");
	                var slink_refr_in = create_slink("COLOR", "u_color", 1, 1, 1, true, true);
	            } else {
	                var subs_refr = m_subs.create_subs_copy();
	                var slink_refr_in = create_slink("COLOR", "COPY", 1, 1, 1, true, true);
	            }

	            m_graph.append_node_attr(graph, subs_refr);
	            m_graph.append_edge_attr(graph, prev_level[0], subs_refr, slink_refr_in);
	        } else
	            var subs_refr = subs_res_opaque;

	        var slink_refr = create_slink("COLOR", "u_refractmap", 1, 1, 1, true, true);
	    } else
	        var subs_refr = null;

	    if (depth_tex && (refractions || shore_smoothing || soft_particles)) {

	        var cam_depth_pack = m_cam.clone_camera(main_cam, true);
	        cam_scene_data.cameras.push(cam_depth_pack);

	        var subs_depth_pack = m_subs.create_subs_depth_pack(cam_depth_pack);
	        m_graph.append_node_attr(graph, subs_depth_pack);

	        var slink_depth_pack_in = create_slink("DEPTH", "u_depth", 1, 1, 1, true, true);
	        m_graph.append_edge_attr(graph, msaa ? subs_res_opaque : subs_main_opaque,
	                subs_depth_pack, slink_depth_pack_in);

	        var slink_depth_pack_out = create_slink("COLOR", "u_scene_depth", 1, 1, 1, true, true);
	        // disable filtering for packed depth
	        slink_depth_pack_out.min_filter = m_tex.TF_NEAREST;
	        slink_depth_pack_out.mag_filter = m_tex.TF_NEAREST;
	    } else
	        var subs_depth_pack = null;

	    // to prevent code duplication
	    var create_custom_sub_main = function(type) {
	        var cam = m_cam.clone_camera(main_cam, true);
	        cam_scene_data.cameras.push(cam);

	        var subs_main = m_subs.create_subs_main(type, cam, false, water_params,
	                num_lights, wfs_params, wls_params, shadow_params, sc_render.sun_exist);

	        m_graph.append_node_attr(graph, subs_main);

	        if (type == m_subs.MAIN_XRAY) {
	            // NOTE: disable MSAA
	            var slink_color = create_slink("COLOR", "COLOR", 1, 1, 1, true, true);
	            m_graph.append_edge_attr(graph, prev_level[0], subs_main, slink_color);

	            var slink_depth = create_slink("DEPTH", "DEPTH", 1, 1, 1, true, true);
	            subs_main.slinks_internal.push(slink_depth);
	        } else {
	            // NOTE: it's possible to do better
	            if (msaa && prev_level[0].type == m_subs.RESOLVE)
	                var subs_prev = subs_main_opaque;
	            else
	                var subs_prev = prev_level[0];

	            m_graph.append_edge_attr(graph, subs_main_opaque, subs_main,
	                                     slink_depth_o);
	            m_graph.append_edge_attr(graph, subs_prev, subs_main, slink_color_o);
	        }
	        if (subs_grass_map) {
	            m_graph.append_edge_attr(graph, subs_grass_map, subs_main,
	                    slink_grass_map_d);
	            m_graph.append_edge_attr(graph, subs_grass_map, subs_main,
	                    slink_grass_map_c);
	        }

	        for (var i = 0; i < shadow_subscenes.length; i++) {
	            var subs_shadow = shadow_subscenes[i];
	            var slink_shadow = shadow_links[i];

	            m_graph.append_edge_attr(graph, subs_shadow, subs_main, slink_shadow);
	        }

	        if (subs_depth_pack)
	            m_graph.append_edge_attr(graph, subs_depth_pack, subs_main,
	                    slink_depth_pack_out);

	        if (reflect_subscenes.length) {
	            var num_refl_subs = reflect_subscenes.length;
	            for (var i = 0; i < num_refl_subs; i++)
	                m_graph.append_edge_attr(graph, reflect_subscenes[i],
	                        subs_main, reflect_links[i]);
	        }
	        if (cube_refl_subscenes.length) {
	            for (var i = 0; i < cube_refl_subscenes.length; i++) {
	                m_graph.append_edge_attr(graph, cube_refl_subscenes[i], subs_main,
	                        cube_reflect_links[i]);
	            }
	        }

	        if (subs_refr)
	            m_graph.append_edge_attr(graph, subs_refr, subs_main, slink_refr);

	        return subs_main;
	    };

	    if (sc_render.glow_over_blend) {
	        var subs_main_blend = create_custom_sub_main(m_subs.MAIN_BLEND);
	        curr_level.push(subs_main_blend);

	        prev_level = curr_level;
	        curr_level = [];
	    }

	    // main glow
	    if (sc_render.glow_materials) {
	        var cam_glow = m_cam.clone_camera(main_cam, true);
	        cam_scene_data.cameras.push(cam_glow);

	        var subs_main_glow = m_subs.create_subs_main(m_subs.MAIN_GLOW, cam_glow, false, water_params,
	                num_lights, wfs_params, wls_params);
	        m_graph.append_node_attr(graph, subs_main_glow);

	        // link some uniforms likewise for the MAIN_OPAQUE subscene
	        if (subs_depth_pack)
	            m_graph.append_edge_attr(graph, subs_depth_pack, subs_main_glow,
	                    slink_depth_pack_out);
	        if (subs_refr)
	            m_graph.append_edge_attr(graph, subs_refr, subs_main_glow, slink_refr);

	        if (subs_grass_map) {
	            m_graph.append_edge_attr(graph, subs_grass_map, subs_main_glow,
	                    slink_grass_map_d);
	            m_graph.append_edge_attr(graph, subs_grass_map, subs_main_glow,
	                    slink_grass_map_c);
	        }

	        if (reflect_subscenes.length) {
	            var num_refl_subs = reflect_subscenes.length;
	            for (var j = 0; j < num_refl_subs; j++) {
	                m_graph.append_edge_attr(graph,
	                                         reflect_subscenes[j], subs_main_glow,
	                                         reflect_links[j]);
	            }
	        }

	        if (cube_refl_subscenes.length) {
	            for (var j = 0; j < cube_refl_subscenes.length; j++) {
	                m_graph.append_edge_attr(graph, cube_refl_subscenes[j], subs_main_glow,
	                        cube_reflect_links[j]);
	            }
	        }

	        if (sc_render.glow_over_blend) {
	            // create fake link in order glow to render before blend
	            m_graph.append_edge_attr(graph, subs_main_glow, subs_main_blend,
	                    create_slink("SCREEN", "NONE", 0, 0, 0, false, false));
	        }

	        m_graph.append_edge_attr(graph, msaa ? subs_res_opaque : subs_main_opaque,
	                subs_main_glow, msaa ? slink_depth_resolve_o : slink_depth_o);
	        var blur_x = m_subs.create_subs_postprocessing("X_GLOW_BLUR");
	        blur_x.subtype = "GLOW_MASK_SMALL";
	        set_texel_size_mult(blur_x, sc_render.glow_params.small_glow_mask_width);
	        var slink_blur_x = create_slink("COLOR", "u_color", 1, 1, 1, true, true);
	        slink_blur_x.min_filter = m_tex.TF_LINEAR;
	        slink_blur_x.mag_filter = m_tex.TF_LINEAR;
	        m_graph.append_node_attr(graph, blur_x);
	        m_graph.append_edge_attr(graph, subs_main_glow, blur_x, slink_blur_x);

	        var blur_y = m_subs.create_subs_postprocessing("Y_GLOW_BLUR");
	        blur_y.subtype = "GLOW_MASK_SMALL";
	        set_texel_size_mult(blur_y, sc_render.glow_params.small_glow_mask_width);
	        var slink_blur_y = create_slink("COLOR", "u_color", 1, 0.5, 0.5, true, true);
	        slink_blur_y.min_filter = m_tex.TF_LINEAR;
	        slink_blur_y.mag_filter = m_tex.TF_LINEAR;
	        m_graph.append_node_attr(graph, blur_y);
	        m_graph.append_edge_attr(graph, blur_x, blur_y, slink_blur_y);

	        var blur_x2 = m_subs.create_subs_postprocessing("X_GLOW_BLUR");
	        blur_x2.subtype = "GLOW_MASK_LARGE";
	        set_texel_size_mult(blur_x2, sc_render.glow_params.large_glow_mask_width);
	        var slink_blur_x2 = create_slink("COLOR", "u_color", 1, 0.5, 0.5, true, true);
	        slink_blur_x2.min_filter = m_tex.TF_LINEAR;
	        slink_blur_x2.mag_filter = m_tex.TF_LINEAR;
	        m_graph.append_node_attr(graph, blur_x2);
	        m_graph.append_edge_attr(graph, blur_y, blur_x2, slink_blur_x2);

	        var blur_y2 = m_subs.create_subs_postprocessing("Y_GLOW_BLUR");
	        blur_y2.subtype = "GLOW_MASK_LARGE";
	        set_texel_size_mult(blur_y2, sc_render.glow_params.large_glow_mask_width);
	        var slink_blur_y2 = create_slink("COLOR", "u_color", 1, 0.25, 0.25, true, true);
	        slink_blur_y2.min_filter = m_tex.TF_LINEAR;
	        slink_blur_y2.mag_filter = m_tex.TF_LINEAR;
	        m_graph.append_node_attr(graph, blur_y2);
	        m_graph.append_edge_attr(graph, blur_x2, blur_y2, slink_blur_y2);

	        var cam_glow_combine = m_cam.clone_camera(main_cam, true);
	        cam_scene_data.cameras.push(cam_glow_combine);
	        var subs_glow_combine = m_subs.create_subs_glow_combine(cam_glow_combine, sc_render);

	        m_graph.append_node_attr(graph, subs_glow_combine);

	        var slink_c_src = create_slink("COLOR", "u_src_color", 1, 1, 1, true, true);
	        slink_c_src.min_filter = m_tex.TF_LINEAR;
	        slink_c_src.mag_filter = m_tex.TF_LINEAR;

	        if (sc_render.glow_over_blend) {
	            if (msaa) {
	                // NOTE: redundant resolve, place the scene below debug_view or so
	                var subs_res_blend = m_subs.create_subs_resolve();
	                m_graph.append_node_attr(graph, subs_res_blend);

	                m_graph.append_edge_attr(graph, subs_main_blend, subs_res_blend,
	                        slink_resolve_in_c);
	                m_graph.append_edge_attr(graph, subs_main_blend, subs_res_blend,
	                        slink_resolve_in_d);
	                m_graph.append_edge_attr(graph, subs_res_blend, subs_glow_combine, slink_c_src);
	            } else
	                m_graph.append_edge_attr(graph, subs_main_blend,
	                        subs_glow_combine, slink_c_src);
	        } else
	            m_graph.append_edge_attr(graph, msaa ? subs_res_opaque : subs_main_opaque,
	                    subs_glow_combine, slink_c_src);

	        var slink_c_y = create_slink("COLOR", "u_glow_mask_small", 1, 0.5, 0.5, true, true);
	        slink_c_y.min_filter = m_tex.TF_LINEAR;
	        slink_c_y.mag_filter = m_tex.TF_LINEAR;
	        m_graph.append_edge_attr(graph, blur_y, subs_glow_combine, slink_c_y);

	        var slink_c_y2 = create_slink("COLOR", "u_glow_mask_large", 1, 0.25, 0.25, true, true);
	        slink_c_y2.min_filter = m_tex.TF_LINEAR;
	        slink_c_y2.mag_filter = m_tex.TF_LINEAR;
	        m_graph.append_edge_attr(graph, blur_y2, subs_glow_combine, slink_c_y2);

	        prev_level = [subs_glow_combine];
	        curr_level = [];
	    }

	    if (!sc_render.glow_over_blend) {
	        var subs_main_blend = create_custom_sub_main(m_subs.MAIN_BLEND);
	        curr_level.push(subs_main_blend);

	        prev_level = curr_level;
	        curr_level = [];
	    }

	    // debug view stuff: wireframe, clustering
	    if (cfg_def.debug_view) {
	        var cam = m_cam.clone_camera(main_cam, true);
	        cam_scene_data.cameras.push(cam);

	        var subs_debug_view = m_subs.create_subs_debug_view(cam);
	        curr_level.push(subs_debug_view);
	        m_graph.append_node_attr(graph, subs_debug_view);
	        m_graph.append_edge_attr(graph, prev_level[0], subs_debug_view,
	                slink_color_o);
	        m_graph.append_edge_attr(graph, prev_level[0], subs_debug_view,
	                slink_depth_o);

	        if (subs_grass_map) {
	            m_graph.append_edge_attr(graph, subs_grass_map, subs_debug_view,
	                    slink_grass_map_d);
	            m_graph.append_edge_attr(graph, subs_grass_map, subs_debug_view,
	                    slink_grass_map_c);
	        }

	        m_debug.set_debug_view_subs(subs_debug_view);

	        prev_level = curr_level;
	        curr_level = [];
	    }

	    if (msaa) {
	        var subs_res_geom = m_subs.create_subs_resolve();
	        m_graph.append_node_attr(graph, subs_res_geom);
	        curr_level.push(subs_res_geom);

	        m_graph.append_edge_attr(graph, prev_level[0], subs_res_geom, slink_resolve_in_c);
	        m_graph.append_edge_attr(graph, prev_level[0], subs_res_geom, slink_resolve_in_d);

	        prev_level = curr_level;
	        curr_level = [];
	    }

	    // last level of geometry rendering
	    var last_geom_level = prev_level.slice(0);

	    // prepare anchor visibility subscene
	    if (!rtt && sc_render.anchor_visibility) {
	        var cam = m_cam.clone_camera(main_cam, true);
	        cam_scene_data.cameras.push(cam);

	        // NOTE: possible bugs due to texture reuse
	        var subs_anchor = m_subs.create_subs_anchor_visibility(cam);
	        m_graph.append_node_attr(graph, subs_anchor);

	        m_graph.append_edge_attr(graph, prev_level[0], subs_anchor,
	                msaa ? slink_depth_resolve_o : slink_depth_o);
	    }

	    // god rays stuff
	    if (god_rays && depth_tex && !rtt) {
	        var max_ray_length = gr_params.max_ray_length;
	        var intensity      = gr_params.intensity;
	        var steps_per_pass = gr_params.steps_per_pass;

	        var subs_prev = prev_level[0];
	        var water = water_params ? true : false;

	        var slink_gr_d = create_slink("DEPTH", "u_input", 1, 1, 1, true, true);
	        var slink_gr_c = create_slink("COLOR", "u_input", 1, 0.25, 0.25, true, true);
	        slink_gr_c.min_filter = m_tex.TF_LINEAR;
	        slink_gr_c.mag_filter = m_tex.TF_LINEAR;

	        // 1-st pass
	        var step = max_ray_length / steps_per_pass;
	        var cam_god_rays = m_cam.clone_camera(main_cam, true);
	        cam_scene_data.cameras.push(cam_god_rays);
	        var subs_god_rays = m_subs.create_subs_god_rays(cam_god_rays,
	                            water, max_ray_length, true, step, num_lights,
	                            steps_per_pass);
	        m_graph.append_node_attr(graph, subs_god_rays);
	        m_graph.append_edge_attr(graph, subs_prev, subs_god_rays, slink_gr_d);

	        // 2-nd pass
	        step = max_ray_length / steps_per_pass * 0.5;
	        var cam_blur1 = m_cam.clone_camera(main_cam, true);
	        cam_scene_data.cameras.push(cam_blur1);
	        var subs_gr_blur1 = m_subs.create_subs_god_rays(cam_blur1,
	                            water, max_ray_length, false, step, num_lights,
	                            steps_per_pass);
	        m_graph.append_node_attr(graph, subs_gr_blur1);
	        m_graph.append_edge_attr(graph, subs_god_rays, subs_gr_blur1, slink_gr_c);

	        // 3-d pass
	        step = max_ray_length / steps_per_pass * 0.25;
	        var cam_blur2 = m_cam.clone_camera(main_cam, true);
	        cam_scene_data.cameras.push(cam_blur2);
	        var subs_gr_blur2 = m_subs.create_subs_god_rays(cam_blur2,
	                            water, max_ray_length, false, step, num_lights,
	                            steps_per_pass);
	        m_graph.append_node_attr(graph, subs_gr_blur2);
	        m_graph.append_edge_attr(graph, subs_gr_blur1, subs_gr_blur2, slink_gr_c);

	        // combine with main scene
	        var subs_god_rays_comb = m_subs.create_subs_god_rays_comb(intensity,
	                                                           num_lights);
	        curr_level.push(subs_god_rays_comb);
	        m_graph.append_node_attr(graph, subs_god_rays_comb);
	        var slink_prev = create_slink("COLOR", "u_main", 1, 1, 1, true, true);
	        slink_prev.min_filter = m_tex.TF_LINEAR;
	        slink_prev.mag_filter = m_tex.TF_LINEAR;
	        m_graph.append_edge_attr(graph, subs_prev, subs_god_rays_comb, slink_prev);
	        var slink_blur2 = create_slink("COLOR", "u_god_rays", 1, 1, 1, true, true);
	        slink_blur2.min_filter = m_tex.TF_LINEAR;
	        slink_blur2.mag_filter = m_tex.TF_LINEAR;
	        m_graph.append_edge_attr(graph, subs_gr_blur2, subs_god_rays_comb,
	                slink_blur2);

	        prev_level = curr_level;
	        curr_level = [];
	    }

	    // bloom
	    if (bloom_params && !rtt) {
	        var subs_prev = prev_level[0];

	        var subs_luminance = m_subs.create_subs_luminance();
	        m_graph.append_node_attr(graph, subs_luminance);
	        var slink_prev = create_slink("COLOR", "u_input", 1, 1, 1, true, true);
	        slink_prev.min_filter = m_tex.TF_LINEAR;
	        slink_prev.mag_filter = m_tex.TF_LINEAR;
	        m_graph.append_edge_attr(graph, subs_prev, subs_luminance, slink_prev);

	        var bloom_key = bloom_params.key;
	        var edge_lum  = bloom_params.edge_lum;

	        var cam_luminance = m_cam.clone_camera(main_cam, true);
	        cam_scene_data.cameras.push(cam_luminance);
	        var subs_lum_trunced = m_subs.create_subs_luminance_truncated(bloom_key,
	                                     edge_lum, num_lights, cam_luminance);
	        m_graph.append_node_attr(graph, subs_lum_trunced);
	        var slink_luminance_tr = create_slink("COLOR", "u_luminance", 1, 0.25, 0.25, true, true);
	            slink_luminance_tr.min_filter = m_tex.TF_LINEAR;
	            slink_luminance_tr.mag_filter = m_tex.TF_LINEAR;

	        if (bloom_params.adaptive) {
	            var subs_av_luminance = m_subs.create_subs_av_luminance();
	            m_graph.append_node_attr(graph, subs_av_luminance);

	            // NOTE: deprecated
	            subs_av_luminance.camera.width = 1;
	            subs_av_luminance.camera.height = 1;

	            var slink_luminance_av = create_slink("COLOR", "u_input", 1, 0.25, 0.25, true, true);
	            slink_luminance_av.use_mipmap = true;
	            slink_luminance_av.min_filter = m_tex.TF_LINEAR_MIPMAP_LINEAR;
	            slink_luminance_av.mag_filter = m_tex.TF_LINEAR;

	            if (cfg_def.webgl2) {
	                slink_luminance_tr.use_mipmap = true;
	                slink_luminance_tr.min_filter = m_tex.TF_LINEAR_MIPMAP_LINEAR;
	                m_graph.append_edge_attr(graph, subs_luminance, subs_av_luminance,
	                        slink_luminance_av);
	            } else {
	                var resize_subs = m_subs.create_resize_subs();
	                var slink_resize = create_slink("COLOR", "u_color", 1, 0.25, 0.25, true, true);

	                m_graph.append_node_attr(graph, resize_subs);
	                m_graph.append_edge_attr(graph, subs_luminance, resize_subs,
	                        slink_resize);
	                m_graph.append_edge_attr(graph, resize_subs, subs_av_luminance,
	                        slink_luminance_av);
	            }
	            m_graph.append_edge_attr(graph, subs_av_luminance, subs_lum_trunced,
	                create_slink("COLOR", "u_average_lum", 1, 1, 1, false, false));
	            subs_lum_trunced.adaptive_bloom = true;
	        } else {
	            subs_lum_trunced.adaptive_bloom = false;
	            subs_lum_trunced.average_luminance = bloom_params.average_luminance;
	        }

	        m_graph.append_edge_attr(graph, subs_prev, subs_lum_trunced,
	                create_slink("COLOR", "u_main", 1, 1, 1, true, true));
	        m_graph.append_edge_attr(graph, subs_luminance, subs_lum_trunced,
	                slink_luminance_tr);
	        
	        var last_subs = subs_lum_trunced;
	        var subs_size = 1;
	        var blur_y_subs_array = [];
	        var blur_pass_number = BLOOM_BLUR_SAMPLES;
	        for (var i = 0; i < blur_pass_number; i++) {
	            var blur_x = m_subs.create_subs_postprocessing("X_BLOOM_BLUR");
	            set_texel_size_mult(blur_x, sc_render.glow_params.small_glow_mask_width);
	            var slink_blur_x = create_slink("COLOR", "u_color", 1, subs_size, subs_size, true, true);
	            slink_blur_x.min_filter = m_tex.TF_LINEAR;
	            slink_blur_x.mag_filter = m_tex.TF_LINEAR;
	            m_graph.append_node_attr(graph, blur_x);
	            m_graph.append_edge_attr(graph, last_subs, blur_x, slink_blur_x);

	            subs_size /= 2;

	            var blur_y = m_subs.create_subs_postprocessing("Y_BLOOM_BLUR");
	            set_texel_size_mult(blur_y, sc_render.glow_params.small_glow_mask_width);
	            var slink_blur_y = create_slink("COLOR", "u_color", 1, subs_size, subs_size, true, true);
	            slink_blur_y.min_filter = m_tex.TF_LINEAR;
	            slink_blur_y.mag_filter = m_tex.TF_LINEAR;
	            m_graph.append_node_attr(graph, blur_y);
	            m_graph.append_edge_attr(graph, blur_x, blur_y, slink_blur_y);
	            last_subs = blur_y;

	            blur_y.bloom_blur_scale = subs_size;
	            blur_x.bloom_blur_scale = subs_size;
	            blur_y_subs_array.push(blur_y, subs_size);
	        }

	        var bloom_blur = bloom_params.blur;
	        var subs_bloom_combine = m_subs.create_subs_bloom_combine(bloom_blur, blur_pass_number);
	        m_graph.append_node_attr(graph, subs_bloom_combine);

	        for (var i = 0; i < blur_y_subs_array.length; i+=2) {
	            var blur_y = blur_y_subs_array[i];
	            var slink_size = blur_y_subs_array[i + 1];
	            var slink_c_y = create_slink("COLOR", "u_bloom_level_" + (i / 2).toString(),
	                    1, slink_size, slink_size, true, true);
	            slink_c_y.min_filter = m_tex.TF_LINEAR;
	            slink_c_y.mag_filter = m_tex.TF_LINEAR;
	            m_graph.append_edge_attr(graph, blur_y, subs_bloom_combine, slink_c_y);
	        }

	        m_graph.append_edge_attr(graph, subs_prev, subs_bloom_combine,
	                create_slink("COLOR", "u_main", 1, 1, 1, true, true));

	        curr_level.push(subs_bloom_combine);
	        prev_level = curr_level;
	        curr_level = [];
	    }

	    // depth of field stuff
	    if (dof && depth_tex && !rtt) {
	        var subs_prev = prev_level[0];
	        var cam_dof = m_cam.clone_camera(main_cam, true);
	        cam_scene_data.cameras.push(cam_dof);

	        if (cam_render.dof_bokeh) {
	            var slink_coc_in = create_slink("COLOR", "u_color", 1, 1, 1, true, true);
	            slink_coc_in.min_filter = m_tex.TF_LINEAR;
	            slink_coc_in.mag_filter = m_tex.TF_LINEAR;

	            var slink_coc_depth_in = create_slink("DEPTH", "u_depth", 1, 1, 1, true, true);

	            var slink_coc_out = create_slink("COLOR", "u_color", 1, 0.5, 0.5, true, true);
	            slink_coc_out.min_filter = m_tex.TF_NEAREST;
	            slink_coc_out.mag_filter = m_tex.TF_NEAREST;

	            // CHECK: is it right a texture filtering?
	            var slink_blur_in = create_slink("COLOR", "u_color", 1, 0.5, 0.5, true, true);
	            slink_blur_in.min_filter = m_tex.TF_NEAREST;
	            slink_blur_in.mag_filter = m_tex.TF_NEAREST;

	            var slink_dof_blurred_in1 = create_slink("COLOR", "u_blurred1", 1, 0.5, 0.5, true, true);
	            slink_dof_blurred_in1.min_filter = m_tex.TF_LINEAR;
	            slink_dof_blurred_in1.mag_filter = m_tex.TF_LINEAR;

	            var slink_dof_blurred_in2 = create_slink("COLOR", "u_blurred2", 1, 0.5, 0.5, true, true);
	            slink_dof_blurred_in2.min_filter = m_tex.TF_LINEAR;
	            slink_dof_blurred_in2.mag_filter = m_tex.TF_LINEAR;

	            var subs_coc_in = last_geom_level[0];
	            if (cam_render.dof_foreground_blur) {
	                var cam_coc_fg = m_cam.clone_camera(main_cam, true);
	                    cam_scene_data.cameras.push(cam_coc_fg);
	                var coc_fg = m_subs.create_subs_coc(cam_coc_fg, "COC_FOREGROUND");
	                cam_coc_fg.dof_distance = cam_render.dof_distance;
	                cam_coc_fg.dof_object = cam_render.dof_object;
	                cam_coc_fg.dof_front_start = cam_render.dof_front_start;
	                cam_coc_fg.dof_front_end = cam_render.dof_front_end;
	                cam_coc_fg.dof_rear_start = cam_render.dof_rear_start;
	                cam_coc_fg.dof_rear_end = cam_render.dof_rear_end;
	                cam_coc_fg.dof_power = cam_render.dof_power;
	                cam_coc_fg.dof_bokeh = cam_render.dof_bokeh;
	                cam_coc_fg.dof_bokeh_intensity = cam_render.dof_bokeh_intensity;
	                cam_coc_fg.dof_foreground_blur = cam_render.dof_foreground_blur;
	                cam_coc_fg.dof_on = true;
	                m_graph.append_node_attr(graph, coc_fg);
	                m_graph.append_edge_attr(graph, subs_prev, coc_fg, slink_coc_in);
	                m_graph.append_edge_attr(graph, subs_coc_in, coc_fg, slink_coc_depth_in);

	                var pp_alpha_x = m_subs.create_subs_postprocessing("X_ALPHA_BLUR");
	                m_graph.append_node_attr(graph, pp_alpha_x);
	                m_graph.append_edge_attr(graph, coc_fg, pp_alpha_x, slink_coc_out);

	                var pp_alpha_y = m_subs.create_subs_postprocessing("Y_ALPHA_BLUR");
	                m_graph.append_node_attr(graph, pp_alpha_y);
	                m_graph.append_edge_attr(graph, pp_alpha_x, pp_alpha_y, slink_blur_in);

	                var cam_coc = m_cam.clone_camera(main_cam, true);
	                var coc = m_subs.create_subs_coc(cam_coc, "COC_COMBINE");
	                cam_scene_data.cameras.push(cam_coc);
	                cam_coc.dof_distance = cam_render.dof_distance;
	                cam_coc.dof_object = cam_render.dof_object;
	                cam_coc.dof_front_start = cam_render.dof_front_start;
	                cam_coc.dof_front_end = cam_render.dof_front_end;
	                cam_coc.dof_rear_start = cam_render.dof_rear_start;
	                cam_coc.dof_rear_end = cam_render.dof_rear_end;
	                cam_coc.dof_power = cam_render.dof_power;
	                cam_coc.dof_bokeh = cam_render.dof_bokeh;
	                cam_coc.dof_bokeh_intensity = cam_render.dof_bokeh_intensity;
	                cam_coc.dof_foreground_blur = cam_render.dof_foreground_blur;
	                cam_coc.dof_on = true;
	                m_graph.append_node_attr(graph, coc);
	                m_graph.append_edge_attr(graph, subs_prev, coc, slink_coc_in);
	                m_graph.append_edge_attr(graph, subs_coc_in, coc, slink_coc_depth_in);
	                m_graph.append_edge_attr(graph, pp_alpha_y, coc,
	                    create_slink("COLOR", "u_coc_fg", 1, 0.5, 0.5, true, true));
	            } else {
	                var cam_coc = m_cam.clone_camera(main_cam, true);
	                cam_scene_data.cameras.push(cam_coc);
	                var coc = m_subs.create_subs_coc(cam_coc, "COC_ALL");
	                cam_coc.dof_distance = cam_render.dof_distance;
	                cam_coc.dof_object = cam_render.dof_object;
	                cam_coc.dof_front_start = cam_render.dof_front_start;
	                cam_coc.dof_front_end = cam_render.dof_front_end;
	                cam_coc.dof_rear_start = cam_render.dof_rear_start;
	                cam_coc.dof_rear_end = cam_render.dof_rear_end;
	                cam_coc.dof_power = cam_render.dof_power;
	                cam_coc.dof_bokeh = cam_render.dof_bokeh;
	                cam_coc.dof_bokeh_intensity = cam_render.dof_bokeh_intensity;
	                cam_coc.dof_foreground_blur = cam_render.dof_foreground_blur;
	                cam_coc.dof_on = true;
	                m_graph.append_node_attr(graph, coc);
	                m_graph.append_edge_attr(graph, subs_prev, coc, slink_coc_in);
	                m_graph.append_edge_attr(graph, subs_coc_in, coc, slink_coc_depth_in);
	            }

	            var pp_x = m_subs.create_subs_postprocessing("X_DOF_BLUR");
	            pp_x.camera.dof_bokeh_intensity = cam_render.dof_bokeh_intensity;
	            m_graph.append_node_attr(graph, pp_x);
	            m_graph.append_edge_attr(graph, coc, pp_x, slink_coc_out);

	            var pp_y1 = m_subs.create_subs_postprocessing("Y_DOF_BLUR");
	            pp_y1.camera.dof_bokeh_intensity = cam_render.dof_bokeh_intensity;
	            m_graph.append_node_attr(graph, pp_y1);
	            m_graph.append_edge_attr(graph, pp_x, pp_y1, slink_blur_in);

	            var pp_y2 = m_subs.create_subs_postprocessing("Y_DOF_BLUR");
	            pp_y2.camera.dof_bokeh_intensity = cam_render.dof_bokeh_intensity;
	            m_graph.append_node_attr(graph, pp_y2);
	            m_graph.append_edge_attr(graph, pp_x, pp_y2, slink_blur_in);

	            var subs_dof = m_subs.create_subs_dof(cam_dof);
	            cam_dof.dof_distance = cam_render.dof_distance;
	            cam_dof.dof_object = cam_render.dof_object;
	            cam_dof.dof_front_start = cam_render.dof_front_start;
	            cam_dof.dof_front_end = cam_render.dof_front_end;
	            cam_dof.dof_rear_start = cam_render.dof_rear_start;
	            cam_dof.dof_rear_end = cam_render.dof_rear_end;
	            cam_dof.dof_power = cam_render.dof_power;
	            cam_dof.dof_bokeh = cam_render.dof_bokeh;
	            cam_dof.dof_bokeh_intensity = cam_render.dof_bokeh_intensity;
	            cam_dof.dof_foreground_blur = cam_render.dof_foreground_blur;
	            cam_dof.dof_on = true;
	            curr_level.push(subs_dof);

	            m_graph.append_node_attr(graph, subs_dof);
	            m_graph.append_edge_attr(graph, subs_prev, subs_dof,
	                    create_slink("COLOR", "u_sharp", 1, 1, 1, true, true));
	            m_graph.append_edge_attr(graph, pp_y1, subs_dof, slink_dof_blurred_in1);
	            m_graph.append_edge_attr(graph, pp_y2, subs_dof, slink_dof_blurred_in2);

	        } else {

	            var slink_blur_x_in = create_slink("COLOR", "u_color", 1, 1, 1, true, true);
	            slink_blur_x_in.min_filter = m_tex.TF_LINEAR;
	            slink_blur_x_in.mag_filter = m_tex.TF_LINEAR;

	            var slink_blur_y_in = create_slink("COLOR", "u_color", 1, 1, 1, true, true);
	            slink_blur_y_in.min_filter = m_tex.TF_LINEAR;
	            slink_blur_y_in.mag_filter = m_tex.TF_LINEAR;

	            var pp_x = m_subs.create_subs_postprocessing("X_BLUR");
	            m_graph.append_node_attr(graph, pp_x);
	            m_graph.append_edge_attr(graph, subs_prev, pp_x, slink_blur_x_in);

	            var pp_y = m_subs.create_subs_postprocessing("Y_BLUR");
	            m_graph.append_node_attr(graph, pp_y);
	            m_graph.append_edge_attr(graph, pp_x, pp_y, slink_blur_y_in);

	            var subs_dof_in = last_geom_level[0];
	            var subs_dof = m_subs.create_subs_dof(cam_dof);
	            cam_dof.dof_distance = cam_render.dof_distance;
	            cam_dof.dof_object = cam_render.dof_object;
	            cam_dof.dof_front_start = cam_render.dof_front_start;
	            cam_dof.dof_front_end = cam_render.dof_front_end;
	            cam_dof.dof_rear_start = cam_render.dof_rear_start;
	            cam_dof.dof_rear_end = cam_render.dof_rear_end;
	            cam_dof.dof_power = cam_render.dof_power;
	            cam_dof.dof_bokeh = cam_render.dof_bokeh;
	            cam_dof.dof_bokeh_intensity = cam_render.dof_bokeh_intensity;
	            cam_dof.dof_foreground_blur = cam_render.dof_foreground_blur;
	            cam_dof.dof_on = true;
	            curr_level.push(subs_dof);

	            m_graph.append_node_attr(graph, subs_dof);
	            m_graph.append_edge_attr(graph, subs_prev, subs_dof,
	                    create_slink("COLOR", "u_sharp", 1, 1, 1, true, true));
	            m_graph.append_edge_attr(graph, pp_y, subs_dof,
	                    create_slink("COLOR", "u_blurred", 1, 1, 1, true, true));
	            m_graph.append_edge_attr(graph, subs_dof_in, subs_dof,
	                    create_slink("DEPTH", "u_depth", 1, 1, 1, true, true));
	        }

	        prev_level = curr_level;
	        curr_level = [];
	    }

	    // objects which are rendered above all
	    if (sc_render.xray) {
	        var subs_main_xray = create_custom_sub_main(m_subs.MAIN_XRAY);
	        curr_level.push(subs_main_xray);

	        prev_level = curr_level;
	        curr_level = [];
	    }

	    // motion blur stuff
	    if (motion_blur && !rtt) {

	        var subs_to_blur = prev_level[0];
	        var subs_mb = m_subs.create_subs_motion_blur(mb_params.mb_decay_threshold,
	                mb_params.mb_factor);
	        curr_level.push(subs_mb);

	        m_graph.append_node_attr(graph, subs_mb);

	        var slink_mb_in = create_slink("COLOR", "u_mb_tex_curr", 1, 1, 1, true, true);
	        m_graph.append_edge_attr(graph, subs_to_blur, subs_mb, slink_mb_in);

	        var slink_mb_accum = create_slink("COLOR", "u_mb_tex_accum", 1, 1, 1, true, true);
	        subs_mb.slinks_internal.push(slink_mb_accum);

	        prev_level = curr_level;
	        curr_level = [];
	    }

	    // outline_mask
	    if (!rtt && sc_render.outline) {
	        var subs_prev = prev_level[0];

	        var cam_outline = m_cam.clone_camera(main_cam, true);
	        cam_scene_data.cameras.push(cam_outline);

	        var subs_outline_mask = m_subs.create_subs_outline_mask(cam_outline, num_lights);
	        m_graph.append_node_attr(graph, subs_outline_mask);

	        var pp_x_ext = m_subs.create_subs_postprocessing("X_EXTEND");

	        // almost the same
	        var slink_mask_pp = create_slink("COLOR", "u_color", 1, 1, 1, true, true);
	        var slink_mask_gl = create_slink("COLOR", "u_outline_mask", 1, 1, 1, true, true);
	        slink_mask_gl.min_filter = m_tex.TF_LINEAR;
	        slink_mask_gl.mag_filter = m_tex.TF_LINEAR;

	        pp_x_ext.is_for_outline = true;
	        m_graph.append_node_attr(graph, pp_x_ext);
	        m_graph.append_edge_attr(graph, subs_outline_mask, pp_x_ext,
	                slink_mask_pp);

	        var slink_ext = create_slink("COLOR", "u_color", 1, 0.5, 0.5, true, true);
	        slink_ext.min_filter = m_tex.TF_LINEAR;
	        slink_ext.mag_filter = m_tex.TF_LINEAR;

	        var pp_y_ext = m_subs.create_subs_postprocessing("Y_EXTEND");
	        pp_y_ext.is_for_outline = true;
	        m_graph.append_node_attr(graph, pp_y_ext);
	        m_graph.append_edge_attr(graph, pp_x_ext, pp_y_ext, slink_ext);

	        var pp_x = m_subs.create_subs_postprocessing("X_BLUR");
	        pp_x.is_for_outline = true;
	        m_graph.append_node_attr(graph, pp_x);
	        m_graph.append_edge_attr(graph, pp_y_ext, pp_x, slink_ext);

	        // almost the same
	        var slink_blur_blur = create_slink("COLOR", "u_color", 1, 0.25, 0.25, true, true);
	        slink_blur_blur.min_filter = m_tex.TF_LINEAR;
	        slink_blur_blur.mag_filter = m_tex.TF_LINEAR;
	        var slink_blur_outline = create_slink("COLOR", "u_outline_mask_blurred", 1, 0.25, 0.25, true, true);
	        slink_blur_outline.min_filter = m_tex.TF_LINEAR;
	        slink_blur_outline.mag_filter = m_tex.TF_LINEAR;

	        var pp_y = m_subs.create_subs_postprocessing("Y_BLUR");
	        pp_y.is_for_outline = true;
	        m_graph.append_node_attr(graph, pp_y);
	        m_graph.append_edge_attr(graph, pp_x, pp_y, slink_blur_blur);

	        var subs_outline = m_subs.create_subs_outline(outline_params);
	        m_graph.append_node_attr(graph, subs_outline);

	        var slink_src = create_slink("COLOR", "u_outline_src", 1, 1, 1, true, true);
	        slink_src.min_filter = m_tex.TF_LINEAR;
	        slink_src.mag_filter = m_tex.TF_LINEAR;
	        m_graph.append_edge_attr(graph, subs_prev, subs_outline,slink_src);

	        m_graph.append_edge_attr(graph, subs_outline_mask, subs_outline,
	                slink_mask_gl);
	        m_graph.append_edge_attr(graph, pp_y, subs_outline, slink_blur_outline);

	        curr_level.push(subs_outline);

	        prev_level = curr_level;
	        curr_level = [];
	    }

	    enforce_slink_uniqueness(graph, depth_tex);
	    if ((sc_render.anaglyph_use || sc_render.hmd_stereo_use || sc_render.sidebyside_use) && !rtt) {
	        var subs_stereo = make_stereo(graph, sc_render, cam_scene_data, prev_level[0]);
	        curr_level.push(subs_stereo);

	        prev_level = curr_level;
	        curr_level = [];
	    }

	    // compositing
	    if (compositing && !rtt) {

	        var subs_prev = prev_level[0];

	        var brightness = cc_params.brightness;
	        var contrast   = cc_params.contrast;
	        var exposure   = cc_params.exposure;
	        var saturation = cc_params.saturation;

	        var subs_compositing = m_subs.create_subs_compositing(brightness, contrast,
	                                                      exposure, saturation);

	        var slink_compositing = create_slink("COLOR", "u_color", 1, 1, 1, true, true);
	        slink_compositing.min_filter = m_tex.TF_LINEAR;
	        slink_compositing.mag_filter = m_tex.TF_LINEAR;
	        // HACK: fix texture reusage in case of splitscreen
	        if ((sc_render.anaglyph_use || sc_render.hmd_stereo_use || sc_render.sidebyside_use) && !rtt)
	            slink_compositing.unique_texture = true;
	        m_graph.append_node_attr(graph, subs_compositing);
	        m_graph.append_edge_attr(graph, subs_prev, subs_compositing,
	                slink_compositing);

	        curr_level.push(subs_compositing);

	        prev_level = curr_level;
	        curr_level = [];
	    }

	    // special precautions needed to prevent subscenes with through-going
	    // attachments from on-screen or RTT (!!!) rendering
	    // NOTE: it's not possible to resolve (blit) directly on screen framebuffer
	    // NOTE: may be a Chromium bug
	    // var prev_id = m_graph.node_by_attr(graph, prev_level[0]);
	    // if (prev_level[0].type == m_subs.MOTION_BLUR ||
	    //         prev_level[0].type == m_subs.RESOLVE)
	    //     var need_subs_pp_copy = true;
	    // else {
	    //     var need_subs_pp_copy = false;
	    //     m_graph.traverse_inputs(graph, prev_id, function(id_in, attr_in,
	    //             attr_edge) {
	    //         var slink_in = attr_edge;
	    //         if (slink_in.from == slink_in.to) {
	    //             need_subs_pp_copy = true;
	    //             return true;
	    //         }
	    //     });
	    // }

	    // downscaling postprocessing subscene
	    var need_subs_pp_copy = !prev_level[0].is_pp ||
	            prev_level[0].type == m_subs.MOTION_BLUR ||
	            prev_level[0].type == m_subs.RESOLVE;

	    if (need_subs_pp_copy) {
	        var subs_pp_copy = m_subs.create_subs_postprocessing("NONE");
	        m_graph.append_node_attr(graph, subs_pp_copy);
	        var slink_pp = create_slink("COLOR", "u_color", 1, 1, 1, true, true);
	        slink_pp.min_filter = m_tex.TF_LINEAR;
	        slink_pp.mag_filter = m_tex.TF_LINEAR;
	        m_graph.append_edge_attr(graph, prev_level[0], subs_pp_copy, slink_pp);

	        curr_level.push(subs_pp_copy);
	        prev_level = curr_level;
	        curr_level = [];
	    }

	    // antialiasing stuff
	    if (antialiasing) {
	        var subs_prev = prev_level[0];

	        if (cfg_def.smaa) {

	            var slink_smaa_in = create_slink("COLOR", "u_color",
	                                             1, 1, 1, true, false);
	            slink_smaa_in.min_filter = m_tex.TF_LINEAR;
	            slink_smaa_in.mag_filter = m_tex.TF_LINEAR;

	            // NOTE: temoporary disabled T2X mode due to artifacts with blend objects
	            //if (!m_cfg.context.alpha) {

	            //    var depth_subs = find_upper_subs(graph, subs_prev, "DEPTH");

	            //    // velocity buffer
	            //    var cam_velocity = m_cam.clone_camera(main_cam, true);
	            //    cam_scene_data.cameras.push(cam_velocity);

	            //    var subs_velocity = m_subs.create_subs_veloctity(cam_velocity);
	            //    var slink_velocity_in = create_slink("DEPTH", "u_depth",
	            //                                     1, 1, 1, true, false);
	            //    slink_velocity_in.min_filter = m_tex.TF_NEAREST;
	            //    slink_velocity_in.mag_filter = m_tex.TF_NEAREST;

	            //    m_graph.append_node_attr(graph, subs_velocity);
	            //    m_graph.append_edge_attr(graph, depth_subs, subs_velocity,
	            //                             slink_velocity_in);

	            //    var slink_velocity_smaa = create_slink("COLOR", "u_velocity_tex",
	            //                                     1, 1, 1, true, false);
	            //}

	            // 1-st pass - edge detection
	            var subs_smaa_1 = m_subs.create_subs_smaa(m_subs.SMAA_EDGE_DETECTION, sc_render);
	            m_graph.append_node_attr(graph, subs_smaa_1);

	            m_graph.append_edge_attr(graph, subs_prev, subs_smaa_1,
	                                     slink_smaa_in);

	            // 2-nd pass - blending weight calculation
	            var subs_smaa_2 = m_subs.create_subs_smaa(m_subs.SMAA_BLENDING_WEIGHT_CALCULATION, sc_render);
	            m_graph.append_node_attr(graph, subs_smaa_2);
	            m_graph.append_edge_attr(graph, subs_smaa_1, subs_smaa_2,
	                                     slink_smaa_in);

	            var slink_search_tex = create_slink("COLOR", "u_search_tex",
	                                                1, 1, 1, false, false);
	            var slink_area_tex = create_slink("COLOR", "u_area_tex",
	                                                1, 1, 1, false, false);

	            slink_search_tex.min_filter = m_tex.TF_LINEAR;
	            slink_search_tex.mag_filter = m_tex.TF_LINEAR;
	            slink_area_tex.min_filter   = m_tex.TF_LINEAR;
	            slink_area_tex.mag_filter   = m_tex.TF_LINEAR;
	            subs_smaa_2.slinks_internal.push(slink_search_tex);
	            subs_smaa_2.slinks_internal.push(slink_area_tex);

	            // 3-rd pass - neighborhood blending
	            var subs_smaa_3 = m_subs.create_subs_smaa(m_subs.SMAA_NEIGHBORHOOD_BLENDING, sc_render);
	            m_graph.append_node_attr(graph, subs_smaa_3);

	            m_graph.append_edge_attr(graph, subs_prev,
	                                     subs_smaa_3, slink_smaa_in);

	            var slink_smaa_blend = create_slink("COLOR", "u_blend",
	                                                1, 1, 1, true, false);
	            slink_smaa_blend.min_filter = m_tex.TF_LINEAR;
	            slink_smaa_blend.mag_filter = m_tex.TF_LINEAR;
	            m_graph.append_edge_attr(graph, subs_smaa_2,
	                                     subs_smaa_3, slink_smaa_blend);

	            // 4-th pass - resolve

	            // NOTE: temoporary disabled T2X mode due to artifacts with blend objects
	            //if (!m_cfg.context.alpha) {
	            //    m_graph.append_edge_attr(graph, subs_velocity, subs_smaa_3,
	            //                             slink_velocity_smaa);
	            //    var subs_smaa_r = m_subs.create_subs_smaa(m_subs.SMAA_RESOLVE, sc_render);
	            //    m_graph.append_node_attr(graph, subs_smaa_r);

	            //    m_graph.append_edge_attr(graph, subs_smaa_3, subs_smaa_r,
	            //                             slink_smaa_in);
	            //    m_graph.append_edge_attr(graph, subs_velocity, subs_smaa_r,
	            //                             slink_velocity_smaa);

	            //    var slink_smaa_in_prev = create_slink("COLOR", "u_color_prev",
	            //                                          1, 1, 1, true, false);
	            //    slink_smaa_in_prev.min_filter = m_tex.TF_LINEAR;
	            //    slink_smaa_in_prev.mag_filter = m_tex.TF_LINEAR;

	            //    subs_smaa_r.slinks_internal.push(slink_smaa_in_prev);

	            //    curr_level.push(subs_smaa_r);
	            //} else
	                curr_level.push(subs_smaa_3);

	        } else {
	            var subs_aa = m_subs.create_subs_aa(sc_render);
	            m_graph.append_node_attr(graph, subs_aa);

	            var slink_aa_in = create_slink("COLOR", "u_color", 1, 1, 1, true, false);
	            slink_aa_in.min_filter = m_tex.TF_LINEAR;
	            slink_aa_in.mag_filter = m_tex.TF_LINEAR;

	            // HACK: fix texture reusage in case of splitscreen
	            if ((sc_render.anaglyph_use || sc_render.hmd_stereo_use || sc_render.sidebyside_use) && !rtt)
	                slink_aa_in.unique_texture = true;

	            m_graph.append_edge_attr(graph, subs_prev, subs_aa, slink_aa_in);

	            curr_level.push(subs_aa);
	        }

	        prev_level = curr_level;
	        curr_level = [];
	    }

	    // NOTE: from anaglyph
	    curr_level.push(prev_level[0]);

	    //
	    // filling up the last level
	    //

	    if (subs_color_picking)
	        if (subs_color_picking_xray)
	            curr_level.push(subs_color_picking_xray);
	        else
	            curr_level.push(subs_color_picking);

	    if (subs_anchor)
	        curr_level.push(subs_anchor);

	    // resized dynamically after images loading finished
	    // see m_data.init_cube_sky_dynamic_props
	    var tex_size = 1;
	    if (sc_render.sky_params.render_sky) {
	        var sky_params = sc_render.sky_params;
	        var wls = sc_render.world_light_set;
	        var tex_param = wls.sky_texture_param;
	        tex_size = tex_param ? tex_param.tex_size : tex_size;
	        var subs_sky = m_subs.create_subs_sky(wls, num_lights, sky_params, tex_size);
	        m_graph.append_node_attr(graph, subs_sky);

	        curr_level.push(subs_sky);

	        if (sky_reflect_links.length) {
	            var subs_irradiance = m_subs.create_subs_irradiance(num_lights, tex_size);
	            m_graph.append_node_attr(graph, subs_irradiance);

	            m_graph.append_edge_attr(graph, subs_sky, subs_irradiance, sky_reflect_links[0]);
	            var slink_irradiance = create_slink("CUBEMAP", "u_irradiance",
	                                            sc_render.cubemap_refl_size, 1, 1, false);
	            slink_irradiance.use_mipmap = false;
	            slink_irradiance.min_filter = m_tex.TF_LINEAR;
	            slink_irradiance.mag_filter = m_tex.TF_LINEAR;
	            m_graph.append_edge_attr(graph, subs_irradiance, subs_main_opaque, slink_irradiance);
	            if (subs_main_blend)
	                m_graph.append_edge_attr(graph, subs_irradiance, subs_main_blend, slink_irradiance);
	            if (subs_main_glow)
	                m_graph.append_edge_attr(graph, subs_irradiance, subs_main_glow, slink_irradiance);
	            if (subs_main_xray)
	                m_graph.append_edge_attr(graph, subs_irradiance, subs_main_xray, slink_irradiance);
	            curr_level.push(subs_irradiance);

	            var subs_r_convolution = m_subs.create_subs_rougness_convolution(num_lights);
	            m_graph.append_node_attr(graph, subs_r_convolution);

	            m_graph.append_edge_attr(graph, subs_sky, subs_r_convolution, sky_reflect_links[0]);
	            var slink_r_conv = create_slink("CUBEMAP", "u_cube_r_convolution",
	                                            sc_render.cubemap_refl_size, 1, 1, false);
	            slink_r_conv.use_mipmap = false;
	            slink_r_conv.min_filter = m_tex.TF_LINEAR_MIPMAP_LINEAR;
	            slink_r_conv.mag_filter = m_tex.TF_LINEAR;
	            m_graph.append_edge_attr(graph, subs_r_convolution, subs_main_opaque, slink_r_conv);
	            if (subs_main_blend)
	                m_graph.append_edge_attr(graph, subs_r_convolution, subs_main_blend, slink_r_conv);
	            if (subs_main_glow)
	                m_graph.append_edge_attr(graph, subs_r_convolution, subs_main_glow, slink_r_conv);
	            if (subs_main_xray)
	                m_graph.append_edge_attr(graph, subs_r_convolution, subs_main_xray, slink_r_conv);

	            var subs_brdf = m_subs.create_subs_brdf();
	            m_graph.append_node_attr(graph, subs_brdf);

	            var slink_brdf = create_slink("COLOR", "u_brdf", 512, 1, 1, false);
	            slink_brdf.min_filter = m_tex.TF_LINEAR;
	            slink_brdf.mag_filter = m_tex.TF_LINEAR;
	            m_graph.append_edge_attr(graph, subs_brdf, subs_main_opaque, slink_brdf);
	            if (subs_main_blend)
	                m_graph.append_edge_attr(graph, subs_brdf, subs_main_blend, slink_brdf);
	            if (subs_main_glow)
	                m_graph.append_edge_attr(graph, subs_brdf, subs_main_glow, slink_brdf);
	            if (subs_main_xray)
	                m_graph.append_edge_attr(graph, subs_brdf, subs_main_xray, slink_brdf);
	        }
	    }

	    var subs_sink = m_subs.create_subs_sink();
	    m_graph.append_node_attr(graph, subs_sink);

	    for (var i = 0; i < curr_level.length; i++) {
	        var subs = curr_level[i];
	        switch (subs.type) {
	        case m_subs.COLOR_PICKING:
	        case m_subs.COLOR_PICKING_XRAY:
	            m_graph.append_edge_attr(graph, subs, subs_sink,
	                    create_slink("COLOR", "NONE", 1, 1, 1, is_color_sub_debug, false));
	            m_graph.append_edge_attr(graph, subs, subs_sink,
	                    create_slink("DEPTH", "NONE", 1, 1, 1, is_color_sub_debug, false));
	            break;
	        case m_subs.SKY:
	            var slink_sky = create_slink("CUBEMAP", "u_sky",
	                    tex_size, 1, 1, false);
	            m_graph.append_edge_attr(graph, subs, subs_sink, slink_sky);

	            
	            break;
	        case m_subs.IRRADIANCE:
	            var slink_irradiance_sink = create_slink("CUBEMAP", "u_irradiance",
	                    tex_size, 1, 1, false);
	            slink_irradiance_sink.use_mipmap = true;
	            slink_irradiance_sink.min_filter = m_tex.TF_NEAREST;
	            slink_irradiance_sink.mag_filter = m_tex.TF_NEAREST;
	            m_graph.append_edge_attr(graph, subs_irradiance, subs_sink, slink_irradiance_sink);
	            break;
	        case m_subs.ANCHOR_VISIBILITY:
	            var slink_anchor_color = create_slink("COLOR", "NONE", 1, 1, 1, true, false);
	            m_graph.append_edge_attr(graph, subs, subs_sink, slink_anchor_color);
	            break;
	        default:

	            if (rtt) {
	                var tex0 = render_to_textures[0];

	                var slink_rtt = create_slink("COLOR", "OFFSCREEN", 1, 1, 1, true, true);
	                slink_rtt.texture = tex0;

	                // first one connected directly to SINK
	                m_graph.append_edge_attr(graph, curr_level[i], subs_sink, slink_rtt);

	                for (var j = 1; j < render_to_textures.length; j++) {
	                    var tex = render_to_textures[j];

	                    var subs_scale = m_subs.create_subs_postprocessing("NONE");
	                    m_graph.append_node_attr(graph, subs_scale);

	                    var slink_to_rtt = create_slink("COLOR", "SCALE", 1, 1, 1, true, true);

	                    m_graph.append_edge_attr(graph, curr_level[i], subs_scale,
	                            slink_to_rtt);

	                    // copied textures have smaller size
	                    var size_mult = tex.source_size / tex0.source_size;

	                    slink_rtt = create_slink("COLOR", "OFFSCREEN", 1,
	                            size_mult, size_mult, true, true);
	                    slink_rtt.texture = tex;

	                    m_graph.append_edge_attr(graph, subs_scale, subs_sink, slink_rtt);
	                }
	            } else
	                m_graph.append_edge_attr(graph, curr_level[i], subs_sink,
	                        create_slink("SCREEN", "NONE", 1, 1, 1, true, false));
	            break;
	        }
	    }
	    // remove unconnected opaque resolve node
	    if (subs_res_opaque && !get_outputs(graph, subs_res_opaque).length) {
	        m_graph.remove_node(graph,
	                m_graph.node_by_attr(graph, subs_res_opaque));
	        m_graph.cleanup_loose_edges(graph);
	    }
	    enforce_slink_uniqueness(graph, depth_tex);
	    enforce_graph_consistency(graph, depth_tex);

	    if (cfg_dbg.enabled) {
	        var subs_from = find_debug_subs(graph);
	        if (subs_from)
	            assign_debug_subscene(graph, subs_from);
	    }

	    process_subscene_links(graph);
	    assign_render_targets(graph);

	    if (shadow_params) {
	        m_graph.traverse(graph, function(nid, subs) {
	            if (subs.type == m_subs.SHADOW_RECEIVE ||
	                    subs.type == m_subs.MAIN_BLEND ||
	                    subs.type == m_subs.MAIN_XRAY)
	                prepare_shadow_receive_subs(graph, subs);
	        });
	    }

	    if (!refl_params.has_reflexible) {
	        for (var i = 0; i < cube_reflect_links.length; i++)
	                cube_reflect_links[i].active = false;
	    }

	    return graph;
	};

	function find_debug_subs(graph) {
	    var subs_dbg = null;
	    var subs_num = 0;

	    m_graph.traverse(graph, function(id, attr) {
	        if (attr.type == cfg_dbg.subs_type) {
	            if (subs_num == cfg_dbg.subs_number) {
	                subs_dbg = attr;
	                return true;
	            } else
	                subs_num++;
	        }
	    });

	    return subs_dbg;
	}

	function assign_debug_subscene(graph, subs_to_debug) {

	    var node_to_debug = m_graph.node_by_attr(graph, subs_to_debug);

	    var subs_debug_view = m_subs.create_subs_postprocessing("NONE");
	    var node_debug_view = m_graph.append_node_attr(graph, subs_debug_view);

	    var node_sink = m_graph.get_sink_nodes(graph)[0];

	    m_graph.traverse_edges(graph, function(edge_from, edge_to, edge_attr) {

	        if (edge_to == node_sink) {
	            m_graph.reconnect_edges(graph, edge_from, node_sink, edge_from, node_debug_view);
	        }
	    });

	    var has_multisample = subs_check_multisample(subs_to_debug, graph);

	    m_graph.traverse_edges(graph, function(edge_from, edge_to, edge_attr) {
	        if (edge_from == node_to_debug) {

	            if (has_multisample) {
	                var subs_res_geom = m_subs.create_subs_resolve();
	                m_graph.append_node_attr(graph, subs_res_geom);

	                var slink_resolve_in_c = create_slink("COLOR", "RESOLVE", 1, 1, 1, true, true);
	                slink_resolve_in_c.multisample = true;
	                slink_resolve_in_c.use_renderbuffer = true;
	                var slink_resolve_in_d = create_slink("DEPTH", "RESOLVE", 1, 1, 1, true, true);
	                slink_resolve_in_d.multisample = true;
	                slink_resolve_in_d.use_renderbuffer = true;

	                m_graph.append_edge_attr(graph, subs_to_debug, subs_res_geom, slink_resolve_in_c);
	                m_graph.append_edge_attr(graph, subs_to_debug, subs_res_geom, slink_resolve_in_d);

	                subs_to_debug = subs_res_geom;
	            }

	            m_graph.append_edge_attr(graph, subs_to_debug, subs_debug_view,
	                    create_slink(cfg_dbg.slink_type, "u_color", edge_attr.size,
	                    edge_attr.size_mult_x, edge_attr.size_mult_y,
	                    edge_attr.update_dim, edge_attr.apply_resolution_factors));
	            return true;
	        }
	    });

	    m_graph.append_edge(graph, node_debug_view, node_sink,
	            create_slink("SCREEN", "NONE", 0.5, 0.5, 0.5, true, true));
	}

	function subs_check_multisample(subs, graph) {
	    var has_multisample = false;

	    var node = m_graph.node_by_attr(graph, subs);

	    // node without output edges has not multisampling
	    if (m_graph.out_edge_count(graph, node)) {
	        var node_out = m_graph.get_out_edge(graph, node, 0);
	        var edge_attr = m_graph.get_edge_attr(graph, node, node_out, 0);

	        if (edge_attr.from == "COLOR" && edge_attr.to == "COLOR" 
	                || edge_attr.from == "DEPTH" && edge_attr.to == "DEPTH") {
	            var attr_out = m_graph.get_node_attr(graph, node_out);
	            has_multisample = subs_check_multisample(attr_out, graph);
	        } else
	            has_multisample = edge_attr.to == "RESOLVE";
	    }

	    return has_multisample;
	}

	function make_stereo(graph, sc_render, cam_scene_data, prev_subs) {
	    var cams = cam_scene_data.cameras;
	    var hmd_stereo_use = sc_render.hmd_stereo_use;
	    var anaglyph_use = sc_render.anaglyph_use;
	    var plane_refl_subs = sc_render.reflection_params.plane_refl_subs;
	    var plane_refl_subs_blend = sc_render.reflection_params.plane_refl_subs_blend;

	    var nid_pre_sink = m_graph.get_node_id(graph, prev_subs);
	    var subs_pre_sink = prev_subs;

	    var subgraph_right = m_graph.subgraph_node_conn(graph, nid_pre_sink,
	            m_graph.BACKWARD_DIR);

	    // [[original left only subscene, new right subscene, original slink]...]
	    var left_only_edges = [];
	    var removed_subscenes = [];
	    var source_nodes_right = [];

	    var subs_clone_cb = function(subs) {
	        var subs_new;

	        // shared
	        if (LEFT_ONLY_SUBS_TYPES.indexOf(subs.type) > -1) {
	            removed_subscenes.push(subs);
	            subs_new = subs;
	        } else {
	            subs_new = m_subs.clone_subs(subs);
	            if (subs_new.type == m_subs.MAIN_PLANE_REFLECT) {
	                // NOTE: x[0] --- left eye
	                for (var i = 0; i < plane_refl_subs.length; i++) {
	                    if (plane_refl_subs[i][0] == subs) {
	                        plane_refl_subs[i] = [subs, subs_new];
	                        subs_new.camera.reflection_plane = subs.camera.reflection_plane;
	                        cam_scene_data.cameras.push(subs_new.camera);
	                        break;
	                    }
	                }
	            }

	            // just copy camera from opaque scene for blend reflection
	            if (subs.type == m_subs.MAIN_PLANE_REFLECT_BLEND) {
	                // NOTE: x[0] --- left eye
	                for (var i = 0; i < plane_refl_subs.length; i++) {
	                    if (plane_refl_subs_blend[i][0] == subs) {
	                        plane_refl_subs_blend[i] = [subs, subs_new];
	                        subs_new.camera = plane_refl_subs[i][1].camera;
	                        break;
	                    }
	                }
	            } else if (cams.indexOf(subs.camera) > -1) {
	                if (hmd_stereo_use) {
	                    m_cam.make_stereo(subs.camera, m_cam.TYPE_HMD_LEFT);
	                    m_cam.make_stereo(subs_new.camera, m_cam.TYPE_HMD_RIGHT);
	                    subs_new.force_do_not_render = true;
	                } else {
	                    m_cam.make_stereo(subs.camera, m_cam.TYPE_STEREO_LEFT);
	                    m_cam.make_stereo(subs_new.camera, m_cam.TYPE_STEREO_RIGHT);
	                }
	                cams.push(subs_new.camera);
	            }

	            var nid_subs = m_graph.node_by_attr(graph, subs);
	            m_graph.traverse_inputs(graph, nid_subs, function(nid_in, subs_in,
	                    slink) {
	                if (LEFT_ONLY_SUBS_TYPES.indexOf(subs_in.type) > -1)
	                    left_only_edges.push([subs_in, subs_new, slink]);
	            });

	            if (subs.type !== m_subs.MOTION_BLUR)
	                for (var i = 0; i < subs.slinks_internal.length; i++)
	                    subs_new.slinks_internal[i].parent_slink = subs.slinks_internal[i];

	            // render order: store source nodes for right eye
	            var is_source_node = true;
	            for (var i = 0; i < m_graph.in_edge_count(graph, nid_subs); i++) {
	                var nid_upper_subs = m_graph.get_in_edge(graph, nid_subs, i);
	                var upper_subs = m_graph.get_node_attr(graph, nid_upper_subs);
	                if (LEFT_ONLY_SUBS_TYPES.indexOf(upper_subs.type) == -1)
	                    is_source_node = false;
	            }

	            if (is_source_node)
	                source_nodes_right.push(subs_new);
	        }

	        return subs_new;
	    };
	    var slink_clone_cb = function(slink) {
	        var new_slink = clone_slink(slink, true);
	        new_slink.parent_slink = slink;
	        return new_slink;
	    };
	    subgraph_right = m_graph.clone(subgraph_right, subs_clone_cb, slink_clone_cb);

	    for (var i = 0; i < removed_subscenes.length; i++)
	        m_graph.remove_node(subgraph_right,
	                m_graph.node_by_attr(subgraph_right, removed_subscenes[i]));

	    m_graph.cleanup_loose_edges(subgraph_right);

	    var subs_stereo = m_subs.create_subs_stereo(hmd_stereo_use, anaglyph_use);
	    var nid_stereo = m_graph.append_node_attr(graph, subs_stereo);

	    // HACK: fix subs texture reusage of last left subs
	    if (cfg_def.ios_copy_tex_hack) {
	        var left_clone = m_subs.create_subs_postprocessing("NONE");
	        var slink_left_copy = create_slink("COLOR", "u_color", 1, 1, 1, true, true);
	    } else {
	        var left_clone = m_subs.create_subs_copy();
	        var slink_left_copy = create_slink("COLOR", "COPY", 1, 1, 1, true, true);
	    }
	    slink_left_copy.min_filter = m_tex.TF_LINEAR;
	    slink_left_copy.mag_filter = m_tex.TF_LINEAR;

	    m_graph.append_node_attr(graph, left_clone);
	    m_graph.append_edge_attr(graph, subs_pre_sink, left_clone, slink_left_copy);

	    var slink_left = create_slink("COLOR", "u_sampler_left", 1, 1, 1, true, true);
	    slink_left.unique_texture = true;
	    slink_left.min_filter = m_tex.TF_LINEAR;
	    slink_left.mag_filter = m_tex.TF_LINEAR;

	    m_graph.append_edge_attr(graph, left_clone, subs_stereo, slink_left);

	    if (!subs_pre_sink.is_pp) {
	        if (cfg_def.ios_copy_tex_hack) {
	            var right_clone = m_subs.create_subs_postprocessing("NONE");
	            var slink_right_copy = create_slink("COLOR", "u_color", 1, 1, 1, true, true);
	        } else {
	            var right_clone = m_subs.create_subs_copy();
	            var slink_right_copy = create_slink("COLOR", "COPY", 1, 1, 1, true, true);
	        }
	        m_graph.append_node_attr(subgraph_right, right_clone);
	        slink_right_copy.parent_slink = slink_left_copy;
	        var nid_right_sink = m_graph.get_sink_nodes(subgraph_right)[0];
	        var right_sink = m_graph.get_node_attr(subgraph_right, nid_right_sink);
	        m_graph.append_edge_attr(subgraph_right, right_sink, right_clone, slink_right_copy);
	    }

	    var slink_right = create_slink("COLOR", "u_sampler_right", 1, 1, 1, true, true);
	    if (subs_pre_sink.is_pp)
	        slink_right.parent_slink = slink_left_copy;
	    slink_right.min_filter = m_tex.TF_LINEAR;
	    slink_right.mag_filter = m_tex.TF_LINEAR;

	    m_graph.append_subgraph(subgraph_right, graph,
	            [m_graph.get_sink_nodes(subgraph_right)[0], nid_stereo,
	            slink_right]
	    );

	    for (var i = 0; i < left_only_edges.length; i++) {
	        var subs1 = left_only_edges[i][0];
	        var subs2 = left_only_edges[i][1];
	        var slink = left_only_edges[i][2];
	        m_graph.append_edge_attr(graph, subs1, subs2, slink);
	    }

	    // render order: left eye before right eye
	    var slink_order = create_slink("SCREEN", "NONE", 0, 0, 0, false, false);
	    for (var i = 0; i < source_nodes_right.length; i++)
	        m_graph.append_edge_attr(graph, left_clone, source_nodes_right[i], slink_order);

	    m_graph.traverse_edges(graph, function(node1, node2, slink) {
	        var subs = m_graph.get_node_attr(graph, node1);
	        if (subs.type === m_subs.MOTION_BLUR)
	            slink.parent_slink = null;
	    });

	    return subs_stereo;
	}

	exports.multiply_size_mult_by_graph = multiply_size_mult_by_graph;
	function multiply_size_mult_by_graph(graph, multiplier_x, multiplier_y) {
	    var slink_list = [];
	    m_graph.traverse(graph, function(subs_id, subs) {
	        if (LEFT_ONLY_SUBS_TYPES.indexOf(subs.type) == -1 &&
	                subs.slinks_internal.length &&
	                has_lower_subs(graph, subs, m_subs.STEREO)) {
	            for (var i = 0; i < subs.slinks_internal.length; i++) {
	                var slink = subs.slinks_internal[i];
	                if (slink_list.indexOf(slink) == -1)
	                    slink_list.push(slink);
	            }
	        }
	    });
	    m_graph.traverse_edges(graph, function(node1, node2, slink) {
	        var subs1 = m_graph.get_node_attr(graph, node1);
	        var subs2 = m_graph.get_node_attr(graph, node2);
	        if (LEFT_ONLY_SUBS_TYPES.indexOf(subs1.type) == -1 &&
	                has_lower_subs(graph, subs2, m_subs.STEREO)) {
	            if (slink_list.indexOf(slink) == -1)
	                slink_list.push(slink);
	        }
	    });

	    for (var i = 0; i < slink_list.length; i++) {
	        slink_list[i].size_mult_x *= multiplier_x;
	        slink_list[i].size_mult_y *= multiplier_y;
	    }
	}

	/**
	 * Set subs texel size
	 */
	exports.set_texel_size = set_texel_size;
	function set_texel_size(subs, size_x, size_y) {
	    var mult = subs.texel_size_multiplier;
	    subs.texel_size[0] = size_x * subs.texel_mask[0] * mult;
	    subs.texel_size[1] = size_y * subs.texel_mask[1] * mult;
	}

	/**
	 * Set subs texel size multiplier.
	 * Use set_texel_size() to update shader uniforms
	 */
	exports.set_texel_size_mult = set_texel_size_mult;
	function set_texel_size_mult(subs, mult) {
	    subs.texel_size_multiplier = mult;
	}

	function create_slink(from, to, size, size_mult_x, size_mult_y, update_dim,
	        apply_resolution_factors) {
	    var slink = {
	        // assign explicitly in all cases
	        from: from,
	        to: to,
	        size: size,
	        size_mult_x: size_mult_x,
	        size_mult_y: size_mult_y,
	        update_dim: update_dim,
	        apply_resolution_factors: apply_resolution_factors,

	        // generic default values
	        active: true,
	        texture: null,
	        multisample: false,
	        use_renderbuffer: false,
	        min_filter: m_tex.TF_NEAREST,
	        mag_filter: m_tex.TF_NEAREST,
	        unique_texture: false,
	        use_comparison: false,
	        use_mipmap: false
	    };

	    return slink;
	}

	function clone_slink(slink, tex_by_link) {

	    var slink_new = create_slink(slink.from, slink.to, slink.size, 
	            slink.size_mult_x, slink.size_mult_y, slink.update_dim, 
	            slink.apply_resolution_factors);
	    
	    slink_new.active = slink.active;

	    if (!tex_by_link && slink.texture)
	        m_util.panic("Failed to clone slink with attached texture");
	    // by link
	    slink_new.texture = slink.texture;

	    slink_new.multisample = slink.multisample;
	    slink_new.use_renderbuffer = slink.use_renderbuffer;
	    slink_new.min_filter = slink.min_filter;
	    slink_new.mag_filter = slink.mag_filter;
	    slink_new.unique_texture = slink.unique_texture;
	    slink_new.use_comparison = slink.use_comparison;
	    slink_new.use_mipmap = slink.use_mipmap;

	    return slink_new;
	}

	function prepare_shadow_receive_subs(graph, subs) {

	    var csm_index = 0;
	    var subs_inputs = get_inputs(graph, subs);
	    var v_light_tsr_num = 0;

	    for (var i = 0; i < subs_inputs.length; i++) {

	        var input = subs_inputs[i];

	        // shadow map with optional blurring
	        if (input.type == m_subs.SHADOW_CAST) {
	            v_light_tsr_num++;

	            subs.p_light_matrix = subs.p_light_matrix || new Array();

	            var index = input.shadow_lamp_index > 0 ? input.shadow_lamp_index : csm_index;
	            // assign uniforms from cast camera by link
	            subs.p_light_matrix[index] = input.camera.proj_matrix;

	            csm_index++;
	        }
	    }

	    if (!subs.v_light_ts || !subs.v_light_r) {
	        if (cfg_def.mac_os_shadow_hack)
	            subs.v_light_tsr = new Float32Array(v_light_tsr_num * 9);
	        else {
	            subs.v_light_ts = new Float32Array(v_light_tsr_num * 4);
	            subs.v_light_r = new Float32Array(v_light_tsr_num * 4);
	        }
	    }

	}

	exports.create_performance_graph = function() {
	    var graph = m_graph.create();

	    var subs_perf = m_subs.create_subs_perf();
	    var cam = m_cam.create_camera(m_cam.TYPE_NONE);
	    var size = 512;
	    cam.width = size;
	    cam.height = size;
	    subs_perf.camera = cam;
	    m_graph.append_node_attr(graph, subs_perf);

	    subs_perf.slinks_internal.push(create_slink("COLOR",
	            "u_color", size, 1, 1, false, false));

	    var subs_sink = m_subs.create_subs_sink();
	    m_graph.append_node_attr(graph, subs_sink);

	    m_graph.append_edge_attr(graph, subs_perf, subs_sink,
	            create_slink("COLOR", "NONE", size, 1, 1, false, false));
	    //        create_slink("SCREEN", "NONE", size, 1, 1, false, false));

	    process_subscene_links(graph);
	    assign_render_targets(graph);

	    return graph;
	};

	/**
	 * Find first on-screen subscene.
	 */
	exports.find_on_screen = function(graph) {

	    var subs = null;

	    m_graph.traverse(graph, function(node, attr) {
	        if (attr.camera && attr.camera.framebuffer === null) {
	            subs = attr;
	            return true;
	        }
	        return false;
	    });

	    return subs;
	};

	/**
	 * Find input of given type.
	 */
	exports.find_input = function(graph, subs, type) {
	    var inputs = get_inputs(graph, subs);
	    for (var i = 0; i < inputs.length; i++)
	        if (inputs[i].type == type)
	            return inputs[i];

	    return null;
	};

	/**
	 * Get inputs of given type.
	 */
	exports.get_inputs_by_type = function(graph, subs, type) {
	    var inputs = get_inputs(graph, subs);
	    var matching_inputs = [];

	    for (var i = 0; i < inputs.length; i++)
	        if (inputs[i].type == type)
	            matching_inputs.push(inputs[i]);

	    return matching_inputs;
	};

	exports.has_lower_subs = has_lower_subs;
	/**
	 * Traverse graph downwards and check if subs has output of given type.
	 * subs itself also checked
	 * @methodOf graph
	 */
	function has_lower_subs(graph, subs, type) {

	    if (subs.type == type)
	        return true;

	    var outputs = get_outputs(graph, subs);
	    for (var i = 0; i < outputs.length; i++)
	        if (has_lower_subs(graph, outputs[i], type))
	            return true;

	    return false;
	}

	exports.has_upper_subs = has_upper_subs;
	/**
	 * Traverse graph upwards and check if subs has input of given type.
	 * subs itself also checked
	 * @methodOf graph
	 */
	function has_upper_subs(graph, subs, type) {

	    if (subs.type == type)
	        return true;

	    var inputs = get_inputs(graph, subs);
	    for (var i = 0; i < inputs.length; i++)
	        if (has_upper_subs(graph, inputs[i], type))
	            return true;

	    return false;
	}

	/**
	 * Traverse graph upwards and find first subscene of given type.
	 * subs itself also may be found,
	 * @methodOf graph
	 */
	exports.get_inputs = get_inputs;
	function get_inputs(graph, subs) {
	    var node = m_graph.node_by_attr(graph, subs);
	    if (node == m_graph.NULL_NODE)
	        m_util.panic("Subscene not in graph");

	    var inputs = [];

	    var in_edge_count = m_graph.in_edge_count(graph, node);
	    for (var i = 0; i < in_edge_count; i++) {
	        var node_input = m_graph.get_in_edge(graph, node, i);
	        if (node_input != node)
	            inputs.push(m_graph.get_node_attr(graph, node_input));
	    }
	    return inputs;
	}

	exports.get_outputs = get_outputs;
	function get_outputs(graph, subs) {
	    var node = m_graph.node_by_attr(graph, subs);
	    if (node == m_graph.NULL_NODE)
	        m_util.panic("Subscene not in graph");

	    var outputs = [];

	    var out_edge_count = m_graph.out_edge_count(graph, node);
	    for (var i = 0; i < out_edge_count; i++) {
	        var node_output = m_graph.get_out_edge(graph, node, i);
	        if (node_output != node)
	            outputs.push(m_graph.get_node_attr(graph, node_output));
	    }
	    return outputs;
	}

	/**
	 * Find first subscene in graph/array matching given type
	 */
	exports.find_subs = function(graph, type) {
	    var subs = null;

	    m_graph.traverse(graph, function(node, attr) {
	        if (attr.type == type) {
	            subs = attr;
	            return true;
	        }
	        return false;
	    });

	    return subs;
	};

	exports.debug_convert_to_dot = function(graph) {

	    var PAPER_SIZE = "11.7,16.5";   // A3
	    //var PAPER_SIZE = "8.3,11.7";    // A4

	    var dot_str = "digraph scenegraph {\n";

	    dot_str += "    ";
	    dot_str += "size=\"" + PAPER_SIZE + "\";\n";
	    dot_str += "    ";
	    dot_str += "ratio=\"fill\";\n";

	    dot_str += "    ";
	    dot_str += "node [shape=box margin=\"0.25,0.055\"];\n";

	    var tex_ids = debug_calc_tex_ids(graph);

	    m_graph.traverse(graph, function(node, attr) {
	        dot_str += "    ";
	        dot_str += dot_format_node(node, attr, tex_ids);
	    });

	    m_graph.traverse_edges(graph, function(node1, node2, attr) {
	        dot_str += "    ";
	        dot_str += dot_format_edge(node1, node2, attr, tex_ids);
	    });

	    dot_str += "}";

	    return dot_str;
	};

	function debug_calc_tex_ids(graph) {
	    var index_buf = [];
	    var ids = [];

	    traverse_slinks(graph, function(slink, internal, subs1, subs2) {
	        if (slink.texture) {
	            var num = index_buf.indexOf(slink.texture);
	            if (num == -1) {
	                index_buf.push(slink.texture);
	                ids.push(slink.texture, index_buf.length - 1);
	            }
	        }
	    });

	    return ids;
	}

	function dot_format_node(node, subs, tex_ids) {
	    var label = m_subs.subs_label(subs);

	    if (subs.camera) {
	        label += "\\n";
	        for (var i = 0; i < tex_ids.length; i+=2) {
	            var c_att = subs.camera.color_attachment;
	            if (tex_ids[i] == c_att) {
	                if (m_tex.is_renderbuffer(c_att))
	                    label += "CR" + tex_ids[i+1] + " ";
	                else
	                    label += "C" + tex_ids[i+1] + " ";
	            }
	        }
	        for (var i = 0; i < tex_ids.length; i+=2) {
	            var d_att = subs.camera.depth_attachment;
	            if (tex_ids[i] == d_att) {
	                if (m_tex.is_renderbuffer(d_att))
	                    label += "DR" + tex_ids[i+1];
	                else
	                    label += "D" + tex_ids[i+1];
	            }
	        }
	    }

	    if (subs.slinks_internal.length)
	        label += "\\n-----\\n";

	    for (var i = 0; i < subs.slinks_internal.length; i++)
	        label += dot_format_edge_label(subs.slinks_internal[i], node, null,
	                tex_ids);

	    var color = "black";

	    if (subs.type == m_subs.SINK)
	        var style = "dotted";
	    else if (subs.enqueue)
	        var style = "solid";
	    else
	        var style = "dashed";

	    style += ",bold";

	    return String(node) + " [label=\"" + label + "\" " +
	        "color=\"" + color + "\" " +
	        "style=\"" + style + "\"" +
	        "];\n";
	}

	function dot_format_edge(node1, node2, slink, tex_ids) {
	    var label = dot_format_edge_label(slink, node1, node2, tex_ids);

	    if (slink.active)
	        var style = "solid";
	    else
	        var style = "dotted";

	    return String(node1) + " -> " + String(node2) + " [label=\"" + label + "\" " +
	            "style=\"" + style + "\"];\n";
	}

	function dot_format_edge_label(slink, node1, node2, tex_ids) {
	    function filters_to_string(filters) {
	        var string = "";

	        if (filters.min == m_tex.TF_LINEAR)
	            string += "L";
	        else if (filters.min == m_tex.TF_NEAREST)
	            string += "N";

	        if (filters.mag == m_tex.TF_LINEAR)
	            string += "L";
	        else if (filters.mag == m_tex.TF_NEAREST)
	            string += "N";

	        return string;
	    }

	    var label = "";

	    label += slink.from + "\\n";
	    label += slink.to != "NONE" ? slink.to + "\\n" : "";

	    label += "(";

	    if (slink.update_dim) {

	        var size_mult_x = slink.size_mult_x;
	        var size_mult_y = slink.size_mult_y;

	        if (Math.round(size_mult_x) != size_mult_x)
	            size_mult_x = size_mult_x.toFixed(2);
	        if (Math.round(size_mult_y) != size_mult_y)
	            size_mult_y = size_mult_y.toFixed(2);

	        var size_x = (size_mult_x == 1 ? "" : size_mult_x) + "S";
	        var size_y = (size_mult_y == 1 ? "" : size_mult_y) + "S";
	        label += size_x + "x" + size_y;

	        label += slink.apply_resolution_factors ? " FACT": " VIEW";
	    } else {
	        var size_mult_x = slink.size_mult_x;
	        var size_mult_y = slink.size_mult_y;
	        label += slink.size * size_mult_x + "x" + slink.size * size_mult_y;
	    }

	    if (slink.from != "SCREEN") {
	        label += " ";

	        // texture filtering
	        if (slink.use_renderbuffer)
	            label += "RR";
	        else
	            label += filters_to_string({min: slink.min_filter, mag: slink.mag_filter});

	        // texture ID number (sharing info)
	        for (var i = 0; i < tex_ids.length; i+=2) {
	            if (tex_ids[i] == slink.texture)
	                label += " " + tex_ids[i+1];
	        }
	    }

	    label += ")" + "\\n";

	    return label;
	}

	/**
	 * Create new rendering queue based on graph structure.
	 * Perform topological sorting based on depth-first search algorithm.
	 * @param graph Rendering graph array
	 */
	exports.create_rendering_queue = function(graph) {

	    var subscenes = m_graph.topsort_attr(graph);
	    var queue = [];

	    for (var i = 0; i < subscenes.length; i++) {
	        var subs = subscenes[i];
	        if (subs.enqueue)
	            queue.push(subs);
	    }

	    return queue;
	};

	exports.connect_render_targets_batch = connect_render_targets_batch;
	function connect_render_targets_batch(graph, subs, batch, is_replacing) {
	    var id = m_graph.node_by_attr(graph, subs);

	    // release unused textures from previous subscenes
	    m_graph.traverse_inputs(graph, id, function(id_in, attr_in,
	            attr_edge) {

	        var slink = attr_edge;
	        var subs_in = attr_in;

	        if (!slink.active)
	            return;

	        switch (slink.from) {
	        case "COLOR":
	        case "CUBEMAP":
	            var tex = subs_in.camera.color_attachment;
	            break;
	        case "DEPTH":
	            var tex = subs_in.camera.depth_attachment;
	            break;
	        case "SCREEN":
	            var tex = null;
	            break;
	        case m_subs.MAIN_CUBE_REFLECT:
	            return;
	        default:
	            m_util.panic("Wrong slink");
	        }

	        switch (slink.to) {
	        case "COLOR":
	        case "CUBEMAP":
	        case "DEPTH":
	        case "NONE":
	        case "SCREEN":
	        case "OFFSCREEN":
	        case "RESOLVE":
	        case "COPY":
	        case "u_cube_reflection": // NOTE: set in update_batch_subs()
	        case "u_plane_reflection": // NOTE: set in update_batch_subs()
	            // nothing
	            break;
	        default:

	            if (!tex)
	                if (!is_replacing)
	                    m_util.panic("Connection of SCREEN is forbidden");
	                else
	                    return;
	            if (tex.w_renderbuffer)
	                m_util.panic("Batch texture can't use renderbuffer");

	            if (m_shaders.check_uniform(batch.shader, slink.to))
	                if (is_replacing)
	                    m_batch.replace_texture(batch, tex, slink.to);
	                else
	                    m_batch.append_texture(batch, tex, slink.to);

	            break;
	        }
	    });

	    for (var i = 0; i < subs.slinks_internal.length; i++) {
	        var slink = subs.slinks_internal[i];
	        var tex = subs.textures_internal[i];

	        switch (slink.to) {
	        case "COLOR":
	        case "CUBEMAP":
	        case "DEPTH":
	        case "NONE":
	        case "SCREEN":
	        case "OFFSCREEN":
	        case "RESOLVE":
	        case "COPY":
	            // nothing
	            break;
	        default:

	            if (tex.w_renderbuffer)
	                m_util.panic("Batch texture can't use renderbuffer");

	            if (m_shaders.check_uniform(batch.shader, slink.to))
	                if (is_replacing)
	                    m_batch.replace_texture(batch, tex, slink.to);
	                else
	                    m_batch.append_texture(batch, tex, slink.to);

	            break;
	        }
	    }
	}

	}

	var int_scenegraph_factory = register("__scenegraph", Int_scenegraph);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Scene internal API.
	 * @name scenes
	 * @namespace
	 * @exports exports as scenes
	 */
	function Int_scenes(ns, exports) {

	var m_batch      = int_batch_factory(ns);
	var m_bounds     = int_boundings_factory(ns);
	var m_cam        = int_camera_factory(ns);
	var m_cfg        = int_config_factory(ns);
	var m_cont       = int_container_factory(ns);
	var m_debug      = int_debug_factory(ns);
	var m_graph      = int_graph_factory(ns);
	var m_hud        = int_hud_factory(ns);
	var m_input      = int_input_factory(ns);
	var m_mat4       = mat4_factory(ns);
	var m_nodemat    = int_nodemat_factory(ns);
	var m_obj        = int_objects_factory(ns);
	var m_textures   = int_textures_factory(ns);
	var m_obj_util   = int_obj_util_factory(ns);
	var m_phy        = int_physics_factory(ns);
	var m_prerender  = int_prerender_factory(ns);
	var m_primitives = int_primitives_factory(ns);
	var m_print      = print_factory(ns);
	var m_quat       = quat_factory(ns);
	var m_render     = int_renderer_factory(ns);
	var m_scgraph    = int_scenegraph_factory(ns);
	var m_sfx        = int_sfx_factory(ns);
	var m_shaders    = int_shaders_factory(ns);
	var m_subs       = int_subscene_factory(ns);
	var m_tex        = int_textures_factory(ns);
	var m_tsr        = int_tsr_factory(ns);
	var m_util       = int_util_factory(ns);
	var m_vec3       = vec3_factory(ns);
	var m_vec4       = vec4_factory(ns);
	var m_version    = int_version_factory(ns);

	var cfg_dbg = m_cfg.debug_subs;
	var cfg_def = m_cfg.defaults;
	var cfg_lim = m_cfg.context_limits;
	var cfg_out = m_cfg.outlining;
	var cfg_scs = m_cfg.scenes;

	var FRAME_EPS = 5;

	/* subscene types for different aspects of processing */

	// add objects
	var OBJECT_SUBSCENE_TYPES = [m_subs.GRASS_MAP, m_subs.SHADOW_CAST, m_subs.MAIN_OPAQUE,
	    m_subs.MAIN_BLEND, m_subs.MAIN_XRAY, m_subs.MAIN_GLOW, 
	    m_subs.MAIN_PLANE_REFLECT, m_subs.MAIN_CUBE_REFLECT,
	    m_subs.MAIN_PLANE_REFLECT_BLEND, m_subs.MAIN_CUBE_REFLECT_BLEND,
	    m_subs.COLOR_PICKING, m_subs.COLOR_PICKING_XRAY, m_subs.SHADOW_RECEIVE, 
	    m_subs.OUTLINE_MASK, m_subs.DEBUG_VIEW];
	exports.OBJECT_SUBSCENE_TYPES = OBJECT_SUBSCENE_TYPES;
	// need light update
	var LIGHT_SUBSCENE_TYPES = [m_subs.MAIN_OPAQUE, m_subs.MAIN_BLEND, m_subs.MAIN_XRAY,
	    m_subs.MAIN_GLOW, m_subs.MAIN_PLANE_REFLECT, m_subs.MAIN_CUBE_REFLECT,
	    m_subs.GOD_RAYS, m_subs.GOD_RAYS_COMBINE, m_subs.SKY,
	    m_subs.MAIN_PLANE_REFLECT_BLEND, m_subs.MAIN_CUBE_REFLECT_BLEND,
	    m_subs.LUMINANCE_TRUNCED, m_subs.SHADOW_RECEIVE, m_subs.SHADOW_CAST,
	    m_subs.COLOR_PICKING, m_subs.COLOR_PICKING_XRAY, m_subs.OUTLINE_MASK];

	var FOG_SUBSCENE_TYPES = [m_subs.MAIN_OPAQUE, m_subs.SSAO, m_subs.MAIN_BLEND,
	    m_subs.MAIN_XRAY, m_subs.MAIN_GLOW, m_subs.MAIN_PLANE_REFLECT,
	    m_subs.MAIN_CUBE_REFLECT, m_subs.MAIN_PLANE_REFLECT_BLEND, m_subs.MAIN_CUBE_REFLECT_BLEND];

	// need time update
	var TIME_SUBSCENE_TYPES = [m_subs.SHADOW_CAST, m_subs.MAIN_OPAQUE,
	    m_subs.MAIN_BLEND, m_subs.MAIN_XRAY, m_subs.MAIN_GLOW,
	    m_subs.MAIN_PLANE_REFLECT, m_subs.MAIN_CUBE_REFLECT,
	    m_subs.MAIN_PLANE_REFLECT_BLEND, m_subs.MAIN_CUBE_REFLECT_BLEND,
	    m_subs.COLOR_PICKING, m_subs.COLOR_PICKING_XRAY, m_subs.SHADOW_RECEIVE,
	    m_subs.GOD_RAYS, m_subs.OUTLINE_MASK, m_subs.DEBUG_VIEW];

	// need camera water distance update
	var MAIN_SUBSCENE_TYPES = [m_subs.MAIN_OPAQUE, m_subs.MAIN_BLEND, m_subs.MAIN_XRAY,
	    m_subs.MAIN_GLOW, m_subs.MAIN_PLANE_REFLECT, m_subs.MAIN_CUBE_REFLECT,
	    m_subs.MAIN_PLANE_REFLECT_BLEND, m_subs.MAIN_CUBE_REFLECT_BLEND];

	var SHORE_DIST_COMPAT = 100;

	var MAX_BATCH_TEXTURES = 8;

	var _main_scene = null;
	var _active_scene = null;
	var _scenes = [];
	// not to be confused with scenegraph
	var _scenes_graph = null;

	var GRASS_MAP_MARGIN = 1E-4;

	var MAX_SHADOW_CAST_BB_PROPORTION = 2;
	var MAX_OPTIMAL_BB_ANGLE = Math.PI / 2;
	var OPTIMAL_BB_COUNT = 10;
	var OPTIMAL_BB_THRESHOLD = 0.1;

	// prevent shadows stretching near edges
	var SHADOW_MAP_EPSILON_XY = 0.005;
	// fix depth rendering near clipping planes
	var SHADOW_MAP_EPSILON_Z = 0.005;

	var _vec2_tmp = new Float32Array(2);
	var _vec3_tmp = new Float32Array(3);
	var _vec3_tmp2 = new Float32Array(3);
	var _quat4_tmp = new Float32Array(4);
	var _vec4_tmp = new Float32Array(4);
	var _mat4_tmp = new Float32Array(16);
	var _corners_cache = new Float32Array(24);
	var _corners_cache2 = new Float32Array(24);

	var _bb_tmp = m_bounds.create_bb();
	var _bb_tmp2 = m_bounds.create_bb();

	var _shadow_cast_min_z = 0;
	var _shadow_cast_max_z = -Infinity;

	var _pixel = new Uint8Array(4);

	exports.create_scene_render = function() {
	    var render = {

	    };

	    return render;
	};

	/**
	 * Set given scene as active
	 */
	exports.set_active = function(scene) {
	    _active_scene = scene;
	    m_sfx.set_active_scene(scene);
	};

	/**
	 * Prepare given scene for rendering.
	 * Executed after all objects added to scene.
	 */
	exports.prepare_rendering = function(scene, scene_main) {

	    var render = scene._render;
	    var queue = m_scgraph.create_rendering_queue(render.graph);

	    if (scene == scene_main) {
	        setup_scene_dim(scene, m_cont.get_viewport_width(), m_cont.get_viewport_height());

	        // attach to existing (may already containt RTT queue)
	        for (var i = 0; i < queue.length; i++)
	            scene._render.queue.push(queue[i]);

	    } else {
	        var tex0 = scene._render_to_textures[0];

	        var width = tex0.source_size;
	        var height = tex0.source_size;

	        setup_scene_dim(scene, width, height);

	        for (var i = 0; i < queue.length; i++)
	            scene_main._render.queue.push(queue[i]);
	    }

	    var subs_arr = subs_array(scene, TIME_SUBSCENE_TYPES);
	    for (var j = 0; j < subs_arr.length; j++)
	        subs_arr[j].wind.set(render.wind);

	    // NOTE: draw all SHADOW_CAST subscenes to fill them with correct DEPTH data
	    // before rendering
	    for (var i = 0; i < render.queue.length; i++)
	        if (render.queue[i].type == m_subs.SHADOW_CAST)
	            m_render.draw(render.queue[i]);
	};

	exports.get_main = get_main;
	function get_main() {
	    if (!_main_scene)
	        _main_scene = find_main_scene(_scenes);

	    return _main_scene;
	}

	/**
	 * Main scene - first non-RTT scene
	 * should be executed after RTT assignment in create_texture_bpy()
	 */
	exports.find_main_scene = find_main_scene;
	function find_main_scene(scenes) {
	    for (var i = 0; i < scenes.length; i++) {
	        var scene = scenes[i];

	        if (!scene._render_to_textures || !scene._render_to_textures.length)
	            return scene;
	    }

	    return null;
	}

	exports.get_active = get_active;
	/**
	 * @methodOf scenes
	 */
	function get_active() {
	    if (!_active_scene)
	        m_util.panic("No active scene available");
	    return _active_scene;
	}



	exports.check_active = check_active;
	function check_active() {
	    if (_active_scene)
	        return true;
	    else
	        return false;
	}

	exports.get_camera = function(scene) {
	    return scene._camera;
	};

	exports.get_all_scenes = get_all_scenes;
	function get_all_scenes() {
	    return _scenes;
	}

	exports.get_rendered_scenes = function() {
	    if (_scenes.length == 1)
	        return _scenes;

	    for (var i = 0; i < _scenes.length; i++) {
	        var graph = _scenes[i]._render.graph;
	        m_graph.traverse(graph, function(node, attr) {
	            var subs = attr;
	            var draw_data = subs.draw_data;
	            for (var j = 0; j < draw_data.length; j++) {
	                var bundles = draw_data[j].bundles;
	                for (var k = 0; k < bundles.length; k++) {
	                    var bundle = bundles[k];
	                    var textures = bundle.batch.textures;
	                    var bpy_tex_names = bundle.batch.bpy_tex_names;
	                    var batch = null;
	                    for (var m = 0; m < textures.length; m++)
	                        if (textures[m].source == "SCENE" && textures[m].source_id == _scenes[i]["name"]
	                                && subs.type != m_subs.COPY) {
	                            m_print.error("Texture-scene loop detected. A scene is " +
	                                "rendered to texture \"" + bpy_tex_names[m] +
	                                "\" yet this texture belongs " +
	                                "to the same scene.");
	                            batch = bundle.batch;
	                            break;
	                        }

	                    if (batch) {
	                        var old_textures = batch.textures;
	                        batch.textures = [];
	                        batch.texture_names = [];
	                        m_batch.update_batch_material_error(batch, null);
	                        m_batch.update_shader(batch);
	                        m_subs.append_draw_data(subs, bundle);
	                        for (var m = 0; m < old_textures.length; m++) {
	                            var old_tex = old_textures[m];
	                            m_textures.cleanup_unused(old_tex);
	                        }
	                    }
	                }
	            }
	        });
	    }

	    var scenes = [];

	    for (var i = 0; i < _scenes.length; i++) {
	        var scene = _scenes[i];

	        // begin from the first non-RTT scene
	        if (scene._render_to_textures.length)
	            continue;

	        var node = m_graph.node_by_attr(_scenes_graph, scene);
	        m_graph.enforce_acyclic(_scenes_graph, node);
	        var graph = m_graph.subgraph_node_conn(_scenes_graph, node, m_graph.BACKWARD_DIR);
	        graph = m_graph.topsort(graph);

	        m_graph.traverse(graph, function(node, attr) {
	            scenes.push(attr);
	        });

	        break;
	    }

	    return scenes;
	};

	exports.append_scene = append_scene;
	/**
	 * Update scene._render
	 * prepare camera before execution
	 * @methodOf scenes
	 */
	function append_scene(bpy_scene, scene_objects, lamps, bpy_mesh_objs, bpy_empty_objs) {
	    bpy_scene._render_to_textures = bpy_scene._render_to_textures || [];
	    bpy_scene._nla = null;

	    var render = bpy_scene._render;
	    var cam_scene_data = m_obj_util.get_scene_data(bpy_scene._camera, bpy_scene);
	    var cam_render = bpy_scene._camera.render;

	    render.video_textures = [];

	    var world = bpy_scene["world"];

	    render.lamps_number      = lamps.length;
	    render.sun_exist         = check_scenes_sun(lamps);
	    render.sky_params        = extract_sky_params(world, render.sun_exist);
	    render.world_light_set   = get_world_light_set(world, render.sky_params);
	    render.world_fog_set     = get_world_fog_set(world);
	    render.hmd_stereo_use    = !bpy_scene._render_to_textures.length &&
	                               check_hmd_stereo_use(cam_scene_data);
	    render.anaglyph_use      = !bpy_scene._render_to_textures.length &&
	                               check_anaglyph_use(cam_scene_data);
	    // TODO: replace the flags (sidebyside_use, anaglyph_use, hmd_stereo_use) by an enum parameter
	    render.sidebyside_use    = !bpy_scene._render_to_textures.length &&
	                               check_sidebyside_use(cam_scene_data);
	    render.anchor_visibility = !render.anaglyph_use && !render.sidebyside_use &&
	                               check_anchor_visibility_objects(bpy_scene, bpy_empty_objs);
	    render.reflection_params = extract_reflections_params(bpy_scene, scene_objects, bpy_mesh_objs);
	    render.bloom_params      = extract_bloom_params(bpy_scene);
	    render.mb_params         = extract_mb_params(bpy_scene);
	    render.cc_params         = extract_cc_params(bpy_scene);
	    render.god_rays_params   = extract_god_rays_params(bpy_scene);
	    render.outline_params    = extract_outline_params(bpy_scene);
	    render.glow_params       = extract_glow_params(bpy_scene);

	    render.dof               = cfg_def.dof && (cam_render.dof_distance > 0 || cam_render.dof_object);
	    render.motion_blur       = cfg_def.motion_blur && bpy_scene["b4w_enable_motion_blur"];
	    render.compositing       = cfg_def.compositing && bpy_scene["b4w_enable_color_correction"];
	    render.antialiasing      = cfg_def.antialiasing &&
	                              cfg_def.msaa_samples == 1 &&
	                              (bpy_scene["b4w_antialiasing_quality"] != "NONE");
	    render.ssao              = cfg_def.ssao && bpy_scene["b4w_enable_ssao"];
	    render.god_rays          = cfg_def.god_rays && bpy_scene["b4w_enable_god_rays"] && render.sun_exist;
	    render.depth_tex         = cfg_def.depth_tex_available;
	    render.glow_over_blend   = bpy_scene["b4w_glow_settings"]["render_glow_over_blend"];
	    render.ssao_params       = extract_ssao_params(bpy_scene);

	    var materials_params     = get_material_params(bpy_mesh_objs);
	    render.materials_params  = materials_params;
	    render.refractions       = check_refraction(bpy_scene, materials_params);
	    render.shadow_params     = extract_shadow_params(bpy_scene, lamps, bpy_mesh_objs);
	    render.water_params      = get_water_params(bpy_mesh_objs);
	    render.xray              = check_xray_materials(bpy_mesh_objs);
	    render.soft_particles    = check_soft_particles(bpy_mesh_objs);
	    render.shore_smoothing   = check_shore_smoothing(bpy_mesh_objs);
	    render.dynamic_grass     = check_dynamic_grass(bpy_scene, bpy_mesh_objs);
	    render.color_picking     = check_selectable_objects(bpy_scene, bpy_mesh_objs);
	    render.outline           = check_outlining_objects(bpy_scene, bpy_mesh_objs);
	    render.glow_materials    = check_glow_materials(bpy_scene, bpy_mesh_objs);
	    render.lod_smooth_type   = bpy_scene["b4w_lod_smooth_type"];
	    render.lod_hyst_interval = bpy_scene["b4w_lod_hyst_interval"];

	    var reflection_quality = cfg_def.reflection_quality ? cfg_def.reflection_quality :
	            bpy_scene["b4w_reflection_quality"];

	    switch (reflection_quality) {
	    case "LOW":
	        render.cubemap_refl_size = cfg_scs.cube_reflect_low;
	        render.plane_refl_size = cfg_scs.plane_reflect_low;
	        break;
	    case "MEDIUM":
	        render.cubemap_refl_size = cfg_scs.cube_reflect_medium;
	        render.plane_refl_size = cfg_scs.plane_reflect_medium;
	        break;
	    case "HIGH":
	        render.cubemap_refl_size = cfg_scs.cube_reflect_high;
	        render.plane_refl_size = cfg_scs.plane_reflect_high;
	        break;
	    default:
	        render.cubemap_refl_size = cfg_scs.cube_reflect_low;
	        render.plane_refl_size = cfg_scs.plane_reflect_low;
	        break;
	    }

	    if (m_cont.is_hidpi()) {
	        m_print.log("%cENABLE HIDPI MODE", "color: #00a");
	        render.aa_quality = "AA_QUALITY_LOW";
	        render.resolution_factor = 1.0;
	        cfg_def.msaa_samples = 1;
	    } else if (cfg_def.msaa_samples > 1) {
	        m_print.log("%cENABLE MSAA RENDERING: " + cfg_def.msaa_samples + "x",
	                "color: #00a");
	        render.resolution_factor = 1.0;
	    } else {
	        render.aa_quality = "AA_QUALITY_" + bpy_scene["b4w_antialiasing_quality"];

	        if (cfg_def.quality === m_cfg.P_ULTRA)
	            render.resolution_factor = 1.33;
	        else
	            render.resolution_factor = 1.0;

	    }
	    var rtt_sort_fun = function(bpy_tex1, bpy_tex2) {
	        return bpy_tex2.source_size - bpy_tex1.source_size;
	    };

	    var rtt_sorted = bpy_scene._render_to_textures.sort(rtt_sort_fun);
	    render.graph = m_scgraph.create_rendering_graph(render, cam_scene_data,
	                cam_render, rtt_sorted);

	    render.queue = [];

	    render.need_shadow_update = false;
	    render.need_grass_map_update = false;
	    render.need_outline = false;
	    render.wind = new Float32Array(3);

	    _scenes.push(bpy_scene);

	    if (!_scenes_graph)
	        _scenes_graph = m_graph.create();

	    m_graph.append_node_attr(_scenes_graph, bpy_scene);

	    // scene_data is ready after scene appending
	    for (var i = 0; i < scene_objects.length; i++)
	        m_obj_util.scene_data_set_active(scene_objects[i], true, bpy_scene);

	    var canvas_container_elem = m_cont.get_container();
	    m_cont.resize(canvas_container_elem.clientWidth,
	            canvas_container_elem.clientHeight, true);
	}

	exports.append_scene_vtex = function(scene, textures, data_id) {
	    for (var i = 0; i < textures.length; i++) {
	        var tex = textures[i]._render;
	        if (tex && tex.is_movie) {
	            tex.vtex_data_id = data_id;
	            scene._render.video_textures.push(textures[i]);
	        }
	    }
	};

	function extract_shadow_params(bpy_scene, lamps, bpy_mesh_objs) {

	    if (!check_render_shadows(bpy_scene, lamps, bpy_mesh_objs))
	        return null;

	    var shs = bpy_scene["b4w_shadow_settings"];
	    var rshs = {};
	    if (shs["csm_resolution"] > cfg_lim.max_texture_size) {
	        rshs.csm_resolution = cfg_lim.max_texture_size;
	        m_print.error("Shadow map texture has unsupported size. Changed to "
	                + cfg_lim.max_texture_size + ".");
	    } else
	        rshs.csm_resolution         = shs["csm_resolution"];

	    cfg_def.shadow_blur_samples = cfg_def.shadow_blur_samples ? cfg_def.shadow_blur_samples : shs["blur_samples"];
	    rshs.soft_shadows = shs["soft_shadows"];

	    var use_ssao = cfg_def.ssao && bpy_scene["b4w_enable_ssao"];
	    var shadow_lamps = m_obj_util.get_shadow_lamps(lamps, use_ssao);

	    rshs.self_shadow_polygon_offset = shs["self_shadow_polygon_offset"];
	    rshs.self_shadow_normal_offset  = shs["self_shadow_normal_offset"];
	    rshs.enable_csm                 = shs["b4w_enable_csm"] && shadow_lamps.length == 1;
	    
	    if (shs["b4w_enable_csm"] && shs["csm_num"] > 1 && shadow_lamps.length > 1)
	        m_print.warn("Disabling Cascaded Shadow Maps because of multiple shadow casting lamps.");

	    rshs.lamp_types = [];
	    rshs.spot_sizes = [];
	    rshs.clip_start = [];
	    rshs.clip_end = [];

	    for (var i = 0; i < shadow_lamps.length; i++) {
	        rshs.lamp_types.push(shadow_lamps[i].light.type);
	        rshs.spot_sizes.push(shadow_lamps[i].light.spot_size);
	        rshs.clip_start.push(shadow_lamps[i].light.clip_start);
	        rshs.clip_end.push(shadow_lamps[i].light.clip_end);
	        if ((rshs.lamp_types[i] == "SPOT" || rshs.lamp_types[i] == "POINT") &&
	                rshs.enable_csm) {
	            m_print.warn("Generating shadows for SPOT " +
	                        "or POINT light. Disabling Cascaded Shadow Maps");
	            rshs.enable_csm = false;
	        }
	    }

	    if (rshs.enable_csm) {
	        rshs.csm_num                    = shs["csm_num"];
	        rshs.csm_first_cascade_border   = shs["csm_first_cascade_border"];
	        rshs.first_cascade_blur_radius  = shs["first_cascade_blur_radius"];
	        rshs.csm_last_cascade_border    = shs["csm_last_cascade_border"];
	        rshs.last_cascade_blur_radius   = shs["last_cascade_blur_radius"];

	        rshs.fade_last_cascade          = shs["fade_last_cascade"];
	        rshs.blend_between_cascades     = shs["blend_between_cascades"];
	    } else {
	        rshs.csm_num                    = 1;
	        rshs.csm_first_cascade_border   = shs["csm_first_cascade_border"];
	        rshs.first_cascade_blur_radius  = shs["first_cascade_blur_radius"];
	        rshs.csm_last_cascade_border    = shs["csm_last_cascade_border"];
	        rshs.last_cascade_blur_radius   = shs["last_cascade_blur_radius"];

	        rshs.fade_last_cascade          = false;
	        rshs.blend_between_cascades     = false;
	    }
	    return rshs;
	}

	function check_render_shadows(bpy_scene, lamps, bpy_mesh_objs) {

	    if (lamps.length == 0)
	        return false;

	    if (cfg_def.shadows) {
	        switch (bpy_scene["b4w_render_shadows"]) {
	        case "OFF":
	            return false;
	        case "ON":
	            return true;
	        case "AUTO":
	        }
	    } else
	        return false

	    var has_casters = false;
	    var has_receivers = false;
	    var use_ssao = cfg_def.ssao && bpy_scene["b4w_enable_ssao"];
	    if (lamps.length == 0 && !use_ssao)
	        return false;

	    for (var i = 0; i < bpy_mesh_objs.length; i++) {
	        var bpy_obj = bpy_mesh_objs[i];

	        if (bpy_obj["b4w_shadow_cast"])
	            has_casters = true;

	        if (bpy_obj["b4w_shadow_receive"])
	            has_receivers = true;

	        if ((use_ssao || has_casters) && has_receivers)
	            return true;
	    }
	    // no casters, no receivers
	    return false;
	}


	function check_scenes_sun(lamps) {
	    for (var i = 0; i < lamps.length; i++)
	        if (lamps[i].light.type == "SUN")
	            return true;
	    return false;

	}
	/**
	 * Check if shore smoothing required for given bpy objects which represent the scene.
	 * Shore smoothing required if we have shore smoothing flag
	 * enabled for water materials
	 */
	function check_shore_smoothing(bpy_objects) {

	    if (!cfg_def.shore_smoothing)
	        return false;

	    var mats = get_objs_materials(bpy_objects);

	    for (var i = 0; i < mats.length; i++) {
	        var mat = mats[i];

	        if (mat.water_settings.is_water && mat.water_settings.shore_smoothing)
	            return true;
	    }

	    return false;
	}

	function check_soft_particles(bpy_objects) {
	    for (var i = 0; i < bpy_objects.length; i++) {
	        var bpy_obj = bpy_objects[i];
	        var psystems = bpy_obj["particle_systems"];
	        for (var j = 0; j < psystems.length; j++) {
	            var pset = psystems[j]["settings"];
	            if (m_obj_util.check_obj_soft_particles_accessibility(
	                    bpy_objects[i]._object, pset))
	                return true;
	        }
	    }
	    return false;

	}
	/**
	 * Check water parameters based on the given bpy objects.
	 */
	function get_water_params(bpy_objects) {

	    // TODO: Now returns only parameters from a water obj which is considered
	    // to be the most important one. Need to collect info from other water
	    // objects.
	    var mats = get_objs_materials(bpy_objects);
	    var water_params = [];

	    for (var i = 0; i < mats.length; i++) {
	        var mat = mats[i];

	        if (mat.water_settings.is_water) {

	            var wp = {};
	            // set water level to obect's origin y coord
	            for (var j = 0; j < bpy_objects.length; j++) {
	                var bpy_obj = bpy_objects[j];
	                var mesh_mats = bpy_obj._object.materials;
	                for (var k = 0; k < mesh_mats.length; k++) {
	                    var mesh_mat = mesh_mats[k];
	                    if (mesh_mat == mat)
	                        wp.water_level = bpy_obj["location"][2];
	                }
	            }

	            // fog stuff
	            wp.fog_color_density = new Float32Array(4);
	            wp.fog_color_density.set(mat.water_settings.fog_color);
	            wp.fog_color_density[3] = mat.water_settings.fog_density;

	            // dynamics stuff
	            if (mat.water_settings.is_dynamic) {
	                wp.dynamic           = true;
	                wp.waves_height      = mat.water_settings.waves_height;
	                wp.waves_length      = mat.water_settings.waves_length;
	                wp.dst_noise_scale0  = mat.water_settings.dst_noise_scale0;
	                wp.dst_noise_scale1  = mat.water_settings.dst_noise_scale1;
	                wp.dst_noise_freq0   = mat.water_settings.dst_noise_freq0;
	                wp.dst_noise_freq1   = mat.water_settings.dst_noise_freq1;
	                wp.dir_min_shore_fac = mat.water_settings.dir_min_shore_fac;
	                wp.dir_freq          = mat.water_settings.dir_freq;
	                wp.dir_noise_scale   = mat.water_settings.dir_noise_scale;
	                wp.dir_noise_freq    = mat.water_settings.dir_noise_freq;
	                wp.dir_min_noise_fac = mat.water_settings.dir_min_noise_fac;
	                wp.dst_min_fac       = mat.water_settings.dst_min_fac;
	                wp.waves_hor_fac     = mat.water_settings.waves_hor_fac;
	            } else {
	                wp.dynamic      = false;
	                wp.waves_height = 0.0;
	                wp.waves_length = 0.0;
	            }

	            // caustics stuff
	            wp.caustics           = mat.water_settings.enable_caust;
	            wp.caustic_scale      = mat.water_settings.caust_scale;
	            wp.caustic_brightness = mat.water_settings.caust_brightness;
	            wp.caustic_speed      = new Float32Array([0.3, 0.7]);

	            wp.shoremap_image  = null;

	            var texture_slots = mat.texture_slots;

	            for (var j = 0; j < texture_slots.length; j++) {
	                var texture = texture_slots[j]["texture"];
	                if (texture["b4w_shore_dist_map"] === true &&
	                        texture["image"]["source"] == "FILE") {
	                    wp.shoremap_image    = texture["image"];
	                    wp.shoremap_tex_size = texture["image"]["size"][0];
	                    wp.max_shore_dist    = texture["b4w_max_shore_dist"];

	                    var shore_boundings = texture["b4w_shore_boundings"];
	                    wp.shoremap_center = [(shore_boundings[0] + shore_boundings[1]) / 2,
	                                          (shore_boundings[2] + shore_boundings[3]) / 2];

	                    wp.shoremap_size = [shore_boundings[0] - shore_boundings[1],
	                                        shore_boundings[2] - shore_boundings[3]];

	                }
	            }
	            water_params.push(wp);
	        }
	    }

	    if (water_params.length > 0) {
	        var wp = water_params[0];
	        if (!wp.dynamic)
	            // set water params from water with "dynamic" property
	            for (var i = 0; i < water_params.length; i++)
	                if (water_params[i].dynamic)
	                    wp = water_params[i];

	        return wp;
	    } else
	        return null;
	}

	function get_material_params(bpy_objects) {

	    var materials_properties_existance = {
	        refractions: false
	    };

	    var materials = get_objs_materials(bpy_objects);

	    var get_nodes_properties = function(node_tree) {
	        if (!node_tree)
	            return;
	        var nodes = node_tree["nodes"];
	        for (var j = 0; j < nodes.length; j++) {
	            var node = nodes[j];

	            if (node["type"] == "GROUP" && node["node_group"])
	                get_nodes_properties(node["node_group"]["node_tree"]);

	            if (node["type"] == "GROUP" && node["node_tree_name"] == "B4W_REFRACTION")
	                materials_properties_existance.refractions = true;

	            if (node["type"] == "BSDF_TRANSPARENT")
	                materials_properties_existance.refractions = true;
	        }
	    };

	    for (var i = 0; i < materials.length; i++) {
	        var material = materials[i];

	        if (material.is_refractive)
	            materials_properties_existance.refractions = true;

	        if (material.node_tree)
	            get_nodes_properties(material.node_tree);
	    }

	    return materials_properties_existance;
	}

	function check_anaglyph_use(cam_scene_data) {
	    // NOTE: disable anaglyph stereo for the non-PERSP camera
	    if (cam_scene_data.cameras[0].type != m_cam.TYPE_PERSP && cfg_def.stereo == "ANAGLYPH") {
	        m_print.warn("Anaglyph stereo is disabled for the non-perspective camera");
	        cfg_def.stereo = "NONE";
	        return false;
	    } else
	        return cfg_def.stereo == "ANAGLYPH";
	}

	function check_sidebyside_use(cam_scene_data) {
	    // NOTE: disable side-by-side stereo for the non-PERSP camera
	    if (cam_scene_data.cameras[0].type != m_cam.TYPE_PERSP && cfg_def.stereo == "SIDEBYSIDE") {
	        m_print.warn("Side-by-side stereo is disabled for the non-perspective camera");
	        cfg_def.stereo = "NONE";
	        return false;
	    } else
	        return cfg_def.stereo == "SIDEBYSIDE";
	}

	function check_hmd_stereo_use(cam_scene_data) {
	    // NOTE: disable head-mounted display stereo for the non-PERSP camera
	    if (cfg_def.stereo == "HMD") {
	        if (cam_scene_data.cameras[0].type != m_cam.TYPE_PERSP) {
	            m_print.warn("Head-mounted display stereo is disabled for the non-perspective camera");
	            cfg_def.stereo = "NONE";
	            return false;
	        }
	        if (!m_input.can_use_device(m_input.DEVICE_HMD)) {
	            m_print.warn("Head-mounted display stereo is disabled for the non-WebVR and non-mobile devices");
	            cfg_def.stereo = "NONE";
	            return false;
	        }
	    }
	    return cfg_def.stereo == "HMD";
	}

	/**
	 * Check if reflections are required for the given scene.
	 * Returns an array of reflection planes and cube reflectibe objs on the scene.
	 */
	function extract_reflections_params(bpy_scene, scene_objects, bpy_mesh_objs) {

	    if (cfg_def.reflections) {
	        switch (bpy_scene["b4w_render_reflections"]) {
	        case "OFF":
	            return false;
	        case "ON":
	        }
	    } else
	        return false;

	    var refl_plane_objs = [];
	    var num_cube_refl = 0;
	    var has_reflexible = false;
	    var has_blend_reflexible = false;

	    for (var i = 0; i < scene_objects.length; i++) {
	        var obj = scene_objects[i];

	        if (obj.render.reflective && obj.render.reflection_type == "CUBE")
	            num_cube_refl++;

	        if (obj.reflective_objs.length) {
	            var refl_plane_id = null;
	            for (var j = 0; j < refl_plane_objs.length; j++) {
	                var rp = refl_plane_objs[j];
	                if (rp == obj) {
	                     refl_plane_id = j;
	                     break;
	                }
	            }

	            // we need only unique reflection planes
	            if (refl_plane_id == null)
	                refl_plane_objs.push(obj);
	        }

	    }

	    for (var i = 0; i < bpy_mesh_objs.length; i++) {
	        var bpy_obj = bpy_mesh_objs[i];

	        if (bpy_obj["b4w_reflexible"])
	            has_reflexible = true;
	        if (check_blend_reflexible(bpy_obj))
	            has_blend_reflexible = true;
	    }

	    return {refl_plane_objs: refl_plane_objs,
	            num_cube_refl:   num_cube_refl,
	            cube_refl_subs:  [],
	            cube_refl_subs_blend:  [],
	            plane_refl_subs: [],
	            plane_refl_subs_blend: [],
	            has_reflexible: has_reflexible,
	            has_blend_reflexible: has_blend_reflexible
	           };
	}

	function check_blend_reflexible(bpy_obj) {

	    if (!bpy_obj["b4w_reflexible"])
	        return;

	    var materials = bpy_obj._object.materials;
	    for (var i = 0; i < materials.length; i++) {
	        var blend_mode = materials[i].blend_mode;
	        if (blend_mode != "OPAQUE" && blend_mode != "CLIP"
	                && blend_mode != "ALPHA_ANTIALIASING")
	            return true;
	    }

	    return false;
	}

	/**
	 * Check dynamic sky parameters
	 */
	function extract_sky_params(world, sun_exist) {

	    var sky_settings = world["b4w_sky_settings"];
	    var sky_params = {};

	    sky_params.render_sky                  = sky_settings["render_sky"] || sky_settings["procedural_skydome"];
	    sky_params.procedural_skydome          = sky_settings["procedural_skydome"];
	    sky_params.use_as_environment_lighting = sky_settings["use_as_environment_lighting"];
	    sky_params.sky_color                   = sky_settings["color"];
	    sky_params.rayleigh_brightness         = sky_settings["rayleigh_brightness"];
	    sky_params.mie_brightness              = sky_settings["mie_brightness"];
	    sky_params.spot_brightness             = sky_settings["spot_brightness"];
	    sky_params.scatter_strength            = sky_settings["scatter_strength"];
	    sky_params.rayleigh_strength           = sky_settings["rayleigh_strength"];
	    sky_params.mie_strength                = sky_settings["mie_strength"];
	    sky_params.rayleigh_collection_power   = sky_settings["rayleigh_collection_power"];
	    sky_params.mie_collection_power        = sky_settings["mie_collection_power"];
	    sky_params.mie_distribution            = sky_settings["mie_distribution"];
	    sky_params.reflexible                  = sky_settings["reflexible"];
	    sky_params.reflexible_only             = sky_settings["reflexible_only"];

	    if (!sun_exist && sky_settings["procedural_skydome"])
	        m_print.warn("There is no sun on the scene. " +
	                          "Procedural sky will use a default sun position.");

	    return sky_params;
	}

	/**
	 * Extract ssao parameters
	 */
	function extract_ssao_params(bpy_scene) {
	    var ssao_params   = {};
	    var ssao_settings = bpy_scene["b4w_ssao_settings"];

	    ssao_params.radius_increase         = ssao_settings["radius_increase"];
	    ssao_params.hemisphere              = ssao_settings["hemisphere"];
	    ssao_params.blur_depth              = ssao_settings["blur_depth"];
	    ssao_params.blur_discard_value      = ssao_settings["blur_discard_value"];
	    ssao_params.influence               = ssao_settings["influence"];
	    ssao_params.dist_factor             = ssao_settings["dist_factor"];
	    ssao_params.samples                 = ssao_settings["samples"];

	    return ssao_params;
	}

	/**
	 * Extract bloom parameters
	 */
	function extract_bloom_params(bpy_scene) {

	    if (!(cfg_def.bloom && bpy_scene["b4w_enable_bloom"]))
	        return null;

	    var bloom_params   = {};
	    var bloom_settings = bpy_scene["b4w_bloom_settings"];

	    bloom_params.blur     = bloom_settings["blur"];
	    bloom_params.edge_lum = bloom_settings["edge_lum"];
	    bloom_params.key      = bloom_settings["key"];
	    bloom_params.adaptive = bloom_settings["adaptive"];
	    bloom_params.average_luminance = bloom_settings["average_luminance"];

	    return bloom_params;
	}

	/**
	 * Extract motion blur parameters
	 */
	function extract_mb_params(bpy_scene) {

	    var mb_params   = {};
	    var mb_settings = bpy_scene["b4w_motion_blur_settings"];

	    mb_params.mb_decay_threshold = mb_settings["motion_blur_decay_threshold"];
	    mb_params.mb_factor          = mb_settings["motion_blur_factor"];

	    return mb_params;
	}

	/**
	 * Extract color correction parameters
	 */
	function extract_cc_params(bpy_scene) {

	    var cc_params   = {};
	    var cc_settings = bpy_scene["b4w_color_correction_settings"];

	    cc_params.brightness = cc_settings["brightness"];
	    cc_params.contrast   = cc_settings["contrast"];
	    cc_params.exposure   = cc_settings["exposure"];
	    cc_params.saturation = cc_settings["saturation"];

	    return cc_params;
	}

	/**
	 * Extract god rays parameters
	 */
	function extract_god_rays_params(bpy_scene) {

	    var god_rays_params   = {};
	    var god_rays_settings = bpy_scene["b4w_god_rays_settings"];

	    god_rays_params.intensity      = god_rays_settings["intensity"];
	    god_rays_params.max_ray_length = god_rays_settings["max_ray_length"];
	    god_rays_params.steps_per_pass = god_rays_settings["steps_per_pass"];

	    return god_rays_params;
	}

	/**
	 * Extract outline parameters
	 */
	function extract_outline_params(bpy_scene) {

	    var outline_params   = {};

	    outline_params.outline_color  = bpy_scene["b4w_outline_color"];
	    outline_params.outline_factor = bpy_scene["b4w_outline_factor"];

	    return outline_params;
	}

	/**
	 * Extract glow parameters
	 */
	function extract_glow_params(bpy_scene) {

	    var glow_params   = {};
	    var glow_settings = bpy_scene["b4w_glow_settings"];

	    glow_params.small_glow_mask_coeff = glow_settings["small_glow_mask_coeff"];
	    glow_params.large_glow_mask_coeff = glow_settings["large_glow_mask_coeff"];
	    glow_params.small_glow_mask_width = glow_settings["small_glow_mask_width"];
	    glow_params.large_glow_mask_width = glow_settings["large_glow_mask_width"];

	    return glow_params;
	}

	/**
	 * Get world lights setting
	 */
	function get_world_light_set(world, sky_params) {

	    var wls = world["light_settings"];

	    var wls_params = {};
	    wls_params.environment_energy       = wls["environment_energy"];
	    wls_params.use_environment_light    = wls["use_environment_light"];
	    wls_params.environment_color        = wls["environment_color"];
	    wls_params.horizon_color            = world["horizon_color"].slice(0);
	    wls_params.zenith_color             = world["zenith_color"].slice(0);
	    wls_params.use_sky_paper            = world["use_sky_paper"];
	    wls_params.use_sky_blend            = world["use_sky_blend"];
	    wls_params.use_sky_real             = world["use_sky_real"];
	    wls_params.sky_texture_slot         = null;
	    wls_params.sky_texture_param        = null;
	    wls_params.environment_texture_slot = null;
	    wls_params.ngraph_proxy_id = "";

	    if (sky_params["render_sky"] && world["use_nodes"] && world["node_tree"]) {
	        var node_tree = world["node_tree"];
	        var uuid = world["uuid"];
	        var mat_name = world["name"];
	        var ngraph_proxy = m_nodemat.compose_ngraph_proxy(node_tree, uuid, 
	                false, world["name"] + "(World)", mat_name, "MAIN", null);

	        wls_params.ngraph_proxy_id = ngraph_proxy.id;
	    }

	    var use_environment_light = true;
	    if (wls_params.use_environment_light && wls_params.environment_color == "SKY_TEXTURE" &&
	        !(sky_params.procedural_skydome && sky_params.use_as_environment_lighting)) {
	        var tex_slot = null;
	        for (var i = 0; i < world["texture_slots"].length; i++)
	            if (world["texture_slots"][i]["texture"]["b4w_use_as_environment_lighting"] &&
	                    !world["texture_slots"][i]["texture"]["b4w_use_as_skydome"]) {
	                tex_slot = world["texture_slots"][i];
	                break;
	            }
	        if (!tex_slot) {
	            // m_print.warn("environment lighting is set to 'Sky Texture'" +
	            //         ", but there is no world texture with 'Sky Texture Usage' property set to 'ENVIRONMENT_LIGHTING'");
	            use_environment_light = false;
	        } else
	            wls_params.environment_texture_slot = tex_slot;
	    }

	    for (var i = 0; i < world["texture_slots"].length; i++)
	        if (world["texture_slots"][i]["texture"]["b4w_use_as_skydome"]) {
	            var sts = world["texture_slots"][i];
	            if (sts["texture"]["image"]) {
	                use_environment_light = true;
	                wls_params.sky_texture_slot = sts;
	                var tex_size = Math.min(cfg_lim.max_cube_map_texture_size,
	                        m_tex.calc_pot_size(sts["texture"]["image"]["size"][0] / 3));
	                wls_params.sky_texture_param = {
	                    tex_size: tex_size,
	                    blend_factor: sts["blend_factor"],
	                    horizon_factor: sts["horizon_factor"],
	                    zenith_up_factor: sts["zenith_up_factor"],
	                    zenith_down_factor: sts["zenith_down_factor"],
	                    color: sts["color"],
	                    default_value: sts["default_value"],
	                    invert: sts["invert"],
	                    use_rgb_to_intensity: sts["use_rgb_to_intensity"],
	                    blend_type: sts["blend_type"],
	                    // stencil: sts["stencil"],
	                    use_map_blend: sts["use_map_blend"],
	                    use_map_horizon: sts["use_map_horizon"],
	                    use_map_zenith_up: sts["use_map_zenith_up"],
	                    use_map_zenith_down: sts["use_map_zenith_down"]
	                };
	            }
	            break;
	        }

	    wls_params.use_environment_light = wls_params.use_environment_light ?
	            use_environment_light : false;

	    return wls_params;
	}

	function get_world_fog_set(world) {
	    var wfs = world["fog_settings"];

	    var wfs_params = {};
	    wfs_params.use_fog = wfs["use_fog"];
	    wfs_params.intensity = wfs["intensity"];
	    wfs_params.depth = wfs["depth"];
	    wfs_params.start = wfs["start"];
	    wfs_params.height = wfs["height"];
	    wfs_params.falloff = wfs["falloff"];
	    if (wfs["use_custom_color"])
	        wfs_params.color = wfs["color"].slice(0);
	    else
	        wfs_params.color = world["horizon_color"].slice(0);

	    var fog_color = wfs_params.color;
	    var fog_dens = 1.0 / wfs_params.depth;
	    wfs_params.fog_color_density = new Float32Array([fog_color[0],
	                                                 fog_color[1],
	                                                 fog_color[2],
	                                                 fog_dens]);
	    wfs_params.fog_params = new Float32Array([wfs_params.intensity,
	                                                 wfs_params.depth,
	                                                 wfs_params.start,
	                                                 wfs_params.height]);
	    return wfs_params;
	}

	/**
	 * To render dynamic grass following conditions must be met:
	 * enabled global setting
	 * at least one terrain material
	 * at least one HAIR particle system (settings) with dynamic grass enabled
	 */
	function check_dynamic_grass(bpy_scene, bpy_objects) {

	    if (!cfg_def.dynamic_grass)
	        return false;

	    switch (bpy_scene["b4w_render_dynamic_grass"]) {
	    case "OFF":
	        return false;
	    case "ON":
	        return true;
	    case "AUTO":
	        // process objects
	    }

	    var has_terrain = false;
	    var has_dyn_grass = false;

	    for (var i = 0; i < bpy_objects.length; i++) {
	        var bpy_obj = bpy_objects[i];
	        var materials = bpy_obj._object.materials;
	        for (var j = 0; j < materials.length; j++) {
	            var mat = materials[j];
	            if (mat.terrain_settings.is_terrain)
	                has_terrain = true;
	        }

	        var psystems = bpy_obj["particle_systems"];
	        for (var j = 0; j < psystems.length; j++) {
	            var pset = psystems[j]["settings"];
	            if (pset["type"] == "HAIR" && pset["b4w_dynamic_grass"])
	                has_dyn_grass = true;
	        }

	        if (has_terrain && has_dyn_grass)
	            return true;
	    }

	    return false;
	}

	function check_selectable_objects(bpy_scene, bpy_objects) {
	    if (cfg_out.outlining_overview_mode)
	        return true;

	    if (cfg_def.enable_selectable) {
	        switch (bpy_scene["b4w_enable_object_selection"]) {
	        case "OFF":
	            return false;
	        case "ON":
	            return true;
	        case "AUTO":
	            for (var i = 0; i < bpy_objects.length; i++)
	                if (bpy_objects[i]._object.render.selectable)
	                    return true;
	            return false;
	        }
	    } else
	        return false;
	}

	function check_outlining_objects(bpy_scene, bpy_objects) {
	    if (cfg_out.outlining_overview_mode)
	        return true;

	    if (cfg_def.enable_outlining)
	        switch (bpy_scene["b4w_enable_outlining"]) {
	        case "OFF":
	            return false;
	        case "ON":
	            return true;
	        case "AUTO":
	            for (var i = 0; i < bpy_objects.length; i++)
	                if (bpy_objects[i]._object.render.outlining)
	                    return true;
	            return false;
	        }
	    else
	        return false;
	}

	function check_glow_materials(bpy_scene, bpy_objects) {
	    if (cfg_def.glow_materials) {
	        switch (bpy_scene["b4w_enable_glow_materials"]) {
	        case "OFF":
	            return false;
	        case "ON":
	            return true;
	        case "AUTO":
	            for (var i = 0; i < bpy_objects.length; i++) {
	                var materials = bpy_objects[i]._object.materials;
	                for (var j = 0; j < materials.length; j++) {
	                    if (m_nodemat.check_material_glow_output(materials[j]))
	                        return true;
	                }
	            }
	            return false;
	        }
	    } else
	        return false;
	}

	function check_refraction(bpy_scene, mat_params) {
	    if (cfg_def.refractions) {
	        switch (bpy_scene["b4w_render_refractions"]) {
	        case "OFF":
	            return false;
	        case "ON":
	            return true;
	        case "AUTO":
	            return mat_params.refractions
	        }
	    } else
	        return false;
	}

	function check_xray_materials(bpy_objects) {
	    for (var i = 0; i < bpy_objects.length; i++) {
	        var materials = bpy_objects[i]._object.materials;
	        for (var j = 0; j < materials.length; j++) {
	            var mat = materials[j];
	            if (mat.render_above_all && mat.blend_mode != "OPAQUE"
	                    && mat.blend_mode != "CLIP" 
	                    && mat.blend_mode != "ALPHA_ANTIALIASING")
	                return true;
	        }
	    }
	    return false;
	}

	function check_anchor_visibility_objects(bpy_scene, bpy_empty_objs) {

	    switch (bpy_scene["b4w_enable_anchors_visibility"]) {
	    case "OFF":
	        return false;
	    case "ON":
	        return true;
	    case "AUTO":
	        for (var i = 0; i < bpy_empty_objs.length; i++) {
	            var obj = bpy_empty_objs[i]._object;
	            if (obj.anchor && obj.anchor.detect_visibility)
	                return true;
	        }
	        return false;
	    }
	}

	exports.get_graph = function(scene) {
	    return scene._render.graph;
	};

	/**
	 * Generate non-object batches for graph subscenes
	 */
	exports.generate_auxiliary_batches = function(scene, graph) {
	    m_graph.traverse(graph, function(node, attr) {
	        var subs = attr;

	        var batch = null;

	        switch (subs.type) {
	        case m_subs.POSTPROCESSING:
	            batch = m_batch.create_postprocessing_batch(subs.pp_effect);
	            break;
	        case m_subs.SSAO:
	            batch = m_batch.create_ssao_batch(subs);
	            break;
	        case m_subs.SSAO_BLUR:
	            batch = m_batch.create_ssao_blur_batch(subs);
	            break;
	        case m_subs.DEPTH_PACK:
	            batch = m_batch.create_depth_pack_batch();
	            break;
	        case m_subs.GOD_RAYS:
	            // needed for special underwater god rays
	            var water = subs.water;
	            var steps = subs.steps_per_pass;

	            batch = m_batch.create_god_rays_batch(subs.pack, water, steps);

	            break;

	        case m_subs.GOD_RAYS_COMBINE:
	            batch = m_batch.create_god_rays_combine_batch();
	            break;

	        case m_subs.MOTION_BLUR:
	            batch = m_batch.create_motion_blur_batch(subs.mb_decay_threshold);
	            break;

	        case m_subs.COC:
	            batch = m_batch.create_coc_batch(subs.coc_type);
	            break;

	        case m_subs.DOF:
	            batch = m_batch.create_dof_batch(subs);

	            var dof_power = subs.camera.dof_power;

	            if (subs.camera.dof_bokeh) {
	                // half power because of downsized subs
	                dof_power /= 2.0;
	                var subs_pp_array = m_scgraph.get_inputs_by_type(graph, subs, m_subs.POSTPROCESSING);

	                // Y_DOF_BLUR
	                m_scgraph.set_texel_size_mult(subs_pp_array[0], dof_power);
	                m_scgraph.set_texel_size_mult(subs_pp_array[1], dof_power);

	                // X_DOF_BLUR
	                subs_pp_array[0] = m_scgraph.find_input(graph, subs_pp_array[0],
	                        m_subs.POSTPROCESSING);
	                m_scgraph.set_texel_size_mult(subs_pp_array[0], dof_power);

	            } else {
	                // Y_BLUR
	                var subs_pp1 = m_scgraph.find_input(graph, subs, m_subs.POSTPROCESSING);
	                // X_BLUR
	                var subs_pp2 = m_scgraph.find_input(graph, subs_pp1, m_subs.POSTPROCESSING);
	                m_scgraph.set_texel_size_mult(subs_pp1, dof_power);
	                m_scgraph.set_texel_size_mult(subs_pp2, dof_power);
	            }

	            break;

	        case m_subs.OUTLINE:
	            batch = m_batch.create_outline_batch();
	            var subs_outline_blur_y = m_scgraph.find_input(graph, subs,
	                    m_subs.POSTPROCESSING);
	            var subs_outline_blur_x = m_scgraph.find_input(graph, subs_outline_blur_y,
	                    m_subs.POSTPROCESSING);
	            var subs_outline_extend_y = m_scgraph.find_input(graph, subs_outline_blur_x,
	                    m_subs.POSTPROCESSING);
	            var subs_outline_extend_x = m_scgraph.find_input(graph, subs_outline_extend_y,
	                    m_subs.POSTPROCESSING);

	            // set blur strength for 2 subscenes
	            m_scgraph.set_texel_size_mult(subs_outline_blur_x, subs.blur_texel_size_mult);
	            m_scgraph.set_texel_size_mult(subs_outline_blur_y, subs.blur_texel_size_mult);

	            // set extend strength for 2 subscenes
	            m_scgraph.set_texel_size_mult(subs_outline_extend_x,
	                    subs.ext_texel_size_mult * subs.outline_factor);
	            m_scgraph.set_texel_size_mult(subs_outline_extend_y,
	                    subs.ext_texel_size_mult * subs.outline_factor);

	            break;

	        case m_subs.GLOW_COMBINE:
	            batch = m_batch.create_glow_combine_batch();
	            break;

	        case m_subs.COMPOSITING:
	            batch = m_batch.create_compositing_batch();
	            break;

	        case m_subs.ANTIALIASING:
	            batch = m_batch.create_antialiasing_batch(subs);
	            break;

	        case m_subs.SMAA_RESOLVE:
	        case m_subs.SMAA_EDGE_DETECTION:
	        case m_subs.SMAA_BLENDING_WEIGHT_CALCULATION:
	        case m_subs.SMAA_NEIGHBORHOOD_BLENDING:
	            batch = m_batch.create_smaa_batch(subs.type);
	            break;

	        case m_subs.STEREO:
	            batch = m_batch.create_stereo_batch(subs.subtype);
	            break;

	        case m_subs.SKY:
	            batch = m_batch.create_cube_sky_batch(scene, subs);
	            break;

	        case m_subs.IRRADIANCE:
	            batch = m_batch.create_cube_irradiance_batch(scene, subs);
	            break;

	        case m_subs.ROUGHNESS_CONVOLUTION:
	            batch = m_batch.create_cube_roughness_convolution_batch(scene, subs);
	            break;

	        case m_subs.BRDF:
	            batch = m_batch.create_brdf_batch(scene, subs);
	            break;

	        case m_subs.LUMINANCE:
	            batch = m_batch.create_luminance_batch();

	            break;
	        case m_subs.AVERAGE_LUMINANCE:

	            batch = m_batch.create_average_luminance_batch();

	            break;
	        case m_subs.LUMINANCE_TRUNCED:
	            batch = m_batch.create_luminance_truncated_batch(subs.adaptive_bloom);

	            break;
	        case m_subs.BLOOM:
	            batch = m_batch.create_bloom_combine_batch(subs.bloom_blur_num);
	            break;
	        case m_subs.RESIZE:
	            batch = m_batch.create_postprocessing_batch("NONE");
	            break;

	        case m_subs.VELOCITY:
	            batch = m_batch.create_velocity_batch();
	            break;
	        case m_subs.ANCHOR_VISIBILITY:
	            batch = m_batch.create_anchor_visibility_batch();
	            break;
	        case m_subs.PERFORMANCE:
	            batch = m_batch.create_performance_batch();
	            break;
	        }

	        if (batch) {
	            var rb = m_subs.init_bundle(batch, m_obj_util.create_render("NONE"));
	            m_subs.append_draw_data(subs, rb);
	            m_scgraph.connect_render_targets_batch(graph, subs, batch, false);
	            check_batch_textures_number(batch);
	        }
	    });
	};

	/**
	 * Extract batches from the object and add to subscenes
	 * @methodOf scenes
	 */
	exports.append_object = function(scene, obj, copy, append_phys) {
	    var type = obj.type;

	    switch (type) {
	    case "MESH":
	    case "LINE":
	    case "WORLD":
	        var graph = scene._render.graph;
	        var obj_render = obj.render;

	        if (!m_scgraph.find_subs(graph, m_subs.SHADOW_CAST) && obj_render.shadow_receive)
	            obj_render.shadow_receive = false;

	        var subs_arr = subs_array(scene, OBJECT_SUBSCENE_TYPES);

	        if (copy || append_phys)
	            m_phy.append_object(obj, scene);

	        for (var i = 0; i < subs_arr.length; i++) {
	            var subs = subs_arr[i];
	            add_object_sub(subs, obj, graph, scene, copy);
	        }

	        break;
	    case "LAMP":
	        update_lamp_scene(obj, scene);
	        break;
	    default:
	        break;
	    }

	    // remove unused batches
	    var scene_data = m_obj_util.get_scene_data(obj, scene);
	    var batches = scene_data.batches;
	    for (var j = 0; j < batches.length; j++)
	        if (batches[j].shader == null && batches[j].type != "PHYSICS") {
	            m_obj_util.scene_data_remove_batch(scene_data, j);
	            j--;
	        }

	    m_obj_util.scene_data_set_active(obj, true, scene);
	};

	exports.init_cube_sky_dim = init_cube_sky_dim;
	function init_cube_sky_dim(scene, world_obj) {
	    if (scene && scene._render && scene._render.graph) {
	        var graph = scene._render.graph;
	        var subs_sky = m_scgraph.find_subs(scene._render.graph, m_subs.SKY);

	        if (subs_sky) {
	            var sky_cube_texture = null;

	            m_scgraph.traverse_slinks(graph, function(slink, internal, subs1, subs2) {
	                if (slink.from == "CUBEMAP" && subs1.type == m_subs.SKY && subs2.type == m_subs.SINK) {
	                    sky_cube_texture = slink.texture;
	                    return true;
	                }
	            });

	            if (sky_cube_texture) {
	                var tex_size = cfg_scs.cubemap_tex_size;
	                var sky_batch = m_batch.get_batch_by_type(world_obj, "SKY", scene);

	                if (sky_batch && sky_batch.has_nodes) {
	                    var ngraph_proxy = m_nodemat.get_ngraph_proxy_cached(sky_batch.ngraph_proxy_id);
	                    var ngraph = ngraph_proxy.graph;
	                    var node_env_tex_height = m_nodemat.get_max_env_texture_height(ngraph);

	                    if (node_env_tex_height != -1)
	                        tex_size = m_textures.calc_pot_size(node_env_tex_height / 2);

	                } else {
	                    var sc_render = scene._render;
	                    var wls = sc_render.world_light_set;
	                    var tex_param = wls.sky_texture_param;
	                    if (tex_param)
	                        tex_size = tex_param.tex_size;
	                }

	                tex_size = Math.min(tex_size, cfg_lim.max_cube_map_texture_size);
	                subs_sky.camera.width  = tex_size;
	                subs_sky.camera.height = tex_size;

	                m_tex.set_cubemap_tex_size(sky_cube_texture, tex_size);

	                update_bsdf_cube_sky_dim(scene, tex_size);

	                var subs_irradinace = m_scgraph.find_subs(scene._render.graph, m_subs.IRRADIANCE);
	                if (subs_irradinace) {
	                    subs_irradinace.camera.width  = tex_size;
	                    subs_irradinace.camera.height = tex_size;

	                    var irradiance_cube_texture = null;

	                    m_scgraph.traverse_slinks(graph, function(slink, internal, subs1, subs2) {
	                        if (slink.from == "CUBEMAP" && subs1.type == m_subs.IRRADIANCE && subs2.type == m_subs.MAIN_OPAQUE) {
	                            irradiance_cube_texture = slink.texture;
	                            return true;
	                        }
	                    });

	                    if (irradiance_cube_texture)
	                        m_tex.set_cubemap_tex_size(irradiance_cube_texture, tex_size);
	                }

	                var subs_r_convolution = m_scgraph.find_subs(scene._render.graph, m_subs.ROUGHNESS_CONVOLUTION);
	                if (subs_r_convolution) {
	                    subs_r_convolution.camera.width  = 128;
	                    subs_r_convolution.camera.height = 128;

	                    var r_convolution_cube_texture = null;

	                    m_scgraph.traverse_slinks(graph, function(slink, internal, subs1, subs2) {
	                        if (slink.from == "CUBEMAP" && subs1.type == m_subs.ROUGHNESS_CONVOLUTION && subs2.type == m_subs.MAIN_OPAQUE) {
	                            r_convolution_cube_texture = slink.texture;
	                            return true;
	                        }
	                    });

	                    if (r_convolution_cube_texture)
	                        m_tex.set_cubemap_tex_size(r_convolution_cube_texture, 128);
	                }
	            }
	        }
	    }
	}

	function update_bsdf_cube_sky_dim(scene, tex_size) {
	    var main_subscenes = subs_array(scene, [m_subs.MAIN_OPAQUE,
	                                            m_subs.MAIN_BLEND,
	                                            m_subs.MAIN_GLOW]);

	    for (var i = 0; i < main_subscenes.length; i++)
	        main_subscenes[i].bsdf_cube_sky_dim = tex_size;
	}

	exports.update_cube_sky_dim = update_cube_sky_dim;
	function update_cube_sky_dim(world, texture) {
	    var scenes_data = world.scenes_data;
	    for (var i = 0; i < scenes_data.length; i++) {
	        var scene = scenes_data[i].scene;
	        var graph = scene._render.graph;
	        var subs_sky = m_scgraph.find_subs(scene._render.graph, m_subs.SKY);

	        if (subs_sky) {
	            var sky_cube_texture = null;

	            m_scgraph.traverse_slinks(graph, function(slink, internal, subs1, subs2) {
	                if (slink.from == "CUBEMAP" && subs1.type == m_subs.SKY && subs2.type == m_subs.IRRADIANCE) {
	                    sky_cube_texture = slink.texture;
	                    return true;
	                }
	            });

	            if (sky_cube_texture) {
	                // same for cubemaps and spheremaps
	                var tex_size = m_textures.calc_pot_size(texture.height / 2);
	                tex_size = Math.min(tex_size, cfg_lim.max_cube_map_texture_size);

	                subs_sky.camera.width  = tex_size;
	                subs_sky.camera.height = tex_size;

	                m_tex.set_cubemap_tex_size(sky_cube_texture, tex_size);

	                update_bsdf_cube_sky_dim(scene, tex_size);
	            }
	        }
	    }
	}

	/**
	 * Filter batch to pass given subscene
	 */
	function add_object_sub(subs, obj, graph, bpy_scene, copy) {
	    switch(subs.type) {
	    case m_subs.MAIN_OPAQUE:
	        add_object_subs_main(subs, obj, graph, "OPAQUE", bpy_scene, copy);
	        break;
	    case m_subs.MAIN_BLEND:
	        add_object_subs_main(subs, obj, graph, "BLEND", bpy_scene, copy);
	        break;
	    case m_subs.MAIN_XRAY:
	        add_object_subs_main(subs, obj, graph, "XRAY", bpy_scene, copy);
	        break;
	    case m_subs.MAIN_GLOW:
	        add_object_subs_main(subs, obj, graph, "GLOW", bpy_scene, copy);
	        break;
	    case m_subs.MAIN_PLANE_REFLECT:
	    case m_subs.MAIN_CUBE_REFLECT:
	        add_object_subs_reflect(subs, obj, graph, false, bpy_scene, copy);
	        break;
	    case m_subs.MAIN_PLANE_REFLECT_BLEND:
	    case m_subs.MAIN_CUBE_REFLECT_BLEND:
	        add_object_subs_reflect(subs, obj, graph, true, bpy_scene, copy);
	        break;
	    case m_subs.SHADOW_RECEIVE:
	        add_object_subs_shadow_receive(subs, obj, graph, bpy_scene, copy);
	        break;
	    case m_subs.SHADOW_CAST:
	        add_object_subs_shadow(subs, obj, graph, bpy_scene, copy);
	        break;
	    case m_subs.COLOR_PICKING:
	        add_object_subs_color_picking(subs, obj, graph, bpy_scene, copy);
	        break;
	    case m_subs.COLOR_PICKING_XRAY:
	        add_object_subs_color_picking(subs, obj, graph, bpy_scene, copy);
	        break;
	    case m_subs.OUTLINE_MASK:
	        add_object_subs_outline_mask(subs, obj, graph, bpy_scene, copy);
	        break;
	    case m_subs.GRASS_MAP:
	        add_object_subs_grass_map(subs, obj, bpy_scene, copy);
	        break;
	    case m_subs.DEBUG_VIEW:
	        add_object_subs_debug_view(subs, obj, graph, bpy_scene, copy);
	        break;
	    default:
	        break;
	    }
	}

	/**
	 * Add object to main scene
	 */
	function add_object_subs_main(subs, obj, graph, main_type, scene, copy) {

	    var obj_render = obj.render;
	    var sc_data = m_obj_util.get_scene_data(obj, scene);

	    // divide obj by batches
	    var batches = sc_data.batches;
	    for (var i = 0; i < batches.length; i++) {

	        var batch = batches[i];

	        if (batch.shadow_cast_only || batch.reflexible_only)
	            continue;

	        if (batch.type != "MAIN" && batch.type != "NODES_GLOW"
	                && batch.type != "PARTICLES" && batch.type != "LINE")
	            continue;

	        if (!(batch.subtype == "OPAQUE" && main_type == "OPAQUE" ||
	                batch.subtype == "BLEND" && main_type == "BLEND" ||
	                batch.subtype == "XRAY" && main_type == "XRAY" ||
	                batch.type == "NODES_GLOW" && main_type == "GLOW"))
	            continue;

	        if (!copy) {
	            update_batch_subs(batch, subs, obj, graph, main_type, scene);
	            if (!m_batch.update_shader(batch)) {
	                if (m_version.type() === "DEBUG") {
	                    m_batch.apply_shader(batch, "error.glslv", "error.glslf");
	                    m_batch.update_shader(batch);
	                } else
	                    continue;
	            }
	        }
	        var rb = m_subs.init_bundle(batch, obj_render, sc_data.batch_world_bounds[i]);
	        m_subs.append_draw_data(subs, rb);

	        m_scgraph.connect_render_targets_batch(graph, subs, batch, false);
	        check_batch_textures_number(batch);
	    }
	}

	function assign_lod_transition_dirs(batch) {
	    if (batch.lod_settings.use_smoothing)
	        m_batch.set_batch_directive(batch, "USE_LOD_SMOOTHING", 1);
	}

	function update_batch_subs(batch, subs, obj, graph, main_type, bpy_scene) {
	    var obj_render = obj.render;
	    var sc_render = bpy_scene._render;
	    var scene_data = m_obj_util.get_scene_data(obj, bpy_scene);

	    var shadow_usage = "NO_SHADOWS";
	    var subs_cast_arr = subs_array(bpy_scene, [m_subs.SHADOW_CAST]);
	    if (subs_cast_arr.length && batch.shadow_receive) {
	        switch (main_type) {
	        case "OPAQUE":
	            shadow_usage = "SHADOW_MAPPING_OPAQUE";
	            break;
	        case "BLEND":
	        case "XRAY":
	            shadow_usage = "SHADOW_MAPPING_BLEND";
	            break;
	        case "COLOR_ID":
	        case "REFLECT":
	        case "GLOW":
	            shadow_usage = "NO_SHADOWS";
	            break;
	        case "SHADOW":
	            shadow_usage = "SHADOW_MASK_GENERATION";
	            break;
	        default:
	            m_util.panic("Wrong subscene type");
	        }

	        for (var i = 0; i < subs_cast_arr.length; i++)
	            m_batch.assign_shadow_receive_dirs(batch, bpy_scene._render.shadow_params, subs_cast_arr[i]);
	    }
	    var blur_samples = "NO_SOFT_SHADOWS";
	    if (sc_render.shadow_params && sc_render.shadow_params.soft_shadows)
	        switch(cfg_def.shadow_blur_samples) {
	        case "16x":
	            blur_samples = "POISSON_X_16";
	            break;
	        case "8x":
	            blur_samples = "POISSON_X_8";
	            break;
	        case "4x":
	            blur_samples = "POISSON_X_4";
	            break;
	        }
	    var shaders_info = batch.shaders_info;

	    m_shaders.set_directive(shaders_info, "SHADOW_USAGE", shadow_usage);
	    m_shaders.set_directive(shaders_info, "POISSON_DISK_NUM", blur_samples);

	    assign_lod_transition_dirs(batch);

	    if (batch.dynamic_grass) {
	        var subs_grass_map = m_scgraph.find_subs(graph, m_subs.GRASS_MAP);
	        if (subs_grass_map)
	            prepare_dynamic_grass_batch(batch, subs_grass_map, obj_render);
	    }

	    var cam = subs.camera;
	    set_batch_cam_type(shaders_info, cam);

	    if ((batch.type == "SHADOW" || main_type == "COLOR_ID") && !batch.has_nodes)
	        return;

	    var num_lights = subs.num_lights;
	    m_shaders.set_directive(shaders_info, "NUM_LIGHTS", num_lights);
	    var num_lfac = num_lights % 2 == 0 ? num_lights / 2:
	                                         Math.floor(num_lights / 2) + 1;
	    m_shaders.set_directive(shaders_info, "NUM_LFACTORS", num_lfac);

	    m_shaders.set_directive(shaders_info, "REFLECTION_PASS", "REFL_PASS_NONE");

	    m_shaders.set_directive(shaders_info, "SSAO_ONLY", 0);

	    var wp = sc_render.water_params;
	    if (wp) {
	        m_shaders.set_directive(shaders_info, "WATER_EFFECTS", 1);
	        m_shaders.set_directive(shaders_info, "WAVES_HEIGHT", m_shaders.glsl_value(wp.waves_height));
	        m_shaders.set_directive(shaders_info, "WAVES_LENGTH", m_shaders.glsl_value(wp.waves_length));
	        m_shaders.set_directive(shaders_info, "WATER_LEVEL", m_shaders.glsl_value(wp.water_level));
	    }

	    if (subs.caustics && batch.caustics) {
	        m_shaders.set_directive(shaders_info, "CAUSTICS", 1);

	        var sh_params = sc_render.shadow_params;
	        if (sh_params) {
	            var ltypes = sh_params.lamp_types;
	            var sun_num = 0;
	            for (var i = 0; i < ltypes.length; i++)
	                if (ltypes[i] == "SUN")
	                    sun_num = i;

	            m_shaders.set_directive(shaders_info, "SUN_NUM", sun_num);
	        }

	        m_shaders.set_directive(shaders_info, "CAUST_SCALE", m_shaders.glsl_value(subs.caust_scale));
	        m_shaders.set_directive(shaders_info, "CAUST_SPEED", m_shaders.glsl_value(subs.caust_speed, 2));
	        m_shaders.set_directive(shaders_info, "CAUST_BRIGHT", m_shaders.glsl_value(subs.caust_brightness));
	    }

	    var subs_cube_refl = scene_data.cube_refl_subs;
	    var subs_plane_refl = scene_data.plane_refl_subs;
	    var subs_sky = m_scgraph.find_subs(graph, m_subs.SKY);

	    if (batch.texture_names.indexOf("u_mirrormap") !== -1) {
	        m_shaders.set_directive(shaders_info, "REFLECTION_TYPE", "REFL_MIRRORMAP");
	    } else if (batch.reflective && subs_cube_refl) {

	        if (!sc_render.reflection_params.has_reflexible) {
	            subs_cube_refl.force_do_not_render = true;

	            var subs_irradinace = m_scgraph.find_subs(graph, m_subs.IRRADIANCE);
	            var subs_r_convolution = m_scgraph.find_subs(graph, m_subs.ROUGHNESS_CONVOLUTION);

	            if (subs_irradinace && subs_r_convolution) {
	                var tex_irradiance = subs_irradinace.camera.color_attachment;
	                m_batch.append_texture(batch, tex_irradiance, "u_cube_irradiance");

	                var tex_r_convolution = subs_r_convolution.camera.color_attachment;
	                m_batch.append_texture(batch, tex_r_convolution, "u_cube_r_convolution");

	                m_shaders.set_directive(shaders_info, "REFLECTION_TYPE", "REFL_PBR");
	            } else {
	                var subs_sky = m_scgraph.find_subs(graph, m_subs.SKY);
	                if (subs_sky) {
	                    var tex = subs_sky.camera.color_attachment;
	                } else
	                    var tex = subs_cube_refl.camera.color_attachment;

	                m_batch.append_texture(batch, tex, "u_cube_reflection");
	                m_shaders.set_directive(shaders_info, "REFLECTION_TYPE", "REFL_CUBE");
	            }

	        } else {
	            var cube_refl_tex = subs_cube_refl.camera.color_attachment;
	            m_batch.append_texture(batch, cube_refl_tex, "u_cube_reflection");
	            m_shaders.set_directive(shaders_info, "REFLECTION_TYPE", "REFL_CUBE");
	        }

	    } else if (batch.reflective && subs_plane_refl) {
	        for (var i = 0; i < subs_plane_refl.length; i++) {
	            var tex = subs_plane_refl[i].camera.color_attachment;
	            m_batch.append_texture(batch, tex, "u_plane_reflection");
	            m_shaders.set_directive(shaders_info, "REFLECTION_TYPE", "REFL_PLANE");
	        }
	    } else {
	        m_shaders.set_directive(shaders_info, "REFLECTION_TYPE", "REFL_NONE");
	    }

	    if (subs_sky) {
	        if (batch.draw_proc_sky) {
	            var tex = subs_sky.camera.color_attachment;
	            m_batch.append_texture(batch, tex, "u_sky");
	        } else if (subs_sky.procedural_skydome) {
	            // by link
	            batch.cube_fog = subs_sky.cube_fog;
	            m_shaders.set_directive(shaders_info, "PROCEDURAL_FOG", 1);
	        }
	    } else {
	        m_shaders.set_directive(shaders_info, "PROCEDURAL_FOG", 0);
	    }

	    var wls = sc_render.world_light_set;
	    if (wls.use_environment_light) {
	        m_shaders.set_directive(shaders_info, "USE_ENVIRONMENT_LIGHT", 1);
	        if (wls.environment_color == "SKY_TEXTURE") {
	            if (wls.environment_texture_slot) {
	                var bpy_tex = wls.environment_texture_slot["texture"];
	                var tex = m_tex.get_batch_texture(wls.environment_texture_slot);
	                m_batch.append_texture(batch, tex, "u_sky_texture", bpy_tex["name"]);
	            } else if (subs_sky) {
	                var tex = subs_sky.camera.color_attachment;
	                m_batch.append_texture(batch, tex, "u_sky_texture");
	            }

	            m_shaders.set_directive(shaders_info, "SKY_TEXTURE", 1);
	        } else if (wls.environment_color == "SKY_COLOR")
	            m_shaders.set_directive(shaders_info, "SKY_COLOR", 1);
	    }

	    var wfs = sc_render.world_fog_set;
	    if (wfs.use_fog) {
	        m_shaders.set_directive(shaders_info, "USE_FOG", 1);
	        m_shaders.set_directive(shaders_info, "FOG_TYPE", wfs.falloff);
	    }

	    if (batch.refractive && batch.blend) {
	        // TODO: Too many directives. Refactoring needed
	        if (cfg_def.depth_tex_available)
	            m_shaders.set_directive(shaders_info, "USE_REFRACTION_CORRECTION", 1);
	        if (batch.type == "MAIN" && batch.has_nodes
	                || batch.type == "NODES_GLOW") {
	            m_shaders.set_directive(shaders_info, "REFRACTIVE", 1);
	            if (sc_render.refractions)
	                m_shaders.set_directive(shaders_info, "USE_REFRACTION", 1);
	            else
	                m_shaders.set_directive(shaders_info, "USE_REFRACTION", 0);
	        } else {
	            if (sc_render.refractions)
	                m_shaders.set_directive(shaders_info, "REFRACTIVE", 1);
	            else
	                m_shaders.set_directive(shaders_info, "REFRACTIVE", 0);
	        }
	        if (sc_render.materials_params.refractions || sc_render.refractions)
	            m_shaders.set_directive(shaders_info, "HAS_REFRACT_TEXTURE", 1);
	    } else {
	        m_shaders.set_directive(shaders_info, "REFRACTIVE", 0);
	        m_shaders.set_directive(shaders_info, "USE_REFRACTION", 0);
	        m_shaders.set_directive(shaders_info, "USE_REFRACTION_CORRECTION", 0);
	    }

	    if (batch.water) {
	        if (cfg_def.shore_smoothing && batch.water_shore_smoothing
	                && m_scgraph.find_subs(graph, m_subs.DEPTH_PACK)) {
	            m_shaders.set_directive(shaders_info, "SHORE_SMOOTHING", 1);
	        } else
	            m_shaders.set_directive(shaders_info, "SHORE_SMOOTHING", 0);

	        if (batch.water_dynamic && wp && wp.waves_height)
	            m_shaders.set_directive(shaders_info, "DYNAMIC", 1);
	        else
	            m_shaders.set_directive(shaders_info, "DYNAMIC", 0);
	    }

	    if (batch.type == "PARTICLES")
	        m_shaders.set_directive(shaders_info, "COLOR_RAMP_LENGTH",
	                batch.particles_data.color_ramp_length);

	    // NOTE: temporary disabled T2X mode due to artifacts with blend objects
	    //if (cfg_def.smaa && !m_cfg.context.alpha)
	    //    m_shaders.set_directive(shaders_info, "SMAA_JITTER", 1);

	    // update scenes graph according to RTT arrangement
	    if (!batch.forked_batch) {
	        var textures = batch.textures;
	        for (var j = 0; j < textures.length; j++) {
	            var tex = textures[j];

	            if (tex.source == "SCENE")
	                for (var k = 0; k < _scenes.length; k++) {
	                    var scene_k = _scenes[k];
	                    var rtt = _scenes[k]._render_to_textures;
	                    for (var l = 0; l < rtt.length; l++)
	                        if (rtt[l] == tex)
	                            m_graph.append_edge_attr(_scenes_graph, scene_k, bpy_scene, null);
	                }
	        }
	    }
	}

	function set_batch_cam_type(shaders_info, subs_cam) {
	    if (subs_cam.type == m_cam.TYPE_ORTHO ||
	            subs_cam.type == m_cam.TYPE_ORTHO_ASPECT ||
	            subs_cam.type == m_cam.TYPE_ORTHO_ASYMMETRIC)
	        m_shaders.set_directive(shaders_info, "CAMERA_TYPE", "CAM_TYPE_ORTHO");
	    else
	        m_shaders.set_directive(shaders_info, "CAMERA_TYPE", "CAM_TYPE_PERSP");
	}

	function check_batch_textures_number(batch) {
	    if (batch.textures.length > MAX_BATCH_TEXTURES)
	        m_print.warn(batch.type, "too many textures used - " +
	            batch.textures.length + " (max " + MAX_BATCH_TEXTURES +
	            "), materials \"" + batch.material_names.join(", ") + "\"");
	}

	function prepare_dynamic_grass_batch(batch, subs_grass_map, obj_render) {
	    // by link
	    batch.grass_map_dim = subs_grass_map.grass_map_dim;

	    var low = subs_grass_map.grass_map_dim[0];
	    var high = subs_grass_map.grass_map_dim[1];
	    var size = subs_grass_map.grass_map_dim[2];

	    var bb = obj_render.bb_local;
	    var bb_max_size = Math.max(bb.max_x - bb.min_x, bb.max_y - bb.min_y);

	    if (size == 0)
	        size = bb_max_size;
	    else
	        size = Math.max(size, bb_max_size);

	    // store back, affects batch and subs grass map
	    subs_grass_map.grass_map_dim[2] = size;

	    // update grass map camera
	    var cam = subs_grass_map.camera;
	    m_cam.set_frustum2(cam, size/2, size/2, -high, -low);
	    m_cam.set_projection(cam, false);

	    var bsize = batch.grass_size || 0;
	    if (bsize == 0)
	        bsize = bb_max_size;
	    else
	        bsize = Math.max(bsize, bb_max_size);
	    batch.grass_size = bsize;
	}

	/**
	 * Add object to main scene
	 */
	function add_object_subs_shadow_receive(subs, obj, graph, scene, copy) {
	    // divide obj by batches
	    var sc_data = m_obj_util.get_scene_data(obj, scene);
	    var batches = sc_data.batches;

	    for (var i = 0; i < batches.length; i++) {
	        var batch = batches[i];

	        if (batch.type != "SHADOW" || batch.subtype != "RECEIVE" ||
	                !batch.shadow_receive)
	            continue;

	        if (!copy) {
	            update_batch_subs(batch, subs, obj, graph, "SHADOW", scene);
	            if (!m_batch.update_shader(batch))
	                continue;
	        }

	        var rb = m_subs.init_bundle(batch, obj.render, sc_data.batch_world_bounds[i]);
	        m_subs.append_draw_data(subs, rb);

	        m_scgraph.connect_render_targets_batch(graph, subs, batch, false);
	        check_batch_textures_number(batch);
	    }
	}

	function add_object_subs_shadow(subs, obj, graph, scene, copy) {
	    var update_needed = false;
	    var obj_render = obj.render;
	    var sc_data = m_obj_util.get_scene_data(obj, scene);
	    var batches = sc_data.batches;

	    var subs_grass_map = m_scgraph.find_subs(graph, m_subs.GRASS_MAP);

	    for (var i = 0; i < batches.length; i++) {
	        var batch = batches[i];

	        if (batch.type != "SHADOW")
	            continue;

	        if (batch.subtype != "CAST")
	            continue;

	        update_needed = true;

	        if (!copy) {
	            assign_lod_transition_dirs(batch);

	            var num_lights = subs.num_lights;
	            m_batch.set_batch_directive(batch, "NUM_LIGHTS", num_lights);
	            var num_lfac = num_lights % 2 == 0 ? num_lights / 2:
	                                                 Math.floor(num_lights / 2) + 1;
	            m_batch.set_batch_directive(batch, "NUM_LFACTORS", num_lfac);

	            set_batch_cam_type(batch.shaders_info, subs.camera);

	            m_shaders.set_directive(batch.shaders_info, "SHADOW_USAGE", "SHADOW_CASTING");

	            if (batch.dynamic_grass && subs_grass_map)
	                prepare_dynamic_grass_batch(batch, subs_grass_map, obj_render);

	            m_batch.set_batch_directive(batch, "SHADOW_TEX_RES",
	                    m_shaders.glsl_value(
	                    scene._render.shadow_params.csm_resolution));

	            if (!m_batch.update_shader(batch))
	                continue;
	        }

	        // NOTE: dynamic grass shadow casting requires update after camera transformations
	        if (batch.dynamic_grass)
	            scene._render.shadow_params.dynamic_grass_cast = true;

	        var rb = m_subs.init_bundle(batch, obj_render, sc_data.batch_world_bounds[i]);
	        m_subs.append_draw_data(subs, rb);
	        
	        m_scgraph.connect_render_targets_batch(graph, subs, batch, false);
	        check_batch_textures_number(batch);
	    }

	    if (update_needed) {
	        var sh_params = scene._render.shadow_params;
	        var subs_main = m_scgraph.find_subs(graph, m_subs.MAIN_OPAQUE);
	        update_subs_shadow(subs, scene, subs_main.camera, sh_params,
	                           true);
	    }
	}

	function add_object_subs_reflect(subs, obj, graph, is_blend_subs, scene, copy) {
	    var obj_render = obj.render;
	    var sc_data = m_obj_util.get_scene_data(obj, scene);
	    var batches = sc_data.batches;

	    for (var i = 0; i < batches.length; i++) {
	        var batch = batches[i];

	        if (batch.type != "MAIN" && batch.type != "PARTICLES" && batch.type != "LINE")
	            continue;

	        if (batch.subtype != "REFLECT")
	            continue;

	        if (batch.blend != is_blend_subs)
	            continue;

	        // do not render reflected object on itself
	        if (subs.type == m_subs.MAIN_PLANE_REFLECT ||
	                subs.type == m_subs.MAIN_PLANE_REFLECT_BLEND) {
	            var refl_id = get_plane_refl_id_by_subs(scene, subs);
	            if (refl_id == obj_render.plane_reflection_id)
	                continue;
	        } else {
	            var refl_id = get_cube_refl_id_by_subs(scene, subs);
	            if (refl_id == obj_render.cube_reflection_id)
	                continue;
	        }

	        if (!copy) {
	            update_batch_subs(batch, subs, obj, graph, "REFLECT", scene);
	            var shaders_info = batch.shaders_info;

	            m_shaders.set_directive(shaders_info, "WATER_EFFECTS", 0);

	            if (subs.type == m_subs.MAIN_PLANE_REFLECT ||
	                    subs.type == m_subs.MAIN_PLANE_REFLECT_BLEND)
	                m_shaders.set_directive(shaders_info, "REFLECTION_PASS", "REFL_PASS_PLANE");
	            else
	                m_shaders.set_directive(shaders_info, "REFLECTION_PASS", "REFL_PASS_CUBE");

	            // disable normalmapping in shader for optimization purposes
	            m_shaders.set_directive(shaders_info, "TEXTURE_NORM", 0);

	            if (!m_batch.update_shader(batch)) {
	                if (m_version.type() === "DEBUG") {
	                    m_batch.apply_shader(batch, "error.glslv", "error.glslf");
	                    m_batch.update_shader(batch);
	                } else
	                    continue;
	            }
	        }

	        var rb = m_subs.init_bundle(batch, obj_render, sc_data.batch_world_bounds[i]);
	        m_subs.append_draw_data(subs, rb);

	        m_scgraph.connect_render_targets_batch(graph, subs, batch, false);
	        check_batch_textures_number(batch);

	        // NOTE: temoporary disabled T2X mode due to artifacts with blend objects
	        //if (cfg_def.smaa && !m_cfg.context.alpha)
	        //    m_shaders.set_directive(shaders_info, "SMAA_JITTER", 1);
	    }
	}

	exports.schedule_shadow_update = schedule_shadow_update;
	/**
	 * Schedule update of shadow subscenes on given bpy scene.
	 * @methodOf scenes
	 */
	function schedule_shadow_update(bpy_scene) {
	    bpy_scene._render.need_shadow_update = true;
	}

	/**
	 * Update all shadow subscenes on active scene
	 */
	function update_shadow_subscenes(bpy_scene) {

	    reset_shadow_cam_vm(bpy_scene);
	    // also update shadow subscene camera

	    // TODO: use subs_array(bpy_scene, [m_subs.MAIN_OPAQUE])
	    // bcz there could be more one MAIN_OPAQUE
	    var subs_main = get_subs(bpy_scene, m_subs.MAIN_OPAQUE);

	    var graph = bpy_scene._render.graph;
	    var recalc_z_bounds = true;
	    var sh_params = bpy_scene._render.shadow_params;

	    m_graph.traverse(graph, function(node, attr) {
	        var subs = attr;
	        if (subs.type === m_subs.SHADOW_CAST) {
	            update_subs_shadow(subs, bpy_scene, subs_main.camera, sh_params,
	                               recalc_z_bounds);
	            recalc_z_bounds = false;
	        }
	    });
	}

	function enable_outline_draw(scene) {
	    var graph = scene._render.graph;
	    m_graph.traverse(graph, function(node, subs) {
	        if (subs.type === m_subs.OUTLINE)
	            subs.draw_outline_flag = 1;
	    });
	}

	exports.update_shadow_billboard_view = function(cam_main, graph) {
	    m_graph.traverse(graph, function(node, attr) {
	        var subs = attr;
	        if (subs.type === m_subs.SHADOW_CAST) {
	            // NOTE: inherit light camera world_tsr from main camera - used in LOD 
	            // calculations, cylindrical billboarding shadows and dynamic grass shadows
	            m_tsr.copy(cam_main.world_tsr, subs.camera.world_tsr);
	            // NOTE: inherit view_tsr from main camera
	            m_tsr.copy(cam_main.view_tsr,
	                    subs.camera.shadow_cast_billboard_view_tsr);
	        }
	    });
	};

	/**
	 * Update shadow subscene camera based on main subscene light.
	 * uses _vec3_tmp, _mat4_tmp, _corners_cache
	 */
	function update_subs_shadow(subs, scene, cam_main, sh_params,
	                            recalc_z_bounds) {

	    if (subs.draw_data.length == 0)
	        return;

	    var cam = subs.camera;

	    // NOTE: inherit light camera world_tsr from main camera - used in LOD 
	    // calculations, cylindrical billboarding shadows and dynamic grass shadows
	    m_tsr.copy(cam_main.world_tsr, cam.world_tsr);

	    // NOTE: inherit view_tsr from main camera
	    m_tsr.copy(cam_main.view_tsr, cam.shadow_cast_billboard_view_tsr);
	    if (sh_params.lamp_types[subs.shadow_lamp_index] === "SUN"
	            || sh_params.lamp_types[subs.shadow_lamp_index] === "HEMI") {
	        // determine camera frustum for shadow casting
	        var bb_world = get_shadow_casters_bb(subs, cam_main.world_tsr, _bb_tmp);
	        var bb_corners = m_bounds.extract_bb_corners(bb_world, _corners_cache);
	        // transform bb corners to light view space
	        m_util.positions_multiply_matrix(bb_corners, cam.view_matrix, bb_corners);

	        if (sh_params.enable_csm) {
	            // calculate world center and radius
	            var center = m_vec3.copy(cam_main.csm_centers[subs.csm_index], _vec3_tmp);
	            var main_view_inv = m_mat4.invert(cam_main.view_matrix, _mat4_tmp);

	            m_util.positions_multiply_matrix(center, main_view_inv, center);

	            // transform sphere center to light view space
	            m_util.positions_multiply_matrix(center, cam.view_matrix, center);

	            var radius = cam_main.csm_radii[subs.csm_index];

	            // get minimum z value for bounding box from light camera for all casters
	            if (recalc_z_bounds) {
	                _shadow_cast_min_z = 0;
	                _shadow_cast_max_z = -Infinity;
	                for (var i = 2; i < bb_corners.length; i+=3) {
	                    _shadow_cast_min_z = Math.min(_shadow_cast_min_z, bb_corners[i]);
	                    _shadow_cast_max_z = Math.max(_shadow_cast_max_z, bb_corners[i]);
	                }
	            }

	            var bb_view = _bb_tmp;
	            bb_view.max_x = center[0] + radius;
	            bb_view.max_y = center[1] + radius;
	            bb_view.max_z = _shadow_cast_max_z;

	            bb_view.min_x = center[0] - radius;
	            bb_view.min_y = center[1] - radius; 
	            bb_view.min_z = _shadow_cast_min_z;
	        } else {
	            var bb_view = _bb_tmp;
	            var optimal_angle = get_optimal_bb_and_angle(bb_corners, bb_view);
	            if (optimal_angle > 0) {
	                var rot_mat = m_mat4.identity(_mat4_tmp);
	                m_mat4.rotate(rot_mat, optimal_angle, m_util.AXIS_MZ, rot_mat);
	                m_mat4.multiply(rot_mat, cam.view_matrix, cam.view_matrix);
	                m_tsr.from_mat4(cam.view_matrix, cam.view_tsr);
	            }
	            bb_view = correct_bb_proportions(bb_view);

	            // NOTE: it's not optimal method to update shadow cam quat
	            // on shadow receive subs
	            update_shadow_receive_subs(subs, scene._render.graph);
	        }
	        m_cam.set_frustum_asymmetric(cam, bb_view.min_x, bb_view.max_x,
	                bb_view.min_y, bb_view.max_y, -bb_view.max_z, -bb_view.min_z);
	        m_cam.set_projection(cam, false);

	    } else if (sh_params.lamp_types[subs.shadow_lamp_index] === "SPOT"
	            || sh_params.lamp_types[subs.shadow_lamp_index] === "POINT") {
	        m_cam.set_projection(cam, false);
	    }
	}

	exports.update_shadow_receive_subs = update_shadow_receive_subs;
	function update_shadow_receive_subs(subs, graph) {
	    var cam_cast = subs.camera;
	    var outputs = m_scgraph.get_outputs(graph, subs);
	    for (var i = 0; i < outputs.length; i++) {
	        var output = outputs[i];

	        // NOTE: it's for debug_subs
	        if (output.type != m_subs.MAIN_OPAQUE && output.type != m_subs.SHADOW_RECEIVE
	                && output.type != m_subs.MAIN_BLEND && output.type != m_subs.MAIN_XRAY)
	            continue;

	        if (cfg_def.mac_os_shadow_hack)
	            output.v_light_tsr.set(cam_cast.view_tsr, subs.shadow_lamp_index * 9);
	        else {
	            var view_trans = m_tsr.get_trans_view(cam_cast.view_tsr);
	            var scale = m_tsr.get_scale(cam_cast.view_tsr);
	            var quat = m_tsr.get_quat_view(cam_cast.view_tsr);

	            m_vec4.set(view_trans[0], view_trans[1], view_trans[2], scale, _vec4_tmp);
	            output.v_light_ts.set(_vec4_tmp, subs.shadow_lamp_index * 4);
	            output.v_light_r.set(quat, subs.shadow_lamp_index * 4);
	        }
	    }
	}
	/**
	 * Get optimal bounding box in light space (smallest cross
	 * sectional area seen from the light source) and angle for light rotation
	 * uses _mat4_tmp, _corners_cache2, _bb_tmp2
	 * @methodOf scenes
	 */
	function get_optimal_bb_and_angle(bb_corners, bb_dest) {
	    var rot_corners = _corners_cache2;
	    rot_corners.set(bb_corners);

	    var angle_delta = MAX_OPTIMAL_BB_ANGLE / (OPTIMAL_BB_COUNT - 1);

	    var rot_mat = m_mat4.identity(_mat4_tmp);
	    m_mat4.rotate(rot_mat, angle_delta, m_util.AXIS_MZ, rot_mat);

	    var min = -1;
	    var min_index = -1;
	    for (var i = 0; i < OPTIMAL_BB_COUNT; i++) {
	        var bb_all = m_bounds.bb_from_coords(rot_corners, 0, rot_corners.length, _bb_tmp2);
	        var S = (bb_all.max_x - bb_all.min_x) * (bb_all.max_y - bb_all.min_y);

	        // use threshold to avoid calculation inaccuracy
	        if (min == -1 || min - S > OPTIMAL_BB_THRESHOLD) {
	            min = S;
	            min_index = i;
	            m_bounds.copy_bb(bb_all, bb_dest);
	        }
	        m_util.positions_multiply_matrix(rot_corners, rot_mat, rot_corners);
	    }

	    return min_index * angle_delta;
	}

	function correct_bb_proportions(bb) {
	    var x = bb.max_x - bb.min_x;
	    var y = bb.max_y - bb.min_y;

	    if (x && y) {
	        var diff = Math.abs(x - y) / 2;
	        if (x/y > MAX_SHADOW_CAST_BB_PROPORTION) {
	            bb.max_y += diff;
	            bb.min_y -= diff;
	        } else if (y/x > MAX_SHADOW_CAST_BB_PROPORTION) {
	            bb.max_x += diff;
	            bb.min_x -= diff;
	        }
	    }

	    bb.max_x += SHADOW_MAP_EPSILON_XY;
	    bb.max_y += SHADOW_MAP_EPSILON_XY;
	    bb.max_z += SHADOW_MAP_EPSILON_Z;
	    bb.min_x -= SHADOW_MAP_EPSILON_XY;
	    bb.min_y -= SHADOW_MAP_EPSILON_XY;
	    bb.min_z -= SHADOW_MAP_EPSILON_Z;

	    return bb;
	}

	/**
	 * uses _vec3_tmp2, _quat4_tmp, _bb_tmp2
	 */
	function get_shadow_casters_bb(subs, main_cam_tsr, dest) {
	    m_bounds.zero_bounding_box(dest);

	    for (var i = 0; i < subs.draw_data.length; i++) {
	        var bundles = subs.draw_data[i].bundles;
	        for (var j = 0; j < bundles.length; j++) {
	            // not all casters will be unique

	            var batch = bundles[j].batch;
	            var render = bundles[j].obj_render;

	            // trying to reproduce shader logic regarding the placing of instances
	            if (batch.dynamic_grass) {
	                var main_cam_quat = m_tsr.get_quat(main_cam_tsr, _quat4_tmp);
	                var main_cam_view = m_vec3.transformQuat(m_util.AXIS_MZ, 
	                        main_cam_quat, _vec3_tmp2);

	                var sin_alpha = - main_cam_view[0];
	                var cos_alpha = main_cam_view[1];
	                var main_camera_eye = m_tsr.get_trans(main_cam_tsr, _vec3_tmp2);

	                // get world position of base point ([0.0, 0.0] (left lower) on UV)
	                var base_x = main_camera_eye[0] - batch.grass_size * (1 + sin_alpha) / 2;
	                var base_y = main_camera_eye[1] - batch.grass_size * (1 - cos_alpha) / 2;

	                // considering the height of a grass instance
	                var bb_world = m_bounds.bounding_box_transform(batch.bounds_local.bb, 
	                        render.world_tsr, _bb_tmp2);
	                var grass_height = bb_world.max_z - bb_world.min_z;

	                var bbox = _bb_tmp2;
	                bbox.min_x = base_x;
	                bbox.min_y = base_y;
	                bbox.min_z = batch.grass_map_dim[0] - grass_height;
	                bbox.max_x = base_x + batch.grass_size;
	                bbox.max_y = base_y + batch.grass_size;
	                bbox.max_z = batch.grass_map_dim[1] + grass_height;
	            } else 
	                var bbox = render.bb_world;

	            if (i == 0 && j == 0)
	                m_bounds.copy_bb(bbox, dest);
	            else
	                m_bounds.expand_bounding_box(dest, bbox);
	        }
	    }

	    return dest;
	}

	exports.get_csm_borders = get_csm_borders;
	/**
	 * @methodOf scenes
	 */
	function get_csm_borders(scene, cam) {
	    var shs = scene._render.shadow_params;

	    var rslt = new Float32Array(shs.csm_num);
	    for (var i = 0; i < shs.csm_num; i++)
	        rslt[i] = m_cam.csm_far_plane(shs, cam, i);

	    return rslt;
	}

	function add_object_subs_color_picking(subs, obj, graph, scene, copy) {

	    var obj_render = obj.render;
	    var sc_data = m_obj_util.get_scene_data(obj, scene);
	    var batches = sc_data.batches;

	    for (var i = 0; i < batches.length; i++) {
	        var batch = batches[i];

	        if (batch.type != "COLOR_ID")
	            continue;

	        if (!(subs.type == m_subs.COLOR_PICKING && batch.subtype == "COLOR_ID" ||
	                subs.type == m_subs.COLOR_PICKING_XRAY && batch.subtype == "COLOR_ID_XRAY"))
	            continue;

	        if (!copy) {
	            update_batch_subs(batch, subs, obj, graph, "COLOR_ID", scene);
	            m_batch.set_batch_directive(batch, "USE_OUTLINE", 0);
	            if (!m_batch.update_shader(batch))
	                continue;
	        }

	        var rb = m_subs.init_bundle(batch, obj_render, sc_data.batch_world_bounds[i]);
	        m_subs.append_draw_data(subs, rb);
	    }
	}

	function add_object_subs_debug_view(subs, obj, graph, scene, copy) {

	    var obj_render = obj.render;
	    var sc_data = m_obj_util.get_scene_data(obj, scene);
	    var batches = sc_data.batches;

	    for (var i = 0; i < batches.length; i++) {
	        var batch = batches[i];

	        if (batch.type != "DEBUG_VIEW")
	            continue;

	        if (!copy) {
	            if (batch.dynamic_grass) {
	                var subs_grass_map = m_scgraph.find_subs(graph, m_subs.GRASS_MAP);
	                if (subs_grass_map)
	                    prepare_dynamic_grass_batch(batch, subs_grass_map, obj_render);
	            }

	            if (!m_batch.update_shader(batch)) {
	                if (m_version.type() === "DEBUG") {
	                    m_batch.apply_shader(batch, "error.glslv", "error.glslf");
	                    m_batch.update_shader(batch);
	                } else
	                    return;
	            }
	        }

	        var rb = m_subs.init_bundle(batch, obj_render, sc_data.batch_world_bounds[i]);
	        m_subs.append_draw_data(subs, rb);

	        m_scgraph.connect_render_targets_batch(graph, subs, batch, false);
	        check_batch_textures_number(batch);
	    }
	}

	/**
	 * Add object to depth map scene
	 */
	function add_object_subs_grass_map(subs, obj, scene, copy) {

	    var obj_render = obj.render;
	    // divide obj by batches
	    var sc_data = m_obj_util.get_scene_data(obj, scene);
	    var batches = sc_data.batches;

	    for (var i = 0; i < batches.length; i++) {
	        var batch = batches[i];

	        if (batch.type != "GRASS_MAP")
	            continue;

	        if (!copy)
	            if (!m_batch.update_shader(batch)) {
	                if (m_version.type() === "DEBUG") {
	                    m_batch.apply_shader(batch, "error.glslv", "error.glslf");
	                    m_batch.update_shader(batch);
	                } else
	                    continue;
	            }

	        var rb = m_subs.init_bundle(batch, obj_render, sc_data.batch_world_bounds[i]);
	        m_subs.append_draw_data(subs, rb);

	        // recalculate scene camera

	        var cam = subs.camera;
	        var bb = obj_render.bb_world;

	        var low = subs.grass_map_dim[0];
	        var high = subs.grass_map_dim[1];
	        var size = subs.grass_map_dim[2];

	        if (low == 0 && high == 0) {
	            // initial exec
	            low = bb.min_z;
	            high = bb.max_z;
	        } else {
	            low = Math.min(low, bb.min_z);
	            high = Math.max(high, bb.max_z);
	        }

	        // NOTE: issue for partially plain meshes near top or bottom
	        var map_margin = (high - low) * GRASS_MAP_MARGIN;
	        low = low - map_margin;
	        high = high + map_margin;

	        subs.grass_map_dim[0] = low;
	        subs.grass_map_dim[1] = high;
	        // subs.grass_map_dim[2] stays intact

	        m_cam.set_frustum2(cam, size/2, size/2, -high, -low);
	        m_cam.set_projection(cam, false);
	    }
	}

	/**
	 * Add object to outline mask scene
	 */
	function add_object_subs_outline_mask(subs, obj, graph, scene, copy) {

	    var obj_render = obj.render;
	    var sc_data = m_obj_util.get_scene_data(obj, scene);
	    var batches = sc_data.batches;

	    for (var i = 0; i < batches.length; i++) {
	        var batch = batches[i];

	        if (batch.type != "COLOR_ID")
	            continue;

	        if (batch.subtype != "OUTLINE")
	            continue;

	        if (!copy) {
	            update_batch_subs(batch, subs, obj, graph, "COLOR_ID", scene);
	            m_batch.set_batch_directive(batch, "USE_OUTLINE", 1);
	            if (!m_batch.update_shader(batch))
	                continue;
	        }

	        var rb = m_subs.init_bundle(batch, obj_render, sc_data.batch_world_bounds[i]);
	        m_subs.append_draw_data(subs, rb);
	    }

	}

	exports.change_visibility_rec = change_visibility_rec;
	function change_visibility_rec(obj, hide) {

	    change_visibility(obj, hide);

	    // TODO: cons_descends array must be replaced with another container for
	    // child objects
	    for (var i = 0; i < obj.cons_descends.length; i++)
	        if (obj.cons_descends[i].parent == obj)
	            change_visibility_rec(obj.cons_descends[i], hide);
	}

	exports.change_visibility = change_visibility;
	function change_visibility(obj, hide) {
	    obj.render.hide = hide;
	    if (m_obj_util.is_lamp(obj))
	        for (var i = 0; i < obj.scenes_data.length; i++) {
	            var scene_data = obj.scenes_data[i];
	            var scene = scene_data.scene;
	            var subs_arr = subs_array(scene, LIGHT_SUBSCENE_TYPES);
	            for (var j = 0; j < subs_arr.length; j++)
	                update_subs_light_factors(obj, scene_data, subs_arr[j]);
	        }
	}

	/**
	 * Check if object is hidden
	 * @methodOf scenes
	 */
	exports.is_hidden = function(obj) {
	    return obj.render.hide;
	};

	/**
	 * Remove object bundles.
	 * @methodOf scenes
	 */
	exports.remove_object_bundles = function(obj, mat_name) {
	    for (var i = 0; i < obj.scenes_data.length; i++) {
	        var scene = obj.scenes_data[i].scene;
	        var subscenes = subs_array(scene, OBJECT_SUBSCENE_TYPES);
	        
	        for (var j = 0; j < subscenes.length; j++) {
	            var draw_data = subscenes[j].draw_data;
	            for (var k = 0; k < draw_data.length; k++) {
	                var bundles = draw_data[k].bundles;
	                for (var l = bundles.length - 1; l >= 0; l--) {
	                    var bundle = bundles[l];
	                    if (bundle.obj_render == obj.render) {
	                        if (bundle.batch) {
	                            if (typeof mat_name == "undefined" 
	                                    || bundle.batch.material_names.indexOf(mat_name) != -1 
	                                    || bundle.batch.material_names.length == 0) {
	                                m_batch.clear_batch(bundle.batch);
	                                bundles.splice(l, 1);
	                            }
	                        } else
	                            bundles.splice(l, 1);
	                    }
	                }
	            }
	        }
	    }
	};

	exports.update_lamp_scene_color_intensity = update_lamp_scene_color_intensity;
	/**
	 * Update light color intensities on subscenes
	 */
	function update_lamp_scene_color_intensity(lamp, scene) {
	    var light = lamp.light;
	    var sc_data = m_obj_util.get_scene_data(lamp, scene);
	    var ind = sc_data.light_index;
	    var subs_arr = subs_array(scene, LIGHT_SUBSCENE_TYPES);
	    for (var i = 0; i < subs_arr.length; i++) {
	        var subs = subs_arr[i];
	        subs.light_color_intensities.set(light.color_intensity, ind * 4);
	        subs.need_perm_uniforms_update = true;
	    }
	}

	exports.update_lamp_scene = update_lamp_scene;
	/**
	 * Update light parameters on subscenes
	 */
	function update_lamp_scene(lamp, scene) {
	    //TODO: better precache this array
	    var subs_arr = subs_array(scene, LIGHT_SUBSCENE_TYPES);

	    var light = lamp.light;
	    var lamp_render = lamp.render;
	    var sc_data = m_obj_util.get_scene_data(lamp, scene);
	    var trans = m_tsr.get_trans_view(lamp_render.world_tsr);
	    var quat = m_tsr.get_quat_view(lamp_render.world_tsr);

	    for (var i = 0; i < subs_arr.length; i++) {
	        var subs = subs_arr[i];

	        update_subs_light_params(lamp, sc_data, subs);

	        switch (light.type) {
	        case "SUN":
	            subs.sun_quaternion.set(quat);
	            // by link
	            subs.sun_intensity = light.color_intensity;
	            m_vec3.copy(light.direction, subs.sun_direction);
	            if (subs.type == m_subs.SKY && subs.procedural_skydome) {
	                subs.need_fog_update = light.need_sun_fog_update;
	                update_sky(scene, subs);
	            }
	            break
	        case "HEMI":
	        case "POINT":
	        case "SPOT":
	            break;
	        default:
	            // TODO: prevent export of such lamps
	            m_print.error("Unknown light type: " + light.type + "\".");
	            break;
	        }

	        var draw_data = subs.draw_data;
	        for (var j = 0; j < draw_data.length; j++) {
	            var bundles = draw_data[j].bundles;
	            for (var k = 0; k < bundles.length; k++) {
	                var batch = bundles[k].batch;
	                if (batch.lamp_uuid_indexes)
	                    m_batch.set_lamp_data(batch, lamp);
	            }
	        }
	    }

	    // TODO: use subs_array(bpy_scene, [m_subs.MAIN_OPAQUE])
	    // bcz there could be more one MAIN_OPAQUE
	    var subs_main = get_subs(scene, m_subs.MAIN_OPAQUE);
	    var cam_main = subs_main.camera;
	    var shadow_subscenes = sc_data.shadow_subscenes;
	    var sh_params = scene._render.shadow_params;

	    for (var i = 0; i < shadow_subscenes.length; i++) {
	        var subs = shadow_subscenes[i];
	        var cam = subs.camera;
	        m_cam.set_view_trans_quat(cam, trans, quat);
	        update_subs_shadow(subs, scene, cam_main, sh_params, true);
	        update_shadow_receive_subs(subs, scene._render.graph);
	    }
	}

	function update_subs_light_params(lamp, sc_data, subs) {
	    var lamp_render = lamp.render;
	    var light = lamp.light;
	    var ind = sc_data.light_index;
	    var trans = m_tsr.get_trans_view(lamp.render.world_tsr);
	    var intens = light.color_intensity;

	    subs.light_directions.set(light.direction, ind * 3);

	    _vec4_tmp[0] = trans[0];
	    _vec4_tmp[1] = trans[1];
	    _vec4_tmp[2] = trans[2];
	    // NOTE: encoding light_factor for diffuse
	    _vec4_tmp[3] = light.use_diffuse && !lamp_render.hide ? 1.0 : 0.0;
	    subs.light_positions.set(_vec4_tmp, ind * 4);

	    _vec4_tmp[0] = intens[0];
	    _vec4_tmp[1] = intens[1];
	    _vec4_tmp[2] = intens[2];
	    // NOTE: encoding light_factor for specular
	    _vec4_tmp[3] = light.use_specular && !lamp_render.hide ? 1.0 : 0.0;
	    subs.light_color_intensities.set(_vec4_tmp, ind * 4);

	    subs.need_perm_uniforms_update = true;
	}

	function update_subs_light_factors(lamp, sc_data, subs) {
	    var lamp_render = lamp.render;
	    var light = lamp.light;
	    var ind = sc_data.light_index;

	    var light_factor = light.use_diffuse && !lamp_render.hide ? 1.0 : 0.0;
	    subs.light_positions[ind * 4 + 3] = light_factor;

	    light_factor = light.use_specular && !lamp_render.hide ? 1.0 : 0.0;
	    subs.light_color_intensities[ind * 4 + 3] = light_factor;

	    subs.need_perm_uniforms_update = true;
	}

	function reset_shadow_cam_vm(bpy_scene) {
	    var lamps = m_obj.get_scene_objs(bpy_scene, "LAMP", m_obj.DATA_ID_ALL);

	    var use_ssao = cfg_def.ssao && bpy_scene["b4w_enable_ssao"];
	    var shadow_lamps = m_obj_util.get_shadow_lamps(lamps, use_ssao);

	    if (!shadow_lamps.length)
	        return;

	    for (var k = 0; k < shadow_lamps.length; k++) {
	        var shadow_lamp = shadow_lamps[k];
	        var lamp_render = shadow_lamp.render;
	        var trans = m_tsr.get_trans(lamp_render.world_tsr, _vec3_tmp);
	        var quat = m_tsr.get_quat(lamp_render.world_tsr, _quat4_tmp);

	        for (var j = 0; j < shadow_lamp.scenes_data.length; j++) {
	            var sc_data = shadow_lamp.scenes_data[j];
	            var shadow_subscenes = sc_data.shadow_subscenes;
	            if (sc_data.scene == bpy_scene)
	                for (var i = 0; i < shadow_subscenes.length; i++) {
	                    var subs = shadow_subscenes[i];
	                    var cam = subs.camera;
	                    m_cam.set_view_trans_quat(cam, trans, quat);
	                }
	        }
	    }
	}

	exports.update_sky_texture = function(world) {
	    var scenes_data = world.scenes_data;
	    for (var i = 0; i < scenes_data.length; i++)
	        update_world_texture(scenes_data[i].scene);
	};

	exports.update_world_texture = update_world_texture;
	function update_world_texture(scene) {
	    var subs_sky = get_subs(scene, m_subs.SKY);
	    if (subs_sky)
	        update_sky(scene, subs_sky);
	}

	exports.update_sky = update_sky;
	function update_sky(scene, subs) {
	    m_prerender.prerender_subs(subs);
	    m_render.draw(subs);
	    if (subs.need_fog_update) {
	        var main_subs = subs_array(scene, FOG_SUBSCENE_TYPES);
	        for (var i = 0; i < main_subs.length; i++) {
	            var draw_data = main_subs[i].draw_data;
	            for (var j = 0; j < draw_data.length; j++) {
	                var bundles = draw_data[j].bundles;
	                for (var k = 0; k < bundles.length; k++) {
	                    var bundle = bundles[k];
	                    if (bundle.do_render) {
	                        var batch = bundle.batch;
	                        if (m_batch.check_batch_perm_uniform(batch, "u_cube_fog"))
	                            m_render.update_batch_permanent_uniform(batch,
	                                                                    "u_cube_fog");
	                    }
	                }
	            }
	        }
	    }

	    update_pbr_sky(scene);
	}

	function update_pbr_sky(scene) {
	    var subs_irradinace = get_subs(scene, m_subs.IRRADIANCE);
	    if (subs_irradinace) {
	        m_prerender.prerender_subs(subs_irradinace);
	        m_render.draw(subs_irradinace);
	    }

	    var subs_r_convolution = get_subs(scene, m_subs.ROUGHNESS_CONVOLUTION);
	    if (subs_r_convolution) {
	        m_prerender.prerender_subs(subs_r_convolution);
	        m_render.draw(subs_r_convolution);
	    }

	    var subs_brdf = get_subs(scene, m_subs.BRDF);
	    if (subs_brdf) {
	        m_prerender.prerender_subs(subs_brdf);
	        m_render.draw(subs_brdf);
	    }
	}

	/**
	 * Perform module cleanup
	 */
	exports.cleanup = function() {
	    for (var i = 0; i < _scenes.length; i++) {
	        var scene = _scenes[i];
	        var graph = scene._render.graph;

	        m_graph.traverse(graph, function(node, attr) {
	            if (!(attr.type == m_subs.SINK))
	                clear_subscene(attr);
	        });

	        scene._render.graph = null;
	        scene._render.queue = [];
	    }

	    _main_scene = null;
	    _active_scene = null;
	    _scenes.length = 0;
	    _scenes_graph = null;
	};

	/**
	 * Clear subscene
	 */
	function clear_subscene(subs) {

	    var cam = subs.camera;

	    m_render.render_target_cleanup(cam.framebuffer, cam.color_attachment,
	            cam.depth_attachment, cam.width, cam.height);

	    var draw_data = subs.draw_data;
	    for (var i = 0; i < draw_data.length; i++) {
	        var bundles = draw_data[i].bundles;
	        for (var j = 0; j < bundles.length; j++) {
	            var batch = bundles[j].batch;
	            if (batch)
	                m_batch.clear_batch(batch);
	        }
	    }
	}


	/**
	 * Extract frustum from camera, make debug geometry and add to active scene
	 * for debug purposes only
	 */
	exports.make_frustum_shot = function(cam, subscene, color) {
	    var corners = m_cam.extract_frustum_corners(cam, cam.near, cam.far, null, true);
	    var submesh = m_primitives.generate_frustum(corners);

	    var render = m_obj_util.create_render("DYNAMIC");

	    render.bb_world = render.bb_local = m_bounds.big_bounding_box();
	    render.bs_world = render.bs_local = m_bounds.big_bounding_sphere();

	    var radius = render.bs_world.radius;
	    render.be_world = render.be_local = m_bounds.be_from_values(
	            [radius, 0, 0], [0, radius, 0], [0, 0, radius], 
	            render.bs_world.center);

	    var batch = m_batch.create_shadeless_batch(submesh, color, 0.5);
	    batch.do_not_cull = true;

	    var rb = m_subs.init_bundle(batch, render);
	    m_subs.append_draw_data(subscene, rb);
	};

	/**
	 * Get all unuque materials of mesh objects
	 */
	function get_objs_materials(bpy_objects) {

	    var mats = [];

	    for (var i = 0; i < bpy_objects.length; i++) {

	        var obj_mats = bpy_objects[i]._object.materials;
	        for (var j = 0; j < obj_mats.length; j++) {
	            var mat = obj_mats[j];

	            if (mats.indexOf(mat) == -1)
	                mats.push(mat);
	        }
	    }

	    return mats;
	}

	/**
	 * Return blender scene timeline's start/end frames
	 */
	exports.get_scene_timeline = function(scene) {
	    var start = scene["frame_start"];
	    var end = scene["frame_end"];

	    return [start, end];
	};

	exports.setup_dim = setup_dim;
	function setup_dim(width, height, scale) {
	    m_cont.setup_viewport_dim(width, height, scale);

	    if (_active_scene)
	        setup_scene_dim(_active_scene, width, height);
	}

	function get_slink_dim(slink, width, height, dest) {
	    var cw = width;
	    var ch = height;

	    if (m_cont.is_hidpi()) {
	        cw *= window.devicePixelRatio;
	        ch *= window.devicePixelRatio;
	    }

	    // use only main scene for the canvas resizing
	    var main_scene = get_main();
	    if (main_scene) {
	        var sc_render = main_scene._render;
	        cw *= sc_render.resolution_factor;
	        ch *= sc_render.resolution_factor;
	    }

	    cw *= slink.size_mult_x;
	    ch *= slink.size_mult_y;

	    dest[0] = Math.floor(cw);
	    dest[1] = Math.floor(ch);

	    return dest;
	}

	function get_down_scale(slink, width, height) {
	    var slink_dim = get_slink_dim(slink, width, height, _vec2_tmp);

	    if (slink_dim[0] > cfg_lim.max_texture_size ||
	            slink_dim[1] > cfg_lim.max_texture_size) {
	        m_print.warn("Texture size exceeds platform limits, downscaling");

	        return Math.min(cfg_lim.max_texture_size / slink_dim[0],
	                cfg_lim.max_texture_size / slink_dim[0]);
	    }

	    return 1;
	}

	/**
	 * Setup dimension for specific scene subscenes
	 */
	function setup_scene_dim(scene, width, height) {
	    var sc_render = scene._render;
	    var cam_scene_data = m_obj_util.get_scene_data(scene._camera, scene);
	    var upd_cameras = cam_scene_data.cameras;

	    if (height != 0)
	        var aspect = width/height;
	    else
	        var aspect = 1;

	    for (var i = 0; i < upd_cameras.length; i++) {
	        var cam = upd_cameras[i];

	        m_cam.set_aspect(cam, aspect);
	        m_cam.set_projection(cam, false);

	        // NOTE: update size of camera shadow cascades
	        if (sc_render.shadow_params)
	            m_cam.update_camera_shadows(cam, sc_render.shadow_params);
	    }

	    if (sc_render.shadow_params) {
	        sc_render.need_shadow_update = true;
	        var shadow_receives = subs_array(scene, [m_subs.SHADOW_RECEIVE]);
	        for (var i = 0; i < shadow_receives.length; i++)
	            shadow_receives[i].need_perm_uniforms_update = true;

	        var main_blends = subs_array(scene, [m_subs.MAIN_BLEND]);
	        for (var i = 0; i < main_blends.length; i++)
	            main_blends[i].need_perm_uniforms_update = true;
	    }

	    setup_slink_dim(scene, width, height);
	}

	function setup_slink_dim(scene, width, height) {
	    var sc_render = scene._render;
	    var graph = sc_render.graph;

	    var scale = Infinity;
	    m_scgraph.traverse_slinks(graph, function(slink, internal, subs1, subs2) {
	        if (!slink.update_dim)
	            return;

	        scale = Math.min(scale, get_down_scale(slink, width, height));
	    });

	    m_scgraph.traverse_slinks(graph, function(slink, internal, subs1, subs2) {
	        if (!slink.update_dim)
	            return;

	        var tex_width, tex_height, dims;

	        if (subs2 && subs2.type == m_subs.SINK ||
	                subs1.is_pp && !slink.apply_resolution_factors) {
	            tex_width = width * slink.size_mult_x;
	            tex_height = height * slink.size_mult_y;
	        } else {
	            dims = get_slink_dim(slink, width, height, _vec2_tmp);
	            tex_width = dims[0] * scale;
	            tex_height = dims[1] * scale;
	        }

	        if (internal) {
	            for (var i = 0; i < subs1.slinks_internal.length; i++) {
	                var slink_i = subs1.slinks_internal[i];
	                if (slink_i == slink)
	                    m_tex.resize(slink.texture, tex_width, tex_height);
	            }
	        } else {
	            if (m_tex.is_texture(slink.texture)) {
	                m_tex.resize(slink.texture, tex_width, tex_height);
	                if (slink.texture.use_mipmap)
	                    subs2.last_mip_map_ind = slink.texture.mipmap_count;
	            }

	            // NOTE: needed in set_dof_params() and several other places
	            var cam = subs1.camera;
	            cam.width = tex_width;
	            cam.height = tex_height;

	            switch (subs1.type) {
	            case m_subs.DOF:
	                set_dof_params(scene, {"dof_power": subs1.camera.dof_power});
	                break;
	            case m_subs.GLOW_COMBINE:
	                set_glow_material_params(scene,
	                        {"small_glow_mask_width": subs1.small_glow_mask_width,
	                        "large_glow_mask_width": subs1.large_glow_mask_width});
	                break;
	            case m_subs.BLOOM:
	                set_bloom_params(scene,
	                        {"blur": subs1.bloom_blur});
	                break;
	            case m_subs.RESIZE:
	                cam.width = cam.color_attachment.width;
	                cam.height = cam.color_attachment.height;
	                break;
	            case m_subs.OUTLINE:
	                var subs_outline_blur_y = m_scgraph.find_input(graph, subs1,
	                        m_subs.POSTPROCESSING);
	                var subs_outline_blur_x = m_scgraph.find_input(graph, subs_outline_blur_y,
	                        m_subs.POSTPROCESSING);
	                var subs_outline_extend_y = m_scgraph.find_input(graph, subs_outline_blur_x,
	                        m_subs.POSTPROCESSING);
	                var subs_outline_extend_x = m_scgraph.find_input(graph, subs_outline_extend_y,
	                        m_subs.POSTPROCESSING);

	                m_scgraph.set_texel_size(subs_outline_blur_y, 1/tex_width, 1/tex_width);
	                m_scgraph.set_texel_size(subs_outline_blur_x, 1/tex_width, 1/tex_width);
	                m_scgraph.set_texel_size(subs_outline_extend_y, 1/tex_width, 1/tex_width);
	                m_scgraph.set_texel_size(subs_outline_extend_x, 1/tex_width, 1/tex_width);
	                break;
	            default:
	                m_scgraph.set_texel_size(subs1, 1/tex_width, 1/tex_height);
	                break;
	            }
	        }
	    });
	}

	exports.subs_array = subs_array;
	/**
	 * Return subscene array matching types array
	 * return only existing subscenes
	 * @methodOf scenes
	 */
	function subs_array(scene, types) {
	    var subscenes = [];

	    // in strict succession
	    for (var i = 0; i < types.length; i++) {
	        var type = types[i];

	        if (scene._render.graph)
	            m_graph.traverse(scene._render.graph, function(node, attr) {
	                var subs = attr;

	                if (subs.type == type)
	                    subscenes.push(subs);
	            });
	    }
	    return subscenes;
	}

	exports.get_subs = get_subs;
	/**
	 * Return first subscene matching given type
	 * @methodOf scenes
	 */
	function get_subs(scene, type) {
	    var graph = scene._render.graph;
	    return m_scgraph.find_subs(graph, type);
	}

	exports.render_both_eyes = function() {
	    switch_stereo_render_eye_mode(false);
	};

	exports.render_one_eye = function() {
	    switch_stereo_render_eye_mode(true);
	};

	function switch_stereo_render_eye_mode(is_one_eye) {
	    var scene = get_main();
	    if (!scene)
	        return;
	    var graph = scene._render.graph;
	    m_graph.traverse(graph, function(node, attr) {
	        var subs = attr;
	        var camera = subs.camera;

	        // CHECK: subs.camera can be null
	        if (camera && camera.type == m_cam.TYPE_HMD_RIGHT)
	            subs.force_do_not_render = is_one_eye;
	    });
	}
	/**
	 * Get horizon and zenith colors
	 */
	exports.get_environment_colors = function(scene) {

	    var subs = get_subs(scene, m_subs.MAIN_OPAQUE);

	    var hor = subs.horizon_color;
	    var zen = subs.zenith_color;

	    var hor_dest = [];
	    var zen_dest = [];

	    hor_dest[0] = hor[0];
	    hor_dest[1] = hor[1];
	    hor_dest[2] = hor[2];

	    zen_dest[0] = zen[0];
	    zen_dest[1] = zen[1];
	    zen_dest[2] = zen[2];

	    return [subs.environment_energy, hor_dest, zen_dest];
	};

	exports.set_environment_colors = set_environment_colors;
	/**
	 * Set environment energy, horizon and zenith colors
	 */
	function set_environment_colors(scene, environment_energy, horizon_color, zenith_color) {

	    var subscenes = subs_array(scene, LIGHT_SUBSCENE_TYPES);

	    for (var i = 0; i < subscenes.length; i++) {
	        var subs = subscenes[i];

	        subs.horizon_color.set(horizon_color);
	        subs.zenith_color.set(zenith_color);
	        subs.environment_energy = environment_energy;

	        subs.need_perm_uniforms_update = true;
	    }
	    var subs_sky = m_scgraph.find_subs(scene._render.graph, m_subs.SKY);
	    if (subs_sky)
	        update_sky(scene, subs_sky);
	}

	/**
	 * Get sky params
	 */
	exports.get_sky_params = function(scene) {

	    var subs = get_subs(scene, m_subs.SKY);
	    if (subs && subs.procedural_skydome) {
	        var sky_params = {};
	        sky_params.color = new Array(3);
	        m_vec3.copy(subs.sky_color, sky_params.color);
	        sky_params.procedural_skydome = subs.procedural_skydome;
	        sky_params.use_as_environment_lighting = subs.use_as_environment_lighting;
	        sky_params.rayleigh_brightness = subs.rayleigh_brightness;
	        sky_params.mie_brightness = subs.mie_brightness;
	        sky_params.spot_brightness = subs.spot_brightness;
	        sky_params.scatter_strength = subs.scatter_strength;
	        sky_params.rayleigh_strength = subs.rayleigh_strength;
	        sky_params.mie_strength = subs.mie_strength;
	        sky_params.rayleigh_collection_power = subs.rayleigh_collection_power;
	        sky_params.mie_collection_power = subs.mie_collection_power;
	        sky_params.mie_distribution = subs.mie_distribution;
	        return sky_params;
	    } else {
	        return null;
	    }
	};

	/**
	 * Get fog params methods
	 */
	exports.get_fog_intensity = function(scene) {

	    var subs = subs_array(scene, FOG_SUBSCENE_TYPES)[0];

	    return subs.fog_params[0];
	};

	exports.get_fog_depth = function(scene) {

	    var subs = subs_array(scene, FOG_SUBSCENE_TYPES)[0];

	    return subs.fog_params[1];
	};

	exports.get_fog_start = function(scene) {

	    var subs = subs_array(scene, FOG_SUBSCENE_TYPES)[0];

	    return subs.fog_params[2];
	};

	exports.get_fog_height = function(scene) {

	    var subs = subs_array(scene, FOG_SUBSCENE_TYPES)[0];

	    return subs.fog_params[3];
	};

	/**
	 * Set fog params methods
	 */
	exports.set_fog_intensity = function(scene, fog_intensity) {

	    var subscenes = subs_array(scene, FOG_SUBSCENE_TYPES);

	    for (var i = 0; i < subscenes.length; i++) {
	        var subs = subscenes[i];
	        subs.fog_params[0] = fog_intensity;
	        subs.need_perm_uniforms_update = true;
	    }
	};

	exports.set_fog_depth = function(scene, fog_depth) {

	    var subscenes = subs_array(scene, FOG_SUBSCENE_TYPES);

	    for (var i = 0; i < subscenes.length; i++) {
	        var subs = subscenes[i];
	        subs.fog_params[1] = fog_depth;
	        subs.need_perm_uniforms_update = true;
	    }
	};

	exports.set_fog_start = function(scene, fog_start) {

	    var subscenes = subs_array(scene, FOG_SUBSCENE_TYPES);

	    for (var i = 0; i < subscenes.length; i++) {
	        var subs = subscenes[i];
	        subs.fog_params[2] = fog_start;
	        subs.need_perm_uniforms_update = true;
	    }
	};

	exports.set_fog_height = function(scene, fog_height) {

	    var subscenes = subs_array(scene, FOG_SUBSCENE_TYPES);

	    for (var i = 0; i < subscenes.length; i++) {
	        var subs = subscenes[i];
	        subs.fog_params[3] = fog_height;
	        subs.need_perm_uniforms_update = true;
	    }
	};

	/**
	 * Get fog color and density
	 */
	exports.get_fog_color_density = function(scene, opt_dest) {

	    var dest = opt_dest || [];

	    var subs = subs_array(scene, FOG_SUBSCENE_TYPES)[0];

	    var fcd = subs.fog_color_density;

	    dest[0] = fcd[0];
	    dest[1] = fcd[1];
	    dest[2] = fcd[2];
	    dest[3] = fcd[3];

	    return dest;
	};

	/**
	 * Set fog color and density
	 */
	exports.set_fog_color_density = function(scene, val) {

	    var subscenes = subs_array(scene, FOG_SUBSCENE_TYPES);

	    for (var i = 0; i < subscenes.length; i++) {
	        var subs = subscenes[i];
	        subs.fog_color_density.set(val);
	        subs.need_perm_uniforms_update = true;
	    }
	};

	/**
	 * Get ssao params
	 */
	exports.get_ssao_params = function(scene) {

	    var subs = get_subs(scene, m_subs.SSAO);
	    var subs_blur = get_subs(scene, m_subs.SSAO_BLUR);
	    var subs_main = get_subs(scene, m_subs.MAIN_OPAQUE);
	    if (!subs)
	        return null;

	    var ssao_params = {};
	    ssao_params.quality = subs.ssao_samples;
	    ssao_params.use_hemisphere = subs.ssao_hemisphere;
	    ssao_params.use_blur_depth = subs_blur.ssao_blur_depth;
	    ssao_params.blur_discard_value = subs_blur.ssao_blur_discard_value;
	    ssao_params.radius_increase = subs.ssao_radius_increase;
	    ssao_params.influence = subs.ssao_influence;
	    ssao_params.dist_factor = subs.ssao_dist_factor;
	    ssao_params.ssao_only = subs_main.ssao_only;
	    ssao_params.ssao_white = subs.ssao_white;

	    return ssao_params;
	};

	exports.get_dof_params = function(scene) {

	    var subs = get_subs(scene, m_subs.DOF);
	    if (!subs)
	        return null;

	    var dof_params = {};

	    dof_params.dof_on = subs.camera.dof_on;
	    dof_params.dof_distance = subs.camera.dof_distance;
	    dof_params.dof_front_start = subs.camera.dof_front_start;
	    dof_params.dof_front_end = subs.camera.dof_front_end;
	    dof_params.dof_rear_start = subs.camera.dof_rear_start;
	    dof_params.dof_rear_end = subs.camera.dof_rear_end;
	    dof_params.dof_power = subs.camera.dof_power;
	    dof_params.dof_bokeh = subs.camera.dof_bokeh;
	    dof_params.dof_bokeh_intensity = subs.camera.dof_bokeh_intensity;
	    dof_params.dof_object = subs.camera.dof_object;
	    return dof_params;
	};

	exports.set_dof_params = set_dof_params;
	function set_dof_params(scene, dof_params) {

	    var subs_dofs = subs_array(scene, [m_subs.DOF]);
	    if (!subs_dofs.length) {
	        m_print.error("DOF is not enabled on the scene. Check camera settings");
	        return 0;
	    }

	    for (var i = 0; i < subs_dofs.length; i++)
	        set_params_dof_subs(subs_dofs[i], dof_params, scene);
	}

	function set_params_dof_subs(subs_dof, dof_params, scene) {
	    var bokeh_enabled = subs_dof.camera.dof_bokeh;

	    var subs_coc_arr = bokeh_enabled ? subs_array(scene, [m_subs.COC]) : [];

	    var graph = scene._render.graph;

	    if (typeof dof_params.dof_on == "boolean") {
	        subs_dof.camera.dof_on = dof_params.dof_on;
	        if (bokeh_enabled)
	            for (var i = 0; i < subs_coc_arr.length; i++)
	                subs_coc_arr[i].camera.dof_on = dof_params.dof_on;
	    }
	    if (typeof dof_params.dof_distance == "number") {
	        subs_dof.camera.dof_distance = dof_params.dof_distance;
	        if (bokeh_enabled)
	            for (var i = 0; i < subs_coc_arr.length; i++)
	                subs_coc_arr[i].camera.dof_distance = dof_params.dof_distance;
	    }
	    if (typeof dof_params.dof_front_start == "number") {
	        subs_dof.camera.dof_front_start = dof_params.dof_front_start;
	        if (bokeh_enabled)
	            for (var i = 0; i < subs_coc_arr.length; i++)
	                subs_coc_arr[i].camera.dof_front_start = dof_params.dof_front_start;
	    }
	    if (typeof dof_params.dof_front_end == "number") {
	        subs_dof.camera.dof_front_end = dof_params.dof_front_end;
	        if (bokeh_enabled)
	            for (var i = 0; i < subs_coc_arr.length; i++)
	                subs_coc_arr[i].camera.dof_front_end = dof_params.dof_front_end;
	    }
	    if (typeof dof_params.dof_rear_start == "number") {
	        subs_dof.camera.dof_rear_start = dof_params.dof_rear_start;
	        if (bokeh_enabled)
	            for (var i = 0; i < subs_coc_arr.length; i++)
	                subs_coc_arr[i].camera.dof_rear_start = dof_params.dof_rear_start;
	    }
	    if (typeof dof_params.dof_rear_end == "number") {
	        subs_dof.camera.dof_rear_end = dof_params.dof_rear_end;
	        if (bokeh_enabled)
	            for (var i = 0; i < subs_coc_arr.length; i++)
	                subs_coc_arr[i].camera.dof_rear_end = dof_params.dof_rear_end;
	    }
	    if (typeof dof_params.dof_bokeh_intensity == "number") {
	        subs_dof.camera.dof_bokeh_intensity = dof_params.dof_bokeh_intensity;
	        if (bokeh_enabled) {
	            var subs_pp_array = m_scgraph.get_inputs_by_type(graph, subs_dof,m_subs.POSTPROCESSING);
	            // Y_DOF_BLUR
	            subs_pp_array[0].camera.dof_bokeh_intensity = dof_params.dof_bokeh_intensity;
	            subs_pp_array[1].camera.dof_bokeh_intensity = dof_params.dof_bokeh_intensity;
	            // X_DOF_BLUR
	            subs_pp_array[0] = m_scgraph.find_input(graph, subs_pp_array[0], m_subs.POSTPROCESSING);
	            subs_pp_array[0].camera.dof_bokeh_intensity = dof_params.dof_bokeh_intensity;
	        }
	    }
	    if (typeof dof_params.dof_power == "number") {
	        if (bokeh_enabled) {
	            var dof_power = dof_params.dof_power;
	            subs_dof.camera.dof_power = dof_power;

	            // half power because of downsized subs
	            dof_power /= 2.0;

	            var width  = subs_dof.camera.width;
	            var height = subs_dof.camera.height;

	            var texel_right = [1/width, 0.0];
	            var texel_up_right = [1/width * 0.5, 1/height * 0.866];
	            var texel_up_left  = [-1/width * 0.5, 1/height * 0.866];

	            var subs_pp_array = m_scgraph.get_inputs_by_type(graph, subs_dof, m_subs.POSTPROCESSING);

	            // Y_DOF_BLUR
	            m_scgraph.set_texel_size_mult(subs_pp_array[0], dof_power);
	            m_scgraph.set_texel_size(subs_pp_array[0], texel_up_left[0], texel_up_left[1]);
	            m_scgraph.set_texel_size_mult(subs_pp_array[1], dof_power);
	            m_scgraph.set_texel_size(subs_pp_array[1], texel_up_right[0], texel_up_right[1]);

	            // X_DOF_BLUR
	            subs_pp_array[0] = m_scgraph.find_input(graph, subs_pp_array[0],
	                    m_subs.POSTPROCESSING);
	            m_scgraph.set_texel_size_mult(subs_pp_array[0], dof_power);
	            m_scgraph.set_texel_size(subs_pp_array[0], texel_right[0], texel_right[1]);

	            if (subs_dof.camera.dof_foreground_blur) {
	                // Y_ALPHA_BLUR
	                subs_pp_array[0] = m_scgraph.find_input(graph, subs_pp_array[0],
	                        m_subs.COC);
	                subs_pp_array[0] = m_scgraph.find_input(graph, subs_pp_array[0],
	                        m_subs.POSTPROCESSING);
	                m_scgraph.set_texel_size(subs_pp_array[0], 1/width, 1/height);

	                // X_ALPHA_BLUR
	                subs_pp_array[0] = m_scgraph.find_input(graph, subs_pp_array[0],
	                        m_subs.POSTPROCESSING);
	                m_scgraph.set_texel_size(subs_pp_array[0], 1/width, 1/height);
	            }

	        } else {
	            subs_dof.camera.dof_power = dof_params.dof_power;
	            var subs_pp1 = m_scgraph.find_input(graph, subs_dof, m_subs.POSTPROCESSING);
	            var subs_pp2 = m_scgraph.find_input(graph, subs_pp1, m_subs.POSTPROCESSING);

	            m_scgraph.set_texel_size_mult(subs_pp1, subs_dof.camera.dof_power);
	            m_scgraph.set_texel_size(subs_pp1, 1/subs_dof.camera.width,
	                                               1/subs_dof.camera.height);
	            m_scgraph.set_texel_size_mult(subs_pp2, subs_dof.camera.dof_power);
	            m_scgraph.set_texel_size(subs_pp2, 1/subs_dof.camera.width,
	                                               1/subs_dof.camera.height);
	        }
	    }
	}

	exports.get_god_rays_params = function(scene) {

	    var gr_subs = subs_array(scene, [m_subs.GOD_RAYS]);
	    var combo_subs = get_subs(scene, m_subs.GOD_RAYS_COMBINE);

	    if (!gr_subs || !combo_subs)
	        return null;

	    var god_rays_params = {};

	    god_rays_params.god_rays_max_ray_length = gr_subs[0].max_ray_length;
	    god_rays_params.god_rays_intensity = combo_subs.god_rays_intensity;

	    var batch = gr_subs[0].draw_data[0].bundles[0].batch;
	    god_rays_params.god_rays_steps = m_batch.get_batch_directive(batch, "STEPS_PER_PASS")[1];

	    return god_rays_params;
	};

	exports.set_god_rays_params = function(scene, god_rays_params) {

	    var gr_subs = subs_array(scene, [m_subs.GOD_RAYS]);
	    var combo_subs = subs_array(scene, [m_subs.GOD_RAYS_COMBINE]);

	    if (!gr_subs.length || !combo_subs.length) {
	        m_print.error("God Rays are not enabled on the scene");
	        return 0;
	    }

	    if (typeof god_rays_params.god_rays_intensity == "number")
	        for (var i = 0; i < combo_subs.length; i++)
	            combo_subs[i].god_rays_intensity = god_rays_params.god_rays_intensity;
	    if (typeof god_rays_params.god_rays_max_ray_length == "number") {
	        var r_length = god_rays_params.god_rays_max_ray_length;
	        for (var i = 0; i < gr_subs.length; i++) {
	            gr_subs[i].max_ray_length = r_length;
	            gr_subs[i].radial_blur_step = r_length / gr_subs[i].steps_per_pass / (i + 1);
	            gr_subs[i].need_perm_uniforms_update = true;
	        }
	    }
	    if (typeof god_rays_params.god_rays_steps == "number") {

	        var steps = m_shaders.glsl_value(god_rays_params.god_rays_steps, 1);
	        var r_length = gr_subs[0].max_ray_length;

	        for (var i = 0; i < gr_subs.length; i++) {
	            gr_subs[i].steps_per_pass = steps;
	            gr_subs[i].radial_blur_step = r_length / steps / (i + 1);
	            gr_subs[i].need_perm_uniforms_update = true;

	            var bundle = gr_subs[i].draw_data[0].bundles[0];
	            var batch = bundle.batch;
	            m_batch.set_batch_directive(batch, "STEPS_PER_PASS", steps);
	            m_batch.update_shader(batch);
	            m_subs.append_draw_data(gr_subs[i], bundle);
	        }
	    }

	    for (var i = 0; i < combo_subs.length; i++)
	        combo_subs.need_perm_uniforms_update = true;
	};

	exports.get_bloom_params = function(scene) {

	    var lum_subs = get_subs(scene, m_subs.LUMINANCE_TRUNCED);
	    var bloom_subs = get_subs(scene, m_subs.BLOOM);
	    if (!lum_subs || !bloom_subs) {
	        return null;
	    }

	    var bloom_params = {};

	    bloom_params.key = lum_subs.bloom_key;
	    bloom_params.edge_lum = lum_subs.bloom_edge_lum;
	    bloom_params.blur = bloom_subs.bloom_blur;
	    bloom_params.adaptive = lum_subs.adaptive_bloom;
	    bloom_params.average_luminance = lum_subs.average_luminance;

	    return bloom_params;
	};

	exports.set_bloom_params = set_bloom_params;
	function set_bloom_params(scene, bloom_params) {

	    var lum_subs = subs_array(scene, [m_subs.LUMINANCE_TRUNCED]);
	    var bloom_subs = subs_array(scene, [m_subs.BLOOM]);

	    if (!lum_subs.length || !bloom_subs.length) {
	        m_print.error("Bloom is not enabled on the scene");
	        return 0;
	    }

	    if (typeof bloom_params.key == "number") {
	        for (var i = 0; i < lum_subs.length; i++) {
	            lum_subs[i].bloom_key = bloom_params.key;
	            lum_subs[i].need_perm_uniforms_update = true;
	        }
	    }
	    if (typeof bloom_params.edge_lum == "number") {
	        for (var i = 0; i < lum_subs.length; i++) {
	            lum_subs[i].bloom_edge_lum = bloom_params.edge_lum;
	            lum_subs[i].need_perm_uniforms_update = true;
	        }
	    }

	    if (typeof bloom_params.blur == "number") {
	        for (var i = 0; i < bloom_subs.length; i++) {
	            bloom_subs[i].bloom_blur = bloom_params.blur;
	            var graph = scene._render.graph;

	            var original_width = bloom_subs[i].camera.width / 0.5;
	            var original_height = bloom_subs[i].camera.height / 0.5;
	            var bloom_inputs = m_scgraph.get_inputs_by_type(graph, bloom_subs[i], m_subs.POSTPROCESSING);

	            for (var j = 0; j < bloom_inputs.length; ++j) {
	                var subs_blur_y = bloom_inputs[j];
	                var subs_blur_x = m_scgraph.find_input(graph, subs_blur_y, m_subs.POSTPROCESSING);

	                var width = original_width * subs_blur_y.bloom_blur_scale;
	                var height = original_height * subs_blur_y.bloom_blur_scale;

	                m_scgraph.set_texel_size_mult(subs_blur_y, bloom_params.blur);
	                m_scgraph.set_texel_size(subs_blur_y, 1/width, 1/height);
	                m_scgraph.set_texel_size_mult(subs_blur_x, bloom_params.blur);
	                m_scgraph.set_texel_size(subs_blur_x, 1/width, 1/height);
	            }
	        }
	    }
	    if (typeof bloom_params.average_luminance == "number") {
	        for (var i = 0; i < lum_subs.length; i++)
	            if (!lum_subs[i].adaptive_bloom) {
	                lum_subs[i].average_luminance = bloom_params.average_luminance;
	                lum_subs[i].need_perm_uniforms_update = true;
	            }
	    }
	}

	exports.get_glow_material_params = function(scene) {
	    var glow_combine_subs = get_subs(scene, m_subs.GLOW_COMBINE);

	    if (!glow_combine_subs)
	        return null;

	    var glow_material_params = {};

	    glow_material_params.small_glow_mask_coeff = glow_combine_subs.small_glow_mask_coeff;
	    glow_material_params.large_glow_mask_coeff = glow_combine_subs.large_glow_mask_coeff;
	    glow_material_params.small_glow_mask_width = glow_combine_subs.small_glow_mask_width;
	    glow_material_params.large_glow_mask_width = glow_combine_subs.large_glow_mask_width;

	    return glow_material_params;
	};

	exports.set_glow_material_params = set_glow_material_params;
	function set_glow_material_params(scene, glow_material_params) {
	    var glow_combine_subscenes = subs_array(scene, [m_subs.GLOW_COMBINE]);

	    if (!glow_combine_subscenes.length) {
	        m_print.error("Glow is not enabled on the scene");
	        return null;
	    }

	    for (var i = 0; i < glow_combine_subscenes.length; i++)
	        set_params_glow_subs(glow_combine_subscenes[i], glow_material_params, scene);
	}


	function set_params_glow_subs(glow_combine_subs, glow_material_params, scene) {
	    var graph = scene._render.graph;
	    var subs = m_scgraph.get_inputs(graph, glow_combine_subs);

	    for (var i = 0; i < subs.length; ++i) {
	        var subscene = subs[i];

	        if (subscene.type == m_subs.POSTPROCESSING && subscene.subtype == "GLOW_MASK_LARGE")
	            var postproc_y_blur_large_subs = subscene;
	        if (subscene.type == m_subs.POSTPROCESSING && subscene.subtype == "GLOW_MASK_SMALL")
	            var postproc_y_blur_small_subs = subscene;
	    }

	    var postproc_x_blur_large_subs = m_scgraph.find_input(graph,
	            postproc_y_blur_large_subs, m_subs.POSTPROCESSING);
	    var postproc_x_blur_small_subs = m_scgraph.find_input(graph,
	            postproc_y_blur_small_subs, m_subs.POSTPROCESSING);

	    if (typeof glow_material_params.small_glow_mask_coeff == "number") {
	        glow_combine_subs.small_glow_mask_coeff = glow_material_params.small_glow_mask_coeff;
	        glow_combine_subs.need_perm_uniforms_update = true;
	    }

	    if (typeof glow_material_params.large_glow_mask_coeff == "number") {
	        glow_combine_subs.large_glow_mask_coeff = glow_material_params.large_glow_mask_coeff;
	        glow_combine_subs.need_perm_uniforms_update = true;
	    }

	    if (typeof glow_material_params.small_glow_mask_width == "number") {
	        glow_combine_subs.small_glow_mask_width = glow_material_params.small_glow_mask_width;
	        m_scgraph.set_texel_size_mult(postproc_y_blur_small_subs,
	                glow_material_params.small_glow_mask_width);
	        m_scgraph.set_texel_size(postproc_y_blur_small_subs,
	                1/glow_combine_subs.camera.width,
	                1/glow_combine_subs.camera.height);
	        postproc_y_blur_small_subs.need_perm_uniforms_update = true;

	        m_scgraph.set_texel_size_mult(postproc_x_blur_small_subs,
	                glow_material_params.small_glow_mask_width);
	        m_scgraph.set_texel_size(postproc_x_blur_small_subs,
	                1/glow_combine_subs.camera.width,
	                1/glow_combine_subs.camera.height);
	        postproc_x_blur_small_subs.need_perm_uniforms_update = true;
	    }

	    if (typeof glow_material_params.large_glow_mask_width == "number") {
	        glow_combine_subs.large_glow_mask_width = glow_material_params.large_glow_mask_width;
	        m_scgraph.set_texel_size_mult(postproc_y_blur_large_subs,
	                glow_material_params.large_glow_mask_width);
	        m_scgraph.set_texel_size(postproc_y_blur_large_subs,
	                1/glow_combine_subs.camera.width,
	                1/glow_combine_subs.camera.height);
	        postproc_y_blur_large_subs.need_perm_uniforms_update = true;

	        m_scgraph.set_texel_size_mult(postproc_x_blur_large_subs,
	                glow_material_params.large_glow_mask_width);
	        m_scgraph.set_texel_size(postproc_x_blur_large_subs,
	                1/glow_combine_subs.camera.width,
	                1/glow_combine_subs.camera.height);
	        postproc_x_blur_large_subs.need_perm_uniforms_update = true;

	    }
	}

	exports.get_wind_params = function(scene) {
	    var wind = get_wind(scene);
	    var length = m_vec3.length(wind);

	    if (length == 0)
	        return null;

	    var angle = m_util.rad_to_deg(Math.atan2(wind[0], -wind[1]));

	    var wind_params = {};
	    wind_params.wind_dir = angle;
	    wind_params.wind_strength = length;

	    return wind_params;
	};

	exports.schedule_grass_map_update = schedule_grass_map_update;
	/**
	 * Schedule update of grass subscenes on given bpy scene.
	 * @methodOf scenes
	 */
	function schedule_grass_map_update(bpy_scene) {
	    bpy_scene._render.need_grass_map_update = true;
	}

	exports.get_water_surface_level = get_water_surface_level;
	/**
	 * Get water surface level
	 * @methodOf scenes
	 */
	function get_water_surface_level(scene, pos_x, pos_y) {

	    var render = scene._render;
	    var wp = render.water_params;

	    if (!wp.dynamic)
	        return wp.water_level;

	    var waves_height = wp.waves_height;
	    var waves_length = wp.waves_length;
	    var water_level  = wp.water_level;

	    var wind_str = m_vec3.length(render.wind) || 1;

	    var subs = get_subs(scene, m_subs.MAIN_OPAQUE);
	    var time = subs.time;
	    time *= wind_str;

	    // small waves
	    var cellular_coords = _vec2_tmp;
	    cellular_coords[0] = 20.0 / waves_length * (pos_x - 0.25 * time);
	    cellular_coords[1] = 20.0 / waves_length * (pos_y - 0.25 * time);
	    var cellular1 = m_util.cellular2x2(cellular_coords);
	    cellular_coords[0] = 17.0 / waves_length * (pos_y + 0.1  * time);
	    cellular_coords[1] = 17.0 / waves_length * (pos_x + 0.1  * time);
	    var cellular2 = m_util.cellular2x2(cellular_coords);
	    var small_waves = cellular1 + cellular2 - 1;

	    // distant waves (only noise)
	    var dst_noise_scale0  = wp.dst_noise_scale0;
	    var dst_noise_scale1  = wp.dst_noise_scale1;
	    var dst_noise_freq0   = wp.dst_noise_freq0;
	    var dst_noise_freq1   = wp.dst_noise_freq1;

	    var noise_coords = _vec2_tmp;

	    noise_coords[0] = dst_noise_scale0 * (pos_x + dst_noise_freq0 * time);
	    noise_coords[1] = dst_noise_scale0 * (pos_y + dst_noise_freq0 * time);
	    var noise1 = m_util.snoise(noise_coords);

	    noise_coords[0] = dst_noise_scale1 * (pos_y - dst_noise_freq1 * time);
	    noise_coords[1] = dst_noise_scale1 * (pos_x - dst_noise_freq1 * time);
	    var noise2 = m_util.snoise(noise_coords);
	    var dist_waves = waves_height * noise1 * noise2;

	    // waves moving towards the shore
	    if (wp.shoremap_image) {

	        // center and size of shore distance field
	        var size_x = wp.shoremap_size[0];
	        var size_y = wp.shoremap_size[1];
	        var center_x = wp.shoremap_center[0];
	        var center_y = wp.shoremap_center[1];

	        // get uv coords on shore distance map
	        var x = (pos_x - center_x) / size_x;
	        var y = (center_y + pos_y) / size_y;
	        x += 0.5;
	        y += 0.5;

	        // if position is out of boundings, consider that shore dist = 1
	        if (x > 1 || x < 0 || y > 1 || y < 0) {
	            var wave_height = dist_waves;
	        } else {
	            var width = wp.shoremap_tex_size;
	            var array = render.shore_distances;

	            var shore_dist = m_util.get_array_smooth_value(array, width, x, y);
	            var dir_min_shore_fac = wp.dir_min_shore_fac;
	            var dir_freq          = wp.dir_freq;
	            var dir_noise_scale   = wp.dir_noise_scale;
	            var dir_noise_freq    = wp.dir_noise_freq;
	            var dir_min_noise_fac = wp.dir_min_noise_fac;
	            var dst_min_fac       = wp.dst_min_fac;

	            var max_shore_dist = wp.max_shore_dist;
	            var shore_waves_length = waves_length / max_shore_dist / Math.PI;
	            // waves moving towards the shore
	            var waves_coords = [dir_noise_scale / waves_length * (pos_x + dir_noise_freq * time),
	                                dir_noise_scale / waves_length * (pos_y + dir_noise_freq * time)];

	            var dist_fact = Math.sqrt(shore_dist);
	            var shore_dir_waves = waves_height * Math.max(shore_dist, dir_min_shore_fac)
	                    * Math.sin((dist_fact / shore_waves_length + dir_freq * time))
	                    * Math.max( m_util.snoise(waves_coords), dir_min_noise_fac );
	            // mix two types of waves basing on distance to the shore
	            var mix_rate = Math.max(dist_fact, dst_min_fac);
	            var wave_height = shore_dir_waves * (1 - mix_rate) + dist_waves * mix_rate;
	            small_waves *= shore_dist;
	        }
	    } else
	        var wave_height = dist_waves;

	    wave_height += 0.05 * small_waves;
	    var cur_water_level = water_level + wave_height;

	    return cur_water_level;
	}

	exports.get_water_mat_params = function(scene, water_params) {

	    var wp = scene._render.water_params;
	    var subs = get_subs(scene, m_subs.MAIN_OPAQUE);

	    if (!subs || !wp)
	        return;

	    water_params.waves_height = wp.waves_height;
	    water_params.waves_length = wp.waves_length;

	    water_params.water_fog_density = subs.water_fog_color_density[3];
	    var wfc = water_params.water_fog_color = [];
	    wfc[0]  = subs.water_fog_color_density[0];
	    wfc[1]  = subs.water_fog_color_density[1];
	    wfc[2]  = subs.water_fog_color_density[2];
	};

	exports.set_water_params = function(scene, water_params) {

	    var wp = scene._render.water_params;

	    if (!wp) {
	        m_print.error("set_water_params() - no water parameters on the scene");
	        return null;
	    }

	    if (typeof water_params.dst_noise_scale0 == "number")
	        wp.dst_noise_scale0 = water_params.dst_noise_scale0;
	    if (typeof water_params.dst_noise_scale1 == "number")
	        wp.dst_noise_scale1 = water_params.dst_noise_scale1;
	    if (typeof water_params.dst_noise_freq0 == "number")
	        wp.dst_noise_freq0 = water_params.dst_noise_freq0;
	    if (typeof water_params.dst_noise_freq1 == "number")
	        wp.dst_noise_freq1 = water_params.dst_noise_freq1;
	    if (typeof water_params.dir_min_shore_fac == "number")
	        wp.dir_min_shore_fac = water_params.dir_min_shore_fac;
	    if (typeof water_params.dir_freq == "number")
	        wp.dir_freq = water_params.dir_freq;
	    if (typeof water_params.dir_noise_scale == "number")
	        wp.dir_noise_scale = water_params.dir_noise_scale;
	    if (typeof water_params.dir_noise_freq == "number")
	        wp.dir_noise_freq = water_params.dir_noise_freq;
	    if (typeof water_params.dir_min_noise_fac == "number")
	        wp.dir_min_noise_fac = water_params.dir_min_noise_fac;
	    if (typeof water_params.dst_min_fac == "number")
	        wp.dst_min_fac = water_params.dst_min_fac;
	    if (typeof water_params.waves_hor_fac == "number")
	        wp.waves_hor_fac = water_params.waves_hor_fac;
	    if(typeof water_params.water_dynamic == "number")
	        wp.dynamic = water_params.water_dynamic;

	    var subscenes = subs_array(scene, MAIN_SUBSCENE_TYPES);

	    for (var i = 0; i < subscenes.length; i++) {
	        var sub = subscenes[i];

	        if (typeof water_params.water_fog_density == "number" && wp.fog_color_density)
	            sub.water_fog_color_density[3] = water_params.water_fog_density;

	        if (typeof water_params.water_fog_color == "object" && wp.fog_color_density)
	            sub.water_fog_color_density.set(water_params.water_fog_color);

	        sub.need_perm_uniforms_update = true;
	    }
	};

	exports.get_shore_dist = function(scene, trans, v_dist_mult) {

	    var wp = scene._render.water_params;
	    if (!wp.shoremap_image)
	        return SHORE_DIST_COMPAT;

	    // center and size of shore distance field
	    var size_x = wp.shoremap_size[0];
	    var size_y = wp.shoremap_size[1];
	    var center_x = wp.shoremap_center[0];
	    var center_y = wp.shoremap_center[1];
	    var max_shore_dist = wp.max_shore_dist;

	    var water_level = wp.water_level;

	    // get uv coords on shore distance map
	    var x = (trans[0] - center_x) / size_x;
	    var y = (center_y + trans[1]) / size_y;
	    x += 0.5;
	    y += 0.5;

	    // if position is out of boundings, consider that shore dist = 1
	    if (x > 1 || x < 0 || y > 1 || y < 0) {
	        var shore_dist = 1.0;
	    } else {
	        var width = wp.shoremap_tex_size;
	        var array = _active_scene._render.shore_distances;
	        var shore_dist_xy = max_shore_dist * m_util.get_array_smooth_value(array, width, x, y);
	        var shore_dist_z  = (water_level - trans[2]) * v_dist_mult;

	        var shore_dist = Math.sqrt(shore_dist_xy * shore_dist_xy +
	                shore_dist_z * shore_dist_z);
	        return shore_dist;
	    }
	};

	/**
	 * Executed every frame
	 * update all scenes
	 */
	exports.update = function(timeline, elapsed) {

	    var active_cam_render = get_active()._camera.render;

	    // update subscene params (uniforms)
	    for (var i = 0; i < _scenes.length; i++) {
	        var scene = _scenes[i];
	        var graph = scene._render.graph;
	        var render = scene._render;

	        if (render.water_params) {
	            var trans = m_tsr.get_trans_view(active_cam_render.world_tsr);
	            var cam_water_depth = trans[2] - get_water_surface_level(scene, trans[0], trans[1]);
	        }

	        for (var j = 0; j < render.video_textures.length; j++) {
	            var vtex = render.video_textures[j]._render;
	            var video = vtex.video_file;
	            var seq_video = vtex.seq_video;

	            if (scene["b4w_use_nla"] && vtex.use_nla)
	                continue;

	            if (!video && !seq_video)
	                continue;

	            if (!m_tex.video_is_played(vtex))
	                continue;

	            var current_frame = m_tex.video_get_current_frame(vtex);
	            var start_frame = m_tex.video_get_start_frame(vtex);
	            if (video && cfg_def.is_mobile_device)
	                start_frame -= FRAME_EPS;
	            var end_frame = m_tex.video_get_end_frame(vtex);

	            // NOTE: if frame_duration + frame_offset is bigger than the actual
	            // video length, cycled non-NLA video won't consider frames at
	            // the end of the cycle

	            // loop and initial reset
	            if (current_frame >= end_frame && vtex.use_cyclic
	                    || current_frame < start_frame) {
	                m_tex.reset_video(vtex);
	                if (seq_video)
	                    vtex.seq_last_discrete_mark = m_tex.seq_video_get_discrete_timemark(
	                            vtex, timeline);
	                continue;
	            }

	            // pause
	            if (current_frame >= end_frame && !vtex.use_cyclic) {
	                m_tex.pause_video(vtex);
	                continue;
	            }

	            // update
	            if (m_tex.video_update_is_available(vtex)) {
	                if (video)
	                    m_tex.update_video_texture(vtex);
	                else {
	                    var mark = m_tex.seq_video_get_discrete_timemark(vtex,
	                            timeline);
	                    if (mark != vtex.seq_last_discrete_mark) {
	                        m_tex.update_seq_video_texture(vtex);
	                        vtex.seq_cur_frame++;
	                    }
	                    vtex.seq_last_discrete_mark = mark;
	                }
	            }
	        }

	        m_graph.traverse(graph, function(node, attr) {
	            var subs = attr;
	            if (TIME_SUBSCENE_TYPES.indexOf(subs.type) > -1) {
	                subs.time = timeline;
	            }
	            if (render.water_params) {
	                subs.cam_water_depth = cam_water_depth;
	            }
	        });
	    }

	    // rendering
	    for (var i = 0; i < _scenes.length; i++) {
	        var scene = _scenes[i];
	        var render = scene._render;
	        var graph = render.graph;
	        var queue = render.queue;

	        // check if rendering needed
	        if (!queue.length)
	            continue;

	        if (render.need_shadow_update) {
	            update_shadow_subscenes(scene);
	            render.need_shadow_update = false;
	        }
	        if (render.need_grass_map_update) {
	            update_subs_grass_map(scene);
	            render.need_grass_map_update = false;
	        }
	        if (render.need_outline) {
	            enable_outline_draw(scene);
	            render.need_outline = false;
	        }
	        if (render.motion_blur)
	            update_motion_blur_subscenes(graph, elapsed);

	        // NOTE: temoporary disabled T2X mode due to artifacts with blend objects
	        //if (cfg_def.smaa && !m_cfg.context.alpha)
	        //    update_smaa_resolve_subscene(graph);

	        // find outline mask scene index
	        var outline_mask_subs = m_scgraph.find_subs(graph, m_subs.OUTLINE_MASK);

	        for (var j = 0; j < queue.length; j++) {
	            var qsubs = queue[j];
	            m_prerender.prerender_subs(qsubs);

	            // optimize outline supporting subscenes
	            if (outline_mask_subs)
	                optimize_outline_postprocessing(graph, qsubs, outline_mask_subs);

	            m_render.draw(qsubs);
	        }
	    }

	    // NOTE: temoporary disabled T2X mode due to artifacts with blend objects
	    //if (cfg_def.smaa && !m_cfg.context.alpha) {
	    //    m_render.increment_subpixel_index();
	    //    var cameras = active_cam_render.cameras;
	    //    for (var i = 0; i < cameras.length; i++) {
	    //        var cam = cameras[i];
	    //        m_mat4.copy(cam.view_proj_matrix, cam.prev_view_proj_matrix);
	    //    }
	    //}

	    if (cfg_def.show_hud_debug_info)
	        m_hud.show_debug_info(_scenes, elapsed);
	};

	exports.request_outline = function(scene) {
	    scene._render.need_outline = true;
	};

	function optimize_outline_postprocessing(graph, qsubs, outline_mask_subs) {
	    // optimize outline POSTPROCESSING subscenes rendering
	    if (qsubs.is_for_outline && qsubs.type == m_subs.POSTPROCESSING)
	        if (outline_mask_subs.do_render != qsubs.do_render)
	            qsubs.do_render = outline_mask_subs.do_render;

	    // optimize OUTLINE rendering if OUTLINE_MASK is switched off
	    if (!outline_mask_subs.do_render && qsubs.type == m_subs.OUTLINE)
	        qsubs.draw_outline_flag = 0;
	}

	function replace_attachment(graph, id, type, tex) {
	    var subs = m_graph.get_node_attr(graph, id);
	    m_cam.set_attachment(subs.camera, type, tex);

	    // TODO: assign now, not every frame
	    subs.assign_texture = true;

	    // replace linked textures
	    m_graph.traverse_outputs(graph, id, function(id_out, attr_out,
	            attr_edge) {

	        var slink = attr_edge;
	        if (slink.active && slink.from == type &&
	                m_scgraph.check_slink_tex_conn(slink))
	            replace_texture(graph, id_out, slink.to, tex);
	    });

	    // NOTE: bottom-up only
	    m_graph.traverse_inputs(graph, id, function(id_in, attr_in,
	            attr_edge) {

	        var slink = attr_edge;
	        if (slink.active && slink.from == type && slink.from == slink.to)
	            replace_attachment(graph, id_in, type, tex);
	    });
	}

	function replace_texture(graph, id, name, tex) {
	    var subs = m_graph.get_node_attr(graph, id);

	    var draw_data = subs.draw_data;
	    for (var i = 0; i < draw_data.length; i++) {
	        var bundles = draw_data[i].bundles;
	        for (var j = 0; j < bundles.length; j++) {
	            var batch = bundles[j].batch;
	            m_batch.replace_texture(batch, tex, name);
	        }
	    }
	}


	/**
	 * Update position of grass map camera.
	 * uses _vec3_tmp _vec3_tmp2 _quat4_tmp
	 */
	function update_subs_grass_map(bpy_scene) {

	    var subscenes_grass_map = subs_array(bpy_scene, [m_subs.GRASS_MAP]);
	    for (var i = 0; i < subscenes_grass_map.length; i++) {
	        var subs_grass_map = subscenes_grass_map[i];
	        var cam = subs_grass_map.camera;

	        var camera_render = bpy_scene._camera.render;
	        var camera_trans = m_tsr.get_trans(camera_render.world_tsr, _vec3_tmp);

	        // calculate grass map center point position relative to camera position
	        var trans = _vec3_tmp2;
	        trans[0] = 0;
	        trans[1] = 0;
	        trans[2] = -subs_grass_map.grass_map_dim[2] / 2;
	        var quat = m_tsr.get_quat(camera_render.world_tsr, _quat4_tmp);
	        m_vec3.transformQuat(trans, quat, trans);

	        // XY plane
	        trans[0] += camera_trans[0];
	        trans[1] += camera_trans[1];
	        trans[2] = 0;

	        // no rotation camera looks down
	        m_quat.identity(quat);

	        m_cam.set_view_trans_quat(cam, trans, quat);
	    }
	}


	function update_motion_blur_subscenes(graph, elapsed) {
	    // TODO: initialize motion blur accumulator texture from rendering input on
	    // the first iteration

	    m_graph.traverse(graph, function(id, attr) {
	        var subs = attr;

	        if (subs.type != m_subs.MOTION_BLUR)
	            return;

	        if (!subs.slinks_internal[0] || !subs.textures_internal[0])
	            m_util.panic("Wrong MOTION_BLUR subscene");

	        var slink = subs.slinks_internal[0];
	        var tex = subs.textures_internal[0];

	        subs.textures_internal[0] = subs.camera.color_attachment;

	        // next subscene may use same texture as input
	        m_graph.traverse_outputs(graph, id, function(id_out, attr_out, attr_edge) {
	            var slink_out = attr_edge;

	            if (slink_out.active)
	                replace_texture(graph, id_out, slink_out.to, tex);
	        });

	        replace_attachment(graph, id, slink.from, tex);
	        replace_texture(graph, id, slink.to, subs.textures_internal[0]);
	        subs.motion_blur_exp = Math.exp(-elapsed/subs.mb_factor);
	    });
	}

	exports.get_all_subscenes = function(scene) {
	    var graph = scene._render.graph;

	    var subscenes = [];
	    m_graph.traverse(graph, function(node, attr) {
	        subscenes.push(attr);
	    });

	    return subscenes;
	};

	exports.get_cam_water_depth = function() {
	    var subs = get_subs(_active_scene, m_subs.MAIN_BLEND);
	    var scene = _active_scene;

	    if (!subs && !scene._render.water_params)
	        return null;

	    return subs.cam_water_depth;
	};

	exports.update_scene_permanent_uniforms = update_scene_permanent_uniforms;
	function update_scene_permanent_uniforms(scene) {
	    var graph = scene._render.graph;

	    m_graph.traverse(graph, function(node, subs){
	        subs.need_perm_uniforms_update = true;
	    });
	}

	exports.set_debug_view_mode = function(subs_debug_view, mode) {
	    subs_debug_view.debug_view_mode = mode;
	    subs_debug_view.do_render = mode != m_debug.DV_NONE;
	    subs_debug_view.blend = (mode == m_debug.DV_TRANSPARENT_WIREFRAME);
	    subs_debug_view.need_perm_uniforms_update = true;

	    var active_scene = get_active();
	    for (var i = 0; i < MAIN_SUBSCENE_TYPES.length; i++) {
	        var subscenes = subs_array(active_scene, [MAIN_SUBSCENE_TYPES[i]]);
	        for (var j = 0; j < subscenes.length; j++)
	            subscenes[j].do_not_debug = (mode == m_debug.DV_RENDER_TIME);
	    }
	};

	exports.set_debug_colors_seed = function(subs_debug_view, seed) {
	    subs_debug_view.debug_colors_seed = seed;
	    subs_debug_view.need_perm_uniforms_update = true;
	};

	exports.set_render_time_threshold = function(subs_debug_view, threshold) {
	    subs_debug_view.debug_render_time_threshold = threshold;
	    subs_debug_view.need_perm_uniforms_update = true;
	};

	exports.set_wireframe_edge_color = function(subs_debug_view, color) {
	    var draw_data = subs_debug_view.draw_data;
	    for (var i = 0; i < draw_data.length; i++) {
	        var bundles = draw_data[i].bundles;
	        for (var j = 0; j < bundles.length; j++) {
	            var batch = bundles[j].batch;
	            m_vec3.copy(color, batch.wireframe_edge_color);
	            batch.shader.need_uniforms_update = true;
	        }
	    }
	};

	exports.update_force_scene = function(scene, obj) {
	    var field = obj.field;
	    var sc_wind = scene._render.wind;
	    if (field && field.type == "WIND" && sc_wind) {
	        var render = obj.render;
	        var quat = m_tsr.get_quat_view(render.world_tsr);
	        m_vec3.transformQuat(m_util.AXIS_Z, quat, sc_wind);
	        m_vec3.normalize(sc_wind, sc_wind);
	        m_vec3.scale(sc_wind, field.strength, sc_wind);

	        var subs_arr = subs_array(scene, TIME_SUBSCENE_TYPES);
	        for (var j = 0; j < subs_arr.length; j++)
	            subs_arr[j].wind.set(sc_wind);
	        return true;
	    }
	    return false;
	};

	exports.pick_color = function(scene, canvas_x, canvas_y) {
	    var subs_color_pick = get_subs(scene, m_subs.COLOR_PICKING);
	    if (subs_color_pick) {
	        // NOTE: rewrite camera.proj_matrix and camera.view_proj_matrix
	        // restoring not needed
	        var is_color_sub_debug = cfg_dbg.enabled && (cfg_dbg.subs_type === m_subs.COLOR_PICKING ||
	                cfg_dbg.subs_type === m_subs.COLOR_PICKING_XRAY);
	        if (is_color_sub_debug)
	            var viewport_xy = m_cont.canvas_to_viewport_coords(canvas_x, canvas_y,
	                    _vec2_tmp, subs_color_pick.camera);
	        else {
	            var canvas = m_cont.get_canvas();
	            var h = canvas.clientHeight;
	            var w = canvas.clientWidth;
	            m_cam.set_color_pick_proj(subs_color_pick.camera, canvas_x, canvas_y, w, h);
	        }

	        // NOTE: may be some delay since exports.update() execution
	        m_prerender.prerender_subs(subs_color_pick);
	        if (subs_color_pick.do_render)
	            m_render.draw(subs_color_pick);

	        var subs_color_pick_xray = get_subs(scene, m_subs.COLOR_PICKING_XRAY);
	        if (subs_color_pick_xray) {
	            m_mat4.copy(subs_color_pick.camera.proj_matrix,
	                    subs_color_pick_xray.camera.proj_matrix);
	            m_mat4.copy(subs_color_pick.camera.view_proj_matrix,
	                    subs_color_pick_xray.camera.view_proj_matrix);
	            m_util.extract_frustum_planes(
	                    subs_color_pick_xray.camera.view_proj_matrix,
	                    subs_color_pick_xray.camera.frustum_planes);
	            m_prerender.prerender_subs(subs_color_pick_xray);
	            if (subs_color_pick_xray.do_render)
	                m_render.draw(subs_color_pick_xray);
	            var cam = subs_color_pick_xray.camera;
	        } else
	            var cam = subs_color_pick.camera;

	        if (subs_color_pick.do_render ||
	                subs_color_pick_xray && subs_color_pick_xray.do_render)
	            if (is_color_sub_debug) {
	                viewport_xy[1] = cam.height - viewport_xy[1];
	                return m_render.read_pixels(cam.framebuffer, viewport_xy[0],
	                        viewport_xy[1], 1, 1, _pixel);
	            } else
	                return m_render.read_pixels(subs_color_pick_xray?
	                        subs_color_pick_xray.camera.framebuffer:
	                        subs_color_pick.camera.framebuffer, 0, 0, 1, 1, _pixel);
	        else
	            return null;
	    } else
	        m_print.error("Object Selection is not available on the scene");

	    return null;
	};

	exports.set_outline_color = set_outline_color;
	function set_outline_color(color) {
	    var scene = get_active();
	    var outline_subscenes = subs_array(scene, [m_subs.OUTLINE]);
	    for (var i = 0; i < outline_subscenes.length; i++) {
	        var subs = outline_subscenes[i];
	        subs.outline_color.set(color);
	        subs.need_perm_uniforms_update = true;
	    }
	}

	/**
	 * return wind vector
	 */
	exports.get_wind = get_wind;
	function get_wind(scene) {
	    return scene._render.wind;
	}

	exports.get_meta_tags = function(scene) {
	    var tags = {
	        title: "",
	        description: ""
	    };

	    if (scene["b4w_tags"]) {
	        tags.title = scene["b4w_tags"]["title"];
	        tags.description = scene["b4w_tags"]["description"];
	    }

	    return tags;
	};

	exports.get_custom_prop = function(scene) {
	    return scene["b4w_custom_prop"];
	};

	exports.update_cube_reflect_subs = function(subs, trans) {
	    var vm_trans = _vec3_tmp;
	    m_vec3.negate(trans, vm_trans);
	    for (var i = 0; i < 6; i++) {
	        var vm = subs.cube_view_matrices[i];
	        var frustum = subs.cube_cam_frustums[i];
	        var cam = subs.camera;
	        m_mat4.translate(m_util.INV_CUBE_VIEW_MATRS[i], vm_trans, vm);
	        m_mat4.multiply(cam.proj_matrix, vm, cam.view_proj_matrix);
	        m_util.extract_frustum_planes(cam.view_proj_matrix, frustum);
	    }
	};

	exports.update_plane_reflect_subs = function(subs, trans, quat) {
	    var cam = subs.camera;
	    m_util.trans_quat_to_plane(trans, quat, m_util.AXIS_Z,
	                               cam.reflection_plane);
	};

	exports.assign_scene_data_subs = function(scene, objects, lamps) {

	    var reflection_params = scene._render.reflection_params;
	    if (reflection_params && objects)
	        for (var i = 0; i < objects.length; i++) {
	            var obj = objects[i];
	            var sc_data = m_obj_util.get_scene_data(obj, scene);

	            if (obj.render.plane_reflection_id != -1) {
	                var plane_refl_subs = reflection_params.plane_refl_subs;
	                var plane_refl_subs_blend = reflection_params.plane_refl_subs_blend;
	                var refl_id = obj.render.plane_reflection_id;

	                if (plane_refl_subs_blend.length && refl_id < plane_refl_subs_blend.length) {
	                    sc_data.plane_refl_subs = plane_refl_subs_blend[refl_id];
	                } else if (plane_refl_subs.length && refl_id < plane_refl_subs.length)
	                    sc_data.plane_refl_subs = plane_refl_subs[refl_id];

	            } else if (obj.render.cube_reflection_id != -1) {
	                var cube_refl_subs = reflection_params.cube_refl_subs;
	                var cube_refl_subs_blend = reflection_params.cube_refl_subs_blend;
	                var refl_id = obj.render.cube_reflection_id;

	                if (cube_refl_subs_blend.length)
	                    sc_data.cube_refl_subs = cube_refl_subs_blend[refl_id];
	                else if (cube_refl_subs.length)
	                    sc_data.cube_refl_subs = cube_refl_subs[refl_id];
	            }
	        }

	    if (lamps) {
	        var use_ssao = cfg_def.ssao && scene["b4w_enable_ssao"];
	        var shadow_lamps = m_obj_util.get_shadow_lamps(lamps, use_ssao);
	        var shadow_params = scene._render.shadow_params;

	        for (var i = 0; i < shadow_lamps.length; i++) {
	            var sc_data = m_obj_util.get_scene_data(shadow_lamps[i], scene);
	            if (shadow_params) {
	                //TODO: assign proper subscenes for each lamp
	                var shadow_subscenes = subs_array(scene, [m_subs.SHADOW_CAST]);
	                for (var j = 0; j < shadow_subscenes.length; j++)
	                    if (i == shadow_subscenes[j].shadow_lamp_index)
	                        sc_data.shadow_subscenes.push(shadow_subscenes[j]);
	            }
	        }
	    }
	};

	function get_plane_refl_id_by_subs(scene, subs) {
	    var refl_subs = scene._render.reflection_params.plane_refl_subs;
	    for (var i = 0; i < refl_subs.length; i++) {
	        for (var j = 0; j < refl_subs[i].length; j++)
	            if (refl_subs[i][j] == subs)
	                return i;
	    }
	    var refl_subs_blend = scene._render.reflection_params.plane_refl_subs_blend;
	    for (var i = 0; i < refl_subs_blend.length; i++) {
	        for (var j = 0; j < refl_subs_blend[i].length; j++)
	            if (refl_subs_blend[i][j] == subs)
	                return i;
	    }
	    return null;
	}

	function get_cube_refl_id_by_subs(scene, subs) {

	    if (!scene._render.reflection_params)
	        return null;

	    var refl_subs = scene._render.reflection_params.cube_refl_subs;
	    for (var i = 0; i < refl_subs.length; i++) {
	        if (refl_subs[i] == subs)
	            return i;
	    }
	    var refl_subs_blend = scene._render.reflection_params.cube_refl_subs_blend;
	    for (var i = 0; i < refl_subs_blend.length; i++) {
	        if (refl_subs_blend[i] == subs)
	            return i;
	    }
	    return null;
	}

	exports.marker_frame = function(scene, name) {
	    return scene["timeline_markers"][name];
	};

	exports.set_hmd_params = function(hmd_params) {
	    var active_scene = get_active();
	    var subs_stereo = get_subs(active_scene, m_subs.STEREO);

	    if (!subs_stereo)
	        return;

	    if (hmd_params.distortion_coefs) {
	        subs_stereo.distortion_params[0] = hmd_params.distortion_coefs[0];
	        subs_stereo.distortion_params[1] = hmd_params.distortion_coefs[1];
	        subs_stereo.need_perm_uniforms_update = true;
	    }

	    if (hmd_params.chromatic_aberration_coefs) {
	        subs_stereo.chromatic_aberration_coefs[0] = hmd_params.chromatic_aberration_coefs[0];
	        subs_stereo.chromatic_aberration_coefs[1] = hmd_params.chromatic_aberration_coefs[1];
	        subs_stereo.chromatic_aberration_coefs[2] = hmd_params.chromatic_aberration_coefs[2];
	        subs_stereo.chromatic_aberration_coefs[3] = hmd_params.chromatic_aberration_coefs[3];
	        subs_stereo.need_perm_uniforms_update = true;
	    }

	    if (hmd_params.base_line_factor) {
	        subs_stereo.distortion_params[2] = hmd_params.base_line_factor;
	        subs_stereo.need_perm_uniforms_update = true;
	    }
	    if (hmd_params.inter_lens_factor) {
	        subs_stereo.distortion_params[3] = hmd_params.inter_lens_factor;
	        subs_stereo.need_perm_uniforms_update = true;
	    }

	    if (hmd_params.enable_hmd_stereo != null) {
	        subs_stereo.enable_hmd_stereo = hmd_params.enable_hmd_stereo;
	        subs_stereo.need_perm_uniforms_update = true;
	    }
	};

	exports.multiply_size_mult = function(multiplier_x, multiplier_y) {
	    var scenes = get_all_scenes();

	    for (var i = 0; i < scenes.length; i++) {
	        var scene = scenes[i];
	        var graph = exports.get_graph(scene);

	        m_scgraph.multiply_size_mult_by_graph(graph, multiplier_x, multiplier_y);
	    }
	};

	exports.update_all_mesh_shaders = function(scene) {
	    var lamps = m_obj.get_scene_objs(scene, "LAMP", m_obj.DATA_ID_ALL);
	    var subs_arr = subs_array(scene, OBJECT_SUBSCENE_TYPES);

	    for (var i = 0; i < subs_arr.length; i++) {
	        var subs = subs_arr[i];
	        var draw_data = subs.draw_data;
	        for (var j = 0; j < draw_data.length; j++) {
	            var bundles = draw_data[j].bundles;
	            for (var k = 0; k < bundles.length; k++) {
	                var bundle = bundles[k];
	                var batch = bundle.batch;
	                if (batch.type != "MAIN")
	                    continue;
	                m_batch.update_batch_lights(batch, lamps, scene);
	                m_batch.update_shader(batch);
	                m_subs.append_draw_data(subs, bundle);
	            }
	        }
	    }
	};

	exports.recalculate_draw_data = function(batch) {
	    // called only after batch.shader was recompiled
	    for (var i = 0; i < _scenes.length; i++) {
	        var graph = _scenes[i]._render.graph;
	        m_graph.traverse(graph, function(node, attr) {
	            var subs = attr;
	            var draw_data = subs.draw_data;
	            for (var j = 0; j < draw_data.length; j++) {
	                var bundles = draw_data[j].bundles;
	                for (var k = 0; k < bundles.length; k++) {
	                    var bundle = bundles[k];
	                    if (bundle.batch == batch)
	                        m_subs.append_draw_data(subs, bundle);
	                }
	            }
	        });
	    }
	};

	}

	var int_scenes_factory = register("__scenes", Int_scenes);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Constraints internal API.
	 * @name constraints
	 * @namespace
	 * @exports exports as constraints
	 */
	function Int_constraints(ns, exports) {

	// (4) Main Engine Entitles
	var m_phy   = int_physics_factory(ns);

	var m_armat = int_armature_factory(ns);
	var m_cam   = int_camera_factory(ns);

	// (6) Config-independent utilitary modules
	var m_tsr   = int_tsr_factory(ns);

	var m_util  = int_util_factory(ns);

	// (7) Independent libs
	var m_quat  = quat_factory(ns);
	var m_vec3  = vec3_factory(ns);


	var CONS_TYPE_STIFF_OBJ           = 1;
	var CONS_TYPE_STIFF_BONE          = 2;
	var CONS_TYPE_TRACK_OBJ           = 3;
	var CONS_TYPE_FOLLOW_OBJ          = 5;
	var CONS_TYPE_STIFF_TRANS_OBJ     = 7;
	var CONS_TYPE_COPY_LOC_OBJ        = 8;
	var CONS_TYPE_COPY_ROT_OBJ        = 9;
	// var CONS_TYPE_COPY_SCALE_OBJ      = 10;
	var CONS_TYPE_COPY_TRANS_OBJ      = 11;
	var CONS_TYPE_SEMI_STIFF_OBJ      = 12;
	var CONS_TYPE_CHILD_OF            = 13;
	var CONS_TYPE_CHILD_OF_BONE       = 14;
	var CONS_TYPE_SEMI_SOFT_OBJ       = 15;
	var CONS_TYPE_STIFF_TRANS_ROT_OBJ = 16;
	var CONS_TYPE_STIFF_VIEWPORT      = 17;
	var BONE_CONS_TYPE_STIFF_OBJ      = 18;

	exports.CONS_TYPE_STIFF_OBJ = CONS_TYPE_STIFF_OBJ;
	exports.CONS_TYPE_STIFF_BONE = CONS_TYPE_STIFF_BONE;
	exports.CONS_TYPE_TRACK_OBJ = CONS_TYPE_TRACK_OBJ;
	exports.CONS_TYPE_FOLLOW_OBJ = CONS_TYPE_FOLLOW_OBJ;
	exports.CONS_TYPE_STIFF_TRANS_OBJ = CONS_TYPE_STIFF_TRANS_OBJ;
	exports.CONS_TYPE_COPY_LOC_OBJ = CONS_TYPE_COPY_LOC_OBJ;
	exports.CONS_TYPE_SEMI_STIFF_OBJ = CONS_TYPE_SEMI_STIFF_OBJ;
	exports.CONS_TYPE_CHILD_OF = CONS_TYPE_CHILD_OF;
	exports.CONS_TYPE_CHILD_OF_BONE = CONS_TYPE_CHILD_OF_BONE;
	exports.CONS_TYPE_SEMI_SOFT_OBJ = CONS_TYPE_SEMI_SOFT_OBJ;
	exports.CONS_TYPE_STIFF_TRANS_ROT_OBJ = CONS_TYPE_STIFF_TRANS_ROT_OBJ;
	exports.CONS_TYPE_STIFF_VIEWPORT = CONS_TYPE_STIFF_VIEWPORT;

	exports.BONE_CONS_TYPE_STIFF_OBJ = BONE_CONS_TYPE_STIFF_OBJ;

	var _vec2_tmp   = new Float32Array(2);
	var _vec2_tmp_2 = new Float32Array(2);
	var _vec3_tmp   = new Float32Array(3);
	var _vec3_tmp_2 = new Float32Array(3);
	var _quat4_tmp  = new Float32Array(4);
	var _quat4_tmp2  = new Float32Array(4);
	var _tsr_tmp    = m_tsr.create();

	var _parent_y_axis = new Float32Array(3);

	/**
	 * Apply stiff-to-object constraint.
	 */
	exports.append_stiff_obj = function(obj, obj_parent, offset, rotation_offset, 
	        scale_offset) {
	    var cons = init_cons(CONS_TYPE_STIFF_OBJ);

	    // link to parent object
	    cons.obj_parent = obj_parent;
	    cons.tsr_offset = m_tsr.create();

	    rotation_offset = rotation_offset ? rotation_offset : m_quat.create();

	    m_tsr.set_trans(offset, cons.tsr_offset);
	    m_tsr.set_scale(scale_offset, cons.tsr_offset);
	    m_tsr.set_quat(rotation_offset, cons.tsr_offset);

	    cons.tsr_restore = new Float32Array(obj.render.world_tsr);

	    apply_cons(obj, cons);
	    update_cons(obj, cons, 0);
	};

	/**
	 * Apply stiff-to-bone constraint.
	 */
	exports.append_stiff_bone = function(obj, armobj, bone_name, offset,
	        rotation_offset, scale_offset) {

	    var cons = init_cons(CONS_TYPE_STIFF_BONE);

	    // link to parent object
	    cons.obj_parent = armobj;
	    cons.bone_name = bone_name;
	    cons.tsr_restore = new Float32Array(obj.render.world_tsr);
	    cons.tsr_offset = m_tsr.create();
	    m_tsr.set_trans(new Float32Array(offset), cons.tsr_offset);
	    m_tsr.set_quat(new Float32Array(rotation_offset), cons.tsr_offset);
	    m_tsr.set_scale(scale_offset, cons.tsr_offset);

	    apply_cons(obj, cons);
	    update_cons(obj, cons, 0);
	};

	/**
	 * Apply semi-stiff-to-object constraint.
	 */
	exports.append_semi_stiff_obj = function(obj, obj_parent, offset, rotation_offset,
	                                        clamp_left, clamp_right, clamp_up, clamp_down) {

	    var cons = init_cons(CONS_TYPE_SEMI_STIFF_OBJ);
	    var quat = m_tsr.get_quat_view(obj.render.world_tsr);
	    var p_quat = m_tsr.get_quat_view(obj_parent.render.world_tsr);

	    // override initial rotation for object
	    if (rotation_offset) {
	        m_quat.copy(rotation_offset, quat);
	        m_quat.multiply(p_quat, quat, quat);
	    } else
	        rotation_offset = m_quat.create();

	    // link to parent object
	    cons.obj_parent = obj_parent;
	    cons.tsr_offset = m_tsr.create();

	    m_tsr.set_trans(offset, cons.tsr_offset);
	    m_tsr.set_quat(rotation_offset, cons.tsr_offset);
	    cons.parent_prev_rotation = new Float32Array(p_quat);

	    cons.clamp_left = m_util.angle_wrap_0_2pi(clamp_left);
	    cons.clamp_right = m_util.angle_wrap_0_2pi(clamp_right);
	    cons.clamp_up = m_util.angle_wrap_periodic(clamp_up, -Math.PI, Math.PI);
	    cons.clamp_down = m_util.angle_wrap_periodic(clamp_down, -Math.PI, Math.PI);

	    cons.tsr_restore = new Float32Array(obj.render.world_tsr);

	    apply_cons(obj, cons);
	    update_cons(obj, cons, 0);
	};

	exports.append_semi_soft_obj = function(obj, obj_parent, offset, softness) {

	    var cons = init_cons(CONS_TYPE_SEMI_SOFT_OBJ);

	    // link to parent object
	    cons.obj_parent = obj_parent;
	    cons.softness = softness;
	    cons.tsr_restore = new Float32Array(obj.render.world_tsr);
	    cons.tsr_offset = m_tsr.create();
	    m_tsr.set_trans(new Float32Array(offset), cons.tsr_offset);

	    apply_cons(obj, cons);
	    update_cons(obj, cons, 0);
	};

	exports.append_stiff_trans_rot_obj = function(obj, obj_parent, offset, rotation_offset, scale_offset) {

	    var cons = init_cons(CONS_TYPE_STIFF_TRANS_ROT_OBJ);

	    // link to parent object
	    cons.obj_parent = obj_parent;
	    cons.tsr_restore = new Float32Array(obj.render.world_tsr);
	    cons.tsr_offset = m_tsr.create();
	    m_tsr.set_trans(new Float32Array(offset), cons.tsr_offset);
	    m_tsr.set_quat(new Float32Array(rotation_offset), cons.tsr_offset);
	    m_tsr.set_scale(scale_offset, cons.tsr_offset);

	    apply_cons(obj, cons);
	    update_cons(obj, cons, 0);
	};

	function init_cons(type) {

	    var cons = {
	        // general info
	        type : type,
	        obj_parent : null,
	        target : null,
	        // location, scale, rotation
	        use_offset : false,
	        tsr_restore : null,
	        tsr_offset : null,
	        euler_offset : null,
	        // coordinate axes
	        axes : null,
	        track_axis : null,
	        vertical_axis : null,
	        use_target_z : false,
	        // another stuff
	        influence : 0,
	        bone_name : "",
	        softness : 0,

	        clamp_left: 0,
	        clamp_right : 0,
	        clamp_up : 0,
	        clamp_down : 0,

	        dist_min : 0,
	        dist_max : 0,

	        left_edge: false,
	        left_right_dist: 0,
	        top_edge: false,
	        top_bottom_dist: 0,
	        distance: 0,
	        hor_units: "",
	        vert_units: ""
	    };

	    return cons;
	}

	function apply_cons(obj, cons) {

	    if (obj.constraint && obj.constraint.obj_parent)
	        remove_parent_descendant(obj.constraint.obj_parent, obj);

	    if (cons.obj_parent)
	        assign_parent_descendant(cons.obj_parent, obj);

	    // may override previous
	    obj.constraint = cons;
	}

	function assign_parent_descendant(obj_parent, obj) {
	    if (obj_parent.cons_descends.indexOf(obj) == -1)
	        obj_parent.cons_descends.push(obj);
	    else
	        m_util.panic("Descendant object override is forbidden");
	}

	exports.remove_parent_descendant = remove_parent_descendant;
	function remove_parent_descendant(obj_parent, obj) {
	    var ind = obj_parent.cons_descends.indexOf(obj);
	    if (ind != -1)
	        obj_parent.cons_descends.splice(ind, 1);
	    else
	        m_util.panic("No descendant object");
	}

	/**
	 * Append track-to-object constraint.
	 */
	exports.append_track_obj = append_track_obj;
	function append_track_obj(obj, obj_parent, track_axis, vertical_axis, use_target_z, influence) {
	    var cons = init_cons(CONS_TYPE_TRACK_OBJ);
	    // link to parent object
	    cons.obj_parent = obj_parent;
	    cons.track_axis = new Float32Array(track_axis);
	    cons.vertical_axis = new Float32Array(vertical_axis);
	    cons.use_target_z = use_target_z;
	    cons.tsr_restore = new Float32Array(obj.render.world_tsr);
	    cons.influence = influence;
	    apply_cons(obj, cons);
	    update_cons(obj, cons, 0);
	}

	/**
	 * Append follow object constraint.
	 */
	exports.append_follow_obj = function(obj, obj_parent, dist_min, dist_max) {
	    var cons = init_cons(CONS_TYPE_FOLLOW_OBJ);

	    // link to parent object
	    cons.obj_parent = obj_parent;
	    cons.dist_min = dist_min;
	    cons.dist_max = dist_max;
	    cons.tsr_restore = new Float32Array(obj.render.world_tsr);

	    apply_cons(obj, cons);
	    update_cons(obj, cons, 0);
	};

	/**
	 * Apply stiff translation constraint.
	 */
	exports.append_stiff_trans_obj = function(obj, obj_parent, offset) {
	    var cons = init_cons(CONS_TYPE_STIFF_TRANS_OBJ);

	    cons.obj_parent = obj_parent;
	    cons.tsr_offset = m_tsr.create();
	    cons.tsr_restore = new Float32Array(obj.render.world_tsr);
	    m_tsr.set_trans(new Float32Array(offset), cons.tsr_offset);

	    apply_cons(obj, cons);
	    update_cons(obj, cons, 0);
	};

	/**
	 * Apply copy translation constraint.
	 */
	exports.append_copy_loc_obj = append_copy_loc_obj;
	function append_copy_loc_obj(obj, obj_parent, offset, axes, use_offset, influence) {
	    var cons = init_cons(CONS_TYPE_COPY_LOC_OBJ);

	    cons.obj_parent = obj_parent;
	    cons.tsr_offset = m_tsr.create();
	    m_tsr.set_trans(offset, cons.tsr_offset);
	    cons.axes = new Float32Array(axes);
	    cons.influence = influence;
	    cons.use_offset = use_offset;
	    cons.tsr_restore = new Float32Array(obj.render.world_tsr);

	    apply_cons(obj, cons);
	    update_cons(obj, cons, 0);
	}

	exports.append_copy_rot_obj = append_copy_rot_obj;
	function append_copy_rot_obj(obj, obj_parent, axes, use_offset, influence) {
	    var cons = init_cons(CONS_TYPE_COPY_ROT_OBJ);
	    cons.obj_parent = obj_parent;

	    var obj_quat = m_tsr.get_quat(obj.render.world_tsr, _quat4_tmp2);
	    // this is a disputable point: maybe we should use m_util.quat_to_eul_opt
	    cons.euler_offset = m_util.quat_to_euler(obj_quat, new Float32Array(3));

	    cons.axes = new Float32Array(axes);
	    cons.influence = influence;
	    cons.use_offset = use_offset;
	    cons.tsr_restore = new Float32Array(obj.render.world_tsr);
	    apply_cons(obj, cons);
	    update_cons(obj, cons, 0);
	}

	exports.append_copy_trans_obj = append_copy_trans_obj;
	function append_copy_trans_obj(obj, obj_parent, influence) {
	    var cons = init_cons(CONS_TYPE_COPY_TRANS_OBJ);

	    cons.obj_parent = obj_parent;
	    cons.tsr_offset = m_tsr.create();
	    m_tsr.copy(obj.render.world_tsr, cons.tsr_offset);
	    cons.tsr_restore = new Float32Array(obj.render.world_tsr);

	    cons.influence = influence;

	    apply_cons(obj, cons);
	    update_cons(obj, cons, 0);
	}


	/**
	 * Append child of constraint.
	 */
	exports.append_child_of = append_child_of;
	function append_child_of(obj, obj_parent, tsr_offset) {
	    var cons = init_cons(CONS_TYPE_CHILD_OF);

	    cons.obj_parent = obj_parent;
	    cons.tsr_offset = new Float32Array(tsr_offset);

	    apply_cons(obj, cons);
	    update_cons(obj, cons, 0);
	}

	/**
	 * Append child of constraint.
	 */
	exports.append_child_of_bone = append_child_of_bone;
	function append_child_of_bone(obj, armobj, bone_name, tsr_offset) {
	    var cons = init_cons(CONS_TYPE_CHILD_OF_BONE);

	    cons.obj_parent = armobj;
	    cons.bone_name = bone_name;
	    cons.tsr_offset = new Float32Array(tsr_offset);

	    apply_cons(obj, cons);
	    update_cons(obj, cons, 0);
	}

	exports.append_stiff_viewport = append_stiff_viewport;
	function append_stiff_viewport(obj, camobj, positioning) {
	    var cons = init_cons(CONS_TYPE_STIFF_VIEWPORT);

	    cons.obj_parent = camobj;
	    cons.tsr_restore = new Float32Array(obj.render.world_tsr);
	    cons.tsr_offset = m_tsr.create();

	    if (m_util.isdef(positioning.right)) {
	        cons.left_edge = false;
	        cons.left_right_dist = positioning.right;
	    } else if (m_util.isdef(positioning.left)) {
	        cons.left_edge = true;
	        cons.left_right_dist = positioning.left;
	    } else {
	        cons.left_edge = true;
	        cons.left_right_dist = 0;
	    }

	    if (m_util.isdef(positioning.bottom)) {
	        cons.top_edge = false;
	        cons.top_bottom_dist = positioning.bottom;
	    } else if (m_util.isdef(positioning.top)) {
	        cons.top_edge = true;
	        cons.top_bottom_dist = positioning.top;
	    } else {
	        cons.top_edge = true;
	        cons.top_bottom_dist = 0;
	    }

	    if (m_util.isdef(positioning.distance)) {
	        cons.distance = positioning.distance;
	    } else {
	        cons.distance = 0;
	    }

	    if (m_util.isdef(positioning.rotation))
	        var rotation_offset = new Float32Array(positioning.rotation);
	    else
	        var rotation_offset = m_quat.create();
	    m_tsr.set_quat(rotation_offset, cons.tsr_offset);

	    if (m_util.isdef(positioning.hor_units))
	        cons.hor_units = positioning.hor_units;
	    else
	        cons.hor_units = "widths";

	    if (m_util.isdef(positioning.vert_units))
	        cons.vert_units = positioning.vert_units;
	    else
	        cons.vert_units = "heights";

	    apply_cons(obj, cons);
	    update_cons(obj, cons, 0);
	}

	/**
	 * Executed frequently.
	 */
	exports.update_constraint = function(obj, elapsed) {
	    if (obj.constraint)
	        update_cons(obj, obj.constraint, elapsed);
	};

	/**
	 * Only trans/quat affected by constraint here
	 */
	function update_cons(obj, cons, elapsed) {
	    switch (cons.type) {
	    case CONS_TYPE_STIFF_OBJ:
	        m_tsr.multiply(cons.obj_parent.render.world_tsr, cons.tsr_offset, obj.render.world_tsr);
	        break;
	    case CONS_TYPE_SEMI_STIFF_OBJ:

	        var trans = m_tsr.get_trans_view(obj.render.world_tsr);
	        var quat = m_tsr.get_quat_view(obj.render.world_tsr);

	        var offset = m_tsr.get_trans(cons.tsr_offset, _vec3_tmp);

	        var p_world_tsr = cons.obj_parent.render.world_tsr;
	        var p_quat = m_tsr.get_quat_view(cons.obj_parent.render.world_tsr);

	        // Qp * Qp_prev_inv * Q
	        m_quat.multiply(
	                m_quat.invert(cons.parent_prev_rotation, cons.parent_prev_rotation),
	                quat, quat);
	        m_quat.multiply(p_quat, quat, quat);

	        m_tsr.transform_vec3(offset, p_world_tsr, trans);
	        m_quat.copy(p_quat, cons.parent_prev_rotation);
	        clamp_orientation(obj, cons);
	        break;
	    case CONS_TYPE_SEMI_SOFT_OBJ:

	        var trans          = m_tsr.get_trans_view(obj.render.world_tsr);
	        var quat           = m_tsr.get_quat_view(obj.render.world_tsr);
	        var p_world_tsr    = cons.obj_parent.render.world_tsr;
	        var p_trans        = m_tsr.get_trans_view(p_world_tsr);
	        var softness       = cons.softness;
	        var trans_pivot    = _vec3_tmp;
	        var quat_pivot     = m_quat.copy(quat, _quat4_tmp);
	        var softness_ratio = 0.16;
	        var offset         = m_tsr.get_trans(cons.tsr_offset, _vec3_tmp_2);

	        m_tsr.transform_vec3(offset, p_world_tsr, trans_pivot);
	        m_util.smooth_v(trans_pivot, trans, elapsed, softness, trans);

	        m_util.quat_rotate_to_target(trans, quat_pivot, p_trans, m_util.AXIS_MZ);
	        m_util.smooth_q(quat_pivot, quat, elapsed, softness * softness_ratio, quat);

	        break;
	    case CONS_TYPE_STIFF_BONE:
	        var quat = m_tsr.get_quat_view(obj.render.world_tsr);
	        var p_tsr = _tsr_tmp;

	        var offset = m_tsr.get_trans(cons.tsr_offset, _vec3_tmp_2);
	        var scale_offset = m_tsr.get_scale(cons.tsr_offset);
	        var rotation_offset = m_tsr.get_quat(cons.tsr_offset, _quat4_tmp);

	        m_armat.get_bone_tsr(cons.obj_parent, cons.bone_name, true, false,
	                             p_tsr);
	        // from armature to world space
	        m_tsr.multiply(cons.obj_parent.render.world_tsr, p_tsr, p_tsr);

	        quat[0] = p_tsr[4];
	        quat[1] = p_tsr[5];
	        quat[2] = p_tsr[6];
	        quat[3] = p_tsr[7];

	        m_quat.multiply(quat, rotation_offset, quat);
	        m_tsr.set_scale(scale_offset * p_tsr[3], obj.render.world_tsr);

	        var trans = m_tsr.get_trans_view(obj.render.world_tsr);
	        m_tsr.transform_vec3(offset, p_tsr, trans);

	        break;
	    case CONS_TYPE_TRACK_OBJ:
	        var trans = m_tsr.get_trans_view(obj.render.world_tsr);
	        var quat = m_tsr.get_quat_view(obj.render.world_tsr);
	        var t_trans = m_tsr.get_trans_view(cons.obj_parent.render.world_tsr);
	        var f = cons.influence;

	        if (cons.use_target_z) {
	            var t_quat = m_tsr.get_quat(cons.obj_parent.render.world_tsr, _quat4_tmp);
	            var target_axis = m_vec3.transformQuat(m_util.AXIS_Z, t_quat, _vec3_tmp);
	        } else
	            var target_axis = m_util.AXIS_Z;
	        m_util.quat_rotate_to_target(trans, quat, t_trans, cons.track_axis);
	        var dir = m_vec3.subtract(t_trans, trans, _vec3_tmp_2);
	        m_vec3.normalize(dir, dir);
	        m_util.quat_set_vertical_axis(quat, cons.vertical_axis, target_axis, dir);
	        var o_quat = m_tsr.get_quat(cons.tsr_restore, _quat4_tmp);
	        m_quat.slerp(o_quat, quat, f, quat);

	        m_tsr.set_trans(trans, cons.tsr_restore);
	        break;

	    case CONS_TYPE_FOLLOW_OBJ:
	        var trans = m_tsr.get_trans_view(obj.render.world_tsr);
	        var quat = m_tsr.get_quat_view(obj.render.world_tsr);
	        var t_trans = m_tsr.get_trans_view(cons.obj_parent.render.world_tsr);

	        m_util.quat_rotate_to_target(trans, quat, t_trans, m_util.AXIS_MZ);

	        // shrink distance
	        var dist = m_vec3.dist(trans, t_trans);

	        // passing target location
	        if (dist > cons.dist_max)
	            var delta = dist - cons.dist_max;
	        else if (dist < cons.dist_min)
	            var delta = dist - cons.dist_min;
	        else
	            var delta = 0.0;

	        if (delta) {
	            // NOTE: from trans to t_trans
	            m_vec3.sub(t_trans, trans, _vec3_tmp);
	            m_vec3.normalize(_vec3_tmp, _vec3_tmp);
	            m_vec3.scale(_vec3_tmp, delta, _vec3_tmp);
	            m_vec3.add(trans, _vec3_tmp, trans);
	        }

	        break;
	    case CONS_TYPE_STIFF_TRANS_OBJ:
	        var p_world_tsr = cons.obj_parent.render.world_tsr;
	        var trans = m_tsr.get_trans_view(obj.render.world_tsr);
	        var offset = m_tsr.get_trans(cons.tsr_offset, _vec3_tmp);
	        m_tsr.transform_vec3(offset, p_world_tsr, trans);

	        m_tsr.set_quat(m_tsr.get_quat_view(obj.render.world_tsr), cons.tsr_restore);
	        break;
	    case CONS_TYPE_COPY_LOC_OBJ:
	        var p_trans = m_tsr.get_trans_view(cons.obj_parent.render.world_tsr);
	        var trans = m_tsr.get_trans_view(obj.render.world_tsr);
	        var axes = cons.axes;

	        var def_offset = m_tsr.get_trans(cons.tsr_offset, _vec3_tmp);
	        var offset = m_vec3.set(0, 0, 0, _vec3_tmp_2);
	        if (cons.use_offset)
	            m_vec3.add(offset, def_offset, offset);
	        var f = cons.influence;
	        if (axes[0])
	            trans[0] = (1 - f) * def_offset[0] + f * (m_util.sign(axes[0]) * p_trans[0] + offset[0]);
	        if (axes[1])
	            trans[1] = (1 - f) * def_offset[1] + f * (m_util.sign(axes[1]) * p_trans[1] + offset[1]);
	        if (axes[2])
	            trans[2] = (1 - f) * def_offset[2] + f * (m_util.sign(axes[2]) * p_trans[2] + offset[2]);

	        m_tsr.set_quat(m_tsr.get_quat_view(obj.render.world_tsr), cons.tsr_restore);
	        break;
	    case CONS_TYPE_COPY_ROT_OBJ:
	        var axes = cons.axes;
	        var p_quat = m_tsr.get_quat(cons.obj_parent.render.world_tsr, _quat4_tmp);

	        var euler = m_util.quat_to_eul_opt(p_quat, cons.euler_offset, _vec3_tmp_2);
	        m_util.compatible_euler(euler, cons.euler_offset);

	        if (axes[0]) {
	            if (cons.use_offset) {
	                var beul = m_vec3.set(cons.euler_offset[0], 0, 0, _vec3_tmp);
	                m_util.rotate_eul(euler, beul, euler);
	            }
	            euler[0] = m_util.sign(axes[0]) * euler[0];
	        } else
	            euler[0] = cons.euler_offset[0];


	        if (axes[1]) {
	            if (cons.use_offset) {
	                var beul = m_vec3.set(0, cons.euler_offset[1], 0, _vec3_tmp);
	                m_util.rotate_eul(euler, beul, euler);
	            }
	            euler[1] = m_util.sign(axes[1]) * euler[1];
	        } else
	            euler[1] = cons.euler_offset[1];

	        if (axes[2]) {
	            if (cons.use_offset) {
	                var beul = m_vec3.set(0, 0, cons.euler_offset[2], _vec3_tmp);
	                m_util.rotate_eul(euler, beul, euler);
	            }
	            euler[2] = m_util.sign(axes[2]) * euler[2];
	        } else
	            euler[2] = cons.euler_offset[2];

	        m_util.compatible_euler(euler, cons.euler_offset);
	        var f = cons.influence;
	        var target_quat = m_util.euler_to_quat(euler, _quat4_tmp);
	        var obj_quat = m_tsr.get_quat(cons.tsr_restore, _quat4_tmp2);
	        m_quat.slerp(obj_quat, target_quat, f, m_tsr.get_quat_view(obj.render.world_tsr));

	        m_tsr.set_trans(m_tsr.get_trans_view(obj.render.world_tsr), cons.tsr_restore);
	        break;
	    case CONS_TYPE_COPY_TRANS_OBJ:
	        var f = cons.influence;
	        var p_trans = m_tsr.get_trans(cons.obj_parent.render.world_tsr, _vec3_tmp);
	        var p_quat = m_tsr.get_quat(cons.obj_parent.render.world_tsr, _quat4_tmp);
	        var o_trans = m_tsr.get_trans(cons.tsr_offset, _vec3_tmp_2);
	        var o_quat = m_tsr.get_quat(cons.tsr_offset, _quat4_tmp2);
	        m_util.blend_arrays(o_trans, p_trans, f, m_tsr.get_trans_view(obj.render.world_tsr));
	        m_quat.slerp(o_quat, p_quat, f, m_tsr.get_quat_view(obj.render.world_tsr));

	        m_tsr.set_trans(m_tsr.get_trans_view(obj.render.world_tsr), cons.tsr_restore);
	        break;
	    case CONS_TYPE_STIFF_TRANS_ROT_OBJ:

	        var quat = m_tsr.get_quat_view(obj.render.world_tsr);

	        var p_world_tsr = cons.obj_parent.render.world_tsr;
	        var p_quat = m_tsr.get_quat_view(cons.obj_parent.render.world_tsr);

	        var offset = m_tsr.get_trans(cons.tsr_offset, _vec3_tmp_2);
	        // var scale_offset = m_tsr.get_scale(cons.tsr_offset);
	        var rotation_offset = m_tsr.get_quat(cons.tsr_offset, _quat4_tmp);

	        m_quat.multiply(p_quat, rotation_offset, quat);

	        var trans = m_tsr.get_trans_view(obj.render.world_tsr);
	        m_tsr.transform_vec3(offset, p_world_tsr, trans);
	        break;
	    case CONS_TYPE_CHILD_OF:
	        var prender = cons.obj_parent.render;
	        var render = obj.render;

	        m_tsr.multiply(prender.world_tsr, cons.tsr_offset, render.world_tsr);
	        break;
	    case CONS_TYPE_CHILD_OF_BONE:

	        var tsr_offset = cons.tsr_offset;
	        var p_tsr = _tsr_tmp;

	        m_armat.get_bone_tsr(cons.obj_parent, cons.bone_name, true, false,
	                             p_tsr);
	        // from armature to world space
	        m_tsr.multiply(cons.obj_parent.render.world_tsr, p_tsr, p_tsr);

	        m_tsr.multiply(p_tsr, tsr_offset, obj.render.world_tsr);

	        break;
	    case CONS_TYPE_STIFF_VIEWPORT:
	        var camobj = cons.obj_parent;
	        var cam = m_cam.get_first_cam(camobj);

	        var trans = m_tsr.get_trans_view(obj.render.world_tsr);

	        var left = m_cam.get_edge(cam, "LEFT");
	        var right = m_cam.get_edge(cam, "RIGHT");
	        var top = m_cam.get_edge(cam, "TOP");
	        var bottom = m_cam.get_edge(cam, "BOTTOM");

	        if (cons.hor_units == "heights")
	            var hor_stride = top - bottom;
	        else
	            var hor_stride = right - left;

	        if (cons.left_edge)
	            trans[0] = left + hor_stride * cons.left_right_dist;
	        else
	            trans[0] = right - hor_stride * cons.left_right_dist;

	        if (cons.vert_units == "heights")
	            var vert_stride = top - bottom;
	        else
	            var vert_stride = right - left;

	        // in the camera's view space
	        if (cons.top_edge)
	            trans[1] = top - vert_stride * cons.top_bottom_dist;
	        else
	            trans[1] = bottom + vert_stride * cons.top_bottom_dist;

	        // NOTE: ortho cameras have scaling problems
	        if (m_cam.is_ortho(cam)) {
	            trans[2] = -cons.distance;
	        } else {
	            trans[2] = -1;
	            m_vec3.normalize(trans, trans);
	            var scale = cons.distance/Math.abs(trans[2]);
	            m_vec3.scale(trans, scale, trans);
	        }

	        m_tsr.transform_dir_vec3(trans, camobj.render.world_tsr, trans);
	        var cam_trans = m_tsr.get_trans_view(camobj.render.world_tsr);
	        m_vec3.add(cam_trans, trans, trans);

	        var obj_quat = m_tsr.get_quat_view(obj.render.world_tsr);
	        var cam_quat = m_tsr.get_quat_view(camobj.render.world_tsr);

	        var rotation_offset = m_tsr.get_quat(cons.tsr_offset, _quat4_tmp2);
	        m_quat.multiply(cam_quat, rotation_offset, obj_quat);

	        break;
	    default:
	        break;
	    }

	    if (obj.render.type == "CAMERA" && obj.render.move_style != m_cam.MS_STATIC) {
	        var corr_axis = obj.render.vertical_axis;
	        if (cons.type == CONS_TYPE_SEMI_STIFF_OBJ) {
	            var p_quat = m_tsr.get_quat_view(cons.obj_parent.render.world_tsr);
	            corr_axis = m_vec3.transformQuat(corr_axis, p_quat, _parent_y_axis);
	        }
	        // the m_cam.correct_up calls update_camera_upside_down, is the followong code line necessary?
	        m_cam.update_camera_upside_down(obj);
	        m_cam.correct_up(obj, corr_axis);
	    }
	}

	/**
	 * Apply stiff-bone-to-object constraint.
	 */
	function append_stiff_bone_to_obj(armobj, obj, bone_name, offset,
	        rotation_offset, scale_offset) {

	    var cons = init_cons(BONE_CONS_TYPE_STIFF_OBJ);

	    cons.bone_name = bone_name;
	    cons.target = obj;
	    cons.tsr_offset = m_tsr.create();
	    m_tsr.set_trans(new Float32Array(offset), cons.tsr_offset);
	    m_tsr.set_quat(new Float32Array(rotation_offset), cons.tsr_offset);
	    m_tsr.set_scale(scale_offset, cons.tsr_offset);

	    apply_bone_cons(armobj, cons);
	    update_bone_cons(armobj, cons);
	}

	function apply_bone_cons(armobj, cons) {
	    var target = cons.target;
	    var bone_name = cons.bone_name;
	    var bone_pointer = armobj.render.bone_pointers[bone_name];

	    remove_arm_bone_descendant(target, armobj, bone_name);
	    target.cons_armat_bone_descends.push([armobj, bone_name]);
	    bone_pointer.constraint = cons;
	}

	function remove_arm_bone_descendant(obj, armobj, bone_name) {
	    var cons_armat_bone_descends = obj.cons_armat_bone_descends;
	    for (var i = 0; i < cons_armat_bone_descends; i++) {
	        var cons_desc = cons_armat_bone_descends[i];
	        if (cons_desc[0] == armobj && cons_desc[1] == bone_name) {
	            cons_armat_bone_descends.splice(i, 1);
	            return;
	        }
	    }
	}

	exports.update_bone_constraint = function(armobj, bone_name) {
	    var bone_pointer = armobj.render.bone_pointers[bone_name];
	    if (bone_pointer.constraint)
	        update_bone_cons(armobj, bone_pointer.constraint);
	};

	function update_bone_cons(armobj, cons) {
	    switch (cons.type) {
	    case BONE_CONS_TYPE_STIFF_OBJ:
	        var target_obj = cons.target;
	        var target_tsr = target_obj.render.world_tsr;
	        var armobj_tsr = armobj.render.world_tsr;

	        var b_tsr = _tsr_tmp;
	        m_tsr.invert(armobj_tsr, b_tsr);
	        m_tsr.multiply(b_tsr, target_tsr, b_tsr);

	        m_armat.set_bone_tsr(armobj, cons.bone_name, b_tsr, false);
	        break;
	    default:
	        break;
	    }
	    armobj.need_update_transform = true;
	}

	/**
	 * uses _vec2_tmp, _vec2_tmp_2, _quat4_tmp
	 */
	function clamp_orientation(obj, cons) {

	    var quat = m_tsr.get_quat_view(obj.render.world_tsr);
	    var p_quat = m_tsr.get_quat_view(cons.obj_parent.render.world_tsr);
	    var rotation_offset = m_tsr.get_quat(cons.tsr_offset, _quat4_tmp2);

	    var quat_base = m_quat.multiply(p_quat, rotation_offset, _quat4_tmp);
	    var base_angles = m_cam.get_camera_angles_from_quat(quat_base, _vec2_tmp);
	    var curr_angles = m_cam.get_camera_angles_from_quat(quat, _vec2_tmp_2);
	    
	    var d_phi = m_util.calc_returning_angle(curr_angles[0], 
	            base_angles[0] + cons.clamp_right, base_angles[0] + cons.clamp_left);
	    var d_theta = m_util.calc_returning_angle(curr_angles[1], 
	            base_angles[1] + cons.clamp_down, base_angles[1] + cons.clamp_up);
	    m_util.rotate_quat(quat, obj.render.vertical_axis, d_phi, d_theta, quat);
	}

	exports.check_constraint = function(obj) {
	    if (obj.constraint)
	        return true;
	    else
	        return false;
	};
	/**
	 * Remove object constraint
	 */
	exports.remove = function(obj, restore_transform) {
	    if (obj.constraint.obj_parent)
	        remove_parent_descendant(obj.constraint.obj_parent, obj);
	    if (restore_transform) 
	        m_tsr.copy(obj.constraint.tsr_restore, obj.render.world_tsr);
	    obj.constraint = null;
	};

	/**
	 * Get constraint type or null
	 */
	exports.get_type = function(obj) {
	    if (obj.constraint)
	        return obj.constraint.type;
	    else
	        return null;
	};

	exports.has_child_of = function(obj) {
	    var cons = obj.constraint;

	    if (cons && (cons.type == CONS_TYPE_CHILD_OF || 
	            cons.type == CONS_TYPE_CHILD_OF_BONE))
	        return true;
	    else
	        return false;
	};

	/**
	 * Do not change returned value.
	 */
	exports.get_child_of_parent_tsr = function(obj) {
	    var cons = obj.constraint;

	    if (cons && cons.type == CONS_TYPE_CHILD_OF) {
	        return cons.obj_parent.render.world_tsr;
	    } else if (cons && cons.type == CONS_TYPE_CHILD_OF_BONE) {
	        var p_tsr = _tsr_tmp;
	        m_armat.get_bone_tsr(cons.obj_parent, cons.bone_name, true, false,
	                             p_tsr);
	        // from armature to world space
	        m_tsr.multiply(cons.obj_parent.render.world_tsr, p_tsr, p_tsr);
	        return p_tsr;
	    } else
	        return null;
	};

	/**
	 * Get link to child-of TSR offset vector or null.
	 */
	exports.get_child_of_offset = function(obj) {
	    var cons = obj.constraint;

	    if (cons && (cons.type == CONS_TYPE_CHILD_OF || 
	            cons.type == CONS_TYPE_CHILD_OF_BONE))
	        return cons.tsr_offset;
	    else
	        return null;
	};

	exports.prepare_object_relations = function(bpy_obj, obj) {
	    var render = obj.render;
	    for (var i = 0; i < bpy_obj["constraints"].length; i++) {
	        var bpy_constraint = bpy_obj["constraints"][i];
	        var const_type = bpy_constraint["type"];
	        // NOTE: temporary solution for old JSONs
	        if (!bpy_constraint["target"])
	            continue;
	        var target_obj = bpy_constraint["target"]._object;
	        if (const_type == "COPY_LOCATION") {
	            var obj_pos_w = new Float32Array(m_tsr.get_trans_view(obj.render.world_tsr));
	            var axes = new Float32Array(bpy_constraint["axes"]);
	            append_copy_loc_obj(obj, target_obj, obj_pos_w, axes,
	                    bpy_constraint["use_offset"], bpy_constraint["influence"]);
	        } else if (const_type == "COPY_ROTATION") {
	            var axes = new Float32Array(bpy_constraint["axes"]);
	            append_copy_rot_obj(obj, target_obj, axes,
	                    bpy_constraint["use_offset"], bpy_constraint["influence"]);
	        } else if (const_type == "COPY_TRANSFORMS") {
	            append_copy_trans_obj(obj, target_obj, bpy_constraint["influence"]);
	        } else if (const_type == "TRACK_TO") {

	            var track_axis_name = bpy_constraint["track_axis"];
	            if (track_axis_name == "TRACK_Y")
	                var track_axis = m_util.AXIS_Y;
	            else if (track_axis_name == "TRACK_NEGATIVE_Y")
	                var track_axis = m_util.AXIS_MY;
	            else if (track_axis_name == "TRACK_X")
	                var track_axis = m_util.AXIS_X;
	            else if (track_axis_name == "TRACK_NEGATIVE_X")
	                var track_axis = m_util.AXIS_MX;
	            else if (track_axis_name == "TRACK_Z")
	                var track_axis = m_util.AXIS_Z;
	            else if (track_axis_name == "TRACK_NEGATIVE_Z")
	                var track_axis = m_util.AXIS_MZ;

	            var up_axis_name = bpy_constraint["up_axis"];
	            if (up_axis_name == "UP_X")
	                var up_axis = m_util.AXIS_X;
	            else if (up_axis_name == "UP_Y")
	                var up_axis = m_util.AXIS_Y;
	            else if (up_axis_name == "UP_Z")
	                var up_axis = m_util.AXIS_Z;

	            append_track_obj(obj, target_obj, track_axis, up_axis,
	                    bpy_constraint["use_target_z"], bpy_constraint["influence"]);
	        }
	    }

	    if (obj.parent) {

	        // disable object physics on collision compound children 
	        // they are just additional shapes for top level parent
	        if (!obj.parent_is_dupli &&
	                obj.physics_settings.use_collision_compound &&
	                obj.parent.physics_settings.use_collision_compound)
	            obj.use_obj_physics = false;

	        var scenes_have_phy = false;
	        for (var i = 0; i < obj.scenes_data.length; i++)
	            if (obj.scenes_data[i].scene._physics) {
	                scenes_have_phy = true;
	                break;
	            }
	        if (scenes_have_phy && m_phy.has_dynamic_settings(obj)) {
	            if (obj.parent_is_dupli)
	                var offset = m_tsr.copy(render.world_tsr, m_tsr.create());
	            else
	                var offset = render.world_tsr;
	            m_tsr.multiply(obj.parent.render.world_tsr, offset, render.world_tsr);
	        } else if (obj.parent_is_dupli || !obj.parent_bone) {
	            // get offset from render before child-of constraint being applied
	            var offset = m_tsr.copy(render.world_tsr, m_tsr.create());

	            // second condition is for cases when direct parenting is disabled
	            // due to obj parent group mismatch
	            if (obj.viewport_alignment && obj.parent.type == "CAMERA") {
	                var positioning = {
	                    distance: obj.viewport_alignment.distance,
	                    rotation: m_tsr.get_quat_view(offset)
	                };

	                switch (obj.viewport_alignment.alignment) {
	                case "TOP_LEFT":
	                    positioning.top = 0;
	                    positioning.left = 0;
	                    break;
	                case "TOP":
	                    positioning.top = 0;
	                    positioning.left = 0.5;
	                    break;
	                case "TOP_RIGHT":
	                    positioning.top = 0;
	                    positioning.right = 0;
	                    break;
	                case "LEFT":
	                    positioning.top = 0.5;
	                    positioning.left = 0;
	                    break;
	                case "CENTER":
	                    positioning.top = 0.5;
	                    positioning.left = 0.5;
	                    break;
	                case "RIGHT":
	                    positioning.top = 0.5;
	                    positioning.right = 0;
	                    break;
	                case "BOTTOM_LEFT":
	                    positioning.bottom = 0;
	                    positioning.left = 0;
	                    break;
	                case "BOTTOM":
	                    positioning.bottom = 0;
	                    positioning.left = 0.5;
	                    break;
	                case "BOTTOM_RIGHT":
	                    positioning.bottom = 0;
	                    positioning.right = 0;
	                    break;
	                }
	                append_stiff_viewport(obj, obj.parent, positioning);
	            } else
	                append_child_of(obj, obj.parent, offset);
	        } else {
	            var offset = m_tsr.copy(render.world_tsr, m_tsr.create());
	            append_child_of_bone(obj, obj.parent, obj.parent_bone,
	                    offset);
	        }
	    }
	    if (obj.type == "ARMATURE") {
	        var pose_bones = bpy_obj["pose"]["bones"];
	        for (var i = 0; i < pose_bones.length; i++) {
	            var pose_bone = pose_bones[i];
	            var constraints = pose_bone["constraints"];
	            if (constraints)
	                for (var j = 0; j < constraints.length; j++) {
	                    var cons = constraints[j];
	                    if (cons["type"] != "COPY_TRANSFORMS" || cons["subtarget"] || cons["mute"])
	                        continue;

	                    var target_obj = cons["target"]._object;
	                    append_stiff_bone_to_obj(obj, target_obj, pose_bone["name"],
	                                                    m_util.VEC3_IDENT,
	                                                    m_util.QUAT4_IDENT, 1);
	                }
	        }
	    }
	};

	exports.check_compatibility = function(obj, target) {
	    return check_compatibility_r(obj.cons_descends, target);
	};

	function check_compatibility_r(descends, target) {
	    for (var i = 0; i < descends.length; i++) {
	        var child = descends[i];
	        if (!check_compatibility_r(child.cons_descends, target) ||
	                child.name == target.name)
	            return false;
	    }
	    return true;
	}

	exports.check_self_applying = function(obj, target) {
	    return obj.name != target.name;
	};

	}

	var int_constraints_factory = register("__constraints", Int_constraints);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Object transformation API
	 * @name transform
	 * @namespace
	 * @exports exports as transform
	 */
	function Int_transform(ns, exports) {

	var m_bounds   = int_boundings_factory(ns);
	var m_cam      = int_camera_factory(ns);
	var m_cons     = int_constraints_factory(ns);
	var m_lights   = int_lights_factory(ns);
	var m_obj      = int_objects_factory(ns);
	var m_obj_util = int_obj_util_factory(ns);
	var m_scs      = int_scenes_factory(ns);
	var m_sfx      = int_sfx_factory(ns);
	var m_tsr      = int_tsr_factory(ns);
	var m_util     = int_util_factory(ns);
	var m_vec3     = vec3_factory(ns);

	var _vec3_tmp  = new Float32Array(3);
	var _vec3_tmp2 = new Float32Array(3);
	var _quat_tmp = new Float32Array(4);
	var _tsr_tmp   = m_tsr.create();
	var _tsr_tmp2  = m_tsr.create();

	var _elapsed = 0;
	var _update_counter = 0;

	exports.update = function(elapsed) {
	    _elapsed = elapsed;
	    _update_counter++;
	};

	exports.set_translation = function(obj, trans) {
	    var render = obj.render;

	    if (m_cons.has_child_of(obj)) {
	        m_tsr.set_trans(trans, render.world_tsr);
	        var tsr_par = m_cons.get_child_of_parent_tsr(obj);
	        var tsr_inv = m_tsr.invert(tsr_par, _tsr_tmp);
	        var offset = m_cons.get_child_of_offset(obj);
	        m_tsr.multiply(tsr_inv, render.world_tsr, offset);
	    } else
	        m_tsr.set_trans(trans, render.world_tsr);
	};

	exports.set_translation_rel = set_translation_rel;
	function set_translation_rel(obj, trans) {
	    if (m_cons.has_child_of(obj)) {
	        var offset = m_cons.get_child_of_offset(obj);
	        m_tsr.set_trans(trans, offset);
	    } else {
	        var render = obj.render;
	        m_tsr.set_trans(trans, render.world_tsr);
	    }
	}

	exports.get_translation = function(obj, dest) {
	    m_tsr.get_trans(obj.render.world_tsr, dest);
	    return dest;
	};

	exports.get_translation_rel = function(obj, dest) {
	    if (m_cons.has_child_of(obj)) {
	        var offset = m_cons.get_child_of_offset(obj);
	        m_tsr.get_trans(offset, dest);
	    } else
	        m_tsr.get_trans(obj.render.world_tsr, dest);

	    return dest;
	};

	exports.set_rotation = set_rotation;
	function set_rotation(obj, quat) {
	    var render = obj.render;

	    if (m_cons.has_child_of(obj)) {
	        m_tsr.set_quat(quat, render.world_tsr);
	        var tsr_par = m_cons.get_child_of_parent_tsr(obj);
	        var tsr_inv = m_tsr.invert(tsr_par, _tsr_tmp);
	        var offset = m_cons.get_child_of_offset(obj);
	        m_tsr.multiply(tsr_inv, render.world_tsr, offset);
	    } else
	        m_tsr.set_quat(quat, render.world_tsr);
	}

	exports.set_rotation_rel = set_rotation_rel;
	function set_rotation_rel(obj, quat) {
	    if (m_cons.has_child_of(obj)) {
	        var offset = m_cons.get_child_of_offset(obj);
	        m_tsr.set_quat(quat, offset);
	    } else
	        m_tsr.set_quat(quat, obj.render.world_tsr);
	}

	exports.get_rotation = get_rotation;
	function get_rotation(obj, dest) {
	    m_tsr.get_quat(obj.render.world_tsr, dest);
	    return dest;
	}

	exports.get_rotation_rel = get_rotation_rel;
	function get_rotation_rel(obj, dest) {
	    if (m_cons.has_child_of(obj)) {
	        var offset = m_cons.get_child_of_offset(obj);
	        m_tsr.get_quat(offset, dest);
	    } else
	        m_tsr.get_quat(obj.render.world_tsr, dest);
	    return dest;
	}

	exports.set_rotation_euler = function(obj, euler) {
	    var quat = m_util.euler_to_quat(euler, _quat_tmp);
	    set_rotation(obj, quat);
	};

	exports.set_rotation_euler_rel = function(obj, euler) {
	    var quat = m_util.euler_to_quat(euler, _quat_tmp);
	    set_rotation_rel(obj, quat);
	};

	exports.get_rotation_euler = function(obj, dest) {
	    var quat = get_rotation(obj, _quat_tmp);
	    dest = m_util.quat_to_euler(quat, dest);
	    return dest;
	};

	exports.get_rotation_euler_rel = function(obj, dest) {
	    var quat = get_rotation_rel(obj, _quat_tmp);
	    dest = m_util.quat_to_euler(quat, dest);
	    return dest;
	};

	exports.set_scale = function(obj, scale) {
	    var render = obj.render;

	    if (m_cons.has_child_of(obj)) {
	        var offset = m_cons.get_child_of_offset(obj);
	        var scale_par = m_tsr.get_scale(m_cons.get_child_of_parent_tsr(obj));
	        m_tsr.set_scale(scale/scale_par, offset);
	    } else
	        m_tsr.set_scale(scale, render.world_tsr);
	};

	exports.set_scale_rel = function(obj, scale) {
	    var render = obj.render;

	    if (m_cons.has_child_of(obj)) {
	        var offset = m_cons.get_child_of_offset(obj);
	        m_tsr.set_scale(scale, offset);
	    } else
	        m_tsr.set_scale(scale, render.world_tsr);
	};

	exports.get_scale = function(obj) {
	    return m_tsr.get_scale(obj.render.world_tsr);
	};

	exports.get_scale_rel = function(obj) {
	    if (m_cons.has_child_of(obj)) {
	        var offset = m_cons.get_child_of_offset(obj);
	        return m_tsr.get_scale(offset);
	    } else
	        return m_tsr.get_scale(obj.render.world_tsr);
	};

	exports.set_tsr = function(obj, tsr) {
	    m_tsr.copy(tsr, obj.render.world_tsr);

	    if (m_cons.has_child_of(obj)) {
	        var tsr_par = m_cons.get_child_of_parent_tsr(obj);
	        var tsr_inv = m_tsr.invert(tsr_par, _tsr_tmp);
	        var offset = m_cons.get_child_of_offset(obj);
	        m_tsr.multiply(tsr_inv, obj.render.world_tsr, offset);
	    }
	};

	exports.set_tsr_rel = set_tsr_rel;
	function set_tsr_rel(obj, tsr) {
	    if (m_cons.has_child_of(obj)) {
	        var offset = m_cons.get_child_of_offset(obj);
	        m_tsr.copy(tsr, offset);
	    } else
	        m_tsr.copy(tsr, obj.render.world_tsr);
	}


	exports.get_tsr = function(obj, dest) {
	    return m_tsr.copy(obj.render.world_tsr, dest);
	};

	exports.get_tsr_rel = get_tsr_rel;
	function get_tsr_rel(obj, dest) {
	    if (m_cons.has_child_of(obj)) {
	        var offset = m_cons.get_child_of_offset(obj);
	        m_tsr.copy(offset, dest);
	    } else
	        m_tsr.copy(obj.render.world_tsr, dest);
	    return dest;
	}

	exports.get_object_size = function(obj) {

	    var render = obj.render;
	    var bb = render.bb_original;

	    var scale  = m_tsr.get_scale(render.world_tsr);
	    var x_size = scale * (bb.max_x - bb.min_x);
	    var y_size = scale * (bb.max_y - bb.min_y);
	    var z_size = scale * (bb.max_z - bb.min_z);

	    var size = 0.5 * Math.sqrt(x_size * x_size + y_size * y_size + z_size * z_size);
	    return size;
	};

	exports.get_object_center = function(obj, calc_bs_center, dest) {
	    if (calc_bs_center) {
	        var render = obj.render;
	        m_vec3.copy(render.bs_world.center, dest);
	    } else {

	        var render = obj.render;
	        var bb = render.bb_original;

	        dest[0] = (bb.max_x + bb.min_x)/2;
	        dest[1] = (bb.max_y + bb.min_y)/2;
	        dest[2] = (bb.max_z + bb.min_z)/2;

	        m_tsr.transform_vec3(dest, render.world_tsr, dest);
	    }

	    return dest;
	};

	/**
	 * Calculate new translation based on distances in local space
	 */
	exports.move_local = function(obj, dx, dy, dz) {
	    var p_tsr = get_tsr_rel(obj, _tsr_tmp);

	    var trans = _vec3_tmp;

	    trans[0] = dx;
	    trans[1] = dy;
	    trans[2] = dz;

	    m_tsr.transform_vec3(trans, p_tsr, trans);
	    set_translation_rel(obj, trans);
	};

	exports.rotate_local = function(obj, quat) {
	    var p_tsr = get_tsr_rel(obj, _tsr_tmp);
	    var tsr = m_tsr.set_quat(quat, m_tsr.identity(_tsr_tmp2));

	    m_tsr.multiply(p_tsr, tsr, tsr);
	    set_tsr_rel(obj, tsr);
	};


	exports.update_transform = update_transform;
	/**
	 * Set object render world_tsr.
	 * NOTE: do not try to update batched objects (buggy _dg_parent influence)
	 * @methodOf transform
	 * @param {Object3D} obj Object 3D
	 */
	function update_transform(obj) {
	    var render = obj.render;
	    var scenes_data = obj.scenes_data;

	    var obj_type = obj.type;

	    // NOTE: need to update before constraints, because they rely on to this flag
	    if (obj_type == "CAMERA")
	        m_cam.update_camera_upside_down(obj);

	    m_cons.update_constraint(obj, _elapsed);

	    if (obj_type == "CAMERA")
	        m_cam.update_camera(obj);

	    m_bounds.bounding_box_transform(render.bb_local, render.world_tsr, render.bb_world);
	    m_bounds.bounding_sphere_transform(render.bs_local, render.world_tsr, render.bs_world);

	    for (var i = 0; i < scenes_data.length; i++) {
	        var batches = scenes_data[i].batches;
	        for (var j = 0; j < batches.length; j++) {
	            var batch = batches[j];
	            var batch_world_bounds = scenes_data[i].batch_world_bounds[j];
	            m_obj_util.update_world_bounds_from_batch_tsr(batch, 
	                    render.world_tsr, batch_world_bounds);
	        }
	    }

	    switch (obj_type) {
	    case "MESH":
	        // used in some node materials
	        if (obj.need_inv_zup_tsr)
	            m_tsr.invert(obj.render.world_tsr, obj.render.world_tsr_inv);
	        var armobj = obj.armobj;
	        if (armobj) {
	            var armobj_tsr = armobj.render.world_tsr;
	            m_tsr.invert(armobj_tsr, _tsr_tmp);
	            m_tsr.multiply(_tsr_tmp, render.world_tsr, _tsr_tmp);
	            m_tsr.get_transcale(_tsr_tmp, render.arm_rel_trans);
	            m_tsr.get_quat(_tsr_tmp, render.arm_rel_quat);
	        }

	        render.force_zsort = true;

	        break;
	    case "CAMERA":
	        for (var i = 0; i < scenes_data.length; i++)
	            m_cam.update_camera_transform(obj, scenes_data[i]);
	        break;
	    case "SPEAKER":
	        m_sfx.speaker_update_transform(obj, _elapsed, _update_counter);
	        break;
	    case "LAMP":
	        m_lights.update_light_transform(obj);
	        break;
	    }

	    // should not change after constraint update
	    var trans = m_tsr.get_trans(render.world_tsr, _vec3_tmp);
	    var quat = m_tsr.get_quat(render.world_tsr, _quat_tmp);

	    for (var i = 0; i < scenes_data.length; i++) {
	        var sc_data = scenes_data[i];
	        if (sc_data.is_active) {
	            var scene = sc_data.scene;
	            var sc_render = scene._render;
	            var batches = sc_data.batches;

	            switch (obj_type) {
	            case "MESH":
	                if (render.shadow_cast)
	                    m_scs.schedule_shadow_update(scene);

	                var cube_refl_subs = sc_data.cube_refl_subs;
	                if (render.cube_reflection_id != null && cube_refl_subs) {
	                    m_scs.update_cube_reflect_subs(cube_refl_subs, trans);
	                }
	                break;
	            case "EMPTY":
	                m_obj.update_force(obj);
	                break;
	            case "CAMERA":
	                // scene update only for the active camera
	                if (m_scs.get_active() == scene && m_scs.get_camera(scene) == obj) {
	                    m_scs.schedule_grass_map_update(scene);
	                    if (sc_render.shadow_params) {
	                        // camera movement only influence csm shadows
	                        if (sc_render.shadow_params.enable_csm 
	                                || sc_render.shadow_params.dynamic_grass_cast)
	                            m_scs.schedule_shadow_update(scene);
	                        var cam_scene_data = m_obj_util.get_scene_data(obj, scene);
	                        var cam_main = cam_scene_data.cameras[0];
	                        m_scs.update_shadow_billboard_view(cam_main, sc_render.graph);
	                    }
	                    
	                    m_sfx.listener_update_transform(scene, trans, quat, _elapsed, 
	                            _update_counter);
	                }
	                break;
	            case "LAMP":
	                m_scs.update_lamp_scene(obj, scene);
	                break;
	            }

	            var plane_refl_subs = sc_data.plane_refl_subs;
	            var refl_objs = obj.reflective_objs;
	            if (refl_objs.length) {
	                for (var j = 0; j < plane_refl_subs.length; j++) {
	                    var cam = plane_refl_subs[j].camera;
	                    m_scs.update_plane_reflect_subs(plane_refl_subs[j], trans, quat);
	                    m_obj_util.update_refl_objects(refl_objs, cam.reflection_plane);
	                    m_cam.set_view(cam, m_scs.get_camera(scene));
	                }
	            }
	        }
	    }

	    var cons_descends = obj.cons_descends;
	    for (var i = 0; i < cons_descends.length; i++)
	        update_transform(cons_descends[i]);

	    var cons_armat_bone_descends = obj.cons_armat_bone_descends;
	    for (var i = 0; i < cons_armat_bone_descends.length; i++) {
	        var cons_armat_desc = cons_armat_bone_descends[i];
	        var armobj = cons_armat_desc[0];
	        var bone_name = cons_armat_desc[1];
	        m_cons.update_bone_constraint(armobj, bone_name);
	    }
	}

	exports.distance = function(obj1, obj2) {
	    var trans1 = m_tsr.get_trans(obj1.render.world_tsr, _vec3_tmp);
	    var trans2 = m_tsr.get_trans(obj2.render.world_tsr, _vec3_tmp2);
	    return m_vec3.dist(trans1, trans2);
	};

	exports.obj_point_distance = function(obj, point) {
	    var trans = m_tsr.get_trans(obj.render.world_tsr, _vec3_tmp);
	    return m_vec3.dist(trans, point);
	};

	}

	var int_transform_factory = register("__transform", Int_transform);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Navigation mesh internal API.
	 * @name navmesh
	 * @namespace
	 * @exports exports as navmesh
	 */
	function Int_navmesh(ns, exports) {

	var m_geom  = int_geometry_factory(ns);
	var m_math  = int_math_factory(ns);
	var m_mat4  = mat4_factory(ns);
	var m_util  = int_util_factory(ns);
	var m_vec3  = vec3_factory(ns);
	var m_vec4  = vec4_factory(ns);

	// TODO: reduce count of tmp variables
	var _vec3_tmp = m_vec3.create();
	var _vec3_tmp2 = m_vec3.create();

	var _vec4_tmp = m_vec4.create();
	var _vec4_tmp2 = m_vec4.create();
	var _vec4_tmp3 = m_vec4.create();

	var _mat4_tmp = m_mat4.create();
	var _mat4_tmp2 = m_mat4.create();
	var _mat4_tmp3 = m_mat4.create();

	var _accum_left_portal_tmp = m_vec3.create();
	var _accum_right_portal_tmp = m_vec3.create();
	var _accum_left_tmp = m_vec3.create();
	var _accum_right_tmp = m_vec3.create();
	var _apex_normal_tmp = m_vec3.create();

	function merge_vertices(geometry) {
	    var vertices_map = {}; // Hashmap for looking up vertex by position
	                           // coordinates (and making sure they are unique)
	    var unique = [];
	    var changes = [];
	    var v, key;
	    var precision_points = 4; // number of decimal points, eg. 4 for epsilon of 0.0001
	    var precision = Math.pow(10, precision_points);
	    var i, il, face;
	    var indices;

	    for (i = 0, il = geometry.vertices.length; i < il; i++) {
	        v = geometry.vertices[i];

	        key = Math.round(v[0] * precision) + '_' + Math.round(v[1] * precision) +
	            '_' + Math.round(v[2] * precision);

	        if (vertices_map[key] === undefined) {
	            vertices_map[key] = i;
	            unique.push(v);
	            changes[i] = unique.length - 1;
	        } else {
	            changes[i] = changes[vertices_map[key]];
	        }
	    }

	    // If faces are completely degenerate after merging vertices, we
	    // have to remove them from the geometry.
	    var face_indices_to_remove = [];

	    for (i = 0, il = geometry.faces.length; i < il; i++) {
	        face = geometry.faces[i];
	        face.indices[0] = changes[face.indices[0]];
	        face.indices[1] = changes[face.indices[1]];
	        face.indices[2] = changes[face.indices[2]];

	        indices = [face.indices[0], face.indices[1], face.indices[2]];

	        // If any duplicate vertices are found in a Face3
	        // we have to remove the face as nothing can be saved
	        for (var n = 0; n < 3; n++) {
	            if (indices[n] == indices[(n + 1) % 3]) {
	                face_indices_to_remove.push(i);
	                break;
	            }
	        }
	    }

	    for (i = face_indices_to_remove.length - 1; i >= 0; i--) {
	        var idx = face_indices_to_remove[i];
	        geometry.faces.splice(idx, 1);
	    }

	    // Use unique set of vertices
	    var diff = geometry.vertices.length - unique.length;
	    geometry.vertices.length = 0;

	    for (i = 0; i < unique.length; i++)
	        geometry.vertices.push(unique[i]);

	    return diff;

	}

	function get_edge_key(vertex_ids_1, vertex_ids_2) {
	    if (vertex_ids_1 > vertex_ids_2)
	        return vertex_ids_2 + "-" + vertex_ids_1;
	    else
	        return vertex_ids_1 + "-" + vertex_ids_2;
	}

	function build_polygons_from_geometry(geometry) {
	    var polygons = [];
	    var vertices = geometry.vertices;
	    // Convert the faces into a custom format that supports more than 3 vertices
	    var polygon_id = 0;
	    for (var i = 0; i < geometry.faces.length; i++) {
	        var face = geometry.faces[i];
	        polygons.push({
	            id: polygon_id++,
	            vertex_ids: face.indices,
	            centroid: face.centroid,
	            normal: face.normal,
	            neighbours: []
	        });
	    }
	    var navigation_mesh = {
	        polygons: polygons,
	        vertices: vertices
	    };

	    // Build a list of adjacent polygons
	    var dict_edge_polygon = {};
	    for (var i = 0; i < polygons.length; i++) {
	        for (var j = 0; j < 3; j++) {
	            var edge_key = get_edge_key(polygons[i].vertex_ids[j],
	                    polygons[i].vertex_ids[(j + 1) % 3]);

	            if (!(edge_key in dict_edge_polygon))
	                dict_edge_polygon[edge_key] = [];
	            dict_edge_polygon[edge_key].push(polygons[i]);
	        }
	    }

	    var keys  = Object.keys(dict_edge_polygon);
	    for (var i = 0, l = keys.length; i < l; i++) {
	        var edge_key = keys[i];
	        for (var j = 0; j < dict_edge_polygon[edge_key].length; j++)
	            for (var k = j + 1; k < dict_edge_polygon[edge_key].length; k++) {
	                dict_edge_polygon[edge_key][j].neighbours.push(
	                        dict_edge_polygon[edge_key][k]);
	                dict_edge_polygon[edge_key][k].neighbours.push(
	                        dict_edge_polygon[edge_key][j]);
	            }
	    }

	    return navigation_mesh;
	}

	function compute_centroids(geometry) {
	    var f, face;
	    for (f = 0; f < geometry.faces.length; f++) {

	        face = geometry.faces[f];
	        m_vec3.add(geometry.vertices[face.indices[0]], geometry.vertices[face.indices[1]], _vec3_tmp);
	        m_vec3.add(_vec3_tmp, geometry.vertices[face.indices[2]], _vec3_tmp);

	        m_vec3.scale(_vec3_tmp, 1/3, face.centroid);
	    }
	}

	function compute_normals(geometry) {
	    for (var i = 0; i < geometry.faces.length; i++) {

	        var face = geometry.faces[i];

	        var v1 = m_vec3.subtract(geometry.vertices[face.indices[1]],
	                geometry.vertices[face.indices[0]], _vec3_tmp);
	        var v2 = m_vec3.subtract(geometry.vertices[face.indices[2]],
	                geometry.vertices[face.indices[0]], _vec3_tmp2);
	        var normal = m_vec3.cross(v1, v2, _vec3_tmp);
	        m_vec3.normalize(normal, normal);
	        m_vec3.copy(normal, face.normal);
	    }
	}

	function build_navigation_mesh(geometry) {
	    compute_centroids(geometry);
	    compute_normals(geometry);
	    merge_vertices(geometry);
	    var navmesh = build_polygons_from_geometry(geometry);
	    return navmesh
	}

	function round_number(number, decimals) {
	    return parseFloat(number.toFixed(decimals));
	}

	function build_islands(navmesh) {
	    var polygons = navmesh.polygons;
	    var islands = [];
	    var island_count = 0;
	    var spread_island_id = function (polygon) {
	        var neighbours = polygon.neighbours;
	        for (var i = 0; i < neighbours.length; i++) {
	            var neighbour = neighbours[i];
	            if (neighbour.island == undefined) {
	                neighbour.island = polygon.island;
	                spread_island_id(neighbour);
	            }
	        }
	    };
	    for (var i = 0; i < polygons.length; i++) {
	        var polygon = polygons[i];
	        if (polygon.island == undefined) {
	            polygon.island = island_count++;
	            spread_island_id(polygon);
	        }
	        if (!islands[polygon.island])
	            islands[polygon.island] = [];

	        islands[polygon.island].push(polygons[i]);
	    }

	    return islands;
	}

	function indexOf(l, v) {
	    if (l.indexOf)
	        return l.indexOf(v);
	    else
	        for (var i = 0; i < l.length; i++) {
	            if (l[i] == v)
	                return i;
	        }
	    return -1;
	}

	var get_shared_vertices_in_order = function (a, b) {
	    function shift_l(uintvec) {
	        var a = uintvec[0];
	        uintvec[0] = uintvec[1];
	        uintvec[1] = uintvec[2];
	        uintvec[2] = a;
	    }
	    var a_list = a.vertex_ids;
	    var b_list = b.vertex_ids;
	    var shared_vertices = [];
	    for (var i = 0; i < a_list.length; i++) {
	        if (indexOf(b_list, a_list[i]) >= 0) {
	            shared_vertices.push(a_list[i]);
	        }
	    }
	    if (shared_vertices.length < 2)
	        return [];
	    if (indexOf(shared_vertices, a_list[0]) >= 0 &&
	        indexOf(shared_vertices, a_list[a_list.length - 1]) >= 0) {
	        // Vertices on both edges are bad, so shift them once to the left
	        shift_l(a_list);
	    }
	    if (indexOf(shared_vertices, b_list[0]) >= 0 &&
	        indexOf(shared_vertices, b_list[b_list.length - 1]) >= 0) {
	        // Vertices on both edges are bad, so shift them once to the left
	        shift_l(b_list);
	    }
	    // Again!
	    shared_vertices = [];
	    for (var i = 0; i < a_list.length; i++) {
	        if (indexOf(b_list, a_list[i]) >= 0)
	            shared_vertices.push(a_list[i]);
	    }
	    return shared_vertices;
	};

	function group_navmesh(navmesh) {

	    var ret = {};
	    var vert = navmesh.vertices;
	    for (var i = 0; i < vert.length; i++) {
	        vert[i][0] = round_number(vert[i][0], 2);
	        vert[i][1] = round_number(vert[i][1], 2);
	        vert[i][2] = round_number(vert[i][2], 2);
	    }

	    ret.vertices = navmesh.vertices;
	    var islands = build_islands(navmesh);
	    ret.islands = [];

	    var find_polygon_index = function (island, p) {
	        for (var i = 0; i < island.length; i++) {
	            if (p === island[i]) return i;
	        }
	    };

	    for (var i = 0; i < islands.length; i++) {
	        var new_island = [];
	        var island = islands[i];
	        for (var j = 0; j < island.length; j++) {
	            var neighbours = [];
	            var poly = island[j];
	            for (var k = 0; k < poly.neighbours.length; k++) {
	                neighbours.push(find_polygon_index(island, poly.neighbours[k]));
	            }
	            // Build a portal list to each neighbour
	            var portals = [];
	            for (var k = 0; k < poly.neighbours.length; k++) {
	                portals.push(get_shared_vertices_in_order(poly, poly.neighbours[k]));
	            }

	            poly.centroid[0] = round_number(poly.centroid[0], 2);
	            poly.centroid[1] = round_number(poly.centroid[1], 2);
	            poly.centroid[2] = round_number(poly.centroid[2], 2);

	            new_island.push({
	                id: find_polygon_index(island, poly),
	                neighbours: neighbours,
	                vertex_ids: poly.vertex_ids,
	                centroid: poly.centroid,
	                normal: poly.normal,
	                portals: portals,
	                // astar
	                f: 0,
	                g: 0,
	                h: 0,
	                cost: 1.0,
	                visited: false,
	                closed: false,
	                parent: null
	                // end astar
	            });

	        }
	        ret.islands.push(new_island);
	    }
	    return ret;
	}

	exports.navmesh_build_from_bufs_data = function(bufs_data) {
	    var vertices = m_geom.get_vbo_source_by_type(bufs_data.vbo_source_data, m_geom.VBO_FLOAT);
	    var indices = bufs_data.ibo_array;
	    var faces = [];
	    for (var i = 0; i < indices.length; i += 3) {
	        faces.push({
	            indices: new Uint32Array([indices[i], indices[i + 1], indices[i + 2]]),
	            centroid: new Float32Array(3),
	            normal: new Float32Array(3)
	        });
	    }
	    var vert = [];
	    for (var i = 0; i < vertices.length; i += 3) {
	        var v = new Float32Array(3);
	        v[0] = vertices[i];
	        v[1] = vertices[i + 1];
	        v[2] = vertices[i + 2];
	        vert.push(v);
	    }
	    var geometry = {
	        vertices: vert,
	        faces: faces
	    };
	    return group_navmesh(build_navigation_mesh(geometry))
	};

	exports.navmesh_get_island = function(navmesh, position, distance_to_closest) {
	    var closest_node_group = null;
	    var distance = Number.MAX_VALUE;
	    var islands = navmesh.islands;
	    for (var i = 0; i < islands.length; i++) {
	        for (var j = 0; j < islands[i].length; j++) {
	            var node = islands[i][j];

	            m_vec3.subtract(node.centroid, position, _vec3_tmp);
	            var measured_distance = distance_to_closest(position, node.centroid,
	                    node.vertex_ids, navmesh.vertices, distance);

	            if (measured_distance < distance) {
	                closest_node_group = i;
	                distance = measured_distance;
	            }
	        }
	    }

	    return closest_node_group;
	};

	/**
	 * A* search algorithm
	 * https://github.com/bgrins/javascript-astar/
	 */
	function astar_search(graph, start_node, end_node, start_pos, target_pos, vertices) {
	    function init(graph) {
	        for (var x = 0; x < graph.length; x++) {
	            var node = graph[x];
	            node.f = 0;
	            node.g = 0;
	            node.h = 0;
	            node.cost = 1.0;
	            node.visited = false;
	            node.closed = false;
	            node.parent = null;
	        }
	    }

	    function heuristic(pos1, pos2) {
	        m_vec3.subtract(pos1, pos2, _vec3_tmp);
	        return m_vec3.dot(_vec3_tmp, _vec3_tmp);
	    }

	    function get_neighbours(graph, node) {
	        var ret = [];
	        for (var e = 0; e < node.neighbours.length; e++) {
	            ret.push(graph[node.neighbours[e]]);
	        }
	        return ret;
	    }

	    init(graph);
	    var open_heap = m_math.binary_heap_new(function (node) {
	        return node.f;
	    });
	    m_math.binary_heap_push(open_heap, start_node);

	    while (open_heap.content.length > 0) {
	        // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.
	        var current_node = m_math.binary_heap_pop(open_heap);
	        // End case -- result has been found, return the traced path.
	        if (current_node === end_node) {
	            var curr = current_node;
	            var ret = [];
	            while (curr.parent) {
	                ret.push(curr);
	                curr = curr.parent;
	            }
	            // push first step of path
	            ret.push(start_node);

	            return ret.reverse();
	        }

	        // Normal case -- move current_node from open to closed, process each
	        // of its neighbours.
	        current_node.closed = true;

	        // Find all neighbours for the current node. Optionally find diagonal
	        // neighbours as well (false by default).
	        var neighbours = get_neighbours(graph, current_node);

	        for (var i = 0, il = neighbours.length; i < il; i++) {
	            var neighbour = neighbours[i];

	            if (neighbour.closed) {
	                // Not a valid node to process, skip to next neighbour.
	                continue;
	            }

	            // The g score is the shortest distance from start to current node.
	            // We need to check if the path we have arrived at this neighbour
	            // is the shortest one we have seen yet.
	            var g_score = current_node.g + m_vec3.dist(neighbour.centroid,
	                    current_node.centroid);
	            var been_visited = neighbour.visited;

	            if (!been_visited || g_score < neighbour.g) {

	                // Found an optimal (so far) path to this node.
	                // Take score for node to see how good it is.
	                neighbour.visited = true;
	                neighbour.parent = current_node;

	                neighbour.h = neighbour.h || (heuristic(neighbour.centroid, target_pos) + heuristic(neighbour.centroid, start_pos));
	                neighbour.g = g_score;
	                neighbour.f = neighbour.g + neighbour.h;
	                if (!been_visited) {
	                    // Pushing to heap will put it in proper place based on the 'f' value.
	                    m_math.binary_heap_push(open_heap, neighbour);
	                } else {
	                    // Already seen the node, but since it has been rescored we
	                    // need to reorder it in the heap
	                    m_math.binary_heap_rescore_element(open_heap, neighbour);
	                }
	            }
	        }
	    }
	    // No result was found - empty array signifies failure to find path.
	    return [];
	}

	function push_vec3(array, vec3) {
	    array.push(vec3[0]);
	    array.push(vec3[1]);
	    array.push(vec3[2]);
	}

	function get_rotation_sign(origin, p1, p2, normal) {
	    var dir_o_p1 = m_vec3.subtract(p1, origin, _vec3_tmp);
	    var dir_o_p2 = m_vec3.subtract(p2, origin, _vec3_tmp2);
	    var cross = m_vec3.cross(dir_o_p1, dir_o_p2, _vec3_tmp);
	    return m_util.sign(m_vec3.dot(normal, cross));
	}

	function vequal(a, b) {
	    m_vec3.subtract(a, b, _vec3_tmp);
	    return m_vec3.dot(_vec3_tmp, _vec3_tmp) < 0.00001;
	}

	// uses _vec3_tmp, _vec3_tmp2, _mat4_tmp3
	function update_accum_mat(accum_mat, curr_portal, prev_portal) {
	    var curr_portal_dir = m_vec3.subtract(curr_portal.right,
	            curr_portal.left, _vec3_tmp);
	    var prev_normal = prev_portal.normal;
	    var curr_normal = curr_portal.normal;

	    var angle = Math.acos(m_vec3.dot(prev_normal, curr_normal));
	    var is_right = m_util.sign(m_vec3.dot(curr_portal_dir,
	            m_vec3.cross(prev_normal, curr_normal, _vec3_tmp2)));
	    angle *= -is_right;

	    var mat = m_mat4.identity(_mat4_tmp3);
	    m_mat4.translate(mat, curr_portal.left, mat);
	    m_mat4.rotate(mat, angle, curr_portal_dir, mat);
	    m_mat4.translate(mat, m_vec3.scale(curr_portal.left, -1, _vec3_tmp2), mat);
	    m_mat4.multiply(accum_mat, mat, accum_mat);
	    return accum_mat;
	}

	// uses _vec3_tmp, _vec4_tmp, _vec4_tmp2, _vec4_tmp3
	function get_point_on_navmesh(accum_begin_apex, accum_end_apex,
	        begin_portal, end_portal,
	        first_poly_normal, interapex_accum_mat, dest) {

	    // four-dimensional point vector (w === 1)
	    var accum_begin_portal = m_vec3.transformMat4(begin_portal,
	            interapex_accum_mat, _vec4_tmp);
	    accum_begin_portal[3] = 1;
	    var accum_end_portal = m_vec3.transformMat4(end_portal,
	            interapex_accum_mat, _vec3_tmp);

	    // four-dimensional direction vector (w === 0)
	    var accum_portal_dir = m_vec3.subtract(accum_end_portal,
	            accum_begin_portal, _vec4_tmp2);
	    var accum_apex_dir = m_vec3.subtract(accum_end_apex, accum_begin_apex,
	            _vec3_tmp);

	    var normal = m_vec3.cross(first_poly_normal, accum_apex_dir, _vec4_tmp3);

	    if (Math.abs(m_vec3.dot(normal, accum_portal_dir)) < 0.01) {
	        var t = 1/2;
	    } else {
	        // four-dimensional plane representation
	        m_vec3.normalize(normal, normal);
	        normal[3] = - m_vec3.dot(normal, accum_end_apex);
	        var t = - m_vec4.dot(normal, accum_begin_portal) /
	                m_vec4.dot(normal, accum_portal_dir);
	    }

	    var portal_dir = m_vec3.subtract(end_portal, begin_portal, _vec3_tmp);
	    return m_vec3.scaleAndAdd(begin_portal, portal_dir, t, dest);
	}

	// uses _mat4_tmp
	// dep: uses _vec3_tmp, _vec3_tmp2, _vec4_tmp, _vec4_tmp2, _vec4_tmp3, _mat4_tmp3
	function update_crucial_on_navmesh(portals, accum_new_apex, new_apex_index,
	        old_portal_apex, old_apex_index, apex_normal, pts_dest, return_normals,
	        normals_dest) {
	    var interapex_accum_mat = m_mat4.identity(_mat4_tmp);
	    for (var j = old_apex_index; j < new_apex_index; j++) {
	        if (portals[j].is_crucial) {
	            if (j > old_apex_index || !j) {
	                // use m_vec3.create(), bcz it is a new point.
	                var navmesh_point = get_point_on_navmesh(
	                        accum_new_apex, old_portal_apex,
	                        portals[j].left, portals[j].right,
	                        apex_normal, interapex_accum_mat,
	                        m_vec3.create());
	                push_vec3(pts_dest, navmesh_point);
	                if (return_normals)
	                    push_vec3(normals_dest, portals[j].normal);

	                if (j)
	                    update_accum_mat(interapex_accum_mat, portals[j], portals[j-1]);
	            }
	        }
	    }
	}

	/**
	 * Pulling the string
	 * https://skatgame.net/mburo/ps/thesis_demyen_2006.pdf
	 */
	function string_pull(portals, return_normals) {
	    var pts = [];
	    var normals = [];
	    // Init scan state
	    var portal_apex, portal_left, portal_right;
	    var accum_portal_left, accum_portal_right, apex_normal;
	    var apex_index = 0;
	    var left_index = 0;
	    var right_index = 0;
	    portal_apex = portals[0].right;
	    portal_left = portals[0].left;
	    portal_right = portals[0].right;
	    accum_portal_left = m_vec3.copy(portal_left, _accum_left_portal_tmp);
	    accum_portal_right = m_vec3.copy(portal_right, _accum_right_portal_tmp);
	    apex_normal = m_vec3.copy(portals[0].normal, _apex_normal_tmp);

	    // Add start point.
	    push_vec3(pts, portal_apex);
	    if (return_normals)
	        push_vec3(normals, portals[0].normal);

	    var accum_mat = m_mat4.identity(_mat4_tmp2);

	    function update_apex(point, index) {
	        apex_index = index;
	        left_index = apex_index;
	        right_index = apex_index;

	        portal_apex = point;
	        portal_left = portal_apex;
	        portal_right = portal_apex;
	        m_vec3.copy(point, accum_portal_left);
	        m_vec3.copy(point, accum_portal_right);
	        m_vec3.copy(portals[apex_index].normal, apex_normal);
	    }

	    for (var i = 1; i < portals.length; i++) {
	        var left = portals[i].left;
	        var right = portals[i].right;
	        var accum_left = m_vec3.transformMat4(left, accum_mat, _accum_left_tmp);
	        var accum_right = m_vec3.transformMat4(right, accum_mat, _accum_right_tmp);
	        if (portals[i].is_crucial)
	            update_accum_mat(accum_mat, portals[i], portals[i-1]);

	        // Update right vertex.
	        if (get_rotation_sign(portal_apex, accum_portal_right, accum_right,
	                apex_normal) <= 0.0) {
	            var eq = vequal(portal_apex, portal_right);
	            if (eq || get_rotation_sign(portal_apex, accum_portal_left,
	                    accum_right, apex_normal) > 0.0) {
	                // Tighten the funnel.
	                portal_right = right;
	                m_vec3.copy(accum_right, accum_portal_right);
	                right_index = i;
	            } else {
	                var left_is_apex = vequal(accum_portal_left, portal_apex);
	                if (!left_is_apex)
	                    update_crucial_on_navmesh(portals, accum_portal_left,
	                            left_index, portal_apex, apex_index, apex_normal, pts,
	                            return_normals, normals);
	                accum_mat = m_mat4.identity(accum_mat);

	                // Make current left the new apex.
	                // Right over left, insert left to path and
	                // restart scan from portal left point.
	                update_apex(portal_left, left_index);

	                // Restart scan
	                i = apex_index;

	                if (!left_is_apex) {
	                    push_vec3(pts, portal_apex);
	                    if (return_normals)
	                        push_vec3(normals, portals[i].normal);
	                }

	                continue;
	            }
	        }

	        // Update left vertex.
	        if (get_rotation_sign(portal_apex, accum_portal_left, accum_left,
	                apex_normal) >= 0.0) {
	            var eq = vequal(portal_apex, portal_left);
	            if (eq || get_rotation_sign(portal_apex, accum_portal_right,
	                    accum_left, apex_normal) < 0.0) {
	                // Tighten the funnel.
	                portal_left = left;
	                m_vec3.copy(accum_left, accum_portal_left);
	                left_index = i;
	            } else {
	                var right_is_apex = vequal(accum_portal_right, portal_apex);
	                if (!right_is_apex)
	                    update_crucial_on_navmesh(portals, accum_portal_right,
	                            right_index, portal_apex, apex_index, apex_normal, pts,
	                            return_normals, normals);
	                accum_mat = m_mat4.identity(accum_mat);

	                // Make current right the new apex.
	                // Left over right, insert right to path and
	                // restart scan from portal right point.
	                update_apex(portal_right, right_index);

	                // Restart scan
	                i = apex_index;
	                if (!right_is_apex) {
	                    push_vec3(pts, portal_apex);
	                    if (return_normals)
	                        push_vec3(normals, portals[i].normal);
	                }

	                continue;
	            }
	        }
	    }

	    var last_index = portals.length - 1;
	    var last_portal_left = portals[last_index].left;
	    var is_last_apex = vequal(portal_apex, last_portal_left);
	    if (!is_last_apex) {
	        update_crucial_on_navmesh(portals, accum_portal_left, last_index,
	                portal_apex, apex_index, apex_normal, pts, return_normals,
	                normals);
	    }

	    if (!is_last_apex || !apex_index) {
	        // Append last point to path.
	        push_vec3(pts, last_portal_left);
	    }

	    if (return_normals) {
	        push_vec3(normals, portals[last_index].normal);
	        return {
	            "positions": new Float32Array(pts),
	            "normals": new Float32Array(normals)
	        }
	    } else
	        return {
	            "positions": new Float32Array(pts),
	            "normals": null
	        }
	}

	function is_point_in_poly(poly, pt) {
	    for (var c = false, i = -1, l = poly.length, j = l - 1; ++i < l; j = i)
	        ((poly[i][1] <= pt[1] && pt[1] < poly[j][1]) ||
	        (poly[j][1] <= pt[1] && pt[1] < poly[i][1])) &&
	        (pt[0] < (poly[j][0] - poly[i][0]) * (pt[1] - poly[i][1]) /
	        (poly[j][1] - poly[i][1]) + poly[i][0]) && (c = !c);
	    return c;
	}

	exports.is_vector_in_poly = is_vector_in_poly;
	function is_vector_in_poly(vector, vertex_ids, vertices) {
	    var polygon_vertices = [];
	    for (var i = 0; i < vertex_ids.length; i++) {
	        var id = vertex_ids[i];
	        polygon_vertices.push(vertices[id]);
	    }
	    if (is_point_in_poly(polygon_vertices, vector))
	        return true;
	    return false;
	}

	function get_navmesh_closest_node(all_nodes, vertices, position,
	        allowed_distance, distance_function) {

	    var closest_node = null;
	    var distance = Number.MAX_VALUE;

	    for (var i = 0; i < all_nodes.length; i++) {
	        var node = all_nodes[i];

	        var measured_distance = distance_function(position, node.centroid,

	                node.vertex_ids, vertices, distance);

	        if (measured_distance < distance) {
	            closest_node = node;
	            distance = measured_distance;
	        }
	    }

	    if (allowed_distance > 0 && distance > allowed_distance)
	        return null;
	    else
	        return closest_node;
	}

	function get_portal_from_to(a, b) {
	    for (var i = 0; i < a.neighbours.length; i++) {
	        if (a.neighbours[i] === b.id) {
	            return a.portals[i];
	        }
	    }
	}

	function channel_push(portals, p1, p2, is_crucial, normal) {
	    portals.push({
	        left: p1,
	        right: p2,
	        is_crucial: is_crucial,
	        normal: normal
	    });
	}

	function get_pulled_string(path, start_pos, target_pos, vertices, return_normals) {
	    var channel_portals = [];

	    channel_push(channel_portals, start_pos, start_pos, false,
	            path[0] && path[0].normal || m_util.AXIS_Z);

	    for (var i = 0; i < path.length; i++) {
	        var polygon = path[i];
	        var next_polygon = path[i + 1];
	        if (next_polygon) {
	            // TODO: remove magic constant
	            var is_crucial = Math.abs(m_vec3.dot(polygon.normal,
	                    next_polygon.normal)) < 0.999;

	            var portals = get_portal_from_to(polygon, next_polygon);
	            channel_push(channel_portals,
	                vertices[portals[0]],
	                vertices[portals[1]],
	                is_crucial,
	                next_polygon.normal
	            );
	        }
	    }

	    channel_push(channel_portals, target_pos, target_pos, false,
	            channel_portals[channel_portals.length - 1].normal);

	    return string_pull(channel_portals, return_normals);
	}

	exports.navmesh_find_path = function(navmesh, start_pos, target_pos, options) {
	    var path = find_path(navmesh, start_pos, target_pos, options);
	    if (!path || !path.length)
	        return null;

	    // We got the corridor
	    // Now pull the rope
	    if (options.do_not_pull_string) {
	        return get_centroid_string(path, options.return_normals);
	    } else {
	        var vertices = navmesh.vertices;
	        return get_pulled_string(path, start_pos, target_pos, vertices,
	                options.return_normals);
	    }
	};

	function get_centroid_string(path, return_normals) {
	    if (return_normals) {
	        var string = new Float32Array(3 * path.length);
	        for (var i = 0; i < path.length; i++)
	            string.set(path[i].centroid, 3 * i);
	        return {
	            "positions": string,
	            "normals": null
	        };
	    } else {
	        var positions = new Float32Array(3 * path.length);
	        var normals = new Float32Array(3 * path.length);
	        for (var i = 0; i < path.length; i++) {
	            positions.set(path[i].centroid, 3 * i);
	            normals.set(path[i].normal, 3 * i);
	        }
	        return {
	            "positions": positions,
	            "normals": normals
	        };
	    }
	}

	function find_path(navmesh, start_pos, target_pos, options) {
	    var island = options.island;
	    var all_nodes = navmesh.islands[island];
	    var vertices = navmesh.vertices;
	    var start_node = get_navmesh_closest_node(all_nodes, vertices, start_pos,
	            options.allowed_distance, options.distance_to_closest);

	    if (!start_node)
	        return null;

	    var target_node = get_navmesh_closest_node(all_nodes, vertices, target_pos,
	            options.allowed_distance, options.distance_to_farthest);

	    if (!target_node)
	        return null;

	    return astar_search(all_nodes, start_node, target_node, start_pos,
	            target_pos, vertices);
	}

	}

	var int_navmesh_factory = register("__navmesh", Int_navmesh);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Physics internal API.
	 * @name physics
	 * @namespace
	 * @exports exports as physics
	 */
	function Int_physics(ns, exports) {

	var m_cfg      = int_config_factory(ns);
	var m_debug    = int_debug_factory(ns);
	var m_ipc      = int_ipc_factory(ns);
	var m_obj_util = int_obj_util_factory(ns);
	var m_print    = print_factory(ns);
	var m_quat     = quat_factory(ns);
	var m_scs      = int_scenes_factory(ns);
	var m_subs     = int_subscene_factory(ns);
	var m_trans    = int_transform_factory(ns);
	var m_tsr      = int_tsr_factory(ns);
	var m_util     = int_util_factory(ns);
	var m_vec3     = vec3_factory(ns);
	var m_version  = int_version_factory(ns);
	var m_navmesh  = int_navmesh_factory(ns);

	var cfg_phy = m_cfg.physics;
	var cfg_def = m_cfg.defaults;
	var cfg_ldr = m_cfg.assets;

	var _phy_fps = 0;
	var _workers = [];
	var _scenes = [];

	var _bounding_objects = {};
	var _bounding_objects_arr = [];

	var _collision_ids = ["ANY"];

	// IDs always begin with 1
	var _unique_counter = {
	    body: 0,
	    constraint: 0,
	    ray_test: 0
	};

	var _vec3_tmp = new Float32Array(3);
	var _quat_tmp = new Float32Array(4);
	var _tsr_tmp  = m_tsr.create();
	var _tsr_tmp2 = m_tsr.create();

	// vehicle types for internal usage
	var VT_CHASSIS     = 10;
	var VT_HULL        = 20;

	/**
	 * Initialize physics engine
	 */
	exports.init_scene_physics = function(scene) {

	    scene._physics = {
	        worker_loaded: false,
	        bundles: [],
	        ray_tests: {},
	        ray_tests_arr: []
	    };

	    var path = cfg_phy.uranium_path;

	    if (cfg_ldr.prevent_caching)
	        path += "?v=" + m_version.get_build_version();

	    m_print.log("%cLOAD PHYSICS", "color: #0a0", cfg_phy.use_workers ?
	            "Using Separate Worker Thread," : "Using Same Thread,",
	            "Max FPS: " + cfg_phy.max_fps);
	    m_print.log("%cPHYSICS PATH", "color: #0a0", path);
	    var worker = m_ipc.create_worker(path, !cfg_phy.use_workers);
	    m_ipc.attach_handler(worker, process_message);

	    _workers.push(worker);
	    _scenes.push(scene);

	    if (cfg_phy.ping)
	        setInterval(function() {m_ipc.post_msg(worker, m_ipc.OUT_PING,
	                    performance.now());}, 1000);
	};

	exports.check_worker_loaded = function(scene) {
	    if (scene._physics)
	        return scene._physics.worker_loaded;
	    else
	        return true;
	};

	exports.cleanup = function() {
	    for (var i = 0; i < _workers.length; i++)
	        m_ipc.terminate(_workers[i]);

	    _workers.length = 0;
	    _scenes.length = 0;

	    _bounding_objects = {};
	    _bounding_objects_arr.length = 0;
	    _collision_ids = ["ANY"];

	    for (var cnt in _unique_counter)
	        _unique_counter[cnt] = 0;
	};

	function add_compound_children(parent, container) {
	    var children = parent.cons_descends;

	    for (var i = 0; i < children.length; i++) {
	        if (children[i].physics_settings.use_collision_compound)
	            container.push(children[i]);

	        add_compound_children(children[i], container);
	    }

	    return null;
	}

	exports.append_object = function(obj, scene) {

	    if (!scene_has_physics(scene))
	        return;

	    var phy_set = obj.physics_settings;

	    var worker = find_worker_by_scene(scene);

	    var compound_children = [];

	    if (phy_set.use_collision_compound)
	        add_compound_children(obj, compound_children);

	    var bundles = scene._physics.bundles;

	    // NOTE_1: object physics has higher priority
	    // NOTE_2: object physics is always bounding physics due to high performance
	    // constraints

	    if (is_vehicle_chassis(obj) || is_vehicle_hull(obj) ||
	            obj.is_character || is_floater_main(obj) || obj.use_obj_physics) {
	        var is_navmesh = is_navigation_mesh(obj);
	        if (is_navmesh)
	            var phy = init_navigation_mesh_physics(obj, scene);
	        else
	            var phy = init_bounding_physics(obj, compound_children, worker);

	        obj.physics = phy;

	        var pb = {
	            batch: null,
	            physics: phy
	        };

	        if (!is_navmesh) {
	            bundles.push(pb);
	            recalc_collision_tests(scene, worker, phy.collision_id);
	        }
	    } else {
	        var sc_data = m_obj_util.get_scene_data(obj, scene);
	        var batches = sc_data.batches;

	        for (var i = 0; i < batches.length; i++) {

	            var batch = batches[i];

	            if (batch.type != "PHYSICS" || has_batch(scene, batch))
	                continue;

	            if (!batch.submesh.base_length) {
	                m_print.error("Object " + obj.name +
	                        " has collision material with no assigned vertices");
	                continue;
	            }

	            if (batch.water && scene._render.water_params) {
	                init_water_physics(batch, scene, worker);
	                continue;
	            }

	            if (batch.use_ghost)
	                var phy = init_ghost_mesh_physics(obj, batch, worker);
	            else
	                var phy = init_static_mesh_physics(obj, batch, worker);

	            obj.physics = phy;
	            // physics bundle
	            var pb = {
	                batch: batch,
	                physics: phy
	            };

	            bundles.push(pb);
	            recalc_collision_tests(scene, worker, phy.collision_id);
	        }
	    }

	    if (is_vehicle_chassis(obj) || is_vehicle_hull(obj)) {
	        init_vehicle(obj, worker);
	        update_vehicle_controls(obj, obj.vehicle, worker);
	    } else if (obj.is_character)
	        init_character(obj, worker);
	    else if (is_floater_main(obj))
	        init_floater(obj, worker);

	    for (var i = 0; i < _bounding_objects_arr.length; i++) {
	        var bound_obj = _bounding_objects_arr[i];
	        if (bound_obj.physics)
	            process_rigid_body_joints(bound_obj);
	    }
	};

	function recalc_collision_tests(scene, worker, collision_id) {
	    var bundles = scene._physics.bundles;

	    for (var i = 0; i < bundles.length; i++) {
	        var phy = bundles[i].physics;

	        for (var j = 0; j < phy.collision_tests.length; j++) {
	            var test = phy.collision_tests[j];

	            if (test.collision_id == "ANY" || collision_id == test.collision_id)
	                append_collision_pairs(test, scene, worker);
	        }
	    }
	}

	function has_batch(scene, batch) {

	    var pbundles = scene._physics.bundles;

	    for (var i = 0; i < pbundles.length; i++) {
	        var pbatch = pbundles[i].batch;

	        if (pbatch && pbatch.id == batch.id)
	            return true;
	    }

	    return false;
	}

	/**
	 * Process message incoming from worker
	 */
	function process_message(worker, msg_id, msg) {

	    // NOTE: silently ignore if something arrives after the worker's termination
	    // NOTE: is it possible?
	    if (!m_ipc.is_active(worker))
	        return;

	    switch (msg_id) {
	    case m_ipc.IN_LOADED:
	        var scene = find_scene_by_worker(worker);
	        scene._physics.worker_loaded = true;

	        // initialize world
	        var fallback_init_time = Date.now() - performance.now();
	        m_ipc.post_msg(worker, m_ipc.OUT_INIT, fallback_init_time, cfg_phy.max_fps,
	                cfg_phy.calc_fps ? cfg_def.fps_measurement_interval : 0);
	        break;
	    case m_ipc.IN_LOG:
	        m_print.log_raw("URANIUM:", msg.slice(1));
	        break;
	    case m_ipc.IN_ERROR:
	        m_print.error(msg);
	        break;
	    case m_ipc.IN_FBMSG:
	        m_debug.fbmsg.apply(this, msg.slice(1));
	        break;
	    case m_ipc.IN_TRANSFORM:
	        var obj = find_obj_by_body_id(msg.body_id);
	        if (obj)
	            update_interpolation_data(obj, msg.time, msg.trans,
	                                msg.quat, msg.linvel, msg.angvel);
	        break;
	    case m_ipc.IN_PROP_OFFSET:
	        var obj_chassis_hull = find_obj_by_body_id(msg.chassis_hull_body_id);
	        if (obj_chassis_hull)
	            update_prop_offset(obj_chassis_hull, msg.prop_ind, msg.trans,
	                               msg.quat);
	        break;
	    case m_ipc.IN_FLOATER_BOB_TRANSFORM:
	        var obj_floater = find_obj_by_body_id(msg[1]);
	        if (obj_floater)
	            update_floater_bob_coords(obj_floater, msg[2], msg[3], msg[4]);
	        break;
	    case m_ipc.IN_VEHICLE_SPEED:
	        var obj = find_obj_by_body_id(msg[1]);
	        if (obj)
	            obj.vehicle.speed = msg[2];
	        break;
	    case m_ipc.IN_COLLISION:
	        var scene = find_scene_by_worker(worker);
	        traverse_collision_tests(scene, msg.body_id_a,
	                                 msg.body_id_b, msg.result,
	                                 null, null, 0);
	        break;
	    case m_ipc.IN_COLLISION_POS_NORM:
	        var scene = find_scene_by_worker(worker);
	        traverse_collision_tests(scene, msg.body_id_a,
	                                 msg.body_id_b, msg.result,
	                                 msg.coll_point, msg.coll_norm, 
	                                 msg.coll_dist);
	        break;
	    case m_ipc.IN_COLLISION_IMPULSE:
	        var obj = find_obj_by_body_id(msg[1]);
	        if (obj) {
	            var phy = obj.physics;

	            if (phy.col_imp_test_cb)
	                phy.col_imp_test_cb(msg[2]);
	        }
	        break;
	    case m_ipc.IN_RAY_HIT:
	    case m_ipc.IN_RAY_HIT_POS_NORM:
	        var scene = find_scene_by_worker(worker);
	        var sphy = scene._physics;
	        var test = sphy.ray_tests[msg.id];

	        // NOTE: ignoring the case when there is no test (may be removed in cb)
	        if (test) {
	            var body_id_hit = msg.body_id_hit;
	            var obj_hit = find_obj_by_body_id(body_id_hit);

	            if (msg_id == m_ipc.IN_RAY_HIT)
	                exec_ray_test_cb(test, msg.hit_fract, obj_hit, msg.hit_time, null, null);
	            else
	                exec_ray_test_cb(test, msg.hit_fract, obj_hit, msg.hit_time, msg.hit_pos,
	                        msg.hit_norm);
	        }
	        break;
	    case m_ipc.IN_REMOVE_RAY_TEST:
	        remove_ray_test(msg.id);
	        break;
	    case m_ipc.IN_PING:
	        var idx = _workers.indexOf(worker);
	        var out_time = (msg[2] - msg[1]).toFixed(3);
	        var in_time = (performance.now() - msg[2]).toFixed(3);
	        var all_time = (performance.now() - msg[1]).toFixed(3);
	        m_print.log("Physics #" + idx + " Ping: OUT " + out_time +
	                " ms, IN " + in_time + " ms, ALL " + all_time + " ms");
	        break;
	    case m_ipc.IN_FPS:
	        _phy_fps = msg[1];
	        break;
	    case m_ipc.IN_DEBUG_STATS:
	        var idx = _workers.indexOf(worker);
	        // TODO: add scene name
	        m_print.log("Worker: #" + String(idx));
	        m_print.log(msg[1]);
	        break;
	    default:
	        m_print.error("Wrong message: " + msg_id);
	        break;
	    }
	}

	function find_scene_by_worker(worker) {
	    for (var i = 0; i < _workers.length; i++)
	        if (_workers[i] == worker)
	            return _scenes[i];
	}

	function find_worker_by_scene(scene) {
	    for (var i = 0; i < _scenes.length; i++)
	        if (_scenes[i] == scene)
	            return _workers[i];
	}

	exports.find_obj_by_body_id = find_obj_by_body_id;
	/**
	 * Find dynamic objects by given body ID
	 */
	function find_obj_by_body_id(body_id) {
	    return _bounding_objects[body_id] || null;
	}

	function update_interpolation_data(obj, time, trans, quat, linvel, angvel) {
	    var phy = obj.physics;

	    phy.curr_time = time;
	    var scale = m_tsr.get_scale(obj.render.world_tsr);
	    m_tsr.set_sep(trans, scale, quat, phy.curr_tsr);

	    m_vec3.copy(linvel, phy.linvel);
	    m_vec3.copy(angvel, phy.angvel);
	}

	function update_prop_offset(obj_chassis_hull, prop_num, trans, quat) {
	    var prop_offset = obj_chassis_hull.vehicle.prop_offsets[prop_num];

	    m_tsr.set_sep(trans, 1.0, quat, prop_offset);
	}

	function update_floater_bob_coords(obj_floater, bob_num, trans, quat) {

	    var obj_bob = obj_floater.floater.bobs[bob_num];
	    m_trans.set_translation(obj_bob, trans);
	    m_trans.set_rotation(obj_bob, quat);
	    m_trans.update_transform(obj_bob);
	}

	function traverse_collision_tests(scene, body_id_a, body_id_b, pair_result,
	        coll_pos, coll_norm, coll_dist) {

	    var bundles = scene._physics.bundles;

	    for (var i = 0; i < bundles.length; i++) {
	        var phy = bundles[i].physics;

	        for (var j = 0; j < phy.collision_tests.length; j++) {
	            var test = phy.collision_tests[j];
	            var pairs = test.pairs;

	            var results_changed = false;

	            for (var k = 0; k < pairs.length; k++) {
	                var pair = pairs[k];

	                if (pair[0] === body_id_a && pair[1] === body_id_b) {
	                    test.pair_results[k] = pair_result;
	                    results_changed = true;
	                    break;
	                }
	            }

	            if (results_changed) {
	                var result = calc_coll_result(test);

	                if (coll_pos && test.body_id_src != body_id_a)
	                    correct_coll_pos_norm(coll_pos, coll_norm, coll_dist);

	                if (!result)
	                    var coll_obj = null;
	                else if (test.body_id_src == body_id_a)
	                    var coll_obj = find_obj_by_body_id(body_id_b);
	                else
	                    var coll_obj = find_obj_by_body_id(body_id_a);

	                test.callback(result, coll_obj, coll_pos, coll_norm, coll_dist);
	            }
	        }
	    }
	}

	function calc_coll_result(test) {
	    
	    var pair_results = test.pair_results;

	    var result = false;

	    // OR
	    for (var i = 0; i < pair_results.length; i++)
	        result = result || pair_results[i];

	    return result;
	}


	/**
	 * NOTE: same is in bindings.js
	 */
	function correct_coll_pos_norm(pos, norm, dist) {
	    pos[0] = pos[0] + norm[0] * dist;
	    pos[1] = pos[1] + norm[1] * dist;
	    pos[2] = pos[2] + norm[2] * dist;

	    norm[0] *= -1;
	    norm[1] *= -1;
	    norm[2] *= -1;
	}

	function exec_ray_test_cb(test, hit_fract, obj_hit, hit_time, hit_pos, hit_norm) {

	    var callback = test.callback;

	    if (hit_pos)
	        callback(test.id, hit_fract, obj_hit, hit_time, hit_pos, hit_norm);
	    else
	        callback(test.id, hit_fract, obj_hit, hit_time);
	}

	exports.update = function(timeline, delta) {

	    for (var i = 0; i < _workers.length; i++) {
	        update_worker(_workers[i], timeline, delta);

	        // update physics water time
	        var scene = _scenes[i];
	        var wp = scene._render.water_params;
	        if (wp && wp.waves_height > 0.0) {
	            var subs = m_scs.get_subs(scene, m_subs.MAIN_OPAQUE);
	            var wind = m_vec3.length(subs.wind) || 1;
	            m_ipc.post_msg(_workers[i], m_ipc.OUT_SET_WATER_TIME, subs.time * wind);
	        }
	    }
	};

	function update_worker(worker, timeline, delta) {
	    if (worker && m_ipc.is_fallback(worker))
	        m_ipc.post_msg(worker, m_ipc.OUT_UPDATE_WORLD, timeline, delta);

	    // interpolate uranium transforms in point of previous frame
	    for (var i = 0; i < _bounding_objects_arr.length; i++) {
	        var obj = _bounding_objects_arr[i];
	        var phy = obj.physics;

	        // current time = 0 - do nothing
	        if (phy.simulated && phy.curr_time) {
	            if (m_ipc.is_fallback(worker))
	                var d = timeline - phy.curr_time;
	            else
	                var d = performance.now() / 1000 - phy.curr_time;

	            // clamp to maximum 10 frames to prevent jitter of sleeping objects
	            d = Math.min(d, 10 * 1/cfg_phy.max_fps);

	            // interpolate to previous frame to fix collision issues
	            // NOTE: needs more testing
	            d -= 1/cfg_phy.max_fps;

	            if (cfg_def.no_phy_interp_hack)
	                d = 0;

	            var tsr = _tsr_tmp;
	            m_tsr.integrate(phy.curr_tsr, d, phy.linvel, phy.angvel,
	                    _tsr_tmp);

	            m_trans.set_tsr(obj, tsr);
	            m_trans.update_transform(obj);
	            sync_transform(obj);

	            if (obj.vehicle)
	                update_prop_transforms(obj);

	            if (obj.vehicle && obj.vehicle.steering_wheel)
	                update_steering_wheel_coords(obj);

	            if (obj.vehicle && obj.vehicle.speedometer)
	                update_speedometer(obj);

	            if (obj.vehicle && obj.vehicle.tachometer)
	                update_tachometer(obj);
	        }
	    }

	    m_ipc.post_msg_arr(worker);

	}

	function update_prop_transforms(obj_chassis_hull) {

	    var obj_props = obj_chassis_hull.vehicle.props;

	    var chass_hull_tsr = obj_chassis_hull.render.world_tsr;
	    var prop_tsr = _tsr_tmp;

	    for (var i = 0; i < obj_props.length; i++) {
	        var obj_prop = obj_props[i];
	        var prop_offset = obj_chassis_hull.vehicle.prop_offsets[i];

	        m_tsr.multiply(chass_hull_tsr, prop_offset, prop_tsr);

	        m_trans.set_tsr(obj_prop, prop_tsr);
	        m_trans.update_transform(obj_prop);
	    }
	}


	exports.get_active_scene = function() {
	    // TODO: fix it
	    return _scenes[0];
	};

	exports.pause = function() {
	    for (var i = 0; i < _workers.length; i++)
	        m_ipc.post_msg(_workers[i], m_ipc.OUT_PAUSE);
	};

	exports.resume = function() {
	    for (var i = 0; i < _workers.length; i++)
	        m_ipc.post_msg(_workers[i], m_ipc.OUT_RESUME);
	};

	function get_unique_body_id() {
	    _unique_counter.body++;
	    return _unique_counter.body;
	}


	function init_water_physics(batch, scene, worker) {

	    var wp = scene._render.water_params;
	    m_ipc.post_msg(worker, m_ipc.OUT_APPEND_WATER, wp.water_level);

	    // TODO: get water_params for proper water object (not the common one)
	    if (batch.water_dynamics) {
	        var water_dyn_info = {};
	        water_dyn_info["dst_noise_scale0"]  = batch.dst_noise_scale0;
	        water_dyn_info["dst_noise_scale1"]  = batch.dst_noise_scale1;
	        water_dyn_info["dst_noise_freq0"]   = batch.dst_noise_freq0;
	        water_dyn_info["dst_noise_freq1"]   = batch.dst_noise_freq1;
	        water_dyn_info["dir_min_shore_fac"] = batch.dir_min_shore_fac;
	        water_dyn_info["dir_freq"]          = batch.dir_freq;
	        water_dyn_info["dir_noise_scale"]   = batch.dir_noise_scale;
	        water_dyn_info["dir_noise_freq"]    = batch.dir_noise_freq;
	        water_dyn_info["dir_min_noise_fac"] = batch.dir_min_noise_fac;
	        water_dyn_info["dst_min_fac"]       = batch.dst_min_fac;
	        water_dyn_info["waves_hor_fac"]     = batch.waves_hor_fac;

	        var waves_height   = wp.waves_height;
	        var waves_length   = wp.waves_length;
	        if (wp.shoremap_image) {
	            var size_x         = wp.shoremap_size[0];
	            var size_y         = wp.shoremap_size[1];
	            var center_x       = wp.shoremap_center[0];
	            var center_y       = wp.shoremap_center[1];
	            var max_shore_dist = wp.max_shore_dist;
	            var array_width    = wp.shoremap_tex_size;
	            m_ipc.post_msg(worker, m_ipc.OUT_ADD_WATER_WRAPPER, water_dyn_info, size_x,
	                           size_y, center_x, center_y, max_shore_dist,
	                           waves_height, waves_length, array_width,
	                           scene._render.shore_distances);
	        } else {
	            m_ipc.post_msg(worker, m_ipc.OUT_ADD_WATER_WRAPPER, water_dyn_info, 0, 0, 0, 0,
	                           0, waves_height, waves_length, 0, null);
	        }
	    }
	}

	function init_static_mesh_physics(obj, batch, worker) {

	    var body_id = get_unique_body_id();

	    var submesh = batch.submesh;

	    var positions = submesh.va_frames[0]["a_position"];
	    var indices = submesh.indices || null;

	    var trans = m_tsr.get_trans_view(obj.render.world_tsr);

	    var friction = batch.friction;
	    var restitution = batch.elasticity;
	    var collision_id = batch.collision_id;
	    var collision_id_num = col_id_num(collision_id);
	    var collision_margin = batch.collision_margin;
	    var collision_group = batch.collision_group;
	    var collision_mask = batch.collision_mask;

	    m_ipc.post_msg(worker, m_ipc.OUT_APPEND_STATIC_MESH_BODY, body_id, positions,
	            indices, trans, friction, restitution, collision_id_num,
	            collision_margin, collision_group, collision_mask);

	    var phy = init_physics(body_id, "STATIC_MESH");
	    phy.collision_id = collision_id;
	    phy.collision_id_num = collision_id_num;
	    return phy;
	}

	function col_id_num(id) {

	    var num = _collision_ids.indexOf(id);
	    if (num == -1) {
	        _collision_ids.push(id);
	        return (_collision_ids.length - 1);
	    } else
	        return num;
	}

	function init_physics(body_id, type) {
	    var phy = {
	        body_id: body_id,
	        type: type,
	        mass: 0,
	        is_ghost: false,
	        simulated: true,
	        is_vehicle: false,
	        is_character: false,
	        is_floater: false,
	        cons_id: null,
	        collision_id: "",
	        collision_id_num: 0,
	        collision_callbacks: {},
	        collision_tests: [],
	        col_imp_test_cb: null,

	        curr_time: 0,
	        curr_tsr: new Float32Array([0,0,0,1,0,0,0,1]),

	        linvel: new Float32Array(3),
	        angvel: new Float32Array(3),

	        cached_trans: new Float32Array(3),
	        cached_quat: new Float32Array(4),
	        navmesh: null
	    };

	    return phy;
	}

	/**
	 * E.g for water ray casting
	 */
	function init_ghost_mesh_physics(obj, batch, worker) {

	    var body_id = get_unique_body_id();

	    var submesh = batch.submesh;
	    var positions = submesh.va_frames[0]["a_position"];
	    var indices = submesh.indices || null;
	    var collision_id = batch.collision_id;
	    var collision_id_num = col_id_num(collision_id);
	    var collision_margin = batch.collision_margin;
	    var collision_group = batch.collision_group;
	    var collision_mask = batch.collision_mask;

	    var trans = m_tsr.get_trans_view(obj.render.world_tsr);

	    m_ipc.post_msg(worker, m_ipc.OUT_APPEND_GHOST_MESH_BODY, body_id, positions,
	            indices, trans, collision_id_num, collision_margin, collision_group,
	            collision_mask);

	    var phy = init_physics(body_id, "STATIC_MESH");
	    phy.is_ghost = true;
	    phy.collision_id = collision_id;
	    phy.collision_id_num = collision_id_num;

	    return phy;
	}


	function init_bounding_physics(obj, compound_children, worker) {
	    var render = obj.render;
	    var phy_set = obj.physics_settings;

	    var physics_type = phy_set.physics_type;

	    var body_id = get_unique_body_id();

	    if (obj.type == "CAMERA") {
	        var bounding_type = phy_set.use_collision_bounds ?
	                phy_set.collision_bounds_type : "BOX";
	        var bounding_object = find_bounding_type(bounding_type, render);

	        // NOTE: some default values
	        var friction = 0.5;
	        var restitution = 0.0;
	    } else if (obj.type == "EMPTY") {
	        var bounding_type = "EMPTY";
	        var bounding_object = null;

	        var friction = 0;
	        var restitution = 0;
	    } else {
	        var bounding_type = phy_set.use_collision_bounds ?
	                phy_set.collision_bounds_type : "BOX";
	        var bounding_object = find_bounding_type(bounding_type, render);
	        var scale = m_tsr.get_scale(render.world_tsr);
	        if (scale != 1)
	            scale_bounding(bounding_object, bounding_type, scale);
	        var friction = render.friction;
	        var restitution = render.elasticity;
	    }

	    var trans = m_tsr.get_trans_view(render.world_tsr);
	    var quat = m_tsr.get_quat_view(render.world_tsr);
	    var is_ghost = phy_set.use_ghost;
	    // use_sleep=true - no sleeping
	    var disable_sleeping = phy_set.use_sleep;
	    var mass = phy_set.mass;
	    var velocity_min = phy_set.velocity_min;
	    var velocity_max = phy_set.velocity_max;
	    var damping = phy_set.damping;
	    var rotation_damping = phy_set.rotation_damping;
	    var collision_id = obj.collision_id;
	    var collision_id_num = col_id_num(collision_id);
	    var collision_margin = phy_set.collision_margin;
	    var collision_group = phy_set.collision_group;
	    var collision_mask = phy_set.collision_mask;
	    var size = render.bs_local.radius;
	    var worker_bounding = create_worker_bounding(bounding_object);
	    var correct_bound_offset = obj.correct_bounding_offset;

	    var comp_children_params = get_children_params(render,
	                    compound_children, bounding_type, worker_bounding);

	    m_ipc.post_msg(worker, m_ipc.OUT_APPEND_BOUNDING_BODY, body_id, trans, quat,
	            physics_type, is_ghost, disable_sleeping, mass,
	            velocity_min, velocity_max, damping, rotation_damping,
	            collision_id_num, collision_margin, collision_group, collision_mask,
	            bounding_type, worker_bounding, size, friction,
	            restitution, comp_children_params, correct_bound_offset);

	    _bounding_objects[body_id] = obj;
	    _bounding_objects_arr.push(obj);

	    var phy = init_physics(body_id, "BOUNDING");
	    phy.type = physics_type;
	    phy.mass = mass;
	    phy.is_ghost = is_ghost;
	    phy.collision_id = collision_id;
	    phy.collision_id_num = collision_id_num;
	    return phy;
	}

	function init_navigation_mesh_physics(obj, scene) {
	    var body_id = get_unique_body_id();
	    var phy = init_physics(body_id, "NAVMESH");
	    var sc_data = m_obj_util.get_scene_data(obj, scene);
	    var batches = sc_data.batches;
	    phy.navmesh = null;
	    for (var i = 0; i < batches.length; i++) {
	        var batch = batches[i];
	        if (batch.type == "PHYSICS") {
	            // here we have single PHYSICS batch so quit after batch was being found
	            phy.navmesh = m_navmesh.navmesh_build_from_bufs_data(batch.bufs_data);
	            break;
	        }
	    }
	    return phy;
	}


	function get_children_params(render, children, bt, wb) {

	    if (!children.length)
	        return [];

	    var comp_children_params = [];

	    // parent object is the first child compound
	    var parent_params = {};
	    parent_params["quat"] = new Float32Array([0, 0, 0, 1]);
	    parent_params["trans"] = new Float32Array(3);
	    parent_params["worker_bounding"] = wb;
	    parent_params["bounding_type"] = bt;

	    comp_children_params.push(parent_params);

	    var wtsr_inv = m_tsr.invert(render.world_tsr, _tsr_tmp);
	    var quat_inv = _quat_tmp;
	    var quat = m_tsr.get_quat_view(render.world_tsr);
	    m_quat.invert(quat, quat_inv);

	    for (var i = 0; i < children.length; i++) {
	        var child_params = {};
	        var child        = children[i];
	        var child_bt     = child.physics_settings.collision_bounds_type;
	        var loc_quat     = new Float32Array(4);
	        var loc_trans    = new Float32Array(3);

	        var ch_trans = m_tsr.get_trans_view(child.render.world_tsr);
	        var ch_quat = m_tsr.get_quat_view(child.render.world_tsr);
	        m_tsr.transform_vec3(ch_trans, wtsr_inv, loc_trans);
	        m_quat.multiply(quat_inv, ch_quat, loc_quat);

	        child_params["trans"] = loc_trans;
	        child_params["quat"] = loc_quat;
	        child_params["bounding_type"] = child_bt;
	        child_params["worker_bounding"] = create_worker_bounding(
	                           find_bounding_type(child_bt, child.render));

	        comp_children_params.push(child_params);
	    }

	    return comp_children_params;
	}

	function find_bounding_type(bounding_type, render) {

	    switch (bounding_type) {
	    case "BOX":
	        var bounding_object = render.bb_local;
	        break;
	    case "CYLINDER":
	        var bounding_object = render.bcyl_local;
	        break;
	    case "CONE":
	        var bounding_object = render.bcon_local;
	        break;
	    case "SPHERE":
	        var bounding_object = render.bs_local;
	        break;
	    case "CAPSULE":
	        var bounding_object = render.bcap_local;
	        break;
	    }

	    return bounding_object;
	}

	function scale_bounding(bound, bounding_type, scale) {
	    switch (bounding_type) {
	    case "BOX":
	        bound.min_x *= scale;
	        bound.max_x *= scale;
	        bound.min_y *= scale;
	        bound.max_y *= scale;
	        bound.min_z *= scale;
	        bound.max_z *= scale;
	        break;
	    case "CYLINDER":
	    case "CONE":
	    case "CAPSULE":
	        bound.height *= scale;
	        bound.radius *= scale;
	        break;
	    case "SPHERE":
	        bound.radius *= scale;
	        break;
	    }
	}

	function create_worker_bounding(bounding_object) {
	    // handle null EMPTY bounding
	    if (!bounding_object)
	        return null;

	    var in_obj = bounding_object;
	    var out_obj = {};

	    if (typeof in_obj.min_x === "number") out_obj["min_x"] = in_obj.min_x;
	    if (typeof in_obj.min_y === "number") out_obj["min_y"] = in_obj.min_y;
	    if (typeof in_obj.min_z === "number") out_obj["min_z"] = in_obj.min_z;
	    if (typeof in_obj.max_x === "number") out_obj["max_x"] = in_obj.max_x;
	    if (typeof in_obj.max_y === "number") out_obj["max_y"] = in_obj.max_y;
	    if (typeof in_obj.max_z === "number") out_obj["max_z"] = in_obj.max_z;

	    if (typeof in_obj.center === "object") out_obj["center"] = in_obj.center;
	    if (typeof in_obj.radius === "number") out_obj["radius"] = in_obj.radius;
	    if (typeof in_obj.height === "number") out_obj["height"] = in_obj.height;

	    return out_obj;
	}

	function init_vehicle(obj, worker) {

	    var body_id = obj.physics.body_id;

	    if (is_vehicle_chassis(obj)) {
	        obj.vehicle.type = VT_CHASSIS;
	        var susp_compress = obj.vehicle.suspension_compression;
	        var susp_stiffness = obj.vehicle.suspension_stiffness;
	        var susp_damping = obj.vehicle.suspension_damping;
	        var wheel_friction = obj.vehicle.wheel_friction;
	        var max_suspension_travel_cm = obj.vehicle.max_suspension_travel_cm;

	        m_ipc.post_msg(worker, m_ipc.OUT_APPEND_CAR, body_id,
	                               susp_compress,
	                               susp_stiffness,
	                               susp_damping,
	                               wheel_friction,
	                               max_suspension_travel_cm);
	    } else if (is_vehicle_hull(obj)) {
	        obj.vehicle.type = VT_HULL;
	        var floating_factor = obj.vehicle.floating_factor;
	        var water_lin_damp = obj.vehicle.water_lin_damp;
	        var water_rot_damp = obj.vehicle.water_rot_damp;
	        m_ipc.post_msg(worker, m_ipc.OUT_APPEND_BOAT, body_id, floating_factor,
	                                water_lin_damp, water_rot_damp);
	    }

	    if (obj.vehicle.props) {
	        var props = obj.vehicle.props;
	        switch (obj.vehicle.type) {

	        case VT_CHASSIS:
	            add_vehicle_prop(props[0], obj, body_id, true, worker);
	            add_vehicle_prop(props[1], obj, body_id, true, worker);
	            add_vehicle_prop(props[2], obj, body_id, false, worker);
	            add_vehicle_prop(props[3], obj, body_id, false, worker);
	            break;
	        case VT_HULL:
	            for (var i = 0; i < props.length; i++)
	                add_vehicle_prop(props[i], obj, body_id, false, worker);
	            break;
	        }
	    }
	}

	function add_vehicle_prop(obj_prop, obj_chassis_hull, chassis_body_id,
	        is_front, worker) {

	    // calculate connection point
	    // NOTE: initial wheel (bob) and vehicle coords may change

	    var prop_trans = m_tsr.get_trans_view(obj_prop.render.world_tsr);

	    var chassis_hull_tsr_inv = m_tsr.invert(obj_chassis_hull.render.world_tsr, _tsr_tmp);

	    var conn_point = new Float32Array(3);
	    m_tsr.transform_vec3(prop_trans, chassis_hull_tsr_inv, conn_point);

	    switch (obj_chassis_hull.vehicle.type) {
	    case VT_CHASSIS:
	        var v_set = obj_chassis_hull.vehicle_settings;
	        var suspension_rest_length = v_set.suspension_rest_length;
	        var roll_influence = v_set.roll_influence;

	        // NOTE: using bounding box, not cylinder
	        var bb = obj_prop.render.bb_local;
	        var radius = (bb.max_z - bb.min_z) / 2;

	        m_ipc.post_msg(worker, m_ipc.OUT_ADD_CAR_WHEEL, chassis_body_id, conn_point,
	                suspension_rest_length, roll_influence, radius, is_front);
	        break;
	    case VT_HULL:
	        m_ipc.post_msg(worker, m_ipc.OUT_ADD_BOAT_BOB, chassis_body_id, 
	                conn_point, obj_prop.bob_synchronize_pos);
	        break;
	    }
	}

	function init_character(obj, worker) {

	    var render = obj.render;
	    var phy    = obj.physics;

	    var height       = render.bb_local.max_z - render.bb_local.min_z;
	    var character_id = phy.body_id;

	    var char_settings = obj.character_settings;
	    var walk_speed    = char_settings.walk_speed;
	    var run_speed     = char_settings.run_speed;
	    var step_height   = char_settings.step_height;
	    var jump_strength = char_settings.jump_strength;
	    var waterline     = char_settings.waterline;

	    var rot_angle     = m_util.dir_ground_proj_angle(obj);

	    m_ipc.post_msg(worker, m_ipc.OUT_APPEND_CHARACTER, character_id, rot_angle, height,
	              walk_speed, run_speed, step_height, jump_strength, waterline);

	    phy.is_character = true;
	}

	function init_floater(obj, worker) {
	    var floating_factor = obj.floater.floating_factor;
	    var water_lin_damp = obj.floater.water_lin_damp;
	    var water_rot_damp = obj.floater.water_rot_damp;
	    var body_id = obj.physics.body_id;

	    m_ipc.post_msg(worker, m_ipc.OUT_APPEND_FLOATER, body_id, floating_factor,
	              water_lin_damp, water_rot_damp);

	    if (obj.floater.bobs) {
	        var bob_objs = obj.floater.bobs;
	        for (var i = 0; i < bob_objs.length; i++) {

	            // calculate connection point
	            var obj_bob = bob_objs[i];

	            var bob_trans = m_tsr.get_trans_view(obj_bob.render.world_tsr);

	            var wtsr_inv = m_tsr.invert(obj.render.world_tsr, _tsr_tmp);

	            var conn_point = new Float32Array(3);
	            m_tsr.transform_vec3(bob_trans, wtsr_inv, conn_point);

	            m_ipc.post_msg(worker, m_ipc.OUT_ADD_FLOATER_BOB, body_id, conn_point, obj_bob.bob_synchronize_pos);
	        }
	    }
	    obj.physics.is_floater = true;
	}

	exports.enable_simulation = function(obj) {
	    var phy = obj.physics;
	    if (!phy)
	        m_util.panic("No object physics");

	    // prevent issues with recurrent exec
	    if (phy.simulated)
	        return;

	    var body_id = phy.body_id;
	    var worker = find_worker_by_body_id(body_id);
	    phy.simulated = true;
	    m_ipc.post_msg(worker, m_ipc.OUT_ENABLE_SIMULATION, body_id);
	};

	exports.disable_simulation = function(obj) {
	    var phy = obj.physics;
	    if (!phy)
	        m_util.panic("No object physics");

	    // prevent issues with recurrent exec
	    if (!phy.simulated)
	        return;

	    var body_id = phy.body_id;
	    var worker = find_worker_by_body_id(body_id);
	    phy.simulated = false;
	    m_ipc.post_msg(worker, m_ipc.OUT_DISABLE_SIMULATION, body_id);
	};

	exports.scene_has_physics = scene_has_physics;
	/**
	 * Check if scene has physics
	 * @methodOf physics
	 */
	function scene_has_physics(scene) {
	    return Boolean(scene._physics);
	}

	exports.obj_has_physics = obj_has_physics;
	/**
	 * Check if object has physics
	 * @methodOf physics
	 */
	function obj_has_physics(obj) {
	    return Boolean(obj.physics);
	}

	/**
	 * Check if object has dynamic and simulated physics
	 */
	exports.has_dynamic_physics = function(obj) {
	    var phy = obj.physics;
	    if (phy && phy.simulated &&
	            (phy.type == "RIGID_BODY" || phy.type == "DYNAMIC") &&
	            phy.mass > 0 && phy.is_ghost == false)
	        return true;
	    else
	        return false;
	};
	/**
	 * Check if object has simulated physics of any type
	 */
	exports.has_simulated_physics = function(obj) {
	    var phy = obj.physics;
	    if (phy && phy.simulated)
	        return true;
	    else
	        return false;
	};

	exports.set_gravity = function(obj, grav_x, grav_y, grav_z) {
	    var body_id = obj.physics.body_id;
	    var worker = find_worker_by_body_id(body_id);
	    m_ipc.post_msg(worker, m_ipc.OUT_SET_GRAVITY, body_id, grav_x, grav_y, grav_z);
	};

	/**
	 * Process rigid body joints constraints
	 */
	function process_rigid_body_joints(obj) {

	    // already processed
	    if (has_constraint(obj))
	        return;

	    for (var i = 0; i < obj.physics_constraints.length; i++) {
	        var cons = obj.physics_constraints[i];
	        var targ = cons.target;
	        var pivot_type = cons.pivot_type;

	        if (!targ.physics)
	            continue;

	        var trans = get_rbj_trans(cons);
	        var quat = get_rbj_quat(cons);

	        // bullet's initial HINGE axis is Z, need to convert to Blender's X-axis
	        if (pivot_type == "HINGE")
	            m_quat.rotateY(quat, Math.PI / 2, quat);

	        var local = m_tsr.identity(_tsr_tmp);

	        local = m_tsr.set_trans(trans, local);
	        local = m_tsr.set_quat(quat, local);

	        var world_a = m_tsr.multiply(obj.render.world_tsr, local, _tsr_tmp);

	        var world_b_inv = m_tsr.invert(targ.render.world_tsr, _tsr_tmp2);

	        var local_b = m_tsr.multiply(world_b_inv, world_a, world_b_inv);

	        var local_b_tra = m_tsr.get_trans_view(local_b);
	        var local_b_qua = m_tsr.get_quat_view(local_b);

	        var limits = prepare_limits(cons);

	        apply_constraint(pivot_type, obj, trans, quat, targ, local_b_tra,
	                local_b_qua, limits, null, null);
	    }
	}

	exports.has_constraint = has_constraint;
	function has_constraint(obj) {
	    return obj.physics && obj.physics.cons_id;
	}

	function get_rbj_trans(cons) {
	    var trans = new Float32Array([cons.pivot_x, cons.pivot_y, cons.pivot_z]);
	    return trans;
	}

	function get_rbj_quat(cons) {
	    var euler = new Float32Array([cons.axis_x, cons.axis_y, cons.axis_z]);
	    var quat = m_util.euler_to_quat(euler, new Float32Array(4));
	    return quat;
	}

	function prepare_limits(cons) {
	    var limits = {};

	    limits["use_limit_x"] = cons.use_limit_x;
	    limits["use_limit_y"] = cons.use_limit_y;
	    limits["use_limit_z"] = cons.use_limit_z;

	    limits["use_angular_limit_x"] = cons.use_angular_limit_x;
	    limits["use_angular_limit_y"] = cons.use_angular_limit_y;
	    limits["use_angular_limit_z"] = cons.use_angular_limit_z;

	    limits["limit_max_x"] = cons.limit_max_x;
	    limits["limit_min_x"] = cons.limit_min_x;
	    limits["limit_max_y"] = cons.limit_max_y;
	    limits["limit_min_y"] = cons.limit_min_y;
	    limits["limit_max_z"] = cons.limit_max_z;
	    limits["limit_min_z"] = cons.limit_min_z;

	    limits["limit_angle_max_x"] = cons.limit_angle_max_x;
	    limits["limit_angle_min_x"] = cons.limit_angle_min_x;
	    limits["limit_angle_max_y"] = cons.limit_angle_max_y;
	    limits["limit_angle_min_y"] = cons.limit_angle_min_y;
	    limits["limit_angle_max_z"] = cons.limit_angle_max_z;
	    limits["limit_angle_min_z"] = cons.limit_angle_min_z;

	    return limits;
	}

	exports.apply_constraint = apply_constraint;
	function apply_constraint(pivot_type, obj_a, trans_a, quat_a,
	        obj_b, trans_b, quat_b, limits, stiffness, damping) {
	    var cons_id = get_unique_constraint_id();

	    var body_a = obj_a.physics.body_id;
	    var body_b = obj_b.physics.body_id;

	    var worker = find_worker_by_body_id(body_a);

	    m_ipc.post_msg(worker, m_ipc.OUT_APPEND_CONSTRAINT, cons_id, pivot_type, limits,
	            body_a, trans_a, quat_a, body_b, trans_b, quat_b, stiffness, damping);

	    // applied constraint always attached to object A
	    var phy = obj_a.physics;
	    phy.cons_id = cons_id;
	}

	function find_worker_by_body_id(body_id) {
	    for (var i = 0; i < _scenes.length; i++) {
	        var scene = _scenes[i];

	        var bundles = scene._physics.bundles;

	        for (var j = 0; j < bundles.length; j++) {
	            var phy = bundles[j].physics;

	            if (phy.body_id == body_id)
	                return _workers[i];
	        }
	    }

	    return null;
	}

	function get_unique_constraint_id() {
	    _unique_counter.constraint++;
	    return _unique_counter.constraint.toString(16);
	}

	exports.clear_constraint = function(obj_a) {
	    var phy = obj_a.physics;
	    var cons_id = phy.cons_id;

	    var worker = find_worker_by_body_id(phy.body_id);

	    m_ipc.post_msg(worker, m_ipc.OUT_REMOVE_CONSTRAINT, cons_id);
	    phy.cons_id = null;
	};

	exports.pull_to_constraint_pivot = function(obj_a, trans_a, quat_a,
	        obj_b, trans_b, quat_b) {

	    var tsr_a = m_tsr.set_sep(trans_a, 1, quat_a, _tsr_tmp);
	    var tsr_b = m_tsr.set_sep(trans_b, 1, quat_b, _tsr_tmp2);

	    // A -> PIVOT
	    m_tsr.invert(tsr_a, tsr_a);

	    // (A -> PIVOT) -> B
	    m_tsr.multiply(tsr_b, tsr_a, tsr_a);

	    m_trans.get_tsr(obj_b, tsr_b);

	    // A -> WORLD
	    m_tsr.multiply(tsr_b, tsr_a, tsr_a);

	    m_trans.set_tsr(obj_a, tsr_a);
	    m_trans.update_transform(obj_a);

	    var trans = m_tsr.get_trans_view(obj_a.render.world_tsr);
	    var quat = m_tsr.get_quat_view(obj_a.render.world_tsr);
	    exports.set_transform(obj_a, trans, quat);
	};

	exports.set_transform = function(obj, trans, quat) {

	    var phy = obj.physics;
	    var msg_cache = m_ipc.get_msg_cache(m_ipc.OUT_SET_TRANSFORM);

	    // use msg_cache as a temporary storage
	    var obj_trans = m_tsr.get_trans(obj.render.world_tsr, msg_cache.trans);
	    var obj_quat = m_tsr.get_quat(obj.render.world_tsr, msg_cache.quat);
	    m_tsr.set_sep(obj_trans, 1, obj_quat, phy.curr_tsr);

	    msg_cache.body_id = phy.body_id;
	    m_vec3.copy(trans, msg_cache.trans);
	    m_quat.copy(quat, msg_cache.quat);
	    // NOTE: slow
	    var worker = find_worker_by_body_id(phy.body_id);
	    m_ipc.post_msg(worker, m_ipc.OUT_SET_TRANSFORM);
	};

	exports.sync_transform = sync_transform;
	/**
	 * Recursively sync object transform with engine, if possible.
	 * @methodOf physics
	 */
	function sync_transform(obj) {

	    if (allows_transform(obj) && transform_changed(obj)) {
	        var phy = obj.physics;
	        var render = obj.render;

	        var msg_cache = m_ipc.get_msg_cache(m_ipc.OUT_SET_TRANSFORM);
	        msg_cache.body_id = phy.body_id;

	        var trans = m_tsr.get_trans(render.world_tsr, msg_cache.trans);
	        var quat = m_tsr.get_quat(render.world_tsr, msg_cache.quat);

	        m_vec3.copy(trans, phy.cached_trans);
	        m_quat.copy(quat, phy.cached_quat);

	        if (phy.type == "DYNAMIC")
	            m_quat.identity(msg_cache.quat);

	        // NOTE: slow
	        var worker = find_worker_by_body_id(phy.body_id);

	        m_ipc.post_msg(worker, m_ipc.OUT_SET_TRANSFORM);
	    }

	    var cons_descends = obj.cons_descends;

	    for (var i = 0; i < cons_descends.length; i++)
	        sync_transform(cons_descends[i]);
	}

	/**
	 * Check if object has physics that allows transform
	 */
	function allows_transform(obj) {
	    var phy = obj.physics;
	    if (!phy)
	        return false;
	    else if (phy.mass === 0)
	        return true;
	    else if (phy.is_ghost === true)
	        return true;
	    else if (phy.simulated === false)
	        return true;
	    else if (phy.type !== "RIGID_BODY" && phy.type !== "DYNAMIC")
	        return true;
	    else
	        return false;
	}

	/**
	 * uses _vec3_tmp _quat_tmp
	 */
	function transform_changed(obj) {
	    var trans = m_tsr.get_trans(obj.render.world_tsr, _vec3_tmp);
	    var quat = m_tsr.get_quat(obj.render.world_tsr, _quat_tmp);
	    return trans[0] != obj.physics.cached_trans[0] ||
	           trans[1] != obj.physics.cached_trans[1] ||
	           trans[2] != obj.physics.cached_trans[2] ||
	           quat[0] != obj.physics.cached_quat[0] ||
	           quat[1] != obj.physics.cached_quat[1] ||
	           quat[2] != obj.physics.cached_quat[2] ||
	           quat[3] != obj.physics.cached_quat[3];
	}


	/**
	 * Move object by applying velocity in its space.
	 */
	exports.apply_velocity = function(obj, vx_local, vy_local, vz_local) {

	    var v_world = _vec3_tmp;
	    vector_to_world(obj, vx_local, vy_local, vz_local, v_world);

	    var body_id = obj.physics.body_id;
	    /*
	    var bt_velocity = bt_body.getLinearVelocity();

	    var vx0 = bt_velocity.x();
	    var vy0 = bt_velocity.y();
	    var vz0 = bt_velocity.z();
	    */

	    var vx0 = 0;
	    var vy0 = 0;
	    var vz0 = 0;

	    var vx0a = Math.abs(vx0);
	    var vy0a = Math.abs(vy0);
	    var vz0a = Math.abs(vz0);

	    var vxa = Math.abs(v_world[0]);
	    var vya = Math.abs(v_world[1]);
	    var vza = Math.abs(v_world[2]);

	    // SIGN * ABS_VEL_CLAMPED
	    v_world[0] = vxa ? (v_world[0] / vxa) * Math.max(vxa, vx0a) : vx0;
	    v_world[1] = vya ? (v_world[1] / vya) * Math.max(vya, vy0a) : vy0;
	    v_world[2] = vza ? (v_world[2] / vza) * Math.max(vza, vz0a) : vz0;

	    var worker = find_worker_by_body_id(body_id);
	    m_ipc.post_msg(worker, m_ipc.OUT_SET_LINEAR_VELOCITY, body_id, v_world[0], v_world[1], v_world[2]);
	};

	/**
	 * Move the object by applying velocity in the world space.
	 * TODO: rename apply_velocity -> apply_velocity_local
	 */
	exports.apply_velocity_world = function(obj, vx, vy, vz) {

	    var body_id = obj.physics.body_id;

	    var worker = find_worker_by_body_id(body_id);
	    m_ipc.post_msg(worker, m_ipc.OUT_SET_LINEAR_VELOCITY, body_id, vx, vy, vz);
	};

	function vector_to_world(obj, vx_local, vy_local, vz_local, dest) {

	    var v = dest || new Float32Array(3);

	    var quat = m_tsr.get_quat_view(obj.render.world_tsr);

	    v[0] = vx_local;
	    v[1] = vy_local;
	    v[2] = vz_local;
	    var v_world = m_vec3.transformQuat(v, quat, v);

	    return v_world;
	}

	/**
	 * Move the object by applying the force in the world space.
	 */
	exports.apply_force = apply_force;
	function apply_force(obj, fx_local, fy_local, fz_local, use_world) {

	    var f_world = _vec3_tmp;
	    if (use_world) {
	        f_world[0] = fx_local;
	        f_world[1] = fy_local;
	        f_world[2] = fz_local;
	    } else
	        vector_to_world(obj, fx_local, fy_local, fz_local, f_world);

	    var body_id = obj.physics.body_id;

	    var worker = find_worker_by_body_id(body_id);
	    m_ipc.post_msg(worker, m_ipc.OUT_APPLY_CENTRAL_FORCE, body_id,
	            f_world[0], f_world[1], f_world[2]);
	}

	/**
	 * Rotate the object by applying torque in the world space.
	 * @param tx_local Tx local space torque
	 * @param ty_local Ty local space torque
	 * @param tz_local Tz local space torque
	 */
	exports.apply_torque = apply_torque;
	function apply_torque(obj, tx_local, ty_local, tz_local) {

	    var t_world = _vec3_tmp;
	    vector_to_world(obj, tx_local, ty_local, tz_local, t_world);

	    var body_id = obj.physics.body_id;
	    var worker = find_worker_by_body_id(body_id);
	    m_ipc.post_msg(worker, m_ipc.OUT_APPLY_TORQUE, body_id, t_world[0], t_world[1], t_world[2]);
	}

	exports.set_angular_velocity = function(obj, av_x, av_y, av_z) {
	    var body_id = obj.physics.body_id;
	    var worker = find_worker_by_body_id(body_id);
	    m_ipc.post_msg(worker, m_ipc.OUT_SET_ANGULAR_VELOCITY, body_id, av_x, av_y, av_z);
	};

	/**
	 * Set character moving direction (may be zero vector).
	 * @param forw Apply forward move (may be negative)
	 * @param side Apply side move (may be negative)
	 */
	exports.set_character_move_dir = function(obj, forw, side) {
	    var body_id = obj.physics.body_id;
	    var worker = find_worker_by_body_id(body_id);
	    m_ipc.post_msg(worker, m_ipc.OUT_SET_CHARACTER_MOVE_DIR, body_id, forw, side);
	};

	/**
	 * Set character moving type.
	 * @param type Character moving type
	 */
	exports.set_character_move_type = function(obj, type) {
	    var body_id = obj.physics.body_id;
	    var worker = find_worker_by_body_id(body_id);
	    m_ipc.post_msg(worker, m_ipc.OUT_SET_CHARACTER_MOVE_TYPE, body_id, type);
	};

	/**
	 * Set character walk speed.
	 * @param velocity Walking velocity
	 */
	exports.set_character_walk_velocity = function(obj, velocity) {
	    var body_id = obj.physics.body_id;
	    var worker = find_worker_by_body_id(body_id);
	    m_ipc.post_msg(worker, m_ipc.OUT_SET_CHARACTER_WALK_VELOCITY, body_id, velocity);
	};

	/**
	 * Set character run speed.
	 * @param velocity Running velocity
	 */
	exports.set_character_run_velocity = function(obj, velocity) {
	    var body_id = obj.physics.body_id;
	    var worker = find_worker_by_body_id(body_id);
	    m_ipc.post_msg(worker, m_ipc.OUT_SET_CHARACTER_RUN_VELOCITY, body_id, velocity);
	};

	/**
	 * Set character fly speed.
	 * @param velocity Flying velocity
	 */
	exports.set_character_fly_velocity = function(obj, velocity) {
	    var body_id = obj.physics.body_id;
	    var worker = find_worker_by_body_id(body_id);
	    m_ipc.post_msg(worker, m_ipc.OUT_SET_CHARACTER_FLY_VELOCITY, body_id, velocity);
	};

	/**
	 * Perform a character's jump
	 */
	exports.character_jump = function(obj) {
	    var body_id = obj.physics.body_id;
	    var worker = find_worker_by_body_id(body_id);
	    m_ipc.post_msg(worker, m_ipc.OUT_CHARACTER_JUMP, body_id);
	};

	/**
	 * Increment character's rotation
	 */
	exports.character_rotation_inc = function(obj, h_angle, v_angle) {
	    var body_id = obj.physics.body_id;
	    var worker = find_worker_by_body_id(body_id);
	    m_ipc.post_msg(worker, m_ipc.OUT_CHARACTER_ROTATION_INCREMENT, body_id, h_angle, v_angle);
	};

	/**
	 * Set character's rotation in both planes
	 */
	exports.set_character_rotation = function(obj, angle_h, angle_v) {
	    var body_id = obj.physics.body_id;
	    var worker = find_worker_by_body_id(body_id);
	    m_ipc.post_msg(worker, m_ipc.OUT_SET_CHARACTER_ROTATION, body_id, angle_h, angle_v);
	};

	/**
	 * Set character's horizontal rotation
	 */
	exports.set_character_rotation_h = function(obj, angle) {
	    var body_id = obj.physics.body_id;
	    var worker = find_worker_by_body_id(body_id);
	    m_ipc.post_msg(worker, m_ipc.OUT_SET_CHARACTER_HOR_ROTATION, body_id, angle);
	};

	/**
	 * Set character's vertical rotation
	 */
	exports.set_character_rotation_v = function(obj, angle) {
	    var body_id = obj.physics.body_id;
	    var worker = find_worker_by_body_id(body_id);
	    m_ipc.post_msg(worker, m_ipc.OUT_SET_CHARACTER_VERT_ROTATION, body_id, angle);
	};

	exports.set_character_vert_move_dir_angle = function(obj, angle) {
	    var body_id = obj.physics.body_id;
	    var worker = find_worker_by_body_id(body_id);
	    m_ipc.post_msg(worker, m_ipc.OUT_SET_CHARACTER_VERT_MOVE_DIR_ANGLE, body_id, angle);
	};

	exports.append_collision_test = function(obj_src, collision_id, callback,
	                                         calc_pos_norm) {
	    var phy = obj_src.physics;
	    if (phy.navmesh)
	        return;

	    var body_id_src = phy.body_id;

	    // no need to add another collision test
	    for (var i = 0; i < phy.collision_tests.length; i++) {
	        var test = phy.collision_tests[i];
	        if (test.collision_id == collision_id && test.callback == callback)
	            return;
	    }

	    var test = {
	        body_id_src: body_id_src,
	        calc_pos_norm: calc_pos_norm || false,
	        collision_id: collision_id,
	        callback: callback,
	        pairs: [],
	        pair_results: []
	    };
	    phy.collision_tests.push(test);

	    var worker = find_worker_by_body_id(body_id_src);
	    var scene = find_scene_by_worker(worker);

	    append_collision_pairs(test, scene, worker);
	};

	/**
	 * NOTE: function doesn't count the pairs already appended by other tests
	 */
	function append_collision_pairs(test, scene, worker) {
	    var pairs = test.pairs;
	    var pair_results = test.pair_results;

	    var body_id_a = test.body_id_src;
	    var body_id_b_arr = [];

	    collision_id_to_body_ids(test.collision_id, scene,
	            body_id_b_arr, null);

	    for (var i = 0; i < body_id_b_arr.length; i++) {
	        var body_id_b = body_id_b_arr[i];

	        // sorted pairs, but comparison does not have any special meaning
	        if (body_id_a < body_id_b && !has_pair(pairs, body_id_a, body_id_b)) {
	            pairs.push([body_id_a, body_id_b]);
	            pair_results.push(false);
	        } else if (body_id_a > body_id_b && !has_pair(pairs, body_id_b, body_id_a)) {
	            pairs.push([body_id_b, body_id_a]);
	            pair_results.push(false);
	        }
	        // == ignored
	    }

	    // NOTE: unknown issues with freezed objects
	    m_ipc.post_msg(worker, m_ipc.OUT_ACTIVATE, body_id_a);
	    m_ipc.post_msg(worker, m_ipc.OUT_APPEND_COLLISION_TEST, pairs, test.calc_pos_norm);
	}

	function has_pair(pairs, body_id_a, body_id_b) {
	    for (var i = 0; i < pairs.length; i++)
	        if (pairs[i][0] == body_id_a && pairs[i][1] == body_id_b)
	            return true;

	    return false;
	}

	/**
	 * Find unique body ids
	 */
	exports.remove_collision_test = function(obj, collision_id, callback) {
	    var phy = obj.physics;
	    var body_id = phy.body_id;

	    var worker = find_worker_by_body_id(body_id);
	    var scene = find_scene_by_worker(worker);

	    for (var i = 0; i < phy.collision_tests.length; i++) {
	        var test = phy.collision_tests[i];
	        if (test.collision_id == collision_id && test.callback == callback) {

	            // report negative collision result as there is no collision anymore
	            if (calc_coll_result(test)) {
	                var zero = m_vec3.set(0, 0, 0, _vec3_tmp);
	                test.callback(false, null, zero, zero, 0);
	            }

	            phy.collision_tests.splice(i, 1);

	            i--;

	            remove_unused_collision_pairs(scene, worker, test.pairs);
	        }
	    }
	};



	/**
	 * Find from pairs unused and remove
	 */
	function remove_unused_collision_pairs(scene, worker, pairs) {

	    var bundles = scene._physics.bundles;

	    var unused_pairs = pairs;   // by link

	    for (var i = 0; i < bundles.length; i++) {
	        var phy = bundles[i].physics;

	        for (var j = 0; j < phy.collision_tests.length; j++) {
	            var test = phy.collision_tests[j];

	            for (var k = 0; k < test.pairs.length; k++) {
	                var pair = test.pairs[k];

	                for (var l = 0; l < unused_pairs.length; l++) {
	                    var unused_pair = unused_pairs[l];

	                    if (pair[0] == unused_pair[0] && pair[1] == unused_pair[1]) {
	                        // have found used one
	                        unused_pairs.splice(l, 1);
	                        l--;
	                    }
	                }
	            }
	        }
	    }

	    if (unused_pairs.length)
	        m_ipc.post_msg(worker, m_ipc.OUT_REMOVE_COLLISION_TEST, unused_pairs);
	}

	function remove_collision_pairs_by_id(scene, worker, body_id) {
	    var bundles = scene._physics.bundles;

	    var removed_pairs = [];

	    for (var i = 0; i < bundles.length; i++) {
	        var phy = bundles[i].physics;

	        for (var j = 0; j < phy.collision_tests.length; j++) {
	            var test = phy.collision_tests[j];

	            for (var k = 0; k < test.pairs.length; k++) {
	                var pair = test.pairs[k];
	                var pair_result = test.pair_results[k];

	                if (pair[0] == body_id || pair[1] == body_id) {

	                    test.pairs.splice(k, 1);
	                    test.pair_results.splice(k, 1);
	                    k--;

	                    // last positive pair removed
	                    if (pair_result && !calc_coll_result(test)) {
	                        var zero = m_vec3.set(0, 0, 0, _vec3_tmp);
	                        test.callback(false, null, zero, zero, 0);
	                    }

	                    // do not check for uniqueness, uranium allows that
	                    removed_pairs.push(pair);
	                }
	            }
	        }
	    }

	    if (removed_pairs.length)
	        m_ipc.post_msg(worker, m_ipc.OUT_REMOVE_COLLISION_TEST, removed_pairs);
	}

	exports.apply_collision_impulse_test = function(obj, callback) {
	    if (has_collision_impulse_test(obj))
	        clear_collision_impulse_test(obj);

	    var phy = obj.physics;
	    var worker = find_worker_by_body_id(phy.body_id);
	    m_ipc.post_msg(worker, m_ipc.OUT_APPLY_COLLISION_IMPULSE_TEST, phy.body_id);
	    phy.col_imp_test_cb = callback;
	};

	exports.clear_collision_impulse_test = clear_collision_impulse_test;
	function clear_collision_impulse_test(obj) {
	    if (!has_collision_impulse_test(obj))
	        return;

	    var phy = obj.physics;
	    var worker = find_worker_by_body_id(phy.body_id);
	    m_ipc.post_msg(worker, m_ipc.OUT_CLEAR_COLLISION_IMPULSE_TEST, phy.body_id);
	    phy.col_imp_test_cb = null;
	}

	function has_collision_impulse_test(obj) {
	    if (obj.physics && obj.physics.col_imp_test_cb)
	        return true;
	    else
	        return false;
	}

	exports.append_ray_test = function(obj, from, to, collision_id, callback,
	        autoremove, calc_all_hits, calc_pos_norm, ign_src_rot) {

	    var id = get_unique_ray_test_id();

	    var test = {
	        id: id,
	        body_id: obj ? obj.physics.body_id : 0,
	        from: new Float32Array(from),
	        to: new Float32Array(to),
	        collision_id: collision_id,
	        collision_id_num: col_id_num(collision_id),
	        autoremove: autoremove,
	        calc_all_hits: calc_all_hits,
	        calc_pos_norm: calc_pos_norm,
	        ign_src_rot: ign_src_rot,
	        callback: callback
	    };

	    // NOTE: it's not possible to determine the worker in no obj specified
	    var worker = find_worker_by_body_id(test.body_id) || _workers[0];
	    var scene = find_scene_by_worker(worker);

	    var sphy = scene._physics;

	    sphy.ray_tests[id] = test;
	    sphy.ray_tests_arr.push(test);

	    m_ipc.post_msg(worker, m_ipc.OUT_APPEND_RAY_TEST, test.id, test.body_id, test.from,
	            test.to, test.collision_id_num, test.autoremove,
	            test.calc_all_hits, test.calc_pos_norm, test.ign_src_rot);

	    return id;
	};

	function get_unique_ray_test_id() {
	    _unique_counter.ray_test++;
	    return _unique_counter.ray_test;
	}

	/**
	 * Find and store body id matching given collision id
	 * @param [dest_arr] Destination array
	 * @param [dest_obj] Destination object with body_id keys and zero values
	 */
	function collision_id_to_body_ids(collision_id, bpy_scene, dest_arr, dest_obj) {

	    if (!dest_arr && !dest_obj)
	        m_util.panic("At least one destination required");

	    for (var i = 0; i < bpy_scene._physics.bundles.length; i++) {
	        var bundle = bpy_scene._physics.bundles[i];
	        if (collision_id == "ANY" || bundle.physics.collision_id == collision_id
	            && bundle.physics.type != "NAVMESH") {
	            var body_id = bundle.physics.body_id;

	            // unique
	            if (dest_arr && dest_arr.indexOf(body_id) == -1)
	                dest_arr.push(body_id);

	            if (dest_obj)
	                dest_obj[body_id] = 0;
	        }
	    }
	}

	exports.remove_ray_test = remove_ray_test;
	function remove_ray_test(id) {

	    var scene = find_scene_by_ray_test_id(id);
	    var worker = find_worker_by_ray_test_id(id);

	    var sphy = scene._physics;

	    if (sphy.ray_tests[id]) {

	        delete sphy.ray_tests[id];
	        sphy.ray_tests_arr.splice(sphy.ray_tests_arr.indexOf, 1);
	        m_ipc.post_msg(worker, m_ipc.OUT_REMOVE_RAY_TEST, id);
	    }
	}

	exports.change_ray_test_from_to = function(id, from, to) {
	    var scene = find_scene_by_ray_test_id(id);
	    var worker = find_worker_by_ray_test_id(id);

	    var sphy = scene._physics;

	    var test = sphy.ray_tests[id];

	    if (test && !test.autoremove) {
	        test.from.set(from);
	        test.to.set(to);
	        m_ipc.post_msg(worker, m_ipc.OUT_CHANGE_RAY_TEST_FROM_TO, id, from, to);
	    }
	};

	exports.is_ray_test = function(id) {
	    var scene = find_scene_by_ray_test_id(id);

	    var sphy = scene._physics;

	    if (sphy.ray_tests[id])
	        return true;
	    else
	        return false;
	};

	function find_scene_by_ray_test_id(id) {
	    for (var i = 0; i < _scenes.length; i++) {
	        var scene = _scenes[i];
	        var sphy = scene._physics;

	        if (sphy.ray_tests[id])
	            return scene;
	    }

	    return null;
	}

	function find_worker_by_ray_test_id(id) {
	    for (var i = 0; i < _scenes.length; i++) {
	        var scene = _scenes[i];
	        var sphy = scene._physics;

	        if (sphy.ray_tests[id])
	            return _workers[i];
	    }

	    return null;
	}

	exports.vehicle_throttle = function(obj, engine_force) {
	    var vehicle = obj.vehicle;

	    vehicle.engine_force = engine_force;

	    var worker = find_worker_by_body_id(obj.physics.body_id);
	    update_vehicle_controls(obj, vehicle, worker);
	};

	function update_vehicle_controls(obj, vehicle, worker) {
	    if (!vehicle.steering_wheel)
	        return;

	    var body_id = obj.physics.body_id;
	    var engine_force = vehicle.engine_force * vehicle.force_max;
	    var brake_force = vehicle.brake_force * vehicle.brake_max;
	    var steering = -vehicle.steering * vehicle.steering_max * 2 * Math.PI /
	        vehicle.steering_ratio;
	    if (vehicle.inverse_control)
	        steering *= -1;

	    switch (vehicle.type) {
	    case VT_CHASSIS:
	        // convert to radians using steering ratio and inverse
	        m_ipc.post_msg(worker, m_ipc.OUT_UPDATE_CAR_CONTROLS, body_id, engine_force,
	                brake_force, steering);
	        break;
	    case VT_HULL:
	        m_ipc.post_msg(worker, m_ipc.OUT_UPDATE_BOAT_CONTROLS, body_id, engine_force,
	                brake_force, steering);
	        break;
	    }
	}

	exports.vehicle_steer = function(obj, steering_value) {
	    var vehicle = obj.vehicle;

	    vehicle.steering = steering_value;

	    var worker = find_worker_by_body_id(obj.physics.body_id);
	    update_vehicle_controls(obj, vehicle, worker);
	};

	exports.vehicle_brake = function(obj, brake_force) {
	    var vehicle = obj.vehicle;

	    vehicle.brake_force = brake_force;

	    var worker = find_worker_by_body_id(obj.physics.body_id);
	    update_vehicle_controls(obj, vehicle, worker);
	};

	function update_steering_wheel_coords(obj_chassis) {

	    var vehicle = obj_chassis.vehicle;
	    var stw_obj = vehicle.steering_wheel;
	    if (!stw_obj)
	        return;

	    var stw_tsr = obj_chassis.vehicle.steering_wheel_tsr;
	    var stw_axis = obj_chassis.vehicle.steering_wheel_axis;

	    m_tsr.multiply(obj_chassis.render.world_tsr, stw_tsr, stw_obj.render.world_tsr);

	    var stw_axis_world = _vec3_tmp;
	    m_tsr.transform_dir_vec3(stw_axis, obj_chassis.render.world_tsr, stw_axis_world);

	    var rotation = _quat_tmp;
	    m_quat.setAxisAngle(stw_axis_world, -vehicle.steering *
	            vehicle.steering_max * 2 * Math.PI, rotation);

	    var stw_obj_quat = m_tsr.get_quat_view(stw_obj.render.world_tsr);
	    m_quat.multiply(rotation, stw_obj_quat, stw_obj_quat);

	    m_trans.update_transform(stw_obj);
	}


	function update_speedometer(obj_chassis) {

	    var vehicle = obj_chassis.vehicle;
	    var sp_obj = vehicle.speedometer;

	    if (!sp_obj)
	        return;

	    var sp_tsr = obj_chassis.vehicle.speedometer_tsr;
	    var sp_axis = obj_chassis.vehicle.speedometer_axis;

	    m_tsr.multiply(obj_chassis.render.world_tsr, sp_tsr, sp_obj.render.world_tsr);

	    var sp_axis_world = _vec3_tmp;
	    m_tsr.transform_dir_vec3(sp_axis, obj_chassis.render.world_tsr, sp_axis_world);

	    var rotation = _quat_tmp;
	    var angle = Math.abs(vehicle.speed) * vehicle.speed_ratio;

	    if (angle > vehicle.max_speed_angle)
	        angle = vehicle.max_speed_angle;

	    m_quat.setAxisAngle(sp_axis_world, -angle, rotation);

	    var sp_obj_quat = m_tsr.get_quat_view(sp_obj.render.world_tsr);
	    m_quat.multiply(rotation, sp_obj_quat, sp_obj_quat);
	    m_quat.normalize(sp_obj_quat, sp_obj_quat);

	    m_trans.update_transform(sp_obj);
	}

	function update_tachometer(obj_chassis) {

	    var vehicle = obj_chassis.vehicle;
	    var tach_obj = vehicle.tachometer;

	    if (!tach_obj)
	        return;

	    var tach_tsr = obj_chassis.vehicle.tachometer_tsr;
	    var tach_axis = obj_chassis.vehicle.tachometer_axis;

	    m_tsr.multiply(obj_chassis.render.world_tsr, tach_tsr, tach_obj.render.world_tsr);

	    var tach_axis_world = _vec3_tmp;
	    m_tsr.transform_dir_vec3(tach_axis, obj_chassis.render.world_tsr, tach_axis_world);

	    var rotation = _quat_tmp;

	    m_quat.setAxisAngle(tach_axis_world, -Math.abs(vehicle.engine_force) *
	            vehicle.delta_tach_angle, rotation);

	    var tach_obj_quat = m_tsr.get_quat_view(tach_obj.render.world_tsr);
	    m_quat.multiply(rotation, tach_obj_quat, tach_obj_quat);
	    m_quat.normalize(tach_obj_quat, tach_obj_quat);

	    m_trans.update_transform(tach_obj);
	}

	exports.is_vehicle_chassis = is_vehicle_chassis;
	function is_vehicle_chassis(obj) {
	    return obj.is_vehicle && obj.vehicle_settings.part == "CHASSIS";
	}

	exports.is_vehicle_hull = is_vehicle_hull;
	function is_vehicle_hull(obj) {
	    return obj.is_vehicle && obj.vehicle_settings.part == "HULL";
	}

	exports.is_navigation_mesh = is_navigation_mesh;
	function is_navigation_mesh(obj) {
	    return obj.physics_settings.physics_type == "NAVMESH";
	}

	exports.is_car_wheel = function(obj) {
	    if (!obj.is_vehicle)
	        return false;

	    var part = obj.vehicle_settings.part;

	    if (part == "WHEEL_FRONT_LEFT" || part == "WHEEL_FRONT_RIGHT" ||
	            part == "WHEEL_BACK_LEFT" || part == "WHEEL_BACK_RIGHT")
	        return true;
	    else
	        return false;
	};

	exports.is_boat_bob = function(obj) {
	    if (!obj.is_vehicle)
	        return false;

	    var part = obj.vehicle_settings.part;

	    if (part == "BOB")
	        return true;
	    else
	        return false;
	};

	exports.is_floater_bob = function(obj) {
	    if (!obj.is_floating)
	        return false;

	    var part = obj.floating_settings.part;

	    if (part == "BOB")
	        return true;
	    else
	        return false;
	};

	exports.is_vehicle_steering_wheel = function(obj) {
	    if (obj.is_vehicle && obj.vehicle_settings.part == "STEERING_WHEEL")
	        return true;
	    else
	        return false;
	};

	exports.is_vehicle_speedometer = function(obj) {
	    if (obj.is_vehicle && obj.vehicle_settings.part == "SPEEDOMETER")
	        return true;
	    else
	        return false;
	};

	exports.is_vehicle_tachometer = function(obj) {
	    if (obj.is_vehicle && obj.vehicle_settings.part == "TACHOMETER")
	        return true;
	    else
	        return false;
	};

	exports.get_vehicle_speed = function(obj) {
	    var vehicle = obj.vehicle;
	    return vehicle.speed;
	};

	exports.wheel_index = function(vehicle_part) {
	    /* 1 --- 0
	     * 2 --- 3 */
	    switch (vehicle_part) {
	    case "WHEEL_FRONT_RIGHT":
	        return 0;
	    case "WHEEL_FRONT_LEFT":
	        return 1;
	    case "WHEEL_BACK_LEFT":
	        return 2;
	    case "WHEEL_BACK_RIGHT":
	        return 3;
	    }
	};

	exports.has_character_physics = function(obj) {
	    return obj.physics && obj.physics.is_character;
	};

	exports.is_floater_main = is_floater_main;
	function is_floater_main(obj) {
	    return obj.is_floating && obj.floating_settings.part == "MAIN_BODY";
	}

	exports.get_fps = function() {
	    return _phy_fps;
	};

	exports.debug_workers = function() {
	    for (var i = 0; i < _workers.length; i++) {
	        var worker = _workers[i];
	        m_ipc.post_msg(worker, m_ipc.OUT_DEBUG);
	    }
	};

	exports.remove_object = function(obj) {

	    var body_id = obj.physics.body_id;

	    if (obj.physics.type == "BOUNDING") {
	        var ind = _bounding_objects_arr.indexOf(obj);
	        if (ind == -1)
	            m_print.error("Object " + obj.name + " doesn't have bounding physics");
	        delete _bounding_objects[body_id];
	        _bounding_objects_arr.splice(ind, 1);
	    }

	    var worker = find_worker_by_body_id(body_id);
	    var scene = find_scene_by_worker(worker);

	    remove_collision_pairs_by_id(scene, worker, body_id);

	    if (has_collision_impulse_test(obj))
	        clear_collision_impulse_test(obj);

	    var bundles = scene._physics.bundles;

	    for (var i = 0; i < bundles.length; i++) {
	        var phy = bundles[i].physics;

	        if (phy.body_id == body_id) {
	            bundles.splice(i, 1);
	            i--;
	        }
	    }

	    m_ipc.post_msg(worker, m_ipc.OUT_REMOVE_BODY, body_id);
	};

	exports.has_dynamic_settings = function(obj) {
	    var phy_set = obj.physics_settings;

	    return (obj.is_vehicle || obj.is_floating || obj.is_character) ||
	           (obj.use_obj_physics && !phy_set.use_ghost && phy_set.mass > 0 &&
	           (phy_set.physics_type == "DYNAMIC" || phy_set.physics_type == "RIGID_BODY"));
	};

	}

	var int_physics_factory = register("__physics", Int_physics);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Curve internal API.
	 * Currently only NURBS (blender path curves) supported.
	 * @name curve
	 * @namespace
	 * @exports exports as curve
	 */
	function Int_curve(ns, exports) {

	var m_util  = int_util_factory(ns);
	var m_vec3  = vec3_factory(ns);

	var SPLINE_POINTS = 1000;

	/**
	 * Create spline object to apply curve modifier
	 */
	exports.create_spline = function(bpy_obj) {
	    var spline = {};

	    var bpy_curve = bpy_obj["data"];

	    // NOTE: only single endpoint (path) NURBS supported
	    var bpy_spline = bpy_curve["splines"][0];
	    if (!(bpy_spline && bpy_spline["type"] == "NURBS" && 
	                bpy_spline["use_endpoint_u"]))
	        return null;

	    var order = bpy_spline["order_u"];
	    spline.order = order;

	    var points = bpy_spline["points"];

	    var knot = gen_open_knot(points.length/5, order, []);
	    spline.knot = knot;

	    if (bpy_curve["dimensions"] == "2D")
	        spline.is_3d = false;
	    else if (bpy_curve["dimensions"] == "3D")
	        spline.is_3d = true;
	    else
	        m_util.panic("Wrong curve dimensions");

	    var cpoints = [];
	    var weights = [];

	    for (var i = 0; i < points.length; i+=5) {
	        cpoints.push(points[i]);    // x
	        cpoints.push(points[i+1]);  // y
	        cpoints.push(points[i+2]);  // z
	        if (spline.is_3d)
	            cpoints.push(points[i+3]);  // tilt
	        weights.push(points[i+4]);
	    }

	    spline.cpoints = cpoints;
	    spline.weights = weights;

	    // render spline to calculate cumulative length of segments
	    // required for length--->t translation
	    points = spline_points(spline, SPLINE_POINTS, []);
	    var ncoords = spline.is_3d ? 4 : 3;

	    var clen = new Float32Array(SPLINE_POINTS);
	    clen[0] = 0;

	    for (var i = 1; i < SPLINE_POINTS; i+=1) {
	        var x0 = points[(i-1) * ncoords];
	        var y0 = points[(i-1) * ncoords + 1];
	        var z0 = points[(i-1) * ncoords + 2];

	        var x = points[i * ncoords];
	        var y = points[i * ncoords + 1];
	        var z = points[i * ncoords + 2];

	        var len = Math.sqrt((x-x0)*(x-x0) + (y-y0)*(y-y0) + (z-z0)*(z-z0));
	        clen[i] = clen[i-1] + len;
	    }
	    spline.cumulative_length = clen;

	    return spline;
	};

	/**
	 * Generate B-spline open knot vector.
	 * @param n Number of control points
	 * @param order Order of basis function
	 * @param [dest] Destination vector
	 */
	function gen_open_knot(n, order, dest) {
	    if (!dest)
	        dest = [];

	    var nplusorder = n + order;
	    var nplus2 = n + 2;

	    dest[0] = 0;

	    for (var i = 2; i <= nplusorder; i++) {
	        if ((i > order) && (i < nplus2))
	            dest[i-1] = dest[i-2] + 1;
	        else
	            dest[i-1] = dest[i-2];
	    }

	    return dest;
	}

	/**
	 * Generate a B-spline periodic uniform knot vector.
	 * @param n Number of control points
	 * @param order Order of basis function
	 * @param [dest] Destination vector
	 */
	function gen_rational_basis(order, t, knot, weights, r) {

	    var n = weights.length;

	    if (!r)
	        r = new Float32Array(n);

	    var nplusorder = n + order;

	    // calculate the first order nonrational basis functions Ni,1
	    var temp = new Float32Array(nplusorder);

	    for (var i = 1; i <= nplusorder-1; i++) {
	        if ((t >= knot[i-1]) && (t < knot[i+1-1]))
	            temp[i-1] = 1;
	        else
	            temp[i-1] = 0;
	    }

	    // calculate the higher order nonrational basis functions
	    for (var k = 2; k <= order; k++) {
	        for (var i = 1; i <= nplusorder-k; i++) {
	            // if the lower order basis function is zero skip the calculation
	            if (temp[i-1] != 0)
	                var d = ((t - knot[i-1]) * temp[i-1]) / (knot[i+k-1-1]-knot[i-1]);
	            else
	                var d = 0;

	            // if the lower order basis function is zero skip the calculation
	            if (temp[i+1-1] != 0)
	                var e = ((knot[i+k-1] - t) * temp[i+1-1]) / (knot[i+k-1] - knot[i+1-1]);
	            else
	                var e = 0;

	            temp[i-1] = d + e;
	        }
	    }

	    // pick up last point
	    if (t == knot[nplusorder-1])
	        temp[n-1] = 1;

	    // calculate sum for denominator of rational basis functions
	    var sum = 0.0;
	    for (var i = 1; i <= n; i++)
	        sum = sum + temp[i-1] * weights[i-1];

	    // form rational basis functions and put in r vector
	    for (var i = 1; i <= n; i++) {
	        if (sum != 0)
	            r[i-1] = (temp[i-1] * weights[i-1]) / sum;
	        else
	            r[i-1] = 0;
	    }

	    return r;
	}

	/**
	 * Calc derivatives of rational basis functions
	 */
	function gen_rational_dbasis(order, t, knot, weights, rd) {
	    
	    var num = weights.length;

	    if (!rd)
	        rd = new Float32Array(num);

	    var n = new Float32Array(num);
	    var d = new Float32Array(num);

	    gen_basis_d(num, order, t, knot, n, d);

	    var sum = 0.0;
	    for (var i = 1; i <= num; i++)
	        sum = sum + n[i-1] * weights[i-1];

	    var dsum = 0.0;
	    for (var i = 1; i <= num; i++)
	        dsum = dsum + d[i-1] * weights[i-1];

	    // form derivatives of rational basis functions
	    for (var i = 1; i <= num; i++) {
	        if (sum != 0) {
	            var rd1 = (d[i-1] * weights[i-1]) / sum;
	            var rd2 = (n[i-1] * weights[i-1] * dsum) / (sum * sum);
	                
	            rd[i-1] = rd1 + rd2;
	        } else
	            rd[i-1] = 0;
	    }

	    return rd;
	}

	/**
	 * Calc non-rational b-spline basis functions and their derivatives
	 */
	function gen_basis_d(num, order, t, knot, n, d) {

	    if (!n)
	        n = new Float32Array(num);
	    if (!d)
	        d = new Float32Array(num);

	    var nplusorder = num + order;

	    // initialized by zero values
	    var temp = new Float32Array(nplusorder);
	    var tempd = new Float32Array(nplusorder);

	    // calculate the first order basis functions Ni,1

	    for (var i = 1; i <= nplusorder-1; i++) {
	        if ((t >= knot[i-1]) && (t < knot[i+1-1]))
	            temp[i-1] = 1;
	        else
	            temp[i-1] = 0;
	    }

	    // pick up last point
	    if (t == knot[nplusorder-1])
	        temp[num-1] = 1;

	    // calculate the higher order basis functions

	    for (var k = 2; k <= order; k++) {
	        for (var i = 1; i <= nplusorder-k; i++) {
	            if (temp[i-1] != 0)
	                var b1 = ((t-knot[i-1])*temp[i-1])/(knot[i+k-1-1]-knot[i-1]);
	            else
	                var b1 = 0;

	            if (temp[i+1-1] != 0)     
	                var b2 = ((knot[i+k-1]-t)*temp[i+1-1])/(knot[i+k-1]-knot[i+1-1]);
	            else
	                var b2 = 0;

	            // first derivative
	            if (temp[i-1] != 0)       
	                var f1 = temp[i-1]/(knot[i+k-1-1]-knot[i-1]);
	            else
	                var f1 = 0;

	            if (temp[i+1-1] != 0)
	                var f2 = -temp[i+1-1]/(knot[i+k-1]-knot[i+1-1]);
	            else
	                var f2 = 0;

	            if (tempd[i-1] != 0)
	                var f3 = ((t-knot[i-1])*tempd[i-1])/(knot[i+k-1-1]-knot[i-1]);
	            else
	                var f3 = 0;

	            if (tempd[i+1-1] != 0)
	                var f4 = ((knot[i+k-1]-t)*tempd[i+1-1])/(knot[i+k-1]-knot[i+1-1]);
	            else
	                var f4 = 0;


	            temp[i-1] = b1 + b2;
	            tempd[i-1] = f1 + f2 + f3 + f4;
	        }
	    }

	    for (var i = 1; i <= num; i++) {
	        n[i-1] = temp[i-1];
	        d[i-1] = tempd[i-1];
	    }

	    return n;
	}



	/**
	 * Requires open knot vector
	 */
	function spline_points(spline, num, dest) {

	    if (!dest)
	        dest = [];

	    var cpoints = spline.cpoints;
	    var ncoords = spline.is_3d ? 4 : 3;
	    var weights = spline.weights;
	    var knot = spline.knot;
	    var order = spline.order;

	    var n = cpoints.length / ncoords;
	    var nplusorder = n + order;

	    // calculate the points on the rational B-spline curve

	    var t = 0;
	    var step = knot[nplusorder-1] / (num-1);

	    for (var i = 0; i < num; i++) {

	        if (knot[nplusorder - 1] - t < 5e-6)
	            t = knot[nplusorder-1];

	        // generate the basis function for this value of t
	        var basis = gen_rational_basis(order, t, knot, weights);

	        // generate a point on the curve
	        for (var j = 0; j < ncoords; j++) {

	            dest[ncoords*i + j] = 0.0;

	            // do local matrix multiplication
	            for (var k = 0; k < n; k++) {
	                var temp = basis[k] * cpoints[ncoords*k + j];
	                dest[ncoords*i + j] += temp;
	            }
	        }

	        t = t + step;
	    }

	    return dest;
	}

	/**
	 * Generate single spline point, located at given t.
	 * @param spline Spline object
	 * @param t Spline parameter
	 * @param [dest] Destination vector
	 */
	exports.spline_point = function(spline, t, dest) {
	    if (!dest)
	        dest = [];

	    t = clamped_t(spline, t);

	    var cpoints = spline.cpoints;
	    var ncoords = spline.is_3d ? 4 : 3;
	    var weights = spline.weights;
	    var knot = spline.knot;
	    var order = spline.order;

	    var n = cpoints.length / ncoords;
	    var nplusorder = n + order;

	    if (knot[nplusorder - 1] - t < 5e-6)
	        t = knot[nplusorder-1];

	    var basis = new Float32Array(n);
	    gen_rational_basis(order, t, knot, weights, basis);

	    for (var i = 0; i < ncoords; i++) {

	        dest[i] = 0.0;

	        for (var j = 0; j < n; j++)
	            dest[i] += basis[j] * cpoints[ncoords*j + i];
	    }

	    return dest;
	};

	function clamped_t(spline, t) {
	    var t_clamped = Math.max(t, 0.0);

	    var max_t = spline_max_t(spline);
	    t_clamped = Math.min(t, max_t);

	    return t_clamped;
	}

	/**
	 * Generate single spline derivative, located at given t.
	 * @param spline Spline object
	 * @param t Spline parameter
	 * @param [dest] Destination vector
	 */
	exports.spline_derivative = function(spline, t, dest) {
	    if (!dest)
	        dest = [];

	    var cpoints = spline.cpoints;
	    var ncoords = spline.is_3d ? 4 : 3;
	    var weights = spline.weights;
	    var knot = spline.knot;
	    var order = spline.order;

	    var n = cpoints.length / ncoords;
	    var nplusorder = n + order;

	    if (knot[nplusorder - 1] - t < 5e-6)
	        t = knot[nplusorder-1];

	    var dbasis = new Float32Array(n);
	    gen_rational_dbasis(order, t, knot, weights, dbasis);

	    for (var i = 0; i < ncoords; i++) {

	        dest[i] = 0.0;

	        for (var j = 0; j < n; j++)
	            dest[i] += dbasis[j] * cpoints[ncoords*j + i];
	    }

	    return dest;
	};

	exports.spline_max_t = spline_max_t;
	/**
	 * Get spline maximum parameter value.
	 * @param spline Spline object
	 */
	function spline_max_t(spline) {
	    var knot = spline.knot;
	    return knot[knot.length - 1];
	}

	exports.spline_length = spline_length;
	/**
	 * Get spline length.
	 * @methodOf curve
	 * @param spline Spline object
	 */
	function spline_length(spline) {
	    var clen = spline.cumulative_length;
	    return clen[clen.length - 1];
	}

	/**
	 * Convert length on the spline to parameter t.
	 * @param spline Spline object
	 * @param len Length along the spline
	 * @returns Clamped t param
	 */
	exports.spline_len_to_t = function(spline, len) {

	    if (len <= 0)
	        return 0;

	    var max_t = spline_max_t(spline);
	    if (len >= spline_length(spline))
	        return max_t; 

	    var clen = spline.cumulative_length;
	    var index = m_util.binary_search_max(clen, len, 0, clen.length-1);

	    // simple linear interpolation
	    var index_float = index + (len - clen[index]) / (clen[index+1] - clen[index]);

	    var t = max_t * index_float / SPLINE_POINTS;
	    return t;
	};

	exports.linear_interpolation = function(y1, x1, y0, x0, x) {
	    return y0 + (x - x0) * (y1 - y0) / (x1 - x0);
	};

	exports.linear = function(x, v1, v4) {
	    var x1 = v1[0], y1 = v1[1],
	        x2 = v4[0], y2 = v4[1];
	    var k = (y2 - y1) / (x2 - x1);
	    var b = y1 - k * x1;
	    return k * x + b;
	};


	exports.bezier = function(x, v1, v2, v3, v4, precision) {

	    // first find parameter t corresponding to x
	    var t = bezier_find_root(0, 1, x, v1[0], v2[0], v3[0], v4[0], precision);

	    // then calc y from t
	    var y = bezier_parametric(t, v1[1], v2[1], v3[1], v4[1]);

	    return y;
	};

	function bezier_find_root(t0_so_far, t1_so_far, x_needed, x0, x1, x2, x3, precision) {

	    // split the interval
	    var t = t0_so_far + (t1_so_far - t0_so_far) / 2;

	    var x = bezier_parametric(t, x0, x1, x2, x3);

	    var dx = x - x_needed;

	    precision = precision? precision : 0.01;

	    if (Math.abs(dx) < precision)
	        return t;

	    if (dx > 0)
	        return bezier_find_root(t0_so_far, t, x_needed, x0, x1, x2, x3, precision);
	    else
	        return bezier_find_root(t, t1_so_far, x_needed, x0, x1, x2, x3, precision);
	}

	function bezier_parametric(t, p0, p1, p2, p3) {
	    var t1 = 1 - t;

	    return p0 * t1 * t1 * t1 +
	       3 * p1 * t1 * t1 * t +
	       3 * p2 * t1 * t  * t +
	           p3 * t  * t  * t;
	}

	exports.calchandle_curvemap = function(bezt, prev, next, h1, h2) {

	    var p1 = new Float32Array(3);
	    var p2 = new Float32Array(3);
	    var p3 = new Float32Array(3);

	    var dvec_a = new Float32Array(3);
	    var dvec_b = new Float32Array(3);

	    var tvec = new Float32Array(3);

	    m_vec3.copy(bezt[1], p2);

	    if (prev == null) {
	        m_vec3.copy(next[1], p3);
	        p1[0] = 2.0 * p2[0] - p3[0];
	        p1[1] = 2.0 * p2[1] - p3[1];
	    } else
	        m_vec3.copy(prev[1], p1);

	    if (next == null) {
	        m_vec3.copy(prev[1], p1);
	        p3[0] = 2.0 * p2[0] - p1[0];
	        p3[1] = 2.0 * p2[1] - p1[1];
	    } else
	        m_vec3.copy(next[1], p3);

	    m_vec3.subtract(p2, p1, dvec_a);
	    m_vec3.subtract(p3, p2, dvec_b);

	    var len_a = m_vec3.length(dvec_a);
	    var len_b = m_vec3.length(dvec_b);

	    if (len_a == 0.0)
	        len_a = 1.0;
	    if (len_b == 0.0)
	        len_b = 1.0;

	    if (h1 == "AUTO" || h2 == "AUTO") {
	        tvec[0] = dvec_b[0] / len_b + dvec_a[0] / len_a;
	        tvec[1] = dvec_b[1] / len_b + dvec_a[1] / len_a;

	        var len = m_vec3.length(tvec) * 2.5614;

	        if (len != 0) {

	            if (h1 == "AUTO") {
	                len_a /= len;
	                m_vec3.scaleAndAdd(p2, tvec, -len_a, bezt[0]);
	            }

	            if (h2 == "AUTO") {
	                len_b /= len;
	                m_vec3.scaleAndAdd(p2, tvec, len_b, bezt[2]);
	            }
	        }
	    }

	    if (h1 == "VECTOR")
	        m_vec3.scaleAndAdd(p2, dvec_a, -1.0 / 3.0, bezt[0]);

	    if (h2 == "VECTOR")
	        m_vec3.scaleAndAdd(p2, dvec_b, 1.0 / 3.0, bezt[2]);
	};

	/**
	 * The total length of the handles is not allowed to be more
	 * than the horizontal distance between (v1-v4).
	 * (prevent curve loops)
	 */
	exports.correct_bezpart = function(v1, v2, v3, v4) {

	    var h1 = [];
	    var h2 = [];
	    var len1, len2, len, fac;

	    // calc handle deltas
	    h1[0] = v1[0] - v2[0];
	    h1[1] = v1[1] - v2[1];

	    h2[0] = v4[0] - v3[0];
	    h2[1] = v4[1] - v3[1];

	    // calculate distances:
	    // len- span of time between keyframes
	    // len1 - length of handle of start key
	    // len2 - length of handle of end key
	    len = v4[0]- v1[0];
	    len1 = Math.abs(h1[0]);
	    len2 = Math.abs(h2[0]);

	    // if the handles have no length, no need to do any corrections
	    if ((len1 + len2) == 0)
	        return;

	    // the two handles cross over each other, so force them
	    // apart using the proportion they overlap
	    if (len1 + len2 > len) {
	        fac = len / (len1 + len2);

	        v2[0] = v1[0] - fac * h1[0];
	        v2[1] = v1[1] - fac * h1[1];

	        v3[0] = v4[0] - fac * h2[0];
	        v3[1] = v4[1] - fac * h2[1];
	    }
	};

	}

	var int_curve_factory = register("__curve", Int_curve);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * NLA scheduler module.
	 * @name nla
	 * @namespace
	 * @exports exports as nla
	 */
	function Int_NLA(ns, exports) {

	var m_anim      = int_animation_factory(ns);
	var m_obj       = int_objects_factory(ns);
	var m_obj_util  = int_obj_util_factory(ns);
	var m_print     = print_factory(ns);
	var m_scs       = int_scenes_factory(ns);
	var m_sfx       = int_sfx_factory(ns);
	var m_tex       = int_textures_factory(ns);
	var m_time      = int_time_factory(ns);
	var m_util      = int_util_factory(ns);

	var _nla_arr = [];
	var _start_time = -1;

	// to fix precision issues with freezing current frame
	var CF_FREEZE_EPSILON = 0.000001;

	exports.update_object = function(bpy_source, obj) {

	    var sd = find_scene_data_for_nla(obj);
	    if (sd) {
	        sd.obj_has_nla_on_scene = true;

	        var slot_num = 0;

	        var adata = bpy_source["animation_data"];
	        if (adata && adata["nla_tracks"].length) {
	            var nla_tracks = adata["nla_tracks"];

	            if (m_obj_util.is_armature(obj) ||
	                    m_obj_util.is_camera(obj) ||
	                    m_obj_util.is_mesh(obj) ||
	                    m_obj_util.is_empty(obj) ||
	                    m_obj_util.is_line(obj) ||
	                    m_obj_util.is_lamp(obj) ||
	                    // no need for separate slot in case of sound
	                    m_obj_util.is_speaker(obj) ||
	                    m_obj_util.is_world(obj)) {

	                var nla_events = get_nla_events(nla_tracks, slot_num);
	                if (nla_events.length) {
	                    obj.nla_events = obj.nla_events.concat(nla_events);
	                    slot_num++;
	                }
	            }
	        }

	        if (bpy_obj_has_data_param_nla(bpy_source)) {
	            var nla_tracks = bpy_source["data"]["animation_data"]["nla_tracks"];
	            var nla_events = get_nla_events(nla_tracks, slot_num);

	            if (nla_events.length) {
	                obj.nla_events = obj.nla_events.concat(nla_events);
	                slot_num++;
	            }
	        }

	        if (m_obj_util.is_mesh(obj)) {
	            var materials = obj.materials;
	            for (var j = 0; j < materials.length; j++) {
	                var mat = materials[j];
	                if (mat.use_nodes && mat.node_tree) {
	                    var nla_tracks = [];
	                    get_nodetree_nla_tracks_r(mat.node_tree, nla_tracks, [mat.name]);
	                    var nla_events = get_nla_events(nla_tracks, slot_num);
	                    if (nla_events.length) {
	                        slot_num += assign_anim_slots(nla_events, slot_num);
	                        obj.nla_events = obj.nla_events.concat(nla_events);
	                    }
	                }
	            }
	        }

	        if (m_obj_util.is_world(obj)) {
	            if (bpy_source["use_nodes"] && bpy_source["node_tree"]) {
	                var nla_tracks = [];
	                get_nodetree_nla_tracks_r(bpy_source["node_tree"], nla_tracks, [bpy_source["name"]]);
	                var nla_events = get_nla_events(nla_tracks, slot_num);
	                if (nla_events.length) {
	                    slot_num += assign_anim_slots(nla_events, slot_num);
	                    obj.nla_events = obj.nla_events.concat(nla_events);
	                }
	            }

	        } else {
	            for (var j = 0; j < bpy_source["particle_systems"].length; j++) {
	                var psys = bpy_source["particle_systems"][j];
	                var pset = psys["settings"];

	                if (pset["type"] == "EMITTER" && pset["b4w_allow_nla"]) {
	                    var ev = init_event();

	                    ev.type = "CLIP";
	                    ev.frame_start = sd.scene["frame_start"];
	                    ev.frame_end = sd.scene["frame_end"] + 1;
	                    ev.anim_name = psys["name"];
	                    ev.anim_slot = slot_num;
	                    ev.action_frame_start = ev.frame_start;
	                    ev.action_frame_end = ev.frame_end;
	                    obj.nla_events.push(ev);
	                    slot_num++;
	                }
	            }

	            var slot_num_va = slot_num+1;

	            for (var j = 0; j < obj.vertex_anim.length; j++) {
	                var va = obj.vertex_anim[j];

	                if (va.allow_nla) {
	                    slot_num = slot_num_va;

	                    var ev = init_event();

	                    ev.type = "CLIP";
	                    ev.frame_start = va.frame_start;
	                    ev.frame_end = va.frame_end;
	                    ev.anim_name = va.name;
	                    ev.anim_slot = slot_num;
	                    ev.action_frame_start = ev.frame_start;
	                    ev.action_frame_end = ev.frame_end;
	                    obj.nla_events.push(ev);
	                }
	            }

	        }
	    }
	};

	function find_scene_data_for_nla(obj) {
	    var scene_data = null;
	    for (var i = obj.scenes_data.length - 1; i >= 0; i--) {
	        var sd = obj.scenes_data[i];
	        if (sd.scene["b4w_use_nla"]) {
	            scene_data = sd;
	            // prefer main scene
	            if (sd.scene._is_main)
	                break;
	        }
	    }

	    return scene_data;
	}

	exports.update_scene = function(scene, is_cyclic, data_id) {

	    if (!scene._nla) {
	        scene._nla = {
	            frame_start: scene["frame_start"],
	            frame_end: scene["frame_end"],
	            frame_offset: 0,
	            last_frame: -1,
	            range_end: scene["frame_end"],
	            range_start: scene["frame_start"],

	            user_callback: null,
	            cyclic: is_cyclic,
	            objects: [],
	            textures: [],
	            scene_name: scene["name"],

	            is_stopped: false,
	            force_update: false,
	            rewinded_to_start: true
	        };
	        _nla_arr.push(scene._nla);
	    }
	    
	    var nla = scene._nla;

	    var objs = m_obj.get_scene_objs_derived(scene, "ALL", data_id);
	    for (var i = 0; i < objs.length; i++) {
	        var obj = objs[i];
	        if (obj.nla_events.length) {
	            if (!nla.objects[data_id])
	                nla.objects[data_id] = [];
	            for (var j = 0; j < obj.scenes_data.length; j++) {
	                var sd = obj.scenes_data[j];
	                if (sd.scene == scene && sd.obj_has_nla_on_scene)
	                    nla.objects[data_id].push(obj);
	            }
	            
	            remove_inconsistent_nla(obj.nla_events, nla, obj.name);
	            calc_nla_extents(obj.nla_events, nla);
	        }
	    }

	    var textures = scene._render.video_textures;
	    for (var i = 0; i < textures.length; i++) {
	        var texture = textures[i]._render;
	        if (texture.use_nla && (texture.video_file || texture.seq_video) 
	                && texture.vtex_data_id == data_id) {

	            var ev = init_event();
	            ev.type = "VIDEO";

	            if (texture.use_cyclic) {
	                // tolerant range for VIDEO event
	                ev.frame_start = 0;
	                ev.frame_end = nla.frame_end;
	            } else {
	                ev.frame_start = m_util.clamp(texture.frame_start, 0, 
	                        nla.frame_end);
	                ev.frame_end = m_util.clamp(texture.frame_start 
	                        + texture.frame_duration, 0, nla.frame_end);
	            }

	            ev.anim_name = textures[i]["name"];
	            nla.textures.push(texture);
	        }
	    }
	};

	function remove_inconsistent_nla(nla_events, nla, name) {
	    for (var i = 0; i < nla_events.length; i++) {
	        var ev = nla_events[i];

	        // out of scene range
	        if (nla.frame_start > ev.frame_end || nla.frame_end < ev.frame_start) {
	            var strip_str = name + " [" + ev.frame_start + ":" +
	                    ev.frame_end + "]";
	            m_print.warn("NLA: Strip is out of scene range: " + strip_str);
	            nla_events.splice(i, 1);
	            i--;
	            continue;
	        }

	        if (!ev.anim_name && ev.type == "CLIP") {
	            // CLIP event is for objects only, not for video textures
	            m_print.warn("NLA: no action in strip for object \"" 
	                    + name + "\".");
	            nla_events.splice(i, 1);
	            i--;
	        }
	    }
	}

	/**
	 * For CLIP events only.
	 */
	function calc_nla_extents(nla_events, nla) {
	    for (var i = 0; i < nla_events.length; i++) {
	        var ev = nla_events[i];

	        var ext_frame_start = nla.frame_start;
	        var ext_frame_end = nla.frame_end + 1;

	        for (var k = 0; k < nla_events.length; k++) {
	            var ev_k = nla_events[k];

	            // slots are like NLA tracks in Blender
	            if (ev.anim_slot != ev_k.anim_slot)
	                continue;

	            if (ev_k.frame_end <= ev.frame_start)
	                ext_frame_start = ev.frame_start;

	            if (ev_k.frame_start >= ev.frame_end)
	                ext_frame_end = Math.min(ext_frame_end, ev_k.frame_start);
	        }

	        ev.ext_frame_start = ext_frame_start;
	        ev.ext_frame_end = ext_frame_end;

	        calc_clip_event_action_frame_final(ev);
	    }
	}

	function calc_clip_event_action_frame_final(ev) {
	    if (ev.repeat % 1 === 0)
	        ev.action_frame_final = ev.action_frame_end;
	    else
	        ev.action_frame_final = ev.action_frame_start + (ev.action_frame_end - ev.action_frame_start) * (ev.repeat % 1);
	}

	function assign_anim_slots(nla_events, start_slot) {
	    // TODO: apply this method for any supported animation types
	    // Currently it supports only nodemat animations
	    var actions = m_anim.get_all_actions();
	    var fc_usage = [];
	    var num_assigned_slots = 0;

	    for (var i = 0; i < nla_events.length; i++) {
	        var ev = nla_events[i];
	        if (ev.anim_uuid != "") {
	            var action = m_util.keysearch("uuid", ev.anim_uuid, actions);
	        } else {
	            var name = ev.anim_name;
	            var action = m_util.keysearch("name", name, actions) ||
	                         m_util.keysearch("name", name + "_B4W_BAKED", actions);
	        }

	        if (!action)
	            continue;

	        var fcurves = action["fcurves"];
	        var cur_fcurves_names = [];
	        for (var fcurve in fcurves)
	            cur_fcurves_names.push(fcurve);
	        fc_usage.push(cur_fcurves_names);
	    }

	    for (var i = 0; i < fc_usage.length; i++) {
	        var have_common_fc = false;
	        for (var k = 0; k < i; k++) {
	            if (m_util.arrays_have_common(fc_usage[i], fc_usage[k])) {
	                nla_events[i].anim_slot = nla_events[k].anim_slot;
	                have_common_fc = true;
	                break;
	            }
	        }
	        if (!have_common_fc)
	            nla_events[i].anim_slot = start_slot + num_assigned_slots++;
	    }
	    return num_assigned_slots;
	}

	function init_event() {
	    var ev = {
	        type: "CLIP",
	        frame_start: 0,
	        frame_end: 0,
	        scheduled: false,
	        paused: false,
	        anim_name: "",
	        anim_uuid: "",
	        anim_slot: 0,
	        name_list: null,
	        action_frame_start: 0,
	        action_frame_end: 0,
	        ext_frame_start: 0,
	        ext_frame_end: 0,
	        use_reverse: false,
	        scale: 1,
	        repeat: 1,
	        action_frame_final: 0 //last action frame in the strip
	    };
	    return ev;
	}

	function get_nodetree_nla_tracks_r(node_tree, container, name_list) {
	    if (node_tree["animation_data"]) {
	        var anim_data = node_tree["animation_data"];
	        var nla_tracks = anim_data["nla_tracks"];
	        if (nla_tracks)
	            for (var i = 0; i < nla_tracks.length; i++) {
	                // TODO: need to check exports. Writing to bpy object directly
	                nla_tracks[i].name_list = name_list;
	                container.push(nla_tracks[i]);
	            }
	    }
	    var nodes = node_tree["nodes"];
	    for (var i = 0; i < nodes.length; i++) {
	        var node = nodes[i];
	        if (node["node_group"]) {
	            var g_node_tree = node["node_group"]["node_tree"];
	            if (g_node_tree) {
	                var new_name_list = name_list.slice();
	                new_name_list.push(node["name"]);
	                get_nodetree_nla_tracks_r(g_node_tree, container,
	                                          new_name_list);
	            }
	        }
	    }
	}

	exports.prepare = function() {
	    // init cache for all nla actions
	    for (var i = 0; i < _nla_arr.length; i++) {
	        var nla = _nla_arr[i];
	        for (var k = 0; k < nla.objects.length; k++) {
	            var objs = nla.objects[k];
	            if (!objs)
	                continue;
	            for (var i = 0; i < objs.length; i++) {
	                var obj = objs[i];
	                var nla_events = obj.nla_events;
	                for (var j = 0; j < nla_events.length; j++) {
	                    var ev = nla_events[j];
	                    m_anim.init_action_cache(obj, ev.name_list, ev.uuid, ev.anim_name, ev.anim_slot);
	                }
	            }
	        }
	    }
	};

	exports.start = function() {
	    _start_time = 0;
	};

	exports.get_start_time = function() {
	    return _start_time
	};

	exports.get_frame_offset = function(scene) {
	    if (scene._nla)
	        return scene._nla.frame_offset;
	    return null;
	};

	exports.set_frame_offset = function(scene, frame_offset) {
	    if (scene._nla) {
	        scene._nla.frame_offset = frame_offset;
	        return true
	    }
	    return false;
	};

	/**
	 * Called every frame
	 */
	exports.update = function(timeline, elapsed) {

	    if (_start_time < 0)
	        return;
	    else if (_start_time == 0)
	        _start_time = timeline; // initialize timer at first iteration

	    for (var i = 0; i < _nla_arr.length; i++) {
	        var nla = _nla_arr[i];

	        // recalculate frame offset for this frame
	        if (nla.is_stopped)
	            nla.frame_offset -= m_time.get_framerate() * elapsed;
	        var cf = calc_curr_frame_scene(nla, timeline);
	        // range end handling
	        if ((!nla.is_stopped || nla.force_update) && cf >= nla.range_end)
	            if (nla.cyclic)
	                cf = nla_range_end_rewind(nla, timeline);
	            else
	                nla_range_end_stop(nla, cf);

	        // NOTE: can be stopped previously from nla_range_end_stop
	        if (!nla.is_stopped || nla.force_update) {
	            process_nla_objects(nla, cf, elapsed);
	            process_nla_video_textures(timeline, nla, cf);
	            nla.last_frame = cf;
	        }

	        nla.force_update = false;
	        nla.rewinded_to_start = false;
	    }
	};

	function nla_range_end_stop(nla, curr_frame) {
	    nla.is_stopped = true;
	    nla.frame_offset -= curr_frame - nla.range_end;
	    if (nla.user_callback)
	        nla.user_callback();
	}

	/**
	 * Rewind to 0 frame.
	 */
	function nla_range_end_rewind(nla, timeline) {
	    // NOTE: callback before rewinding
	    if (nla.user_callback)
	        nla.user_callback();

	    set_frame(nla.range_start, timeline);
	    nla.rewinded_to_start = true;
	    return calc_curr_frame_scene(nla, timeline);
	}

	function process_nla_objects(nla, curr_frame, elapsed) {
	    for (var k = 0; k < nla.objects.length; k++) {
	        var objs = nla.objects[k];
	        if (!objs)
	            continue;
	        for (var i = 0; i < objs.length; i++) {
	            var obj = objs[i];
	            var nla_events = obj.nla_events;

	            // NOTE: allow single-strip speakers to play again
	            for (var j = 0; j < nla_events.length; j++) {
	                var ev = nla_events[j];
	                if (ev.type == "SOUND" 
	                        && curr_frame < (nla.last_frame - CF_FREEZE_EPSILON))
	                    ev.scheduled = false;
	            }

	            for (var j = 0; j < nla_events.length; j++) {
	                var ev = nla_events[j];

	                switch (ev.type) {
	                case "CLIP":
	                    if (ev.ext_frame_start <= curr_frame && curr_frame < ev.ext_frame_end)
	                        if (!ev.scheduled) {
	                            process_clip_event_start(obj, ev, curr_frame, elapsed);

	                            for (var k = 0; k < nla_events.length; k++)
	                                if (nla_events[k] != ev &&
	                                        nla_events[k].anim_slot == ev.anim_slot)
	                                    nla_events[k].scheduled = false;

	                            ev.scheduled = true;
	                        }

	                    if (ev.scheduled)
	                        process_clip_event(obj, ev, curr_frame, elapsed);

	                    break;
	                case "SOUND":
	                    if ((curr_frame < (nla.last_frame - CF_FREEZE_EPSILON) || 
	                            nla.last_frame < ev.frame_start) &&
	                            ev.frame_start <= curr_frame && curr_frame < ev.frame_end)
	                        if (!ev.scheduled) {
	                            process_sound_event(obj, ev, curr_frame);
	                            ev.scheduled = true;
	                        }

	                    if (nla.last_frame < ev.frame_end && ev.frame_end <= curr_frame)
	                        if (ev.scheduled)
	                            ev.scheduled = false;
	                    break;
	                default:
	                    break;
	                }
	            }
	        }
	    }
	}

	/**
	 * Perform non-continuous actions.
	 */
	function process_nla_video_textures(timeline, nla, nla_frame) {
	    for (var i = 0; i < nla.textures.length; i++) {
	        var tex = nla.textures[i];

	        if (!tex.video_file && !tex.seq_video)
	            continue;

	        var video_frame_native = m_tex.video_get_current_frame(tex);
	        var video_frame_clamped = get_video_frame_clamped(nla_frame, tex);
	        var frame_start = m_tex.video_get_start_frame(tex);

	        var need_update = false;
	        var need_set_frame = false;

	        // force update via set_frame() or rewinding the whole nla 
	        if (nla.force_update || nla.rewinded_to_start)
	            need_set_frame = true;

	        if (!nla.is_stopped) {
	            var need_play = frame_need_play_video(nla_frame, tex);
	            var is_played = m_tex.video_is_played(tex);

	            // rewind cyclic video texture
	            if (tex.use_cyclic && video_frame_clamped == frame_start)
	                need_set_frame = true;

	            // if video is stopped on a wrong frame (e.g. dynamically 
	            // loaded textures) we need to set the correct one 
	            if (!is_played && video_frame_native != video_frame_clamped)
	                need_set_frame = true;

	            // play/pause video
	            if (need_play && !is_played)
	                m_tex.play_video(tex);
	            else if (need_play && is_played)
	                need_update = true;
	            else if (!need_play && is_played) {
	                // NOTE: allow to play non-sequential video until it'll 
	                // reach calculated frame (may be caused by lags)
	                if (tex.video_file && video_frame_native < video_frame_clamped)
	                    need_update = true;
	                else
	                    m_tex.pause_video(tex);
	            }
	        }

	        if (need_set_frame) {
	            m_tex.set_frame_video(tex.video_tex_name, video_frame_clamped, tex.vtex_data_id);
	            if (tex.seq_video)
	                tex.seq_last_discrete_mark = m_tex.seq_video_get_discrete_timemark(tex, timeline);
	        } else if (need_update && m_tex.video_update_is_available(tex)) {
	            if (tex.video_file)
	                m_tex.update_video_texture(tex);
	            else {
	                var mark = m_tex.seq_video_get_discrete_timemark(tex, timeline);
	                if (mark != tex.seq_last_discrete_mark) {
	                    tex.seq_cur_frame = video_frame_clamped;
	                    m_tex.update_seq_video_texture(tex);
	                }
	                tex.seq_last_discrete_mark = mark;
	            }
	        }
	    }
	}

	/**
	 * Convert nla frame to a raw video frame. Video frame can be out of a playable range.
	 */
	function nla_frame_to_video_frame(nla_frame, vtex) {
	    var frame_delta = Math.round(nla_frame) - vtex.frame_start;
	    if (vtex.use_cyclic) {
	        frame_delta = frame_delta % vtex.frame_duration;
	        if (frame_delta < 0)
	            frame_delta += vtex.frame_duration;
	    }
	    return vtex.frame_offset + frame_delta;
	}

	/**
	 * Get a valid video frame which is needed to play on a certain nla frame.
	 */
	function get_video_frame_clamped(nla_frame, vtex) {
	    var video_frame = nla_frame_to_video_frame(nla_frame, vtex);

	    var frame_clamped = m_util.clamp(video_frame, vtex.frame_offset, 
	            vtex.frame_offset + m_tex.video_get_duration(vtex) - 1);

	    if (vtex.seq_video) {
	        frame_clamped = m_tex.video_frame_to_seq_frame(vtex, frame_clamped);
	        // NOTE: insufficient video_frame clamping
	        if (frame_clamped == vtex.seq_movie_length)
	            frame_clamped--;
	    }
	    return frame_clamped;
	}

	function frame_need_play_video(cf, vtex) {
	    var frame = nla_frame_to_video_frame(cf, vtex);
	    return vtex.frame_offset <= frame && frame <= vtex.frame_offset 
	            + m_tex.video_get_duration(vtex);
	}

	/**
	 * NOTE: unused
	 */
	// function pause_scheduled_objects(objects) {
	//     for (var i = 0; i < objects.length; i++) {
	//         var obj = objects[i];
	//         var nla_events = obj.nla_events;
	//         for (var j = 0; j < nla_events.length; j++) {
	//             var ev = nla_events[j];
	//             if (ev.scheduled && !ev.paused) {
	//                 process_event_pause(obj);
	//                 ev.paused = true;
	//             }
	//         }
	//     }
	// }

	/**
	 * NOTE: unused
	 */
	// function resume_scheduled_objects(objects) {
	//     for (var i = 0; i < objects.length; i++) {
	//         var obj = objects[i];
	//         var nla_events = obj.nla_events;
	//         for (var j = 0; j < nla_events.length; j++) {
	//             var ev = nla_events[j];
	//             if (ev.paused) {
	//                 process_event_resume(obj);
	//                 ev.paused = false;
	//             }
	//         }
	//     }
	// }

	function calc_curr_frame_scene(nla, timeline) {

	    var cf = (timeline - _start_time) * m_time.get_framerate() + nla.frame_offset;

	    if (cf > nla.frame_start) {
	        cf -= nla.frame_start;
	        if (nla.cyclic) {
	            var stride = nla.frame_end - nla.frame_start + 1;
	            cf %= stride;
	        }
	        cf += nla.frame_start;
	    } else {
	        cf = nla.frame_start;
	    }

	    return cf;
	}

	function process_clip_event_start(obj, ev, frame, elapsed) {
	    var name_list = ev.name_list;
	    if (ev.anim_uuid != "")
	        m_anim.apply_by_uuid(obj, name_list, ev.anim_uuid, ev.anim_slot);
	    else
	        m_anim.apply(obj, name_list, ev.anim_name, ev.anim_slot);
	    // NOTE: should not be required
	    m_anim.set_behavior(obj, m_anim.AB_FINISH_STOP, ev.anim_slot);
	    var action_frame = get_curr_action_frame(ev.frame_start, ev);
	    m_anim.set_frame(obj, action_frame, ev.anim_slot);
	}

	function process_clip_event(obj, ev, frame, elapsed) {
	    var new_anim_frame = get_curr_action_frame(frame, ev);
	    var curr_anim_frame = m_anim.get_current_frame_float(obj, ev.anim_slot);
	    // do not update animation if the frame is not changed
	    // to allow object movement in between
	    if (Math.abs(new_anim_frame - curr_anim_frame) > CF_FREEZE_EPSILON)
	        m_anim.set_frame(obj, new_anim_frame, ev.anim_slot);

	}

	function get_curr_action_frame(frame, ev) {
	    frame = m_util.clamp(frame, ev.frame_start, ev.frame_end);
	    if (frame == ev.frame_end) {
	        var action_frame = ev.action_frame_final;
	    } else {
	        var track_frame = (frame - ev.frame_start) / ev.scale;
	        var track_len = ev.action_frame_end - ev.action_frame_start;
	        var action_frame_offset = track_frame % track_len;

	        var action_frame = ev.action_frame_start + action_frame_offset;
	    }

	    if (ev.use_reverse)
	        action_frame = ev.action_frame_end - action_frame + ev.action_frame_start;

	    return action_frame;
	}

	function process_sound_event(obj, ev, frame) {
	    var when = (ev.frame_start - frame) / m_time.get_framerate();
	    var duration = (ev.frame_end - ev.frame_start) / m_time.get_framerate();
	    m_sfx.play(obj, when, duration);
	}

	exports.cleanup = function(data_id) {
	    if (data_id == 0) {
	        _nla_arr.length = 0;
	        _start_time = -1;
	    } else
	        for (var i = 0; i < _nla_arr.length; i++)
	            _nla_arr[i].objects[data_id] = null;
	};

	/**
	 * Convert NLA tracks to events
	 */
	function get_nla_events(nla_tracks, anim_slot_num) {

	    var nla_events = [];

	    for (var i = 0; i < nla_tracks.length; i++) {
	        var track = nla_tracks[i];

	        var strips = track["strips"];
	        if (!strips)
	            continue;

	        for (var j = 0; j < strips.length; j++) {

	            var strip = strips[j];

	            var ev = init_event();

	            ev.type = strip["type"];
	            ev.frame_start = strip["frame_start"];
	            ev.frame_end = strip["frame_end"];
	            ev.anim_slot = anim_slot_num;
	            ev.action_frame_start = strip["action_frame_start"];
	            ev.action_frame_end = strip["action_frame_end"];
	            ev.use_reverse = strip["use_reverse"];
	            ev.scale = strip["scale"];
	            ev.repeat = strip["repeat"];

	            if (strip["action"]){
	                ev.anim_name = strip["action"]["name"];
	                ev.anim_uuid = strip["action"]["uuid"];
	                ev.name_list = track.name_list;
	            }

	            nla_events.push(ev);
	        }
	    }

	    return nla_events;
	}

	exports.bpy_obj_has_nla = function(bpy_obj) {
	    // TODO: particles/vertex animation
	    var adata = bpy_obj["animation_data"];

	    if ((adata && adata["nla_tracks"].length) || bpy_obj_has_data_param_nla(bpy_obj) ||
	            bpy_obj_has_nodemats_nla(bpy_obj))
	        return true;
	    else
	        return false;
	};

	function bpy_obj_has_data_param_nla(bpy_obj) {
	    if ((bpy_obj["type"] == "SPEAKER" || bpy_obj["type"] == "LAMP")
	         && bpy_obj["data"]["animation_data"] &&
	            bpy_obj["data"]["animation_data"]["nla_tracks"].length)
	        return true;
	    else
	        return false;
	}

	function bpy_obj_has_nodemats_nla(bpy_obj) {
	    if (bpy_obj["type"] != "MESH" || !bpy_obj["data"])
	        return false;

	    var materials = bpy_obj["data"]["materials"];
	    if (!materials)
	        return false;

	    for (var j = 0; j < materials.length; j++) {
	        var mat = materials[j];
	        var node_tree = mat.node_tree;
	        if (mat.use_nodes && node_tree) {
	            if (check_nodetree_nla_tracks_r(node_tree))
	                return true;
	        }
	    }
	    return false;
	}

	function check_nodetree_nla_tracks_r(node_tree, container) {
	    if (node_tree["animation_data"]) {
	        var anim_data = node_tree["animation_data"];
	        var nla_tracks = anim_data["nla_tracks"];
	        if (nla_tracks && nla_tracks.length)
	            return true;
	    }
	    var nodes = node_tree["nodes"];
	    for (var i = 0; i < nodes.length; i++) {
	        var node = nodes[i];
	        if (node["node_group"]) {
	            var g_node_tree = node["node_group"]["node_tree"];
	            if (g_node_tree)
	                check_nodetree_nla_tracks_r(g_node_tree, container);
	        }
	    }
	    return false;
	}

	exports.set_frame = set_frame;
	function set_frame(frame, timeline) {
	    var active_scene = m_scs.get_active();
	    if (active_scene._nla) {
	        var cf = calc_curr_frame_scene(active_scene._nla, timeline);
	        active_scene._nla.frame_offset -= cf - frame;
	        active_scene._nla.force_update = true;
	    }
	}

	exports.get_frame = get_frame;
	function get_frame(timeline) {
	    var active_scene = m_scs.get_active();
	    if (active_scene._nla)
	        return calc_curr_frame_scene(active_scene._nla, timeline);
	    else
	        return -1;
	}

	exports.stop_nla = stop_nla;
	function stop_nla() {
	    var active_scene = m_scs.get_active();

	    if (active_scene._nla) {
	        active_scene._nla.is_stopped = true;

	        var vtexs = active_scene._nla.textures;

	        for (var i = 0; i < vtexs.length; i++) {
	            var vtex = vtexs[i];
	            m_tex.pause_video(vtex);
	        }
	    }
	}

	exports.play_nla = play_nla;
	function play_nla(callback) {
	    var active_scene = m_scs.get_active();
	    if (active_scene._nla) {
	        active_scene._nla.is_stopped = false;
	        if (callback)
	            active_scene._nla.user_callback = callback;
	        else
	            active_scene._nla.user_callback = null;
	    }

	    // NOTE: video textures will be unpaused on the next update
	}

	exports.get_frame_start = function() {
	    var active_scene = m_scs.get_active();
	    if (active_scene._nla)
	        return active_scene._nla.frame_start;
	    else
	        return -1;
	};

	exports.get_frame_end = function() {
	    var active_scene = m_scs.get_active();
	    if (active_scene._nla)
	        return active_scene._nla.frame_end;
	    else
	        return -1;
	};

	exports.is_play = function() {
	    var active_scene = m_scs.get_active();
	    if (active_scene._nla)
	        return !active_scene._nla.is_stopped;
	    else
	        return false;
	};

	exports.check_nla = function() {
	    var active_scene = m_scs.get_active();
	    if (active_scene._nla)
	        return active_scene["b4w_use_nla"];
	    else
	        return false;
	};

	exports.check_logic_nodes = function() {
	    var active_scene = m_scs.get_active();
	    if (active_scene._nla)
	        return active_scene["b4w_logic_nodes"].length > 0;
	    else
	        return false;
	};

	exports.set_range = function(start_frame, end_frame) {
	    var active_scene = m_scs.get_active();
	    if (active_scene._nla) {
	        active_scene._nla.range_start = start_frame;
	        active_scene._nla.range_end = end_frame;
	    } else
	        return false;
	};

	exports.set_range_end = function(end_frame) {
	    var active_scene = m_scs.get_active();
	    if (active_scene._nla) {
	        active_scene._nla.range_end = end_frame;
	    } else
	        return false;
	};

	exports.set_range_start = function(start_frame) {
	    var active_scene = m_scs.get_active();
	    if (active_scene._nla) {
	        active_scene._nla.range_start = start_frame;
	    } else
	        return false;
	};

	exports.reset_range = reset_range;
	function reset_range() {
	    var active_scene = m_scs.get_active();
	    if (active_scene._nla) {
	        var nla = active_scene._nla;
	        nla.range_start = nla.frame_start;
	        nla.range_end = nla.frame_end;
	    } else
	        return false;
	}

	exports.set_cyclic = function(is_cyclic) {
	    var active_scene = m_scs.get_active();
	    if (active_scene._nla)
	        active_scene._nla.cyclic = is_cyclic;
	    else
	        return false;
	};

	exports.clear_callback = function() {
	    var active_scene = m_scs.get_active();
	    if (active_scene._nla)
	        active_scene._nla.user_callback = null;
	};

	exports.set_offset_from_range_start = function(timeline) {
	    var active_scene = m_scs.get_active();
	    var nla = active_scene._nla;
	    if (nla) {
	        nla.frame_offset = -(timeline - _start_time) * m_time.get_framerate() + nla.range_start;
	        nla.force_update = true;
	    }
	};

	exports.get_frame_end = function() {
	    var active_scene = m_scs.get_active();
	    var nla = active_scene._nla;
	    if (nla)
	        return nla.frame_end;
	    else
	        return null;
	};

	}

	var int_nla_factory = register("__nla", Int_NLA);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Controls internal API.
	 * @name controls
	 * @namespace
	 * @exports exports as controls
	 */
	function Int_controls(ns, exports) {

	var m_cfg   = int_config_factory(ns);
	var m_cont  = int_container_factory(ns);
	var m_input = int_input_factory(ns);
	var m_obj   = int_objects_factory(ns);
	var m_print = print_factory(ns);
	var m_phy   = int_physics_factory(ns);
	var m_quat  = quat_factory(ns);
	var m_time  = int_time_factory(ns);
	var m_tsr   = int_tsr_factory(ns);
	var m_util  = int_util_factory(ns);
	var m_vec3  = vec3_factory(ns);

	var cfg_ctl = m_cfg.controls;
	var cfg_dft = m_cfg.defaults;

	var _objects = [];
	var _global_object = {};

	var _sensors_cache = [];
	var _manifolds_cache = [];
	var _accumulators_cache = [];

	var _vec2_tmp  = new Float32Array(2);
	var _vec2_tmp2 = new Float32Array(2);

	var _vec3_tmp = m_vec3.create();
	var _quat_tmp = m_quat.create();

	// flag and counter to maintain object cache and manifolds consistency
	var _manifolds_updated = false;
	var _update_counter = 0;

	// sensor types for internal usage
	var ST_CUSTOM            = 10;
	var ST_KEYBOARD          = 20;
	var ST_MOUSE_WHEEL       = 30;
	var ST_MOUSE_MOVE        = 40;
	var ST_MOUSE_CLICK       = 50;
	var ST_TOUCH_MOVE        = 60;
	var ST_TOUCH_ZOOM        = 70;
	var ST_TOUCH_ROTATE      = 75;
	var ST_TOUCH_CLICK       = 80;
	var ST_COLLISION         = 90;
	var ST_COLLISION_IMPULSE = 100;
	var ST_RAY               = 110;
	var ST_MOTION            = 120;
	var ST_V_VELOCITY        = 130;
	var ST_TIMER             = 140;
	var ST_ELAPSED           = 150;
	var ST_TIMELINE          = 160;
	var ST_SELECTION         = 170;
	var ST_GYRO_DELTA        = 180;
	var ST_GYRO_ANGLES       = 190;
	var ST_GYRO_QUAT         = 200;
	var ST_HMD_QUAT          = 210;
	var ST_HMD_POSITION      = 220;
	var ST_CALLBACK          = 230;
	var ST_GAMEPAD_BTNS      = 240;
	var ST_GMPD_AXIS         = 250;
	var ST_GAMEPAD_POSITION  = 260;
	var ST_GAMEPAD_ORIENTATION = 270;
	var ST_PLOCK_MOUSE_MOVE  = 280;
	var ST_PLOCK             = 290;

	// control types
	exports.CT_POSITIVE   = 10;
	exports.CT_CONTINUOUS = 20;
	exports.CT_TRIGGER    = 30;
	exports.CT_SHOT       = 40;
	exports.CT_LEVEL      = 50;
	exports.CT_CHANGE     = 60;

	exports.PL_SINGLE_TOUCH_MOVE      = 0;
	exports.PL_MULTITOUCH_MOVE_ZOOM   = 1;
	exports.PL_MULTITOUCH_MOVE_PAN    = 2;
	exports.PL_MULTITOUCH_MOVE_ROTATE = 3;

	var SENSOR_SMOOTH_PERIOD = 0.3;
	var CAM_SMOOTH_CHARACTER_MOUSE = 0.1;
	var MOUSE_DELTA_THRESHOLD = 0.01;

	// input states
	// 0 - not pressed; 1 - pressed
	// convention: MOUSE_STATE_ + prev_state + curr_sate
	var INPUT_STATE_00 = 0;
	var INPUT_STATE_01 = 1;
	var INPUT_STATE_11 = 2;
	var INPUT_STATE_10 = 3;

	var KEY_SHIFT = 16;

	var MAX_COUNT_FINGERS = 10;

	var _smooth_factor = 1.0;

	exports.update = function(timeline, elapsed) {
	    // prepare sensor accumulators
	    for (var i = 0; i < _accumulators_cache.length; i++) {
	        var accum = _accumulators_cache[i];
	        prepare_accumulator(accum);
	    }

	    for (var i = 0; i < _sensors_cache.length; i++) {
	        var sensor = _sensors_cache[i];
	        update_sensor(sensor, timeline, elapsed);
	    }

	    for (var i = 0; i < _objects.length; i++) {
	        var obj = _objects[i];
	        var manifolds_arr = obj.sensor_manifolds_arr;

	        for (var j = 0; j < manifolds_arr.length; j++) {
	            var manifold = manifolds_arr[j];

	            // already updated
	            if (manifold.update_counter == _update_counter)
	                continue;

	            manifold.update_counter = _update_counter;

	            var pulse = manifold_gen_pulse(manifold);
	            if (pulse) {
	                var cb_obj = (obj == _global_object) ? null : obj;
	                _manifolds_updated = false;
	                manifold.callback(cb_obj, manifold.id, pulse, manifold.callback_param);
	                // go to loop start
	                if (_manifolds_updated) {
	                    i = -1;
	                    break;
	                }
	            }
	        }
	    }

	    // discharge after ALL callback exec
	    for (var i = 0; i < _objects.length; i++) {
	        var obj = _objects[i];
	        var manifolds_arr = obj.sensor_manifolds_arr;

	        for (var j = 0; j < manifolds_arr.length; j++) {
	            var manifold = manifolds_arr[j];
	            discharge_sensors(manifold.sensors);
	        }
	    }

	    // update sensor accumulators state after ALL callback exec
	    for (var i = 0; i < _accumulators_cache.length; i++) {
	        var accum = _accumulators_cache[i];
	        update_accumulator(accum);
	    }

	    _update_counter++;
	};

	exports.create_custom_sensor = function(value) {
	    var sensor = init_sensor(ST_CUSTOM);
	    sensor_set_value(sensor, value);
	    return sensor;
	};

	function init_sensor(type, element) {
	    if (!element)
	        element = m_cont.get_container();

	    var sensor = {
	        type: type,
	        value: 0,
	        payload: null,
	        element: element,

	        do_activation: false,

	        // for ST_KEYBOARD
	        key: 0,

	        // for ST_COLLISION and ST_RAY
	        collision_id: "",
	        calc_pos_norm: false,

	        // for ST_COLLISION
	        collision_obj: null,
	        collision_cb: function() {},

	        // for ST_COLLISION_IMPULSE
	        col_imp_obj: null,
	        col_imp_cb: function() {},

	        // for ST_RAY, ST_MOTION and ST_SELECTION
	        source_object: null,

	        // for ST_RAY
	        from: new Float32Array(3),
	        to: new Float32Array(3),
	        is_binary_value: false,
	        ign_src_rot: false,
	        ray_test_id: 0,
	        ray_test_cb: function() {},

	        // for ST_MOUSE_MOVE and ST_TOUCH_MOVE
	        axis: "",

	        // for ST_MOTION, ST_V_VELOCITY, ST_TIMER and ST_ELAPSED
	        time_last: 0.0,

	        // for ST_MOTION and ST_V_VELOCITY
	        trans_last: new Float32Array(3),
	        quat_last: new Float32Array(4),
	        threshold: 0.0,

	        // for ST_MOTION
	        quat_temp: new Float32Array(4),
	        avg_linear_vel: 0.0,
	        avg_angular_vel: 0.0,
	        rotation_threshold: 0.0,

	        // for ST_V_VELOCITY
	        avg_vertical_vel: 0.0,

	        // for ST_TIMER
	        period: 0.0,
	        repeat: false,

	        // for ST_SELECTION
	        enable_toggle_switch: false,

	        // for ST_GAMEPAD_BTNS
	        gamepad_id: 0,

	        // for ST_GAMEPAD_POSITION
	        position: m_vec3.create(),

	        // for ST_GAMEPAD_ORIENTATION
	        orientation: m_quat.create(),

	        // for ST_CALLBACK
	        callback: function() {}
	    };

	    return sensor;
	}

	function prepare_accumulator(accum) {
	    if (!accum.mouse_select_data.is_updated) {
	        accum.mouse_select_data.obj = m_obj.pick_object(
	                accum.mouse_select_data.coord[0],
	                accum.mouse_select_data.coord[1]);
	        accum.mouse_select_data.is_updated = true;
	        accum.global_selected_obj = accum.mouse_select_data.obj;
	    }

	    for (var i = 0; i < MAX_COUNT_FINGERS; ++i) {
	        var touch_data = accum.touch_select_dlist[i];
	        if (!touch_data.is_updated) {
	            touch_data.obj = m_obj.pick_object(
	                    touch_data.coord[0], touch_data.coord[1]);
	            touch_data.is_updated = true;
	            accum.global_selected_obj = touch_data.obj;
	        }
	    }
	}

	function update_accumulator(accum) {
	    // is_updated_keyboard is used for optimization
	    if (!accum.is_updated_keyboard) {
	        for (var i = 0; i < accum.downed_keys.length; i++) {
	            if (accum.downed_keys[i] == INPUT_STATE_01)
	                accum.downed_keys[i] = INPUT_STATE_11;
	            else if (accum.downed_keys[i] == INPUT_STATE_10)
	                accum.downed_keys[i] = INPUT_STATE_00;
	        }
	        accum.is_updated_keyboard = true;
	    }

	    if (accum.mouse_state == INPUT_STATE_01)
	        accum.mouse_state = INPUT_STATE_11;
	    else if (accum.mouse_state == INPUT_STATE_10)
	        accum.mouse_state = INPUT_STATE_00;

	    for (var j = 0; j < accum.touch_select_dlist.length; j++) {
	        var t = accum.touch_select_dlist[j];
	        if (t.touch_state == INPUT_STATE_01)
	            t.touch_state = INPUT_STATE_11;
	        else if (t.touch_state == INPUT_STATE_10)
	            t.touch_state = INPUT_STATE_00;
	    }

	    accum.wheel_delta = 0;
	    accum.mouse_last_x = accum.mouse_curr_x;
	    accum.mouse_last_y = accum.mouse_curr_y;
	    accum.downed_keys[0] = INPUT_STATE_00;

	    accum.touches_last_x.set(accum.touches_curr_x);
	    accum.touches_last_y.set(accum.touches_curr_y);
	    accum.touch_zoom_last_dist = accum.touch_zoom_curr_dist;

	    accum.gyro_gamma_last = accum.gyro_gamma_new;
	    accum.gyro_beta_last = accum.gyro_beta_new;
	    accum.gyro_alpha_last = accum.gyro_alpha_new;

	    accum.is_updated_gyro_quat = false;
	}

	function get_accumulator(element) {
	    if (!element)
	        element = m_cont.get_container();

	    for (var i = 0; i < _accumulators_cache.length; i++) {
	        var accumulator = _accumulators_cache[i];
	        if (element == accumulator.element)
	            return accumulator;
	    }

	    var accumulator = {
	        element: element,

	        is_updated_keyboard: true,
	        mouse_state: INPUT_STATE_00,
	        is_touch_ended: true,
	        // for ST_MOUSE_MOVE sensor
	        mouse_last_x: 0,
	        mouse_last_y: 0,
	        mouse_curr_x: 0,
	        mouse_curr_y: 0,

	        // for ST_PLOCK_MOUSE_MOVE
	        pointerlock_dx: 0.0,
	        pointerlock_dy: 0.0,

	        // for ST_TOUCH_MOVE sensor
	        touches_last_x: new Float32Array(2),
	        touches_curr_x: new Float32Array(2),
	        touches_last_y: new Float32Array(2),
	        touches_curr_y: new Float32Array(2),
	        touch_zoom_curr_dist: 0,
	        touch_zoom_last_dist: 0,
	        touch_start_rot: 0,

	        // for ST_KEYBOARD sensor
	        downed_keys: new Uint8Array(256),

	        // for ST_MOUSE_WHEEL sensor
	        wheel_delta: 0,

	        // for ST_SELECTION sensor
	        global_selected_obj: null,
	        mouse_select_data: create_input_point(),
	        touch_select_dlist: new Array(MAX_COUNT_FINGERS),

	        // for ST_GYRO_QUAT sensor
	        is_updated_gyro_quat: false,
	        gyro_quat: m_quat.create(),

	        // for ST_GYRO_ANGLES, ST_GYRO_DELTA sensor
	        gyro_gamma_new : 0.0,
	        gyro_beta_new : 0.0,
	        gyro_alpha_new : 0.0,

	        // for ST_GYRO_DELTA sensor
	        gyro_gamma_last : 0.0,
	        gyro_beta_last : 0.0,
	        // random unattainable value for initialization
	        gyro_alpha_last : Infinity,

	        // callbacks
	        orientation_quat_cb: null,
	        orientation_angles_cb: null,
	        mouse_wheel_cb: null,
	        mouse_down_which_cb: null,
	        mouse_select_cb: null,
	        touch_select_start_cb: null,
	        touch_select_end_cb: null,
	        mouse_up_which_cb: null,
	        mouse_location_cb: null,
	        pointerlock_cb: null,
	        keyboard_downed_keys_cb: null,
	        touch_start_cb: null,
	        touch_move_cb: null,
	        touch_end_cb: null,

	        registered_accum_values: {}
	    };
	    for (var i = 0; i < MAX_COUNT_FINGERS; ++i)
	        accumulator.touch_select_dlist[i] = create_input_point();

	    function create_input_point() {
	        return {
	            coord: new Float32Array(2),
	            is_updated: true,
	            obj: null,

	            // use for touch
	            identifier: -1,
	            touch_state: INPUT_STATE_00
	        };
	    }

	    accumulator.orientation_quat_cb = function(angles) {
	        // calculate gyro_quat only one time per frame
	        if (!accumulator.is_updated_gyro_quat) {
	            m_input.gyro_angles_to_quat(angles, accumulator.gyro_quat);
	            accumulator.is_updated_gyro_quat = true;
	        }
	    };

	    accumulator.orientation_angles_cb = function(quat) {
	        var euler_angles = m_vec3.copy(quat, _vec3_tmp);
	        accumulator.gyro_alpha_new = euler_angles[0];
	        accumulator.gyro_beta_new = euler_angles[1];
	        accumulator.gyro_gamma_new = euler_angles[2];

	        if (accumulator.gyro_alpha_last == Infinity) {
	            accumulator.gyro_alpha_last = euler_angles[0];
	            accumulator.gyro_beta_last = euler_angles[1];
	            accumulator.gyro_gamma_last = euler_angles[2];
	        }
	    };

	    accumulator.mouse_wheel_cb = function(wd) {
	        // accumulated
	        accumulator.wheel_delta += wd * cfg_ctl.mouse_wheel_notch_multiplier;
	    };

	    accumulator.mouse_down_which_cb = function(wd) {
	        var device = m_input.get_device_by_type_element(m_input.DEVICE_MOUSE,
	                accumulator.element);
	        var loc = m_input.get_vector_param(device, m_input.MOUSE_LOCATION, _vec2_tmp);
	        accumulator.mouse_last_x = loc[0];
	        accumulator.mouse_last_y = loc[1];
	        accumulator.mouse_curr_x = loc[0];
	        accumulator.mouse_curr_y = loc[1];
	        if (accumulator.mouse_state == INPUT_STATE_10 || accumulator.mouse_state == INPUT_STATE_00)
	            accumulator.mouse_state = INPUT_STATE_01;
	        accumulator.which = wd;
	    };

	    accumulator.mouse_select_cb = function(wd) {
	        var device = m_input.get_device_by_type_element(m_input.DEVICE_MOUSE,
	                accumulator.element);
	        var loc = m_input.get_vector_param(device, m_input.MOUSE_LOCATION, _vec2_tmp);
	        var canvas_xy = m_cont.client_to_canvas_coords(loc[0], loc[1], _vec2_tmp);
	        accumulator.mouse_select_data.is_updated = false;
	        accumulator.mouse_select_data.coord[0] = canvas_xy[0];
	        accumulator.mouse_select_data.coord[1] = canvas_xy[1];
	    };

	    accumulator.touch_select_start_cb = function(touches) {
	        for (var i = 0; i < touches.length; ++i) {
	            var touch = touches[i];
	            var rel_touch = null;
	            var cur_touch = null;
	            for (var j = 0; j < accumulator.touch_select_dlist.length; j++) {
	                var t = accumulator.touch_select_dlist[j];
	                var is_released = t.touch_state == INPUT_STATE_10 || t.touch_state == INPUT_STATE_00;
	                if (t.identifier == touch.identifier) {
	                    if (is_released)
	                        cur_touch = t;
	                    break;
	                } else if (!rel_touch && is_released) {
	                    rel_touch = t;
	                    rel_touch.identifier = touch.identifier;
	                }
	            }

	            var result_touch = cur_touch || rel_touch;
	            if (result_touch) {
	                var canvas_xy = m_cont.client_to_canvas_coords(
	                        touches[i].clientX, touches[i].clientY, _vec2_tmp);

	                result_touch.is_updated = false;
	                result_touch.touch_state = INPUT_STATE_01;
	                result_touch.coord[0] = canvas_xy[0];
	                result_touch.coord[1] = canvas_xy[1];
	            }
	        }
	    };

	    accumulator.touch_select_end_cb = function(touches) {
	        for (var i = 0; i < accumulator.touch_select_dlist.length; ++i) {
	            var touch_select = accumulator.touch_select_dlist[i];
	            var found = false;
	            for (var j = 0; j < touches.length; ++j) {
	                var touch = touches[j];
	                if (touch.identifier == touch_select.identifier) {
	                    found = true;
	                    break;
	                }
	            }

	            if (!found) {
	                if (touch_select.touch_state != INPUT_STATE_00)
	                    touch_select.touch_state = INPUT_STATE_10;
	                touch_select.obj = null;
	            }
	        }
	    };

	    accumulator.mouse_up_which_cb = function(wd) {
	        var device = m_input.get_device_by_type_element(m_input.DEVICE_MOUSE,
	                accumulator.element);
	        var loc = m_input.get_vector_param(device, m_input.MOUSE_LOCATION, _vec2_tmp);
	        accumulator.mouse_last_x = loc[0];
	        accumulator.mouse_last_y = loc[1];
	        accumulator.mouse_curr_x = loc[0];
	        accumulator.mouse_curr_y = loc[1];
	        if (accumulator.mouse_state != INPUT_STATE_00)
	            accumulator.mouse_state = INPUT_STATE_10;
	        accumulator.which = wd;
	    };

	    accumulator.mouse_location_cb = function(location) {
	        if (!cfg_dft.ie11_edge_touchscreen_hack || accumulator.mouse_state != INPUT_STATE_00) {
	            accumulator.mouse_curr_x = location[0];
	            accumulator.mouse_curr_y = location[1];
	        }
	    };

	    accumulator.pointerlock_cb = function(location) {
	        accumulator.pointerlock_dx += location[0];
	        accumulator.pointerlock_dy += location[1];
	    };

	    accumulator.keyboard_down_keys_cb = function(key) {
	        if (accumulator.downed_keys[key] != INPUT_STATE_11) {
	            accumulator.downed_keys[key] = INPUT_STATE_01;
	            accumulator.is_updated_keyboard = false;
	        }
	    };

	    accumulator.keyboard_down_mod_keys_cb = function(key) {
	        for(var i = 0; i < accumulator.downed_keys.length; i++)
	            if (accumulator.downed_keys[i] != INPUT_STATE_00) {
	                accumulator.downed_keys[i] = INPUT_STATE_10;
	                accumulator.is_updated_keyboard = false;
	            }
	    };

	    accumulator.keyboard_up_keys_cb = function(key) {
	        accumulator.is_updated_keyboard = false;
	        accumulator.downed_keys[key] = INPUT_STATE_10;
	    };

	    accumulator.touch_start_cb = function(touches) {
	        accumulator.is_touch_ended = false;

	        if (touches.length == 1) {
	            // reset coords from last touch session
	            accumulator.touches_last_x[0] = touches[0].clientX;
	            accumulator.touches_last_x[1] = -1;
	            accumulator.touches_last_y[0] = touches[0].clientY;
	            accumulator.touches_last_y[1] = -1;

	        } else if (touches.length > 1) {
	            var zoom_dist = touch_zoom_dist(touches);
	            accumulator.touch_zoom_curr_dist = accumulator.touch_zoom_last_dist = zoom_dist;

	            // reset coords from last touch session
	            accumulator.touches_last_x[0] = touches[0].clientX;
	            accumulator.touches_last_x[1] = touches[1].clientX;
	            accumulator.touches_last_y[0] = touches[0].clientY;
	            accumulator.touches_last_y[1] = touches[1].clientY;

	            accumulator.touch_start_rot = touch_rotation(touches);
	        }

	        // reset coords from last touch session
	        accumulator.touches_curr_x.set(accumulator.touches_last_x);
	        accumulator.touches_curr_y.set(accumulator.touches_last_y);
	    };

	    accumulator.touch_move_cb = function(touches) {
	        if (touches.length === 1) { // panning
	            accumulator.touches_curr_x[0] = touches[0].clientX;
	            accumulator.touches_curr_x[1] = -1;
	            accumulator.touches_curr_y[0] = touches[0].clientY;
	            accumulator.touches_curr_y[1] = -1;
	        } else if (touches.length > 1) {
	            accumulator.touches_curr_x[0] = touches[0].clientX;
	            accumulator.touches_curr_x[1] = touches[1].clientX;
	            accumulator.touches_curr_y[0] = touches[0].clientY;
	            accumulator.touches_curr_y[1] = touches[1].clientY;

	            var zoom_dist = touch_zoom_dist(touches);

	            accumulator.touch_zoom_curr_dist = zoom_dist;
	        }
	    };

	    accumulator.touch_end_cb = function(touches) {
	        if (touches.length == 0)
	            accumulator.is_touch_ended = true;
	    };

	    _accumulators_cache.push(accumulator);
	    return accumulator;
	}

	function register_accum_value(accum, value_name) {
	    if (value_name in accum.registered_accum_values &&
	            accum.registered_accum_values[value_name] > 0) {
	        accum.registered_accum_values[value_name] += 1;
	        return;
	    }

	    accum.registered_accum_values[value_name] = 1;
	    switch (value_name) {
	    case "orientation_quat":
	        var device = m_input.get_device_by_type_element(m_input.DEVICE_GYRO);
	        if (device)
	            m_input.attach_param_cb(device, m_input.GYRO_ORIENTATION_ANGLES,
	                    accum.orientation_quat_cb);
	        break;
	    case "orientation_angles":
	        var device = m_input.get_device_by_type_element(m_input.DEVICE_GYRO);
	        if (device)
	            m_input.attach_param_cb(device, m_input.GYRO_ORIENTATION_ANGLES,
	                    accum.orientation_angles_cb);
	        break;
	    case "mouse_wheel":
	        var device = m_input.get_device_by_type_element(m_input.DEVICE_MOUSE,
	                accum.element);
	        if (device)
	            m_input.attach_param_cb(device, m_input.MOUSE_WHEEL,
	                    accum.mouse_wheel_cb);
	        break;
	    case "mouse_down_which":
	        var device = m_input.get_device_by_type_element(m_input.DEVICE_MOUSE,
	                accum.element);
	        if (device)
	            m_input.attach_param_cb(device, m_input.MOUSE_DOWN_WHICH,
	                    accum.mouse_down_which_cb);
	        break;
	    case "mouse_select":
	        var device = m_input.get_device_by_type_element(m_input.DEVICE_MOUSE,
	                accum.element);
	        if (device)
	            m_input.attach_param_cb(device, m_input.MOUSE_DOWN_WHICH,
	                    accum.mouse_select_cb);
	        break;
	    case "touch_select":
	        var device = m_input.get_device_by_type_element(m_input.DEVICE_TOUCH,
	                accum.element);
	        if (device) {
	            m_input.attach_param_cb(device, m_input.TOUCH_START,
	                    accum.touch_select_start_cb);
	            m_input.attach_param_cb(device, m_input.TOUCH_END,
	                    accum.touch_select_end_cb);
	        }
	        break;
	    case "mouse_up_which":
	        var device = m_input.get_device_by_type_element(m_input.DEVICE_MOUSE,
	                accum.element);
	        if (device)
	            m_input.attach_param_cb(device, m_input.MOUSE_UP_WHICH,
	                    accum.mouse_up_which_cb);
	        break;
	    case "mouse_location":
	        var device = m_input.get_device_by_type_element(m_input.DEVICE_MOUSE,
	                accum.element);
	        if (device)
	            m_input.attach_param_cb(device, m_input.MOUSE_LOCATION,
	                    accum.mouse_location_cb);
	        break;
	    case "mouse_pointerlock":
	        var device = m_input.get_device_by_type_element(m_input.DEVICE_MOUSE,
	                accum.element);
	        if (device)
	            m_input.attach_param_cb(device, m_input.MOUSE_LOCATION_PL,
	                    accum.pointerlock_cb);
	        break;
	    case "keyboard_downed_keys":
	        var device = m_input.get_device_by_type_element(m_input.DEVICE_KEYBOARD,
	                accum.element);
	        if (device) {
	            m_input.attach_param_cb(device, m_input.KEYBOARD_DOWN,
	                    accum.keyboard_down_keys_cb);
	            m_input.attach_param_cb(device, m_input.KEYBOARD_DOWN_MODIFIED,
	                    accum.keyboard_down_mod_keys_cb);
	            m_input.attach_param_cb(device, m_input.KEYBOARD_UP,
	                    accum.keyboard_up_keys_cb);
	        }
	        break;
	    case "touch_start":
	        var device = m_input.get_device_by_type_element(m_input.DEVICE_TOUCH,
	                accum.element);
	        if (device)
	            m_input.attach_param_cb(device, m_input.TOUCH_START,
	                    accum.touch_start_cb);
	        break;
	    case "touch_move":
	        var device = m_input.get_device_by_type_element(m_input.DEVICE_TOUCH,
	                accum.element);
	        if (device)
	            m_input.attach_param_cb(device, m_input.TOUCH_MOVE,
	                    accum.touch_move_cb);
	        break;
	    case "touch_end":
	        var device = m_input.get_device_by_type_element(m_input.DEVICE_TOUCH,
	                accum.element);
	        if (device)
	            m_input.attach_param_cb(device, m_input.TOUCH_END,
	                    accum.touch_end_cb);
	        break;
	    }
	}

	function unregister_accum_value(accum, value_name) {
	    if (!(value_name in accum.registered_accum_values))
	        return
	    else
	        if (accum.registered_accum_values[value_name] > 0) {
	            accum.registered_accum_values[value_name] -= 1;
	            if (accum.registered_accum_values[value_name])
	                return;
	        } else
	            return;

	    switch (value_name) {
	    case "orientation_quat":
	        var device = m_input.get_device_by_type_element(m_input.DEVICE_GYRO);
	        if (device)
	            m_input.detach_param_cb(device, m_input.GYRO_ORIENTATION_QUAT,
	                    accum.orientation_quat_cb);
	        break;
	    case "orientation_angles":
	        var device = m_input.get_device_by_type_element(m_input.DEVICE_GYRO);
	        if (device)
	            m_input.detach_param_cb(device, m_input.GYRO_ORIENTATION_ANGLES,
	                    accum.orientation_angles_cb);
	        break;
	    case "mouse_wheel":
	        var device = m_input.get_device_by_type_element(m_input.DEVICE_MOUSE,
	                accum.element);
	        if (device)
	            m_input.detach_param_cb(device, m_input.MOUSE_WHEEL,
	                    accum.mouse_wheel_cb);
	        break;
	    case "mouse_down_which":
	        var device = m_input.get_device_by_type_element(m_input.DEVICE_MOUSE,
	                accum.element);
	        if (device)
	            m_input.detach_param_cb(device, m_input.MOUSE_DOWN_WHICH,
	                    accum.mouse_down_which_cb);
	        break;
	    case "mouse_select":
	        var device = m_input.get_device_by_type_element(m_input.DEVICE_MOUSE,
	                accum.element);
	        if (device)
	            m_input.detach_param_cb(device, m_input.MOUSE_DOWN_WHICH,
	                    accum.mouse_select_cb);
	        break;
	    case "touch_select":
	        var device = m_input.get_device_by_type_element(m_input.DEVICE_TOUCH,
	                accum.element);
	        if (device) {
	            m_input.detach_param_cb(device, m_input.TOUCH_START,
	                    accum.touch_select_start_cb);
	            m_input.detach_param_cb(device, m_input.TOUCH_END,
	                    accum.touch_select_end_cb);
	        }
	        break;
	    case "mouse_up_which":
	        var device = m_input.get_device_by_type_element(m_input.DEVICE_MOUSE,
	                accum.element);
	        if (device)
	            m_input.detach_param_cb(device, m_input.MOUSE_UP_WHICH,
	                    accum.mouse_up_which_cb);
	        break;
	    case "mouse_location":
	        var device = m_input.get_device_by_type_element(m_input.DEVICE_MOUSE,
	                accum.element);
	        if (device)
	            m_input.detach_param_cb(device, m_input.MOUSE_LOCATION,
	                    accum.mouse_location_cb);
	        break;
	    case "mouse_pointerlock":
	        var device = m_input.get_device_by_type_element(m_input.DEVICE_MOUSE,
	                accum.element);
	        if (device)
	            m_input.detach_param_cb(device, m_input.MOUSE_LOCATION_PL,
	                    accum.pointerlock_cb);
	        break;
	    case "keyboard_downed_keys":
	        var device = m_input.get_device_by_type_element(m_input.DEVICE_KEYBOARD,
	                accum.element);
	        if (device) {
	            m_input.detach_param_cb(device, m_input.KEYBOARD_DOWN,
	                    accum.keyboard_down_keys_cb);
	            m_input.detach_param_cb(device, m_input.KEYBOARD_DOWN_MODIFIED,
	                    accum.keyboard_down_mod_keys_cb);
	            m_input.detach_param_cb(device, m_input.KEYBOARD_UP,
	                    accum.keyboard_up_keys_cb);
	        }
	        break;
	    case "touch_start":
	        var device = m_input.get_device_by_type_element(m_input.DEVICE_TOUCH,
	                accum.element);
	        if (device)
	            m_input.detach_param_cb(device, m_input.TOUCH_START,
	                    accum.touch_start_cb);
	        break;
	    case "touch_move":
	        var device = m_input.get_device_by_type_element(m_input.DEVICE_TOUCH,
	                accum.element);
	        if (device)
	            m_input.detach_param_cb(device, m_input.TOUCH_MOVE,
	                    accum.touch_move_cb);
	        break;
	    case "touch_end":
	        var device = m_input.get_device_by_type_element(m_input.DEVICE_TOUCH,
	                accum.element);
	        if (device)
	            m_input.detach_param_cb(device, m_input.TOUCH_END,
	                    accum.touch_end_cb);
	        break;
	    }
	}

	exports.create_keyboard_sensor = function(key) {
	    var element = document;
	    var sensor = init_sensor(ST_KEYBOARD, element);
	    sensor.key = key;
	    sensor.do_activation = true;
	    return sensor;
	};

	exports.create_gamepad_btn_sensor = function(btn, id) {
	    var element = document;
	    var sensor = init_sensor(ST_GAMEPAD_BTNS, element);

	    id = id || m_input.get_first_gmpd_id();
	    sensor.gamepad_id = id;
	    sensor.key = btn;
	    sensor.do_activation = true;
	    return sensor;
	};

	exports.create_gamepad_axis_sensor = function(axis, id) {
	    var element = document;
	    var sensor = init_sensor(ST_GMPD_AXIS, element);

	    id = id == undefined ? m_input.get_first_gmpd_id() : id;
	    sensor.gamepad_id = id;
	    sensor.key = axis;
	    sensor.do_activation = true;
	    return sensor;
	};

	exports.create_gamepad_position_sensor = function(id) {
	    var element = document;
	    var sensor = init_sensor(ST_GAMEPAD_POSITION, element);

	    id = id === undefined ? m_input.get_first_gmpd_id() : id;

	    sensor.gamepad_id = id;
	    sensor.do_activation = true;
	    sensor.payload = m_vec3.create();
	    return sensor;
	};

	exports.create_gamepad_orientation_sensor = function(id) {
	    var element = document;
	    var sensor = init_sensor(ST_GAMEPAD_ORIENTATION, element);

	    id = id === undefined ? m_input.get_first_gmpd_id() : id;

	    sensor.gamepad_id = id;
	    sensor.do_activation = true;
	    sensor.payload = m_quat.create();
	    return sensor;
	};

	exports.create_collision_sensor = function(obj, collision_id,
	                                           calc_pos_norm) {
	    if (!(obj && m_phy.obj_has_physics(obj))) {
	        m_print.error("Wrong collision object");
	        return null;
	    }

	    var sensor = init_sensor(ST_COLLISION);
	    sensor.collision_obj = obj;
	    sensor.collision_id = collision_id;
	    sensor.calc_pos_norm = calc_pos_norm;

	    sensor.payload = {
	        coll_obj: null,
	        coll_pos: calc_pos_norm ? new Float32Array(3) : null,
	        coll_norm: calc_pos_norm ? new Float32Array(3) : null,
	        coll_dist: 0
	    };

	    sensor.collision_cb = function(is_collision, coll_obj, coll_pos, coll_norm, coll_dist) {
	        sensor_set_value(sensor, is_collision);

	        var payload = sensor.payload;

	        payload.coll_obj = coll_obj;

	        if (sensor.calc_pos_norm) {
	            payload.coll_pos.set(coll_pos);
	            payload.coll_norm.set(coll_norm);
	            payload.coll_dist = coll_dist;
	        }
	    };
	    sensor.do_activation = true;

	    return sensor;
	};

	exports.create_collision_impulse_sensor = function(obj) {
	    if (!(obj && obj.physics)) {
	        m_print.error("Wrong collision impulse object");
	        return null;
	    }

	    var sensor = init_sensor(ST_COLLISION_IMPULSE);
	    sensor.col_imp_obj = obj;
	    sensor.col_imp_cb = function(impulse) {
	        sensor_set_value(sensor, impulse);
	    };
	    sensor.do_activation = true;

	    return sensor;
	};

	exports.create_ray_sensor = function(obj_src, from, to, collision_id,
	        is_binary_value, calc_pos_norm, ign_src_rot) {

	    var sensor = init_sensor(ST_RAY);
	    sensor.source_object = obj_src;
	    sensor.from = from;
	    sensor.to = to;
	    sensor.collision_id = collision_id;
	    sensor.is_binary_value = is_binary_value;
	    sensor.calc_pos_norm = calc_pos_norm;
	    sensor.ign_src_rot = ign_src_rot;

	    sensor.payload = {
	        hit_fract: 0,
	        obj_hit: null,
	        hit_time: 0,
	        hit_pos: new Float32Array(3),
	        hit_norm: new Float32Array(3),
	        ray_test_id: 0
	    };

	    sensor.ray_test_cb = function(id, hit_fract, obj_hit, hit_time,
	            hit_pos, hit_norm) {
	        if (sensor.is_binary_value)
	            sensor_set_value(sensor, hit_fract == -1 ? 0 : 1);
	        else
	            sensor_set_value(sensor, hit_fract);

	        sensor.payload.hit_fract = hit_fract;
	        sensor.payload.obj_hit = obj_hit;
	        sensor.payload.hit_time = hit_time;

	        if (sensor.calc_pos_norm) {
	            sensor.payload.hit_pos.set(hit_pos);
	            sensor.payload.hit_norm.set(hit_norm);
	        }
	    };
	    sensor.do_activation = true;

	    return sensor;
	};

	exports.create_mouse_click_sensor = function(element) {
	    var sensor = init_sensor(ST_MOUSE_CLICK, element);
	    sensor.do_activation = true;
	    sensor.payload = {coords: new Float32Array(2), which: null};
	    return sensor;
	};

	exports.create_mouse_wheel_sensor = function(element) {
	    var sensor = init_sensor(ST_MOUSE_WHEEL, element);
	    sensor.do_activation = true;
	    return sensor;
	};

	exports.create_mouse_move_sensor = function(axis, element) {
	    var sensor = init_sensor(ST_MOUSE_MOVE, element);
	    sensor.axis = axis || "XY";
	    sensor.payload = {coords: new Float32Array(2)};
	    sensor.do_activation = true;
	    return sensor;
	};

	exports.create_touch_move_sensor = function(axis, element) {
	    var sensor = init_sensor(ST_TOUCH_MOVE, element);
	    sensor.axis = axis || "XY";
	    sensor.payload = {coords: new Float32Array(2), gesture: 0};
	    sensor.do_activation = true;
	    return sensor;
	};

	exports.create_touch_zoom_sensor = function(element) {
	    var sensor = init_sensor(ST_TOUCH_ZOOM, element);
	    sensor.payload = 0;
	    sensor.do_activation = true;
	    return sensor;
	};

	exports.create_touch_rotate_sensor = function(element) {
	    var sensor = init_sensor(ST_TOUCH_ROTATE, element);
	    sensor.payload = 0;
	    sensor.do_activation = true;
	    return sensor;
	};

	exports.create_touch_click_sensor = function(element) {
	    var sensor = init_sensor(ST_TOUCH_CLICK, element);
	    sensor.payload = {coords: new Float32Array(2)};
	    sensor.do_activation = true;
	    return sensor;
	};

	exports.create_motion_sensor = function(obj, threshold, rotation_threshold) {

	    if (!obj) {
	        m_print.error("Wrong collision object");
	        return null;
	    }

	    var sensor = init_sensor(ST_MOTION);

	    sensor.source_object = obj;

	    var trans = m_tsr.get_trans_view(obj.render.world_tsr);
	    var quat = m_tsr.get_quat_view(obj.render.world_tsr);

	    sensor.quat_temp = new Float32Array(4);
	    sensor.trans_last = new Float32Array(trans);
	    sensor.quat_last = new Float32Array(quat);

	    sensor.avg_linear_vel = 0;
	    sensor.avg_angular_vel = 0;

	    sensor.threshold = threshold || 0.1;
	    sensor.rotation_threshold = rotation_threshold || 0.1;

	    sensor.time_last = 0.0;

	    sensor.payload = new Float32Array([0, 0]);

	    return sensor;
	};

	exports.create_vertical_velocity_sensor = function(obj, threshold) {

	    if (!obj) {
	        m_print.error("Wrong collision object");
	        return null;
	    }

	    var sensor = init_sensor(ST_V_VELOCITY);

	    sensor.source_object = obj;

	    var trans = m_tsr.get_trans_view(obj.render.world_tsr);
	    var quat = m_tsr.get_quat_view(obj.render.world_tsr);

	    sensor.trans_last = new Float32Array(trans);
	    sensor.quat_last = new Float32Array(quat);

	    sensor.avg_vertical_vel = 0;

	    sensor.threshold = threshold || 1.0;
	    sensor.time_last = 0.0;

	    sensor.payload = 0;

	    return sensor;
	};

	exports.create_timer_sensor = function(period, do_repeat) {
	    var sensor = init_sensor(ST_TIMER);
	    // period < 0 for expired timer
	    sensor.period = period;
	    sensor.repeat = do_repeat;
	    sensor.do_activation = true;
	    return sensor;
	};

	exports.reset_timer_sensor = function(obj, manifold_id, num, period) {
	    obj = obj || _global_object;

	    var manifolds = obj.sensor_manifolds;

	    if (!manifolds || !manifolds[manifold_id]) {
	        m_print.error("reset_timer_sensor(): wrong object");
	        return null;
	    }

	    var sensor = manifolds[manifold_id].sensors[num];
	    if (!sensor) {
	        m_print.error("reset_timer_sensor(): sensor not found");
	        return null;
	    }

	    sensor.time_last = m_time.get_timeline();
	    sensor.period = period;
	};

	exports.create_elapsed_sensor = function() {
	    var sensor = init_sensor(ST_ELAPSED);
	    sensor.time_last = 0.0;
	    return sensor;
	};

	exports.create_gyro_delta_sensor = function() {
	    var sensor = init_sensor(ST_GYRO_DELTA, window);
	    sensor.payload = new Float32Array(3);
	    var device = m_input.get_device_by_type_element(m_input.DEVICE_GYRO);
	    if (device)
	        sensor_set_value(sensor, 1);
	    else
	        sensor_set_value(sensor, 0);
	    sensor.do_activation = true;
	    return sensor;
	};

	exports.create_gyro_angles_sensor = function() {
	    var sensor = init_sensor(ST_GYRO_ANGLES, window);
	    sensor.payload = new Float32Array(3);
	    var device = m_input.get_device_by_type_element(m_input.DEVICE_GYRO);
	    if (device)
	        sensor_set_value(sensor, 1);
	    else
	        sensor_set_value(sensor, 0);
	    sensor.do_activation = true;
	    return sensor;
	};

	exports.create_gyro_quat_sensor = function() {
	    var sensor = init_sensor(ST_GYRO_QUAT, window);
	    sensor.payload = m_quat.create();
	    var device = m_input.get_device_by_type_element(m_input.DEVICE_GYRO);
	    if (device)
	        sensor_set_value(sensor, 1);
	    else
	        sensor_set_value(sensor, 0);
	    sensor.do_activation = true;
	    return sensor;
	};

	exports.create_hmd_quat_sensor = function() {
	    var sensor = init_sensor(ST_HMD_QUAT, window);
	    sensor.payload = m_quat.create();
	    var device = m_input.get_device_by_type_element(m_input.DEVICE_HMD);
	    if (device)
	        sensor_set_value(sensor, 1);
	    else
	        sensor_set_value(sensor, 0);
	    sensor.do_activation = true;
	    return sensor;
	};

	exports.create_hmd_position_sensor = function() {
	    var sensor = init_sensor(ST_HMD_POSITION, window);
	    sensor.payload = m_vec3.create();
	    var device = m_input.get_device_by_type_element(m_input.DEVICE_HMD);
	    if (device)
	        sensor_set_value(sensor, 1);
	    else
	        sensor_set_value(sensor, 0);
	    sensor.do_activation = true;
	    return sensor;
	};

	exports.create_timeline_sensor = function() {
	    var sensor = init_sensor(ST_TIMELINE);
	    return sensor;
	};

	exports.create_selection_sensor = function(obj, enable_toggle_switch) {
	    var sensor = init_sensor(ST_SELECTION);
	    sensor.source_object = obj;
	    sensor.enable_toggle_switch = enable_toggle_switch;
	    sensor.do_activation = true;
	    return sensor;
	};

	exports.create_callback_sensor = function(callback, value) {
	    var sensor = init_sensor(ST_CALLBACK);
	    sensor.callback = callback;
	    sensor_set_value(sensor, value);
	    return sensor;
	};

	exports.create_plock_mouse_sensor = function(element) {
	    var sensor = init_sensor(ST_PLOCK_MOUSE_MOVE, element);
	    sensor.payload = {coords: new Float32Array(2)};
	    sensor.do_activation = true;
	    return sensor;
	};

	exports.create_plock_sensor = function(element) {
	    var sensor = init_sensor(ST_PLOCK, element);
	    sensor.do_activation = true;
	    return sensor;
	};

	exports.sensor_set_value = sensor_set_value;
	function sensor_set_value(sensor, value) {
	    sensor.value = Number(value);
	}

	function manifold_logic_result(manifold) {
	    // update sensor values before passing them to logic function
	    // NOTE: maybe it's happening too often
	    var sensors = manifold.sensors;
	    var values = manifold.sensor_values;
	    for (var i = 0; i < sensors.length; i++)
	        values[i] = sensors[i].value;
	    var logic_result = manifold.logic_fun(values);

	    return logic_result;
	}

	exports.get_sensor_value = function(obj, manifold_id, num) {
	    obj = obj || _global_object;

	    var manifolds = obj.sensor_manifolds;

	    if (!manifolds || !manifolds[manifold_id]) {
	        m_print.error("get_sensor_value(): wrong object");
	        return null;
	    }

	    var sensor = manifolds[manifold_id].sensors[num];
	    if (!sensor) {
	        m_print.error("get_sensor_value(): sensor not found");
	        return null;
	    }

	    return sensor.value;
	};

	exports.get_sensor_payload = function(obj, manifold_id, num) {
	    obj = obj || _global_object;

	    var manifolds = obj.sensor_manifolds;

	    if (!manifolds || !manifolds[manifold_id]) {
	        m_print.error("get_sensor_payload(): wrong object");
	        return null;
	    }

	    var sensor = manifolds[manifold_id].sensors[num];
	    if (!sensor) {
	        m_print.error("get_sensor_payload(): sensor not found");
	        return null;
	    }
	    return sensor.payload;
	};

	/**
	 * uses _vec2_tmp _vec2_tmp2 _vec3_tmp _quat_tmp
	 */
	function update_sensor(sensor, timeline, elapsed) {
	    if (!elapsed)
	        return;

	    switch (sensor.type) {
	    case ST_MOTION:
	        var obj = sensor.source_object;

	        var trans = m_tsr.get_trans(obj.render.world_tsr, _vec3_tmp);
	        var quat = m_tsr.get_quat(obj.render.world_tsr, _quat_tmp);

	        var dist = m_vec3.dist(sensor.trans_last, trans);

	        var quat_temp = sensor.quat_temp;

	        m_quat.invert(sensor.quat_last, quat_temp);
	        m_quat.multiply(quat, quat_temp, quat_temp);
	        m_quat.normalize(quat_temp, quat_temp);
	        var angle = Math.abs(2 * Math.acos(quat_temp[3]));

	        var linear_vel = dist / elapsed;
	        sensor.avg_linear_vel = m_util.smooth(linear_vel, sensor.avg_linear_vel,
	                elapsed, SENSOR_SMOOTH_PERIOD);
	        sensor.payload[0] = linear_vel;

	        var angular_vel = angle / elapsed;
	        sensor.avg_angular_vel = m_util.smooth(angular_vel,
	                sensor.avg_angular_vel, elapsed, SENSOR_SMOOTH_PERIOD);
	        sensor.payload[1] = angular_vel;

	        if (sensor.avg_linear_vel >= sensor.threshold || sensor.avg_angular_vel
	                >= sensor.rotation_threshold)
	            sensor_set_value(sensor, 1);
	        else
	            sensor_set_value(sensor, 0);

	        m_vec3.copy(trans, sensor.trans_last);
	        m_quat.copy(quat, sensor.quat_last);

	        sensor.time_last = timeline;
	        break;

	    case ST_V_VELOCITY:
	        var obj = sensor.source_object;
	        var trans = m_tsr.get_trans(obj.render.world_tsr, _vec3_tmp);

	        var vel = Math.abs(trans[1] - sensor.trans_last[1]) / elapsed;
	        sensor.avg_vertical_vel = m_util.smooth(vel, sensor.avg_vertical_vel,
	                elapsed, SENSOR_SMOOTH_PERIOD);
	        sensor.payload = vel;

	        if (sensor.avg_vertical_vel >= sensor.threshold)
	            sensor_set_value(sensor, 1);
	        else
	            sensor_set_value(sensor, 0);

	        m_vec3.copy(trans, sensor.trans_last);

	        sensor.time_last = timeline;
	        break;

	    case ST_TIMER:
	        if (!sensor.do_activation && sensor.period >= 0 &&
	                (timeline - sensor.time_last) >= sensor.period) {
	            sensor_set_value(sensor, 1);
	            if (sensor.repeat) {
	                sensor.time_last = timeline;
	            } else {
	                sensor.period = -sensor.period;
	            }
	        }
	        break;

	    case ST_ELAPSED:
	        if (!sensor.time_last) {
	            sensor.time_last = timeline;
	        }

	        sensor_set_value(sensor, timeline - sensor.time_last);
	        sensor.time_last = timeline;
	        break;

	    case ST_TIMELINE:
	        sensor_set_value(sensor, timeline);
	        break;

	    case ST_GYRO_DELTA:
	        var accum = get_accumulator(sensor.element);
	        sensor.payload[0] = accum.gyro_gamma_new - accum.gyro_gamma_last;
	        sensor.payload[1] = accum.gyro_beta_new - accum.gyro_beta_last;
	        sensor.payload[2] = accum.gyro_alpha_new - accum.gyro_alpha_last;
	        break;

	    case ST_GYRO_ANGLES:
	        var accum = get_accumulator(sensor.element);
	        sensor.payload[0] = accum.gyro_gamma_new;
	        sensor.payload[1] = accum.gyro_beta_new;
	        sensor.payload[2] = accum.gyro_alpha_new;
	        break;

	    case ST_GYRO_QUAT:
	        var accum = get_accumulator(sensor.element);
	        m_quat.copy(accum.gyro_quat, sensor.payload);
	        break;

	    case ST_HMD_QUAT:
	        var device = m_input.get_device_by_type_element(m_input.DEVICE_HMD);
	        m_input.get_vector_param(device, m_input.HMD_ORIENTATION_QUAT, sensor.payload);
	        break;

	    case ST_HMD_POSITION:
	        var device = m_input.get_device_by_type_element(m_input.DEVICE_HMD);
	        m_input.get_vector_param(device, m_input.HMD_POSITION, sensor.payload);
	        break;

	    case ST_GAMEPAD_BTNS:
	        var device = get_gmpd_device_by_id(sensor.gamepad_id);
	        sensor.value = m_input.get_gamepad_btn_value(device, sensor.key);
	        break;
	    case ST_GMPD_AXIS:
	        var device = get_gmpd_device_by_id(sensor.gamepad_id);
	        sensor.value = m_input.get_gamepad_axis_value(device, sensor.key);
	        break;
	    case ST_GAMEPAD_POSITION:
	        var device = get_gmpd_device_by_id(sensor.gamepad_id);
	        m_input.get_gamepad_position(device, sensor.payload);
	        sensor_set_value(sensor, 1);
	        break;
	    case ST_GAMEPAD_ORIENTATION:
	        var device = get_gmpd_device_by_id(sensor.gamepad_id);
	        m_input.get_gamepad_orientation(device, sensor.payload);
	        sensor_set_value(sensor, 1);
	        break;
	    case ST_CALLBACK:
	        sensor_set_value(sensor, sensor.callback());
	        break;

	    case ST_MOUSE_WHEEL:
	        var accum = get_accumulator(sensor.element);
	        sensor_set_value(sensor, accum.wheel_delta);
	        break;
	    case ST_MOUSE_MOVE:
	        var accum = get_accumulator(sensor.element);
	        if (!cfg_dft.ie11_edge_touchscreen_hack ||
	                accum.mouse_state == INPUT_STATE_01 || accum.mouse_state == INPUT_STATE_11) {
	            var delta_x = accum.mouse_curr_x - accum.mouse_last_x;
	            var delta_y = accum.mouse_curr_y - accum.mouse_last_y;

	            sensor.payload.coords[0] = accum.mouse_curr_x;
	            sensor.payload.coords[1] = accum.mouse_curr_y;
	            switch (sensor.axis) {
	            case "X":
	                sensor_set_value(sensor, delta_x);
	                break;
	            case "Y":
	                sensor_set_value(sensor, delta_y);
	                break;
	            case "XY":
	                var delta = Math.sqrt(delta_x*delta_x + delta_y*delta_y);
	                sensor_set_value(sensor, delta);
	                break;
	            }
	        }
	        break;
	    case ST_PLOCK_MOUSE_MOVE:
	        var accum = get_accumulator(sensor.element);

	        var delta_x = accum.pointerlock_dx;
	        var delta_y = accum.pointerlock_dy;

	        var rot_x = m_util.smooth(delta_x, 0,
	                elapsed, smooth_coeff_mouse());
	        var rot_y = m_util.smooth(delta_y, 0,
	                elapsed, smooth_coeff_mouse());

	        if (Math.abs(delta_x) > MOUSE_DELTA_THRESHOLD ||
	                Math.abs(delta_y) > MOUSE_DELTA_THRESHOLD) {
	            accum.pointerlock_dx -= rot_x;
	            accum.pointerlock_dy -= rot_y;
	            sensor.payload.coords[0] = rot_x;
	            sensor.payload.coords[1] = rot_y;
	        } else {
	            sensor.payload.coords[0] = 0.0;
	            sensor.payload.coords[1] = 0.0;
	        }
	        sensor_set_value(sensor, Math.sqrt(delta_x*delta_x + delta_y*delta_y));
	        break;
	    case ST_MOUSE_CLICK:
	        var accum = get_accumulator(sensor.element);
	        sensor_set_value(sensor, (accum.mouse_state != INPUT_STATE_00) | 0);
	        sensor.payload.which = accum.which;
	        sensor.payload.coords[0] = accum.mouse_curr_x;
	        sensor.payload.coords[1] = accum.mouse_curr_y;
	        break;
	    case ST_SELECTION:
	        var accum = get_accumulator(sensor.element);
	        sensor_set_value(sensor, 0);
	        if (!sensor.enable_toggle_switch) {
	            if ((accum.mouse_state != INPUT_STATE_00) &&
	                    accum.mouse_select_data.obj == sensor.source_object)
	                sensor_set_value(sensor, 1);
	            else {
	                for (var i = 0; i < MAX_COUNT_FINGERS; ++i) {
	                    var touch_data = accum.touch_select_dlist[i];
	                    if (touch_data.touch_state != INPUT_STATE_00 &&
	                         touch_data.obj == sensor.source_object) {
	                        sensor_set_value(sensor, 1);
	                        break;
	                    }
	                }
	            }
	        } else
	            if (accum.global_selected_obj == sensor.source_object)
	                sensor_set_value(sensor, 1);
	        break;
	    case ST_KEYBOARD:
	        var accum = get_accumulator(sensor.element);

	        // NOTE: accum.downed_keys[0] && sensor.key == KEY_SHIFT --- hack to
	        // prevent wrong keyup with chrome/webkit
	        sensor.payload = accum.downed_keys[sensor.key];
	        if (sensor.payload == 1 || accum.downed_keys[0] && sensor.key == KEY_SHIFT)
	            sensor_set_value(sensor, 1);
	        else if (!sensor.payload)
	            sensor_set_value(sensor, 0);
	        break;
	    case ST_TOUCH_MOVE:
	        var accum = get_accumulator(sensor.element);

	        if (accum.touches_curr_x[1] == -1 && accum.touches_curr_y[1] == -1) {
	            var delta_x = (accum.touches_curr_x[0] - accum.touches_last_x[0]);
	            var delta_y = (accum.touches_curr_y[0] - accum.touches_last_y[0]);
	            var delta = Math.sqrt(delta_x * delta_x + delta_y * delta_y);

	            // perform calculations for secondary touch point
	            if (accum.touches_last_x[1] != -1 && accum.touches_last_y[1] != -1) {
	                var delta_second_x = (accum.touches_curr_x[0] - accum.touches_last_x[1]);
	                var delta_second_y = (accum.touches_curr_y[0] - accum.touches_last_y[1]);
	                var delta_second = Math.sqrt(delta_second_x * delta_second_x
	                        + delta_second_y * delta_second_y);

	                // use second touch point (from the last touch) if it's closer to
	                // current touch than the first point
	                if (delta_second < delta) {
	                    delta_x = delta_second_x;
	                    delta_y = delta_second_y;
	                    delta = delta_second;
	                }
	            }

	            sensor.payload.gesture = exports.PL_SINGLE_TOUCH_MOVE;
	        } else {
	            var cur_center = _vec2_tmp;
	            cur_center[0] = (accum.touches_curr_x[0] + accum.touches_curr_x[1]) / 2;
	            cur_center[1] = (accum.touches_curr_y[0] + accum.touches_curr_y[1]) / 2;

	            var last_center = _vec2_tmp2;
	            last_center[0] = (accum.touches_last_x[0] + accum.touches_last_x[1]) / 2;
	            last_center[1] = (accum.touches_last_y[0] + accum.touches_last_y[1]) / 2;

	            var delta_x = (cur_center[0] - last_center[0]);
	            var delta_y = (cur_center[1] - last_center[1]);
	            var delta = Math.sqrt(delta_x * delta_x + delta_y * delta_y);

	            sensor.payload.gesture = exports.PL_MULTITOUCH_MOVE_PAN;
	        }
	        sensor.payload.coords[0] = accum.touches_curr_x[0];
	        sensor.payload.coords[1] = accum.touches_curr_y[0];
	        switch(sensor.axis) {
	        case "X":
	            sensor_set_value(sensor, delta_x);
	            break;
	        case "Y":
	            sensor_set_value(sensor, delta_y);
	            break;
	        case "XY":
	            sensor_set_value(sensor, delta);
	            break;
	        }
	        break;
	    case ST_TOUCH_ZOOM:
	        var accum = get_accumulator(sensor.element);
	        var delta_dist = accum.touch_zoom_curr_dist - accum.touch_zoom_last_dist;
	        sensor.payload = exports.PL_MULTITOUCH_MOVE_ZOOM;
	        sensor_set_value(sensor, delta_dist);
	        break;
	    case ST_TOUCH_ROTATE:
	        var accum = get_accumulator(sensor.element);
	        if (accum.touches_curr_x[1] != -1) { // not panning
	            var x = accum.touches_curr_x[0] - accum.touches_curr_x[1],
	                y = accum.touches_curr_y[0] - accum.touches_curr_y[1];

	            var delta_rotation = Math.atan2(y,x);
	            sensor.payload = exports.PL_MULTITOUCH_MOVE_ROTATE;
	            sensor_set_value(sensor, delta_rotation - accum.touch_start_rot);
	        }
	        break;
	    case ST_TOUCH_CLICK:
	        var accum = get_accumulator(sensor.element);
	        sensor.payload.coords[0] = accum.touches_curr_x[0];
	        sensor.payload.coords[1] = accum.touches_curr_y[0];
	        if (accum.is_touch_ended)
	            sensor_set_value(sensor, 0);
	        else
	            sensor_set_value(sensor, 1);
	        break;
	    default:
	        break;
	    }
	}

	/**
	 *  1 - positive pulse
	 * -1 - negative pulse
	 *  0 - no pulse
	 */
	function manifold_gen_pulse(manifold) {

	    var pulse = 0;

	    switch (manifold.type) {
	    case exports.CT_POSITIVE:
	        var logic_result = manifold_logic_result(manifold);
	        if (logic_result)
	            pulse = 1;
	        else
	            pulse = 0;
	        break;
	    case exports.CT_CONTINUOUS:
	        var last_pulse = manifold.last_pulse;
	        var logic_result = manifold_logic_result(manifold);
	        if (logic_result) {
	            pulse = 1;
	            manifold.last_pulse = 1;
	        } else if (last_pulse == 1) {
	            pulse = -1;
	            manifold.last_pulse = -1;
	        } else
	            pulse = 0;

	        break;
	    case exports.CT_TRIGGER:
	        var last_pulse = manifold.last_pulse;
	        var logic_result = manifold_logic_result(manifold);

	        if (logic_result && last_pulse == -1) {
	            pulse = 1;
	            manifold.last_pulse = 1;
	        } else if (!logic_result && last_pulse == 1) {
	            pulse = -1;
	            manifold.last_pulse = -1;
	        } else
	            pulse = 0;

	        break;
	    case exports.CT_SHOT:
	        var last_pulse = manifold.last_pulse;
	        var logic_result = manifold_logic_result(manifold);

	        if (logic_result && last_pulse == -1) {
	            pulse = 1;
	            manifold.last_pulse = 1;
	        } else if (!logic_result && last_pulse == 1) {
	            // give no ouput, but register negative pulse
	            pulse = 0;
	            manifold.last_pulse = -1;
	        } else
	            pulse = 0;

	        break;

	    case exports.CT_LEVEL:
	        // ignore previous pulses
	        var logic_result = manifold_logic_result(manifold);

	        if (manifold.last_logic_result != logic_result) {
	            pulse = 1;
	            manifold.last_logic_result = logic_result;
	        } else
	            pulse = 0;
	        break;

	    case exports.CT_CHANGE:
	        // ignore previous pulses and logic result
	        var sensors = manifold.sensors;
	        var last_values = manifold.last_sensor_values;

	        for (var i = 0; i < sensors.length; i++) {
	            var value = sensors[i].value;

	            if (!pulse && value != last_values[i])
	                pulse = 1;

	            last_values[i] = value;
	        }

	        break;
	    default:
	        m_util.panic("Wrong sensor manifold type: " + manifold.type);
	        break;
	    }

	    return pulse;
	}

	/**
	 * Some sensors need to be discharged after pulse generation
	 */
	function discharge_sensors(sensors) {
	    for (var i = 0; i < sensors.length; i++) {
	        var sensor = sensors[i];

	        switch (sensor.type) {
	        case ST_MOUSE_WHEEL:
	            sensor_set_value(sensor, 0);
	            break;
	        case ST_MOUSE_MOVE:
	            sensor_set_value(sensor, 0);
	            break;
	        case ST_TOUCH_MOVE:
	            sensor_set_value(sensor, 0);
	            break;
	        case ST_TOUCH_ZOOM:
	            sensor_set_value(sensor, 0);
	            break;
	        case ST_TOUCH_ROTATE:
	            sensor_set_value(sensor, 0);
	            break;
	        case ST_TOUCH_CLICK:
	            sensor_set_value(sensor, 0);
	            break;
	        case ST_TIMER:
	            sensor_set_value(sensor, 0);
	            break;
	        default:
	            // do nothing
	            break;
	        }
	    }
	}

	exports.cleanup = function() {
	    _objects = [];
	    _global_object = {};

	    for (var i = 0; i < _sensors_cache.length; i++)
	        deactivate_sensor(_sensors_cache[i]);
	    _sensors_cache.length = 0;
	    _manifolds_cache.length = 0;
	};

	exports.check_sensor_manifold = function(obj, id) {
	    obj = obj || _global_object;

	    // NOTE: need to be initialized in object update routine
	    if (!obj.sensor_manifolds)
	        return false;

	    if (id && obj.sensor_manifolds[id])
	        return true;
	    else if (id)
	        return false;
	    else
	        for (var i in obj.sensor_manifolds)
	            return true;

	    return false;
	};

	exports.create_sensor_manifold = function(obj, id, type, sensors,
	        logic_fun, callback, callback_param) {
	    obj = obj || _global_object;

	    obj.sensor_manifolds_arr = obj.sensor_manifolds_arr || [];
	    obj.sensor_manifolds = obj.sensor_manifolds || {};

	    var manifolds = obj.sensor_manifolds;
	    var manifolds_arr = obj.sensor_manifolds_arr;

	    var old_manifold = manifolds[id];
	    if (old_manifold)
	        remove_sensor_manifold(obj, id);

	    var manifold = {
	        id: id,
	        type: type,
	        sensors: sensors.slice(0),

	        logic_fun: logic_fun,
	        // cache for logic function
	        sensor_values: new Array(sensors.length),

	        callback: callback,
	        callback_param: callback_param,

	        // for CONTINUOUS, TRIGGER, SHOT control type
	        last_pulse: -1,

	        // for LEVEL control type
	        last_logic_result: 0,

	        // for CHANGE control type
	        last_sensor_values: new Array(sensors.length),

	        update_counter: -1
	    };

	    manifolds[id] = manifold;
	    manifolds_arr.push(manifold);

	    if (_objects.indexOf(obj) == -1)
	        _objects.push(obj);

	    for (var i = 0; i < manifold.sensors.length; i++) {
	        var sensor = manifold.sensors[i];
	        activate_sensor(sensor);
	        var sens_ind = _sensors_cache.indexOf(sensor);
	        if (sens_ind == -1) {
	            _sensors_cache.push(sensor);
	            _manifolds_cache.push([manifold]);
	        } else
	            _manifolds_cache[sens_ind].push(manifold);
	    }

	    _manifolds_updated = true;
	};

	exports.default_AND_logic_fun = default_AND_logic_fun;
	/**
	 * Default AND logic function.
	 * @see ECMA-262: Binary Logical Operators
	 */
	function default_AND_logic_fun(s) {
	    for (var i = 0; i < s.length; i++) {
	        if (!s[i])
	            return s[i];
	    }
	    return s[s.length - 1];
	}

	/**
	 * Default OR logic function.
	 * @see ECMA-262: Binary Logical Operators
	 */
	exports.default_OR_logic_fun = function(s) {
	    for (var i = 0; i < s.length; i++) {
	        if (s[i])
	            return s[i];
	    }
	    return s[s.length - 1];
	};

	function activate_sensor(sensor) {
	    if (sensor.do_activation) {
	        switch (sensor.type) {
	        case ST_COLLISION:
	            m_phy.append_collision_test(sensor.collision_obj,
	                    sensor.collision_id, sensor.collision_cb,
	                    sensor.calc_pos_norm);
	            break;
	        case ST_COLLISION_IMPULSE:
	            m_phy.apply_collision_impulse_test(sensor.col_imp_obj,
	                    sensor.col_imp_cb);
	            break;
	        case ST_RAY:
	            sensor.ray_test_id = m_phy.append_ray_test(sensor.source_object,
	                    sensor.from, sensor.to, sensor.collision_id,
	                    sensor.ray_test_cb, false, false, sensor.calc_pos_norm,
	                    sensor.ign_src_rot);
	            // TODO: check if the next line is necessary
	            sensor.payload.ray_test_id = sensor.ray_test_id;
	            break;
	        case ST_TIMER:
	            sensor.time_last = m_time.get_timeline();
	            // reset sensor if appended again
	            if (sensor.period < 0)
	                sensor.period = -sensor.period;
	            break;
	        case ST_KEYBOARD:
	            var accumulator = get_accumulator(sensor.element);
	            register_accum_value(accumulator, "keyboard_downed_keys");
	            break;
	        case ST_MOUSE_WHEEL:
	            var accumulator = get_accumulator(sensor.element);
	            register_accum_value(accumulator, "mouse_wheel");
	            break;
	        case ST_MOUSE_MOVE:
	            var accumulator = get_accumulator(sensor.element);
	            register_accum_value(accumulator, "mouse_down_which");
	            register_accum_value(accumulator, "mouse_up_which");
	            register_accum_value(accumulator, "mouse_location");
	            break;
	        case ST_PLOCK_MOUSE_MOVE:
	            var accumulator = get_accumulator(sensor.element);
	            register_accum_value(accumulator, "mouse_pointerlock");
	            break;
	        case ST_PLOCK:
	            m_input.activate_pointerlock(sensor);
	            break;
	        case ST_MOUSE_CLICK:
	            var accumulator = get_accumulator(sensor.element);
	            register_accum_value(accumulator, "mouse_down_which");
	            register_accum_value(accumulator, "mouse_up_which");
	            break;
	        case ST_TOUCH_MOVE:
	            var accumulator = get_accumulator(sensor.element);
	            register_accum_value(accumulator, "touch_start");
	            register_accum_value(accumulator, "touch_move");
	            register_accum_value(accumulator, "touch_end");
	            break;
	        case ST_TOUCH_ZOOM:
	            var accumulator = get_accumulator(sensor.element);
	            register_accum_value(accumulator, "touch_start");
	            register_accum_value(accumulator, "touch_move");
	            break;
	        case ST_TOUCH_ROTATE:
	            var accumulator = get_accumulator(sensor.element);
	            register_accum_value(accumulator, "touch_start");
	            register_accum_value(accumulator, "touch_move");
	            break;
	        case ST_TOUCH_CLICK:
	            var accumulator = get_accumulator(sensor.element);
	            register_accum_value(accumulator, "touch_start");
	            register_accum_value(accumulator, "touch_end");
	            break;
	        case ST_SELECTION:
	            var accumulator = get_accumulator(sensor.element);
	            register_accum_value(accumulator, "mouse_select");
	            register_accum_value(accumulator, "touch_select");
	            register_accum_value(accumulator, "touch_start");
	            register_accum_value(accumulator, "touch_end");
	            register_accum_value(accumulator, "mouse_down_which");
	            register_accum_value(accumulator, "mouse_up_which");
	            break;
	        case ST_GYRO_DELTA:
	        case ST_GYRO_ANGLES:
	            var accumulator = get_accumulator(sensor.element);
	            register_accum_value(accumulator, "orientation_angles");
	            break;
	        case ST_GYRO_QUAT:
	            var accumulator = get_accumulator(sensor.element);
	            register_accum_value(accumulator, "orientation_quat");
	            break;
	        case ST_GAMEPAD_BTNS:
	        case ST_GAMEPAD_POSITION:
	        case ST_GAMEPAD_ORIENTATION:
	            if (sensor.gamepad_id == 0)
	                m_input.get_device_by_type_element(m_input.DEVICE_GAMEPAD0);
	            else if (sensor.gamepad_id == 1)
	                m_input.get_device_by_type_element(m_input.DEVICE_GAMEPAD1);
	            else if (sensor.gamepad_id == 2)
	                m_input.get_device_by_type_element(m_input.DEVICE_GAMEPAD2);
	            else
	                m_input.get_device_by_type_element(m_input.DEVICE_GAMEPAD3);
	            break;
	        }

	        sensor.do_activation = false;
	    }
	}

	exports.remove_sensor_manifold = remove_sensor_manifold;
	function remove_sensor_manifold(obj, id) {
	    obj = obj || _global_object;

	    var manifolds = obj.sensor_manifolds;
	    if (!manifolds)
	        return;

	    var manifolds_arr = obj.sensor_manifolds_arr;

	    if (id) {
	        var manifold = manifolds[id];
	        if (manifold) {
	            var sensors = manifold.sensors;

	            for (var i = 0; i < sensors.length; i++) {
	                var sensor = sensors[i];

	                var sens_users = get_sensor_users(sensor, _sensors_cache,
	                        _manifolds_cache);

	                if (sens_users.length == 1) {
	                    deactivate_sensor(sensor);
	                    var sens_ind = _sensors_cache.indexOf(sensor);
	                    if (sens_ind > -1) {
	                        _sensors_cache.splice(sens_ind, 1);
	                        _manifolds_cache.splice(sens_ind, 1);
	                    } else
	                        m_util.panic("Sensors cache is corrupted");
	                } else if (sens_users.length > 1)
	                    sens_users.splice(sens_users.indexOf(manifold), 1);
	            }

	            delete manifolds[id];

	            var man_index = manifolds_arr.indexOf(manifold);
	            if (man_index > -1)
	                manifolds_arr.splice(man_index, 1);
	            else
	                m_util.panic("Incorrect manifolds array");

	            // remove from objects if manifolds have 0 sensors
	            if (!Object.getOwnPropertyNames(manifolds).length)
	                remove_from_objects(obj);
	        }
	    } else {
	        // make a copy to ensure reliable results
	        var removed_ids = [];
	        for (var man_id in manifolds)
	            removed_ids.push(man_id);

	        for (var i = 0; i < removed_ids.length; i++)
	            remove_sensor_manifold(obj, removed_ids[i]);
	    }

	    _manifolds_updated = true;
	}

	function remove_from_objects(obj) {
	    // remove from _objects
	    var obj_index = _objects.indexOf(obj);
	    if (obj_index > -1)
	        _objects.splice(obj_index, 1);
	    else {
	        m_print.error("Wrong object");
	        return;
	    }
	}

	function get_sensor_users(sensor, sensors_cache, manifolds_cache) {
	    var sens_ind = sensors_cache.indexOf(sensor);
	    if (sens_ind > -1)
	        return manifolds_cache[sens_ind];
	    else
	        return [];
	}

	/**
	 * Remove sensor from given sensors array.
	 * Physics sensors also require proper cleanup
	 */
	function deactivate_sensor(sensor) {
	    switch (sensor.type) {
	    case ST_COLLISION:
	        m_phy.remove_collision_test(sensor.collision_obj,
	                sensor.collision_id, sensor.collision_cb);
	        sensor.do_activation = true;
	        break;
	    case ST_COLLISION_IMPULSE:
	        m_phy.clear_collision_impulse_test(sensor.col_imp_obj);
	        sensor.do_activation = true;
	        break;
	    case ST_RAY:
	        m_phy.remove_ray_test(sensor.ray_test_id);
	        sensor.do_activation = true;
	        break;
	    case ST_TIMER:
	        sensor.do_activation = true;
	        break;
	    case ST_KEYBOARD:
	        var accumulator = get_accumulator(sensor.element);
	        unregister_accum_value(accumulator, "keyboard_downed_keys");
	        sensor.do_activation = true;
	        break;
	    case ST_MOUSE_WHEEL:
	        var accumulator = get_accumulator(sensor.element);
	        unregister_accum_value(accumulator, "mouse_wheel");
	        sensor.do_activation = true;
	        break;
	    case ST_MOUSE_MOVE:
	        var accumulator = get_accumulator(sensor.element);
	        unregister_accum_value(accumulator, "mouse_down_which");
	        unregister_accum_value(accumulator, "mouse_up_which");
	        unregister_accum_value(accumulator, "mouse_location");
	        sensor.do_activation = true;
	        break;
	    case ST_PLOCK_MOUSE_MOVE:
	        var accumulator = get_accumulator(sensor.element);
	        unregister_accum_value(accumulator, "mouse_pointerlock");
	        sensor.do_activation = true;
	        break;
	    case ST_MOUSE_CLICK:
	        var accumulator = get_accumulator(sensor.element);
	        unregister_accum_value(accumulator, "mouse_down_which");
	        unregister_accum_value(accumulator, "mouse_up_which");
	        sensor.do_activation = true;
	        break;
	    case ST_TOUCH_MOVE:
	        var accumulator = get_accumulator(sensor.element);
	        unregister_accum_value(accumulator, "touch_start");
	        unregister_accum_value(accumulator, "touch_move");
	        unregister_accum_value(accumulator, "touch_end");
	        sensor.do_activation = true;
	        break;
	    case ST_TOUCH_ZOOM:
	        var accumulator = get_accumulator(sensor.element);
	        unregister_accum_value(accumulator, "touch_start");
	        unregister_accum_value(accumulator, "touch_move");
	        sensor.do_activation = true;
	        break;
	    case ST_TOUCH_ROTATE:
	        var accumulator = get_accumulator(sensor.element);
	        unregister_accum_value(accumulator, "touch_start");
	        unregister_accum_value(accumulator, "touch_move");
	        sensor.do_activation = true;
	        break;
	    case ST_TOUCH_CLICK:
	        var accumulator = get_accumulator(sensor.element);
	        unregister_accum_value(accumulator, "touch_start");
	        unregister_accum_value(accumulator, "touch_end");
	        sensor.do_activation = true;
	        break;
	    case ST_SELECTION:
	        var accumulator = get_accumulator(sensor.element);
	        unregister_accum_value(accumulator, "mouse_select");
	        unregister_accum_value(accumulator, "touch_select");
	        unregister_accum_value(accumulator, "touch_start");
	        unregister_accum_value(accumulator, "touch_end");
	        unregister_accum_value(accumulator, "mouse_down_which");
	        unregister_accum_value(accumulator, "mouse_up_which");
	        sensor.do_activation = true;
	        break;
	    case ST_GYRO_DELTA:
	    case ST_GYRO_ANGLES:
	        var accumulator = get_accumulator(sensor.element);
	        unregister_accum_value(accumulator, "orientation_angles");
	        sensor.do_activation = true;
	        break;
	    case ST_GYRO_QUAT:
	        var accumulator = get_accumulator(sensor.element);
	        unregister_accum_value(accumulator, "orientation_quat");
	        sensor.do_activation = true;
	        break;
	    case ST_HMD_QUAT:
	    case ST_HMD_POSITION:
	        sensor.do_activation = true;
	        break;
	    }
	}


	exports.reset = function() {
	    for (var i = 0; i < _objects.length; i++) {
	        var obj = _objects[i];
	        var manifolds = obj.sensor_manifolds;
	        var manifolds_arr = obj.sensor_manifolds_arr;

	        for (var j in manifolds)
	            delete manifolds[j];

	        manifolds_arr.length = 0;
	    }

	    for (var i = 0; i < _sensors_cache.length; i++)
	        deactivate_sensor(_sensors_cache[i]);

	    _objects.length = 0;

	    _sensors_cache.length = 0;
	    _manifolds_cache.length = 0;
	};

	exports.debug = function() {
	    m_print.log(String(_objects.length) + " objects with manifolds", _objects);
	    m_print.log(String(_sensors_cache.length) + " sensors", _sensors_cache);

	    var collisions = [];
	    var rays = [];

	    for (var i = 0; i < _sensors_cache.length; i++) {
	        var sensor = _sensors_cache[i];
	        if (sensor.type == ST_COLLISION)
	            collisions.push(sensor);
	        if (sensor.type == ST_RAY)
	            rays.push(sensor);
	    }

	    m_print.log(String(collisions.length) + " collision sensors", collisions);
	    m_print.log(String(rays.length) + " ray sensors", rays);
	};

	function touch_zoom_dist(touches) {
	    var touch1 = touches[0];
	    var touch2 = touches[1];

	    var x = touch1.clientX - touch2.clientX,
	        y = touch1.clientY - touch2.clientY;

	    return Math.sqrt(x*x + y*y);
	}

	function touch_rotation(touches) {
	    var touch1 = touches[0];
	    var touch2 = touches[1];

	    var x = touch1.clientX - touch2.clientX,
	        y = touch1.clientY - touch2.clientY;

	    return Math.atan2(y,x);
	}

	function get_gmpd_device_by_id(gamepad_id) {
	    if (gamepad_id == 0)
	        var device = m_input.get_device_by_type_element(m_input.DEVICE_GAMEPAD0);
	    else if (gamepad_id == 1)
	        var device = m_input.get_device_by_type_element(m_input.DEVICE_GAMEPAD1);
	    else if (gamepad_id == 2)
	        var device = m_input.get_device_by_type_element(m_input.DEVICE_GAMEPAD2);
	    else
	        var device = m_input.get_device_by_type_element(m_input.DEVICE_GAMEPAD3);

	    return device;
	}

	function smooth_coeff_mouse() {
	    return CAM_SMOOTH_CHARACTER_MOUSE * _smooth_factor;
	}

	exports.set_plock_smooth_factor = function(value) {
	    _smooth_factor = value;
	};

	}

	var int_controls_factory = register("__controls", Int_controls);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	/**
	 * Created by dal on 04.09.15.
	 */
	"use strict";

	/**
	 * Logic Nodes scheduler module.
	 * @name logic_nodes
	 * @namespace
	 * @exports exports as logic_nodes
	 */
	function Int_logic_nodes(ns, exports) {

	var m_anim      = int_animation_factory(ns);
	var m_assets    = int_assets_factory(ns);
	var m_cam       = int_camera_factory(ns);
	var m_nla       = int_nla_factory(ns);
	var m_obj       = int_objects_factory(ns);
	var m_print     = print_factory(ns);
	var m_scs       = int_scenes_factory(ns);
	var m_cfg       = int_config_factory(ns);
	var m_ctl       = int_controls_factory(ns);
	var m_batch     = int_batch_factory(ns);
	var m_geom      = int_geometry_factory(ns);
	var m_mat3      = mat3_factory(ns);
	var m_mat4      = mat4_factory(ns);
	var m_phy       = int_physics_factory(ns);
	var m_quat      = quat_factory(ns);
	var m_sfx       = int_sfx_factory(ns);
	var m_time      = int_time_factory(ns);
	var m_trans     = int_transform_factory(ns);
	var m_tsr       = int_tsr_factory(ns);
	var m_util      = int_util_factory(ns);
	var m_vec3      = vec3_factory(ns);
	var m_obj_util  = int_obj_util_factory(ns);

	var _vec4_tmp  = new Float32Array(4);
	var _vec3_tmp  = new Float32Array(3);
	var _vec3_tmp1 = new Float32Array(3);
	var _vec2_tmp  = new Float32Array(2);
	var _mat3_tmp  = new Float32Array(9);
	var _mat4_tmp  = new Float32Array(16);


	/**
	 * Logic State
	 */
	var UNINITIALIZED  = 0;
	var INITIALIZATION = 1;
	var RUNNING        = 2;
	var STOPPED        = 3;

	/**
	 * Node State by type
	 */
	// Playing state(Animation, Transformation, Timeline, Sound etc)
	var NPS_NOT_STARTED  = -1;
	var NPS_PLAYING      = 0;
	var NPS_FINISHED     = 1;
	// Switch Select
	var NSS_NOT_READY_QUITE = -3;
	var NSS_NOT_READY       = -2;   // force minimum 1 frame between sensors creation for correct accumulator work
	var NSS_READY           = -1;
	var NSS_MISS            = 0;
	var NSS_HIT             = 1;
	// Send Request
	var NSR_NOT_STARTED          = -1;
	var NSR_SENDING_REQUEST      = 0;
	var NSR_RESPONSE_RECEIVED    = 1;

	/**
	 * Formats for convert_variable
	 */
	var NT_NUMBER = 0;
	var NT_STRING = 1;
	var NT_OBJECT = 2;
	exports.NT_NUMBER = NT_NUMBER;
	exports.NT_STRING = NT_STRING;
	exports.NT_OBJECT = NT_OBJECT;

	/**
	 * Keep node constants synchronized with:
	 *   exporter.py : process_scene_nla
	 *   reformer.js : assign_logic_nodes_object_params
	 */

	/**
	 * Node math operations
	 */
	var NMO_DIV    = 0;
	var NMO_SUB    = 1;
	var NMO_MUL    = 2;
	var NMO_ADD    = 3;
	var NMO_RAND   = 4;
	var NMO_SIN    = 5;
	var NMO_COS    = 6;
	var NMO_TAN    = 7;
	var NMO_ARCSIN = 8;
	var NMO_ARCCOS = 9;
	var NMO_ARCTAN = 10;
	var NMO_LOG    = 11;
	var NMO_MIN    = 12;
	var NMO_MAX    = 13;
	var NMO_ROUND  = 14;
	var NMO_MOD    = 15;
	var NMO_ABS    = 16;
	exports.NMO_DIV    = NMO_DIV;
	exports.NMO_SUB    = NMO_SUB;
	exports.NMO_MUL    = NMO_MUL;
	exports.NMO_ADD    = NMO_ADD;
	exports.NMO_RAND   = NMO_RAND;
	exports.NMO_SIN    = NMO_SIN;
	exports.NMO_COS    = NMO_COS;
	exports.NMO_TAN    = NMO_TAN;
	exports.NMO_ARCSIN = NMO_ARCSIN;
	exports.NMO_ARCCOS = NMO_ARCCOS;
	exports.NMO_ARCTAN = NMO_ARCTAN;
	exports.NMO_LOG    = NMO_LOG;
	exports.NMO_MIN    = NMO_MIN;
	exports.NMO_MAX    = NMO_MAX;
	exports.NMO_ROUND  = NMO_ROUND;
	exports.NMO_MOD    = NMO_MOD;
	exports.NMO_ABS    = NMO_ABS;

	/**
	 * Node string operations
	 */
	var NSO_JOIN    = 0;
	var NSO_FIND    = 1;
	var NSO_REPLACE = 2;
	var NSO_SPLIT   = 3;
	var NSO_COMPARE = 4;
	exports.NSO_JOIN    = NSO_JOIN;
	exports.NSO_FIND    = NSO_FIND;
	exports.NSO_REPLACE = NSO_REPLACE;
	exports.NSO_SPLIT   = NSO_SPLIT;
	exports.NSO_COMPARE = NSO_COMPARE;

	/**
	 * Node conditions
	 */
	var NC_GEQUAL   = 0;
	var NC_LEQUAL   = 1;
	var NC_GREATER  = 2;
	var NC_LESS     = 3;
	var NC_NOTEQUAL = 4;
	var NC_EQUAL    = 5;
	exports.NC_GEQUAL   = NC_GEQUAL;
	exports.NC_LEQUAL   = NC_LEQUAL;
	exports.NC_GREATER  = NC_GREATER;
	exports.NC_LESS     = NC_LESS;
	exports.NC_NOTEQUAL = NC_NOTEQUAL;
	exports.NC_EQUAL    = NC_EQUAL;

	/**
	 * Node space type
	 */
	var NST_WORLD  = 0;
	var NST_PARENT = 1;
	var NST_LOCAL  = 2;
	exports.NST_WORLD  = NST_WORLD;
	exports.NST_PARENT = NST_PARENT;
	exports.NST_LOCAL  = NST_LOCAL;

	/**
	 * Node camera move style
	 */
	var NCMS_STATIC  = 0;
	var NCMS_TARGET  = 1;
	var NCMS_EYE     = 2;
	var NCMS_HOVER   = 3;
	exports.NCMS_STATIC = NCMS_STATIC;
	exports.NCMS_TARGET = NCMS_TARGET;
	exports.NCMS_EYE    = NCMS_EYE;
	exports.NCMS_HOVER  = NCMS_HOVER;

	/**
	 * Node cb param type
	 */
	var NCPT_OBJECT  = 0;
	var NCPT_VARIABLE = 1;
	exports.NCPT_OBJECT = NCPT_OBJECT;
	exports.NCPT_VARIABLE = NCPT_VARIABLE;

	/**
	 * Add your node to _nodes_handlers
	 * Use do_nothing_handler for stubs
	 */
	var _nodes_handlers = {
	    "ENTRYPOINT": entrypoint_handler,
	    "HIDE": hide_object_handler,
	    "SHOW": show_object_handler,
	    "PAGEPARAM": pageparam_handler,
	    "SWITCH_SELECT": switch_select_handler,
	    "SELECT": select_handler,
	    "PLAY": play_timeline_handler,
	    "REDIRECT": redirect_handler,
	    "MATH": math_handler,
	    "CONDJUMP": conditional_jump_handler,
	    "REGSTORE": regstore_handler,
	    "PLAY_ANIM": play_anim_handler,
	    "SELECT_PLAY": do_nothing_handler,
	    "SEND_REQ": send_req_handler,
	    "INHERIT_MAT": inherit_mat_handler,
	    "SET_SHADER_NODE_PARAM": set_shader_node_param_handler,
	    "DELAY": delay_handler,
	    "APPLY_SHAPE_KEY": apply_shape_key_handler,
	    "OUTLINE": outline_handler,
	    "MOVE_CAMERA": move_camera_handler,
	    "SET_CAMERA_MOVE_STYLE": set_camera_move_style_handler,
	    "SET_CAMERA_LIMITS": set_camera_limits_handler,
	    "MOVE_TO": move_to_handler,
	    "TRANSFORM_OBJECT": transform_object_handler,    
	    "SPEAKER_PLAY": speaker_play_handler,
	    "SPEAKER_STOP": speaker_stop_handler,
	    "STOP_ANIM": stop_anim_handler,
	    "STOP_TIMELINE": stop_timeline_handler,
	    "CONSOLE_PRINT": console_print_handler,
	    "STRING": string_handler,
	    "GET_TIMELINE": get_timeline_handler,
	    "JSON": json_handler,
	    "JS_CALLBACK": js_callback_handler,
	    "EMPTY": do_nothing_handler,
	    "DATE_TIME": date_time_handler,
	    "ELAPSED": elapsed_handler,
	    "CALL_FUNC": call_func_handler,
	    "DEF_FUNC": do_nothing_handler,
	    "SWITCH": switch_handler
	};

	var _logic_arr = [];

	var _logic_custom_cb_arr = {};

	var _node_ident_counters = {};

	function init_node(snode, logic_script) {

	    var node = {
	        name: snode["name"],
	        type: snode["type"],
	        label: snode["label"],
	        slot_idx_order: snode["slot_idx_order"],
	        slot_idx_jump: snode["slot_idx_jump"],
	        frame_start: snode["frame_range"][0],
	        frame_end: snode["frame_range"][1],
	        frame_start_mask: snode["frame_range_mask"] ? snode["frame_range_mask"][0] : true,
	        frame_end_mask: snode["frame_range_mask"] ? snode["frame_range_mask"][1] : true,
	        param_name: snode["param_name"],
	        op: snode["operation"],
	        mute: snode["mute"],
	        dupli_name_list: snode["object"],
	        anim_name: snode["anim_name"],
	        parse_json_vars: snode["parse_json_vars"],
	        parse_json_paths: snode["parse_json_paths"],
	        objects_paths: snode["objects_paths"],
	        nodes_paths: snode["nodes_paths"],
	        floats: snode["floats"],
	        bools: snode["bools"],
	        vars: snode["variables"],
	        strings: snode["strings"],
	        logic_functions: snode["logic_functions"],
	        logic_node_trees: snode["logic_node_trees"],
	        materials_names: snode["materials_names"],
	        shader_nd_type: snode["shader_nd_type"],
	        common_usage_names: snode["common_usage_names"],
	        encode_json_vars: snode["encode_json_vars"],
	        encode_json_paths: snode["encode_json_paths"],
	        thread: logic_script,
	        process_node: _nodes_handlers[snode["type"]] ? _nodes_handlers[snode["type"]] : unknown_node_handler,
	        processed: false,
	        links_dict: snode["links"],
	        instances: [],
	        func_id: -1,
	        links_keys: null,
	        select_object_idx: -1
	    };

	    return node;
	}

	function get_node_instance(node, thread_state, init_cb) {
	    var extend_len = (thread_state.thread_index + 1) - node.instances.length;
	    if (extend_len > 0) {
	        for (var i = 0; i < extend_len; i++) {
	            if (i == extend_len - 1) {
	                node.instances.push({
	                    objects: {},
	                    slot_idx_jump: -1,
	                    state: NPS_NOT_STARTED,
	                    sel_obj_idxs: [],
	                    timer: -1,
	                    camera_state: {},
	                    anim_slot: m_anim.SLOT_ALL,
	                    obj_state: null
	                });
	            } else
	                node.instances.push(0);
	        }
	        if (init_cb)
	            init_cb(node, node.instances[thread_state.thread_index], thread_state);
	    }
	    return node.instances[thread_state.thread_index];

	}

	function get_var(var_desc, global_vars, local_vars) {
	    return var_desc[0]?global_vars[var_desc[1]]:local_vars[var_desc[1]];
	}

	function set_var(var_desc, global_vars, local_vars, value) {
	    if (var_desc[0])
	        global_vars[var_desc[1]] = value;
	    else
	        local_vars[var_desc[1]] = value;
	}

	function do_nothing_handler(node, logic, thread_state, timeline, elapsed, start_time) {
	    switch (logic.state) {
	    case INITIALIZATION:
	        break;
	    case RUNNING:
	        thread_state.curr_node = node.slot_idx_order;
	        break;
	    }
	}

	function unknown_node_handler(node, logic, thread_state, timeline, elapsed, start_time) {
	    switch (logic.state) {
	    case INITIALIZATION:
	        m_print.error("Unknown node type: " + node.type);
	        break;
	    case RUNNING:
	        thread_state.curr_node = node.slot_idx_order;
	        break;
	    }
	}

	exports.init_logic = function(scene, data_id) {
	    var logic = {
	        data_id: data_id,
	        scene_name: scene["name"],
	        state: UNINITIALIZED,
	        nla_thread: null,
	        scene: scene,
	        curr_thread: null,
	        logic_threads: [],
	        logic_functions: [],
	        sorted_markers_values: [],
	        variables: {},
	        variables_references: {} // used in CALL_FUNC to merge return-type values
	                                 // at the end of call
	    };
	    scene._logic = logic;
	    prepare_logic(scene, logic);
	};

	exports.update = function(timeline, elapsed) {
	    var start_time = m_nla.get_start_time();
	    if (start_time <= 0)
	        return;

	    // for each scene
	    for (var i = 0; i < _logic_arr.length; i++) {
	        process_logic(i, timeline, elapsed, start_time);
	    }
	};

	exports.append_custom_cb = function(cb_id, cb) {
	    _logic_custom_cb_arr[cb_id] = cb;
	};

	exports.remove_custom_cb = function(cb_id) {
	    delete _logic_custom_cb_arr[cb_id];
	};

	exports.run_ep = function(scene_name, ep_name) {
	    for (var i = 0; i < _logic_arr.length; i++) {
	        if (_logic_arr[i].scene_name == scene_name) {
	            var logic = _logic_arr[i];
	            for (var j = 0; j < logic.logic_threads.length; j++) {
	                var ep = logic.logic_threads[j].nodes[0];
	                if (ep.name == ep_name) {
	                    if(ep.bools["js"])
	                        ep.mute  = false;
	                        logic.logic_threads[j].thread_state.curr_node = 0;
	                    break;
	                }
	            }
	            break;
	        }
	    }
	};

	function reset_play(thread) {
	    var callstack = thread.thread_state.callstack;
	    var len = callstack.length;
	    var scripts = [];
	    if (len <= 1) {
	        scripts.push(thread.nodes);
	    }
	    for (var k = 1; k < len; k++) {
	        scripts.push(callstack[k].logic_func.func.nodes);
	    }

	    for (var k = 0; k < scripts.length; k++) {
	        for (var i = 0; i < scripts[k].length; i++) {
	            var node = scripts[k][i];
	            if (node.type == "PLAY") {
	                var inst = get_node_instance(node, thread.thread_state);
	                inst.state = NPS_NOT_STARTED;
	            }
	        }
	    }
	}

	function reset_selections(thread, exclude_node) {
	    var script = thread.nodes;
	    for (var i = 0; i < script.length; i++) {
	        var node = script[i];
	        if (node.type == "SWITCH_SELECT" && node != exclude_node) {
	            var inst = get_node_instance(node, thread.thread_state);
	            inst.state = NSS_NOT_READY_QUITE;
	        }
	    }
	}

	function process_logic(index, timeline, elapsed, start_time) {
	    // for each thread
	    var logic = _logic_arr[index];
	    for (var k = 0; k < _logic_arr[index].logic_threads.length; k++) {
	        logic.curr_thread = _logic_arr[index].logic_threads[k];
	        process_logic_thread(_logic_arr[index].logic_threads[k], logic, timeline, elapsed, start_time);
	    }
	}

	/**
	 * Return URL param
	 */
	function get_url_param(name, param_type, is_hash_param) {
	    var cfg_url_params = m_cfg.get("url_params");

	    if (cfg_url_params && name in cfg_url_params)
	        return Number(cfg_url_params[name]);

	    var url_params = is_hash_param ? location.hash : location.search;

	    if (!url_params)
	        return 0;

	    var params = url_params.slice(1).split("&");

	    for (var i = 0; i < params.length; i++) {
	        var param = params[i].split("=");

	        if (param.length > 1 && param[0] == name)
	            return convert_variable(param[1], param_type);
	    }

	    return 0;
	}

	function get_world(node) {
	    return m_obj.get_world_by_name(node.dupli_name_list[0], 0);
	}

	function entrypoint_handler(node, logic, thread_state, timeline, elapsed, start_time) {
	    switch (logic.state) {
	    case RUNNING:
	        // init callstack
	        thread_state.callstack.push({
	            caller_node: null,
	            variables: thread_state.variables,
	            logic_func: null});
	        thread_state.curr_node = node.slot_idx_order;
	        break;
	    }
	}

	function hide_object_handler(node, logic, thread_state, timeline, elapsed, start_time) {
	    var is_var = node.bools["id0"];
	    function init(node, inst, thread_state) {
	        if (!is_var) {
	            inst.obj = m_obj.get_object(m_obj.GET_OBJECT_BY_DUPLI_NAME_LIST, node.objects_paths["id0"], 0);
	            if(!inst.obj) {
	                m_print.error("Logic script error: object not found. Node: ", node.name);
	                node.mute = true;
	            }
	        }
	    }
	    switch (logic.state) {
	    case INITIALIZATION:
	        break;
	    case RUNNING:
	        var inst = get_node_instance(node, thread_state, init);
	        var obj = is_var ? get_var(node.vars["id0"], logic.variables, thread_state.variables) : inst.obj;
	        var process_child = node.bools["ch"];
	        if (process_child)
	            m_scs.change_visibility_rec(obj, true);
	        else
	            m_scs.change_visibility(obj, true);
	        thread_state.curr_node = node.slot_idx_order;
	        break;
	    }
	}
	function show_object_handler(node, logic, thread_state, timeline, elapsed, start_time) {
	    var is_var = node.bools["id0"];
	    function init(node, inst, thread_state) {
	        if (!is_var) {
	            inst.obj = m_obj.get_object(m_obj.GET_OBJECT_BY_DUPLI_NAME_LIST, node.objects_paths["id0"], 0);
	            if(!inst.obj) {
	                m_print.error("Logic script error: object not found. Node: ", node.name);
	                node.mute = true;
	            }
	        }
	    }
	    switch (logic.state) {
	    case INITIALIZATION:
	        break;
	    case RUNNING:
	        var inst = get_node_instance(node, thread_state, init);
	        var obj = is_var ? get_var(node.vars["id0"], logic.variables, thread_state.variables) : inst.obj;
	        var process_child = node.bools["ch"];
	        if (process_child)
	            m_scs.change_visibility_rec(obj, false);
	        else
	            m_scs.change_visibility(obj, false);
	        thread_state.curr_node = node.slot_idx_order;
	        break;
	    }
	}
	function pageparam_handler(node, logic, thread_state, timeline, elapsed, start_time) {
	    switch (logic.state) {
	    case RUNNING:
	        set_var(node.vars["vd"], logic.variables, thread_state.variables,
	            get_url_param(node.param_name, node.floats["ptp"], node.bools["hsh"]));
	        thread_state.curr_node = node.slot_idx_order;
	        break;
	    }
	}

	function select_handler(node, logic, thread_state, timeline, elapsed, start_time) {
	    switch (logic.state) {
	    case INITIALIZATION:
	        m_print.error("Logic script error: node is deprecated. Node: ", node.name);
	        node.mute = true;
	        break;
	    }
	}

	var gen_switch_select_cb = function() {
	    return function (obj, id, pulse, param) {
	        var node = param[0];
	        var logic = param[1];
	        var thread = param[2];
	        var inst = get_node_instance(node, thread.thread_state);
	        if (inst.state != NSS_READY)
	            return;
	        for (var i = 0; i < inst.sel_objs_len; i++) {
	            var val = m_ctl.get_sensor_value(obj, id, i);
	            if (val) {
	                for (var j = 0; j < inst.sel_obj_idxs.length; j++) {
	                    if (inst.sel_obj_idxs[j] == i) {
	                        if (logic.nla_thread == inst.thread) {
	                            if (m_nla.is_play(logic._nla))
	                                inst.state = NSS_NOT_READY_QUITE;
	                            if (!(thread.thread_state.in_progress)) {
	                                inst.state = NSS_HIT;
	                                inst.slot_idx_jump = inst.links_idxs[j];
	                            }
	                        } else {
	                            inst.state = NSS_HIT;
	                            inst.slot_idx_jump = inst.links_idxs[j];
	                        }
	                        inst.select_object_idx = i;
	                        return;
	                    }
	                }
	                inst.select_object_idx = i;
	            }
	        }
	        inst.state = NSS_MISS;
	    }
	};

	function create_switch_select_sensor(node, logic, thread) {
	    var sel_objs = m_obj.get_selectable_objects();
	    var inst = get_node_instance(node, thread.thread_state);
	    inst.sel_obj_idxs = [];
	    inst.links_idxs = [];
	    for (var key in node.objects_paths) {
	        var obj = node.bools[key] ?
	        get_var(node.vars[key], logic.variables, thread.thread_state.variables) :
	        m_obj.get_object(m_obj.GET_OBJECT_BY_DUPLI_NAME_LIST, node.objects_paths[key], 0);
	        var obj_idx = sel_objs.indexOf(obj);
	        if (obj_idx == -1) {
	            m_print.error("logic script error: non-selectable object:",
	                node.objects_paths[key][node.objects_paths[key].length -1]);
	            return -1;
	        }
	        inst.sel_obj_idxs.push(obj_idx);
	        inst.links_idxs.push(node.links_dict[key]);
	    }
	    inst.sel_objs_len = sel_objs.length;

	    var sel_sensors = [];
	    for (var j = 0; j < sel_objs.length; j++) {
	        sel_sensors.push(m_ctl.create_selection_sensor(sel_objs[j], false));
	    }
	    var select_cb = gen_switch_select_cb();
	    m_ctl.create_sensor_manifold(null, "LOGIC_NODES_SWITCH_SELECT_" + node_ident(node.label), m_ctl.CT_SHOT,
	        sel_sensors, m_ctl.default_OR_logic_fun, select_cb, [node, logic, thread]);
	}

	function switch_select_handler(node, logic, thread_state, timeline, elapsed, start_time) {
	    function init(node, inst, thread_state) {
	        inst.state = NSS_NOT_READY_QUITE;
	    }
	    // state:
	    //        -2: not ready, needs sensor reset
	    //        -1: ready
	    //         0: Miss
	    //         1: Hit
	    switch (logic.state) {
	    case INITIALIZATION:
	        break;
	    case RUNNING:
	        var inst = get_node_instance(node, thread_state, init);
	        if (inst.state == NSS_NOT_READY_QUITE) {
	            inst.state = NSS_NOT_READY;
	            reset_selections(logic.logic_threads[thread_state.thread_index], node);
	            create_switch_select_sensor(node, logic, logic.logic_threads[thread_state.thread_index]);
	        } else if (inst.state == NSS_NOT_READY) {
	            inst.state = NSS_READY;
	        } else if (inst.state == NSS_MISS || inst.state == NSS_HIT) {
	            if (node.vars["vd"] && node.vars["vd"][1]) {
	                var sel_objs = m_obj.get_selectable_objects();
	                var v = set_var(node.vars["vd"], logic.variables, thread_state.variables, sel_objs[inst.select_object_idx]);
	            }
	            thread_state.curr_node = inst.state ? inst.slot_idx_jump : node.slot_idx_order;
	            inst.state = NSS_NOT_READY_QUITE;
	            m_ctl.remove_sensor_manifold(null, "LOGIC_NODES_SWITCH_SELECT_" + node_ident(node.label));
	            break;
	        }
	        break;
	    }
	}

	function switch_handler(node, logic, thread_state, timeline, elapsed, start_time) {
	    switch (logic.state) {
	    case INITIALIZATION:
	        var keys = Object.keys(node.vars);
	        for (var k in keys) {
	            if (!keys[k].startsWith("id")) {
	                keys.splice(k, 1);
	            }
	        }
	        node.links_keys = keys;
	        break;
	    case RUNNING:
	        var v1 = get_var(node.vars["v"], logic.variables, thread_state.variables);
	        for (var k in node.links_keys) {
	            var param = node.vars[node.links_keys[k]];
	            var v2 = get_var(param, logic.variables, thread_state.variables);
	            if (v1 == v2) {
	                thread_state.curr_node = node.links_dict[node.links_keys[k]];
	                return;
	            }
	        }
	        thread_state.curr_node = node.slot_idx_order;
	        break;
	    }
	}

	function play_timeline_handler(node, logic, thread_state, timeline, elapsed, start_time) {
	    switch (logic.state) {
	    case INITIALIZATION:
	        m_nla.stop_nla();
	        if (!node.bools["not_wait"])
	            node.bools["not_wait"] = false;
	        break;
	    case RUNNING:
	        var inst = get_node_instance(node, thread_state);
	        switch (inst.state) {
	        case NPS_NOT_STARTED:
	            if (m_nla.is_play(logic._nla)) {
	                // if current thread is in progress
	                if (logic.curr_thread == logic.nla_thread && thread_state.in_progress) {
	                    break;
	                }
	                else {
	                    // reset nla thread
	                    var thread = logic.nla_thread;
	                    if (thread) {
	                        var nla_nodes = get_thread_nodes(thread);
	                        var nla_nd = nla_nodes[thread.thread_state.curr_node];
	                        thread.thread_state.curr_node = nla_nd.slot_idx_order;
	                        reset_play(logic.nla_thread);
	                    }
	                }
	            }
	            thread_state.in_progress = !node.bools["not_wait"];

	            logic.nla_thread = logic.curr_thread;
	            inst.state = NPS_PLAYING;
	            if (node.frame_start_mask) {
	                m_nla.set_range_start(node.frame_start);
	                m_nla.set_offset_from_range_start(timeline);
	            }
	            if (node.frame_end_mask) {
	                m_nla.set_range_end(node.frame_end);
	            } else {
	                var cur_frame = m_nla.get_frame(timeline);
	                var end = -1;
	                for (var v in logic.sorted_markers_values) {
	                    if (cur_frame < logic.sorted_markers_values[v]) {
	                        end = v;
	                        break;
	                    }
	                }
	                if (end >= 0)
	                    m_nla.set_range_end(logic.sorted_markers_values[end]);
	                else
	                    m_nla.set_range_end(m_nla.get_frame_end());
	            }
	            m_nla.play_nla(null);

	            // if we can we must switch to the next node immediately
	            // else there could be a conflict between nodes of such type
	            if (node.bools["not_wait"]) {
	                thread_state.curr_node = node.slot_idx_order;
	                inst.state = NPS_NOT_STARTED;
	                thread_state.in_progress = false;
	            }
	            //
	            break;
	        case NPS_PLAYING:
	            // playing
	            if (!m_nla.is_play()) {
	                thread_state.curr_node = node.slot_idx_order;
	                inst.state = NPS_NOT_STARTED;
	                thread_state.in_progress = false;
	            }
	            break;
	        case NPS_FINISHED:
	            thread_state.curr_node = node.slot_idx_order;
	            inst.state = NPS_NOT_STARTED;
	            logic.nla_thread = null;
	            thread_state.in_progress = false;
	            break;
	        default:
	            m_util.panic("Unknown state of " + node.name);
	            inst.state = NPS_NOT_STARTED;
	            break;
	        }
	        break;
	    }
	}

	function console_print_handler(node, logic, thread_state, timeline, elapsed, start_time) {
	    switch (logic.state) {
	    case RUNNING:
	        var j = 0;
	        var result = "{";
	        for (var i in node.vars) {
	            if (j > 0)
	                result += ", ";
	            var key = node.vars[i][1];
	            var val = get_var(node.vars[i], logic.variables, thread_state.variables);

	            result += "\"" + key + "\": ";
	            try {
	                result += JSON.stringify(val);
	            } catch(e) {
	                if (val)
	                    result += "{\"name\": \""+ val.name + "\", \"type\": \"" + val.type + "\"}";
	                else
	                    result += "Object";
	            }
	            ++j;
	        }
	        result += "}";
	        m_print.log(node.common_usage_names["msg"], result);
	        thread_state.curr_node = node.slot_idx_order;
	        break;
	    }
	}

	function stop_timeline_handler(node, logic, thread_state, timeline, elapsed, start_time) {
	    switch (logic.state) {
	    case RUNNING:
	        if (node.bools["rst"]) {
	            m_nla.set_offset_from_range_start(timeline);
	        }
	        m_nla.stop_nla();
	        thread_state.curr_node = node.slot_idx_order;
	        break;
	    }
	}

	function redirect_handler(node, logic, thread_state, timeline, elapsed, start_time) {
	    switch (logic.state) {
	    case RUNNING:
	        var url = node.bools["url"] ? convert_variable(
	                get_var(node.vars['url'], logic.variables, thread_state.variables), NT_STRING) : node.strings["url"];
	        window.location.href = url;
	        logic.state = STOPPED;
	        break;
	    }
	}


	function send_req_handler(node, logic, thread_state, timeline, elapsed, start_time) {
	    var inst = get_node_instance(node, thread_state);
	    function asset_cb(loaded_data, id, type, url, param) {
	        var resp_string = JSON.stringify(loaded_data);
	        var node = param[0];
	        var thread_state = param[1];
	        var inst = get_node_instance(node, thread_state);
	        set_var(param[0].vars["dst"], logic.variables, thread_state.variables, resp_string);
	        inst.state = 1;
	    }

	    switch (logic.state) {
	    case RUNNING:
	        switch (inst.state) {
	        case NSR_NOT_STARTED:
	            inst.state = NSR_SENDING_REQUEST;
	            var url = node.bools["url"] ? convert_variable(
	                    get_var(node.vars['url'], logic.variables, thread_state.variables), NT_STRING) : node.strings["url"];

	            var header = {};
	            if (node.bools["ct"])
	                header["Content-Type"] = node.strings["ct"];
	            if (node.common_usage_names["request_type"] == "GET") {
	                m_assets.enqueue([{id:url, type:m_assets.AT_JSON, url:url, overwrite_header: header,
	                    param:[node, thread_state]}], asset_cb, null, null, null);
	            }
	            else if (node.common_usage_names["request_type"] == "POST") {
	                    var req = convert_variable(
	                        get_var(node.vars["dst1"], logic.variables, thread_state.variables), NT_STRING);

	                    m_assets.enqueue([{id:url, type:m_assets.AT_JSON, url:url, 
	                            overwrite_header: header, request_method:"POST", 
	                            post_data:req, param:[node, thread_state]}],
	                            asset_cb, null, null, null);
	            }
	            break;
	        case NSR_SENDING_REQUEST:
	            break;
	        case NSR_RESPONSE_RECEIVED:
	            inst.state = NSR_NOT_STARTED;
	            thread_state.curr_node = node.slot_idx_order;
	            break;
	        }
	        break;
	    }
	}

	function inherit_mat_handler(node, logic, thread_state, timeline, elapsed, start_time) {
	    function init(node, inst, thread_state) {
	        for (var i = 0; i < 2; i++) {
	            inst.objects["id"+i] = m_obj.get_object(m_obj.GET_OBJECT_BY_DUPLI_NAME_LIST, node.objects_paths["id"+i], 0);
	            if(!inst.objects["id"+i]) {
	                m_print.error("Logic script error: object not found. Node: ", node.name);
	                node.mute = true;
	            }
	        }
	    }
	    switch (logic.state) {
	    case INITIALIZATION:
	        break;
	    case RUNNING:
	        var inst = get_node_instance(node, thread_state, init);
	        m_obj.inherit_material(inst.objects['id0'], node.materials_names['id0'],
	            inst.objects['id1'], node.materials_names['id1']);
	        thread_state.curr_node = node.slot_idx_order;
	        break;
	    }
	}

	function delay_handler(node, logic, thread_state, timeline, elapsed, start_time) {
	    var inst = get_node_instance(node, thread_state);
	    switch (logic.state) {
	    case INITIALIZATION:
	        break;
	    case RUNNING:
	        if (inst.state == NPS_NOT_STARTED) {
	            // start delay
	            inst.state = NPS_PLAYING;
	            inst.timer = 0;
	            thread_state.in_progress = true;
	            return;
	        } else if (inst.state == NPS_PLAYING) {
	            // count the time
	            inst.timer += elapsed;
	            var dl = node.bools["dl"] ? convert_variable(
	                get_var(node.vars['dl'], logic.variables,thread_state.variables), NT_NUMBER) : node.floats["dl"];
	            if (dl < inst.timer) {
	                inst.state = NPS_NOT_STARTED;
	                thread_state.curr_node = node.slot_idx_order;
	                thread_state.in_progress = false;
	            }
	        }
	        break;
	    }
	}

	function apply_shape_key_handler(node, logic, thread_state, timeline, elapsed, start_time) {
	    function init(node, inst, thread_state) {
	        var obj = inst.objects["id0"] =
	        m_obj.get_object(m_obj.GET_OBJECT_BY_DUPLI_NAME_LIST, node.objects_paths["id0"], 0);
	        if(!obj) {
	            m_print.error("Logic script error: object not found. Node: ", node.name);
	            node.mute = true;
	        }
	        var key = node.common_usage_names['sk'];
	        if (!m_geom.check_shape_keys(obj)) {
	            m_print.error("No shape keys in object:", obj.name);
	            node.mute = true;
	        } else if (!m_geom.has_shape_key(obj, key)) {
	            m_print.error("Wrong key name:", key);
	            node.mute = true;
	        }
	    }
	    switch (logic.state) {
	    case INITIALIZATION:
	        break;
	    case RUNNING:
	        var inst = get_node_instance(node, thread_state, init);
	        m_geom.apply_shape_key(inst.objects["id0"], node.common_usage_names['sk'],
	            node.bools["skv"] ? convert_variable(
	                get_var(node.vars['skv'], logic.variables, thread_state.variables), NT_NUMBER) : node.floats['skv']);
	        thread_state.curr_node = node.slot_idx_order;
	        break;
	    }
	}

	function outline_handler(node, logic, thread_state, timeline, elapsed, start_time) {
	    var is_var = node.bools["id0"];
	    function init(node, inst, thread_state) {
	        if(!is_var) {
	            inst.obj = m_obj.get_object(m_obj.GET_OBJECT_BY_DUPLI_NAME_LIST, node.objects_paths["id0"], 0);
	            if(!inst.obj) {
	                m_print.error("Logic script error: object not found. Node: ", node.name);
	                node.mute = true;
	            }
	            if (!(inst.obj && inst.obj.render && inst.obj.render.outlining)) {
	                m_print.error("Can't evaluate 'Outline' logic node: wrong object");
	                node.mute = true;
	            }
	        }
	    }
	    switch (logic.state) {
	    case INITIALIZATION:
	        break;
	    case RUNNING:
	        var inst = get_node_instance(node, thread_state, init);
	        var obj = is_var ? get_var(node.vars["id0"], logic.variables, thread_state.variables) : inst.obj;
	        switch (node.common_usage_names["outline_operation"]) {
	        case "PLAY":
	            var oa_set = obj.render.outline_anim_settings_default;
	            m_obj.apply_outline_anim(obj, oa_set.outline_duration,
	                oa_set.outline_period, oa_set.outline_relapses);
	            break;
	        case "STOP":
	                m_obj.clear_outline_anim(obj);
	            break;
	        case "INTENSITY":
	            m_obj.set_outline_intensity(obj, node.bools["in"] ? convert_variable(
	                        get_var(node.vars['in'], logic.variables, thread_state.variables), NT_NUMBER) : node.floats['in']);
	            break;
	        }
	        thread_state.curr_node = node.slot_idx_order;
	        break;
	    }
	}

	function move_camera_handler(node, logic, thread_state, timeline, elapsed, start_time) {
	    function move_cam(cam, trans, target, tsr) {
	        switch (m_cam.get_move_style(cam)) {
	        case m_cam.MS_TARGET_CONTROLS:
	            m_cam.set_trans_pivot(cam, trans, target);
	            break;
	        case m_cam.MS_EYE_CONTROLS:
	        case m_cam.MS_STATIC:
	            m_trans.set_tsr(cam, tsr);
	            break;
	        case m_cam.MS_HOVER_CONTROLS:
	            m_vec3.sub(target, trans, _vec3_tmp);
	            m_vec3.normalize(_vec3_tmp, _vec3_tmp);
	            m_cam.set_hover_pivot(cam, target);
	            var phi = 0;
	            var theta = 0;
	            // ZOX projection
	            _vec3_tmp1[0] = _vec3_tmp[0];
	            _vec3_tmp1[1] = 0;
	            _vec3_tmp1[2] = _vec3_tmp[2];
	            var dot = m_vec3.dot(_vec3_tmp1, _vec3_tmp);
	            theta = Math.acos(dot / (m_vec3.length(_vec3_tmp1) * m_vec3.length(_vec3_tmp)));
	            if (_vec3_tmp[2])
	                phi = Math.atan(_vec3_tmp[0] / _vec3_tmp[2]);
	            else {
	                if (_vec3_tmp[0] > 0)
	                    phi = 0;
	                else
	                    phi = Math.PI;
	            }
	            if (_vec3_tmp[2] > 0 && _vec3_tmp[0] > 0) {
	                _vec2_tmp[1] = -(Math.PI + _vec2_tmp[1]);
	            }
	            else if (_vec3_tmp[2] > 0 && _vec3_tmp[0] < 0) {
	                _vec2_tmp[1] = -(Math.PI + _vec2_tmp[1]);
	            }
	            else if (_vec3_tmp[2] < 0 && _vec3_tmp[0] < 0) {
	                _vec2_tmp[0] += Math.PI;
	                phi = -(Math.PI - phi);
	            }
	            else if (_vec3_tmp[2] < 0 && _vec3_tmp[0] > 0) {
	                _vec2_tmp[0] += Math.PI;
	                phi -= Math.PI;
	            }
	            m_cam.set_rotation_hover_angles(cam, phi + Math.PI, -theta);
	            break;
	        }

	        m_trans.update_transform(cam);
	        m_phy.sync_transform(cam);
	    }

	    function set_tsr(cam, trans, target, tsr_out) {
	        m_mat4.lookAt(trans, target, m_util.AXIS_Z, _mat4_tmp);
	        m_mat4.invert(_mat4_tmp, _mat4_tmp);
	        // m_mat4.rotateX(_mat4_tmp, Math.PI / 2, _mat4_tmp);
	        var rot_matrix = _mat3_tmp;
	        m_mat3.fromMat4(_mat4_tmp, rot_matrix);
	        m_quat.fromMat3(rot_matrix, _vec4_tmp);
	        m_quat.normalize(_vec4_tmp, _vec4_tmp);
	        var scale = m_tsr.get_scale(cam.render.world_tsr);
	        m_tsr.set_sep(trans, scale, _vec4_tmp, tsr_out);
	    }

	    var ca_is_var = node.bools["id0"];
	    var tr_is_var = node.bools["id1"];
	    var ta_is_var = node.bools["id2"];

	    function init(node, inst, thread_state) {
	        var o = null;
	        o = inst.objects["ca"] = get_object(node, "id0", ca_is_var, logic.variables, thread_state.variables);
	        if(!o && !ca_is_var) {
	            m_print.error("Logic script error: object not found. Node: ", node.name);
	            node.mute = true;
	        }
	        inst.objects["tr"] = get_object(node, "id1", tr_is_var, logic.variables, thread_state.variables);
	        if(!inst.objects["tr"] && ! tr_is_var) {
	            m_print.error("Logic script error: object not found. Node: ", node.name);
	            node.mute = true;
	        }
	        inst.objects["ta"] = get_object(node, "id2", ta_is_var, logic.variables, thread_state.variables);
	        if(!inst.objects["ta"] && !ta_is_var) {
	            m_print.error("Logic script error: object not found. Node: ", node.name);
	            node.mute = true;
	        }
	        inst.state = NPS_NOT_STARTED;

	        inst.camera_state = {
	            trans_start: new Float32Array(3),
	            trans_end: new Float32Array(3),
	            interp_trans: new Float32Array(3),
	            target_start: new Float32Array(3),
	            target_end: new Float32Array(3),
	            interp_target: new Float32Array(3),
	            tsr_start: new Float32Array(8),
	            tsr_end: new Float32Array(8),
	            interp_tsr: new Float32Array(8)
	        };

	    }
	    switch (logic.state) {
	    case INITIALIZATION:
	        break;
	    case RUNNING:
	        var inst = get_node_instance(node, thread_state, init);
	        var cam = ca_is_var ? get_var(node.vars["id0"], logic.variables, thread_state.variables) : inst.objects["ca"];

	        var tr = tr_is_var ? get_var(node.vars["id1"], logic.variables, thread_state.variables) : inst.objects["tr"];

	        var ta = ta_is_var ? get_var(node.vars["id2"], logic.variables, thread_state.variables) : inst.objects["ta"];

	        var trans = m_tsr.get_trans_view(tr.render.world_tsr);
	        var target = m_tsr.get_trans_view(ta.render.world_tsr);

	        switch (inst.state) {
	        case NPS_NOT_STARTED:
	            var dur = node.bools["dur"] ? convert_variable(
	                get_var(node.vars['dur'], logic.variables, thread_state.variables), NT_NUMBER) : node.floats["dur"];
	            if (dur == 0.0) {
	                set_tsr(cam, trans, target, inst.camera_state.tsr_end);
	                move_cam(cam, trans, target, inst.camera_state.tsr_end);
	                thread_state.curr_node = node.slot_idx_order;
	                return;
	            }
	            // start interpolation
	            var cam_trans = m_tsr.get_trans_view(cam.render.world_tsr);
	            m_vec3.copy(cam_trans, inst.camera_state.trans_start);
	            var move_style = m_cam.get_move_style(cam);
	            if (move_style == m_cam.MS_HOVER_CONTROLS) {
	                m_vec3.copy(cam.render.hover_pivot, inst.camera_state.target_start);
	            } else if (move_style == m_cam.MS_STATIC || move_style == m_cam.MS_EYE_CONTROLS) {
	                // calc tsr
	                m_tsr.copy(cam.render.world_tsr, inst.camera_state.tsr_start);
	                set_tsr(cam, trans, target, inst.camera_state.tsr_end);
	            } else {
	                m_vec3.copy(cam.render.pivot, inst.camera_state.target_start);
	            }
	            m_vec3.copy(trans, inst.camera_state.trans_end);
	            m_vec3.copy(target, inst.camera_state.target_end);

	            inst.state = NPS_PLAYING;
	            var trans_animator = m_time.animate(0, 1, dur * 1000, function(e) {
	                if (m_scs.check_active()) {
	                    if (move_style == m_cam.MS_STATIC || move_style == m_cam.MS_EYE_CONTROLS) {
	                        m_tsr.interpolate(inst.camera_state.tsr_start, inst.camera_state.tsr_end,
	                            m_util.smooth_step(e), inst.camera_state.interp_tsr);
	                    }
	                    else {
	                        inst.camera_state.interp_target = m_vec3.lerp(inst.camera_state.target_start,
	                            inst.camera_state.target_end, m_util.smooth_step(e), inst.camera_state.interp_target);
	                        inst.camera_state.interp_trans = m_vec3.lerp(inst.camera_state.trans_start,
	                            inst.camera_state.trans_end, m_util.smooth_step(e), inst.camera_state.interp_trans);
	                    }
	                    move_cam(cam, inst.camera_state.interp_trans, inst.camera_state.interp_target,
	                        inst.camera_state.interp_tsr);
	                    if (e == 1)
	                       inst.state = NPS_FINISHED;
	                }
	            });
	            break;
	        case NPS_PLAYING:
	            // interpolation is in progress
	            break;
	        case NPS_FINISHED:
	            // end
	            m_time.clear_animation(trans_animator);
	            inst.state = NPS_NOT_STARTED;
	            thread_state.curr_node = node.slot_idx_order;
	            break;
	        }
	        break;
	    }
	}

	function set_camera_move_style_handler(node, logic, thread_state, timeline, elapsed, start_time) {
	    var bools = node.bools;
	    function init(node, inst, thread_state) {
	        if (!bools["id0"]) {
	            var cam = inst.objects["id0"] =
	                m_obj.get_object(m_obj.GET_OBJECT_BY_DUPLI_NAME_LIST, node.objects_paths["id0"], 0);
	            if(!cam) {
	                m_print.error("Logic script error: object not found. Node: ", node.name);
	                node.mute = true;
	            }
	        }
	        if (bools["pvo"] && !bools["id1"]) {
	            inst.objects["id1"] = m_obj.get_object(m_obj.GET_OBJECT_BY_DUPLI_NAME_LIST, node.objects_paths["id1"], 0);
	        }
	    }
	    switch (logic.state) {
	    case INITIALIZATION:
	        break;
	    case RUNNING:
	        var inst = get_node_instance(node, thread_state, init);
	        var cam = bools["id0"] ? get_var(node.vars['id0'], logic.variables, thread_state.variables) : inst.objects["id0"];
	        var render = cam.render;
	        inst.cam_state = {
	            target_cam_upside_down      : render.target_cam_upside_down,
	            use_panning                 : render.use_panning,
	            horizontal_limits           : render.horizontal_limits,
	            vertical_limits             : render.vertical_limits,
	            distance_limits             : render.distance_limits,
	            hover_horiz_trans_limits    : render.hover_horiz_trans_limits,
	            hover_vert_trans_limits     : render.hover_vert_trans_limits,
	            pivot_limits                : render.pivot_limits,
	            enable_hover_hor_rotation   : render.enable_hover_hor_rotation
	        };
	        if (m_obj_util.is_camera(cam)) {
	            var cam_render = cam.render;
	            var cam_state = inst.cam_state;
	            m_cam.wipe_move_style(cam);

	            switch (node.common_usage_names["camera_move_style"]) {
	            case NCMS_STATIC:
	                cam_render.move_style = m_cam.MS_STATIC;
	                break;
	            case NCMS_EYE:
	                cam_render.move_style = m_cam.MS_EYE_CONTROLS;

	                var pos = m_tsr.get_trans_view(cam_render.world_tsr);

	                m_cam.setup_eye_model(cam, pos, null, cam_state.horizontal_limits, cam_state.vertical_limits);
	                break;
	            case NCMS_HOVER:
	                cam_render.move_style = m_cam.MS_HOVER_CONTROLS;

	                var pos = m_tsr.get_trans_view(cam_render.world_tsr);
	                var pivot = _vec3_tmp;
	                if (node.bools["pvo"]) {
	                    var pvo = bools["id1"] ? get_var(node.vars['id1'], logic.variables, thread_state.variables) : inst.objects["id1"];
	                    pivot = m_tsr.get_trans_view(pvo.render.world_tsr);
	                }
	                else {
	                    pivot[0] = node.bools["pvx"] ?
	                        convert_variable(get_var(node.vars["pvx"], logic.variables, thread_state.variables), NT_NUMBER) : node.floats["pvx"];
	                    pivot[1] = node.bools["pvy"] ?
	                        convert_variable(get_var(node.vars["pvy"], logic.variables, thread_state.variables), NT_NUMBER) : node.floats["pvy"];
	                    pivot[2] = node.bools["pvz"] ?
	                        convert_variable(get_var(node.vars['pvz'], logic.variables, thread_state.variables), NT_NUMBER) : node.floats["pvz"];
	                }

	                m_cam.setup_hover_model(cam, pos, pivot, cam_state.distance_limits,
	                        cam_state.vertical_limits, cam_state.hover_horiz_trans_limits, cam_state.hover_vert_trans_limits, cam_state.enable_hover_hor_rotation);
	                break;
	            case NCMS_TARGET:
	                cam_render.move_style = m_cam.MS_TARGET_CONTROLS;

	                var pos = m_tsr.get_trans_view(cam_render.world_tsr);
	                var pivot = _vec3_tmp;
	                if (node.bools["pvo"]) {
	                    var pvo = bools["id1"] ? get_var(node.vars['id1'], logic.variables, thread_state.variables) : inst.objects["id1"];
	                    pivot = m_tsr.get_trans_view(pvo.render.world_tsr);
	                } else {
	                    pivot[0] = node.bools["pvx"] ?
	                        convert_variable(get_var(node.vars["pvx"], logic.variables, thread_state.variables), NT_NUMBER) : node.floats["pvx"];
	                    pivot[1] = node.bools["pvy"] ?
	                        convert_variable(get_var(node.vars["pvy"], logic.variables, thread_state.variables), NT_NUMBER) : node.floats["pvy"];
	                    pivot[2] = node.bools["pvz"] ?
	                        convert_variable(get_var(node.vars['pvz'], logic.variables, thread_state.variables), NT_NUMBER) : node.floats["pvz"];
	                }

	                m_cam.setup_target_model(cam, pos, pivot, cam_state.horizontal_limits,
	                        cam_state.vertical_limits, cam_state.distance_limits, cam_state.pivot_limits, cam_state.use_panning);
	                break;
	            }

	            // velocities
	            var vel = _vec3_tmp1;
	            vel[0] = node.bools["vtr"] ?
	                        convert_variable(get_var(node.vars["vtr"], logic.variables, thread_state.variables), NT_NUMBER) : node.floats["vtr"];
	            vel[1] = node.bools["vro"] ?
	                        convert_variable(get_var(node.vars["vro"], logic.variables, thread_state.variables), NT_NUMBER) : node.floats["vro"];
	            vel[2] = node.bools["vzo"] ?
	                        convert_variable(get_var(node.vars['vzo'], logic.variables, thread_state.variables), NT_NUMBER) : node.floats["vzo"];
	            vel[0] = m_util.clamp(vel[0], 0, Infinity);
	            vel[1] = m_util.clamp(vel[1], 0, Infinity);
	            vel[2] = m_util.clamp(vel[2], 0, 0.99);
	            cam_render.velocity_trans = vel[0];
	            cam_render.velocity_rot   = vel[1];
	            cam_render.velocity_zoom  = vel[2];

	            m_trans.update_transform(cam);
	            m_phy.sync_transform(cam);
	            // init ortho after the camera was updated
	            m_cam.init_ortho_props(cam);
	        } else {
	            m_print.error("Logic script error: object is not a Camera. Node: ", node.name);
	        }

	        thread_state.curr_node = node.slot_idx_order;
	        break;
	    }
	}

	function set_camera_limits_handler(node, logic, thread_state, timeline, elapsed, start_time) {
	    var bools = node.bools;
	    function init(node, inst, thread_state) {
	        var cam = null;
	        if (!bools["id0"]) {
	            cam = inst.objects["id0"] =
	                m_obj.get_object(m_obj.GET_OBJECT_BY_DUPLI_NAME_LIST, node.objects_paths["id0"], 0);
	            if(!cam) {
	                m_print.error("Logic script error: object not found. Node: ", node.name);
	                node.mute = true;
	            }
	        }
	    }
	    switch (logic.state) {
	    case INITIALIZATION:
	        break;
	    case RUNNING:
	        var inst = get_node_instance(node, thread_state, init);
	        var cam = bools["id0"] ? get_var(node.vars['id0'], logic.variables, thread_state.variables) : inst.objects["id0"];
	        if (m_obj_util.is_camera(cam)) {
	            var cam_render = cam.render;

	            switch(cam_render.move_style) {
	            case m_cam.MS_TARGET_CONTROLS:
	                if (node.bools["dsl"]) {
	                    var dslmin = node.bools["dslmin"] ? convert_variable(
	                        get_var(node.vars['dslmin'], logic.variables, thread_state.variables), NT_NUMBER) : node.floats["dslmin"];
	                    var dslmax = node.bools["dslmax"] ? convert_variable(
	                        get_var(node.vars['dslmax'], logic.variables, thread_state.variables), NT_NUMBER) : node.floats["dslmax"];

	                    var limits = {};
	                    limits.min = Math.max(dslmin, 0);
	                    limits.max = Math.max(dslmax, 0);
	                    m_cam.set_distance_limits(cam, limits);
	                }

	                if (node.bools["vrl"]) {
	                    var vrldown = node.bools["vrldown"] ? convert_variable(
	                        get_var(node.vars['vrldown'], logic.variables, thread_state.variables), NT_NUMBER) : node.floats["vrldown"];
	                    var vrlup = node.bools["vrlup"] ? convert_variable(
	                        get_var(node.vars['vrlup'], logic.variables, thread_state.variables), NT_NUMBER) : node.floats["vrlup"];

	                    var limits = {};
	                    limits.down = vrldown;
	                    limits.up = vrlup;
	                    limits.camera_space = node.common_usage_names["cam_lim_vert_rot_space_type"] == "CAMERA";
	                    m_cam.set_vertical_rot_limits(cam, limits);
	                }

	                if (node.bools["hrl"]) {
	                    var hrlleft = node.bools["hrlleft"] ? convert_variable(
	                        get_var(node.vars['hrlleft'], logic.variables, thread_state.variables), NT_NUMBER) : node.floats["hrlleft"];
	                    var hrlright = node.bools["hrlright"] ? convert_variable(
	                        get_var(node.vars['hrlright'], logic.variables, thread_state.variables), NT_NUMBER) : node.floats["hrlright"];

	                    var limits = {};
	                    limits.left = hrlleft;
	                    limits.right = hrlright;
	                    limits.camera_space = node.common_usage_names["cam_lim_hor_rot_space_type"] == "CAMERA";
	                    m_cam.set_horizontal_rot_limits(cam, limits);
	                }

	                if (node.bools["pvl"]) {
	                    var pvlmin = node.bools["pvlmin"] ? convert_variable(
	                        get_var(node.vars['pvlmin'], logic.variables, thread_state.variables), NT_NUMBER) : node.floats["pvlmin"];
	                    var pvlmax = node.bools["pvlmax"] ? convert_variable(
	                        get_var(node.vars['pvlmax'], logic.variables, thread_state.variables), NT_NUMBER) : node.floats["pvlmax"];

	                    var limits = {};
	                    limits.min_z = pvlmin;
	                    limits.max_z = pvlmax;
	                    m_cam.set_pivot_limits(cam, limits);
	                }

	                break;
	            case m_cam.MS_HOVER_CONTROLS:
	                if (node.bools["htl"]) {
	                    var htlmin = node.bools["htlmin"] ? convert_variable(
	                        get_var(node.vars['htlmin'], logic.variables, thread_state.variables), NT_NUMBER) : node.floats["htlmin"];
	                    var htlmax = node.bools["htlmax"] ? convert_variable(
	                        get_var(node.vars['htlmax'], logic.variables, thread_state.variables), NT_NUMBER) : node.floats["htlmax"];

	                    var limits = {};
	                    limits.min = htlmin;
	                    limits.max = htlmax;
	                    m_cam.set_hor_trans_limits(cam, limits);
	                }

	                if (node.bools["vtl"]) {
	                    var vtlmin = node.bools["vtlmin"] ? convert_variable(
	                        get_var(node.vars['vtlmin'], logic.variables, thread_state.variables), NT_NUMBER) : node.floats["vtlmin"];
	                    var vtlmax = node.bools["vtlmax"] ? convert_variable(
	                        get_var(node.vars['vtlmax'], logic.variables, thread_state.variables), NT_NUMBER) : node.floats["vtlmax"];

	                    var limits = {};
	                    limits.min = vtlmin;
	                    limits.max = vtlmax;
	                    m_cam.set_vert_trans_limits(cam, limits);
	                }

	                if (node.bools["vrl"]) {
	                    var vrldown = node.bools["vrldown"] ? convert_variable(
	                        get_var(node.vars['vrldown'], logic.variables, thread_state.variables), NT_NUMBER) : node.floats["vrldown"];
	                    var vrlup = node.bools["vrlup"] ? convert_variable(
	                        get_var(node.vars['vrlup'], logic.variables, thread_state.variables), NT_NUMBER) : node.floats["vrlup"];

	                    var limits = {};
	                    limits.down = vrldown;
	                    limits.up = vrlup;
	                    limits.camera_space = node.common_usage_names["cam_lim_vert_rot_space_type"] == "CAMERA";
	                    m_cam.hover_set_vertical_limits(cam, limits);
	                }

	                if (node.bools["dsl"]) {
	                    var dslmin = node.bools["dslmin"] ? convert_variable(
	                        get_var(node.vars['dslmin'], logic.variables, thread_state.variables), NT_NUMBER) : node.floats["dslmin"];
	                    var dslmax = node.bools["dslmax"] ? convert_variable(
	                        get_var(node.vars['dslmax'], logic.variables, thread_state.variables), NT_NUMBER) : node.floats["dslmax"];

	                    var limits = {};
	                    limits.min = Math.max(dslmin, 0);
	                    limits.max = Math.max(dslmax, 0);
	                    m_cam.hover_set_distance_limits(cam, limits);
	                }
	                break;
	            case m_cam.MS_EYE_CONTROLS:
	                if (node.bools["vrl"]) {
	                    var vrldown = node.bools["vrldown"] ? convert_variable(
	                        get_var(node.vars['vrldown'], logic.variables, thread_state.variables), NT_NUMBER) : node.floats["vrldown"];
	                    var vrlup = node.bools["vrlup"] ? convert_variable(
	                        get_var(node.vars['vrlup'], logic.variables, thread_state.variables), NT_NUMBER) : node.floats["vrlup"];

	                    var limits = {};
	                    limits.down = vrldown;
	                    limits.up = vrlup;
	                    limits.camera_space = node.common_usage_names["cam_lim_vert_rot_space_type"] == "CAMERA";
	                    m_cam.set_vertical_rot_limits(cam, limits);
	                }

	                if (node.bools["hrl"]) {
	                    var hrlleft = node.bools["hrlleft"] ? convert_variable(
	                        get_var(node.vars['hrlleft'], logic.variables, thread_state.variables), NT_NUMBER) : node.floats["hrlleft"];
	                    var hrlright = node.bools["hrlright"] ? convert_variable(
	                        get_var(node.vars['hrlright'], logic.variables, thread_state.variables), NT_NUMBER) : node.floats["hrlright"];

	                    var limits = {};
	                    limits.left = hrlleft;
	                    limits.right = hrlright;
	                    limits.camera_space = node.common_usage_names["cam_lim_hor_rot_space_type"] == "CAMERA";
	                    m_cam.set_horizontal_rot_limits(cam, limits);
	                }

	                break;
	            case m_cam.MS_STATIC:
	                break;
	            }

	            m_trans.update_transform(cam);
	            m_phy.sync_transform(cam);
	        } else {
	            m_print.error("Logic script error: object is not a Camera. Node: ", node.name);
	        }
	        // init ortho after the camera was updated
	        // m_cam.init_ortho_props(cam);
	        thread_state.curr_node = node.slot_idx_order;
	        break;
	    }
	}

	function move_to_handler(node, logic, thread_state, timeline, elapsed, start_time) {
	    function move_to(obj, dest) {
	        m_trans.set_tsr(obj, dest);

	        m_trans.update_transform(obj);
	        m_phy.sync_transform(obj);
	    }
	    var bools = node.bools;
	    var is_var0 = bools["id0"];
	    var is_var1 = bools["id1"];
	    function init(node, inst, thread_state) {
	        inst.objects["id0"] = get_object(node, "id0", is_var0, logic.variables, thread_state.variables);
	        if (!inst.objects["id0"] && !is_var0) {
	            m_print.error("Logic script error: object not found. Node: ", node.name);
	            node.mute = true;
	        }

	        inst.objects["id1"] = get_object(node, "id1", is_var1, logic.variables, thread_state.variables);
	        if (!inst.objects["id1"] && !is_var1) {
	            m_print.error("Logic script error: object not found. Node: ", node.name);
	            node.mute = true;
	        }

	        inst.state = NPS_NOT_STARTED;

	        inst.obj_state = {
	            dest_tsr_start: new Float32Array(8),
	            dest_tsr_end: new Float32Array(8),
	            interp_tsr_dest: new Float32Array(8)
	        };
	    }
	    switch (logic.state) {
	    case INITIALIZATION:
	        break;    
	    case RUNNING:
	        var inst = get_node_instance(node, thread_state, init);
	        var obj = bools["id0"] ? get_var(node.vars['id0'], logic.variables, thread_state.variables) : inst.objects["id0"];
	        if (obj.is_dynamic) {
	            m_tsr.copy(obj.render.world_tsr, inst.obj_state.dest_tsr_start);
	            //destination
	            var de = bools["id1"] ? get_var(node.vars['id1'], logic.variables, thread_state.variables) : inst.objects["id1"];
	            m_tsr.copy(de.render.world_tsr, inst.obj_state.dest_tsr_end);

	            switch (inst.state) {
	            case NPS_NOT_STARTED:
	                var dur = node.bools["dur"] ? convert_variable(
	                    get_var(node.vars['dur'], logic.variables, thread_state.variables), NT_NUMBER) : node.floats["dur"];
	                if (dur == 0.0) {
	                    move_to(obj, inst.obj_state.dest_tsr_end);
	                    thread_state.curr_node = node.slot_idx_order;
	                    return;
	                }

	                inst.state = NPS_PLAYING;
	                var trans_animator = m_time.animate(0, 1, dur * 1000, function(e) {
	                    if (m_scs.check_active()) {
	                        inst.obj_state.interp_dest = m_tsr.interpolate(inst.obj_state.dest_tsr_start,
	                            inst.obj_state.dest_tsr_end, m_util.smooth_step(e), inst.obj_state.interp_tsr_dest);
	                        move_to(obj, inst.obj_state.interp_tsr_dest);
	                        if (e == 1)
	                        inst.state = NPS_FINISHED;
	                }
	                });
	                break;
	            case NPS_PLAYING:
	                // interpolation is in progress
	                break;
	            case NPS_FINISHED:
	                // end
	                m_time.clear_animation(trans_animator);
	                inst.state = NPS_NOT_STARTED;
	                thread_state.curr_node = node.slot_idx_order;
	                break;
	            }
	            break;
	        } else {
	            m_print.error("Logic script error: object '" + obj.name + "' must be dynamic. Node: ", node.name);
	            thread_state.curr_node = node.slot_idx_order;
	        }
	    }
	}

	function transform_object_handler(node, logic, thread_state, timeline, elapsed, start_time) {
	    function transform_obj(obj, tsr, space) {
	        if(space == NST_WORLD){
	            m_trans.set_tsr(obj, tsr);
	        }
	        else {
	            m_trans.set_tsr_rel(obj, tsr);
	        }

	        m_trans.update_transform(obj);
	        m_phy.sync_transform(obj);       
	    }

	    var is_var = node.bools["id0"];
	    function init(node, inst, thread_state) {
	        inst.obj = get_object(node, "id0", is_var, logic.variables, thread_state.variables);
	        if(!inst.obj && !is_var) {
	            m_print.error("Logic script error: object not found. Node: ", node.name);
	            node.mute = true;
	        }

	        inst.state = NPS_NOT_STARTED;

	        inst.obj_state = {
	            space: NST_WORLD,
	            tsr_start: new Float32Array(8),
	            tsr_end: new Float32Array(8),
	            interp_tsr: new Float32Array(8)
	        };
	    }
	    var inst = get_node_instance(node, thread_state, init);
	    switch (logic.state) {
	    case INITIALIZATION:
	        break;
	    case RUNNING:
	        var obj = is_var ? get_var(node.vars["id0"], logic.variables, thread_state.variables) : inst.obj;

	        switch (inst.state) {
	        case NPS_NOT_STARTED:
	            var tr = _vec3_tmp1;
	            tr[0] = node.bools["trx"] ?
	                convert_variable(get_var(node.vars['trx'], logic.variables, thread_state.variables), NT_NUMBER) : node.floats["trx"];
	            tr[1] = node.bools["try"] ?
	                convert_variable(get_var(node.vars['try'], logic.variables, thread_state.variables), NT_NUMBER) : node.floats["try"];
	            tr[2] = node.bools["trz"] ?
	                convert_variable(get_var(node.vars['trz'], logic.variables, thread_state.variables), NT_NUMBER) : node.floats["trz"];
	            //euler angles rotation
	            var eul_rot =  _vec3_tmp;
	            eul_rot[0] = node.bools["rox"] ?
	                convert_variable(get_var(node.vars['rox'], logic.variables, thread_state.variables), NT_NUMBER) * Math.PI / 180 : node.floats["rox"];
	            eul_rot[1] = node.bools["roy"] ?
	                convert_variable(get_var(node.vars['roy'], logic.variables, thread_state.variables), NT_NUMBER) * Math.PI / 180 : node.floats["roy"];
	            eul_rot[2] = node.bools["roz"] ?
	                convert_variable(get_var(node.vars['roz'], logic.variables, thread_state.variables), NT_NUMBER) * Math.PI / 180 : node.floats["roz"];
	            var sc = node.bools["sc"] ? get_var(node.vars['sc'], logic.variables, thread_state.variables) : node.floats["sc"];
	            
	            m_util.euler_to_quat(eul_rot, _vec4_tmp);
	            m_tsr.set_sep(
	                tr,
	                sc,
	                _vec4_tmp,
	                inst.obj_state.tsr_end
	            );

	            inst.obj_state.space = node.common_usage_names["space_type"];
	            switch (inst.obj_state.space) {
	                case NST_WORLD:
	                    m_trans.get_tsr(obj, inst.obj_state.tsr_start);
	                    break;
	                case NST_PARENT:
	                    m_trans.get_tsr_rel(obj, inst.obj_state.tsr_start);
	                    break;
	                case NST_LOCAL:
	                    m_trans.get_tsr_rel(obj, inst.obj_state.tsr_start);
	                    m_tsr.multiply(inst.obj_state.tsr_start, inst.obj_state.tsr_end, inst.obj_state.tsr_end);
	                    break;
	            }

	            var dur = node.bools["dur"] ?
	                convert_variable(get_var(node.vars['dur'], logic.variables, thread_state.variables), NT_NUMBER) : node.floats["dur"];
	            if (dur == 0.0) {
	                transform_obj(obj, inst.obj_state.tsr_end, inst.obj_state.space);
	                thread_state.curr_node = node.slot_idx_order;
	                return;
	            }

	            inst.state = NPS_PLAYING;
	            var trans_animator = m_time.animate(0, 1, dur * 1000, function(e) {
	                if (m_scs.check_active()) {
	                    m_tsr.interpolate(inst.obj_state.tsr_start, inst.obj_state.tsr_end,
	                            m_util.smooth_step(e), inst.obj_state.interp_tsr);

	                    transform_obj(obj, inst.obj_state.interp_tsr, inst.obj_state.space);

	                    if (e == 1)
	                        inst.state = NPS_FINISHED;
	               }
	            });
	            break;
	        case NPS_PLAYING:
	            // interpolation is in progress
	            break;
	        case NPS_FINISHED:
	            // end
	            m_time.clear_animation(trans_animator);
	            inst.state = NPS_NOT_STARTED;
	            thread_state.curr_node = node.slot_idx_order;
	            break;
	        }
	        break;
	    }
	}

	function speaker_play_handler(node, logic, thread_state, timeline, elapsed, start_time) {
	    var is_var = node.bools["id0"];
	    function init(node, inst, thread_state) {
	        inst.obj = get_object(node, "id0", is_var, logic.variables, thread_state.variables);
	        if(!inst.obj && !is_var) {
	            m_print.error("Logic script error: object not found. Node: ", node.name);
	            node.mute = true;
	        }
	    }
	    switch (logic.state) {
	    case INITIALIZATION:
	        if (node.bools["not_wait"] == undefined)
	            node.bools["not_wait"] = true;
	        break;
	    case RUNNING:
	        var inst = get_node_instance(node, thread_state, init);
	        inst.obj = is_var ? get_var(node.vars["id0"], logic.variables, thread_state.variables) : inst.obj;
	        if (!m_sfx.is_playing(inst.obj)) {
	            if (inst.state == NPS_PLAYING)
	                inst.state = NPS_FINISHED;
	        }
	        switch (inst.state) {
	        case NPS_NOT_STARTED:
	            // this node is not playing
	            // check other threads
	            for (var k in logic.logic_threads) {
	                var curr_node = logic.logic_threads[k].thread_state.curr_node;
	                if (curr_node != -1) { // case when the thread is already stopped
	                    var node2 = logic.logic_threads[k].nodes[curr_node];
	                    if (node2.type == "SPEAKER_PLAY" && node2!= node && inst.state == NPS_PLAYING && node2.obj == node.obj) {
	                        node2.state = NPS_FINISHED;
	                    }
	                }
	            }

	            // blocking selection
	            if (!node.bools["not_wait"])
	                thread_state.in_progress = true;

	            m_sfx.play_def(inst.obj);
	            inst.state = NPS_PLAYING;
	            break;
	        case NPS_PLAYING:
	            // playing
	            if (node.bools["not_wait"]) {
	                thread_state.curr_node = node.slot_idx_order;
	                inst.state = NPS_NOT_STARTED;
	            }
	            break;
	        case NPS_FINISHED:
	            // end playing
	            if (!node.bools["not_wait"])
	                thread_state.in_progress = false;
	            thread_state.curr_node = node.slot_idx_order;
	            inst.state = NPS_NOT_STARTED;
	            break;
	        default:
	            m_util.panic("Unknown state of " + node.name);
	            inst.state = NPS_NOT_STARTED;
	            break;
	        }
	    }
	}

	function speaker_stop_handler(node, logic, thread_state, timeline, elapsed, start_time) {
	    var is_var = node.bools["id0"];
	    function init(node, inst, thread_state) {
	        inst.obj = get_object(node, "id0", is_var, logic.variables, thread_state.variables);
	        if(!inst.obj && !is_var) {
	            m_print.error("Logic script error: object not found. Node: ", node.name);
	            node.mute = true;
	        }
	    }
	    switch (logic.state) {
	    case INITIALIZATION:
	        break;
	    case RUNNING:
	        var inst = get_node_instance(node, thread_state, init);
	        var obj = is_var ? get_var(node.vars["id0"], logic.variables, thread_state.variables) : inst.obj;
	        m_sfx.stop(obj);
	        thread_state.curr_node = node.slot_idx_order;
	        break;
	    }
	}

	function set_shader_node_param_handler(node, logic, thread_state, timeline, elapsed, start_time) {
	    function init(node, inst, thread_state) {
	        if (node.objects_paths["id0"]) {
	            inst.objects["id0"] = m_obj.get_object(m_obj.GET_OBJECT_BY_DUPLI_NAME_LIST, node.objects_paths["id0"], 0);
	            if(!node.objects_paths["id0"]) {
	                m_print.error("Logic script error: object not found. Node: ", node.name);
	                node.mute = true;
	            }
	            node.nodes_paths["id0"].unshift(node.materials_names["id0"]);
	        }
	    }
	    switch (logic.state) {
	    case INITIALIZATION:
	        break;
	    case RUNNING:
	        var inst = get_node_instance(node, thread_state, init);
	        var obj = inst.objects["id0"];
	        var name_list = node.nodes_paths["id0"];

	        var mat_name = name_list[0];
	        var batch_main = m_batch.find_batch_material(obj, mat_name, "MAIN");

	        thread_state.curr_node = node.slot_idx_order;

	        if (batch_main === null) {
	            m_print.error("Material \"" + mat_name +
	                          "\" was not found in the object \"" + obj.name + "\".");
	            return;
	        }

	        if (node.shader_nd_type == "ShaderNodeRGB") {
	            var ind = m_obj.get_node_rgb_ind_by_name_list(batch_main.node_rgb_inds,
	                                                        name_list, 1);
	            m_obj.set_nodemat_rgb(obj, mat_name, ind,
	                node.bools["id0"] ?
	                    convert_variable(get_var(node.vars["id0"], logic.variables, thread_state.variables), NT_NUMBER) : node.floats["id0"],
	                node.bools["id1"] ?
	                    convert_variable(get_var(node.vars["id1"], logic.variables, thread_state.variables), NT_NUMBER) : node.floats["id1"],
	                node.bools["id2"] ?
	                    convert_variable(get_var(node.vars["id2"], logic.variables, thread_state.variables), NT_NUMBER) : node.floats["id2"]);
	        }

	        if (node.shader_nd_type == "ShaderNodeValue") {
	            var ind = m_obj.get_node_val_ind_by_name_list(batch_main.node_value_inds,
	                                                        name_list, 1);
	            m_obj.set_nodemat_value(obj, mat_name, ind,
	                node.bools["id0"] ?
	                    convert_variable(get_var(node.vars["id0"], logic.variables, thread_state.variables), NT_NUMBER) : node.floats["id0"]);
	        }
	        break;
	    }
	}

	function math_handler(node, logic, thread_state, timeline, elapsed, start_time) {
	    switch (logic.state) {
	    case RUNNING:
	        var val1 = (node.vars["id0"][1] == -1) ? node.floats["inp1"] : convert_variable(
	            get_var(node.vars["id0"], logic.variables, thread_state.variables), NT_NUMBER);
	        var val2 = (node.vars["id1"][1] == -1) ? node.floats["inp2"] : convert_variable(
	            get_var(node.vars["id1"], logic.variables, thread_state.variables), NT_NUMBER);
	        var result = 0;
	        switch (node.op) {
	        case NMO_ADD:
	            result = val1 + val2;
	            break;
	        case NMO_MUL:
	            result = val1 * val2;
	            break;
	        case NMO_SUB:
	            result = val1 - val2;
	            break;
	        case NMO_DIV:
	            if (val2 == 0)
	                m_util.panic("Division by zero in Logic script");

	            result = val1 / val2;
	            break;
	        case NMO_RAND:
	            result = Math.random() * (val2 - val1) + val1;
	            break;
	        case NMO_SIN:
	            result = Math.sin(val1);
	            break;
	        case NMO_COS:
	            result = Math.cos(val1);
	            break;
	        case NMO_TAN:
	            result = Math.tan(val1);
	            break;
	        case NMO_ARCSIN:
	            result = Math.asin(val1);
	            break;
	        case NMO_ARCCOS:
	            result = Math.acos(val1);
	            break;
	        case NMO_ARCTAN:
	            result = Math.atan(val1);
	            break;
	        case NMO_LOG:
	            result = Math.log(val1);
	            break;
	        case NMO_MIN:
	            result = Math.min(val1, val2);
	            break;
	        case NMO_MAX:
	            result = Math.max(val1, val2);
	            break;
	        case NMO_ROUND:
	            result = Math.round(val1);
	            break;
	        case NMO_MOD:
	            result = val1 % val2;
	            break;
	        case NMO_ABS:
	            result = Math.abs(val1);
	            break;
	        }

	        set_var(node.vars["vd"], logic.variables, thread_state.variables, result);
	        thread_state.curr_node = node.slot_idx_order;
	        break;
	    }
	}

	function conditional_jump_handler(node, logic, thread_state, timeline, elapsed, start_time) {
	    switch (logic.state) {
	    case RUNNING:
	        var arg_type = node.common_usage_names["variable_type"];
	        var arg_arr = get_const_value_storage(node, arg_type);

	        var cond_result = false;

	        if (arg_type == NT_OBJECT) {
	            var val1 = node.bools["id0"] ?
	            get_var(node.vars["id0"], logic.variables, thread_state.variables) :
	            m_obj.get_object(m_obj.GET_OBJECT_BY_DUPLI_NAME_LIST, node.objects_paths["id0"], 0);
	            var val2 = node.bools["id1"] ?
	            get_var(node.vars["id1"], logic.variables, thread_state.variables) :
	            m_obj.get_object(m_obj.GET_OBJECT_BY_DUPLI_NAME_LIST, node.objects_paths["id1"], 0);

	            switch (node.common_usage_names["condition"]) {
	            case NC_EQUAL:
	                if (val1 == val2)
	                    cond_result = true;
	                break;
	            case NC_NOTEQUAL:
	                if (val1 != val2)
	                    cond_result = true;
	                break;
	            }
	        } else {
	            var val1 = (node.vars["id0"][1] == -1) ? arg_arr["inp1"] : convert_variable(
	                get_var(node.vars["id0"], logic.variables, thread_state.variables), arg_type);
	            var val2 = (node.vars["id1"][1] == -1) ? arg_arr["inp2"] : convert_variable(
	                get_var(node.vars["id1"], logic.variables, thread_state.variables), arg_type);

	            switch (node.common_usage_names["condition"]) {
	            case NC_EQUAL:
	                if (val1 == val2)
	                    cond_result = true;
	                break;
	            case NC_NOTEQUAL:
	                if (val1 != val2)
	                    cond_result = true;
	                break;
	            case NC_LESS:
	                if (val1 < val2)
	                    cond_result = true;
	                break;
	            case NC_GREATER:
	                if (val1 > val2)
	                    cond_result = true;
	                break;
	            case NC_LEQUAL:
	                if (val1 <= val2)
	                    cond_result = true;
	                break;
	            case NC_GEQUAL:
	                if (val1 >= val2)
	                    cond_result = true;
	                break;
	            }
	        }

	        if (cond_result)
	            thread_state.curr_node = node.slot_idx_jump;
	        else
	            thread_state.curr_node = node.slot_idx_order;

	        break;
	    }
	}

	function regstore_handler(node, logic, thread_state, timeline, elapsed, start_time) {
	    switch (logic.state) {
	    case RUNNING:
	        if (node.bools["vs"]) {
	            var value = get_var(node.vars["vs"], logic.variables, thread_state.variables);
	        } else {
	            var var_type = node.common_usage_names["variable_type"];
	            var arg_arr = get_const_value_storage(node, var_type);
	            if (var_type == NT_OBJECT) {
	                var value = m_obj.get_object(m_obj.GET_OBJECT_BY_DUPLI_NAME_LIST, arg_arr["id0"], 0);
	            } else {
	                var value = arg_arr["inp1"];
	            }
	        }
	        set_var([(node.bools["new"] && node.bools["gl"]) || node.vars["vd"][0], node.vars["vd"][1]], logic.variables, thread_state.variables, value);
	        thread_state.curr_node = node.slot_idx_order;
	        break;
	    }
	}

	function get_object(node, id, is_var, global_vars, local_vars) {
	    return is_var ? get_var(node.vars[id], global_vars, local_vars) : m_obj.get_object(m_obj.GET_OBJECT_BY_DUPLI_NAME_LIST, node.objects_paths[id], 0);
	}

	function get_thread_nodes(thread) {
	    var callstack = thread.thread_state.callstack;
	    if (callstack.length <= 1) {
	        var nodes = thread.nodes;
	    } else {
	        var nodes = callstack[callstack.length - 1].logic_func.func.nodes;
	    }
	    return nodes;
	}

	function play_anim_handler(node, logic, thread_state, timeline, elapsed, start_time) {
	    // return anim slot number for already applied, -1 otherwise
	    function get_slot_by_anim_name(obj, anim_name) {
	        var anim_slot = -1;
	        for (var i = 0; i < 8; i++) {
	            var anim_slot_obj = obj.anim_slots[i];
	            if (anim_slot_obj && anim_slot_obj.animation_name) {
	                if (m_anim.strip_baked_suffix(anim_slot_obj.animation_name) == m_anim.strip_baked_suffix(anim_name))
	                    if (anim_slot != -1)
	                        anim_slot = i;
	                    else
	                        return -1;
	            }
	        }

	        return anim_slot;
	    }

	    var is_var = node.bools["id0"];
	    var is_env = node.bools["env"];

	    function init(node, inst, thread_state) {
	        inst.obj = is_env ? get_world(node) : get_object(node, "id0", is_var, logic.variables, thread_state.variables);
	        if(!inst.obj && !is_var) {
	            m_print.error("Logic script error: object not found. Node: ", node.name);
	            node.mute = true;
	        }
	    }

	    switch (logic.state) {
	    case INITIALIZATION:
	        break;
	    case RUNNING:
	        var inst = get_node_instance(node, thread_state, init);
	        if (!is_env)
	            inst.obj = is_var ? get_var(node.vars["id0"], logic.variables, thread_state.variables) : inst.obj;
	        if (inst.state == NPS_PLAYING && !m_anim.is_play(inst.obj, inst.anim_slot))
	            inst.state = NPS_FINISHED;

	        switch (inst.state) {
	        case NPS_NOT_STARTED:
	            // this node is not playing
	            // check other threads
	            for (var k in logic.logic_threads) {
	                var thread = logic.logic_threads[k];
	                var script = get_thread_nodes(thread);

	                var curr_node = thread.thread_state.curr_node;
	                if (curr_node != -1) { // case when the thread is already stopped
	                    var node2 = script[curr_node];
	                    var inst2 = get_node_instance(node2, thread.thread_state);
	                    if (node2.type == "PLAY_ANIM" && node2 != node && inst2.state == NPS_PLAYING && inst2.obj == inst.obj)
	                        inst2.state = NPS_FINISHED;
	                }
	            }

	            var behavior = node.common_usage_names["param_anim_behavior"];
	            if (node.anim_name == "") {
	                // TODO make check_anim for default animation
	                m_anim.apply_def(inst.obj);
	                m_anim.set_behavior(inst.obj, behavior, m_anim.SLOT_ALL);
	            } else {
	                var anim_slot = get_slot_by_anim_name(inst.obj, node.anim_name);

	                if (anim_slot == -1) {
	                    inst.anim_slot = m_anim.slot_by_anim_type(inst.obj, node.anim_name);
	                    m_anim.apply(inst.obj, null, node.anim_name, inst.anim_slot);
	                } else
	                    inst.anim_slot = anim_slot;

	                m_anim.set_behavior(inst.obj, behavior,  inst.anim_slot);
	            }

	            // blocking selection
	            if (!node.bools["not_wait"])
	                thread_state.in_progress = true;

	            m_anim.play(inst.obj, null, inst.anim_slot);
	            inst.state = NPS_PLAYING;

	            // if we can we must switch to the next node immediately
	            // else there could be a conflict between nodes of such type
	            if (node.bools["not_wait"]) {
	                thread_state.curr_node = node.slot_idx_order;
	                inst.state = NPS_NOT_STARTED;
	            }
	            break;
	        case NPS_PLAYING:
	            // playing
	            // do nothing
	            break;
	        case NPS_FINISHED:
	            // end playing
	            if (!node.bools["not_wait"])
	                thread_state.in_progress = false;
	            thread_state.curr_node = node.slot_idx_order;
	            inst.state = NPS_NOT_STARTED;
	            break;
	        default:
	            m_util.panic("Unknown state of " + node.name);
	            inst.state = NPS_NOT_STARTED;
	            break;
	        }
	        break;
	    }
	}

	function stop_anim_handler(node, logic, thread_state, timeline, elapsed, start_time) {
	    var is_var = node.bools["id0"];
	    var is_env = node.bools["env"];
	    function init(node, inst, thread_state) {
	        inst.obj = is_env ? get_world(node) : get_object(node, "id0", is_var, logic.variables, thread_state.variables);
	        if(!inst.obj && !is_var) {
	            m_print.error("Logic script error: object not found. Node: ", node.name);
	            node.mute = true;
	        }
	    }
	    switch (logic.state) {
	    case INITIALIZATION:
	        break;
	    case RUNNING:
	        var inst = get_node_instance(node, thread_state, init);
	        inst.obj = is_var ? get_var(node.vars["id0"], logic.variables, thread_state.variables) : inst.obj;
	        m_anim.stop(inst.obj, m_anim.SLOT_ALL);
	        if (node.bools["rst"])
	            m_anim.set_first_frame(inst.obj, m_anim.SLOT_ALL);
	        thread_state.curr_node = node.slot_idx_order;
	        break;
	    }
	}

	function string_handler(node, logic, thread_state, timeline, elapsed, start_time) {
	    switch (logic.state) {
	    case RUNNING:
	        var op1 = node.bools["id0"] ? convert_variable(
	            get_var(node.vars['id0'], logic.variables, thread_state.variables), NT_STRING) : node.strings["id0"];
	        var op2 = node.bools["id1"] ? convert_variable(
	            get_var(node.vars['id1'], logic.variables, thread_state.variables), NT_STRING) : node.strings["id1"];
	        var result = 0;
	        switch (node.common_usage_names["string_operation"]) {
	        case NSO_JOIN:
	            result = op1 + op2;
	            break;
	        case NSO_FIND:
	            result = op1.indexOf(op2);
	            break;
	        case NSO_REPLACE:
	            var op3 = node.bools["id2"] ? convert_variable(
	                get_var(node.vars['id2'], logic.variables, thread_state.variables), NT_STRING) : node.strings["id2"];
	            result = op1.replace(op2, op3);
	            break;
	        case NSO_SPLIT:
	            var vars = node.vars;
	            result  = op1.substring(0, op1.indexOf(op2));
	            set_var(vars['dst1'], logic.variables, thread_state.variables,
	                op1.substring(op1.indexOf(op2)+1, op1.length));
	            //if splitter not found keep result in main destination
	            if(get_var(vars['dst'], logic.variables, thread_state.variables) == "") {
	                result = get_var(vars['dst1'], logic.variables, thread_state.variables);
	                set_var(vars['dst1'], logic.variables, thread_state.variables, "");
	            }
	            break;        
	        case NSO_COMPARE:
	            switch (node.common_usage_names["condition"]) {
	            case NC_EQUAL:
	                result = op1 == op2 ? 1 : 0;
	                break;
	            case NC_NOTEQUAL:
	                result = op1 != op2 ? 1 : 0;
	                break;
	            case NC_LESS:
	                result = op1 < op2 ? 1 : 0;
	                break;
	            case NC_GREATER:
	                result = op1 > op2 ? 1 : 0;
	                break;
	            case NC_LEQUAL:
	                result = op1 <= op2 ? 1 : 0;
	                break;
	            case NC_GEQUAL:
	                result = op1 >= op2 ? 1 : 0;
	                break;
	            }
	            break;
	        }

	        set_var(node.vars['dst'], logic.variables, thread_state.variables, result);
	        thread_state.curr_node = node.slot_idx_order;
	        break;
	    }
	}

	function get_timeline_handler(node, logic, thread_state, timeline, elapsed, start_time) {
	    switch (logic.state) {
	    case RUNNING:
	        var curr_frame = node.bools["nla"] ? convert_variable(m_nla.get_frame(timeline), NT_NUMBER)
	                                             : convert_variable(m_time.get_frame(timeline), NT_NUMBER);

	        set_var(node.vars["vd"], logic.variables, thread_state.variables, curr_frame);
	        thread_state.curr_node = node.slot_idx_order;
	        break;
	    }
	}

	function json_handler(node, logic, thread_state, timeline, elapsed, start_time) {
	    function get_json_deep_values(src_json, parse_paths, parse_vars, dest_vars) {
	        for(var i = 0; i < parse_paths.length; i++) {
	            var full_path = parse_paths[i];
	            var path_steps = full_path.split('.');
	            var deep_value = src_json;
	            var dest_name = parse_vars[i];

	            for(var j = 0; j < path_steps.length; j++) {
	                deep_value = deep_value[path_steps[j]];

	                if(deep_value === undefined || deep_value === null)
	                    break; 
	            }

	            deep_value = convert_b4w_type(deep_value);
	            dest_vars[dest_name] = deep_value;
	        }

	    }
	    function encode_json_deep_values(src_vars, encode_paths, encode_vars, dest_json) {
	        if(!dest_json)
	            dest_json = {};

	        for(var i = 0; i < encode_paths.length; i++) {
	            var full_path = encode_paths[i];
	            var path_steps = full_path.split('.');
	            var deep_value = dest_json;
	            var src_name = encode_vars[i];

	            if (!(src_name in src_vars))
	                continue;

	            for(var j = 0; j < path_steps.length - 1; j++) {
	                if(deep_value[path_steps[j]] === undefined)
	                    if (isNaN(path_steps[j+1]))
	                        deep_value[path_steps[j]] = {};
	                    else
	                        deep_value[path_steps[j]] = [];

	                deep_value = deep_value[path_steps[j]];
	            }

	            var last_path_step = path_steps[path_steps.length -1];
	            deep_value[last_path_step] = convert_b4w_type(src_vars[src_name]);
	        }
	    }


	    switch (logic.state) {
	    case RUNNING:
	        switch (node.common_usage_names["json_operation"]) {
	        case"PARSE":
	            //JSON parsing errors shield
	            try {
	                var src_json_string = convert_variable(get_var(node.vars["jsn"], logic.variables, thread_state.variables), NT_STRING);
	                var src_json = JSON.parse(src_json_string);

	                get_json_deep_values(src_json, node.parse_json_paths, node.parse_json_vars, thread_state.variables);

	            } catch(e) {
	                m_print.error("logic script error: non valid JSON string");
	            }
	            break;
	        case "ENCODE":
	            var dest_json = {};
	            encode_json_deep_values(thread_state.variables, node.encode_json_paths, node.encode_json_vars, dest_json);

	            var dest_json_string = convert_variable(JSON.stringify(dest_json), NT_STRING);
	            set_var(node.vars["jsn"], logic.variables, thread_state.variables, dest_json_string);
	            break;
	        }
	        thread_state.curr_node = node.slot_idx_order;
	        break;
	    }
	}

	function js_callback_handler(node, logic, thread_state, timeline, elapsed, start_time) {
	    switch (logic.state) {
	    case RUNNING:
	        var cb_id = node.bools["cb"] ? convert_variable(
	            get_var(node.vars["cb"], logic.variables, thread_state.variables), NT_STRING) : node.strings["cb"];

	        var in_params = [];
	        var index = 0;
	        var key = "id" + index;
	        var param;
	        var in_types_dict = node.common_usage_names["js_cb_params"];
	        while (key in in_types_dict) {
	            if (in_types_dict[key] == NCPT_OBJECT)
	                param =  m_obj.get_object(m_obj.GET_OBJECT_BY_DUPLI_NAME_LIST, node.objects_paths[key], 0);
	            else
	                param = get_var(node.vars[key], logic.variables, thread_state.variables);

	            in_params.push(param);
	            index++;
	            key = "id" + index;
	        }

	        var out_params = [];
	        index = 0;
	        key = "out" + index;
	        while (key in node.vars) {
	            param = get_var(node.vars[key], logic.variables, thread_state.variables);
	            out_params.push(param);
	            index++;
	            key = "out" + index;
	        }

	        var ret = 1;
	        if (cb_id in _logic_custom_cb_arr) {

	            ret = !_logic_custom_cb_arr[cb_id](in_params, out_params);
	            if (ret) {
	                for (var i = 0; i < out_params.length; i++) {
	                    key = "out" + i;
	                    if (key in node.vars)
	                    set_var(node.vars[key], logic.variables, thread_state.variables, convert_b4w_type(out_params[i]));
	                }
	            }
	        } else
	            m_print.error("logic script error: no custom callback with id " + cb_id);

	        if (ret)
	            thread_state.curr_node = node.slot_idx_order;
	        break;
	    }
	}

	function date_time_handler(node, logic, thread_state, timeline, elapsed, start_time) {
	    switch (logic.state) {
	    case RUNNING:
	        var type = node.common_usage_names["time_type"];
	        var D = new Date();
	        var y, M, d, h, m, s;
	        if (type == "L") {
	            y = D.getFullYear();
	            M = D.getMonth();
	            d = D.getDate();
	            h = D.getHours();
	            m = D.getMinutes();
	            s = D.getSeconds();
	        }
	        else {
	            y = D.getUTCFullYear();
	            M = D.getUTCMonth();
	            d = D.getUTCDate();
	            h = D.getUTCHours();
	            m = D.getUTCMinutes();
	            s = D.getUTCSeconds();
	        }
	        if (node.bools["y"])
	                set_var(node.vars["y"], logic.variables, thread_state.variables, y);
	        if (node.bools["M"])
	            set_var(node.vars["M"], logic.variables, thread_state.variables, M);
	        if (node.bools["d"])
	            set_var(node.vars["d"], logic.variables, thread_state.variables, d);
	        if (node.bools["h"])
	            set_var(node.vars["h"], logic.variables, thread_state.variables, h);
	        if (node.bools["m"])
	            set_var(node.vars["m"], logic.variables, thread_state.variables, m);
	        if (node.bools["s"])
	            set_var(node.vars["s"], logic.variables, thread_state.variables, s);

	        thread_state.curr_node = node.slot_idx_order;
	        break;
	    }
	}

	function elapsed_handler(node, logic, thread_state, timeline, elapsed, start_time) {
	    switch (logic.state) {
	    case RUNNING:
	        set_var(node.vars["s"], logic.variables, thread_state.variables, elapsed);
	        thread_state.curr_node = node.slot_idx_order;
	        break;
	    }
	}

	function call_func_handler(node, logic, thread_state, timeline, elapsed, start_time) {
	    switch (logic.state) {
	    case INITIALIZATION:
	        var node_tree = node.logic_node_trees["id0"];
	        var func = node.logic_functions["id0"];
	        for (var i = 0; i < logic.logic_functions.length; i++) {
	            var desc = logic.logic_functions[i];
	            if (desc.id[0][0] == node_tree[0] &&
	                desc.id[0][1] == node_tree[1] &&
	                desc.id[1] == func) {
	                    node.func_id = i;
	                    break;
	                }
	        }
	        break;
	    case RUNNING:
	        // init local vars
	        var local_variables = {};
	        thread_state.variables_references = {};
	        for (var v in node.vars) {
	            var varval = node.vars[v][1];
	            var varname = node.strings[v];
	            local_variables[varname] = thread_state.variables[varval];
	            if (v.startsWith("out")) {
	                thread_state.variables_references[varval] = varname;
	            }
	        }
	        // increase callstack
	        thread_state.callstack.push({
	            caller_node: node,
	            variables: local_variables,
	            logic_func: logic.logic_functions[node.func_id]});
	        // replace local vars in thread_state
	        thread_state.variables = local_variables;
	        //
	        thread_state.update_script_cycle = true;
	        thread_state.curr_node = logic.logic_functions[node.func_id].func.nodes[0].slot_idx_order;
	        break;
	    }
	}

	function process_logic_thread(thread, logic, timeline, elapsed, start_time) {
	    thread.thread_state.update_script_cycle = false;
	    var callstack = thread.thread_state.callstack;
	    if (callstack.length <= 1) {
	        var script = thread.nodes;
	    } else {
	        var script = callstack[callstack.length - 1].logic_func.func.nodes;
	    }

	    if (!script.length)
	        return;

	    /* Reset "processed"*/
	    for (var i = 0; i < script.length; i++) {
	        script[i].processed = false;
	    }
	    for (var i = 0; i < script.length; i++) {
	        if (thread.thread_state.curr_node >= 0) {
	            var node = script[thread.thread_state.curr_node];
	        } else if (thread.thread_state.callstack.length > 1) {
	            var stack_frame = thread.thread_state.callstack.pop();
	            var caller_node = stack_frame.caller_node;
	            var upper_stack_frame = callstack[callstack.length-1];
	            if (upper_stack_frame.logic_func)
	                var upper_script = upper_stack_frame.logic_func.func.nodes;
	            else
	                var upper_script = thread.nodes;
	            thread.thread_state.curr_node = caller_node.slot_idx_order;
	            var node = upper_script[caller_node.slot_idx_order];
	            // restore vars
	            var vars = thread.thread_state.variables;
	            thread.thread_state.variables = upper_stack_frame.variables;
	            for (var v in thread.thread_state.variables_references) {
	                var vname = thread.thread_state.variables_references[v];
	                thread.thread_state.variables[v] = vars[vname];
	            }
	            // update script var from outer 'for' cycle
	            return;
	        } else {
	            return;
	        }
	        if (node.processed)
	            return;
	        if (!node.mute) {
	            node.process_node(node, logic, thread.thread_state, timeline, elapsed, start_time);
	            node.processed = true;
	            if (thread.thread_state.update_script_cycle)
	                return;
	        } else {
	            if (node.type == "ENTRYPOINT") {
	                return;
	            } else {
	                thread.thread_state.curr_node = node.slot_idx_order;
	                node.processed = true;
	                continue;
	            }
	        }
	    }
	}

	function prepare_logic(scene, logic) {
	    var bpy_logic_threads = scene["b4w_logic_nodes"];
	    var logic_threads = logic.logic_threads;
	    var logic_functions = logic.logic_functions;
	    logic.state = INITIALIZATION;
	    var threads_count = -1;
	    for (var k = 0; k < bpy_logic_threads.length; k++) {
	        var thread = {
	            nodes: [],
	            thread_state: {
	                scene: scene,
	                curr_node: 0,
	                in_progress: false, // used for selection blocking during Play Anim
	                                    // in cases when "Do Not Wait" is not checked
	                                    // or during Delay
	                update_script_cycle: false, // used for current nodes list reseting (switch frame in callstack)
	                thread_index: k,
	                callstack: [],
	                variables: {
	                    "R1": 0,
	                    "R2": 0,
	                    "R3": 0,
	                    "R4": 0,
	                    "R5": 0,
	                    "R6": 0,
	                    "R7": 0,
	                    "R8": 0
	                }
	            }
	        };
	        //logic_threads.push(thread);

	        var subtree = bpy_logic_threads[k];
	        for (var i = 0; i < subtree.length; i++) {
	            var snode = subtree[i];
	            var node = init_node(snode, thread);
	            // just copy all
	            thread.nodes.push(node);
	        }
	        switch (thread.nodes[0].type) {
	        case "ENTRYPOINT":
	            threads_count++;
	            thread.thread_state.thread_index = threads_count;
	            logic_threads.push(thread);
	            break;
	        case "DEF_FUNC":
	            var def_func_node = thread.nodes[0];
	            thread.thread_state = null;
	            var func_desc = {
	                id: [def_func_node.logic_node_trees["id0"], def_func_node.logic_functions["id0"]],
	                func: thread
	            };
	            logic_functions.push(func_desc);
	            break
	        }
	    }

	    // Nodes initialization
	    for (var k = 0; k < logic_threads.length; k++) {
	        var thread = logic_threads[k];
	        for (var l = 0; l < thread.nodes.length; l++) {
	            node = thread.nodes[l];
	            // NOTE: additional checks for objects inside node handlers
	            // are for objects from non-exported scenes and other difficult to prevent stuff
	            if (!node.mute)
	                node.process_node(node, logic, thread.thread_state, 0, 0);
	        }
	    }

	    for (var k = 0; k < logic_functions.length; k++) {
	        var func = logic_functions[k].func;
	        for (var l = 0; l < func.nodes.length; l++) {
	            node = func.nodes[l];
	            if (!node.mute)
	                node.process_node(node, logic, 0, 0, 0);
	        }
	    }

	    var markers = scene["timeline_markers"];
	    for (var key in markers) {
	        logic.sorted_markers_values.push(markers[key]);
	    }
	    function sortNumber(a,b)
	    {
	        return a - b;
	    }
	    logic.sorted_markers_values.sort(sortNumber);
	    logic.state = RUNNING;
	    _logic_arr.push(logic);
	}

	function convert_variable(variable, type) {
	    switch (type) {
	    case NT_NUMBER:
	        return Number(variable) ? Number(variable) : 0;
	    case NT_STRING:
	        return String(variable);
	    case NT_OBJECT:
	        return variable;
	    default: 
	        return null;
	    }
	}

	function convert_b4w_type(variable) {
	    switch (typeof(variable)) {
	    case "string":
	        return convert_variable(variable, NT_STRING);
	    case "number":
	        return convert_variable(variable, NT_NUMBER);

	    default:
	        return convert_variable(variable, NT_STRING);
	    }
	}

	/**
	 * Compose unique node identifier based on given node_label.
	 */
	function node_ident(node_label) {
	    if (!_node_ident_counters[node_label])
	        _node_ident_counters[node_label] = 0;

	    var name = node_label + "_" + _node_ident_counters[node_label];
	    // remove slash and space symbols
	    name = name.replace(/ /g, "_").replace(/\//g, "_");

	    _node_ident_counters[node_label]++;

	    return name;
	}

	function get_const_value_storage(node, var_type) {
	    switch(var_type) {
	    case NT_NUMBER:
	        return node.floats;
	    case NT_STRING:
	        return node.strings;
	    case NT_OBJECT:
	        return node.objects_paths;
	    }
	}

	exports.cleanup = function() {
	    _logic_arr.length = 0;
	    _logic_custom_cb_arr = {};
	    _node_ident_counters = {};
	};
	}

	var int_logic_nodes_factory = register("__logic_nodes", Int_logic_nodes);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Data reformer internal API.
	 * Functions for blender (bpy) data reforming, such as compatibility hacks,
	 * modifiers, custom materials etc.
	 * @name reformer
	 * @namespace
	 * @exports exports as reformer
	 */
	function Int_reformer(ns, exports) {

	var m_bounds = int_boundings_factory(ns);
	var m_cfg    = int_config_factory(ns);
	var m_curve  = int_curve_factory(ns);
	var m_mat4   = mat4_factory(ns);
	var m_print  = print_factory(ns);
	var m_quat   = quat_factory(ns);
	var m_tbn    = int_tbn_factory(ns);
	var m_util   = int_util_factory(ns);
	var m_vec3   = vec3_factory(ns);
	var m_mat3   = mat3_factory(ns);
	var m_logn   = int_logic_nodes_factory(ns);
	var m_anim   = int_animation_factory(ns);

	var cfg_def = m_cfg.defaults;

	var REPORT_COMPATIBILITY_ISSUES = true;

	var REQUIRED_FOR_PART_SYS_BIN_FORMAT = [5, 4];

	var _unreported_compat_issues = false;

	var _params_reported = {};

	var _mat3_tmp = m_mat3.create();
	var _tbn_tmp  = m_tbn.create();
	var _quat_tmp = m_quat.create();

	function reform_node(node) {

	    switch(node["type"]) {
	    case "VALTORGB":
	        if(!node["color_ramp"]) {
	            node["color_ramp"] = {"elements" : [{"position": 0.5, "color": [1, 1, 1, 1]}]};
	            report("node Color Ramp", node, "color_ramp");
	        }
	        break;
	    case "CURVE_RGB":
	        if(!node["curve_mapping"]) {
	            node["curve_mapping"] = {"curves_data": [[[0, 0], [1, 1]],
	                [[0, 0], [1, 1]], [[0, 0], [1, 1]], [[0, 0], [1, 1]]],
	                "curves_handle_types" : ["EXTRAPOLATED", "EXTRAPOLATED",
	                "EXTRAPOLATED", "EXTRAPOLATED"], "curve_extend" : 
	                [["AUTO", "AUTO"], ["AUTO", "AUTO"], ["AUTO", "AUTO"], ["AUTO", "AUTO"]]};
	            report("node RGB Curves", node, "curve_mapping");
	        }
	        break;
	    case "CURVE_VEC":
	        if(!node["curve_mapping"]) {
	            node["curve_mapping"] = {"curves_data": [[[0, 0], [1, 1]],
	                [[0, 0], [1, 1]], [[0, 0], [1, 1]]],
	                "curves_handle_types" : ["EXTRAPOLATED", "EXTRAPOLATED",
	                "EXTRAPOLATED"], "curve_extend" : 
	                [["AUTO", "AUTO"], ["AUTO", "AUTO"], ["AUTO", "AUTO"]]};
	            report("node Vector Curves", node, "curve_mapping");
	        }
	        break;
	    case "MAPPING":
	        if(!node["vector_type"]) {
	            node["vector_type"] = "POINT";
	            report("node Mapping", node, "vector_type");
	        }
	        break;
	    case "MATERIAL":
	    case "MATERIAL_EXT":
	        if (!("alpha" in node)) {
	            node["alpha"] = 1;
	            report("node material", node, "alpha");
	        }

	        if (!("darkness" in node)) {
	            node["darkness"] = 1;
	            report("node material", node, "darkness");
	        }

	        if (!("diffuse_toon_size" in node)) {
	            node["diffuse_toon_size"] = 0.5;
	            report("node material", node, "diffuse_toon_size");
	        }

	        if (!("diffuse_toon_smooth" in node)) {
	            node["diffuse_toon_smooth"] = 0.1;
	            report("node material", node, "diffuse_toon_smooth");
	        }

	        if (!("diffuse_intensity" in node)) {
	            node["diffuse_intensity"] = 1;
	            report("node material", node, "diffuse_intensity");
	        }

	        if (!("use_tangent_shading" in node)) {
	            node["use_tangent_shading"] = false;
	            report("node material", node, "use_tangent_shading");
	        }

	        if (!("specular_shader" in node)) {
	            node["specular_shader"] = "COOKTORR";
	            report("node material", node, "specular_shader");
	        }

	        if (!("specular_ior" in node)) {
	            node["specular_ior"] = 4;
	            report("node material", node, "specular_ior");
	        }

	        if (!("specular_hardness" in node)) {
	            node["specular_hardness"] = 50;
	            report("node material", node, "specular_hardness");
	        }

	        if (!("specular_slope" in node)) {
	            node["specular_slope"] = 0.1;
	            report("node material", node, "specular_slope");
	        }

	        if (!("specular_toon_size" in node)) {
	            node["specular_toon_size"] = 0.5;
	            report("node material", node, "specular_toon_size");
	        }

	        if (!("specular_toon_smooth" in node)) {
	            node["specular_toon_smooth"] = 0.1;
	            report("node material", node, "specular_toon_smooth");
	        }

	        if (!("specular_intensity" in node)) {
	            node["specular_intensity"] = 0.5;
	            report("node material", node, "specular_intensity");
	        }

	        if (!("diffuse_shader" in node)) {
	            node["diffuse_shader"] = "LAMBERT";
	            report("node material", node, "diffuse_shader");
	        }

	        if (!("roughness" in node)) {
	            node["roughness"] = 0.5;
	            report("node material", node, "roughness");
	        }

	        if (!("diffuse_fresnel" in node)) {
	            node["diffuse_fresnel"] = 0.1;
	            report("node material", node, "diffuse_fresnel");
	        }

	        if (!("diffuse_fresnel_factor" in node)) {
	            node["diffuse_fresnel_factor"] = 0.5;
	            report("node material", node, "diffuse_fresnel_factor");
	        }
	        break;
	    case "MATH":
	    case "MIX_RGB":
	        if (!("use_clamp" in node)) {
	            node["use_clamp"] = false;
	            report("node " + node["type"], node, "use_clamp");
	        }
	        break;
	    case "GROUP":
	        // NOTE: allow auto-generated names for custom nodes
	        // (e.g consider TIME.001 as TIME)
	        node["node_tree_name"] = node["node_tree_name"].replace(/\.[0-9]{3,}$/g, "");

	        // HACK: prepend B4W_ prefix for special nodes; temporary backward compatibility
	        switch(node["node_tree_name"]) {
	        case "CLAMP":
	        case "LEVELS_OF_QUALITY":
	        case "LINEAR_TO_SRGB":
	        case "NORMAL_VIEW":
	        case "PARALLAX":
	        case "REFLECT":
	        case "REFRACTION":
	        case "REPLACE":
	        case "SMOOTHSTEP":
	        case "SRGB_TO_LINEAR":
	        case "TIME":
	        case "TRANSLUCENCY":
	        case "VECTOR_VIEW":
	            node["node_tree_name"] = "B4W_" + node["node_tree_name"];
	            break;
	        default:
	            break;
	        }
	        break;
	    case "VECT_TRANSFORM":
	        if (!("convert_from" in node)) {
	            node["convert_from"] = "WORLD";
	            report("node " + node["type"], node, "convert_from");
	        }

	        if (!("convert_to" in node)) {
	            node["convert_to"] = "WORLD";
	            report("node " + node["type"], node, "convert_to");
	        }

	        if (!("vector_type" in node)) {
	            node["vector_type"] = "POINT";
	            report("node " + node["type"], node, "vector_type");
	        }
	        break;
	    }
	}

	exports.check_particles_bin_format = function(loaded_data_version) {
	    return m_util.version_cmp(loaded_data_version, REQUIRED_FOR_PART_SYS_BIN_FORMAT) != -1;
	};

	/**
	 * Check bpy_data, perform necessary compatibility hacks.
	 */
	exports.check_bpy_data = function(bpy_data) {

	    _params_reported = {};

	    var check_modifier = function(mod, bpy_obj) {
	        switch (mod["type"]) {
	        case "ARRAY":
	            if (!("fit_type" in mod)) {
	                report_modifier(mod["type"], bpy_obj,
	                                bpy_data["b4w_filepath_blend"]);
	                return false;
	            }
	            break;
	        default:
	            break;
	        }

	        return true;
	    };

	    /* worlds */
	    var worlds = bpy_data["worlds"];

	    if (worlds.length == 0) {
	        report_missing_datablock("world", bpy_data["b4w_filepath_blend"]);
	        var world = {
	            "name": "DEFAULT",
	            "horizon_color": new Float32Array([0,0,0]),
	            "zenith_color": new Float32Array([0,0,0]),
	            "light_settings": {
	                "use_environment_light": false,
	                "environment_energy": 1,
	                "environment_color": "PLAIN"
	            },
	            "fog_settings": {
	                "use_fog": false,
	                "intensity": 0.0,
	                "depth": 25.0,
	                "start": 5.0,
	                "height": 0.0,
	                "falloff": "INVERSE_QUADRATIC",
	                "use_custom_color": true,
	                "color": [0.5, 0.5, 0.5]
	            },
	            "use_sky_paper": false,
	            "use_sky_blend": false,
	            "use_sky_real": false,
	            "use_nodes": false,
	            "node_tree": null,
	            "texture_slots": []
	        };
	        worlds.push(world);
	    }

	    for (var i = 0; i < worlds.length; i++) {
	        var world = worlds[i];

	        if (!("use_sky_blend" in world)) {
	            report("world", world, "use_sky_blend");
	            world["use_sky_blend"] = false;
	        }

	        if (!("use_sky_paper" in world)) {
	            report("world", world, "use_sky_paper");
	            world["use_sky_paper"] = false;
	        }

	        if (!("use_sky_real" in world)) {
	            report("world", world, "use_sky_real");
	            world["use_sky_real"] = false;
	        }

	        if(!("b4w_sky_settings" in world) || !("rayleigh_brightness" in world["b4w_sky_settings"])) {
	            report("world", world, "rayleigh_brightness");
	            world["b4w_sky_settings"] = {
	                "render_sky": false,
	                "procedural_skydome": false,
	                "use_as_enviroment_map": false,
	                "color": [0.24, 0.43, 0.75],
	                "rayleigh_brightness": 3.3,
	                "mie_brightness": 0.1,
	                "spot_brightness": 10.0,
	                "scatter_strength": 0.2,
	                "rayleigh_strength": 0.2,
	                "mie_strength": 0.006,
	                "rayleigh_collection_power": 0.5,
	                "mie_collection_power": 0.5,
	                "mie_distribution": 0.4
	            };
	        }

	        if(!("fog_settings" in world)) {
	            report("world", world, "fog_settings");
	            world["fog_settings"] = {
	                "use_fog": false,
	                "intensity": 0.0,
	                "depth": 25.0,
	                "start": 0.0,
	                "height": 0.0,
	                "falloff": "QUADRATIC",
	                "use_custom_color": true,
	                "color": [0.5, 0.5, 0.5]
	            };
	            if ("b4w_fog_color" in world) {
	                world["fog_settings"]["use_custom_color"] = true;
	                world["fog_settings"]["color"] = world["b4w_fog_color"];
	            }
	            if ("b4w_fog_density" in world) {
	                if (world["b4w_fog_density"] > 0.0)
	                    world["fog_settings"]["depth"] = 1.0 / world["b4w_fog_density"];
	            }
	        }

	        if (!("render_sky" in world["b4w_sky_settings"])) {
	            report("world", world, "render_sky");
	            world["b4w_sky_settings"]["render_sky"] = false;
	        }

	        var texture_slots = world["texture_slots"];
	        for (var j = 0; j < texture_slots.length; j++) {
	            var slot = texture_slots[j];
	            if (!("blend_type" in slot)) {
	                slot["blend_type"] = "MIX";
	                report("world_texture_slot", slot, "blend_type");
	            }
	            if (!("use_map_blend" in slot)) {
	                slot["use_map_blend"] = false;
	                report("world_texture_slot", slot, "use_map_blend");
	            }
	            if (!("use_map_horizon" in slot)) {
	                slot["use_map_horizon"] = true;
	                report("world_texture_slot", slot, "use_map_horizon");
	            }
	            if (!("use_map_zenith_up" in slot)) {
	                slot["use_map_zenith_up"] = false;
	                report("world_texture_slot", slot, "use_map_zenith_up");
	            }
	            if (!("use_rgb_to_intensity" in slot)) {
	                slot["use_rgb_to_intensity"] = false;
	                report("world_texture_slot", slot, "use_rgb_to_intensity");
	            }
	            if (!("invert" in slot)) {
	                slot["invert"] = false;
	                report("world_texture_slot", slot, "invert");
	            }
	            if (!("color" in slot)) {
	                slot["color"] = [1.0, 0.0, 1.0];
	                report("world_texture_slot", slot, "color");
	            }
	            if (!("blend_factor" in slot)) {
	                slot["blend_factor"] = 0.0;
	                report("world_texture_slot", slot, "blend_factor");
	            }
	            if (!("horizon_factor" in slot)) {
	                slot["horizon_factor"] = 1.0;
	                report("world_texture_slot", slot, "horizon_factor");
	            }
	            if (!("zenith_up_factor" in slot)) {
	                slot["zenith_up_factor"] = 0.0;
	                report("world_texture_slot", slot, "zenith_up_factor");
	            }
	            if (!("zenith_down_factor" in slot)) {
	                slot["zenith_down_factor"] = 0.0;
	                report("world_texture_slot", slot, "zenith_down_factor");
	            }
	            if (!("default_value" in slot)) {
	                slot["default_value"] = 1.0;
	                report("world_texture_slot", slot, "default_value");
	            }
	        }

	        if (!("b4w_use_default_animation" in world)) {
	            report("world", world, "b4w_use_default_animation");
	            world["b4w_use_default_animation"] = false;
	        }

	        if (!("b4w_anim_behavior" in world)) {
	            report("world", world, "b4w_anim_behavior");
	            world["b4w_anim_behavior"] = "CYCLIC";
	        }
	    }

	    /* scenes */
	    var scenes = bpy_data["scenes"];
	    for (var i = 0; i < scenes.length; i++) {
	        var scene = scenes[i];
	        var sc_world = scene["world"];

	        if (!("timeline_markers" in scene)) {
	            scene["timeline_markers"] = null;
	            report("scene", scene, "timeline_markers");
	        }
	        if (typeof scene["b4w_enable_physics"] == "boolean") {
	            scene["b4w_enable_physics"] = "AUTO";
	        }

	        if (!("b4w_reflection_quality" in scene)) {
	            scene["b4w_reflection_quality"] = "MEDIUM";
	            report("scene", scene, "b4w_reflection_quality");
	        }

	        if (!("b4w_use_nla" in scene)) {
	            scene["b4w_use_nla"] = false;
	            report("scene", scene, "b4w_use_nla");
	        }

	        if (!("fps" in scene)) {
	            scene["fps"] = 24;
	            report("scene", scene, "fps");
	        }

	        if (!("b4w_nla_cyclic" in scene)) {
	            scene["b4w_nla_cyclic"] = false;
	            report("scene", scene, "b4w_nla_cyclic");
	        }

	        if (!("b4w_logic_nodes" in scene)) {
	            scene["b4w_logic_nodes"] = [];
	            report("scene", scene, "b4w_logic_nodes");
	        }

	        if ("b4w_detect_collisions" in scene) {
	            report_deprecated("scene", scene, "b4w_detect_collisions");
	            delete scene["b4w_detect_collisions"];
	        }

	        if (!("audio_doppler_speed" in scene)) {
	            scene["audio_doppler_speed"] = 343.3;
	            //report("scene", scene, "audio_doppler_speed");
	        }
	        if (!("audio_doppler_factor" in scene)) {
	            scene["audio_doppler_factor"] = 1.0;
	            //report("scene", scene, "audio_doppler_factor");
	        }

	        if (!("b4w_dynamic_compressor_settings" in scene)) {
	            scene["b4w_dynamic_compressor_settings"] = {
	                "threshold": -24,
	                "knee": 30,
	                "ratio": 12,
	                "attack": 0.003,
	                "release": 0.250
	            };
	            report("scene", scene, "b4w_dynamic_compressor_settings");
	        }
	        if (!("b4w_enable_convolution_engine" in scene)) {
	            scene["b4w_enable_convolution_engine"] = false;
	            //report("scene", scene, "b4w_enable_convolution_engine");
	        }

	        if (!("b4w_enable_bloom" in scene)) {
	            scene["b4w_enable_bloom"] = false;
	            report("scene", scene, "b4w_enable_bloom");
	        }

	        if (!("b4w_enable_motion_blur" in scene)) {
	            scene["b4w_enable_motion_blur"] = false;
	            report("scene", scene, "b4w_enable_motion_blur");
	        }

	        if (!("b4w_enable_color_correction" in scene)) {
	            scene["b4w_enable_color_correction"] = false;
	            report("scene", scene, "b4w_enable_color_correction");
	        }

	        if (!("b4w_antialiasing_quality" in scene)) {
	            scene["b4w_antialiasing_quality"] = "MEDIUM";
	            report("scene", scene, "b4w_antialiasing_quality");
	        }

	        if (!("b4w_tags" in scene)) {
	            scene["b4w_tags"] = {
	                "title": "",
	                "description": ""
	            };
	            report("scene", scene, "b4w_tags");
	        }

	        if (!("b4w_lod_smooth_type" in scene)) {
	            scene["b4w_lod_smooth_type"] = "OFF";
	            report("scene", scene, "b4w_lod_smooth_type");
	        }

	        if (!("b4w_lod_hyst_interval" in scene)) {
	            scene["b4w_lod_hyst_interval"] = 0;
	            report("scene", scene, "b4w_lod_hyst_interval");
	        }

	        if (!("b4w_enable_object_selection" in scene)) {
	            scene["b4w_enable_object_selection"] = "AUTO";
	            report("scene", scene, "b4w_enable_object_selection");
	        }
	        if (!("b4w_enable_outlining" in scene)) {
	            scene["b4w_enable_outlining"] = "AUTO";
	            report("scene", scene, "b4w_enable_outlining");
	        }
	        if (!("b4w_enable_glow_materials" in scene)) {
	            scene["b4w_enable_glow_materials"] = "AUTO";
	            report("scene", scene, "b4w_enable_glow_materials");
	        }
	        if (!("b4w_enable_anchors_visibility" in scene)) {
	            scene["b4w_enable_anchors_visibility"] = "AUTO";
	            report("scene", scene, "b4w_enable_anchors_visibility");
	        }

	        if (!("b4w_outline_color" in scene)) {
	            scene["b4w_outline_color"] = [1.0,1.0,1.0];
	            report("scene", scene, "b4w_outline_color");
	        }

	        if (!("b4w_outline_factor" in scene)) {
	            if ("b4w_glow_factor" in scene)
	                scene["b4w_outline_factor"] = scene["b4w_glow_factor"];
	            else
	                scene["b4w_outline_factor"] = 1.0;
	            report("scene", scene, "b4w_outline_factor");
	        }

	        if (!("b4w_shadow_settings" in scene)) {
	            report("scene", scene, "b4w_shadow_settings");
	            var w_shadows = sc_world["b4w_shadow_settings"];
	            if (w_shadows)
	                scene["b4w_shadow_settings"] = w_shadows;
	            else
	                scene["b4w_shadow_settings"] = {
	                        "csm_resolution": 2048,
	                        "blur_samples": "16x",
	                        "self_shadow_polygon_offset": 1,
	                        "b4w_enable_csm": false,
	                        "csm_num": 1,
	                        "csm_first_cascade_border": 10,
	                        "first_cascade_blur_radius": 3,
	                        "csm_last_cascade_border": 100,
	                        "last_cascade_blur_radius": 1.5,
	                        "fade_last_cascade": true,
	                        "blend_between_cascades": true
	                    };
	        }
	        var shadows = scene["b4w_shadow_settings"];
	        if(!("csm_resolution" in shadows)) {
	            report("scene", scene, "b4w_shadow_settings.csm_resolution");
	            shadows["csm_resolution"] = 2048;
	        }
	        if(!("blur_samples" in shadows)) {
	            report("scene", scene, "b4w_shadow_settings.blur_samples");
	            shadows["blur_samples"] = "16x";
	        }
	        if(!("soft_shadows" in shadows)) {
	            report("scene", scene, "b4w_shadow_settings.soft_shadows");
	            shadows["soft_shadows"] = true;
	        }
	        if(!("self_shadow_polygon_offset" in shadows)) {
	            report("scene", scene, "b4w_shadow_settings.self_shadow_polygon_offset");
	            shadows["self_shadow_polygon_offset"] = 1;
	        }
	        if(!("self_shadow_normal_offset" in shadows)) {
	            report("scene", scene, "b4w_shadow_settings.self_shadow_normal_offset");
	            shadows["self_shadow_normal_offset"] = 0.01;
	        }
	        if(!("b4w_enable_csm" in shadows)) {
	            report("scene", scene, "b4w_shadow_settings.b4w_enable_csm");
	            shadows["b4w_enable_csm"] = false;
	        }
	        if(!("csm_num" in shadows)) {
	            report("scene", scene, "b4w_shadow_settings.csm_num");
	            shadows["csm_num"] = 1;
	        }
	        if(!("csm_first_cascade_border" in shadows)) {
	            report("scene", scene, "b4w_shadow_settings.csm_first_cascade_border");
	            shadows["csm_first_cascade_border"] = 10;
	        }
	        if(!("first_cascade_blur_radius" in shadows)) {
	            report("scene", scene, "b4w_shadow_settings.first_cascade_blur_radius");
	            shadows["first_cascade_blur_radius"] = 3;
	        }
	        if(!("csm_last_cascade_border" in shadows)) {
	            report("scene", scene, "b4w_shadow_settings.csm_last_cascade_border");
	            shadows["csm_last_cascade_border"] = 100;
	        }
	        if(!("last_cascade_blur_radius" in shadows)) {
	            report("scene", scene, "b4w_shadow_settings.last_cascade_blur_radius");
	            shadows["last_cascade_blur_radius"] = 1.5;
	        }
	        if(!("fade_last_cascade" in shadows)) {
	            report("scene", scene, "b4w_shadow_settings.fade_last_cascade");
	            shadows["fade_last_cascade"] = true;
	        }
	        if(!("blend_between_cascades" in shadows)) {
	            report("scene", scene, "b4w_shadow_settings.blend_between_cascades");
	            shadows["blend_between_cascades"] = true;
	        }

	        if (!("b4w_ssao_settings" in scene)) {
	            report("scene", scene, "b4w_ssao_settings");
	            var w_ssao = sc_world["b4w_ssao_settings"];
	            if (w_ssao)
	                scene["b4w_ssao_settings"] = w_ssao;
	            else
	                scene["b4w_ssao_settings"] = {
	                    "dist_factor": 0.0,
	                    "samples": 16,
	                    "hemisphere": false,
	                    "blur_depth": false,
	                    "blur_discard_value": 1.0
	                };
	        }
	        var ssao = scene["b4w_ssao_settings"];
	        if(!("dist_factor" in ssao)) {
	            report("scene", scene, "b4w_ssao_settings.dist_factor");
	            ssao["dist_factor"] = 0.0;
	        }
	        if(!("samples" in ssao)) {
	            report("scene", scene, "b4w_ssao_settings.samples");
	            ssao["samples"] = 16;
	        }
	        if(!("hemisphere" in ssao)) {
	            report("scene", scene, "b4w_ssao_settings.hemisphere");
	            ssao["hemisphere"] = false;
	        }
	        if(!("blur_depth" in ssao)) {
	            report("scene", scene, "b4w_ssao_settings.blur_depth");
	            ssao["blur_depth"] = false;
	        }
	        if(!("blur_discard_value" in ssao)) {
	            report("scene", scene, "b4w_ssao_settings.blur_discard_value");
	            ssao["blur_discard_value"] = 1.0;
	        }

	        if (!("b4w_bloom_settings" in scene)) {
	            report("scene", scene, "b4w_bloom_settings");
	            var w_bloom = sc_world["b4w_bloom_settings"];
	            if (w_bloom)
	                scene["b4w_bloom_settings"] = w_bloom;
	            else
	                scene["b4w_bloom_settings"] = {
	                    "key": 0.2,
	                    "blur": 4.0,
	                    "edge_lum": 1.0
	                };
	        }
	        if(!("key" in scene["b4w_bloom_settings"])) {
	            report("scene", scene, "b4w_bloom_settings.key");
	            scene["b4w_bloom_settings"]["key"] = 0.2;
	        }
	        if(!("blur" in scene["b4w_bloom_settings"])) {
	            report("scene", scene, "b4w_bloom_settings.blur");
	            scene["b4w_bloom_settings"]["blur"] = 4.0;
	        }
	        if(!("edge_lum" in scene["b4w_bloom_settings"])) {
	            report("scene", scene, "b4w_bloom_settings.edge_lum");
	            scene["b4w_bloom_settings"]["edge_lum"] = 1.0;
	        }
	        if (!("adaptive" in scene["b4w_bloom_settings"])) {
	            report("scene", scene, "b4w_bloom_settings.adaptive");
	            scene["b4w_bloom_settings"]["adaptive"] = true;
	        }
	        if (!("average_luminance" in scene["b4w_bloom_settings"])) {
	            report("scene", scene, "b4w_bloom_settings.average_luminance");
	            scene["b4w_bloom_settings"]["average_luminance"] = 0.5;
	        }

	        if (!("b4w_motion_blur_settings" in scene)) {
	            report("scene", scene, "b4w_motion_blur_settings");
	            var w_motion_blur = sc_world["b4w_motion_blur_settings"];
	            if (w_motion_blur)
	                scene["b4w_motion_blur_settings"] = w_motion_blur;
	            else
	                scene["b4w_motion_blur_settings"] = {
	                    "motion_blur_factor": 0.01,
	                    "motion_blur_decay_threshold": 0.01
	                };
	        }
	        if(!("motion_blur_factor" in scene["b4w_motion_blur_settings"])) {
	            report("scene", scene, "b4w_motion_blur_settings.motion_blur_factor");
	            scene["b4w_motion_blur_settings"]["motion_blur_factor"] = 0.01;
	        }
	        if(!("motion_blur_decay_threshold" in scene["b4w_motion_blur_settings"])) {
	            report("scene", scene, "b4w_motion_blur_settings.motion_blur_decay_threshold");
	            scene["b4w_motion_blur_settings"]["motion_blur_decay_threshold"] = 0.01;
	        }

	        if (!("b4w_color_correction_settings" in scene)) {
	            report("scene", scene, "b4w_color_correction_settings");
	            var w_color_correction = sc_world["b4w_color_correction_settings"];
	            if (w_color_correction)
	                scene["b4w_color_correction_settings"] = w_color_correction;
	            else
	                scene["b4w_color_correction_settings"] = {
	                    "brightness" : 0.0,
	                    "contrast" : 0.0,
	                    "exposure": 1.0,
	                    "saturation": 1.0
	                };
	        }

	        if (!("b4w_god_rays_settings" in scene)) {
	            report("scene", scene, "b4w_god_rays_settings");
	            var w_god_rays = sc_world["b4w_god_rays_settings"];
	            if (w_god_rays)
	                scene["b4w_god_rays_settings"] = w_god_rays;
	            else
	                scene["b4w_god_rays_settings"] = {
	                    "intensity" : 0.7,
	                    "max_ray_length" : 1.0,
	                    "steps_per_pass": 10
	                };
	        }
	        if(!("steps_per_pass" in scene["b4w_god_rays_settings"])) {
	            report("scene", scene, "b4w_god_rays_settings.steps_per_pass");
	            scene["b4w_god_rays_settings"]["steps_per_pass"] = 10.0;
	        }

	        if (!("b4w_glow_settings" in scene)) {
	            report("scene", scene, "b4w_glow_settings");
	            scene["b4w_glow_settings"] = {
	                "render_glow_over_blend": false,
	                "small_glow_mask_coeff": 2.0,
	                "large_glow_mask_coeff": 2.0,
	                "small_glow_mask_width": 2.0,
	                "large_glow_mask_width": 6.0
	            };
	            var glow_set = scene["b4w_glow_settings"];
	            if ("b4w_render_glow_over_blend" in sc_world)
	                glow_set["render_glow_over_blend"] = sc_world["b4w_render_glow_over_blend"];
	            if ("b4w_small_glow_mask_coeff" in sc_world)
	                glow_set["small_glow_mask_coeff"] = sc_world["b4w_small_glow_mask_coeff"];
	            if ("b4w_large_glow_mask_coeff" in sc_world)
	                glow_set["large_glow_mask_coeff"] = sc_world["b4w_large_glow_mask_coeff"];
	            if ("b4w_small_glow_mask_width" in sc_world)
	                glow_set["small_glow_mask_width"] = sc_world["b4w_small_glow_mask_width"];
	            if ("b4w_large_glow_mask_width" in sc_world)
	                glow_set["large_glow_mask_width"] = sc_world["b4w_large_glow_mask_width"];
	        }

	        var r_shadows = scene["b4w_render_shadows"];
	        if (r_shadows != "AUTO" && r_shadows != "OFF" && r_shadows != "ON")
	            if (r_shadows)
	                scene["b4w_render_shadows"] = "ON";
	            else
	                scene["b4w_render_shadows"] = "OFF";

	        var r_refl = scene["b4w_render_reflections"];
	        if (r_refl != "OFF" && r_refl != "ON")
	            if (r_refl)
	                scene["b4w_render_reflections"] = "ON";
	            else
	                scene["b4w_render_reflections"] = "OFF";

	        var r_refr = scene["b4w_render_refractions"];
	        if (r_refr != "AUTO" && r_refr != "OFF" && r_refr != "ON")
	            if (r_refr)
	                scene["b4w_render_refractions"] = "ON";
	            else
	                scene["b4w_render_refractions"] = "OFF";

	        if (!("b4w_render_dynamic_grass" in scene)) {
	            report("scene", scene, "b4w_render_dynamic_grass");
	            scene["b4w_render_dynamic_grass"] = "AUTO";
	        }

	        if (scene["b4w_nla_script"]) {
	            report_deprecated("scene", scene, "b4w_nla_script");
	        }

	        if (!("audio_distance_model" in scene)) {
	            report("scene", scene, "audio_distance_model");
	            scene["audio_distance_model"] = "INVERSE_CLAMPED";
	        }

	        if (!("b4w_custom_prop" in scene)) {
	            report("scene", scene, "b4w_custom_prop");
	            scene["b4w_custom_prop"] = null;
	        }
	    }

	    /* object data - meshes */
	    var meshes = bpy_data["meshes"];

	    for (var i = 0; i < meshes.length; i++) {
	        var mesh = meshes[i];

	        if (!mesh["b4w_boundings"]) {
	            report("mesh", mesh, "b4w_boundings");
	            mesh["b4w_boundings"] = {};
	            var b_data = mesh["b4w_boundings"];
	            if (mesh["b4w_bounding_box"])
	                b_data["bb"] = mesh["b4w_bounding_box"];
	            else
	                b_data["bb"] = {"max_x" : 0, "max_y" : 0, "max_z" : 0,
	                    "min_x" : 0, "min_y" : 0, "min_z" : 0};

	            if (mesh["b4w_bounding_box_source"])
	                b_data["bb_src"] = mesh["b4w_bounding_box_source"];
	            else
	                b_data["bb_src"] = mesh["b4w_bounding_box"];

	            if (mesh["b4w_bounding_sphere_center"])
	                b_data["bs_cen"] = mesh["b4w_bounding_sphere_center"];
	            else
	                b_data["bs_cen"] = [0, 0, 0];

	            if (mesh["b4w_bounding_cylinder_center"])
	                b_data["bc_cen"] = mesh["b4w_bounding_cylinder_center"];
	            else
	                b_data["bc_cen"] = [0, 0, 0];

	            if (mesh["b4w_bounding_ellipsoid_center"])
	                b_data["be_cen"] = mesh["b4w_bounding_ellipsoid_center"];
	            else
	                b_data["be_cen"] = [0, 0, 0];

	            if (mesh["b4w_bounding_ellipsoid_axes"])
	                b_data["be_ax"] = mesh["b4w_bounding_ellipsoid_axes"];
	            else {
	                var bb = b_data["bb"];
	                b_data["be_ax"] = [(bb["max_x"] - bb["min_x"])/2,
	                                                   (bb["max_y"] - bb["min_y"])/2,
	                                                   (bb["max_z"] - bb["min_z"])/2];
	            }

	            if (mesh["b4w_rotated_bounding_box"])
	                b_data["rbb"] = mesh["b4w_rotated_bounding_box"];
	            else {
	                var bb = b_data["bb"];
	                b_data["rbb"] = {
	                    "rbb_c" : [(bb["max_x"] + bb["min_x"])/2,
	                                (bb["max_y"] + bb["min_y"])/2,
	                                (bb["max_z"] + bb["min_z"])/2],
	                    "rbb_s" : [1, 1, 1]
	                };
	            }

	            if(mesh["b4w_cov_axis_x"])
	                b_data["caxis_x"] = mesh["b4w_cov_axis_x"];
	            else
	                b_data["caxis_x"] = [1,0,0];

	            if(mesh["b4w_cov_axis_y"])
	                b_data["caxis_y"] = mesh["b4w_cov_axis_y"];
	            else
	                b_data["caxis_y"] = [0,1,0];

	            if(mesh["b4w_cov_axis_z"])
	                b_data["caxis_z"] = mesh["b4w_cov_axis_z"];
	            else
	                b_data["caxis_z"] = [0,0,1];
	        }

	        if (!("is_boundings_overridden" in mesh)) {
	            report("mesh", mesh, "is_boundings_overridden");
	            mesh["is_boundings_overridden"] = false;
	        }

	        if (!("b4w_shape_keys" in mesh)) {
	            mesh["b4w_shape_keys"] = [];
	            report("mesh", mesh, "b4w_shape_keys");
	        }

	        var submesh_is_ok = true;
	        for (var k = 0; k < mesh["submeshes"].length; k++) {
	            var submesh = mesh["submeshes"][k];
	            if (!("boundings" in submesh)) {
	                submesh_is_ok = false;
	                submesh["boundings"] = {
	                    "be_ax" : mesh["b4w_bounding_ellipsoid_axes"],
	                    "be_cen" : mesh["b4w_bounding_ellipsoid_center"],
	                    "bb" : {
	                        "max_x" : mesh["b4w_bounding_box"]["max_x"],
	                        "max_y" : mesh["b4w_bounding_box"]["max_y"],
	                        "max_z" : mesh["b4w_bounding_box"]["max_z"],
	                        "min_x" : mesh["b4w_bounding_box"]["min_x"],
	                        "min_y" : mesh["b4w_bounding_box"]["min_y"],
	                        "min_z" : mesh["b4w_bounding_box"]["min_z"]
	                    }
	                };
	            }

	            if (!("uv_layers" in submesh)) {
	                report("submesh", mesh, "uv_layers");
	                submesh["uv_layers"] = mesh["uv_textures"];
	            }

	            if (!("be_ax" in submesh["boundings"]))
	                submesh["boundings"]["be_ax"] = mesh["b4w_bounding_ellipsoid_axes"];

	            if (!("be_cen" in submesh["boundings"]))
	                submesh["boundings"]["be_cen"] = mesh["b4w_bounding_ellipsoid_center"];

	            if (!("bb" in submesh["boundings"]))
	                submesh["boundings"]["bb"] = mesh["b4w_bounding_box"];

	            if (!("rbb" in submesh["boundings"])) {
	                var bb = mesh["b4w_bounding_box"];
	                submesh["boundings"]["rbb"] = {
	                    "rbb_c" : [(bb["max_x"] + bb["min_x"])/2,
	                                (bb["max_y"] + bb["min_y"])/2,
	                                (bb["max_z"] + bb["min_z"])/2],
	                    "rbb_s" : [1, 1, 1]
	                };
	            }
	            if (!("caxis_x" in submesh["boundings"]))
	                submesh["boundings"]["caxis_x"] = [1,0,0];
	            if (!("caxis_y" in submesh["boundings"]))
	                submesh["boundings"]["caxis_y"] = [0,1,0];
	            if (!("caxis_z" in submesh["boundings"]))
	                submesh["boundings"]["caxis_z"] = [0,0,1];
	        }
	        if (!submesh_is_ok)
	            report("mesh", mesh, "submesh_bd");

	        check_export_props(mesh);

	        for (var j = 0; j < mesh["b4w_vertex_anim"].length; j++) {
	            var va = mesh["b4w_vertex_anim"][j];
	            if (!("allow_nla" in va)) {
	                report("mesh[\"b4w_vertex_anim\"]", mesh, "allow_nla");
	                va["allow_nla"] = true;
	            }
	        }

	        if (!("active_uv_name" in mesh)) {
	            report("mesh", mesh, "active_uv_name");
	            mesh["active_uv_name"] = "";
	        }
	    }

	    /* object data - cameras */
	    var cameras = bpy_data["cameras"];

	    for (var i = 0; i < cameras.length; i++) {
	        var camera = cameras[i];
	        if (!camera["type"]) {
	            camera["type"] = "PERSP";
	            report("camera", camera, "type");
	        }

	        if ("b4w_eye_target_dist" in camera) {
	            delete camera["b4w_eye_target_dist"];
	            report_deprecated("camera", camera, "b4w_eye_target_dist");
	        }

	        if (!("b4w_hover_zero_level" in camera)) {
	            camera["b4w_hover_zero_level"] = 0;
	            report("camera", camera, "b4w_hover_zero_level");
	        }

	        if (!("b4w_trans_velocity" in camera)) {
	            camera["b4w_trans_velocity"] = 1;
	            report("camera", camera, "b4w_trans_velocity");
	        }
	        
	        if (!("b4w_rot_velocity" in camera)) {
	            camera["b4w_rot_velocity"] = 1;
	            report("camera", camera, "b4w_rot_velocity");
	        }

	        if (!("b4w_zoom_velocity" in camera)) {
	            camera["b4w_zoom_velocity"] = 0.1;
	            report("camera", camera, "b4w_zoom_velocity");
	        }

	        if (!("b4w_use_target_distance_limits" in camera)) {
	            camera["b4w_use_target_distance_limits"] 
	                    = camera["b4w_use_distance_limits"] || false;
	            report("camera", camera, "b4w_use_target_distance_limits");
	        }

	        if (!("b4w_use_zooming" in camera)) {
	            camera["b4w_use_zooming"] = camera["b4w_use_distance_limits"] || false;
	            report("camera", camera, "b4w_use_zooming");
	        }

	        if (!("b4w_distance_min" in camera)) {
	            camera["b4w_distance_min"] = 1;
	            report("camera", camera, "b4w_distance_min");
	        }
	        if (!("b4w_distance_max" in camera)) {
	            camera["b4w_distance_max"] = 100;
	            report("camera", camera, "b4w_distance_max");
	        }

	        if (!("b4w_horizontal_translation_min" in camera)) {
	            camera["b4w_horizontal_translation_min"] = -100;
	            report("camera", camera, "b4w_horizontal_translation_min");
	        }
	        if (!("b4w_horizontal_translation_max" in camera)) {
	            camera["b4w_horizontal_translation_max"] = 100;
	            report("camera", camera, "b4w_horizontal_translation_max");
	        }

	        if (!("b4w_vertical_translation_min" in camera)) {
	            camera["b4w_vertical_translation_min"] = -100;
	            report("camera", camera, "b4w_vertical_translation_min");
	        }

	        if (!("b4w_vertical_translation_max" in camera)) {
	            camera["b4w_vertical_translation_max"] = 100;
	            report("camera", camera, "b4w_vertical_translation_max");
	        }

	        if (!("b4w_use_horizontal_clamping" in camera)) {
	            camera["b4w_use_horizontal_clamping"] = false;
	            report("camera", camera, "b4w_use_horizontal_clamping");
	        }

	        if (!("b4w_rotation_left_limit" in camera)) {
	            camera["b4w_rotation_left_limit"] = -Math.PI;
	            report("camera", camera, "b4w_rotation_left_limit");
	        }
	        if (!("b4w_rotation_right_limit" in camera)) {
	            camera["b4w_rotation_right_limit"] = Math.PI;
	            report("camera", camera, "b4w_rotation_right_limit");
	        }

	        if (!("b4w_horizontal_clamping_type" in camera)) {
	            camera["b4w_horizontal_clamping_type"] = "LOCAL";
	            report("camera", camera, "b4w_horizontal_clamping_type");
	        }

	        if (!("b4w_use_vertical_clamping" in camera)) {
	            camera["b4w_use_vertical_clamping"] = false;
	            report("camera", camera, "b4w_use_vertical_clamping");
	        }

	        if (!("b4w_rotation_down_limit" in camera)) {
	            camera["b4w_rotation_down_limit"] = -Math.PI / 2;
	            report("camera", camera, "b4w_rotation_down_limit");
	        }
	        if (!("b4w_rotation_up_limit" in camera)) {
	            camera["b4w_rotation_up_limit"] = Math.PI / 2;
	            report("camera", camera, "b4w_rotation_up_limit");
	        }

	        if (!("b4w_vertical_clamping_type" in camera)) {
	            camera["b4w_vertical_clamping_type"] = "LOCAL";
	            report("camera", camera, "b4w_vertical_clamping_type");
	        }

	        if (!("b4w_hover_angle_min" in camera)) {
	            camera["b4w_hover_angle_min"] = Math.PI / 6;
	            report("camera", camera, "b4w_hover_angle_min");
	        }
	        if (!("b4w_hover_angle_max" in camera)) {
	            camera["b4w_hover_angle_max"] = Math.PI / 6;
	            report("camera", camera, "b4w_hover_angle_max");
	        }

	        if (!("b4w_enable_hover_hor_rotation" in camera)) {
	            camera["b4w_enable_hover_hor_rotation"] = true;
	            report("camera", camera, "b4w_enable_hover_hor_rotation");
	        }

	        if (!("b4w_use_panning" in camera)) {
	            camera["b4w_use_panning"] = true;
	            report("camera", camera, "b4w_use_panning");
	        }

	        if (!("b4w_use_pivot_limits" in camera)) {
	            camera["b4w_use_pivot_limits"] = false;
	            camera["b4w_pivot_z_min"] = 0;
	            camera["b4w_pivot_z_max"] = 10;
	            report("camera", camera, "b4w_use_pivot_limits");
	        }

	        if (!("b4w_dof_bokeh" in camera)) {
	            camera["b4w_dof_bokeh"] = false;
	            report("camera", camera, "b4w_dof_bokeh");
	        }

	        if (!("b4w_dof_bokeh_intensity" in camera)) {
	            camera["b4w_dof_bokeh_intensity"] = 0.3;
	            report("camera", camera, "b4w_dof_bokeh_intensity");
	        }

	        if (!("b4w_dof_foreground_blur" in camera)) {
	            camera["b4w_dof_foreground_blur"] = false;
	            report("camera", camera, "b4w_dof_foreground_blur");
	        }

	        if (!("b4w_dof_front_start" in camera)) {
	            camera["b4w_dof_front_start"] = 0;
	            report("camera", camera, "b4w_dof_front_start");
	        }

	        if (!("b4w_dof_front_end" in camera)) {
	            camera["b4w_dof_front_end"] = camera["b4w_dof_front"];
	            report("camera", camera, "b4w_dof_front_end");
	        }

	        if (!("b4w_dof_rear_start" in camera)) {
	            camera["b4w_dof_rear_start"] = 0;
	            report("camera", camera, "b4w_dof_rear_start");
	        }

	        if (!("b4w_dof_rear_end" in camera)) {
	            camera["b4w_dof_rear_end"] = camera["b4w_dof_rear"];
	            report("camera", camera, "b4w_dof_rear_end");
	        }

	        if (!("sensor_fit" in camera)) {
	            camera["sensor_fit"] = "VERTICAL";
	            report("camera", camera, "sensor_fit");
	        }
	    }

	    /* object data - lamps */
	    var lamps = bpy_data["lamps"];

	    for (var i = 0; i < lamps.length; i++) {
	        var lamp = lamps[i];

	        if (!("b4w_generate_shadows" in lamp)) {
	            lamp["b4w_generate_shadows"] = false;
	            report("lamp", lamp, "b4w_generate_shadows");
	        }

	        if (!("b4w_dynamic_intensity" in lamp)) {
	            lamp["b4w_dynamic_intensity"] = false;
	            report("lamp", lamp, "b4w_dynamic_intensity");
	        }

	        if (!("use_diffuse" in lamp)) {
	            lamp["use_diffuse"] = true;
	            report("lamp", lamp, "use_diffuse");
	        }

	        if (!("use_specular" in lamp)) {
	            lamp["use_specular"] = true;
	            report("lamp", lamp, "use_specular");
	        }

	        if (!("clip_start" in lamp)) {
	            lamp["clip_start"] = 0.1;
	            report("lamp", lamp, "clip_start");
	        }

	        if (!("clip_end" in lamp)) {
	            lamp["clip_end"] = 30.0;
	            report("lamp", lamp, "clip_end");
	        }

	        if (lamp["type"] == "POINT" || lamp["type"] == "SPOT") {
	            if (!("use_sphere" in lamp)) {
	                lamp["use_sphere"] = false;
	                report("lamp", lamp, "use_sphere");
	            }

	            if (cfg_def.mali4_lamps_hack)
	                lamp["type"] = "SUN";
	        }
	    }

	    /* object data - speakers */
	    var speakers = bpy_data["speakers"];

	    for (var i = 0; i < speakers.length; i++) {
	        var speaker = speakers[i];
	        if (!("b4w_behavior" in speaker)) {
	            if (speaker["b4w_background_music"])
	                speaker["b4w_behavior"] = "BACKGROUND_SOUND";
	            else
	                speaker["b4w_behavior"] = "POSITIONAL";

	            //report("speaker", speaker, "b4w_behavior");
	        }
	        if (!("b4w_auto_play" in speaker)) {
	            speaker["b4w_auto_play"] = false;
	            report("speaker", speaker, "b4w_auto_play");
	        }

	        if (!("b4w_enable_doppler" in speaker)) {
	            speaker["b4w_enable_doppler"] = false;
	            report("speaker", speaker, "b4w_enable_doppler");
	        }

	        if (!("b4w_delay" in speaker)) {
	            speaker["b4w_delay"] = 0;
	            //report("speaker", speaker, "b4w_delay");
	        }
	        if (!("b4w_delay_random" in speaker)) {
	            speaker["b4w_delay_random"] = 0;
	            //report("speaker", speaker, "b4w_delay_random");
	        }

	        if (!("b4w_volume_random" in speaker)) {
	            speaker["b4w_volume_random"] = 0;
	            //report("speaker", speaker, "b4w_volume_random");
	        }
	        if (!("b4w_pitch_random" in speaker)) {
	            speaker["b4w_pitch_random"] = 0;
	            //report("speaker", speaker, "b4w_pitch_random");
	        }

	        if (!("b4w_fade_in" in speaker)) {
	            speaker["b4w_fade_in"] = 0;
	            //report("speaker", speaker, "b4w_fade_in");
	        }
	        if (!("b4w_fade_out" in speaker)) {
	            speaker["b4w_fade_out"] = 0;
	            //report("speaker", speaker, "b4w_fade_out");
	        }
	        if (!("b4w_loop" in speaker)) {
	            speaker["b4w_loop"] = false;
	            //report("speaker", speaker, "b4w_loop");
	        }
	        if (!("b4w_loop_start" in speaker)) {
	            speaker["b4w_loop_start"] = 0;
	            report("speaker", speaker, "b4w_loop_start");
	        }
	        if (!("b4w_loop_end" in speaker)) {
	            speaker["b4w_loop_end"] = 0;
	            report("speaker", speaker, "b4w_loop_end");
	        }

	        if (speaker["animation_data"])
	            check_strip_props(speaker["animation_data"]);
	    }

	    /* textures */
	    var textures = bpy_data["textures"];

	    for (var i = 0; i < textures.length; i++) {
	        var texture = textures[i];
	        if (!("b4w_anisotropic_filtering" in texture)) {
	            texture["b4w_anisotropic_filtering"] = "OFF";
	            report("texture", texture, "b4w_anisotropic_filtering");
	        }

	        if (!("b4w_water_foam" in texture)) {
	            texture["b4w_water_foam"] = false;
	            report("texture", texture, "b4w_water_foam");
	        }

	        if (!("b4w_foam_uv_freq" in texture)) {
	            texture["b4w_foam_uv_freq"] = [1, 1];
	            report("texture", texture, "b4w_foam_uv_freq");
	        }

	        if (!("b4w_foam_uv_magnitude" in texture)) {
	            texture["b4w_foam_uv_magnitude"] = [1, 1];
	            report("texture", texture, "b4w_foam_uv_magnitude");
	        }

	        if (!("b4w_parallax_steps" in texture)) {
	            texture["b4w_parallax_steps"] = 5;
	            report("material", texture, "b4w_parallax_steps");
	        }

	        if (!("b4w_parallax_lod_dist" in texture)) {
	            texture["b4w_parallax_lod_dist"] = 10;
	            report("material", texture, "b4w_parallax_lod_dist");
	        }

	        if (!("b4w_shore_dist_map" in texture)) {
	            texture["b4w_shore_dist_map"] = false;
	            report("texture", texture, "b4w_shore_dist_map");
	        }

	        if (!("b4w_shore_boundings" in texture)) {
	            texture["b4w_shore_boundings"] = [1000, -1000, 1000, -1000];
	            report("texture", texture, "b4w_shore_boundings");
	        }

	        if (!("b4w_max_shore_dist" in texture)) {
	            texture["b4w_max_shore_dist"] = 100;
	            report("texture", texture, "b4w_max_shore_dist");
	        }

	        if (!("b4w_disable_compression" in texture)) {
	            texture["b4w_disable_compression"] = false;
	            report("texture", texture, "b4w_disable_compression");
	        }

	        if (!("b4w_source_type" in texture)) {
	            texture["b4w_source_type"] = "";
	            report("texture", texture, "b4w_source_type");
	        }

	        if (!("b4w_source_id" in texture)) {
	            texture["b4w_source_id"] = "";
	            report("texture", texture, "b4w_source_id");
	        }

	        if (!("b4w_source_size" in texture)) {
	            texture["b4w_source_size"] = 1024;
	            report("texture", texture, "b4w_source_size");
	        }

	        if (!("b4w_enable_canvas_mipmapping" in texture)) {
	            texture["b4w_enable_canvas_mipmapping"] = true;
	            report("texture", texture, "b4w_enable_canvas_mipmapping");
	        }

	        if (!("b4w_nla_video" in texture)) {
	            texture["b4w_nla_video"] = false;
	            report("texture", texture, "b4w_nla_video");
	        }
	    }

	    /* images */
	    var images = bpy_data["images"];

	    for (var i = 0; i < images.length; i++) {
	        var image = images[i];

	        if (!("colorspace_settings_name" in image)) {
	            image["colorspace_settings_name"] = "sRGB";
	            report("image", image, "colorspace_settings_name");
	        }
	    }

	    /* materials */
	    var materials = bpy_data["materials"];

	    for (var i = 0; i < materials.length; i++) {
	        var mat = materials[i];

	        if (mat["game_settings"]["alpha_blend"] == "ALPHA_ANTIALIASING") {
	            if (cfg_def.mali_alpha_antialias_hack) {
	                // warning message has already been shown in compat.js
	                mat["game_settings"]["alpha_blend"] = "CLIP";
	            } else if (cfg_def.msaa_samples < 2) {
	                m_print.warn("Material \"" + mat["name"] + "\" has the "
	                        + "\"Alpha Anti-Aliasing\" transparency type, but " 
	                        + "multisampling is disabled. Changed to \"Alpha Clip\".");
	                mat["game_settings"]["alpha_blend"] = "CLIP";
	            }
	        }

	        if (!("use_tangent_shading" in mat)) {
	            mat["use_tangent_shading"] = false;
	            report("material", mat, "use_tangent_shading");
	        }

	        if ("b4w_node_mat_type" in mat) {
	            report_deprecated("material", mat, "b4w_node_mat_type");
	        }

	        if ("b4w_skydome" in mat) {
	            report_deprecated("material", mat, "b4w_skydome");
	        }

	        if ("b4w_procedural_skydome" in mat) {
	            report_deprecated("material", mat, "b4w_procedural_skydome");
	        }

	        if (!("b4w_lens_flares" in mat)) {
	            mat["b4w_lens_flares"] = false;
	            report("material", mat, "b4w_lens_flares");
	        }

	        if (mat["name"] === "LENS_FLARES") {
	            if (!mat["b4w_lens_flares"])
	                m_print.warn("\"LENS_FLARES\" material name has been found. Enable " +
	                        "the \"Lens Flare\" property for this material.");
	            mat["b4w_lens_flares"] = true;
	        }

	        if (mat["b4w_water"]) {
	            if (!("b4w_water_shore_smoothing" in mat)) {
	                mat["b4w_water_shore_smoothing"] = false;
	                report("material", mat, "b4w_water_shore_smoothing");
	            }

	            if (!("b4w_water_dynamic" in mat)) {
	                mat["b4w_water_dynamic"] = false;
	                report("material", mat, "b4w_water_dynamic");
	            }

	            if (!("b4w_waves_height" in mat)) {
	                mat["b4w_waves_height"] = 1.0;
	                report("material", mat, "b4w_waves_height");
	            }

	            if (!("b4w_waves_length" in mat)) {
	                mat["b4w_waves_length"] = 1.0;
	                report("material", mat, "b4w_waves_length");
	            }

	            if (!("b4w_water_dst_noise_scale0" in mat)) {
	                mat["b4w_water_dst_noise_scale0"] = 0.05;
	                report("material", mat, "b4w_water_dst_noise_scale0");
	            }

	            if (!("b4w_water_dst_noise_scale1" in mat)) {
	                mat["b4w_water_dst_noise_scale1"] = 0.03;
	                report("material", mat, "b4w_water_dst_noise_scale1");
	            }

	            if (!("b4w_water_dst_noise_freq0" in mat)) {
	                mat["b4w_water_dst_noise_freq0"] = 1.3;
	                report("material", mat, "b4w_water_dst_noise_freq0");
	            }

	            if (!("b4w_water_dst_noise_freq1" in mat)) {
	                mat["b4w_water_dst_noise_freq1"] = 1.0;
	                report("material", mat, "b4w_water_dst_noise_freq1");
	            }

	            if (!("b4w_water_dir_min_shore_fac" in mat)) {
	                mat["b4w_water_dir_min_shore_fac"] = 0.4;
	                report("material", mat, "b4w_water_dir_min_shore_fac");
	            }

	            if (!("b4w_water_dir_freq" in mat)) {
	                mat["b4w_water_dir_freq"] = 0.5;
	                report("material", mat, "b4w_water_dir_freq");
	            }

	            if (!("b4w_water_dir_noise_scale" in mat)) {
	                mat["b4w_water_dir_noise_scale"] = 0.05;
	                report("material", mat, "b4w_water_dir_noise_scale");
	            }

	            if (!("b4w_water_dir_noise_freq" in mat)) {
	                mat["b4w_water_dir_noise_freq"] = 0.07;
	                report("material", mat, "b4w_water_dir_noise_freq");
	            }

	            if (!("b4w_water_dir_min_noise_fac" in mat)) {
	                mat["b4w_water_dir_min_noise_fac"] = 0.5;
	                report("material", mat, "b4w_water_dir_min_noise_fac");
	            }

	            if (!("b4w_water_dst_min_fac" in mat)) {
	                mat["b4w_water_dst_min_fac"] = 0.2;
	                report("material", mat, "b4w_water_dst_min_fac");
	            }

	            if (!("b4w_water_waves_hor_fac" in mat)) {
	                mat["b4w_water_waves_hor_fac"] = 5.0;
	                report("material", mat, "b4w_water_waves_hor_fac");
	            }

	            if (!("b4w_water_absorb_factor" in mat)) {
	                mat["b4w_water_absorb_factor"] = 6.0;
	                report("material", mat, "b4w_water_absorb_factor");
	            }

	            if (!("b4w_water_fog_color" in mat)) {
	                mat["b4w_water_fog_color"] = [0.5,0.7,0.7];
	                report("material", mat, "b4w_water_fog_color");
	            }

	            if (!("b4w_foam_factor" in mat)) {
	                mat["b4w_foam_factor"] = 5.0;
	                report("material", mat, "b4w_foam_factor");
	            }

	            if (!("b4w_generated_mesh" in mat)) {
	                mat["b4w_generated_mesh"] = false;
	                report("material", mat, "b4w_generated_mesh");
	            }

	            if (!("b4w_water_num_cascads" in mat)) {
	                mat["b4w_water_num_cascads"] = 5;
	                report("material", mat, "b4w_water_num_cascads");
	            }

	            if (!("b4w_water_subdivs" in mat)) {
	                mat["b4w_water_subdivs"] = 64;
	                report("material", mat, "b4w_water_subdivs");
	            }

	            if (!("b4w_water_detailed_dist" in mat)) {
	                mat["b4w_water_detailed_dist"] = 1000;
	                report("material", mat, "b4w_water_detailed_dist");
	            }

	            if (!("b4w_water_enable_caust" in mat)) {
	                mat["b4w_water_enable_caust"] = false;
	                report("material", mat, "b4w_water_enable_caust");
	            }

	            if (!("b4w_water_caust_scale" in mat)) {
	                mat["b4w_water_caust_scale"] = 0.25;
	                report("material", mat, "b4w_water_caust_scale");
	            }

	            if (!("b4w_water_caust_brightness" in mat)) {
	                mat["b4w_water_caust_brightness"] = 0.5;
	                report("material", mat, "b4w_water_caust_brightness");
	            }
	        }

	        if (!("b4w_dynamic_grass_size" in mat)) {
	            mat["b4w_dynamic_grass_size"] = "";
	            //report("material", mat, "b4w_dynamic_grass_size");
	        }

	        if (!("b4w_dynamic_grass_color" in mat)) {
	            mat["b4w_dynamic_grass_color"] = "";
	            //report("material", mat, "b4w_dynamic_grass_color");
	        }

	        if (!("diffuse_intensity" in mat)) {
	            mat["diffuse_intensity"] = 1.0;
	            report("material", mat, "diffuse_intensity");
	        }

	        if (!("b4w_use_ghost" in mat)) {
	            mat["b4w_use_ghost"] = false;
	            //report("material", mat, "b4w_use_ghost");
	        }

	        if (!("b4w_collision_margin" in mat)) {
	            mat["b4w_collision_margin"] = 0.040;
	            report("material", mat, "b4w_collision_margin");
	        }

	        if (!("b4w_collision_group" in mat)) {
	            mat["b4w_collision_group"] = 128;
	            report("material", mat, "b4w_collision_group");
	        }

	        if (!("b4w_collision_mask" in mat)) {
	            mat["b4w_collision_mask"] = 127;
	            report("material", mat, "b4w_collision_mask");
	        }

	        if (!("b4w_do_not_render" in mat)) {
	            mat["b4w_do_not_render"] = false;
	            report("material", mat, "b4w_do_not_render");
	        }

	        if (mat.type == "HALO" && !("b4w_halo_sky_stars" in mat)) {
	            mat["b4w_halo_sky_stars"] = false;
	            report("material", mat, "b4w_halo_sky_stars");
	        }

	        if (mat.type == "HALO" && !("b4w_halo_stars_blend_height" in mat)) {
	            mat["b4w_halo_stars_blend_height"] = 10;
	            report("material", mat, "b4w_halo_stars_blend_height");
	        }

	        if (mat.type == "HALO" && !("b4w_halo_stars_min_height" in mat)) {
	            mat["b4w_halo_stars_min_height"] = 0;
	            report("material", mat, "b4w_halo_stars_min_height");
	        }

	        if (!("specular_shader" in mat)) {
	            mat["specular_shader"] = "COOKTORR";
	            report("material", mat, "specular_shader");
	        }

	        if (!("diffuse_shader" in mat)) {
	            mat["diffuse_shader"] = "LAMBERT";
	            report("material", mat, "diffuse_shader");
	        }

	        if (!("roughness" in mat)) {
	            mat["roughness"] = 0.5;
	            report("material", mat, "roughness");
	        }

	        if (!("diffuse_fresnel" in mat)) {
	            mat["diffuse_fresnel"] = 0.1;
	            report("material", mat, "diffuse_fresnel");
	        }

	        if (!("diffuse_fresnel_factor" in mat)) {
	            mat["diffuse_fresnel_factor"] = 0.5;
	            report("material", mat, "diffuse_fresnel_factor");
	        }

	        if (!("specular_slope" in mat)) {
	            mat["specular_slope"] = 0.2;
	            report("material", mat, "specular_slope");
	        }

	        if (!("specular_toon_size" in mat)) {
	            mat["specular_toon_size"] = 0.5;
	            report("material", mat, "specular_toon_size");
	        }

	        if (!("specular_toon_smooth" in mat)) {
	            mat["specular_toon_smooth"] = 0.1;
	            report("material", mat, "specular_toon_smooth");
	        }

	        if (!("specular_alpha" in mat)) {
	            mat["specular_alpha"] = 1.0;
	            report("material", mat, "specular_alpha");
	        }

	        if (!("b4w_wettable" in mat)) {
	            mat["b4w_wettable"] = false;
	            report("material", mat, "b4w_wettable");
	        }

	        if (!("b4w_refractive" in mat)) {
	            mat["b4w_refractive"] = false;
	            report("material", mat, "b4w_refractive");
	        }

	        if (!("b4w_refr_bump" in mat)) {
	            mat["b4w_refr_bump"] = 0;
	            report("material", mat, "b4w_refr_bump");
	        }

	        if (!("b4w_shallow_water_col" in mat)) {
	            mat["b4w_shallow_water_col"] = [0.0, 0.8, 0.3];
	            report("material", mat, "b4w_shallow_water_col");
	        }

	        if (!("b4w_shore_water_col" in mat)) {
	            mat["b4w_shore_water_col"] = [0.0, 0.9, 0.2];
	            report("material", mat, "b4w_shore_water_col");
	        }

	        if (!("b4w_shallow_water_col_fac" in mat)) {
	            mat["b4w_shallow_water_col_fac"] = 1.0;
	            report("material", mat, "b4w_shallow_water_col_fac");
	        }

	        if (!("b4w_shore_water_col_fac" in mat)) {
	            mat["b4w_shore_water_col_fac"] = 0.5;
	            report("material", mat, "b4w_shore_water_col_fac");
	        }

	        if (!("b4w_water_sss_strength" in mat)) {
	            mat["b4w_water_sss_strength"] = 5.9;
	            report("material", mat, "b4w_water_sss_strength");
	        }

	        if (!("b4w_water_sss_width" in mat)) {
	            mat["b4w_water_sss_width"] = 0.45;
	            report("material", mat, "b4w_water_sss_width");
	        }

	        if (!("b4w_render_above_all" in mat)) {
	            mat["b4w_render_above_all"] = false;
	            report("material", mat, "b4w_render_above_all");
	        }
	        if (!("b4w_water_norm_uv_velocity" in mat)) {
	            mat["b4w_water_norm_uv_velocity"] = 0.05;
	            report("material", mat, "b4w_water_norm_uv_velocity");
	        }
	        if (!("specular_ior" in mat)) {
	            mat["specular_ior"] = 1.0;
	            report("material", mat, "specular_ior");
	        }
	        if (!("darkness" in mat)) {
	            mat["darkness"] = 0.0;
	            report("material", mat, "darkness");
	        }
	        if (!("diffuse_toon_size" in mat)) {
	            mat["diffuse_toon_size"] = 0.0;
	            report("material", mat, "diffuse_toon_size");
	        }
	        if (!("diffuse_toon_smooth" in mat)) {
	            mat["diffuse_toon_smooth"] = 0.0;
	            report("material", mat, "diffuse_toon_smooth");
	        }
	        if (!("pass_index" in mat)) {
	            mat["pass_index"] = 0.0;
	            report("material", mat, "pass_index");
	        }

	        var texture_slots = mat["texture_slots"];
	        for (var j = 0; j < texture_slots.length; j++) {
	            var slot = texture_slots[j];
	            if (!("blend_type" in slot)) {
	                slot["blend_type"] = "MIX";
	                report("texture_slot", slot, "blend_type");
	            }
	        }

	        if (mat["node_tree"]) {
	            var nodes = mat["node_tree"]["nodes"];
	            for (var j = 0; j < nodes.length; j++)
	                reform_node(nodes[j]);
	            if (mat["node_tree"]["animation_data"])
	                check_strip_props(mat["node_tree"]["animation_data"]);
	        }
	    }

	    /*node_groups*/
	    var node_groups = bpy_data["node_groups"];
	    for (var i = 0; i < node_groups.length; i++) {
	        var nodes = node_groups[i]["node_tree"]["nodes"];

	        for (var j = 0; j < nodes.length; j++)
	            reform_node(nodes[j]);
	    }
	    var objects = bpy_data["objects"];

	    for (var i = 0; i < objects.length; i++) {
	        var bpy_obj = objects[i];

	        switch(bpy_obj["type"]) {
	        case "MESH":
	            if (!("b4w_dynamic_geometry" in bpy_obj)) {
	                bpy_obj["b4w_dynamic_geometry"] = false;
	                //report("object", bpy_obj, "b4w_dynamic_geometry");
	            }

	            if (!("b4w_reflexible" in bpy_obj)) {
	                bpy_obj["b4w_reflexible"] = false;
	                //report("object", bpy_obj, "b4w_reflexible");
	            }

	            if (!("b4w_reflexible_only" in bpy_obj)) {
	                bpy_obj["b4w_reflexible_only"] = false;
	                //report("object", bpy_obj, "b4w_reflexible_only");
	            }

	            if (!("b4w_reflective" in bpy_obj)) {
	                bpy_obj["b4w_reflective"] = false;
	                //report("object", bpy_obj, "b4w_reflective");
	            }
	            if (!("b4w_reflection_type" in bpy_obj)) {
	                bpy_obj["b4w_reflection_type"] = "PLANE";
	                report("object", bpy_obj, "b4w_reflection_type");
	            }

	            if (!("b4w_wind_bending" in bpy_obj)) {
	                bpy_obj["b4w_wind_bending"] = false;
	                report("object", bpy_obj, "b4w_wind_bending");
	            }

	            if (!("b4w_wind_bending_angle" in bpy_obj)) {
	                bpy_obj["b4w_wind_bending_angle"] = 10.0;
	                bpy_obj["b4w_wind_bending_freq"] = 0.25;
	                report("object", bpy_obj, "wind bending params");
	            }

	            if (!("b4w_detail_bending_amp" in bpy_obj)) {
	                bpy_obj["b4w_detail_bending_amp"] = 0.1;
	                bpy_obj["b4w_branch_bending_amp"] = 0.3;
	                report("object", bpy_obj, "detail bending params");
	            }

	            if (!("b4w_detail_bending_freq" in bpy_obj)) {
	                bpy_obj["b4w_detail_bending_freq"] = 1.0;
	                report("object", bpy_obj, "b4w_detail_bending_freq");
	            }

	            if (!("b4w_main_bend_stiffness_col" in bpy_obj)) {
	                bpy_obj["b4w_main_bend_stiffness_col"] = "";
	                report("object", bpy_obj, "b4w_main_bend_stiffness_col");
	            }

	            if (!("b4w_detail_bend_colors" in bpy_obj)) {
	                bpy_obj["b4w_detail_bend_colors"] = {
	                    "leaves_stiffness_col": "",
	                    "leaves_phase_col": "",
	                    "overall_stiffness_col": ""
	                };
	                report("object", bpy_obj, "b4w_detail_bend_colors");
	            }

	            if (!("b4w_caustics" in bpy_obj)) {
	                bpy_obj["b4w_caustics"] = false;
	                //report("object", bpy_obj, "b4w_caustics");
	            }

	            // NOTE: all vertex things go to mesh
	            // 1 bpy_obj == 1 mesh (enforced by exporter)
	            if ("vertex_groups" in bpy_obj && bpy_obj["vertex_groups"].length &&
	                    bpy_obj["data"] && bpy_obj["data"]["vertex_groups"].length == 0) {
	                bpy_obj["data"]["vertex_groups"] = bpy_obj["vertex_groups"];
	                delete bpy_obj["vertex_groups"];
	                report("object", bpy_obj, "vertex_groups");
	            }
	            if ("b4w_vertex_anim" in bpy_obj && bpy_obj["b4w_vertex_anim"].length &&
	                    bpy_obj["data"] && bpy_obj["data"]["b4w_vertex_anim"].length == 0) {
	                bpy_obj["data"]["b4w_vertex_anim"] = bpy_obj["b4w_vertex_anim"];
	                delete bpy_obj["b4w_vertex_anim"];
	                report("object", bpy_obj, "b4w_vertex_anim");
	            }

	            if (!("b4w_do_not_render" in bpy_obj)) {
	                bpy_obj["b4w_do_not_render"] = false;
	                //report("object", bpy_obj, "b4w_do_not_render");
	            }

	            if (!("b4w_hidden_on_load" in bpy_obj)) {
	                bpy_obj["b4w_hidden_on_load"] = false;
	                //report("object", bpy_obj, "b4w_hidden_on_load");
	            }

	            if (!("b4w_hide_chldr_on_load" in bpy_obj)) {
	                bpy_obj["b4w_hide_chldr_on_load"] = false;
	                //report("object", bpy_obj, "b4w_hidden_on_load");
	            }

	            if (!("use_ghost" in bpy_obj["game"])) {
	                bpy_obj["game"]["use_ghost"] = false;
	                //report("object", bpy_obj, "use_ghost");
	            }
	            if (!("use_sleep" in bpy_obj["game"])) {
	                bpy_obj["game"]["use_sleep"] = false;
	                //report("object", bpy_obj, "use_sleep");
	            }
	            if (!("velocity_min" in bpy_obj["game"])) {
	                bpy_obj["game"]["velocity_min"] = 0;
	                //report("object", bpy_obj, "velocity_min");
	            }
	            if (!("velocity_max" in bpy_obj["game"])) {
	                bpy_obj["game"]["velocity_max"] = 0;
	                //report("object", bpy_obj, "velocity_max");
	            }
	            if (!("collision_group" in bpy_obj["game"])) {
	                bpy_obj["game"]["collision_group"] = 1;
	                //report("object", bpy_obj, "collision_group");
	            }
	            if (!("collision_mask" in bpy_obj["game"])) {
	                bpy_obj["game"]["collision_mask"] = 255;
	                //report("object", bpy_obj, "collision_mask");
	            }

	            check_collision_bounds_type(bpy_obj);

	            if ("b4w_vehicle_settings" in bpy_obj) {
	                if (bpy_obj["b4w_vehicle_settings"]) {
	                    if (!("steering_ratio" in bpy_obj["b4w_vehicle_settings"])) {
	                        bpy_obj["b4w_vehicle_settings"]["steering_ratio"] = 10;
	                        //report("object", bpy_obj, "steering_ratio");
	                    }
	                    if (!("steering_max" in bpy_obj["b4w_vehicle_settings"])) {
	                        bpy_obj["b4w_vehicle_settings"]["steering_max"] = 1;
	                        //report("object", bpy_obj, "steering_max");
	                    }
	                    if (!("inverse_control" in bpy_obj["b4w_vehicle_settings"])) {
	                        bpy_obj["b4w_vehicle_settings"]["inverse_control"] = false;
	                        //report("object", bpy_obj, "inverse_control");
	                    }
	                    if (!("force_max" in bpy_obj["b4w_vehicle_settings"])) {
	                        bpy_obj["b4w_vehicle_settings"]["force_max"] = 1500;
	                        //report("object", bpy_obj, "force_max");
	                    }
	                    if (!("brake_max" in bpy_obj["b4w_vehicle_settings"])) {
	                        bpy_obj["b4w_vehicle_settings"]["brake_max"] = 100;
	                        //report("object", bpy_obj, "brake_max");
	                    }
	                    if (!("speed_ratio" in bpy_obj["b4w_vehicle_settings"])) {
	                        bpy_obj["b4w_vehicle_settings"]["speed_ratio"] = 0.027;
	                        //report("object", bpy_obj, "speed_ratio");
	                    }
	                    if (!("max_speed_angle" in bpy_obj["b4w_vehicle_settings"])) {
	                        bpy_obj["b4w_vehicle_settings"]["max_speed_angle"] = Math.PI;
	                        //report("object", bpy_obj, "max_speed_angle");
	                    }
	                    if (!("delta_tach_angle" in bpy_obj["b4w_vehicle_settings"])) {
	                        bpy_obj["b4w_vehicle_settings"]["delta_tach_angle"] = 4.43;
	                        //report("object", bpy_obj, "delta_tach_angle");
	                    }
	                    if (!("suspension_compression" in bpy_obj["b4w_vehicle_settings"])) {
	                        bpy_obj["b4w_vehicle_settings"]["suspension_compression"] = 4.4;
	                        //report("object", bpy_obj, "suspension_compression");
	                    }
	                    if (!("suspension_stiffness" in bpy_obj["b4w_vehicle_settings"])) {
	                        bpy_obj["b4w_vehicle_settings"]["suspension_stiffness"] = 20.0;
	                        //report("object", bpy_obj, "suspension_stiffness");
	                    }
	                    if (!("suspension_damping" in bpy_obj["b4w_vehicle_settings"])) {
	                        bpy_obj["b4w_vehicle_settings"]["suspension_damping"] = 2.3;
	                        //report("object", bpy_obj, "suspension_damping");
	                    }
	                    if (!("wheel_friction" in bpy_obj["b4w_vehicle_settings"])) {
	                        bpy_obj["b4w_vehicle_settings"]["wheel_friction"] = 1000.0;
	                        //report("object", bpy_obj, "wheel_friction");
	                    }
	                    if (!("roll_influence" in bpy_obj["b4w_vehicle_settings"])) {
	                        bpy_obj["b4w_vehicle_settings"]["roll_influence"] = 0.1;
	                        //report("object", bpy_obj, "roll_influence");
	                    }
	                    if (!("max_suspension_travel_cm" in bpy_obj["b4w_vehicle_settings"])) {
	                        bpy_obj["b4w_vehicle_settings"]["max_suspension_travel_cm"] = 30;
	                        //report("object", bpy_obj, "max_suspension_travel_cm");
	                    }
	                    if (!("floating_factor" in bpy_obj["b4w_vehicle_settings"])) {
	                        bpy_obj["b4w_vehicle_settings"]["floating_factor"] = 3.0;
	                        //report("object", bpy_obj, "floating_factor");
	                    }
	                    if (!("floating_factor" in bpy_obj["b4w_vehicle_settings"])) {
	                        bpy_obj["b4w_vehicle_settings"]["floating_factor"] = 3.0;
	                        //report("object", bpy_obj, "floating_factor");
	                    }
	                    if (!("water_lin_damp" in bpy_obj["b4w_vehicle_settings"])) {
	                        bpy_obj["b4w_vehicle_settings"]["water_lin_damp"] = 0.9;
	                        //report("object", bpy_obj, "water_lin_damp");
	                    }
	                    if (!("water_rot_damp" in bpy_obj["b4w_vehicle_settings"])) {
	                        bpy_obj["b4w_vehicle_settings"]["water_rot_damp"] = 0.9;
	                        //report("object", bpy_obj, "water_rot_damp");
	                    }
	                }
	            } else {
	                bpy_obj["b4w_vehicle_settings"] = null;
	                report("object", bpy_obj, "b4w_vehicle_settings");
	            }

	            if ("b4w_floating_settings" in bpy_obj) {
	                if (bpy_obj["b4w_floating_settings"]) {
	                    if (!("floating_factor" in bpy_obj["b4w_floating_settings"])) {
	                        bpy_obj["b4w_floating_settings"]["floating_factor"] = 3.0;
	                        //report("object", bpy_obj, "floating_factor");
	                    }
	                    if (!("water_lin_damp" in bpy_obj["b4w_floating_settings"])) {
	                        bpy_obj["b4w_floating_settings"]["water_lin_damp"] = 0.8;
	                        //report("object", bpy_obj, "water_lin_damp");
	                    }
	                    if (!("water_rot_damp" in bpy_obj["b4w_floating_settings"])) {
	                        bpy_obj["b4w_floating_settings"]["water_rot_damp"] = 0.8;
	                        //report("object", bpy_obj, "water_rot_damp");
	                    }
	                }
	            } else {
	                bpy_obj["b4w_floating_settings"] = null;
	                report("object", bpy_obj, "b4w_floating_settings");
	            }

	            if ("b4w_character_settings" in bpy_obj) {
	                if (bpy_obj["b4w_character_settings"]) {
	                    if (!("walk_speed" in bpy_obj["b4w_character_settings"])) {
	                        bpy_obj["b4w_character_settings"]["walk_speed"] = 4;
	                        //report("object", bpy_obj, "walk_speed");
	                    }
	                    if (!("run_speed" in bpy_obj["b4w_character_settings"])) {
	                        bpy_obj["b4w_character_settings"]["run_speed"] = 8;
	                        //report("object", bpy_obj, "run_speed");
	                    }
	                    if (!("step_height" in bpy_obj["b4w_character_settings"])) {
	                        bpy_obj["b4w_character_settings"]["step_height"] = 0.25;
	                        //report("object", bpy_obj, "step_height");
	                    }
	                    if (!("jump_strength" in bpy_obj["b4w_character_settings"])) {
	                        bpy_obj["b4w_character_settings"]["jump_strength"] = 5;
	                        //report("object", bpy_obj, "jump_strength");
	                    }
	                    if (!("waterline" in bpy_obj["b4w_character_settings"])) {
	                        bpy_obj["b4w_character_settings"]["waterline"] = 0.0;
	                        //report("object", bpy_obj, "waterline");
	                    }
	                }
	            } else {
	                bpy_obj["b4w_character_settings"] = null;
	                report("object", bpy_obj, "b4w_character_settings");
	            }

	            if (!("b4w_selectable" in bpy_obj)) {
	                bpy_obj["b4w_selectable"] = false;
	                report("object", bpy_obj, "b4w_selectable");
	            }
	            if (!("b4w_outlining" in bpy_obj)) {
	                bpy_obj["b4w_outlining"] = false;
	                report("object", bpy_obj, "b4w_outlining");
	            }
	            if (!("b4w_outline_on_select" in bpy_obj)) {
	                bpy_obj["b4w_outline_on_select"] = false;
	                report("object", bpy_obj, "b4w_outline_on_select");
	            }
	            if (!("b4w_billboard" in bpy_obj)) {
	                bpy_obj["b4w_billboard"] = false;
	                report("object", bpy_obj, "b4w_billboard");
	            }
	            if (!("b4w_billboard_geometry" in bpy_obj)) {
	                bpy_obj["b4w_billboard_geometry"] = "SPHERICAL";
	                report("object", bpy_obj, "b4w_billboard_geometry");
	            }
	            if (!("b4w_pres_glob_orientation" in bpy_obj)) {
	                bpy_obj["b4w_pres_glob_orientation"] = false;
	                report("object", bpy_obj, "b4w_pres_glob_orientation");
	            }
	            if (!("b4w_outline_settings" in bpy_obj)) {
	                if ("b4w_glow_settings" in bpy_obj)
	                    bpy_obj["b4w_outline_settings"] = bpy_obj["b4w_glow_settings"];
	                else {
	                    bpy_obj["b4w_outline_settings"] = {};
	                    bpy_obj["b4w_outline_settings"]["outline_duration"] = 1.0;
	                    bpy_obj["b4w_outline_settings"]["outline_period"] = 1.0;
	                    bpy_obj["b4w_outline_settings"]["outline_relapses"] = 0;
	                }
	                report("object", bpy_obj, "b4w_outline_settings");
	            }
	            if (!("lod_levels" in bpy_obj)) {
	                bpy_obj["lod_levels"] = [];
	                report("object", bpy_obj, "lod_levels");
	            }
	            if (!("b4w_animation_mixing" in bpy_obj)) {
	                bpy_obj["b4w_animation_mixing"] = false;
	                report("object", bpy_obj, "b4w_animation_mixing");
	            }
	            break;
	        case "EMPTY":
	            if (!("b4w_anchor" in bpy_obj)) {
	                bpy_obj["b4w_anchor"] = null;
	                report("object", bpy_obj, "b4w_anchor");
	            }
	            if (bpy_obj["b4w_anchor"] && !("max_width" in bpy_obj["b4w_anchor"])) {
	                bpy_obj["b4w_anchor"]["max_width"] = 250;
	            }

	            break;
	        default:
	            break;
	        }

	        if (!("collision_margin" in bpy_obj["game"])) {
	            bpy_obj["game"]["collision_margin"] = 0.040;
	            report("object", bpy_obj, "collision_margin");
	        }

	        if (!("b4w_anim_behavior" in bpy_obj)) {
	            bpy_obj["b4w_anim_behavior"] = bpy_obj["b4w_cyclic_animation"] ?
	                    "CYCLIC" : "FINISH_STOP";
	            report("object", bpy_obj, "b4w_anim_behavior");
	        }

	        if (!("rotation_quaternion" in bpy_obj)) {
	            var quat = [0,0,0,1];
	            m_util.euler_to_quat(bpy_obj["rotation_euler"], quat);
	            quat_b4w_bpy(quat, quat);
	            bpy_obj["rotation_quaternion"] = quat;
	            report("object", bpy_obj, "rotation_quaternion");
	        }

	        if ("webgl_do_not_batch" in bpy_obj) {
	            bpy_obj["b4w_do_not_batch"] = bpy_obj["webgl_do_not_batch"];

	            if (bpy_obj["webgl_do_not_batch"])
	                report_deprecated("object", bpy_obj, "webgl_do_not_batch");
	        }

	        if (!("b4w_shadow_cast_only" in bpy_obj)) {
	            bpy_obj["b4w_shadow_cast_only"] = false;
	            report("object", bpy_obj, "b4w_shadow_cast_only");
	        }

	        if (!("b4w_correct_bounding_offset" in bpy_obj)) {
	            bpy_obj["b4w_correct_bounding_offset"] = "AUTO";
	            report("object", bpy_obj, "b4w_correct_bounding_offset");
	        }

	        var psystems = bpy_obj["particle_systems"];
	        for (var j = 0; j < psystems.length; j++) {
	            var psys = psystems[j];
	            var pset = psys["settings"];

	            if (!("use_rotation_dupli" in pset)) {
	                pset["use_rotation_dupli"] = false;
	                report("particle_settings", pset, "use_rotation_dupli");
	            }

	            if (!("use_whole_group" in pset)) {
	                pset["use_whole_group"] = false;
	                report("particle_settings", pset, "use_whole_group");
	            }

	            if (!psys["transforms"]) {
	                psys["transforms"] = new Float32Array();
	                report("particle_system", psys, "transforms");
	            }

	            if (!("b4w_billboard_align" in pset)) {
	                pset["b4w_billboard_align"] = "VIEW";
	                report("particle_settings", pset, "b4w_billboard_align");
	            }

	            if (!("b4w_dynamic_grass" in pset)) {
	                pset["b4w_dynamic_grass"] = false;
	                report("object", pset, "b4w_dynamic_grass");
	            }

	            if (!("b4w_dynamic_grass_scale_threshold" in pset)) {
	                pset["b4w_dynamic_grass_scale_threshold"] = 0.01;
	                report("object", pset, "b4w_dynamic_grass_scale_threshold");
	            }

	            if (!("b4w_initial_rand_rotation" in pset)) {
	                pset["b4w_initial_rand_rotation"] = false;
	                report("particle_settings", pset, "b4w_initial_rand_rotation");
	            }

	            if (!("b4w_rotation_type" in pset)) {
	                pset["b4w_rotation_type"] = "Z";
	                report("particle_settings", pset, "b4w_rotation_type");
	            }

	            if (!("b4w_rand_rotation_strength" in pset)) {
	                pset["b4w_rand_rotation_strength"] = 1;
	                report("particle_settings", pset, "b4w_rand_rotation_strength");
	            }

	            if (!("b4w_hair_billboard" in pset)) {
	                pset["b4w_hair_billboard"] = false;
	                report("particle_settings", pset, "b4w_hair_billboard");
	            }

	            if (!("b4w_hair_billboard_type" in pset)) {
	                pset["b4w_hair_billboard_type"] = "BASIC";
	                report("particle_settings", pset, "b4w_hair_billboard_type");
	            }

	            if (!("b4w_hair_billboard_jitter_amp" in pset)) {
	                pset["b4w_hair_billboard_jitter_amp"] = 0;
	                report("particle_settings", pset, "b4w_hair_billboard_jitter_amp");
	            }

	            if (!("b4w_hair_billboard_jitter_freq" in pset)) {
	                pset["b4w_hair_billboard_jitter_freq"] = 0;
	                report("particle_settings", pset, "b4w_hair_billboard_jitter_freq");
	            }

	            if (!("b4w_hair_billboard_geometry" in pset)) {
	                pset["b4w_hair_billboard_geometry"] = "SPHERICAL";
	                report("particle_settings", pset, "b4w_hair_billboard_geometry");
	            }

	            if (!("b4w_wind_bend_inheritance" in pset)) {
	                pset["b4w_wind_bend_inheritance"] = "PARENT";
	                report("particle_settings", pset, "b4w_wind_bend_inheritance");
	            }

	            if (!("b4w_shadow_inheritance" in pset)) {
	                pset["b4w_shadow_inheritance"] = "PARENT";
	                report("particle_settings", pset, "b4w_shadow_inheritance");
	            }

	            if (!("b4w_reflection_inheritance" in pset)) {
	                pset["b4w_reflection_inheritance"] = "PARENT";
	                report("particle_settings", pset, "b4w_reflection_inheritance");
	            }

	            if (!("b4w_vcol_from_name" in pset)) {
	                pset["b4w_vcol_from_name"] = "";
	                report("particle_settings", pset, "b4w_vcol_from_name");
	            }

	            if (!("b4w_vcol_to_name" in pset)) {
	                pset["b4w_vcol_to_name"] = "";
	                report("particle_settings", pset, "b4w_vcol_to_name");
	            }

	            if (!("b4w_coordinate_system" in pset)) {
	                pset["b4w_coordinate_system"] = "LOCAL";
	                report("particle_settings", pset, "b4w_coordinate_system");
	            }

	            if (!("b4w_allow_nla" in pset)) {
	                pset["b4w_allow_nla"] = true;
	                report("particle_settings", pset, "b4w_allow_nla");
	            }

	            if (!("b4w_enable_soft_particles" in pset)) {
	                pset["b4w_enable_soft_particles"] = false;
	                report("particle_settings", pset, "b4w_enable_soft_particles");
	            }

	            if (!("b4w_particles_softness" in pset)) {
	                pset["b4w_particles_softness"] = 1.0;
	                report("particle_settings", pset, "b4w_particles_softness");
	            }

	            if (!("billboard_tilt" in pset)) {
	                pset["billboard_tilt"] = 0.0;
	                report("particle_settings", pset, "billboard_tilt");
	            }

	            if (!("billboard_tilt_random" in pset)) {
	                pset["billboard_tilt_random"] = 0.0;
	                report("particle_settings", pset, "billboard_tilt_random");
	            }

	            if (!("use_rotations" in pset)) {
	                pset["use_rotations"] = false;
	                report("particle_settings", pset, "use_rotations");
	            }
	        }

	        if (!("constraints" in bpy_obj)) {
	            bpy_obj["constraints"] = [];
	            report("object", bpy_obj, "constraints");
	        }
	        var constraints = bpy_obj["constraints"];
	        for (var j = 0; j < constraints.length; j++) {
	            var cons = constraints[j];
	            if (!("influence" in cons)) {
	                cons["influence"] = 1;
	            }
	            if (!("axes" in cons)) {
	                cons["axes"] = [1, 1, 1];
	            }
	        }

	        var mods = bpy_obj["modifiers"];
	        for (var j = 0; j < mods.length; j++) {
	            if (!check_modifier(mods[j], bpy_obj)) {
	                // remove from array
	                mods.splice(j, 1);
	                j--;
	            }
	        }

	        if (!("animation_data" in bpy_obj)) {
	            bpy_obj["animation_data"] = {
	                "action": null,
	                "nla_tracks": []
	            };
	            report("object", bpy_obj, "animation_data");
	        }

	        if (bpy_obj["animation_data"]) {
	            if (!("action" in bpy_obj["animation_data"])) {
	                bpy_obj["animation_data"]["action"] = null;
	                report_raw("no action in animation data " + bpy_obj["name"]);
	            }

	            if (!("nla_tracks" in bpy_obj["animation_data"])) {
	                bpy_obj["animation_data"]["nla_tracks"] = [];
	                report_raw("no NLA in animation data " + bpy_obj["name"]);
	            }

	            check_strip_props(bpy_obj["animation_data"]);
	        }

	        if (!("b4w_collision_id" in bpy_obj)) {
	            bpy_obj["b4w_collision_id"] = "";
	            report("object", bpy_obj, "b4w_collision_id");
	        }

	        if (!("b4w_viewport_alignment" in bpy_obj)) {
	            bpy_obj["b4w_viewport_alignment"] = null;
	            report("object", bpy_obj, "b4w_viewport_alignment");
	        }

	        if (!("pinverse_tsr" in bpy_obj)) {
	            bpy_obj["pinverse_tsr"] = null;
	            report("object", bpy_obj, "pinverse_tsr");
	        }

	        if (!("b4w_cluster_data" in bpy_obj)) {
	            bpy_obj["b4w_cluster_data"] = { 
	                "cluster_id": -1,
	                "cluster_center": null
	            };
	            report("object", bpy_obj, "b4w_cluster_data");
	        }

	        if (!("pass_index" in bpy_obj)) {
	            bpy_obj["pass_index"] = 0.0;
	            report("object", bpy_obj, "pass_index");
	        }

	        if (!("b4w_custom_prop" in bpy_obj)) {
	            report("object", bpy_obj, "b4w_custom_prop");
	            bpy_obj["b4w_custom_prop"] = null;
	        }

	        if (check_negative_scale(bpy_obj))
	            report_raw("negative scale for object \"" + bpy_obj["name"] + "\", can lead to some errors");

	        if (!check_uniform_scale(bpy_obj))
	            report_raw("non-uniform scale for object " + bpy_obj["name"]);
	    }

	    if (_unreported_compat_issues)
	        m_print.error("Compatibility issues detected");

	    for (var param in _params_reported) {
	        var param_data = _params_reported[param];
	        var param_name = param.match(/.*?(?=>>|$)/i)[0];
	        m_print.warn("Property \"" + String(param_name) +
	            "\" is " + param_data.report_type + " for \"" + param_data.type +
	             "\". To fix this, reexport " + bpy_data["b4w_filepath_blend"]);
	    }
	};

	function check_strip_props(animation_data) {

	    var nla_tracks = animation_data["nla_tracks"];
	    if (nla_tracks)
	        for (var j = 0; j < nla_tracks.length; j++) {
	            var track = nla_tracks[j];
	            for (var k = 0; k < track["strips"].length; k++) {
	                var strip = track["strips"][k];
	                if (!("action" in strip)) {
	                    strip["action"] = null;
	                    report("strip", strip, "action");
	                }
	                if (!("action_frame_start" in strip)) {
	                    strip["action_frame_start"] = 0;
	                    report("strip", strip, "action_frame_start");
	                }
	                if (!("action_frame_end" in strip)) {
	                    strip["action_frame_end"] = strip["frame_end"] - strip["frame_start"];
	                    report("strip", strip, "action_frame_end");
	                }

	                if (!("repeat" in strip)) {
	                    strip["repeat"] = 1;
	                    report("strip", strip, "repeat");
	                }
	                if (!("use_reverse" in strip)) {
	                    strip["use_reverse"] = false;
	                    report("strip", strip, "use_reverse");
	                }
	                if (!("scale" in strip)) {
	                    strip["scale"] = 1;
	                    report("strip", strip, "scale");
	                }
	            }
	        }
	}

	function check_export_props(bpy_obj) {
	    var export_props = ["b4w_apply_scale", "b4w_apply_modifiers", 
	            "b4w_export_edited_normals", "b4w_loc_export_vertex_anim", 
	            "b4w_shape_keys"];
	    var prop_found = null;
	    for (var i = 0; i < export_props.length; i++) {
	        if (bpy_obj[export_props[i]])
	            if(!prop_found)
	                prop_found = export_props[i];
	            else {
	                bpy_obj[export_props[i]] = false;
	                m_print.warn("WARNING property \"" + export_props[i] + "\" of object \"" 
	                    + bpy_obj["name"] + "\" has been set to \"false\". Foreground property \""
	                    + prop_found + "\" already exists.");
	            }
	    }
	}

	function check_collision_bounds_type(bpy_obj) {
	    var game = bpy_obj["game"];
	    var bounds_type = game["collision_bounds_type"];
	    if (game["use_collision_bounds"] && bounds_type != "BOX"
	            && bounds_type != "CYLINDER" && bounds_type != "CONE"
	            && bounds_type != "SPHERE" && bounds_type != "CAPSULE"
	            && bounds_type != "EMPTY") {
	        m_print.error("Wrong collision bounds type " + bounds_type +
	                ". Disable physics for object " + bpy_obj["name"]);
	        bpy_obj["b4w_collision"] = false;
	        bpy_obj["b4w_floating"] = false;
	        bpy_obj["b4w_vehicle"] = false;
	        bpy_obj["b4w_character"] = false;
	    }
	}

	function quat_b4w_bpy(quat, dest) {
	    var x = quat[0];
	    var y = quat[1];
	    var z = quat[2];
	    var w = quat[3];

	    dest[0] = w;
	    dest[1] = x;
	    dest[2] = y;
	    dest[3] = z;

	    return dest;
	}

	/**
	 * Report compatibility issue.
	 */
	function report(type, bpy_datablock, missing_param) {

	    if (!REPORT_COMPATIBILITY_ISSUES) {
	        _unreported_compat_issues = true;
	        return;
	    }

	    var param_id = missing_param+">>"+type;

	    if (!(param_id in _params_reported)) {
	        _params_reported[param_id] = {
	            storage: [],
	            report_type: "undefined",
	            type: type
	        };
	    }

	    _params_reported[param_id].storage.push(bpy_datablock["name"]);
	}
	/**
	 * Report about missing datablock.
	 */
	function report_missing_datablock(type, file_path_blend) {
	    if (!REPORT_COMPATIBILITY_ISSUES) {
	        _unreported_compat_issues = true;
	        return;
	    }

	    m_print.warn("WARNING " + "Datablock " + type + " is missing, reexport \"" +
	                file_path_blend + "\" scene");
	}
	/**
	 * Report about deprecated datablock
	 */
	function report_deprecated(type, bpy_datablock, deprecated_param) {
	    if (!REPORT_COMPATIBILITY_ISSUES) {
	        _unreported_compat_issues = true;
	        return;
	    }

	    var param_id = deprecated_param+">>"+type;

	    if (!(param_id in _params_reported)) {
	        _params_reported[param_id] = {
	            storage: [],
	            report_type: "deprecated",
	            type: type
	        };
	    }
	    _params_reported[param_id].storage.push(bpy_datablock["name"]);
	}
	function report_modifier(type, bpy_obj, file_path_blend) {
	    if (!REPORT_COMPATIBILITY_ISSUES) {
	        _unreported_compat_issues = true;
	        return;
	    }

	    m_print.error("WARNING " + "Incomplete modifier " + String(type) + " for " +
	            "\"" + bpy_obj["name"] + "\"" + ", reexport \"" +
	            file_path_blend + "\" scene");

	}
	/**
	 * Report raw message
	 */
	function report_raw(msg) {
	    if (!REPORT_COMPATIBILITY_ISSUES) {
	        _unreported_compat_issues = true;
	        return;
	    }
	    m_print.warn(msg);
	}

	function check_uniform_scale(bpy_obj) {
	    var scale = bpy_obj["scale"];
	    var eps = 0.005;

	    if (scale[0] == 0 && scale[1] == 0 && scale[2] == 0)
	        return true;

	    var delta1 = Math.abs((scale[0] - scale[1]) / scale[0]);
	    var delta2 = Math.abs((scale[1] - scale[2]) / scale[1]);

	    return (delta1 < eps && delta2 < eps);
	}

	function check_negative_scale(bpy_obj) {
	    return bpy_obj["scale"][0] < 0 || bpy_obj["scale"][1] < 0 || bpy_obj["scale"][2] < 0;
	}

	exports.check_anim_fcurve_completeness = function(fcurve, action) {
	    if (!("num_channels" in fcurve)) {
	        fcurve["num_channels"] = 1;
	        report_raw("B4W Warning: no channels number in animation fcurve for \"" +
	                   action["name"] + "\" action, reexport scene");
	    }
	};

	/**
	 * Apply modifiers for mesh object and return new mesh.
	 */
	exports.apply_mesh_modifiers = function(bpy_obj) {
	    if (!has_modifiers(bpy_obj))
	        return null;

	    var mesh = mesh_copy(bpy_obj["data"], bpy_obj["data"]["name"] + "_MOD");
	    var modifiers = bpy_obj["modifiers"];
	    for (var i = 0; i < modifiers.length; i++) {
	        var mod = modifiers[i];

	        switch(mod["type"]) {
	        case "ARRAY":
	            apply_array_modifier(mesh, mod);
	            break;
	        case "CURVE":
	            apply_curve_modifier(mesh, mod);
	            break;
	        default:
	            // just ignore
	            break;
	        }
	        m_bounds.recalculate_mesh_boundings(mesh);
	    }
	    return mesh;
	};

	/**
	 * Check if given object has interesting modifiers
	 */
	function has_modifiers(bpy_obj) {
	    var modifiers = bpy_obj["modifiers"];
	    for (var i = 0; i < modifiers.length; i++) {
	        var mod = modifiers[i];
	        var type = mod["type"];
	        if (type == "ARRAY" || type == "CURVE")
	            return true;
	    }

	    return false;
	}

	function apply_array_modifier(mesh, mod) {

	    var dx = 0;
	    var dy = 0;
	    var dz = 0;

	    var trans_matrix = new Float32Array(16);

	    var new_meshes = [];

	    for (var i = 1; i < mod["count"]; i++) {

	        if (mod["use_constant_offset"]) {
	            dx += mod["constant_offset_displace"][0];
	            dy += mod["constant_offset_displace"][1];
	            dz += mod["constant_offset_displace"][2];
	        }

	        if (mod["use_relative_offset"]) {
	            var bb = mesh["b4w_boundings"]["bb"];
	            dx += (bb["max_x"] - bb["min_x"]) * mod["relative_offset_displace"][0];
	            dy += (bb["max_y"] - bb["min_y"]) * mod["relative_offset_displace"][1];
	            dz += (bb["max_z"] - bb["min_z"]) * mod["relative_offset_displace"][2];
	        }

	        m_util.trans_matrix(dx, dy, dz, trans_matrix);

	        var mc = mesh_copy(mesh);
	        mesh_transform_locations(mc, trans_matrix);
	        new_meshes.push(mc);
	    }

	    for (var i = 0; i < new_meshes.length; i++)
	        array_mesh_join(mesh, new_meshes[i]);
	}

	function apply_curve_modifier(mesh, mod) {
	    var bpy_obj = mod["object"];
	    var spline = m_curve.create_spline(bpy_obj);

	    var matrix = new Float32Array(16);

	    var ncoords = spline.is_3d ? 4 : 3;

	    var point = new Float32Array(ncoords);
	    var deriv = new Float32Array(ncoords);

	    var trans = new Float32Array(3);
	    var quat = new Float32Array(4);
	    var qtilt = new Float32Array(4);

	    var tangent_a = new Float32Array(3);
	    var tangent_b = new Float32Array(3);

	    var loc = new Float32Array(3);

	    for (var i = 0; i < mesh["submeshes"].length; i++) {
	        var submesh = mesh["submeshes"][i];

	        var position = submesh["position"];
	        var tbn = submesh["tbn"];

	        // NOTE: expected that mesh lies on positive side of deform axis
	        var deform_index = deform_axis_index(mod["deform_axis"]);
	        tangent_a[0] = 0;
	        tangent_a[1] = 0;
	        tangent_a[2] = 0;
	        tangent_a[deform_index] = 1;

	        var slen = m_curve.spline_length(spline);

	        for (var j = 0; j < position.length / 3; j++) {

	            loc[0] = position[3*j];
	            loc[1] = position[3*j+1];
	            loc[2] = position[3*j+2];

	            var loc_spline_len = loc[deform_index];
	            var t = m_curve.spline_len_to_t(spline, loc_spline_len);

	            m_curve.spline_point(spline, t, point);

	            trans[0] = point[0];
	            trans[1] = point[1];
	            trans[2] = point[2];

	            m_curve.spline_derivative(spline, t, deriv);

	            tangent_b[0] = deriv[0];
	            // NOTE: workaround for bug with wrong twist of curves along y-axis
	            // maybe it's somehow connected with Z-UP curve property
	            tangent_b[1] = 0;
	            tangent_b[2] = deriv[2];
	            m_vec3.normalize(tangent_b, tangent_b);

	            m_quat.rotationTo(tangent_a, tangent_b, quat);

	            // calculate possible curve exceeding
	            if (loc_spline_len < 0) {
	                point[0] = tangent_b[0];
	                point[1] = tangent_b[1];
	                point[2] = tangent_b[2];
	                m_vec3.scale(point, loc_spline_len, point);
	                m_vec3.add(trans, point, trans);
	            } else if (loc_spline_len > slen) {
	                point[0] = tangent_b[0];
	                point[1] = tangent_b[1];
	                point[2] = tangent_b[2];
	                m_vec3.scale(point, (loc_spline_len - slen), point);
	                m_vec3.add(trans, point, trans);
	            }

	            m_mat4.fromRotationTranslation(quat, trans, matrix);

	            if (spline.is_3d) {
	                var tilt = point[3];
	                m_quat.setAxisAngle(tangent_a, tilt, qtilt);
	                m_vec3.transformQuat(loc, qtilt, loc);
	            }

	            // simple translation to curve point space
	            loc[deform_index] = 0;

	            m_vec3.transformMat4(loc, matrix, loc);

	            // save
	            position[3*j] = loc[0];
	            position[3*j+1] = loc[1];
	            position[3*j+2] = loc[2];

	            var cur_tbn = m_tbn.get_item(tbn, j, _tbn_tmp);
	            m_tbn.multiply_quat(cur_tbn, quat, cur_tbn);
	            m_tbn.set_item(tbn, cur_tbn, j);
	        }
	    }
	}

	function deform_axis_index(deform_axis) {
	    switch (deform_axis) {
	    case "POS_X":
	    case "NEG_X":
	        return 0;
	    case "POS_Y":
	    case "NEG_Y":
	        return 1;
	    case "POS_Z":
	    case "NEG_Z":
	        return 2;
	    default:
	        m_util.panic("Wrong deform axis value " + deform_axis);
	    }
	}

	/**
	 * Extract submesh with given material index
	 */
	function mesh_copy(mesh, new_name) {

	    if (!new_name)
	        new_name = mesh["name"] + "_COPY";

	    var materials = mesh["materials"];
	    var submeshes = mesh["submeshes"];

	    mesh["materials"] = null;
	    mesh["submeshes"] = null;

	    var mesh_new = m_util.clone_object_r(mesh);

	    mesh["materials"] = materials;
	    mesh["submeshes"] = submeshes;

	    mesh_new["name"] = new_name;
	    // materials by link
	    mesh_new["materials"] = mesh["materials"].slice(0);

	    mesh_new["submeshes"] = [];
	    for (var i = 0; i < submeshes.length; i++) {
	        var submesh = submeshes[i];
	        var submesh_new = m_util.clone_object_nr(submesh);
	        mesh_new["submeshes"].push(submesh_new);
	    }
	    return mesh_new;
	}

	/**
	 * Join two meshes: used only for ARRAY modifier
	 */
	function array_mesh_join(mesh, mesh2) {

	    for (var i = 0; i < mesh["submeshes"].length; i++) {
	        var submesh = mesh["submeshes"][i];
	        var submesh2 = mesh2["submeshes"][i];

	        var base_length = submesh["base_length"];
	        var index_length = submesh["indices"].length;

	        if (base_length)
	            for (var prop in submesh) {
	                switch (prop) {
	                case "base_length":
	                    submesh[prop] += submesh2[prop];
	                    break;
	                case "boundings":
	                    // will be recalculated later for all meshes by calling 
	                    // m_bounds.recalculate_mesh_boundings()
	                    break;
	                case "indices":
	                    submesh[prop] = m_util.uint32_concat(submesh[prop], submesh2[prop]);
	                    for (var j = index_length; j < submesh[prop].length; j++)
	                        submesh[prop][j] += base_length;
	                    break;

	                case "position":
	                    submesh[prop] = array_join_framed_submesh_props(submesh[prop], 
	                            submesh2[prop], submesh[prop].length / base_length / 3);
	                    break;
	                case "tbn":
	                    submesh[prop] = array_join_framed_submesh_props(submesh[prop], 
	                            submesh2[prop], submesh[prop].length / base_length / 4);
	                    break;
	                case "shade_tangs":
	                    submesh[prop] = array_join_framed_submesh_props(submesh[prop], 
	                            submesh2[prop], submesh[prop].length / base_length / 3);
	                    break;
	                case "group":
	                    submesh[prop] = array_join_framed_submesh_props(submesh[prop], 
	                            submesh2[prop], submesh[prop].length / base_length);
	                    break;
	                case "texcoord":
	                    submesh[prop] = array_join_framed_submesh_props(submesh[prop], 
	                            submesh2[prop], submesh["uv_layers"].length);
	                    break;
	                case "color":
	                    submesh[prop] = array_join_framed_submesh_props(submesh[prop], 
	                            submesh2[prop], submesh["vertex_colors"].length);
	                    break;
	                case "uv_layers":
	                case "vertex_colors":
	                    // uv anv vc layer names are the same for all submeshes
	                    break;
	                default:
	                    m_print.warn("array_mesh_join(): unknown submesh property \"" + prop 
	                            + "\"");
	                    submesh[prop] = m_util.float32_concat(submesh[prop], submesh2[prop]);
	                    break;
	                }
	            }
	    }

	    return mesh;
	}

	function array_join_framed_submesh_props(prop0, prop1, part_count) {
	    if (part_count > 1) {
	        var part_len0 = prop0.length / part_count;
	        var part_len1 = prop1.length / part_count;
	        var joined_prop = new Float32Array(prop0.length + prop1.length);
	        var offset = 0;
	        for (var j = 0; j < part_count; j++) {
	            joined_prop.set(prop0.subarray(part_len0 * j, part_len0 * (j + 1)), offset);
	            offset += part_len0;
	            joined_prop.set(prop1.subarray(part_len1 * j, part_len1 * (j + 1)), offset);
	            offset += part_len1;
	        }
	        return joined_prop;
	    } else
	        return m_util.float32_concat(prop0, prop1);
	}

	/**
	 * Transform mesh locations by given matrix
	 */
	function mesh_transform_locations(mesh, matrix) {
	    var mat3 = m_mat3.fromMat4(matrix, _mat3_tmp);
	    var quat = m_quat.fromMat3(mat3, _quat_tmp);

	    for (var i = 0; i < mesh["submeshes"].length; i++) {
	        var submesh = mesh["submeshes"][i];

	        m_util.positions_multiply_matrix(submesh["position"], matrix,
	                submesh["position"], 0);

	        m_tbn.multiply_quat(submesh["tbn"], quat, submesh["tbn"]);
	    }
	}

	/**
	 * Rewrite object params according to Logic script.
	 * Not the best place to do such things, but other methods are much harder to
	 * implement (see update_object())
	 */
	exports.assign_logic_nodes_object_params = function(bpy_objects, bpy_world, scene) {

	    function set_bpy_objs_prop(objects_path, props) {
	        var name = objects_path[0];
	        if (objects_path.length > 1)
	            for (var k = 1; k < objects_path.length; k++)
	                name += "*" + objects_path[k];
	        for (var k = 0; k < bpy_objects.length; k++) {
	            var bpy_obj = bpy_objects[k];
	            if (bpy_obj["name"] == name) {
	                for (var key in props) {
	                    bpy_obj[key] = props[key];
	                }
	            }
	        }
	    }
	    function set_bpy_objs_props(objects_paths, props) {
	        for (var id in objects_paths) {
	            set_bpy_objs_prop(objects_paths[id], props);
	        }
	    }

	    var script = scene["b4w_logic_nodes"];
	    for (var i = 0; i < script.length; i++) {
	        var subtree = script[i];
	        for (var j = 0; j < subtree.length; j++) {
	            var snode = subtree[j];
	            var rename = {
	                "register1":"variable1",
	                "register2":"variable2",
	                "registerd":"variabled"
	            };
	            for (var key in rename) {
	                if (key in snode)
	                    snode[rename[key]] = snode[key];
	            }
	            // add scope for variables
	            for (var v in snode["variables"]) {
	                if (typeof(snode["variables"][v][0]) != "boolean")
	                    snode["variables"][v] = [false, snode["variables"][v]];
	            }
	            if (["MATH", "CONDJUMP", "PAGEPARAM", "REGSTORE"].indexOf(snode["type"]) >= 0) {
	                if ("variable1" in snode)
	                    snode["variables"]["id0"] = [false, snode["variable1"]];
	                if ("variable2" in snode)
	                    snode["variables"]["id1"] = [false, snode["variable2"]];
	                if ("variabled" in snode)
	                    snode["variables"]["vd"] = [false, snode["variabled"]];
	            }

	            for (var l in snode["links"]) {
	                if (!l.startsWith("id"))
	                    delete snode["links"][l];
	            }

	            var cu_names = snode["common_usage_names"];
	            var var_names = snode["variables"];

	            switch (snode["type"]) {
	            case "SELECT":
	                for (var k = 0; k < bpy_objects.length; k++) {
	                    var bpy_obj = bpy_objects[k];
	                    if (bpy_obj["name"] == snode["object"])
	                        bpy_obj["b4w_selectable"] = true;
	                }
	                if (!snode["bools"])
	                    snode["bools"] = {};
	                if (!snode["bools"]["not_wait"])
	                    snode["bools"]["not_wait"] = false;
	                report_raw("Logic nodes type \"SELECT\" is deprecated");
	                break;
	            case "SWITCH_SELECT":
	                set_bpy_objs_props(snode["objects_paths"], {"b4w_selectable": true});
	                if (snode["links"] instanceof Array) {
	                    report_raw("Format of a \"SWITCH_SELECT\" node is outdated. " +
	                    "It is recommended to reexport the scene \"" + scene.name+"\"");
	                    var links = {};
	                    var kk = 0;
	                    for (k in snode["objects_paths"]) {
	                        links[k] = snode["links"][kk];
	                        kk++;
	                    }
	                    snode["links"] = links;
	                }
	                break;
	            case "SELECT_PLAY":
	                report_raw("Logic nodes type \"SELECT_PLAY\" is deprecated, " +
	                "node will be muted. To fix this, reexport the scene \"" + scene.name+"\"");
	                snode["mute"] = true;
	                break;
	            case "SELECT_PLAY_ANIM":
	                report_raw("Logic nodes type \"SELECT_PLAY_ANIM\" is deprecated");
	                break;    
	            case "SHOW":
	            case "HIDE":
	                if (!snode["bools"])
	                    snode["bools"] = {};

	                if (snode["bools"]["ch"] === undefined)
	                    snode["bools"]["ch"] = false;
	                if (!snode.bools["id0"])
	                    set_bpy_objs_props(snode["objects_paths"], {"b4w_do_not_batch": true});
	                break;
	            case "SET_SHADER_NODE_PARAM":
	            case "INHERIT_MAT":
	                set_bpy_objs_props(snode["objects_paths"], {"b4w_do_not_batch": true});
	                break;
	            case "PLAY":
	                scene["b4w_use_nla"] = true;
	                break;
	            case "MOVE_TO":
	                set_bpy_objs_props(snode["objects_paths"], {"b4w_do_not_batch": true});
	                break;
	            case "TRANSFORM_OBJECT":
	                set_bpy_objs_props(snode["objects_paths"], {"b4w_do_not_batch": true});

	                switch(cu_names["space_type"]){
	                case "WORLD":
	                    cu_names["space_type"] = m_logn.NST_WORLD;
	                    break;
	                case "PARENT":
	                    cu_names["space_type"] = m_logn.NST_PARENT;
	                    break;
	                case "LOCAL":
	                    cu_names["space_type"] = m_logn.NST_LOCAL;
	                    break;
	                }
	                break;
	            case "OUTLINE":
	                set_bpy_objs_props(snode["objects_paths"], {"b4w_outlining": true});
	                break;
	            case "CONDJUMP":
	                if (snode["condition"])
	                    cu_names["condition"] = snode["condition"];

	                if ("cnd" in snode["floats"])
	                    cu_names["condition"] = snode["floats"]["cnd"];
	                else {
	                    switch(cu_names["condition"]){
	                    case "GEQUAL":
	                        cu_names["condition"] = m_logn.NC_GEQUAL;
	                        break;
	                    case "LEQUAL":
	                        cu_names["condition"] = m_logn.NC_LEQUAL;
	                        break;
	                    case "GREATER":
	                        cu_names["condition"] = m_logn.NC_GREATER;
	                        break;
	                    case "LESS":
	                        cu_names["condition"] = m_logn.NC_LESS;
	                        break;
	                    case "NOTEQUAL":
	                        cu_names["condition"] = m_logn.NC_NOTEQUAL;
	                        break;
	                    case "EQUAL":
	                        cu_names["condition"] = m_logn.NC_EQUAL;
	                        break;
	                    }
	                }
	                if (snode["number1"] != undefined)
	                    snode["input1"] = snode["number1"];
	                if (snode["number2"] != undefined)
	                    snode["input2"] = snode["number2"];
	                if (!snode["bools"])
	                    snode["bools"] = {};
	                if (snode["bools"]["str"])
	                    cu_names["variable_type"] = "STRING";
	                switch (cu_names["variable_type"]) {
	                case "NUMBER":
	                    cu_names["variable_type"] = m_logn.NT_NUMBER;
	                    break;
	                case "STRING":
	                    cu_names["variable_type"] = m_logn.NT_STRING;
	                    break;
	                case "OBJECT":
	                    cu_names["variable_type"] = m_logn.NT_OBJECT;
	                    break;
	                }

	                if (cu_names["variable_type"] === undefined) {
	                    cu_names["variable_type"] = m_logn.NT_NUMBER;
	                    snode["floats"]["inp1"] = snode["input1"];
	                    snode["floats"]["inp2"] = snode["input2"];
	                }

	                if (var_names["id0"] === undefined) {
	                    var_names["id0"] = var_names["v1"];
	                    var_names["id1"] = var_names["v2"];
	                }
	                break;
	            case "SEND_REQ":
	                if (!snode["bools"])
	                    snode["bools"] = {};
	                if (!snode["strings"])
	                    snode["strings"] = {};

	                if (snode["bools"]["ct"] === undefined)
	                    snode["bools"]["ct"] = false;
	                if (snode["url"] != undefined) {
	                    snode["bools"]["url"] = false;
	                    snode["strings"]["url"] = snode["url"];
	                }

	                break;
	            case "MATH":
	                if (snode["number1"] != undefined)
	                    snode["input1"] = snode["number1"];
	                if (snode["number2"] != undefined)
	                    snode["input2"] = snode["number2"];
	                if (snode["input1"] != undefined)
	                    snode["floats"]["inp1"] = snode["input1"];
	                if (snode["input2"] != undefined)
	                    snode["floats"]["inp2"] = snode["input2"];
	                switch (snode["operation"]) {
	                case "DIV":
	                    snode["operation"] = m_logn.NMO_DIV;
	                    break;
	                case "SUB":
	                    snode["operation"] = m_logn.NMO_SUB;
	                    break;
	                case "MUL":
	                    snode["operation"] = m_logn.NMO_MUL;
	                    break;
	                case "ADD":
	                    snode["operation"] = m_logn.NMO_ADD;
	                    break;
	                case "RAND":
	                    snode["operation"] = m_logn.NMO_RAND;
	                    break;
	                case "SIN":
	                    snode["operation"] = m_logn.NMO_SIN;
	                    break;
	                case "COS":
	                    snode["operation"] = m_logn.NMO_COS;
	                    break;
	                case "TAN":
	                    snode["operation"] = m_logn.NMO_TAN;
	                    break;
	                case "ARCSIN":
	                    snode["operation"] = m_logn.NMO_ARCSIN;
	                    break;
	                case "ARCCOS":
	                    snode["operation"] = m_logn.NMO_ARCCOS;
	                    break;
	                case "ARCTAN":
	                    snode["operation"] = m_logn.NMO_ARCTAN;
	                    break;
	                case "LOG":
	                    snode["operation"] = m_logn.NMO_LOG;
	                    break;
	                case "MIN":
	                    snode["operation"] = m_logn.NMO_MIN;
	                    break;
	                case "MAX":
	                    snode["operation"] = m_logn.NMO_MAX;
	                    break;
	                case "ROUND":
	                    snode["operation"] = m_logn.NMO_ROUND;
	                    break;
	                case "MOD":
	                    snode["operation"] = m_logn.NMO_MOD;
	                    break;
	                case "ABS":
	                    snode["operation"] = m_logn.NMO_ABS;
	                    break;
	                }
	                if (var_names["id0"] === undefined) {
	                    var_names["id0"] = var_names["v1"];
	                    var_names["id1"] = var_names["v2"];
	                }
	                break;
	            case "REGSTORE":
	                if (!snode["floats"])
	                        snode["floats"] = {};
	                if (!snode["strings"])
	                        snode["strings"] = {};

	                if (snode["number1"] != undefined)
	                    snode["input1"] = snode["number1"];
	                if (snode["input1"] != undefined)
	                    switch (typeof(snode["input1"])) {
	                    case "number":
	                        snode["floats"]["inp1"] = snode["input1"];
	                        cu_names["variable_type"] = "NUMBER";
	                        break;
	                    default:
	                        snode["strings"]["inp1"] = snode["input1"];
	                        cu_names["variable_type"] = "STRING";
	                    }

	                switch(cu_names["variable_type"]) {
	                case "NUMBER":
	                    cu_names["variable_type"] = m_logn.NT_NUMBER;
	                    break;
	                case "STRING":
	                    cu_names["variable_type"] = m_logn.NT_STRING;
	                    break;
	                case "OBJECT":
	                    cu_names["variable_type"] = m_logn.NT_OBJECT;
	                    set_bpy_objs_props(snode["objects_paths"], {"b4w_do_not_batch": true});
	                    break;
	                }

	                break;
	            case "PAGEPARAM":
	                if (!snode["bools"])
	                    snode["bools"] = {};
	                if (snode["bools"]["hsh"] === undefined)
	                    snode["bools"]["hsh"] = false;

	                if (!snode["floats"])
	                    snode["floats"] = {};
	                if (snode["floats"]["ptp"] === undefined)
	                    snode["floats"]["ptp"] = 0;
	                break;
	            case "STOP_ANIM":
	            case "PLAY_ANIM":
	                if (!snode["bools"])
	                    snode["bools"] = {};
	                if (snode["bools"]["env"] === undefined)
	                    snode["bools"]["env"] = false;
	                if (snode["bools"]["id0"] === undefined)
	                    snode["bools"]["id0"] = false;
	                if (!snode["bools"]["id0"])
	                    set_bpy_objs_prop(snode["objects_paths"]["id0"], {"b4w_do_not_batch": true});

	                if (snode["type"] == "PLAY_ANIM") {
	                    var behavior = cu_names["param_anim_behavior"];
	                    if(!behavior)
	                        behavior = "FINISH_STOP";
	                    cu_names["param_anim_behavior"] = m_anim.anim_behavior_bpy_b4w(behavior);
	                }
	                break;
	            case "STRING":
	                switch(cu_names["string_operation"]){
	                case "JOIN":
	                    cu_names["string_operation"] = m_logn.NSO_JOIN;
	                    break;
	                case "FIND":
	                    cu_names["string_operation"] = m_logn.NSO_FIND;
	                    break;
	                case "REPLACE":
	                    cu_names["string_operation"] = m_logn.NSO_REPLACE;
	                    break;
	                case "SPLIT":
	                    cu_names["string_operation"] = m_logn.NSO_SPLIT;
	                    break;
	                case "COMPARE":
	                    cu_names["string_operation"] = m_logn.NSO_COMPARE;
	                    break;
	                }

	                if ("cnd" in snode["floats"])
	                    cu_names["condition"] = snode["floats"]["cnd"];
	                else {
	                    switch(cu_names["condition"]){
	                    case "GEQUAL":
	                        cu_names["condition"] = m_logn.NC_GEQUAL;
	                        break;
	                    case "LEQUAL":
	                        cu_names["condition"] = m_logn.NC_LEQUAL;
	                        break;
	                    case "GREATER":
	                        cu_names["condition"] = m_logn.NC_GREATER;
	                        break;
	                    case "LESS":
	                        cu_names["condition"] = m_logn.NC_LESS;
	                        break;
	                    case "NOTEQUAL":
	                        cu_names["condition"] = m_logn.NC_NOTEQUAL;
	                        break;
	                    case "EQUAL":
	                        cu_names["condition"] = m_logn.NC_EQUAL;
	                        break;
	                    }
	                }

	                break;
	            case "REDIRECT":
	                if (snode["url"] != undefined) {
	                    snode["bools"]["url"] = false;
	                    snode["strings"]["url"] = snode["url"];
	                }
	                break;
	            case "SET_CAMERA_MOVE_STYLE":
	                switch(cu_names["camera_move_style"]){
	                case "STATIC":
	                    cu_names["camera_move_style"] = m_logn.NCMS_STATIC;
	                    break;
	                case "TARGET":
	                    cu_names["camera_move_style"] = m_logn.NCMS_TARGET;
	                    break;
	                case "EYE":
	                    cu_names["camera_move_style"] = m_logn.NCMS_EYE;
	                    break;
	                case "HOVER":
	                    cu_names["camera_move_style"] = m_logn.NCMS_HOVER;
	                    break;
	                }
	                break;
	            case "ENTRYPOINT":
	                if (!snode["bools"])
	                    snode["bools"] = {};
	                if (snode["bools"]["js"] === undefined)
	                    snode["bools"]["js"] = false;

	                if (snode["bools"]["js"])
	                    snode["mute"] = true;
	                break;
	            case "JS_CALLBACK":
	                var cb_params_dict = cu_names["js_cb_params"];
	                for (var key in cb_params_dict)
	                    switch(cb_params_dict[key]) {
	                        case "OBJECT":
	                            cb_params_dict[key] = m_logn.NCPT_OBJECT;
	                            break;
	                        case "VARIABLE":
	                            cb_params_dict[key] = m_logn.NCPT_VARIABLE;
	                            break;
	                    }
	                break;
	            }
	        }
	    }
	};

	}

	var int_reformer_factory = register("__reformer", Int_reformer);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Animation internal API.
	 * @name animation
	 * @namespace
	 * @exports exports as animation
	 */
	function Int_animation(ns, exports) {

	var m_armat     = int_armature_factory(ns);
	var m_cfg       = int_config_factory(ns);
	var m_lights    = int_lights_factory(ns);
	var m_obj_util  = int_obj_util_factory(ns);
	var m_particles = int_particles_factory(ns);
	var m_phy       = int_physics_factory(ns);
	var m_print     = print_factory(ns);
	var m_quat      = quat_factory(ns);
	var m_reformer  = int_reformer_factory(ns);
	var m_scs       = int_scenes_factory(ns);
	var m_sfx       = int_sfx_factory(ns);
	var m_subs      = int_subscene_factory(ns);
	var m_time      = int_time_factory(ns);
	var m_trans     = int_transform_factory(ns);
	var m_tsr       = int_tsr_factory(ns);
	var m_util      = int_util_factory(ns);
	var m_vec3      = vec3_factory(ns);

	var cfg_ani = m_cfg.animation;
	var cfg_lim = m_cfg.context_limits;

	var LAST_FRAME_EPSILON = 0.000001;

	exports.LAST_FRAME_EPSILON = LAST_FRAME_EPSILON;

	var OBJ_ANIM_TYPE_NONE        =  0;
	var OBJ_ANIM_TYPE_ARMATURE    = 10;
	var OBJ_ANIM_TYPE_OBJECT      = 20;
	var OBJ_ANIM_TYPE_VERTEX      = 30;
	var OBJ_ANIM_TYPE_SOUND       = 40;
	var OBJ_ANIM_TYPE_PARTICLES   = 50;
	var OBJ_ANIM_TYPE_MATERIAL    = 60;
	var OBJ_ANIM_TYPE_LIGHT       = 70;
	var OBJ_ANIM_TYPE_ENVIRONMENT = 80;

	exports.OBJ_ANIM_TYPE_NONE        = OBJ_ANIM_TYPE_NONE;
	exports.OBJ_ANIM_TYPE_ARMATURE    = OBJ_ANIM_TYPE_ARMATURE;
	exports.OBJ_ANIM_TYPE_OBJECT      = OBJ_ANIM_TYPE_OBJECT;
	exports.OBJ_ANIM_TYPE_VERTEX      = OBJ_ANIM_TYPE_VERTEX;
	exports.OBJ_ANIM_TYPE_SOUND       = OBJ_ANIM_TYPE_SOUND;
	exports.OBJ_ANIM_TYPE_PARTICLES   = OBJ_ANIM_TYPE_PARTICLES;
	exports.OBJ_ANIM_TYPE_MATERIAL    = OBJ_ANIM_TYPE_MATERIAL;
	exports.OBJ_ANIM_TYPE_LIGHT       = OBJ_ANIM_TYPE_LIGHT;
	exports.OBJ_ANIM_TYPE_ENVIRONMENT = OBJ_ANIM_TYPE_ENVIRONMENT;

	var SLOT_0   = 0;
	var SLOT_1   = 1;
	var SLOT_2   = 2;
	var SLOT_3   = 3;
	var SLOT_4   = 4;
	var SLOT_5   = 5;
	var SLOT_6   = 6;
	var SLOT_7   = 7;
	var SLOT_ALL = -1;

	exports.SLOT_0   = SLOT_0;
	exports.SLOT_1   = SLOT_1;
	exports.SLOT_2   = SLOT_2;
	exports.SLOT_3   = SLOT_3;
	exports.SLOT_4   = SLOT_4;
	exports.SLOT_5   = SLOT_5;
	exports.SLOT_6   = SLOT_6;
	exports.SLOT_7   = SLOT_7;
	exports.SLOT_ALL = SLOT_ALL;

	// values specified in exporter
	var KF_INTERP_BEZIER = 0;
	var KF_INTERP_LINEAR = 1;
	var KF_INTERP_CONSTANT = 2;

	// animation behavior
	var AB_CYCLIC = 10;
	var AB_FINISH_RESET = 20;
	var AB_FINISH_STOP = 30;

	var VECTORS_RESERVED = 50;

	exports.AB_CYCLIC = AB_CYCLIC;
	exports.AB_FINISH_RESET = AB_FINISH_RESET;
	exports.AB_FINISH_STOP = AB_FINISH_STOP;

	//action environment mask elements
	var AEM_ENERGY          = 0;
	var AEM_HORIZON_COLOR   = 1;
	var AEM_ZENITH_COLOR    = 2;
	var AEM_FOG_INTENSITY   = 3;
	var AEM_FOG_DEPTH       = 4;
	var AEM_FOG_START       = 5;
	var AEM_FOG_HEIGHT      = 6;
	var AEM_FOG_COLOR       = 7;

	var _frame_info_tmp = new Array(3);
	var _vec3_tmp = new Float32Array(3);
	var _vec3_tmp2 = new Float32Array(3);
	var _vec4_tmp = new Float32Array(4);
	var _vec4_tmp2 = new Float32Array(4);
	var _vec4_tmp3 = new Float32Array(4);
	var _vec4_tmp4 = new Float32Array(4);
	var _quat4_tmp = new Float32Array(4);
	var _quat4_tmp2 = new Float32Array(4);
	var _quat4_tmp3 = new Float32Array(4);
	var _quat4_tmp4 = new Float32Array(4);
	var _tsr_tmp = m_tsr.create();
	var _tsr_tmp2 = m_tsr.create();

	// populated after init_anim()
	var _anim_objs_cache = [];
	var _actions = [];

	exports.get_max_bones = function() {
	    return m_util.trunc((cfg_lim.max_vertex_uniform_vectors - VECTORS_RESERVED) / 4);
	};

	exports.frame_to_sec = function(frame) {
	    return frame/m_time.get_framerate();
	};

	function create_action_render() {
	    var render = {
	        type: OBJ_ANIM_TYPE_NONE,
	        num_pierced: 0,
	        pierce_step: 0,

	        params: null,
	        bones: null,
	        bflags: null,
	        
	        channels_mask: new Int8Array(8)
	    };
	    return render;
	}

	/**
	 * Called every frame
	 */
	exports.update = function(elapsed) {
	    for (var i = 0; i < _anim_objs_cache.length; i++) {
	        var obj = _anim_objs_cache[i];

	        //TODO: need to sort slots properly (psys "set_time" issue)
	        for (var j = 0; j < 8; j++)
	            animate(obj, elapsed, j);

	        if (obj.render.anim_mixing) {
	            process_mix_factor(obj, elapsed);
	            mix_skeletal_animation(obj, elapsed);
	        }
	    }

	    // exec finish callbacks after animation updates to eliminate
	    // possible race conditions
	    for (var i = 0; i < _anim_objs_cache.length; i++) {
	        var obj = _anim_objs_cache[i];
	        for (var j = 0; j < 8; j++) {
	            // NOTE: anim_slots may be cleared in some of finish callbacks
	            if (!obj.anim_slots.length)
	                break;
	            handle_finish_callback(obj, j);
	        }
	    }
	};

	function handle_finish_callback(obj, slot_num) {
	    var anim_slot = obj.anim_slots[slot_num];

	    if (!anim_slot)
	        return;

	    if (anim_slot.finish_callback && anim_slot.exec_finish_callback) {
	        anim_slot.exec_finish_callback = false;
	        anim_slot.finish_callback(obj, slot_num);
	    }
	}

	exports.get_all_actions = function() {
	    return _actions;
	};

	function apply_vertex_anim(obj, va, slot_num) {

	    var anim_slot = obj.anim_slots[slot_num];

	    anim_slot.type = OBJ_ANIM_TYPE_VERTEX;

	    var start = va.frame_start;
	    // last frame will be rendered
	    var length = va.frame_end - start + 1;
	    anim_slot.start = start;
	    anim_slot.length = length;
	    anim_slot.current_frame_float = start;

	    anim_slot.animation_name = va.name;

	    // calculate VBO offset for given vertex animation
	    var va_frame_offset = 0;
	    for (var i = 0; i < obj.vertex_anim.length; i++) {
	        var va_i = obj.vertex_anim[i];

	        if (va_i == va)
	            break;
	        else
	            va_frame_offset += (va_i.frame_end - va_i.frame_start + 1);
	    }

	    anim_slot.va_frame_offset = va_frame_offset;
	}

	function apply_particles_anim(batch, anim_slot, pdata) {
	    anim_slot.type = OBJ_ANIM_TYPE_PARTICLES;
	    anim_slot.animation_name = pdata.name;

	    anim_slot.start  = pdata.frame_start;
	    anim_slot.length = pdata.frame_end - anim_slot.start;

	    if (!pdata.cyclic)
	        anim_slot.length += pdata.lifetime_frames;
	}

	function apply_obj_particles_anim(obj, psys_name, slot_num) {
	    var scenes_data = obj.scenes_data;
	    for (var i = 0; i < scenes_data.length; i++) {
	        var batches = scenes_data[i].batches;
	        for (var j = 0; j < batches.length; j++) {
	            var pdata = batches[j].particles_data;

	            if (!pdata || pdata.name != psys_name)
	                continue;

	            var anim_slot = obj.anim_slots[slot_num];
	            apply_particles_anim(batches[j], anim_slot, pdata);
	        }
	    }
	}

	function init_anim(obj, slot_num) {

	    var anim_slot = {
	        type: null,
	        animation_name: null,

	        action_frame_range: null,
	        action_step: 0,
	        action_bflags: null,
	        channels_mask: new Int8Array(8),

	        quats: null,
	        trans: null,

	        bone_space_quats: null,
	        bone_space_trans: null,

	        skinning_data: [],

	        play: false,
	        behavior: AB_FINISH_RESET,

	        // cff = 0-length
	        current_frame_float: 0,
	        start: 0,
	        length: 0,

	        trans_smooth_period: 0,
	        quat_smooth_period: 0,

	        exec_finish_callback: false,

	        va_frame_offset: null,
	        speed: 1,

	        volume: null,
	        pitch: null,

	        color: null,
	        energy: null,

	        zenith_color: null,
	        horizon_color: null,
	        fog_intensity: null,
	        fog_depth: null,
	        fog_start: null,
	        fog_height: null,
	        fog_color: null,

	        nodemat_values: [],
	        node_value_inds: [],

	        nodemat_rgbs: [],
	        node_rgb_inds: [],

	        node_batches: null
	    };

	    if (!obj.anim_slots.length)
	        for (var i = 0; i < 8; i++)
	            obj.anim_slots.push(null);

	    obj.anim_slots[slot_num] = anim_slot;
	}

	function update_anim_cache(obj) {
	    if (_anim_objs_cache.indexOf(obj) == -1)
	        _anim_objs_cache.push(obj);
	}

	exports.get_anim_names = function(obj) {
	    var anim_names = [];

	    if (has_vertex_anim(obj)) {
	        for (var i = 0; i < obj.vertex_anim.length; i++)
	            anim_names.push(obj.vertex_anim[i].name);
	    }

	    var actions = get_actions(obj);
	    for (var i = 0; i < actions.length; i++) {
	        anim_names.push(strip_baked_suffix(actions[i]["name"]));
	    }

	    if (m_particles.obj_has_particles(obj) && m_particles.obj_has_anim_particles(obj)) {
	        var scenes_data = obj.scenes_data;
	        for (var i = 0; i < scenes_data.length; i++) {
	            var batches = scenes_data[i].batches;
	            for (var j = 0; j < batches.length; j++) {
	                var pdata = batches[j].particles_data;
	                if (pdata)
	                    anim_names.push(pdata.name);
	            }
	        }
	    }

	    return anim_names;
	};

	exports.strip_baked_suffix = strip_baked_suffix;
	function strip_baked_suffix(name) {
	    return name.replace(/_B4W_BAKED$/, "");
	}

	exports.get_anim_type = function(obj, slot_num) {
	    var anim_slot = obj.anim_slots[slot_num];
	    if (anim_slot)
	        return anim_slot.type;

	    return OBJ_ANIM_TYPE_NONE;
	};

	/**
	 * Search for possible object animations init and apply one of each type
	 * (object, vertex, armature, etc...)
	 */
	exports.apply_def = function(obj) {
	    var slot_num = SLOT_0;

	    var scenes_data = obj.scenes_data;
	    for (var i = 0; i < scenes_data.length; i++) {
	        var batches = scenes_data[i].batches;
	        for (var j = 0; j < batches.length; j++) {
	            var pdata = batches[j].particles_data;
	            if (pdata && pdata.p_type == "EMITTER" && !batches[j].forked_batch) {
	                do_before_apply(obj, slot_num);
	                apply_particles_anim(batches[j], obj.anim_slots[slot_num], pdata);
	                do_after_apply(obj, slot_num);

	                if (pdata.cyclic)
	                    obj.anim_slots[slot_num].behavior = AB_CYCLIC;
	                else
	                    obj.anim_slots[slot_num].behavior = obj.anim_behavior_def;

	                slot_num++;
	            }
	        }
	    }

	    var action_slots = get_default_actions(obj);
	    for (var i = 0; i < action_slots.length; i++) {
	        var act_slot = action_slots[i];
	        var name_list = act_slot.name_list;
	        var action = act_slot.action;

	        do_before_apply(obj, slot_num);
	        if (apply_action(obj, name_list, action, slot_num)) {
	            do_after_apply(obj, slot_num);
	            obj.anim_slots[slot_num].behavior = obj.anim_behavior_def;
	            slot_num++;
	        } else
	            obj.anim_slots[slot_num] = null;
	    }

	    if (has_vertex_anim(obj)) {
	        do_before_apply(obj, slot_num);
	        apply_vertex_anim(obj, obj.vertex_anim[0], slot_num);
	        do_after_apply(obj, slot_num);
	        obj.anim_slots[slot_num].behavior = obj.anim_behavior_def;
	        slot_num++;
	    }
	};

	exports.anim_behavior_bpy_b4w = function(behavior) {
	    switch (behavior) {
	    case "CYCLIC":
	        return AB_CYCLIC;
	    case "FINISH_RESET":
	        return AB_FINISH_RESET;
	    case "FINISH_STOP":
	        return AB_FINISH_STOP;
	    default:
	        m_util.panic("Wrong animation behavior");
	    }
	};

	/**
	 * Returns object specific actions
	 */
	function get_actions(obj) {

	    var act_list = [];

	    for (var i = 0; i < _actions.length; i++) {
	        var action = _actions[i];
	        var act_render = action._render;

	        if (act_render.type == OBJ_ANIM_TYPE_OBJECT)
	            act_list.push(action);
	        else if (action._render.type == OBJ_ANIM_TYPE_MATERIAL && (obj.type == "MESH" || obj.type == "WORLD"))
	            act_list.push(action);
	        else if (act_render.type == OBJ_ANIM_TYPE_ARMATURE && obj.type == "ARMATURE")
	            act_list.push(action);
	        else if (act_render.type == OBJ_ANIM_TYPE_SOUND && obj.type == "SPEAKER")
	            act_list.push(action);
	        else if (act_render.type == OBJ_ANIM_TYPE_ENVIRONMENT && obj.type == "WORLD")
	            act_list.push(action);
	    }

	    return act_list;
	}

	/**
	 * Default actions were collected at the loading stage from the following places:
	 *  obj.animation_data.action
	 *  spkobj.data.animation_data
	 *  obj.data.materials.node_tree.animation_data
	 */
	function get_default_actions(obj) {
	    return obj.def_action_slots.slice();
	}

	exports.get_bpy_material_actions = function(bpy_obj) {
	    var act_list = [];

	    var materials = bpy_obj["data"]["materials"];
	    for (var i = 0; i < materials.length; i++) {
	        var mat = materials[i];
	        var node_tree = mat.node_tree;

	        if (node_tree)
	            get_node_tree_actions_r(node_tree, act_list, [mat.name]);
	    }
	    return act_list;
	};

	exports.get_bpy_world_material_actions = get_bpy_world_material_actions;
	function get_bpy_world_material_actions(bpy_obj) {
	    var act_list = [];

	    var node_tree = bpy_obj["node_tree"];

	    if (node_tree)
	        get_node_tree_actions_r(node_tree, act_list, [bpy_obj["name"]]);

	    return act_list;
	}

	exports.init_action_slot = init_action_slot;
	function init_action_slot(name_list, action) {
	    return {
	        name_list: name_list,
	        action: action
	    }
	}

	function get_node_tree_actions_r(node_tree, container, name_list) {
	    if (node_tree["animation_data"]) {
	        var anim_data = node_tree["animation_data"];
	        var action = anim_data["action"];
	        if (action && action._render.type == OBJ_ANIM_TYPE_MATERIAL)
	            container.push(init_action_slot(name_list, action));
	    }

	    var nodes = node_tree["nodes"];
	    for (var i = 0; i < nodes.length; i++) {
	        var node = nodes[i];
	        if (node["node_group"]) {
	            var g_node_tree = node["node_group"]["node_tree"];
	            if (g_node_tree) {
	                var new_name_list = name_list.slice();
	                new_name_list.push(node["name"]);
	                get_node_tree_actions_r(g_node_tree, container, new_name_list);
	            }
	        }
	    }
	}

	function has_vertex_anim(obj) {
	    if (m_obj_util.is_mesh(obj) && obj.render.vertex_anim)
	        return true;
	    else
	        return false;
	}

	/**
	 * Start to play preset animation
	 * offset in seconds
	 */
	exports.play = function(obj, finish_callback, slot_num) {
	    function play_slot(anim_slot) {
	        anim_slot.play = true;

	        if (finish_callback)
	            anim_slot.finish_callback = finish_callback;
	        else
	            anim_slot.finish_callback = null;

	        anim_slot.exec_finish_callback = false;
	    }
	    process_anim_slots(obj.anim_slots, slot_num, play_slot);

	    if (obj.render.anim_mixing)
	        sync_skeletal_animations(obj);
	};

	/**
	 * Stop object animation
	 */
	exports.stop = function(obj, slot_num) {
	    function stop_slot(anim_slot) {
	        anim_slot.play = false;
	        anim_slot.finish_callback = null;
	        anim_slot.exec_finish_callback = false;
	    }
	    process_anim_slots(obj.anim_slots, slot_num, stop_slot);
	};

	exports.is_play = function(obj, slot_num) {
	    var anim_slots = obj.anim_slots;
	    if (slot_num == SLOT_ALL) {
	        for (var i = 0; i < 8; i++) {
	            if(anim_slots[i])
	                if(anim_slots[i].play)
	                    return true;
	        }
	    } else {
	        var anim_slot = anim_slots[slot_num];
	        if (anim_slot)
	            return anim_slot.play;
	    }
	    return false;
	};

	/**
	 * Set frame and update animation.
	 */
	exports.set_frame = set_frame;
	function set_frame(obj, cff, slot_num) {
	    var anim_slots = obj.anim_slots;
	    if (slot_num == SLOT_ALL) {
	        for (var i = 0; i < 8; i++) {
	            var anim_slot = anim_slots[i];
	            if (anim_slot) {
	                anim_slot.current_frame_float = cff;
	                update_object_animation(obj, 0, i, true);
	            }
	        }
	    } else {
	        var anim_slot = anim_slots[slot_num];
	        if (anim_slot) {
	            anim_slot.current_frame_float = cff;
	            update_object_animation(obj, 0, slot_num, true);
	        }
	    }
	}
	exports.set_first_frame = set_first_frame;
	function set_first_frame (obj, slot_num) {
	    function set_slot_first_frame(slot) {
	        set_frame(obj, slot.start, slot_num);
	    }
	    slot_num = slot_num || SLOT_0;
	    process_anim_slots(obj.anim_slots, slot_num, set_slot_first_frame);
	}

	exports.get_current_frame_float = function(obj, slot_num) {
	    var anim_slot = obj.anim_slots[slot_num];
	    if (anim_slot && anim_slot.current_frame_float)
	        return anim_slot.current_frame_float;
	    else
	        return 0.0;
	};

	exports.is_cyclic = function(obj, slot_num) {
	    var anim_slot = obj.anim_slots[slot_num];
	    return anim_slot && anim_slot.behavior == AB_CYCLIC;
	};

	exports.set_behavior = function(obj, behavior, slot_num) {
	    function set_slot_behavior(anim_slot) {
	        anim_slot.behavior = behavior;
	    }
	    process_anim_slots(obj.anim_slots, slot_num, set_slot_behavior);
	};

	exports.get_behavior = function(obj, slot_num) {
	    var anim_slot = obj.anim_slots[slot_num];
	    return anim_slot && anim_slot.behavior;
	};

	exports.apply_smoothing = function(obj, trans_period, quat_period, slot_num) {
	    function apply_slot_smoothing(anim_slot) {
	        anim_slot.trans_smooth_period = trans_period || 0;
	        anim_slot.quat_smooth_period = quat_period || 0;
	    }
	    process_anim_slots(obj.anim_slots, slot_num, apply_slot_smoothing);
	};

	exports.remove_slot_animation = function(obj, slot_num) {
	    if (slot_num == SLOT_ALL)
	        for (var i = 0; i < 8; i++)
	            obj.anim_slots[i] = null;
	    else
	        obj.anim_slots[slot_num] = null;

	    if (obj.render.anim_mixing)
	        recalculate_armature_anim_slots(obj, slot_num);
	};


	function process_anim_slots(anim_slots, slot_num, procedure) {
	    if (slot_num == SLOT_ALL)
	        for (var i = 0; i < 8; i++) {
	            var anim_slot = anim_slots[i];
	            if (anim_slot)
	                procedure(anim_slot);
	        }
	    else {
	        var anim_slot = anim_slots[slot_num];
	        if (anim_slot)
	            procedure(anim_slot);
	    }
	}

	/**
	 * Update object animation (set object pose)
	 */
	exports.update_object_animation = update_object_animation;
	function update_object_animation(obj, elapsed, slot_num, force_update) {
	    animate(obj, elapsed, slot_num, force_update);
	    handle_finish_callback(obj, slot_num);

	    if (obj.render.anim_mixing) {
	        process_mix_factor(obj, elapsed);
	        mix_skeletal_animation(obj, elapsed);
	    }
	}

	/**
	 * <p>Check if animation possible
	 * <p>animation is possible, if one of the following conditions is met:
	 * <ol>
	 * <li>obj is an armature
	 * <li>obj has a link to an armature
	 * <li>obj has an object or armature action
	 * <li>obj is a speaker with param animation
	 * <li>obj is a mesh with nodemat animation
	 * <li>obj has particle system
	 * <li>obj has vertex animation
	 * <li>obj is world
	 * </ol>
	 */
	exports.obj_is_animatable = function(obj) {
	    if (obj.type == "ARMATURE")
	        return true;

	    if (obj.armobj)
	        return true;

	    if (obj.type == "WORLD")
	        return true;

	    for (var i = 0; i < obj.def_action_slots.length; i++) {
	        var act_slot = obj.def_action_slots[i];
	        var act_type = act_slot.action._render.type;
	        if (act_type == OBJ_ANIM_TYPE_OBJECT || act_type == OBJ_ANIM_TYPE_ARMATURE
	                || act_type == OBJ_ANIM_TYPE_SOUND && obj.type == "SPEAKER"
	                || act_type == OBJ_ANIM_TYPE_LIGHT && obj.type == "LAMP"
	                || act_type == OBJ_ANIM_TYPE_MATERIAL && obj.type == "MESH")
	            return true;
	    }

	    if (m_particles.obj_has_particles(obj) && m_particles.obj_has_anim_particles(obj))
	        return true;

	    if (obj.type == "MESH" && obj.vertex_anim.length)
	        return true;

	    return false;
	};

	exports.bpy_mesh_empty_is_animatable = function(bpy_obj) {

	    var armobj = get_bpy_armobj(bpy_obj);
	    if (armobj)
	        return true;

	    if (bpy_obj._def_action_slots)
	        for (var i = 0; i < bpy_obj._def_action_slots.length; i++) {
	            var act_slot = bpy_obj._def_action_slots[i];
	            var action = act_slot.action;
	            var act_type = action._render.type;

	            if (act_type == OBJ_ANIM_TYPE_OBJECT || 
	                    act_type == OBJ_ANIM_TYPE_MATERIAL && bpy_obj["type"] == "MESH")
	                return true;
	        }

	    if (m_particles.bpy_obj_has_particles(bpy_obj) 
	            && m_particles.bpy_obj_has_anim_particles(bpy_obj))
	        return true;

	    if (bpy_obj["type"] == "MESH" && bpy_obj["data"]["b4w_vertex_anim"].length)
	        return true;

	    return false;
	};

	exports.is_animated = is_animated;
	function is_animated(obj) {
	    return Boolean(obj.anim_slots.length);
	}

	/**
	 * Init action cache
	 */
	exports.init_action_cache = init_action_cache;
	function init_action_cache(obj, name_list, uuid, name, slot_num) {

	    if (uuid)
	        var action = m_util.keysearch("uuid", uuid, _actions);
	    else {
	        var action = m_util.keysearch("name", name, _actions) ||
	        m_util.keysearch("name", name + "_B4W_BAKED", _actions);
	    }

	    if (!action)
	        return;

	    init_anim(obj, slot_num);
	    update_anim_cache(obj);

	    var frame_range = action["frame_range"];

	    if (frame_range[0] > frame_range[1]) {
	        m_print.warn("Incompatible action \"" + action["name"] +
	                "\" has been applied to object \"" + obj.name + "\"");
	        return false;
	    }

	    var act_render = action._render;

	    switch (act_render.type) {
	    case OBJ_ANIM_TYPE_ARMATURE:
	        if (m_obj_util.is_armature(obj)) {
	            var pose_data_frames = get_cached_anim_data(obj, name_list, action);
	            if (!pose_data_frames) {
	                pose_data_frames = calc_pose_data_frames(action,
	                                                    obj.render.bone_pointers);
	                cache_anim_data(obj, name_list, action, pose_data_frames);
	            }
	            init_skinned_objs_data(obj, slot_num, action, pose_data_frames);
	        }
	        break;
	    case OBJ_ANIM_TYPE_OBJECT:
	        var tsr = act_render.params["tsr"];
	        if (tsr) {
	            var obj_anim_data = get_cached_anim_data(obj, name_list, action);
	            if (!obj_anim_data) {
	                obj_anim_data = calc_obj_anim_data(obj, action, tsr);
	                cache_anim_data(obj, name_list, action, obj_anim_data);
	            }
	        } else {
	            m_print.warn("Incompatible action \"" + action["name"] +
	                    "\" has been applied to object \"" + obj.name + "\"");
	            return false;
	        }
	        break;
	    }
	}

	/**
	 * Calculate object animation data:
	 * quats, trans for each bone (group) index and pierced point
	 * save them to obj.anim_slots
	 */
	function apply_action(obj, name_list, action, slot_num) {

	    var frame_range = action["frame_range"];

	    if (frame_range[0] > frame_range[1]) {
	        m_print.warn("Incompatible action \"" + action["name"] + 
	                "\" has been applied to object \"" + obj.name + "\"");
	        return false;
	    }

	    var act_render = action._render;

	    var anim_slot = obj.anim_slots[slot_num];

	    anim_slot.animation_name = action["name"];
	    anim_slot.action_frame_range = frame_range;
	    anim_slot.action_step = act_render.pierce_step;
	    anim_slot.action_bflags = act_render.bflags;
	    anim_slot.channels_mask.set(act_render.channels_mask);

	    anim_slot.start = frame_range[0];
	    anim_slot.length = frame_range[1] - frame_range[0];
	    anim_slot.current_frame_float = frame_range[0];

	    switch (act_render.type) {
	    case OBJ_ANIM_TYPE_ARMATURE:
	        if (m_obj_util.is_armature(obj)) {
	            anim_slot.type = OBJ_ANIM_TYPE_ARMATURE;

	            var pose_data_frames = get_cached_anim_data(obj, name_list, action);
	            if (!pose_data_frames) {
	                pose_data_frames = calc_pose_data_frames(action,
	                                                    obj.render.bone_pointers);
	                cache_anim_data(obj, name_list, action, pose_data_frames);
	            }

	            anim_slot.trans = pose_data_frames.trans;
	            anim_slot.quats = pose_data_frames.quats;
	            anim_slot.bone_space_quats = pose_data_frames.bone_space_quats;
	            anim_slot.bone_space_trans = pose_data_frames.bone_space_trans;

	            init_skinned_objs_data(obj, slot_num, action, pose_data_frames);
	        }
	        break;

	    case OBJ_ANIM_TYPE_SOUND:
	        if (m_obj_util.is_speaker(obj)) {
	            anim_slot.volume = act_render.params["volume"] || null;
	            anim_slot.pitch = act_render.params["pitch"] || null;
	            anim_slot.type = OBJ_ANIM_TYPE_SOUND;
	        }
	        break;

	    case OBJ_ANIM_TYPE_LIGHT:
	        if (m_obj_util.is_lamp(obj)) {
	            anim_slot.color = act_render.params["color"] || null;
	            anim_slot.energy = act_render.params["energy"] || null;
	            anim_slot.type = OBJ_ANIM_TYPE_LIGHT;
	        }
	        break;

	    case OBJ_ANIM_TYPE_MATERIAL:
	        if (obj.type == "MESH" || obj.type == "WORLD") {
	            anim_slot.type = OBJ_ANIM_TYPE_MATERIAL;

	            var is_world_action = m_obj_util.is_world(obj);

	            var nodemat_anim_data = calc_nodemat_anim_data(obj, name_list, action, is_world_action);

	            anim_slot.node_value_inds = nodemat_anim_data.val_inds;
	            anim_slot.nodemat_values = nodemat_anim_data.values;
	            anim_slot.node_rgb_inds = nodemat_anim_data.rgb_inds;
	            anim_slot.nodemat_rgbs = nodemat_anim_data.rgbs;

	            anim_slot.node_batches = nodemat_anim_data.node_batches;
	        }
	        break;

	    case OBJ_ANIM_TYPE_OBJECT:
	        var tsr = act_render.params["tsr"];
	        if (tsr) {

	            anim_slot.type = OBJ_ANIM_TYPE_OBJECT;

	            var obj_anim_data = get_cached_anim_data(obj, name_list, action);
	            if (!obj_anim_data) {
	                obj_anim_data = calc_obj_anim_data(obj, action, tsr);
	                cache_anim_data(obj, name_list, action, obj_anim_data);
	            }

	            anim_slot.trans = obj_anim_data.trans;
	            anim_slot.quats = obj_anim_data.quats;

	            // move particles with world coordinate system to objects position
	            if (m_particles.obj_has_particles(obj)) {
	                var trans = anim_slot.trans[0];
	                var quats = anim_slot.quats[0];
	                m_particles.update_start_pos(obj, trans, quats);
	            }
	        } else {
	            m_print.warn("Incompatible action \"" + action["name"] + 
	                    "\" has been applied to object \"" + obj.name + "\"");
	            return false;
	        }
	        break;
	    case OBJ_ANIM_TYPE_ENVIRONMENT:
	        //check meta_object WORLD
	        if (m_obj_util.is_world(obj)) {
	            anim_slot.energy = act_render.params["light_settings.environment_energy"] || null;
	            anim_slot.horizon_color = act_render.params["horizon_color"] || null;
	            anim_slot.zenith_color = act_render.params["zenith_color"] || null;
	            anim_slot.fog_intensity = act_render.params["mist_settings.intensity"] || null;
	            anim_slot.fog_depth = act_render.params["mist_settings.depth"] || null;
	            anim_slot.fog_start = act_render.params["mist_settings.start"] || null;
	            anim_slot.fog_height = act_render.params["mist_settings.height"] || null;
	            anim_slot.fog_color = act_render.params["b4w_fog_color"] || null;
	            anim_slot.type = OBJ_ANIM_TYPE_ENVIRONMENT;
	        }
	        break;
	    }

	    if (m_obj_util.is_armature(obj) && act_render.type != OBJ_ANIM_TYPE_ARMATURE)
	        recalculate_armature_anim_slots(obj, slot_num);
	    return true;
	}

	function get_cached_anim_data(obj, name_list, action) {

	    var cache = obj.action_anim_cache;
	    if (name_list)
	        var names_str = name_list.join("%join%");
	    else
	        var names_str = null;

	    for (var i = 0; i < cache.length; i+=3)
	        if (action == cache[i] && names_str == cache[i+1])
	            return cache[i+2];

	    return null;
	}

	exports.delete_cached_anim_data_by_mat = delete_cached_anim_data_by_mat;
	function delete_cached_anim_data_by_mat(obj, mat_name) {
	    var cache = obj.action_anim_cache;
	    var cache_filtered = [];

	    for (var i = 0; i < cache.length; i += 3) {

	        if (cache[i]._render.type == OBJ_ANIM_TYPE_MATERIAL)
	            if (cache[i + 1] === null || cache[i + 1].split("%join%")[0] == mat_name)
	                continue;

	        cache_filtered.push(cache[i], cache[i + 1], cache[i + 2]);
	    }
	    
	    obj.action_anim_cache = cache_filtered;
	}

	function cache_anim_data(obj, name_list, action, data) {
	    var cache = obj.action_anim_cache;
	    if (name_list)
	        var names_str = name_list.join("%join%");
	    else
	        var names_str = null;
	    cache.push(action, names_str, data);
	}

	function init_skinned_objs_data(armobj, slot_num, action,
	                                armobj_pose_data_frames) {

	    var render = armobj.render;
	    var skinned_renders = render.skinned_renders;

	    var anim_slot = armobj.anim_slots[slot_num];
	    var skinning_data = anim_slot.skinning_data;

	    var skinning_data_cache = get_cached_skinning_data(render, action);

	    if (!skinning_data_cache) {
	        for (var i = 0; i < skinned_renders.length; i++) {
	            var sk_rend = skinned_renders[i];
	            var pose_data_frames = calc_skinned_pose_data_frames(
	                                armobj_pose_data_frames, sk_rend.bone_skinning_info);
	            skinning_data.push(pose_data_frames);
	        }
	        cache_skinning_data(render, action, skinning_data);
	    } else
	        anim_slot.skinning_data = skinning_data_cache;

	    if (render.anim_mixing) {
	        var skeletal_slots = render.blend_skel_slots;
	        if (slot_num > skeletal_slots[1]) {
	            var tmp = skeletal_slots[1];
	            skeletal_slots[1] = slot_num;
	            skeletal_slots[0] = tmp;
	        } else if (slot_num > skeletal_slots[0] && slot_num < skeletal_slots[1])
	            skeletal_slots[0] = slot_num;

	        sync_skeletal_animations(armobj);
	    }
	}

	function get_cached_skinning_data(render, action) {
	    var cache = render.skinning_data_cache;

	    for (var i = 0; i < cache.length; i+=2)
	        if (action == cache[i])
	            return cache[i+1];

	    return null;
	}

	function cache_skinning_data(render, action, skinning_data) {
	    var cache = render.skinning_data_cache;
	    cache.push(action, skinning_data);
	}

	function sync_skeletal_animations(armobj) {

	    var skeletal_slots = armobj.render.blend_skel_slots;

	    // one or none skeletal animation applied
	    if (skeletal_slots[0] == -1 || skeletal_slots[1] == -1)
	        return;

	    // last skeletal animation slot determines frame allignment
	    var last_skel_slot = skeletal_slots[1];

	    var anim_slots = armobj.anim_slots;
	    var last_skel_anim = anim_slots[last_skel_slot];

	    var cff = last_skel_anim.current_frame_float;
	    var cff_int = Math.floor(cff);
	    var frame_factor = cff - cff_int;

	    var prev_skel_slot = skeletal_slots[0];
	    var prev_skel_anim = anim_slots[prev_skel_slot];
	    cff = prev_skel_anim.current_frame_float;
	    cff_int = Math.floor(cff);

	    prev_skel_anim.current_frame_float = cff_int + frame_factor;
	}

	function recalculate_armature_anim_slots(obj, overriden_slot) {

	    var skeletal_slots = obj.render.blend_skel_slots;

	    var last_skel_slot = skeletal_slots[1];

	    skeletal_slots[0] = -1;
	    skeletal_slots[1] = -1;

	    if (overriden_slot == SLOT_ALL)
	        return;

	    var anim_slots = obj.anim_slots;
	    for (var i = last_skel_slot; i >= SLOT_0; i--) {

	        var anim_slot = anim_slots[i];

	        if (anim_slot && anim_slot.type == OBJ_ANIM_TYPE_ARMATURE) {
	            if (i > skeletal_slots[1]) {
	                skeletal_slots[1] = i;
	                continue;
	            } else if (i > skeletal_slots[0])
	                skeletal_slots[1] = i;

	            // two slots have been assigned
	            break;
	        }
	    }
	}

	/**
	 * Find constraint with type and target pointing to armature obj
	 * NOTE: unused
	 */
	function node_name_from_param_name(param_name, name_list) {
	    // extract text between first "[" and "]" which is exactly a node name
	    var node_name = param_name.match(/"(.*?)"/ )[1];

	    if (name_list && name_list.length > 1) {
	        var full_name = name_list[1];
	        for (var i = 2; i < name_list.length; i++)
	            full_name = full_name + "%join%" + name_list[i];
	        full_name += "%join%" + node_name;
	    } else
	        var full_name = node_name;

	    return full_name;
	}

	function calc_nodemat_anim_data(obj, name_list, action, is_world_action) {

	    var val_inds = [];
	    var values = [];
	    var rgb_inds = [];
	    var rgbs = [];
	    var node_batches = [];

	    var act_render = action._render;
	    var mat_name = name_list? name_list[0]: null;

	    for (var param_name in act_render.params) {
	        var node_name = node_name_from_param_name(param_name, name_list);
	        for (var i = 0; i < obj.scenes_data.length; i++) {
	            var batches = obj.scenes_data[i].batches;
	            for (var j = 0; j < batches.length; j++) {
	                var batch = batches[j];

	                // if mat name is not specified, process all suitable materials
	                if (!is_world_action)
	                    if (mat_name && batch.material_names.indexOf(mat_name) == -1)
	                        continue;

	                var val_ind_pairs = batch.node_value_inds;
	                var rgb_ind_pairs = batch.node_rgb_inds;

	                var found_vals =
	                    calc_node_act_value(param_name, node_name, act_render,
	                                  values, val_inds, val_ind_pairs);
	                var found_rgbs =
	                    calc_node_act_rgb(param_name, node_name, act_render,
	                                  rgbs, rgb_inds, rgb_ind_pairs);

	                if (found_vals || found_rgbs)
	                    node_batches.push(batch);
	            }
	        }
	    }

	    return {val_inds: val_inds, values: values,
	            rgb_inds: rgb_inds, rgbs: rgbs,
	            node_batches: node_batches};
	}

	function calc_node_act_rgb(param_name, node_name, act_render, values, inds,
	                       val_ind_pairs) {
	    if (!val_ind_pairs)
	        return false;

	    var found_vals = false;
	    for (var i = 0; i < val_ind_pairs.length; i+=2) {
	        var name = val_ind_pairs[i];
	        if (node_name == name) {
	            var ind = val_ind_pairs[i+1];
	            inds.push(ind);
	            values.push(new Float32Array(act_render.params[param_name]));
	            found_vals = true;
	        }
	    }
	    return found_vals;
	}

	function calc_node_act_value(param_name, node_name, act_render, values, inds,
	                       val_ind_pairs) {
	    if (!val_ind_pairs)
	        return false;

	    var found_vals = false;
	    for (var i = 0; i < val_ind_pairs.length; i+=3) {
	        var name = val_ind_pairs[i];
	        if (node_name == name) {
	            inds.push(val_ind_pairs[i+1] * 4 + val_ind_pairs[i+2]);
	            values.push(new Float32Array(act_render.params[param_name]));
	            found_vals = true;
	        }
	    }
	    return found_vals;
	}


	function calc_obj_anim_data(obj, action, tsr) {

	    var act_render = action._render;

	    // TODO: clarify length/frame_range/num_pierced
	    var num_pierced = act_render.num_pierced;

	    var anim_trans = [];
	    var anim_quats = [];
	    for (var i = 0; i < num_pierced; i++) {
	        anim_trans.push(tsr.subarray(i*8, i*8 + 4));
	        anim_quats.push(tsr.subarray(i*8 + 4, i*8 + 8));
	    }
	    return {trans: anim_trans, quats: anim_quats};
	}

	function animate(obj, elapsed, slot_num, force_update) {
	    var anim_slot = obj.anim_slots[slot_num];

	    if (!anim_slot || anim_slot.type == null)
	        return;

	    // update paused animation only if elapsed == 0
	    if (!anim_slot.play && !force_update)
	        return

	    var render = obj.render;

	    var cff = anim_slot.current_frame_float;
	    var start = anim_slot.start;
	    var length = anim_slot.length;

	    cff += anim_slot.speed * elapsed * m_time.get_framerate();

	    var anim_type = anim_slot.type;
	    var speed = anim_slot.speed;

	    if ((speed >= 0 && cff >= start + length) ||
	        (speed < 0 && cff < start)) {
	        if (!force_update)
	            anim_slot.exec_finish_callback = true;
	        switch (anim_slot.behavior) {
	        case AB_CYCLIC:
	            if (speed >= 0)
	                cff = (cff - start) % length + start;
	            else
	                cff = start + length - LAST_FRAME_EPSILON;
	            break;
	        case AB_FINISH_RESET:
	            if (speed >= 0)
	                cff = start;
	            else
	                cff = start + length - LAST_FRAME_EPSILON;
	            anim_slot.play = false;
	            break;
	        case AB_FINISH_STOP:
	            if (speed >= 0)
	                cff = start + length - LAST_FRAME_EPSILON;
	            else
	                cff = start;
	            anim_slot.play = false;
	            break;
	        }
	    }
	    anim_slot.current_frame_float = cff;

	    switch (anim_type) {
	    case OBJ_ANIM_TYPE_ARMATURE:
	        // NOTE: skeletal animation blending is being processed after animate()
	        if (!render.anim_mixing) {

	            var finfo = action_anim_finfo(anim_slot);

	            var frame = finfo[0];
	            var frame_next = finfo[1];
	            var frame_factor = finfo[2];

	            render.quats_before = anim_slot.quats[frame];
	            render.quats_after  = anim_slot.quats[frame_next];
	            render.trans_before = anim_slot.trans[frame];
	            render.trans_after  = anim_slot.trans[frame_next];

	            render.frame_factor = frame_factor;

	            animate_skinned_objs(render, anim_slot, frame, frame_next);
	            m_trans.update_transform(obj);
	        }
	        break;

	    case OBJ_ANIM_TYPE_OBJECT:
	        var finfo = action_anim_finfo(anim_slot);

	        var trans = get_anim_translation(anim_slot, 0, finfo, _vec3_tmp);
	        var quat = get_anim_rotation(anim_slot, 0, finfo, _quat4_tmp);
	        var scale = get_anim_scale(anim_slot, 0, finfo);
	        if (obj.parent && obj.pinverse_tsr) {
	            var tsr = _tsr_tmp;
	            m_tsr.set_sep(trans, scale, quat, tsr);
	            m_tsr.multiply(obj.pinverse_tsr, tsr, tsr);
	            m_tsr.get_trans(tsr, trans);
	            m_tsr.get_quat(tsr, quat);
	            scale = m_tsr.get_scale(tsr);
	        }

	        if (anim_slot.trans_smooth_period) {
	            var trans_old = _vec3_tmp2;
	            m_trans.get_translation(obj, trans_old);
	            m_util.smooth_v(trans, trans_old, elapsed,
	                    anim_slot.trans_smooth_period, trans);
	        }

	        if (anim_slot.quat_smooth_period) {
	            var quat_old = _quat4_tmp2;
	            m_trans.get_rotation(obj, quat_old);
	            m_util.smooth_q(quat, quat_old, elapsed,
	                    anim_slot.quat_smooth_period, quat);
	        }

	        var mask = anim_slot.channels_mask;

	        if (mask[0])
	            m_trans.set_translation_rel(obj, trans);
	        if (mask[1])
	            m_trans.set_rotation_rel(obj, quat);
	        if (mask[2])
	            m_trans.set_scale_rel(obj, scale);

	        m_trans.update_transform(obj);
	        m_phy.sync_transform(obj);
	        break;

	    case OBJ_ANIM_TYPE_VERTEX:
	        var finfo = vertex_anim_finfo(anim_slot);

	        render.va_frame = finfo[0];
	        render.va_frame_factor = finfo[2];
	        break;

	    case OBJ_ANIM_TYPE_SOUND:
	        var finfo = action_anim_finfo(anim_slot);
	        var fc = finfo[0];
	        var fn = finfo[1];
	        var ff = finfo[2];

	        if (anim_slot.volume) {
	            var volume = (1-ff) * anim_slot.volume[fc] + ff * anim_slot.volume[fn];
	            m_sfx.set_volume(obj, volume);
	        }

	        if (anim_slot.pitch) {
	            var pitch = (1-ff) * anim_slot.pitch[fc] + ff * anim_slot.pitch[fn];
	            m_sfx.playrate(obj, pitch);
	        }
	        break;

	    case OBJ_ANIM_TYPE_PARTICLES:
	        if (anim_slot.behavior == AB_CYCLIC)
	            var time = (cff - start) / m_time.get_framerate();
	        else
	            var time = cff / m_time.get_framerate();
	        m_particles.set_time(obj, anim_slot.animation_name, time);
	        break;

	    case OBJ_ANIM_TYPE_MATERIAL:
	        var finfo = action_anim_finfo(anim_slot);
	        var fc = finfo[0];
	        var fn = finfo[1];
	        var ff = finfo[2];

	        var values = anim_slot.nodemat_values;
	        var val_indices = anim_slot.node_value_inds;

	        var rgbs = anim_slot.nodemat_rgbs;
	        var rgb_indices = anim_slot.node_rgb_inds;
	        var node_batches = anim_slot.node_batches;

	        for (var i = 0; i < val_indices.length; i++) {
	            var vals = values[i];
	            var ind = val_indices[i];

	            var nodemat_value = (1-ff) * vals[fc] + ff * vals[fn];
	            for (var j = 0; j < node_batches.length; j++)
	                node_batches[j].node_values[ind] = nodemat_value;
	        }
	        for (var i = 0; i < rgb_indices.length; i++) {
	            var rgb = rgbs[i];
	            var ind = rgb_indices[i];

	            // TODO: replace subarray
	            var prev = rgb.subarray(fc*3, fc*3 + 3);
	            var next = rgb.subarray(fn*3, fn*3 + 3);
	            var curr = m_vec3.lerp(prev, next, ff, _vec3_tmp);
	            for (var j = 0; j < node_batches.length; j++) {
	                node_batches[j].node_rgbs[3 * ind] = curr[0];
	                node_batches[j].node_rgbs[3 * ind + 1] = curr[1];
	                node_batches[j].node_rgbs[3 * ind + 2] = curr[2];
	            }
	        }

	        // force sky redrawing
	        if (m_obj_util.is_world(obj))
	            m_scs.update_sky_texture(obj);

	        break;

	    case OBJ_ANIM_TYPE_LIGHT:
	        var finfo = action_anim_finfo(anim_slot);
	        var fc = finfo[0];
	        var fn = finfo[1];
	        var ff = finfo[2];

	        var mask = anim_slot.channels_mask;

	        var energy = anim_slot.energy;
	        if (energy && mask[0]) {
	            var en = (1-ff) * energy[fc] + ff * energy[fn];
	            m_lights.set_light_energy(obj.light, en);
	        }

	        var color = anim_slot.color;
	        if (color && mask[1]) {
	            _vec3_tmp[0] = (1-ff) * color[3 * fc]     + ff * color[3 * fn];
	            _vec3_tmp[1] = (1-ff) * color[3 * fc + 1] + ff * color[3 * fn + 1];
	            _vec3_tmp[2] = (1-ff) * color[3 * fc + 2] + ff * color[3 * fn + 2];
	            m_lights.set_light_color(obj.light, _vec3_tmp);
	        }

	        var scenes_data = obj.scenes_data;
	        for (var i = 0; i < scenes_data.length; i++)
	            m_scs.update_lamp_scene_color_intensity(obj, scenes_data[i].scene);

	        break;

	    case OBJ_ANIM_TYPE_ENVIRONMENT:
	        var finfo = action_anim_finfo(anim_slot);
	        var fc = finfo[0];
	        var fn = finfo[1];
	        var ff = finfo[2];

	        var mask = anim_slot.channels_mask;

	        var scenes_data = obj.scenes_data;

	        var subs = m_scs.get_subs(scenes_data[0].scene, m_subs.MAIN_OPAQUE);

	        var energy = anim_slot.energy;
	        if (mask[AEM_ENERGY]) {
	            var energy_value = (1-ff) * energy[fc] + ff * energy[fn];
	        }
	        else {
	            var energy_value = subs.energy;
	        }

	        var horizon_color = anim_slot.horizon_color;
	        if (mask[AEM_HORIZON_COLOR]) {
	            _vec3_tmp[0] = (1-ff) * horizon_color[3 * fc]     + ff * horizon_color[3 * fn];
	            _vec3_tmp[1] = (1-ff) * horizon_color[3 * fc + 1] + ff * horizon_color[3 * fn + 1];
	            _vec3_tmp[2] = (1-ff) * horizon_color[3 * fc + 2] + ff * horizon_color[3 * fn + 2];
	            var horizon_color_value = _vec3_tmp;
	        }
	        else {
	            var horizon_color_value = subs.horizon_color;
	        }

	        var zenith_color = anim_slot.zenith_color;
	        if (mask[AEM_ZENITH_COLOR]) {
	            _vec3_tmp2[0] = (1-ff) * zenith_color[3 * fc]     + ff * zenith_color[3 * fn];
	            _vec3_tmp2[1] = (1-ff) * zenith_color[3 * fc + 1] + ff * zenith_color[3 * fn + 1];
	            _vec3_tmp2[2] = (1-ff) * zenith_color[3 * fc + 2] + ff * zenith_color[3 * fn + 2];
	            var zenith_color_value = _vec3_tmp2;
	        }
	        else{
	            var zenith_color_value = subs.zenith_color;
	        }

	        var fog_intensity = anim_slot.fog_intensity;
	        if (mask[AEM_FOG_INTENSITY]) {
	            var fog_intensity_value = (1-ff) * fog_intensity[fc] + ff * fog_intensity[fn];
	        }

	        var fog_depth = anim_slot.fog_depth;
	        if (mask[AEM_FOG_DEPTH]) {
	            var fog_depth_value = (1-ff) * fog_depth[fc] + ff * fog_depth[fn];
	        }

	        var fog_start = anim_slot.fog_start;
	        if (mask[AEM_FOG_START]) {
	            var fog_start_value = (1-ff) * fog_start[fc] + ff * fog_start[fn];
	        }

	        var fog_height = anim_slot.fog_height;
	        if (mask[AEM_FOG_HEIGHT]) {
	            var fog_height_value = (1-ff) * fog_height[fc] + ff * fog_height[fn];
	        }

	        var fog_color = anim_slot.fog_color;
	        if (mask[AEM_FOG_COLOR]) {
	            _quat4_tmp[0] = (1-ff) * fog_color[3 * fc]     + ff * fog_color[3 * fn];
	            _quat4_tmp[1] = (1-ff) * fog_color[3 * fc + 1] + ff * fog_color[3 * fn + 1];
	            _quat4_tmp[2] = (1-ff) * fog_color[3 * fc + 2] + ff * fog_color[3 * fn + 2];
	            var fog_color_value = _quat4_tmp;
	        }

	        for (var i = 0; i < scenes_data.length; i++) {
	            var scene = obj.scenes_data[i].scene;

	            if (mask[AEM_ENERGY] || mask[AEM_HORIZON_COLOR] || mask[AEM_ZENITH_COLOR])
	                m_scs.set_environment_colors(scene, energy_value, horizon_color_value, zenith_color_value);
	            if (mask[AEM_FOG_INTENSITY])
	                m_scs.set_fog_intensity(scene, fog_intensity_value);
	            if (mask[AEM_FOG_DEPTH])
	                m_scs.set_fog_depth(scene, fog_depth_value);
	            if (mask[AEM_FOG_START])
	                m_scs.set_fog_start(scene, fog_start_value);
	            if (mask[AEM_FOG_HEIGHT])
	                m_scs.set_fog_height(scene, fog_height_value);
	            if (mask[AEM_FOG_COLOR])
	                m_scs.set_fog_color_density(scene, fog_color_value);
	        }

	        break;

	    default:
	        m_util.panic("Unknown animation type:" + anim_type);
	        break;
	    }
	}

	/**
	 * Calculate integer frame, frame_next and float frame_factor
	 */
	function action_anim_finfo(anim_slot) {
	    var cff = anim_slot.current_frame_float;
	    var action_start = anim_slot.action_frame_range[0];
	    var action_end = anim_slot.action_frame_range[1];

	    var range = action_end - action_start;

	    // index in fcurve' pierced points array
	    var index_float = cff - action_start;

	    if (index_float < 0)
	        index_float = 0;
	    if (index_float >= range)
	        index_float = range;

	    var step = anim_slot.action_step;
	    index_float /= step;

	    var frame = Math.floor(index_float);

	    // NOTE: get from first group
	    if (anim_slot.action_bflags[frame])
	        var frame_factor = index_float - frame;
	    else
	        var frame_factor = 0;

	    var frame_next = Math.ceil(frame + frame_factor);

	    _frame_info_tmp[0] = frame;
	    _frame_info_tmp[1] = frame_next;
	    _frame_info_tmp[2] = frame_factor;

	    return _frame_info_tmp;
	}

	/**
	 * Calculate integer frame, frame_next and float frame_factor
	 */
	function vertex_anim_finfo(anim_slot) {
	    var cff = anim_slot.current_frame_float;
	    // index in VBO array, starting from 0
	    var index_float = cff - anim_slot.start;

	    if (index_float < 0)
	        index_float = 0;
	    if (index_float >= anim_slot.length)
	        index_float = anim_slot.length;

	    var frame = Math.floor(index_float);
	    var frame_next = frame + 1;
	    var frame_factor = index_float - frame;

	    // handle last frame for non-cyclic animation
	    // for cyclic animation we have last frame equal to first one
	    // see extract_submesh()
	    if (anim_slot.behavior != AB_CYCLIC && frame_next == anim_slot.length) {
	        frame = frame-1;
	        frame_next = frame;
	        frame_factor = 1.0;
	    }

	    // take into account previous vertex anims
	    var va_frame_offset = anim_slot.va_frame_offset;

	    _frame_info_tmp[0] = frame + va_frame_offset;
	    _frame_info_tmp[1] = frame_next + va_frame_offset;
	    _frame_info_tmp[2] = frame_factor;

	    return _frame_info_tmp;
	}

	function animate_skinned_objs(render, anim_slot, frame, frame_next) {
	    // update skinned objects
	    var skinned_renders = render.skinned_renders;
	    var skinning_data = anim_slot.skinning_data;
	    for (var i = 0; i < skinned_renders.length; i++) {
	        var skinned_render = skinned_renders[i];
	        var sk_data = skinning_data[i];
	        skinned_render.quats_before = sk_data.quats[frame];
	        skinned_render.quats_after  = sk_data.quats[frame_next];
	        skinned_render.trans_before = sk_data.trans[frame];
	        skinned_render.trans_after  = sk_data.trans[frame_next];
	        skinned_render.frame_factor = render.frame_factor;
	    }
	}

	/**
	 * Mix two last skeletal animations based on mix_factor
	 */
	function mix_skeletal_animation(obj, elapsed) {
	    var render = obj.render;
	    var mix_factor = render.anim_mix_factor;

	    var skeletal_slots = render.blend_skel_slots;

	    var ind_0 = skeletal_slots[0];
	    var ind_1 = skeletal_slots[1];

	    // no skeletal anim assigned to armature
	    if (ind_1 == -1)
	        return;

	    if (ind_0 != -1) {
	        // penult anim
	        var skeletal_slot_0 = obj.anim_slots[ind_0];

	        if (skeletal_slot_0.play || elapsed == 0 || render.mix_with_current) {

	            var finfo_0 = action_anim_finfo(skeletal_slot_0);

	            var frame_0 = finfo_0[0];
	            var frame_next_0 = finfo_0[1];
	            render.frame_factor = finfo_0[2];

	            var quats_prev_0 = skeletal_slot_0.quats[frame_0];
	            var quats_next_0 = skeletal_slot_0.quats[frame_next_0];
	            var trans_prev_0 = skeletal_slot_0.trans[frame_0];
	            var trans_next_0 = skeletal_slot_0.trans[frame_next_0];
	        } else
	            mix_factor = 1;
	    } else
	        mix_factor = 1;

	    // last anim
	    var skeletal_slot_1 = obj.anim_slots[ind_1];

	    if (skeletal_slot_1.play || elapsed == 0 || render.mix_with_current) {

	        var finfo_1 = action_anim_finfo(skeletal_slot_1);

	        var frame_1 = finfo_1[0];
	        var frame_next_1 = finfo_1[1];

	        // frame_factor is common for two animations as they are synced when applied
	        render.frame_factor = finfo_1[2];
	    } else if (ind_0 != -1 && skeletal_slot_0.play) {
	        mix_factor = 0;
	    } else {
	        return;
	    }

	    var quats_prev_1 = skeletal_slot_1.quats[frame_1];
	    var quats_next_1 = skeletal_slot_1.quats[frame_next_1];
	    var trans_prev_1 = skeletal_slot_1.trans[frame_1];
	    var trans_next_1 = skeletal_slot_1.trans[frame_next_1];
	    if (mix_factor == 1 && !render.mix_with_current) {
	        render.quats_before.set(quats_prev_1);
	        render.quats_after.set(quats_next_1);
	        render.trans_before.set(trans_prev_1);
	        render.trans_after.set(trans_next_1);
	    } else if (mix_factor == 0 && !render.mix_with_current) {
	        render.quats_before.set(quats_prev_0);
	        render.quats_after.set(quats_next_0);
	        render.trans_before.set(trans_prev_0);
	        render.trans_after.set(trans_next_0);
	    } else {
	        var bone_pointers = render.bone_pointers;
	        if (render.mix_with_current && !render.trans_curr && !render.quats_curr) {
	            render.trans_curr = new Float32Array(render.trans_before.length);
	            render.quats_curr = new Float32Array(render.quats_before.length);
	            for (var bone_name in bone_pointers) {
	                var bone_pointer = bone_pointers[bone_name];
	                if (!bone_pointer.parent_bone_ptr)
	                    check_mix_with_current(render, bone_pointer);
	            }
	        }
	        for (var bone_name in bone_pointers) {
	            var bone_pointer = bone_pointers[bone_name];
	            if (!bone_pointer.parent_bone_ptr)
	                blend_two_anim(render, bone_pointer, skeletal_slot_0, skeletal_slot_1,
	                        frame_0, frame_next_0, frame_1, frame_next_1);
	        }
	    }
	    m_trans.update_transform(obj);
	    m_armat.update_skinned_renders(obj);
	}

	function blend_two_anim(render, bone_pointer, slot_0, slot_1, frame_0, frame_next_0,
	        frame_1, frame_next_1) {
	    var parent_bone_ptr = bone_pointer.parent_bone_ptr;
	    var mix_factor = render.anim_mix_factor;

	    var quat1_frame = _quat4_tmp;
	    var quat2_frame = _quat4_tmp2;

	    var trans1_frame = _vec4_tmp;
	    var trans2_frame = _vec4_tmp2;

	    var quat1_frame_n = _quat4_tmp3;
	    var quat2_frame_n = _quat4_tmp4;

	    var trans1_frame_n = _vec4_tmp3;
	    var trans2_frame_n = _vec4_tmp4;

	    var i = bone_pointer.bone_index * 4;

	    var b_sp_quats1_frame = slot_1.bone_space_quats[frame_1];
	    var b_sp_trans1_frame = slot_1.bone_space_trans[frame_1];

	    var b_sp_quats1_frame_n = slot_1.bone_space_quats[frame_next_1];
	    var b_sp_trans1_frame_n = slot_1.bone_space_trans[frame_next_1];

	    if (!render.mix_with_current) {
	        var b_sp_quats0_frame = slot_0.bone_space_quats[frame_0];    
	        var b_sp_trans0_frame = slot_0.bone_space_trans[frame_0];

	        var b_sp_quats0_frame_n = slot_0.bone_space_quats[frame_next_0];
	        var b_sp_trans0_frame_n = slot_0.bone_space_trans[frame_next_0];
	    }
	    // init quats_before and after
	    for (var j = 0; j < 4; j++) {
	        quat2_frame[j] = b_sp_quats1_frame[i + j];
	        trans2_frame[j] = b_sp_trans1_frame[i + j];

	        quat2_frame_n[j] = b_sp_quats1_frame_n[i + j];
	        trans2_frame_n[j] = b_sp_trans1_frame_n[i + j];

	        if (render.mix_with_current) {
	            quat1_frame[j] = render.quats_curr[i + j];
	            trans1_frame[j] = render.trans_curr[i + j];

	            quat1_frame_n[j] = render.quats_curr[i + j];
	            trans1_frame_n[j] = render.trans_curr[i + j];
	        } else {
	            quat1_frame[j] = b_sp_quats0_frame[i + j];
	            trans1_frame[j] = b_sp_trans0_frame[i + j];

	            quat1_frame_n[j] = b_sp_quats0_frame_n[i + j];
	            trans1_frame_n[j] = b_sp_trans0_frame_n[i + j];
	        }
	    }
	    // before
	    m_quat.slerp(quat1_frame, quat2_frame, mix_factor, quat1_frame);
	    m_util.blend_arrays(trans1_frame, trans2_frame, mix_factor, trans1_frame);

	    m_tsr.set_transcale(trans1_frame, _tsr_tmp);
	    m_tsr.set_quat(quat1_frame, _tsr_tmp);
	    if (parent_bone_ptr)
	        m_tsr.multiply(parent_bone_ptr.tsr_local_pose_b, _tsr_tmp, _tsr_tmp);
	    m_tsr.copy(_tsr_tmp, bone_pointer.tsr_local_pose_b);
	    m_tsr.multiply(_tsr_tmp, bone_pointer.tsr_local_rest_i, _tsr_tmp);

	    m_tsr.get_transcale(_tsr_tmp, trans1_frame);
	    m_tsr.get_quat(_tsr_tmp, quat1_frame);


	    // after
	    m_quat.slerp(quat1_frame_n, quat2_frame_n, mix_factor, quat1_frame_n);
	    m_util.blend_arrays(trans1_frame_n, trans2_frame_n, mix_factor, trans1_frame_n);

	    m_tsr.set_transcale(trans1_frame_n, _tsr_tmp);
	    m_tsr.set_quat(quat1_frame_n, _tsr_tmp);
	    if (parent_bone_ptr)
	        m_tsr.multiply(parent_bone_ptr.tsr_local_pose_a, _tsr_tmp, _tsr_tmp);
	    m_tsr.copy(_tsr_tmp, bone_pointer.tsr_local_pose_a);
	    m_tsr.multiply(_tsr_tmp, bone_pointer.tsr_local_rest_i, _tsr_tmp);

	    m_tsr.get_transcale(_tsr_tmp, trans1_frame_n);
	    m_tsr.get_quat(_tsr_tmp, quat1_frame_n);

	    for (var j = 0; j < 4; j++) {
	        render.quats_before[i + j] = quat1_frame[j];
	        render.trans_before[i + j] = trans1_frame[j];
	        render.quats_after[i + j] = quat1_frame_n[j];
	        render.trans_after[i + j] = trans1_frame_n[j];
	    }

	    var descend_bones_ptrs = bone_pointer.descend_bones_ptrs;
	    for (var j = 0; j < descend_bones_ptrs.length; j++) {
	        var child_bone_pointer = descend_bones_ptrs[j];
	        blend_two_anim(render, child_bone_pointer, slot_0, slot_1, frame_0, frame_next_0,
	            frame_1, frame_next_1);
	    }
	}

	function check_mix_with_current(render, bone_pointer) {
	    var i = bone_pointer.bone_index * 4;
	    var parent_bone_ptr = bone_pointer.parent_bone_ptr;
	    var mix_factor = render.anim_mix_factor;

	    var trans_frame_0 = _vec4_tmp;
	    var quat_frame_0 = _quat4_tmp;

	    var trans_frame_1 = _vec4_tmp2;
	    var quat_frame_1 = _quat4_tmp2;

	    for (var j = 0; j < 4; j++) {
	        trans_frame_0[j] = render.trans_before[i + j];
	        quat_frame_0[j] = render.quats_before[i + j];
	        trans_frame_1[j] = render.trans_after[i + j];
	        quat_frame_1[j] = render.quats_after[i + j];
	    }
	    // before
	    m_tsr.set_transcale(trans_frame_0, _tsr_tmp);
	    m_tsr.set_quat(quat_frame_0, _tsr_tmp);

	    m_tsr.multiply(_tsr_tmp, bone_pointer.tsr_local_rest, _tsr_tmp);
	    m_tsr.copy(_tsr_tmp, bone_pointer.tsr_local_pose_b);
	    if (parent_bone_ptr) {
	        m_tsr.invert(parent_bone_ptr.tsr_local_pose_b, _tsr_tmp2);
	        m_tsr.multiply(_tsr_tmp2, _tsr_tmp, _tsr_tmp);
	    }
	    m_tsr.get_transcale(_tsr_tmp, trans_frame_0);
	    m_tsr.get_quat(_tsr_tmp, quat_frame_0);


	    // after
	    m_tsr.set_transcale(trans_frame_1, _tsr_tmp);
	    m_tsr.set_quat(quat_frame_1, _tsr_tmp);

	    m_tsr.multiply(_tsr_tmp, bone_pointer.tsr_local_rest, _tsr_tmp);
	    m_tsr.copy(_tsr_tmp, bone_pointer.tsr_local_pose_a);
	    if (parent_bone_ptr) {
	        m_tsr.invert(parent_bone_ptr.tsr_local_pose_a, _tsr_tmp2);
	        m_tsr.multiply(_tsr_tmp2, _tsr_tmp, _tsr_tmp);
	    }
	    m_tsr.get_transcale(_tsr_tmp, trans_frame_1);
	    m_tsr.get_quat(_tsr_tmp, quat_frame_1);

	    m_quat.slerp(quat_frame_0, quat_frame_1, mix_factor, quat_frame_0);
	    m_util.blend_arrays(trans_frame_0, trans_frame_1, mix_factor, trans_frame_0);

	    for (var j = 0; j < 4; j++) {
	        render.quats_curr[i + j] = quat_frame_0[j];
	        render.trans_curr[i + j] = trans_frame_0[j];

	    }
	    var descend_bones_ptrs = bone_pointer.descend_bones_ptrs;
	    for (var j = 0; j < descend_bones_ptrs.length; j++) {
	        var child_bone_pointer = descend_bones_ptrs[j];
	        check_mix_with_current(render, child_bone_pointer);
	    }
	}

	function process_mix_factor(obj, elapsed) {

	    var render = obj.render;
	    var cur_mix_factor = render.anim_mix_factor;

	    var speed = render.anim_mix_factor_change_speed;
	    if (speed == 0)
	        return;

	    if (render.mix_with_current && !render.trans_curr && !render.quats_curr)
	        cur_mix_factor = render.anim_mix_factor = 0.0;

	    var dest_mix_factor = render.anim_destination_mix_factor;

	    var delta = dest_mix_factor - cur_mix_factor;
	    var increment = speed * elapsed;

	    if (m_util.sign(delta) == m_util.sign(speed) // still need changes
	            && Math.abs(increment) < Math.abs(delta))
	        render.anim_mix_factor += increment;
	    else {
	        render.anim_mix_factor = render.anim_destination_mix_factor;
	        render.anim_mix_factor_change_speed = 0;
	        if (render.anim_mix_cb) {
	            render.anim_mix_cb();
	            render.anim_mix_cb = null;
	        }
	        if (render.mix_with_current) {
	            render.trans_curr = null;
	            render.quats_curr = null;
	            render.mix_with_current = false;
	        }
	    }
	}

	/**
	 * Calculate skeletal animation data (i.e. pose) for every "pierced" frame
	 * using prepared in action curves
	 */
	function calc_pose_data_frames(action, bone_pointers) {
	    var trans_frames = [];
	    var quats_frames = [];
	    var bone_space_trans_frames = [];
	    var bone_space_quats_frames = [];

	    // for every pierced frame setup pose and calc pose data
	    var num_pierced = action._render.num_pierced;
	    for (var i = 0; i < num_pierced; i++) {
	        // for every pose bone set its matrix_basis
	        for (var bone_name in bone_pointers) {
	            var bpointer = bone_pointers[bone_name];
	            var tsr_basis = bpointer.tsr_basis;

	            // retrieve transform for this pierced point
	            var bone_tsr = action._render.bones[bone_name];
	            if (bone_tsr)
	                m_tsr.copy(bone_tsr.subarray(i*8, i*8 + 8), tsr_basis);
	            else
	                // provide identity tsr for bones not deformed in this action
	                m_tsr.identity(tsr_basis);

	            // reset cache state (for calc_pose_bone)
	            bpointer.tsr_channel_cache_valid = false;
	        }

	        var pose_data = calc_pose_data(bone_pointers);

	        trans_frames.push(pose_data.trans);
	        quats_frames.push(pose_data.quats);
	        bone_space_trans_frames.push(pose_data.bone_space_trans);
	        bone_space_quats_frames.push(pose_data.bone_space_quats);
	    }

	    return {trans: trans_frames, quats: quats_frames,
	        bone_space_trans:bone_space_trans_frames, bone_space_quats:bone_space_quats_frames};
	}

	exports.calc_pose_data = calc_pose_data;
	/**
	 * Calculate pose trans/quats for armature object
	 */
	function calc_pose_data(bone_pointers) {

	    var trans = [];
	    var quats = [];
	    var bone_space_trans = [];
	    var bone_space_quats = [];

	    var t = new Float32Array(4);
	    var q = new Float32Array(4);

	    for (var bone_name in bone_pointers) {
	        var bpointer = bone_pointers[bone_name];

	        calc_pose_bone(bpointer, t, q);
	        var bone_index = bpointer.bone_index;

	        m_tsr.multiply(bpointer.tsr_bone_rest, bpointer.tsr_basis, _tsr_tmp);

	        for (var i = 0; i < 4; i++) {
	            /* quat, tran vec4 */
	            var comp_index = 4 * bone_index + i;
	            trans[comp_index] = t[i];
	            quats[comp_index] = q[i];
	            bone_space_trans[comp_index] = _tsr_tmp[i];
	            bone_space_quats[comp_index] = _tsr_tmp[i + 4];
	        }
	    }
	    return {trans: trans, quats: quats,
	        bone_space_trans: bone_space_trans, bone_space_quats: bone_space_quats};
	}

	/**
	 * Copy skeletal animation data (i.e. pose) for every "pierced" frame
	 * from armature to skinned object
	 */
	function calc_skinned_pose_data_frames(armobj_pose_data_frames,
	                                       bone_skinning_info) {
	    // convert to form appropriate for renderer
	    var trans_frames = [];
	    var quats_frames = [];

	    var armobj_trans_frames = armobj_pose_data_frames.trans;
	    var armobj_quats_frames = armobj_pose_data_frames.quats;

	    for (var i = 0; i < armobj_trans_frames.length; i++) {
	        var pose_data = extract_skinned_pose_data(armobj_trans_frames[i],
	                                                  armobj_quats_frames[i],
	                                                  bone_skinning_info);
	        trans_frames.push(pose_data.trans);
	        quats_frames.push(pose_data.quats);
	    }
	    return {trans: trans_frames, quats: quats_frames};
	}

	exports.extract_skinned_pose_data = extract_skinned_pose_data;
	/**
	 * Copy pose trans/quats from armature to skinned object
	 */
	function extract_skinned_pose_data(arm_trans, arm_quats, bone_skinning_info) {
	    var trans = [];
	    var quats = [];

	    for (var bone_name in bone_skinning_info) {
	        var skininfo = bone_skinning_info[bone_name];
	        var index = skininfo.bone_index;
	        var deform_index = skininfo.deform_bone_index;

	        // write to appropriate places in uniform arrays
	        for (var i = 0; i < 4; i++) {
	            /* quat, tran vec4 */
	            var comp_skin_index = 4 * deform_index + i;
	            var comp_arm_index = 4 * index + i;
	            trans[comp_skin_index] = arm_trans[comp_arm_index];
	            quats[comp_skin_index] = arm_quats[comp_arm_index];
	        }
	    }

	    trans = new Float32Array(trans);
	    quats = new Float32Array(quats);

	    return {trans: trans, quats: quats};

	}

	/**
	 * Calculate pose data for given bone.
	 * recursively calculate tsr_channel_cache beginning from "root"
	 * store tsr_channel_cache_valid state in each bone
	 */
	function calc_pose_bone(bone_pointer, dest_trans_scale, dest_quat) {
	    var chain = bone_pointer.chain;
	    var bone_root_ptr = chain[chain.length-1];

	    var tsr_channel_parent = bone_root_ptr.tsr_channel_cache;
	    // reset "root" bone if not valid
	    if (!bone_root_ptr.tsr_channel_cache_valid)
	        m_tsr.identity(tsr_channel_parent);

	    // start from the last bone ("root" for chain)
	    for (var i = chain.length - 1; i >= 0; i--) {
	        var bone_ptr = chain[i];

	        var tsr_channel = bone_ptr.tsr_channel_cache;

	        // this can be already calculated because
	        // a bone can participate in other chains
	        // else calculate channel TSR
	        if (bone_ptr.tsr_channel_cache_valid) {
	            tsr_channel_parent = tsr_channel;
	            continue;
	        }

	        // bone armature-relative TSR
	        var tsr_local = bone_ptr.tsr_local_rest;
	        // bone-relative TSR
	        var tsr_basis = bone_ptr.tsr_basis;

	        // apply basis translation (delta) in armature space
	        // go to bone space, apply pose, return back to armature space
	        // tsr_local * (tsr_basis * tsr_locali)
	        m_tsr.invert(tsr_local, _tsr_tmp);
	        m_tsr.multiply(tsr_basis, _tsr_tmp, _tsr_tmp);
	        m_tsr.multiply(tsr_local, _tsr_tmp, _tsr_tmp);

	        // apply hierarchy
	        m_tsr.multiply(tsr_channel_parent, _tsr_tmp, tsr_channel);

	        // save
	        tsr_channel_parent = tsr_channel;
	        bone_ptr.tsr_channel_cache_valid = true;
	    }

	    // split and store calculated TSR
	    var tsr = bone_ptr.tsr_channel_cache;

	    dest_trans_scale[0] = tsr[0];
	    dest_trans_scale[1] = tsr[1];
	    dest_trans_scale[2] = tsr[2];
	    dest_trans_scale[3] = tsr[3];
	    dest_quat[0] = tsr[4];
	    dest_quat[1] = tsr[5];
	    dest_quat[2] = tsr[6];
	    dest_quat[3] = tsr[7];
	    m_quat.normalize(dest_quat, dest_quat);
	}

	/**
	 * Parse animation curves.
	 */
	exports.append_action = function(action) {
	    var BONE_EXP = new RegExp(/pose.bones\[\".+\"\]/g);
	    var TSR8_DEF = m_tsr.create();

	    var init_storage = function(pierced_points, default_value) {
	        if (typeof default_value == "object" && default_value.length) {
	            var len = default_value.length;
	            var storage = new Float32Array(pierced_points * len);

	            for (var i = 0; i < pierced_points; i++)
	                for (var j = 0; j < len; j++)
	                    storage[i * len + j] = default_value[j];

	        } else if (typeof default_value == "number") {
	            var storage = new Float32Array(pierced_points);

	            for (var i = 0; i < pierced_points; i++)
	                storage[i] = default_value;
	        } else
	            m_util.panic("Wrong storage default value");

	        return storage;
	    };

	    var get_storage = function(params, bones, data_path, pierced_points,
	                               num_channels) {
	        if (data_path.search(BONE_EXP) > -1) {
	            var storage_obj = bones;
	            var name = data_path.split("\"")[1];
	            var def_val = TSR8_DEF;
	        } else {
	            var storage_obj = params;
	            if (num_channels == 8) {
	                var name = "tsr";
	                var def_val = TSR8_DEF;
	            } else if (num_channels > 1) {
	                var name = data_path;
	                var def_val = new Float32Array(num_channels);
	            } else {
	                var name = data_path;
	                var def_val = 0.0;
	            }
	        }

	        if (!storage_obj[name]) {
	            storage_obj[name] = init_storage(pierced_points, def_val);
	        }

	        return storage_obj[name];
	    };

	    var storage_offset = function(data_path, array_index) {
	        if (data_path.indexOf("location") > -1) {
	            var base_offset = 0;
	            var channel_offset = array_index;
	        } else if (data_path.indexOf("rotation_quaternion") > -1) {
	            var base_offset = 4;
	            // W X Y Z -> X Y Z W
	            var channel_offset = (array_index == 0) ? 3 : array_index - 1;
	        } else if (data_path.indexOf("scale") > -1) {
	            var base_offset = 3;
	            var channel_offset = 0;
	        } else {
	            var base_offset = 0;
	            var channel_offset = array_index;
	        }
	        return base_offset + channel_offset;
	    };

	    var prepare_tsr_arr = function(tsr_arr, num_pierced) {
	        for (var i = 0; i < num_pierced; i++) {
	            var quat = tsr_arr.subarray(i*8 + 4, i*8 + 8);
	            m_quat.normalize(quat, quat);
	        }
	    };

	    var act_render = action._render = create_action_render();
	    act_render.pierce_step = 1 / cfg_ani.frame_steps;

	    var fcurves = action["fcurves"];
	    var params = {};
	    var bones = {};
	    var num_pierced = 0;

	    for (var data_path in fcurves) {
	        var channels = fcurves[data_path];

	        for (var array_index in channels) {
	            var fcurve = channels[array_index];
	            var pp = fcurve._pierced_points;
	            m_reformer.check_anim_fcurve_completeness(fcurve, action);
	            var num_channels = fcurve["num_channels"];

	            if (!num_pierced)
	                num_pierced = pp.length;

	            var storage = get_storage(params, bones, data_path, num_pierced,
	                                      num_channels);

	            var stride = storage.length / num_pierced;
	            // NOTE: converting JSON key "array_index" to Int
	            var offset = storage_offset(data_path, array_index | 0);

	            for (var i = 0; i < num_pierced; i++)
	                storage[i * stride + offset] = pp[i];
	        }
	    }

	    if (m_util.get_dict_length(params)) {
	        for (var p in params)
	            if (p == "tsr")
	                prepare_tsr_arr(params[p], num_pierced);
	        act_render.params = params;
	    }

	    if (m_util.get_dict_length(bones)) {
	        for (var b in bones)
	            prepare_tsr_arr(bones[b], num_pierced);
	        act_render.bones = bones;
	    }

	    act_render.num_pierced = num_pierced;

	    act_render.bflags = action._bflags;

	    if ("tsr" in params)
	        set_tsr_act_channels_mask(fcurves, act_render.channels_mask);

	    if ("color" in params || "energy" in params)
	        set_lamp_act_channels_mask(fcurves, act_render.channels_mask);

	    if ("light_settings.environment_energy" in params
	            || "horizon_color"              in params
	            || "zenith_color"               in params
	            || "mist_settings.intensity"    in params
	            || "mist_settings.depth"        in params
	            || "mist_settings.start"        in params
	            || "mist_settings.height"       in params
	            || "b4w_fog_color"              in params
	        )
	        set_environment_act_channels_mask(fcurves, act_render.channels_mask);

	    update_action_type(action);

	    _actions.push(action);
	};

	/**
	 * Update action type.
	 * Zero fcurves means no params and no bones therefore action will have
	 * OBJ_ANIM_TYPE_NONE type.
	 */
	function update_action_type(action) {
	    var act_render = action._render;

	    if (act_render.bones)
	        act_render.type = OBJ_ANIM_TYPE_ARMATURE;
	    else if (act_render.params) {
	        if ("volume" in act_render.params || "pitch" in act_render.params)
	            act_render.type = OBJ_ANIM_TYPE_SOUND;
	        else if (is_material_action(action))
	            act_render.type = OBJ_ANIM_TYPE_MATERIAL;
	        else if (is_light_action(action))
	            act_render.type = OBJ_ANIM_TYPE_LIGHT;
	        else if (is_environment_action(action))
	            act_render.type = OBJ_ANIM_TYPE_ENVIRONMENT;
	        else if (is_object_action(action))
	            act_render.type = OBJ_ANIM_TYPE_OBJECT;
	        else
	            act_render.type = OBJ_ANIM_TYPE_NONE;
	    } else
	        act_render.type = OBJ_ANIM_TYPE_NONE;
	}

	function is_material_action(action) {
	    var params = action._render.params;

	    if (params)
	        for (var param in params)
	            if (param.indexOf("nodes") != -1)
	                return true;
	    return false;
	}

	function is_light_action(action) {
	    var params = action._render.params;

	    if (params) {
	        var fcurves = action["fcurves"];
	        for (var param in fcurves)
	            if (param == "color" && !fcurves[param][3])
	                return true;
	            if (param == "energy")
	                return true;
	    }
	    return false;
	}

	function is_environment_action(action) {
	    var params = action._render.params;

	    if ("light_settings.environment_energy" in params
	            || "horizon_color"              in params
	            || "zenith_color"               in params
	            || "mist_settings.intensity"    in params
	            || "mist_settings.depth"        in params
	            || "mist_settings.start"        in params
	            || "mist_settings.height"       in params
	            || "b4w_fog_color"              in params
	        )
	        return true;

	    return false;
	}

	function is_object_action(action) {
	    var params = action._render.params;

	    if (params) {
	        var fcurves = action["fcurves"];
	        for (var param in fcurves)
	            if (param == "location"
	                    || param == "rotation_quaternion"
	                    || param == "scale"
	                )
	                return true;
	    }
	    return false;
	}

	function set_tsr_act_channels_mask(fcurves, mask) {
	    mask[0] = mask[1] = mask[2] = 0;
	    for (var data_path in fcurves) {
	        if (data_path == "location")
	            mask[0] = 1;
	        else if (data_path == "rotation_quaternion")
	            mask[1] = 1;
	        else if (data_path == "scale")
	            mask[2] = 1;
	    }
	}

	function set_lamp_act_channels_mask(fcurves, mask) {
	    mask[0] = mask[1] = 0;
	    for (var data_path in fcurves) {
	        if (data_path == "energy")
	            mask[0] = 1;
	        else if (data_path == "color")
	            mask[1] = 1;
	    }
	}

	function set_environment_act_channels_mask(fcurves, mask) {
	    mask[AEM_ENERGY] = mask[AEM_HORIZON_COLOR] = mask[AEM_ZENITH_COLOR] = 0;
	    mask[AEM_FOG_INTENSITY] = mask[AEM_FOG_DEPTH] = mask[AEM_FOG_START] = 0;
	    mask[AEM_FOG_HEIGHT] = mask[AEM_FOG_COLOR] = 0;
	    for (var data_path in fcurves) {
	        if (data_path == "light_settings.environment_energy")
	            mask[AEM_ENERGY] = 1;
	        else if (data_path == "horizon_color")
	            mask[AEM_HORIZON_COLOR] = 1;
	        else if (data_path == "zenith_color")
	            mask[AEM_ZENITH_COLOR] = 1;
	        else if (data_path == "mist_settings.intensity")
	            mask[AEM_FOG_INTENSITY] = 1;
	        else if (data_path == "mist_settings.depth")
	            mask[AEM_FOG_DEPTH] = 1;
	        else if (data_path == "mist_settings.start")
	            mask[AEM_FOG_START] = 1;
	        else if (data_path == "mist_settings.height")
	            mask[AEM_FOG_HEIGHT] = 1;
	        else if (data_path == "b4w_fog_color")
	            mask[AEM_FOG_COLOR] = 1;
	    }
	}

	exports.get_approx_curve_length = function(start, end) {
	    return (end - start) * cfg_ani.frame_steps + 1;
	};

	/**
	 * Perform fcurve extrapolation/interpolation.
	 * Write points array for each fcurve
	 * Update bflags array for each fcurve in action (write only unit values)
	 */
	exports.approximate_curve = function(fcurve, fcurve_bin_data, points, bflags,
	        start, end) {

	    // initialize util arrays
	    var v1 = new Float32Array(2);
	    var v2 = new Float32Array(2);
	    var v3 = new Float32Array(2);
	    var v4 = new Float32Array(2);

	    var first_frame = fcurve_bin_data[1];
	    var first_frame_value = fcurve_bin_data[2];

	    var last_frame = fcurve_bin_data[fcurve["last_frame_offset"] + 1];
	    var last_frame_value = fcurve_bin_data[fcurve["last_frame_offset"] + 2];

	    var out_cursor = 0;
	    var bin_cursor = 0;
	    var interp_prev = null;

	    for (var i = start; i <= end; i++) {
	        // make extrapolation before fcurve
	        if (i < first_frame)
	            for (var j = 0; j < cfg_ani.frame_steps; j++)
	                points[out_cursor++] = first_frame_value;

	        // make extrapolation after fcurve
	        else if (i > last_frame)
	            for (var j = 0; j < cfg_ani.frame_steps; j++)
	                points[out_cursor++] = last_frame_value;

	        // process points inside
	        else {
	            // calc properties of current keyframe
	            var interp = fcurve_bin_data[bin_cursor];
	            var offset_to_next_kf = 3;
	            if (interp === KF_INTERP_BEZIER)
	                offset_to_next_kf += 2;
	            if (interp_prev === KF_INTERP_BEZIER)
	                offset_to_next_kf += 2;
	            var is_blended = (interp === KF_INTERP_CONSTANT) ? 0 : 1;

	            // NOTE: if next frame time same as current (decimal converted to
	            // integer) then move to next frame immediately
	            if (fcurve_bin_data[bin_cursor + 1]
	                    == fcurve_bin_data[bin_cursor + offset_to_next_kf + 1]) {
	                interp_prev = interp;
	                bin_cursor += offset_to_next_kf;
	                continue;
	            }

	            // take base data from source array for integer point value
	            var substep_from = 0;
	            if (i == fcurve_bin_data[bin_cursor + 1]) {
	                if (is_blended)
	                    bflags[out_cursor] = 1;
	                points[out_cursor] = fcurve_bin_data[bin_cursor + 2];
	                out_cursor++;

	                substep_from++;
	            }

	            // process points for fcurve last keyframe (extrapolation,
	            // outside fcurve)
	            if (i == last_frame)
	                for (var j = substep_from; j < cfg_ani.frame_steps; j++)
	                    points[out_cursor++] = last_frame_value;
	            else {
	                // control point
	                v1[0] = fcurve_bin_data[bin_cursor + 1];
	                v1[1] = fcurve_bin_data[bin_cursor + 2];
	                // right handle
	                if (interp !== KF_INTERP_BEZIER) {
	                    v2[0] = 0;
	                    v2[1] = 0;
	                } else {
	                    if (interp_prev === KF_INTERP_BEZIER) {
	                        v2[0] = fcurve_bin_data[bin_cursor + 5];
	                        v2[1] = fcurve_bin_data[bin_cursor + 6];
	                    } else {
	                        v2[0] = fcurve_bin_data[bin_cursor + 3];
	                        v2[1] = fcurve_bin_data[bin_cursor + 4];
	                    }
	                }
	                // left handle next
	                if (interp !== KF_INTERP_BEZIER) {
	                    v3[0] = 0;
	                    v3[1] = 0;
	                } else {
	                    v3[0] = fcurve_bin_data[bin_cursor + offset_to_next_kf + 3];
	                    v3[1] = fcurve_bin_data[bin_cursor + offset_to_next_kf + 4];
	                }
	                // control point next
	                v4[0] = fcurve_bin_data[bin_cursor + offset_to_next_kf + 1];
	                v4[1] = fcurve_bin_data[bin_cursor + offset_to_next_kf + 2];

	                // make interpolation for decimal values
	                for (var j = substep_from; j < cfg_ani.frame_steps; j++) {
	                    var interp_val = i + j / cfg_ani.frame_steps;
	                    switch (interp) {
	                    case KF_INTERP_BEZIER:
	                        correct_bezpart(v1, v2, v3, v4);
	                        if (is_blended)
	                            bflags[out_cursor] = 1;
	                        points[out_cursor] = bezier(interp_val, v1, v2, v3, v4);
	                        out_cursor++;
	                        break;
	                    case KF_INTERP_LINEAR:
	                        if (is_blended)
	                            bflags[out_cursor] = 1;
	                        points[out_cursor] = linear(interp_val, v1, v4);
	                        out_cursor++;
	                        break;
	                    case KF_INTERP_CONSTANT:
	                        if (is_blended)
	                            bflags[out_cursor] = 1;
	                        points[out_cursor] = fcurve_bin_data[bin_cursor + 2];
	                        out_cursor++;
	                        break;
	                    default:
	                        m_util.panic("Unknown keyframe interpolation mode: " + interp);
	                    }
	                }
	            }

	            // reaching new keyframe point on next iteration
	            if (i + 1 == fcurve_bin_data[bin_cursor + offset_to_next_kf + 1]) {
	                interp_prev = interp;
	                bin_cursor += offset_to_next_kf;
	            }
	        }
	    }
	};

	function linear(x, v1, v4) {
	    var x1 = v1[0], y1 = v1[1],
	        x2 = v4[0], y2 = v4[1];
	    var k = (y2 - y1) / (x2 - x1);
	    var b = y1 - k * x1;
	    return k * x + b;
	}


	/**
	 * The total length of the handles is not allowed to be more
	 * than the horizontal distance between (v1-v4).
	 * (prevent curve loops)
	 */
	function correct_bezpart(v1, v2, v3, v4) {

	    var h1 = [];
	    var h2 = [];
	    var len1, len2, len, fac;

	    // calc handle deltas
	    h1[0] = v1[0] - v2[0];
	    h1[1] = v1[1] - v2[1];

	    h2[0] = v4[0] - v3[0];
	    h2[1] = v4[1] - v3[1];

	    // calculate distances:
	    // len- span of time between keyframes
	    // len1    - length of handle of start key
	    // len2    - length of handle of end key
	    len = v4[0]- v1[0];
	    len1 = Math.abs(h1[0]);
	    len2 = Math.abs(h2[0]);

	    // if the handles have no length, no need to do any corrections
	    if ((len1 + len2) == 0)
	        return;

	    // the two handles cross over each other, so force them
	    // apart using the proportion they overlap
	    if (len1 + len2 > len) {
	        fac = len / (len1 + len2);

	        v2[0] = v1[0] - fac * h1[0];
	        v2[1] = v1[1] - fac * h1[1];

	        v3[0] = v4[0] - fac * h2[0];
	        v3[1] = v4[1] - fac * h2[1];
	    }
	}

	function bezier(x, v1, v2, v3, v4) {

	    // first find parameter t corresponding to x
	    var t = bezier_find_root(0, 1, x, v1[0], v2[0], v3[0], v4[0]);

	    // then calc y from t
	    var y = bezier_parametric(t, v1[1], v2[1], v3[1], v4[1]);

	    return y;
	}

	function bezier_find_root(t0_so_far, t1_so_far, x_needed, x0, x1, x2, x3) {

	    // split the interval
	    var t = t0_so_far + (t1_so_far - t0_so_far) / 2;

	    var x = bezier_parametric(t, x0, x1, x2, x3);

	    var dx = x - x_needed;

	    var precision = 0.02;

	    if (Math.abs(dx) < precision)
	        return t;

	    if (dx > 0)
	        return bezier_find_root(t0_so_far, t, x_needed, x0, x1, x2, x3);
	    else
	        return bezier_find_root(t, t1_so_far, x_needed, x0, x1, x2, x3);
	}

	function bezier_parametric(t, p0, p1, p2, p3) {
	    var t1 = 1 - t;

	    return p0 * t1 * t1 * t1 +
	       3 * p1 * t1 * t1 * t +
	       3 * p2 * t1 * t  * t +
	           p3 * t  * t  * t;
	}

	function get_anim_translation(anim_slot, index, frame_info, dest) {
	    var frame = frame_info[0];
	    var frame_next = frame_info[1];
	    var frame_factor = frame_info[2];

	    var trans = anim_slot.trans;

	    var x = trans[frame][4*index];
	    var y = trans[frame][4*index+1];
	    var z = trans[frame][4*index+2];

	    var xn = trans[frame_next][4*index];
	    var yn = trans[frame_next][4*index+1];
	    var zn = trans[frame_next][4*index+2];

	    dest[0] = (1-frame_factor) * x + frame_factor * xn;
	    dest[1] = (1-frame_factor) * y + frame_factor * yn;
	    dest[2] = (1-frame_factor) * z + frame_factor * zn;

	    return dest;
	}

	function get_anim_rotation(anim_slot, index, frame_info, dest) {
	    var frame = frame_info[0];
	    var frame_next = frame_info[1];
	    var frame_factor = frame_info[2];

	    var quats = anim_slot.quats;
	    var quat_frame = _quat4_tmp2;
	    quat_frame[0] = quats[frame][4*index];
	    quat_frame[1] = quats[frame][4*index + 1];
	    quat_frame[2] = quats[frame][4*index + 2];
	    quat_frame[3] = quats[frame][4*index + 3];
	    var quat_frame_next = _quat4_tmp3;
	    quat_frame_next[0] = quats[frame_next][4*index];
	    quat_frame_next[1] = quats[frame_next][4*index + 1];
	    quat_frame_next[2] = quats[frame_next][4*index + 2];
	    quat_frame_next[3] = quats[frame_next][4*index + 3];

	    m_quat.slerp(quat_frame, quat_frame_next, frame_factor, dest);
	    return dest;
	}

	function get_anim_scale(anim_slot, index, frame_info) {
	    var frame = frame_info[0];
	    var frame_next = frame_info[1];
	    var frame_factor = frame_info[2];

	    var trans = anim_slot.trans;

	    var s = trans[frame][4*index+3];
	    var sn = trans[frame_next][4*index+3];

	    var scale = (1-frame_factor) * s + frame_factor * sn;
	    return scale;
	}

	function do_before_apply(obj, slot_num) {
	    init_anim(obj, slot_num);
	    update_anim_cache(obj);
	}

	function do_after_apply(obj, slot_num) {
	    // to update e.g bounding boxes
	    m_trans.update_transform(obj);
	    m_phy.sync_transform(obj);
	    update_object_animation(obj, 0, slot_num, true);
	}

	exports.apply = apply;
	// name_list can be used to specify object's material and nested groups
	function apply(obj, name_list, name, slot_num) {

	    slot_num = slot_num || SLOT_0;

	    if (m_obj_util.is_mesh(obj)) {
	        var vertex_anim = get_vertex_anim_by_name(obj, name);
	        if (vertex_anim) {
	            do_before_apply(obj, slot_num);
	            apply_vertex_anim(obj, vertex_anim, slot_num);
	            do_after_apply(obj, slot_num);
	            return true;
	        }

	        var pdata = get_particles_data_by_name(obj, name);
	        if (pdata && pdata.p_type == "EMITTER") {
	            do_before_apply(obj, slot_num);
	            apply_obj_particles_anim(obj, pdata.name, slot_num);
	            do_after_apply(obj, slot_num);
	            return true;
	        }

	    }
	    var action = m_util.keysearch("name", name, _actions) ||
	            m_util.keysearch("name", name + "_B4W_BAKED", _actions);
	    if (action) {
	        do_before_apply(obj, slot_num);
	        if (apply_action(obj, name_list, action, slot_num)) {
	            do_after_apply(obj, slot_num);
	            return true;
	        } else
	            obj.anim_slots[slot_num] = null;
	    }

	    m_print.error("Unsupported object: \"" + obj.name +
	                  "\" or animation name: \"" + name + "\"");
	    return false;
	}

	exports.apply_by_uuid = function(obj, name_list, uuid, slot_num) {
	    slot_num = slot_num || SLOT_0;
	    var action = m_util.keysearch("uuid", uuid, _actions);
	    if (action) {
	        do_before_apply(obj, slot_num);
	        if (apply_action(obj, name_list, action, slot_num)) {
	            do_after_apply(obj, slot_num);
	            return true;
	        } else
	            obj.anim_slots[slot_num] = null;
	    }

	    m_print.error("Unsupported object: \"" + obj.name +
	                  "\" or animation uuid: \"" + uuid + "\"");
	    return false;
	};

	exports.validate_action_by_name = function(obj, name) {
	    var action = m_util.keysearch("name", name, _actions) ||
	            m_util.keysearch("name", name + "_B4W_BAKED", _actions);

	    if (action) {
	        if (action._render.type == OBJ_ANIM_TYPE_NONE)
	            return false;    
	    } else {

	        var pdata = get_particles_data_by_name(obj, name);
	        if (!pdata)
	            if (!m_obj_util.is_mesh(obj) || 
	                    !get_vertex_anim_by_name(obj, name))
	                return false;
	    }

	    return true;
	};


	exports.get_slot_num_by_anim = get_slot_num_by_anim;
	function get_slot_num_by_anim(obj, anim_name) {
	    var anim_slots = obj.anim_slots;
	    for (var i = 0; i < anim_slots.length; i++) {
	        var anim_slot = anim_slots[i];
	        if (anim_slot && strip_baked_suffix(anim_slot.animation_name) ==
	                         strip_baked_suffix(anim_name))
	            return i;
	    }
	    return -1;
	}

	exports.get_anim_by_slot_num = function(obj, slot_num) {
	    var anim_slot = obj.anim_slots[slot_num];
	    if (anim_slot && anim_slot.animation_name)
	        return strip_baked_suffix(anim_slot.animation_name);

	    return null;
	};

	exports.remove = function(obj) {
	    obj.anim_slots.length = 0;
	    var ind = _anim_objs_cache.indexOf(obj);
	    if (ind != -1)
	        _anim_objs_cache.splice(ind, 1);
	};

	exports.remove_actions = function(data_id) {
	    for (var i = _actions.length - 1; i >= 0; i--)
	        if (_actions[i]._data_id == data_id)
	            _actions.splice(i, 1);
	};

	exports.apply_to_first_empty_slot = function(obj, name) {
	    if (!obj.anim_slots.length) {
	        if (apply(obj, null, name, SLOT_0))
	            return SLOT_0;
	        else
	            return -1;
	    }
	    for (var i = 0; i < obj.anim_slots.length; i++) {
	        if (!obj.anim_slots[i]) {
	            if (apply(obj, null, name, i))
	                return i;
	            else
	                return -1;
	        }
	    }
	};

	exports.set_skel_mix_factor = function(obj, factor, time, mix_cb) {
	    var render = obj.render;
	    var cur_mix_factor = render.anim_mix_factor;
	    var speed = (factor - cur_mix_factor) / time;

	    render.anim_mix_factor_change_speed = speed;
	    render.anim_destination_mix_factor = factor;
	    if (render.anim_mix_cb)
	        render.anim_mix_cb();
	    render.anim_mix_cb = mix_cb;
	};

	exports.mix_from_cur_pos = function(obj, slot, time, mix_cb) {
	    var render = obj.render;
	    render.blend_skel_slots[1] = slot;

	    var speed = 1.0 / time;
	    render.anim_mix_factor_change_speed = speed;
	    render.anim_destination_mix_factor = 1.0;

	    if (render.anim_mix_cb)
	        render.anim_mix_cb();
	    render.anim_mix_cb = mix_cb;

	    render.trans_curr = null;
	    render.quats_curr = null;
	    render.mix_with_current = true;
	};

	exports.set_speed = function(obj, speed, slot_num) {
	    function set_speed(anim_slot) {
	        anim_slot.speed = speed;
	    }
	    process_anim_slots(obj.anim_slots, slot_num, set_speed);
	};

	exports.get_speed = function(obj, slot_num) {
	    return obj.anim_slots[slot_num].speed;
	};

	exports.get_anim_start_frame = get_anim_start_frame;
	function get_anim_start_frame(obj, slot_num) {
	    var anim_slot = obj.anim_slots[slot_num];
	    return anim_slot.start;
	}

	exports.get_anim_length = function(obj, slot_num) {
	    var anim_slot = obj.anim_slots[slot_num];
	    return anim_slot.length;
	};

	exports.cleanup = function() {
	    _anim_objs_cache.length = 0;
	    _actions.length = 0;
	};

	/**
	 * uses _vec3_tmp, _quat4_tmp
	 */
	exports.fcurve_replace_euler_by_quat = function(fcurve) {
	    var ch = fcurve[0] || fcurve[1] || fcurve[2];
	    var pcount = ch._pierced_points.length;

	    var quat = _quat4_tmp;
	    var euler_angles = _vec3_tmp;

	    var is_x_rot = Boolean(fcurve[0]);
	    if (!is_x_rot)
	        fcurve[0] = { _pierced_points: new Float32Array(pcount),
	                        "num_channels": 8};
	    var is_y_rot = Boolean(fcurve[1]);
	    if (!is_y_rot)
	        fcurve[1] = { _pierced_points: new Float32Array(pcount),
	                        "num_channels": 8};
	    var is_z_rot = Boolean(fcurve[2]);
	    if (!is_z_rot)
	        fcurve[2] = { _pierced_points: new Float32Array(pcount),
	                        "num_channels": 8};
	    fcurve[3] = { _pierced_points: new Float32Array(pcount),
	                    "num_channels": 8};

	    for (var i = 0; i < pcount; i++) {
	        euler_angles[0] = (is_x_rot) ? fcurve[0]._pierced_points[i]: 0;
	        euler_angles[1] = (is_y_rot) ? fcurve[1]._pierced_points[i]: 0;
	        euler_angles[2] = (is_z_rot) ? fcurve[2]._pierced_points[i]: 0;
	        m_util.euler_to_quat(euler_angles, quat);

	        // (x, y, z, w) to (w, x, y, z) fcurve format
	        fcurve[0]._pierced_points[i] = quat[3];
	        fcurve[1]._pierced_points[i] = quat[0];
	        fcurve[2]._pierced_points[i] = quat[1];
	        fcurve[3]._pierced_points[i] = quat[2];
	    }
	};

	function get_vertex_anim_by_name(obj, name) {
	    for (var i = 0; i < obj.vertex_anim.length; i++) {
	        var va = obj.vertex_anim[i];
	        if (va.name === name)
	            return va;
	    }

	    return null;
	}

	function get_particles_data_by_name(obj, name) {
	    var scenes_data = obj.scenes_data;
	    for (var i = 0; i < scenes_data.length; i++) {
	        var batches = scenes_data[i].batches;
	        for (var j = 0; j < batches.length; j++) {
	            var pdata = batches[j].particles_data;
	            if (pdata && pdata.name === name)
	                return pdata;
	        }
	    }

	    return null;
	}

	exports.get_bpy_armobj = get_bpy_armobj;
	function get_bpy_armobj(bpy_obj) {
	    var modifiers = bpy_obj["modifiers"];
	    for (var i = 0; i < modifiers.length; i++) {
	        var modifier = modifiers[i];
	        if (modifier["type"] == "ARMATURE")
	            return modifier["object"];
	    }

	    return null;
	}

	exports.slot_by_anim_type = slot_by_anim_type;
	function slot_by_anim_type(obj, anim_name) {

	    var first_free_slot = SLOT_7;
	    var anim_type = OBJ_ANIM_TYPE_NONE;

	    for (var i = 0; i < _actions.length; i++) {
	        var action = _actions[i];
	        if (action["name"] == anim_name) {
	            anim_type = action._render.type;
	            break;
	        }
	    }

	    if (anim_type == OBJ_ANIM_TYPE_NONE) {
	        if (get_vertex_anim_by_name(obj, anim_name))
	            anim_type = OBJ_ANIM_TYPE_VERTEX;
	        else {
	            var pdata = get_particles_data_by_name(obj, anim_name);
	            if (pdata && pdata.p_type == "EMITTER")
	                anim_type = OBJ_ANIM_TYPE_PARTICLES;
	        }
	    }

	    for (var i = 0; i < 8; i++) {
	        var anim_slot = obj.anim_slots[i];
	        if (anim_slot) {
	            if (anim_slot.type == anim_type)
	                return i;
	        } else if (i < first_free_slot)
	            first_free_slot = i;
	    }

	    return first_free_slot;
	}


	}

	var int_animation_factory = register("__animation", Int_animation);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Material internal API.
	 * @name material
	 * @namespace
	 * @exports exports as material
	 */
	function Int_material(ns, exports) {

	var m_util = int_util_factory(ns);

	exports.init_material = init_material;
	function init_material() {
	    var mat = {

	        name: "",
	        type: "",
	        uuid: "",

	        use_nodes: false,
	        node_tree: null,

	        texture_slots: [],

	        blend_mode: "",

	        use_shadeless: false,
	        use_transparency: false,
	        use_backface_culling: false,
	        use_tangent_shading: false,
	        use_orco_tex_coord: false,
	        use_vertex_color_paint: false,
	        use_double_sided_lighting: false,

	        do_not_render: false,
	        render_above_all: false,

	        is_lens_flares: false,
	        is_wettable: false,
	        is_refractive: false,
	        refr_bump: 0,
	        
	        pass_index: 0,
	        offset_z: 0,


	        diffuse_shader: "",
	        diffuse_color: new Float32Array(3),
	        diffuse_intensity: 0,
	        diffuse_toon_size: 0,
	        diffuse_toon_smooth: 0,
	        roughness: 0,
	        diffuse_fresnel: 0,
	        diffuse_fresnel_factor: 0,
	        darkness: 0,
	        alpha: 0,

	        specular_shader: "",
	        specular_color: new Float32Array(3),
	        specular_intensity: 0,
	        specular_toon_size: 0,
	        specular_toon_smooth: 0,
	        specular_hardness: 0,
	        specular_ior: 0,
	        specular_slope: 0,
	        specular_alpha: 0,

	        emit: 0,
	        ambient: 0,

	        water_settings: {
	            is_water: false,

	            shore_smoothing: false,
	            absorb_factor: 0,
	            foam_factor: 0,

	            shallow_col: new Float32Array(3),
	            shore_col: new Float32Array(3),
	            shallow_col_fac: 0,
	            shore_col_fac: 0,

	            fog_color: new Float32Array(3),
	            fog_density: 0,

	            sss_strength: 0,
	            sss_width: 0,
	            norm_uv_velocity: 0,

	            // dynamic water surface settings
	            is_dynamic: false,
	            waves_height: 0,
	            waves_length: 0,
	            dst_noise_scale0: 0,
	            dst_noise_scale1: 0,
	            dst_noise_freq0: 0,
	            dst_noise_freq1: 0,
	            dir_min_shore_fac: 0,
	            dir_freq: 0,
	            dir_noise_scale: 0,
	            dir_noise_freq: 0,
	            dir_min_noise_fac: 0,
	            dst_min_fac: 0,
	            waves_hor_fac: 0,

	            // generated mesh settings
	            is_generated_mesh: false,
	            num_cascads: 0,
	            num_subdivs: 0,
	            detailed_dist: 0,

	            // caustics settings
	            enable_caust: false,
	            caust_scale: 0,
	            caust_brightness: 0
	        },

	        terrain_settings: {
	            is_terrain: false,
	            dynamic_grass_size: "",
	            dynamic_grass_color: ""
	        },

	        raytrace_mirror: {
	            reflect_factor: 0,
	            fresnel: 0,
	            fresnel_factor: 0
	        },

	        halo_settings: {
	            size: 0,
	            hardness: 0,
	                        
	            rings_color: new Float32Array(3),
	            lines_color: new Float32Array(3),
	            ring_count: 0,
	            line_count: 0,
	            star_tip_count: 0,

	            is_sky_stars: false,
	            stars_blend_height: 0,
	            stars_min_height: 0
	        },

	        physics_settings: {
	            use_coll_physics: false,
	            use_ghost: false,

	            friction: 0,
	            elasticity: 0,
	            collision_id: "",
	            collision_margin: 0,
	            collision_group: 0,
	            collision_mask: 0
	        }
	    };

	    return mat;
	}

	exports.create_default = function() {
	    var mat = init_material();

	    mat.name = "DEFAULT";
	    mat.type = "SURFACE";
	    mat.uuid = m_util.gen_uuid();

	    mat.use_nodes = false;
	    mat.node_tree = null;

	    mat.texture_slots = [];

	    mat.blend_mode = "OPAQUE";
	    mat.use_shadeless = false;
	    mat.use_transparency = false;
	    mat.use_backface_culling = true;
	    mat.use_vertex_color_paint = false;
	    mat.use_double_sided_lighting = false;

	    mat.render_above_all = false;

	    mat.is_refractive = false;
	    mat.refr_bump = 0;

	    mat.pass_index = 0;
	    mat.offset_z = 0;

	    mat.diffuse_shader = "LAMBERT";
	    mat.diffuse_color.set([0.8, 0.8, 0.8]);
	    mat.diffuse_intensity = 0.8;
	    mat.alpha = 1.0;

	    mat.specular_shader = "COOKTORR";
	    mat.specular_color.set([1, 1, 1]);
	    mat.specular_intensity = 0.5;
	    mat.specular_hardness = 50;
	    mat.specular_alpha = 1;

	    mat.emit = 0;
	    mat.ambient = 1.0;

	    mat.water_settings.is_water = false;

	    mat.terrain_settings.is_terrain = false;

	    mat.raytrace_mirror.reflect_factor = 0;
	    mat.raytrace_mirror.fresnel = 0;
	    mat.raytrace_mirror.fresnel_factor = 1.25;

	    mat.physics_settings.use_coll_physics = false;

	    return mat;
	};

	exports.update_material = function(bpy_mat, mat) {

	    mat.name = bpy_mat["name"];
	    mat.type = bpy_mat["type"];
	    mat.uuid = bpy_mat["uuid"];

	    mat.use_nodes = bpy_mat["use_nodes"];
	    mat.node_tree = bpy_mat["node_tree"];

	    mat.texture_slots = bpy_mat["texture_slots"];

	    mat.blend_mode = bpy_mat["game_settings"]["alpha_blend"];
	    mat.use_shadeless = bpy_mat["use_shadeless"];
	    mat.use_transparency = bpy_mat["use_transparency"];
	    mat.use_backface_culling = bpy_mat["game_settings"]["use_backface_culling"];
	    mat.use_tangent_shading = bpy_mat["use_tangent_shading"];
	    mat.use_orco_tex_coord = bpy_mat["use_orco_tex_coord"];
	    mat.use_vertex_color_paint = bpy_mat["use_vertex_color_paint"];
	    mat.use_double_sided_lighting = bpy_mat["b4w_double_sided_lighting"];

	    mat.do_not_render = bpy_mat["b4w_do_not_render"];
	    mat.render_above_all = bpy_mat["b4w_render_above_all"];

	    mat.is_lens_flares = bpy_mat["b4w_lens_flares"];
	    mat.is_wettable = bpy_mat["b4w_wettable"];
	    mat.is_refractive = bpy_mat["b4w_refractive"];
	    mat.refr_bump = bpy_mat["b4w_refr_bump"];
	        
	    mat.pass_index = bpy_mat["pass_index"];
	    mat.offset_z = bpy_mat["offset_z"];

	    mat.diffuse_shader = bpy_mat["diffuse_shader"];
	    mat.diffuse_color.set(bpy_mat["diffuse_color"]);
	    mat.diffuse_intensity = bpy_mat["diffuse_intensity"];
	    mat.diffuse_toon_size = bpy_mat["diffuse_toon_size"];
	    mat.diffuse_toon_smooth = bpy_mat["diffuse_toon_smooth"];
	    mat.roughness = bpy_mat["roughness"];
	    mat.diffuse_fresnel = bpy_mat["diffuse_fresnel"];
	    mat.diffuse_fresnel_factor = bpy_mat["diffuse_fresnel_factor"];
	    mat.darkness = bpy_mat["darkness"];
	    mat.alpha = bpy_mat["alpha"];

	    mat.specular_shader = bpy_mat["specular_shader"];
	    mat.specular_color.set(bpy_mat["specular_color"]);
	    mat.specular_intensity = bpy_mat["specular_intensity"];
	    mat.specular_toon_size = bpy_mat["specular_toon_size"];
	    mat.specular_toon_smooth = bpy_mat["specular_toon_smooth"];
	    mat.specular_hardness = bpy_mat["specular_hardness"];
	    mat.specular_ior = bpy_mat["specular_ior"];
	    mat.specular_slope = bpy_mat["specular_slope"];
	    mat.specular_alpha = bpy_mat["specular_alpha"];

	    mat.emit = bpy_mat["emit"];
	    mat.ambient = bpy_mat["ambient"];

	    var ws = mat.water_settings;
	    ws.is_water = bpy_mat["b4w_water"];

	    ws.shore_smoothing = bpy_mat["b4w_water_shore_smoothing"];
	    ws.absorb_factor = bpy_mat["b4w_water_absorb_factor"];
	    ws.foam_factor = bpy_mat["b4w_foam_factor"];

	    ws.shallow_col.set(bpy_mat["b4w_shallow_water_col"]);
	    ws.shore_col.set(bpy_mat["b4w_shore_water_col"]);
	    ws.shallow_col_fac = bpy_mat["b4w_shallow_water_col_fac"];
	    ws.shore_col_fac = bpy_mat["b4w_shore_water_col_fac"];

	    ws.fog_color.set(bpy_mat["b4w_water_fog_color"]);
	    ws.fog_density = bpy_mat["b4w_water_fog_density"];

	    ws.sss_strength = bpy_mat["b4w_water_sss_strength"];
	    ws.sss_width = bpy_mat["b4w_water_sss_width"];
	    ws.norm_uv_velocity = bpy_mat["b4w_water_norm_uv_velocity"];

	    // dynamic water surface settings
	    ws.is_dynamic = bpy_mat["b4w_water_dynamic"];
	    ws.waves_height = bpy_mat["b4w_waves_height"];
	    ws.waves_length = bpy_mat["b4w_waves_length"];
	    ws.dst_noise_scale0 = bpy_mat["b4w_water_dst_noise_scale0"];
	    ws.dst_noise_scale1 = bpy_mat["b4w_water_dst_noise_scale1"];
	    ws.dst_noise_freq0 = bpy_mat["b4w_water_dst_noise_freq0"];
	    ws.dst_noise_freq1 = bpy_mat["b4w_water_dst_noise_freq1"];
	    ws.dir_min_shore_fac = bpy_mat["b4w_water_dir_min_shore_fac"];
	    ws.dir_freq = bpy_mat["b4w_water_dir_freq"];
	    ws.dir_noise_scale = bpy_mat["b4w_water_dir_noise_scale"];
	    ws.dir_noise_freq = bpy_mat["b4w_water_dir_noise_freq"];
	    ws.dir_min_noise_fac = bpy_mat["b4w_water_dir_min_noise_fac"];
	    ws.dst_min_fac = bpy_mat["b4w_water_dst_min_fac"];
	    ws.waves_hor_fac = bpy_mat["b4w_water_waves_hor_fac"];

	    // generated mesh settings
	    ws.is_generated_mesh = bpy_mat["b4w_generated_mesh"];
	    ws.num_cascads = bpy_mat["b4w_water_num_cascads"];
	    ws.num_subdivs = bpy_mat["b4w_water_subdivs"];
	    ws.detailed_dist = bpy_mat["b4w_water_detailed_dist"];

	    // caustics settings
	    ws.enable_caust = bpy_mat["b4w_water_enable_caust"];
	    ws.caust_scale = bpy_mat["b4w_water_caust_scale"];
	    ws.caust_brightness = bpy_mat["b4w_water_caust_brightness"];

	    var ts = mat.terrain_settings;
	    ts.is_terrain = bpy_mat["b4w_terrain"];
	    ts.dynamic_grass_size = bpy_mat["b4w_dynamic_grass_size"];
	    ts.dynamic_grass_color = bpy_mat["b4w_dynamic_grass_color"];

	    var rm = mat.raytrace_mirror;
	    rm.reflect_factor = bpy_mat["raytrace_mirror"]["reflect_factor"];
	    rm.fresnel = bpy_mat["raytrace_mirror"]["fresnel"];
	    rm.fresnel_factor = bpy_mat["raytrace_mirror"]["fresnel_factor"];

	    var hs = mat.halo_settings;
	    hs.size = bpy_mat["halo"]["size"];
	    hs.hardness = bpy_mat["halo"]["hardness"];
	                        
	    hs.rings_color.set(bpy_mat["halo"]["b4w_halo_rings_color"]);
	    hs.lines_color.set(bpy_mat["halo"]["b4w_halo_lines_color"]);
	    hs.ring_count = bpy_mat["halo"]["ring_count"];
	    hs.line_count = bpy_mat["halo"]["line_count"];
	    hs.star_tip_count = bpy_mat["halo"]["star_tip_count"];

	    hs.is_sky_stars = bpy_mat["b4w_halo_sky_stars"];
	    hs.stars_blend_height = bpy_mat["b4w_halo_stars_blend_height"];
	    hs.stars_min_height = bpy_mat["b4w_halo_stars_min_height"];

	    var ps = mat.physics_settings;
	    ps.use_coll_physics = bpy_mat["b4w_collision"];
	    ps.use_ghost = bpy_mat["b4w_use_ghost"];

	    ps.friction = bpy_mat["physics"]["friction"];
	    ps.elasticity = bpy_mat["physics"]["elasticity"];
	    ps.collision_id = bpy_mat["b4w_collision_id"];
	    ps.collision_margin = bpy_mat["b4w_collision_margin"];
	    ps.collision_group = bpy_mat["b4w_collision_group"];
	    ps.collision_mask = bpy_mat["b4w_collision_mask"];
	};

	exports.clone_material = function(mat) {

	    var new_mat = mat;

	    new_mat.name = mat.name;
	    new_mat.type = mat.type;
	    new_mat.uuid = mat.uuid; // need unique?

	    new_mat.use_nodes = mat.use_nodes;

	    // by link for now, raw bpy data anyway
	    new_mat.node_tree = mat.node_tree;
	    // by link for now, raw bpy data anyway
	    new_mat.texture_slots = mat.texture_slots.slice();

	    new_mat.blend_mode = mat.blend_mode;

	    new_mat.use_shadeless = mat.use_shadeless;
	    new_mat.use_transparency = mat.use_transparency;
	    new_mat.use_backface_culling = mat.use_backface_culling;
	    new_mat.use_tangent_shading = mat.use_tangent_shading;
	    new_mat.use_orco_tex_coord = mat.use_orco_tex_coord;
	    new_mat.use_vertex_color_paint = mat.use_vertex_color_paint;
	    new_mat.use_double_sided_lighting = mat.use_double_sided_lighting;

	    new_mat.do_not_render = mat.do_not_render;
	    new_mat.render_above_all = mat.render_above_all;

	    new_mat.is_lens_flares = mat.is_lens_flares;
	    new_mat.is_wettable = mat.is_wettable;
	    new_mat.is_refractive = mat.is_refractive;
	    new_mat.refr_bump = mat.refr_bump;
	        
	    new_mat.pass_index = mat.pass_index;
	    new_mat.offset_z = mat.offset_z;

	    new_mat.diffuse_shader = mat.diffuse_shader;
	    new_mat.diffuse_color.set(mat.diffuse_color);
	    new_mat.diffuse_intensity = mat.diffuse_intensity;
	    new_mat.diffuse_toon_size = mat.diffuse_toon_size;
	    new_mat.diffuse_toon_smooth = mat.diffuse_toon_smooth;
	    new_mat.roughness = mat.roughness;
	    new_mat.diffuse_fresnel = mat.diffuse_fresnel;
	    new_mat.diffuse_fresnel_factor = mat.diffuse_fresnel_factor;
	    new_mat.darkness = mat.darkness;
	    new_mat.alpha = mat.alpha;

	    new_mat.specular_shader = mat.specular_shader;
	    new_mat.specular_color.set(mat.specular_color);
	    new_mat.specular_intensity = mat.specular_intensity;
	    new_mat.specular_toon_size = mat.specular_toon_size;
	    new_mat.specular_toon_smooth = mat.specular_toon_smooth;
	    new_mat.specular_hardness = mat.specular_hardness;
	    new_mat.specular_ior = mat.specular_ior;
	    new_mat.specular_slope = mat.specular_slope;
	    new_mat.specular_alpha = mat.specular_alpha;

	    new_mat.emit = mat.emit;
	    new_mat.ambient = mat.ambient;

	    var wp = mat.water_settings;
	    var new_wp = new_mat.water_settings;

	    new_wp.is_water = wp.is_water;

	    new_wp.shore_smoothing = wp.shore_smoothing;
	    new_wp.absorb_factor = wp.absorb_factor;
	    new_wp.foam_factor = wp.foam_factor;

	    new_wp.shallow_col.set(wp.shallow_col);
	    new_wp.shore_col.set(wp.shore_col);
	    new_wp.shallow_col_fac = wp.shallow_col_fac;
	    new_wp.shore_col_fac = wp.shore_col_fac;

	    new_wp.fog_color = wp.fog_color;
	    new_wp.fog_density = wp.fog_density;

	    new_wp.sss_strength = wp.sss_strength;
	    new_wp.sss_width = wp.sss_width;
	    new_wp.norm_uv_velocity = wp.norm_uv_velocity;

	    // dynamic water surface settings
	    new_wp.is_dynamic = wp.is_dynamic;
	    new_wp.waves_height = wp.waves_height;
	    new_wp.waves_length = wp.waves_length;
	    new_wp.dst_noise_scale0 = wp.dst_noise_scale0;
	    new_wp.dst_noise_scale1 = wp.dst_noise_scale1;
	    new_wp.dst_noise_freq0 = wp.dst_noise_freq0;
	    new_wp.dst_noise_freq1 = wp.dst_noise_freq1;
	    new_wp.dir_min_shore_fac = wp.dir_min_shore_fac;
	    new_wp.dir_freq = wp.dir_freq;
	    new_wp.dir_noise_scale = wp.dir_noise_scale;
	    new_wp.dir_noise_freq = wp.dir_noise_freq;
	    new_wp.dir_min_noise_fac = wp.dir_min_noise_fac;
	    new_wp.dst_min_fac = wp.dst_min_fac;
	    new_wp.waves_hor_fac = wp.waves_hor_fac;

	    // generated mesh settings
	    new_wp.is_generated_mesh = wp.is_generated_mesh;
	    new_wp.num_cascads = wp.num_cascads;
	    new_wp.num_subdivs = wp.num_subdivs;
	    new_wp.detailed_dist = wp.detailed_dist;

	    // caustics settings
	    new_wp.enable_caust = wp.enable_caust;
	    new_wp.caust_scale = wp.caust_scale;
	    new_wp.caust_brightness = wp.caust_brightness;

	    var ts = mat.terrain_settings;
	    var new_ts = new_mat.terrain_settings;
	    new_ts.is_terrain = ts.is_terrain;
	    new_ts.dynamic_grass_size = ts.dynamic_grass_size;
	    new_ts.dynamic_grass_color = ts.dynamic_grass_color;

	    var rt = mat.raytrace_mirror;
	    var new_rt = new_mat.raytrace_mirror;
	    new_rt.reflect_factor = rt.reflect_factor;
	    new_rt.fresnel = rt.fresnel;
	    new_rt.fresnel_factor = rt.fresnel_factor;

	    var hs = mat.halo_settings;
	    var new_hs = new_mat.halo_settings;
	    new_hs.size = hs.size;
	    new_hs.hardness = hs.hardness;
	                
	    new_hs.rings_color.set(hs.rings_color);
	    new_hs.lines_color.set(hs.lines_color);
	    new_hs.ring_count = hs.ring_count;
	    new_hs.line_count = hs.line_count;
	    new_hs.star_tip_count = hs.star_tip_count;

	    new_hs.is_sky_stars = hs.is_sky_stars;
	    new_hs.stars_blend_height = hs.stars_blend_height;
	    new_hs.stars_min_height = hs.stars_min_height;
	        
	    var ps = mat.physics_settings;
	    var new_ps = new_mat.physics_settings;
	    new_ps.use_coll_physics = ps.use_coll_physics;
	    new_ps.use_ghost = ps.use_ghost;

	    new_ps.friction = ps.friction;
	    new_ps.elasticity = ps.elasticity;
	    new_ps.collision_id = ps.collision_id;
	    new_ps.collision_margin = ps.collision_margin;
	    new_ps.collision_group = ps.collision_group;
	    new_ps.collision_mask = ps.collision_mask;
	    
	    return new_mat;
	};

	}

	var int_material_factory = register("__material", Int_material);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Objects common functionality
	 * @name objects
	 * @namespace
	 * @exports exports as objects
	 */
	function Int_objects(ns, exports) {

	var m_anim       = int_animation_factory(ns);
	var m_batch      = int_batch_factory(ns);
	var m_bounds     = int_boundings_factory(ns);
	var m_cam        = int_camera_factory(ns);
	var m_cfg        = int_config_factory(ns);
	var m_cons       = int_constraints_factory(ns);
	var m_cont       = int_container_factory(ns);
	var m_geom       = int_geometry_factory(ns);
	var m_lights     = int_lights_factory(ns);
	var m_mat        = int_material_factory(ns);
	var m_nla        = int_nla_factory(ns);
	var m_nodemat    = int_nodemat_factory(ns);
	var m_obj_util   = int_obj_util_factory(ns);
	var m_particles  = int_particles_factory(ns);
	var m_phy        = int_physics_factory(ns);
	var m_print      = print_factory(ns);
	var m_primitives = int_primitives_factory(ns);
	var m_quat       = quat_factory(ns);
	var m_scenes     = int_scenes_factory(ns);
	var m_subs       = int_subscene_factory(ns);
	var m_sfx        = int_sfx_factory(ns);
	var m_tex        = int_textures_factory(ns);
	var m_time       = int_time_factory(ns);
	var m_trans      = int_transform_factory(ns);
	var m_tsr        = int_tsr_factory(ns);
	var m_util       = int_util_factory(ns);
	var m_vec3       = vec3_factory(ns);
	var m_armat      = int_armature_factory(ns);
	var m_anchors    = int_anchors_factory(ns);
	var m_render     = int_renderer_factory(ns);

	var cfg_def = m_cfg.defaults;
	var cfg_out = m_cfg.outlining;

	var DEBUG_DISABLE_STATIC_OBJS = false;

	var _all_objects = {"ALL": []};

	var _color_id_counter = 0;
	var _cube_refl_counter = 0;
	var _refl_plane_objs = [];
	var _outline_anim_objs = [];

	var _vec3_tmp = new Float32Array(3);
	var _quat_tmp = new Float32Array(4);

	var COLOR_ID_THRESHOLD = 3.0;
	var DATA_ID_ALL = -1;

	var LOD_TRANSITION_TIME = 0.4; //sec
	var LOD_HYST_INTERVAL_LIMIT_COEFF = 0.3;

	exports.GET_OBJECT_BY_NAME = 0;
	exports.GET_OBJECT_BY_DUPLI_NAME = 1;
	exports.GET_OBJECT_BY_DUPLI_NAME_LIST = 2;

	exports.DATA_ID_ALL = DATA_ID_ALL;

	exports.update = function(timeline, elapsed) {
	    // update outline objects first (no need for processing among other objs)
	    for (var i = 0; i < _outline_anim_objs.length; i++) {
	        var obj = _outline_anim_objs[i];
	        update_obj_outline_intensity(obj, timeline);
	        if (obj.render.outline_intensity)
	            request_scenes_outline(obj);
	    }

	    var armatures = _all_objects["ARMATURE"];
	    if (armatures)
	        // update bone constraints
	        for (var i = 0; i < armatures.length; i++) {
	            var armobj = armatures[i];
	            if (armobj.need_update_transform) {
	                m_trans.update_transform(armobj);
	                armobj.need_update_transform = false;
	            }
	        }
	};

	exports.set_outline_intensity = set_outline_intensity;
	function set_outline_intensity(obj, value) {
	    obj.render.outline_intensity = value;
	    request_scenes_outline(obj);
	}

	function request_scenes_outline(obj) {
	    var scenes_data = obj.scenes_data;
	    var obj_render = obj.render;
	    for (var i = 0; i < scenes_data.length; i++) {
	        var sc_data = scenes_data[i];
	        var scene = sc_data.scene;
	        var render = scene._render;
	        if (render.outline && obj_render.outline_intensity)
	            m_scenes.request_outline(scene);
	    }
	}

	exports.apply_outline_anim = function(obj, tau, T, N) {
	    var oa = obj.outline_animation;
	    oa.time_start = 0;
	    oa.outline_time = tau;
	    oa.period = T;
	    oa.relapses = N;

	    var ind = _outline_anim_objs.indexOf(obj);
	    if (ind == -1)
	        _outline_anim_objs.push(obj);
	};

	exports.clear_outline_anim = clear_outline_anim;
	function clear_outline_anim(obj) {
	    obj.render.outline_intensity = 0;

	    var ind = _outline_anim_objs.indexOf(obj);
	    if (ind != -1)
	        _outline_anim_objs.splice(ind, 1);
	}

	exports.create_object_from_bpy = function(bpy_obj, is_world) {

	    var name = is_world ? "%meta_world%" + bpy_obj["name"] : bpy_obj["name"];
	    var origin_name = is_world ? "%meta_world%" + bpy_obj["name"] : bpy_obj["origin_name"];
	    var type = is_world ? "WORLD" : bpy_obj["type"];


	    var obj = m_obj_util.create_object(name, type, origin_name);

	    if (obj.type == "MESH") {
	        for (var i = 0; i < bpy_obj["data"]["materials"].length; i++)
	            // NOTE: material was previously generated and written into the bpy 
	            // object
	            obj.materials.push(bpy_obj["data"]["materials"][i]);
	    }

	    for (var i = 0; i < bpy_obj._scenes.length; i++)
	        m_obj_util.append_scene_data(obj, bpy_obj._scenes[i]);

	    bpy_obj._object = obj;

	    if (is_world)
	        update_world(bpy_obj, obj);
	    else
	        update_object(bpy_obj, obj);

	    return obj;
	};

	/**
	 * Update object: updates b4w object from bpy object.
	 */
	function update_object(bpy_obj, obj) {

	    obj.uuid = bpy_obj["uuid"];
	    obj.is_meta = false;

	    obj.def_action_slots = bpy_obj._def_action_slots;
	    obj.is_dynamic = bpy_obj._is_dynamic;
	    obj.is_hair_dupli = bpy_obj._is_hair_dupli || false;

	    prepare_physics_settings(bpy_obj, obj);

	    if (obj.type === "MESH")
	        var render_type = obj.is_dynamic ? "DYNAMIC" : "STATIC";
	    else
	        var render_type = obj.type;

	    var render = obj.render = m_obj_util.create_render(render_type);

	    prepare_parenting_props(bpy_obj, obj);

	    var pos = bpy_obj["location"];
	    var scale = bpy_obj["scale"][0];
	    var rot = _quat_tmp;
	    m_util.quat_bpy_b4w(bpy_obj["rotation_quaternion"], rot);

	    m_trans.set_translation(obj, pos);
	    m_trans.set_rotation(obj, rot);
	    m_trans.set_scale(obj, scale);

	    obj.use_default_animation = bpy_obj["b4w_use_default_animation"];
	    obj.anim_behavior_def = m_anim.anim_behavior_bpy_b4w(bpy_obj["b4w_anim_behavior"]);

	    if (bpy_obj["b4w_object_tags"])
	        obj.metatags = {
	            title: bpy_obj["b4w_object_tags"]["title"],
	            description: bpy_obj["b4w_object_tags"]["description"],
	            category: bpy_obj["b4w_object_tags"]["category"]
	        };

	    obj.custom_prop = bpy_obj["b4w_custom_prop"];

	    if (bpy_obj["b4w_viewport_alignment"])
	        obj.viewport_alignment = {
	            alignment: bpy_obj["b4w_viewport_alignment"]["alignment"],
	            distance: bpy_obj["b4w_viewport_alignment"]["distance"]
	        };

	    render.hide = bpy_obj["b4w_hidden_on_load"];
	    render.hide_children = bpy_obj["b4w_hide_chldr_on_load"];

	    switch (bpy_obj["type"]) {
	    case "ARMATURE":
	        m_armat.update_object(bpy_obj, obj);
	        var bone_pointers = render.bone_pointers;
	        var pose_data = m_anim.calc_pose_data(bone_pointers);

	        if (bpy_obj["b4w_animation_mixing"]) {
	            render.quats_before = new Float32Array(pose_data.quats);
	            render.quats_after  = new Float32Array(pose_data.quats);
	            render.trans_before = new Float32Array(pose_data.trans);
	            render.trans_after  = new Float32Array(pose_data.trans);
	        } else {
	            render.quats_before = pose_data.quats;
	            render.quats_after  = pose_data.quats;
	            render.trans_before = pose_data.trans;
	            render.trans_after  = pose_data.trans;
	        }

	        // we need to recalculate bpointers' tsrs after pose is applied
	        // NOTE: need to find better realization
	        for (var bone_name in bone_pointers) {
	            var bpointer = bone_pointers[bone_name];
	            // do this only for root bones. They will update others
	            if (bpointer.chain.length == 1)
	                m_armat.update_bone_tsr_r(bpointer, true, pose_data.trans,
	                                                          pose_data.quats);
	        }

	        render.pose_data = pose_data;
	        render.frame_factor = 0;
	        render.anim_mixing = bpy_obj["b4w_animation_mixing"];
	        break;

	    case "MESH":
	        render.bb_original = m_batch.bb_bpy_to_b4w(bpy_obj["data"]["b4w_boundings"]["bb"]);
	        obj.is_boundings_overridden = bpy_obj["data"]["is_boundings_overridden"];
	        render.do_not_render = bpy_obj["b4w_do_not_render"];
	        render.selectable = cfg_out.outlining_overview_mode || bpy_obj["b4w_selectable"];
	        render.origin_selectable = bpy_obj["b4w_selectable"];

	        render.outlining = cfg_out.outlining_overview_mode || bpy_obj["b4w_outlining"];
	        render.origin_outlining = bpy_obj["b4w_outlining"];

	        render.outline_on_select = cfg_out.outlining_overview_mode || bpy_obj["b4w_outline_on_select"];

	        render.billboard = bpy_obj["b4w_billboard"];
	        render.billboard_pres_glob_orientation = bpy_obj["b4w_pres_glob_orientation"];
	        // set default object billboard type
	        render.billboard_type = "BASIC";
	        render.billboard_spherical = bpy_obj["b4w_billboard_geometry"] == "SPHERICAL";

	        var oa_set = render.outline_anim_settings_default;
	        oa_set.outline_duration = bpy_obj["b4w_outline_settings"]["outline_duration"],
	        oa_set.outline_period = bpy_obj["b4w_outline_settings"]["outline_period"],
	        oa_set.outline_relapses = bpy_obj["b4w_outline_settings"]["outline_relapses"];

	        if (render.selectable) {
	            // assign color id
	            render.color_id = m_util.gen_color_id(_color_id_counter);
	            _color_id_counter++;
	        }

	        prepare_vertex_anim(bpy_obj, obj);
	        prepare_shape_keys(bpy_obj, obj);

	        render.shadow_cast = bpy_obj["b4w_shadow_cast"];
	        render.shadow_receive = bpy_obj["b4w_shadow_receive"];
	        render.shadow_cast_only = bpy_obj["b4w_shadow_cast_only"]
	                && render.shadow_cast;

	        render.reflexible = bpy_obj["b4w_reflexible"];
	        render.reflexible_only = bpy_obj["b4w_reflexible_only"]
	                                 && render.reflexible;
	        render.reflective = bpy_obj["b4w_reflective"];
	        render.reflection_type = bpy_obj["b4w_reflection_type"];

	        // HACK: forcing cube reflections for cycles mats with bsdf_glossy
	        if (!render.reflective)
	            update_obj_bsdf_glossy_reflections(obj);

	        render.caustics = bpy_obj["b4w_caustics"];

	        render.wind_bending = bpy_obj["b4w_wind_bending"];
	        // improves batching
	        if (bpy_obj["b4w_wind_bending"]) {
	            render.wind_bending_angle = bpy_obj["b4w_wind_bending_angle"];
	            var amp = m_batch.wb_angle_to_amp(m_util.deg_to_rad(
	                    bpy_obj["b4w_wind_bending_angle"]),
	                    render.bb_original, bpy_obj["scale"][0]);
	            render.wind_bending_amp = amp;
	            render.wind_bending_freq   = bpy_obj["b4w_wind_bending_freq"];
	            render.detail_bending_freq = bpy_obj["b4w_detail_bending_freq"];
	            render.detail_bending_amp  = bpy_obj["b4w_detail_bending_amp"];
	            render.branch_bending_amp  = bpy_obj["b4w_branch_bending_amp"]; 

	            render.main_bend_col = bpy_obj["b4w_main_bend_stiffness_col"];
	            var bnd_st = bpy_obj["b4w_detail_bend_colors"];
	            render.detail_bend_col.leaves_stiffness = bnd_st["leaves_stiffness_col"];
	            render.detail_bend_col.leaves_phase = bnd_st["leaves_phase_col"];
	            render.detail_bend_col.overall_stiffness = bnd_st["overall_stiffness_col"];
	        }
	       
	        render.dynamic_geometry = bpy_obj["b4w_dynamic_geometry"];

	        // for material inheritance
	        if (render.dynamic_geometry) {
	            obj._bpy_obj = bpy_obj;

	            for (var i = 0; i < obj.materials.length; i++) {
	                var mat = obj.materials[i];
	                obj.mat_inheritance_data.original_mat_names.push(mat.name);
	                obj.mat_inheritance_data.is_disabled.push(false);
	            }
	        }

	        // assign params for object (bounding) physics simulation
	        // it seems BGE uses first material to get physics param
	        var first_mat = obj.materials[0];
	        render.friction = first_mat.physics_settings.friction;
	        render.elasticity = first_mat.physics_settings.elasticity;

	        render.lod_dist_min = 0;
	        render.lod_dist_max = m_obj_util.LOD_DIST_MAX_INFINITY;

	        render.pass_index = bpy_obj["pass_index"];
	        break;

	    case "LINE":
	        render.bb_local = m_bounds.create_bb();
	        render.be_local = m_bounds.create_be();
	        render.bb_world = m_bounds.create_bb();
	        render.be_world = m_bounds.create_be();
	        break;

	    case "CAMERA":
	        m_cam.camera_object_to_camera(bpy_obj, obj);
	        m_cam.assign_boundings(obj);
	        break;

	    case "LAMP":
	        m_lights.lamp_to_light(bpy_obj, obj);
	        break;

	    case "SPEAKER":
	        // SPEAKER object is attached only to the one(main) scene anyway
	        obj.sfx = m_sfx.create_sfx();
	        var is_enabled = false;
	        for (var i = 0; i < obj.scenes_data.length; i++)
	            if (obj.scenes_data[i].scene._sfx) {
	                is_enabled = true;
	                break;
	            }

	        if (is_enabled)
	            m_sfx.update_object(bpy_obj, obj);

	        break;

	    case "EMPTY":
	        // NOTE: center = 1/2 height
	        var bb = m_bounds.create_bb();
	        render.bb_local = bb;

	        var bs = m_bounds.create_bs();
	        render.bs_local = bs;

	        if (bpy_obj["field"])
	            obj.field = {
	                type: bpy_obj["field"]["type"],
	                strength: bpy_obj["field"]["strength"]
	            };

	        if (bpy_obj["b4w_anchor"])
	            obj.anchor = {
	                type: bpy_obj["b4w_anchor"]["type"],
	                detect_visibility: bpy_obj["b4w_anchor"]["detect_visibility"],
	                element_id: bpy_obj["b4w_anchor"]["element_id"],
	                max_width: bpy_obj["b4w_anchor"]["max_width"]
	            };
	        break;

	    default:
	        break;
	    }

	    objects_storage_add(obj);
	}

	function update_world(bpy_world, world) {
	    world.uuid = bpy_world["uuid"];
	    world.is_meta = false;

	    world.def_action_slots = bpy_world._def_action_slots;
	    world.is_dynamic = bpy_world._is_dynamic;

	    var render_type = world.type;
	    world.render = m_obj_util.create_render(render_type);

	    world.use_default_animation = bpy_world["b4w_use_default_animation"];
	    world.anim_behavior_def = m_anim.anim_behavior_bpy_b4w(bpy_world["b4w_anim_behavior"]);

	    objects_storage_add(world);
	}

	function update_obj_bsdf_glossy_reflections(obj) {
	    var materials = obj.materials;
	    for (var i = 0; i < materials.length; i++) {
	        var mat = materials[i];
	        if (mat.use_nodes && (check_bsdf_type(mat.node_tree, "BSDF_GLOSSY") 
	                || check_bsdf_type(mat.node_tree, "BSDF_DIFFUSE"))) {
	            obj.render.reflective = true;
	            obj.render.reflection_type = "CUBE";
	        }
	    }
	}

	function check_bsdf_type(node_tree, bsdf_type) {
	    if (node_tree._bsdf_types.indexOf(bsdf_type) != -1)
	        return true;
	    else
	        return false;
	}

	exports.update_object_relations = function(bpy_obj, obj) {
	    var render = obj.render;

	    if (obj.type == "MESH") {

	        // apply pose if any
	        var bpy_armobj = m_anim.get_bpy_armobj(bpy_obj);
	        if (bpy_armobj) {

	            var armobj = bpy_armobj._object;
	            var amr_pose_data = armobj.render.pose_data;

	            prepare_skinning_info(bpy_obj, obj, armobj);
	            var pose_data = m_anim.extract_skinned_pose_data(
	                                        amr_pose_data.trans,
	                                        amr_pose_data.quats,
	                                        render.bone_skinning_info);

	            if (bpy_armobj["b4w_animation_mixing"]) {
	                render.quats_before = new Float32Array(pose_data.quats);
	                render.quats_after  = new Float32Array(pose_data.quats);
	                render.trans_before = new Float32Array(pose_data.trans);
	                render.trans_after  = new Float32Array(pose_data.trans);
	            } else {
	                render.quats_before = pose_data.quats;
	                render.quats_after  = pose_data.quats;
	                render.trans_before = pose_data.trans;
	                render.trans_after  = pose_data.trans;
	            }

	            render.arm_rel_trans = new Float32Array(4);
	            render.arm_rel_quat = m_quat.create();
	            render.pose_data = pose_data;
	            render.frame_factor = 0;
	        }
	        if (render.reflective)
	            attach_reflection_data(bpy_obj, obj);
	    }
	};

	exports.update_force = update_force;
	function update_force(obj) {
	    if (obj.field) {
	        var scenes_data = obj.scenes_data;
	        for (var i = 0; i < scenes_data.length; i++) {
	            var scene = scenes_data[i].scene;
	            m_scenes.update_force_scene(scene, obj);
	        }
	    }
	}

	function attach_reflection_data(bpy_obj, obj) {
	    var render = obj.render;

	    if (render.reflection_type == "CUBE")
	        render.cube_reflection_id = _cube_refl_counter++;
	    else if (render.reflection_type == "PLANE") {

	        var refl_plane_obj = get_reflection_plane_obj(bpy_obj, obj);

	        if (!refl_plane_obj)
	            refl_plane_obj = create_default_refl_plane(obj);
	        
	        var refl_plane_id = null;
	        for (var i = 0; i < _refl_plane_objs.length; i++) {
	            var rp = _refl_plane_objs[i];
	            if (rp == refl_plane_obj) {
	                 refl_plane_id = i;
	                 break;
	            }
	        }

	        if (refl_plane_id == null) {
	            // we need only unique reflection planes
	            refl_plane_id = _refl_plane_objs.length;
	            _refl_plane_objs.push(refl_plane_obj);
	        }

	        refl_plane_obj.render.plane_reflection_id = refl_plane_id;
	        render.plane_reflection_id = refl_plane_id;
	        refl_plane_obj.reflective_objs.push(obj);
	    }
	}

	function create_default_refl_plane(obj) {
	    var unique_name = m_util.unique_name("%reflection%");
	    var reflection_plane = m_obj_util.create_object(unique_name, "EMPTY");

	    var render = m_obj_util.create_render("EMPTY");
	    reflection_plane.render = render;
	    copy_scene_data(obj, reflection_plane);
	    m_cons.append_stiff_obj(reflection_plane, obj, [0, 0, 0], null, 1);

	    objects_storage_add(reflection_plane);
	    return reflection_plane;
	}

	function get_reflection_plane_obj(bpy_obj, obj) {
	    var constraints = bpy_obj["constraints"];
	    for (var i = 0; i < constraints.length; i++) {
	        var cons = constraints[i];
	        if (cons["type"] == "LOCKED_TRACK" && cons.name == "REFLECTION PLANE") {
	            if (cons["target"] && cons["target"]._object)
	                return cons["target"]._object;
	            else
	                m_print.warn("Reflection plane target for object: \"" + obj.name +
	                    "\" is not present on the scene. Using object's Z-axis.");
	        }
	    }
	    return null;
	}

	exports.copy_scene_data = copy_scene_data;
	function copy_scene_data(from_obj, to_obj) {
	    var from_data = from_obj.scenes_data;
	    var to_data = to_obj.scenes_data;

	    for (var i = 0; i < from_data.length; i++) {
	        var is_already_attached = false;
	        for (var j = 0; j < to_data.length; j++) {
	            if (from_data[i].scene == to_data[j].scene) {
	                is_already_attached = true;
	                break;
	            }
	        }

	        if (!is_already_attached)
	            // filter unwanted objects
	            if (check_bpy_obj_scene_compatibility(to_obj, from_data[i].scene))
	                m_obj_util.append_scene_data(to_obj, from_data[i].scene);
	    }
	}

	exports.check_bpy_obj_scene_compatibility = check_bpy_obj_scene_compatibility;
	function check_bpy_obj_scene_compatibility(bpy_obj, bpy_scene) {
	    // SPEAKERs on secondary(rtt) scenes aren't allowed
	    if (!bpy_scene._is_main && bpy_obj["type"] == "SPEAKER")
	        return false;

	    // LAMPs aren't allowed if they are from secondary(dynamically loaded) data
	    if (!bpy_scene._is_primary_thread && bpy_obj["type"] == "LAMP")
	        return false;

	    return true;
	}

	exports.update_objects_dynamics = function(objects) {
	    for (var i = 0; i < objects.length; i++) {
	        var obj = objects[i];

	        if (obj.render && (obj.render.type == "DYNAMIC" ||
	                obj.render.type == "CAMERA"))
	            m_trans.update_transform(obj);

	        // try to use default animation
	        // TODO: remove default animation during nla setup
	        if (obj.use_default_animation && m_anim.obj_is_animatable(obj)) {
	            m_anim.apply_def(obj);
	            if (obj.anim_slots.length)
	                m_anim.play(obj, null, m_anim.SLOT_ALL);
	        }
	    }
	};

	exports.bpy_obj_is_dynamic = function(bpy_obj) {

	    // NOTE: need hierarhical objects structure here
	    if (bpy_obj["b4w_hidden_on_load"])
	        return true;
	    if (bpy_obj["dg_parent"] && bpy_obj["dg_parent"]._is_dynamic)
	        return true;
	    if (bpy_obj["parent"] && bpy_obj["parent"]._is_dynamic)
	        return true;

	    switch (bpy_obj["type"]) {
	    case "MESH":
	        return bpy_mesh_is_dynamic(bpy_obj);
	        break;
	    case "EMPTY":
	        return bpy_empty_is_dynamic(bpy_obj);
	        break;
	    default:
	        return true;
	        break;
	    }
	};

	function bpy_mesh_is_dynamic(bpy_obj) {
	    var is_animated = m_anim.bpy_mesh_empty_is_animatable(bpy_obj);
	    var has_do_not_batch = bpy_obj["b4w_do_not_batch"];
	    var is_collision = bpy_obj["b4w_collision"];
	    var is_vehicle_part = bpy_obj["b4w_vehicle"];
	    var is_floater_part = bpy_obj["b4w_floating"];
	    var is_character = bpy_obj["b4w_character"];
	    var dyn_grass_emitter = m_particles.has_dynamic_grass_particles(bpy_obj);
	    var has_nla = m_nla.bpy_obj_has_nla(bpy_obj);
	    var has_shape_keys = bpy_obj["data"]["b4w_shape_keys"].length > 0;
	    var has_dynamic_geometry = bpy_obj["b4w_dynamic_geometry"];

	    var has_dynamic_target = check_dynamic_target(bpy_obj);
	    return DEBUG_DISABLE_STATIC_OBJS || is_animated || has_do_not_batch
	            || is_collision || is_vehicle_part || has_shape_keys
	            || is_floater_part || dyn_grass_emitter || is_character
	            || has_nla || has_dynamic_geometry || has_dynamic_mat(bpy_obj)
	            || has_dynamic_target;
	}

	function check_dynamic_target(bpy_obj) {
	    // NOTE: currently we support only one constraint for object
	    var is_dynamic = false;
	    var len = bpy_obj["constraints"].length;
	    if (len) {
	        var last_constraint = null;
	        for (var i = len - 1; i >= 0; i--) {
	            var cons = bpy_obj["constraints"][i];
	            if (!(cons["type"] == "LOCKED_TRACK" && cons["name"] == "REFLECTION PLANE")) {
	                last_constraint = cons;
	                break;
	            }
	        }
	        if (!last_constraint)
	            return false;
	        // NOTE: temporary solution for old JSONs
	        if (!last_constraint["target"])
	            return false;
	        var target = last_constraint["target"];
	        var type = target["type"];
	        if (target["parent"]) {
	            var parent_type = target["parent"]["type"];
	            if (parent_type == "MESH")
	                is_dynamic = is_dynamic || bpy_mesh_is_dynamic(target["parent"]);
	            else if (parent_type == "EMPTY")
	                is_dynamic = is_dynamic || bpy_empty_is_dynamic(target["parent"]);
	            else
	                is_dynamic = true;
	            return is_dynamic;
	        }
	        if (type == "MESH") {
	            is_dynamic = is_dynamic || bpy_mesh_is_dynamic(target);
	        } else if (type == "EMPTY")
	            is_dynamic = is_dynamic || bpy_empty_is_dynamic(target);
	        else
	            is_dynamic = true;
	    }

	    return is_dynamic;
	}

	function bpy_empty_is_dynamic(bpy_obj) {
	    var is_animated = m_anim.bpy_mesh_empty_is_animatable(bpy_obj);
	    var has_nla = m_nla.bpy_obj_has_nla(bpy_obj);
	    var has_do_not_batch = bpy_obj["b4w_do_not_batch"];
	    var anchor = Boolean(bpy_obj["b4w_anchor"]);
	    var has_dynamic_target = check_dynamic_target(bpy_obj);
	    return is_animated || has_nla || has_do_not_batch || anchor
	            || has_dynamic_target;
	}

	function has_dynamic_mat(bpy_obj) {
	    var mesh = bpy_obj["data"];

	    // lens flares are not strictly required to be dynamic
	    // make them so to prevent possible bugs in the future

	    // water should be dynamic for convenience
	    // This allows dynamically adjusting water params

	    for (var i = 0; i < mesh["materials"].length; i++) {
	        var mat = mesh["materials"][i];

	        if (mat.water_settings.is_water)
	            return true;
	        if (mat.is_lens_flares)
	            return true;
	        if (has_dynamic_nodes(mat.node_tree))
	            return true;
	    }

	    return false;
	}

	function has_dynamic_nodes(node_tree) {
	    if (!node_tree)
	        return false;

	    var nodes = node_tree["nodes"];
	    for (var i = 0; i < nodes.length; i++) {
	        var node = nodes[i];
	        if (node["type"] == "VECT_TRANSFORM") {
	            var convert_from =  node["convert_from"];
	            var convert_to   =  node["convert_to"];
	            var output = node["outputs"][0];
	            if (output["is_linked"]
	                    && !(convert_from == "WORLD" && convert_to == "CAMERA")
	                    && !(convert_from == "CAMERA" && convert_to == "WORLD")
	                    && !(convert_from == "OBJECT" && convert_to == "OBJECT"))
	                return true;
	        }
	        if (node["type"] == "NORMAL_MAP") {
	            var space = node["space"];
	            var output = node["outputs"][0];
	            if (output["is_linked"] && (space == "OBJECT" || space == "BLENDER_OBJECT"))
	                return true;
	        }
	        if (node["type"] == "TEX_COORD") {
	            var obj_output = node["outputs"][3];
	            if (obj_output["is_linked"])
	                return true;
	        }
	        if (node["type"] == "OBJECT_INFO") {
	            // TODO: change this implementation to the attributes-based model
	            var loc_output = node["outputs"][0];
	            var obj_ind_output = node["outputs"][1];
	            var rand_output = node["outputs"][3];
	            if (loc_output["is_linked"] || obj_ind_output["is_linked"] ||
	                    rand_output["is_linked"]) {
	                return true;
	            }
	        }
	    }

	    return false;
	}

	/**
	 * Prepare skinning
	 *
	 * get info about relations between vertex groups and bones
	 * and save to mesh internals for using in buffers generation.
	 * Finally mark render to use skinning shaders
	 */
	function prepare_skinning_info(bpy_obj, obj, armobj) {

	    var render = obj.render;
	    var mesh = bpy_obj["data"];

	    obj.armobj = armobj;

	    var vertex_groups = mesh["vertex_groups"];
	    if (!vertex_groups.length)
	        return;

	    var arm_bone_pointers = armobj.render.bone_pointers;
	    var deform_bone_index = 0;
	    var bone_skinning_info = {};

	    // collect deformation bones
	    for (var bone_name in arm_bone_pointers) {
	        // bone is deform if it has corresponding vertex group
	        var vgroup = m_util.keysearch("name", bone_name, vertex_groups);
	        if (!vgroup)
	            continue;
	        var arm_bpointer = arm_bone_pointers[bone_name];

	        bone_skinning_info[bone_name] = {vgroup_index: vgroup["index"],
	                                         bone_index: arm_bpointer.bone_index,
	                                         deform_bone_index: deform_bone_index++};
	    }
	    render.bone_skinning_info = bone_skinning_info;

	    var num_bones = deform_bone_index;

	    // will be extended beyond this limit later
	    var max_bones = m_anim.get_max_bones();
	    render.max_bones = num_bones;

	    if (num_bones > 2 * max_bones) {
	        render.is_skinning = false;
	        m_print.error("too many bones for \"" + bpy_obj["name"] + "\" / " +
	                render.max_bones + " bones (max " + max_bones +
	                " with blending, " + 2 * max_bones + " without blending)." 
	                + " Skinning will be disabled.");
	    } else
	        render.is_skinning = true;
	}

	function prepare_shape_keys(bpy_obj, obj) {
	    if (bpy_obj["type"] != "MESH")
	        m_util.panic("Wrong object type: " + bpy_obj["name"]);

	    var render = obj.render;
	    if (bpy_obj["data"]["b4w_shape_keys"].length) {
	        render.use_shape_keys = true;
	        for (var i = 0; i < bpy_obj["data"]["b4w_shape_keys"].length; i++) {
	            var key = {};
	            key["value"] = bpy_obj["data"]["b4w_shape_keys"][i]["value"];
	            key["name"] = bpy_obj["data"]["b4w_shape_keys"][i]["name"];
	            render.shape_keys_values.push(key);
	        }

	    } else
	        render.use_shape_keys = false;
	}

	exports.get_meta_tags = function(obj) {
	    return m_util.clone_object_r(obj.metatags);
	};

	exports.get_custom_prop = function(obj) {
	    return obj.custom_prop;
	};

	exports.cleanup = function() {
	    _color_id_counter = 0;
	    _cube_refl_counter = 0;
	    _refl_plane_objs.length = 0;
	    _outline_anim_objs.length = 0;
	    _all_objects = {"ALL":[]};
	};

	exports.copy = function(obj, name, deep_copy) {
	    var new_obj = copy_object(obj, name, deep_copy);
	    new_obj.render.is_copied = true;
	    new_obj.render.is_copied_deep = deep_copy;
	    new_obj.render.color_id = m_util.gen_color_id(_color_id_counter);
	    _color_id_counter++;

	    return new_obj;
	};

	function get_name_suff_unique(name) {
	    if (get_object_by_name(name, _all_objects["ALL"], false, DATA_ID_ALL)) {
	        var i = 1;
	        var num;
	        while (true) {
	            num = "." + (String(i).length < 3 ? ("000" + String(i)).slice(-3) : String(i));
	            if(!get_object_by_name(name + num, _all_objects["ALL"], false,
	                    DATA_ID_ALL))
	                break;
	            i++;
	        }

	        m_print.error("Object \"" + name + "\" already exists. "
	                + "Name was replaced by \"" + name + num + "\".");
	        return num;
	    }

	    return "";
	}

	function copy_object(obj, new_name, deep_copy) {

	    var origin_name = new_name;
	    var dg_parent = m_obj_util.get_dg_parent(obj);
	    var name = dg_parent ? m_obj_util.gen_dupli_name(dg_parent.name, new_name) : new_name;

	    var suff = get_name_suff_unique(name);
	    name += suff;
	    origin_name += suff;

	    var new_obj = m_obj_util.create_object(name, obj.type, origin_name);

	    new_obj.is_meta = obj.is_meta;

	    // by link
	    new_obj._bpy_obj = obj._bpy_obj;

	    new_obj.mat_inheritance_data.original_mat_names 
	            = m_obj_util.copy_bpy_object_props_by_link(obj.mat_inheritance_data.original_mat_names);
	    new_obj.mat_inheritance_data.is_disabled 
	            = m_obj_util.copy_bpy_object_props_by_link(obj.mat_inheritance_data.is_disabled); 
	    
	    // NOTE: not all props are needed or supported for the copied object
	    new_obj.is_dynamic = obj.is_dynamic;
	    new_obj.is_hair_dupli = obj.is_hair_dupli;
	    new_obj.use_default_animation = obj.use_default_animation;
	    new_obj.def_action_slots = obj.def_action_slots;

	    new_obj.render = m_obj_util.clone_render(obj.render);

	    // do not preserve LOD functionality for copied objects
	    new_obj.render.is_lod = false;

	    new_obj.metatags = m_obj_util.copy_object_props_by_value(obj.metatags);
	    new_obj.custom_prop = m_obj_util.copy_object_props_by_value(obj.custom_prop);

	    copy_scene_data(obj, new_obj);
	    new_obj.action_anim_cache = m_obj_util.copy_bpy_object_props_by_link(obj.action_anim_cache);
	    
	    new_obj.parent = m_obj_util.copy_bpy_object_props_by_link(obj.parent);
	    new_obj.parent_is_dupli = obj.parent_is_dupli;
	    new_obj.parent_bone = obj.parent_bone;

	    new_obj.vertex_anim = m_obj_util.copy_bpy_object_props_by_link(obj.vertex_anim);
	    new_obj.anim_behavior_def = obj.anim_behavior_def;

	    // copied object can't be a vehicle, floater or character
	    if (obj.physics && !(obj.is_vehicle || obj.is_character 
	            || obj.is_floating)) {
	        new_obj.use_obj_physics = obj.use_obj_physics;
	        // NOTE: physics will be added later
	        new_obj.physics = null;
	    }

	    new_obj.collision_id = obj.collision_id;
	    new_obj.correct_bounding_offset = obj.correct_bounding_offset;

	    new_obj.physics_settings =
	            m_obj_util.copy_object_props_by_value(obj.physics_settings);

	    copy_batches(obj, new_obj, deep_copy);

	    for (var i = 0; i < obj.materials.length; i++)
	        new_obj.materials.push(m_mat.clone_material(obj.materials[i]));

	    // disable scene data for the new obj until appending it to the scene
	    m_obj_util.scene_data_set_active(new_obj, false);

	    objects_storage_add(new_obj);

	    return new_obj;
	}

	function copy_batches(obj, new_obj, deep_copy) {
	    var bpy_bufs_data = [];
	    for (var i = 0; i < obj.scenes_data.length; i++) {

	        var sc_data = obj.scenes_data[i];
	        var new_sc_data = new_obj.scenes_data[i];

	        var batches = sc_data.batches;

	        if (deep_copy) {
	            var new_batches = new_sc_data.batches;
	            for (var j = 0; j < batches.length; j++)
	                if (!batches[j].forked_batch) {
	                    var new_batch = m_obj_util.copy_object_props_by_value(batches[j]);
	                    new_batch.bufs_data = m_geom.clone_bufs_data(batches[j].bufs_data);
	                    m_obj_util.append_batch(new_obj, new_sc_data.scene, new_batch);
	                    bpy_bufs_data.push(batches[j].bufs_data);
	                }

	            for (var j = 0; j < batches.length; j++)
	                if (batches[j].forked_batch) {
	                    var new_forked_batch = m_obj_util.copy_object_props_by_value(batches[j]);
	                    m_obj_util.append_batch(new_obj, new_sc_data.scene, new_forked_batch);
	                    for (var k = 0; k < bpy_bufs_data.length; k++)
	                        if (bpy_bufs_data[k] == batches[j].bufs_data)
	                            new_forked_batch.bufs_data = new_batches[k].bufs_data;
	                }

	            for (var j = 0; j < new_batches.length; j++) {
	                if (new_batches[j].bufs_data)
	                    m_geom.update_gl_buffers(new_batches[j].bufs_data);

	                if (cfg_def.allow_vao_ext && new_batches[j].bufs_data)
	                    m_render.assign_vao(new_batches[j]);

	                // to create unique batch ID
	                new_batches[j].odd_id_prop = m_batch.generate_odd_id(
	                        new_batches[j], new_obj.render, new_obj.uuid);
	                m_batch.update_batch_id(new_batches[j]);
	            }

	            m_tex.share_batch_canvas_textures(new_batches);
	        } else
	            for (var j = 0; j < batches.length; j++)
	                m_obj_util.append_batch(new_obj, new_sc_data.scene, batches[j]);
	    }
	}

	function prepare_physics_settings(bpy_obj, obj) {

	    obj.is_vehicle = bpy_obj["b4w_vehicle"];
	    obj.is_character = bpy_obj["b4w_character"];
	    obj.is_floating = bpy_obj["b4w_floating"];
	    obj.use_obj_physics = bpy_obj["b4w_collision"];
	    obj.collision_id = bpy_obj["b4w_collision_id"];
	    obj.correct_bounding_offset = bpy_obj["b4w_correct_bounding_offset"];

	    var game = bpy_obj["game"];

	    obj.physics_settings = {
	        physics_type:           game["physics_type"],
	        use_ghost:              game["use_ghost"],
	        use_sleep:              game["use_sleep"],
	        mass:                   game["mass"],
	        velocity_min:           game["velocity_min"],
	        velocity_max:           game["velocity_max"],
	        damping:                game["damping"],
	        rotation_damping:       game["rotation_damping"],
	        lock_location_x:        game["lock_location_x"],
	        lock_location_y:        game["lock_location_y"],
	        lock_location_z:        game["lock_location_z"],
	        lock_rotation_x:        game["lock_rotation_x"],
	        lock_rotation_y:        game["lock_rotation_y"],
	        lock_rotation_z:        game["lock_rotation_z"],
	        collision_margin:       game["collision_margin"],
	        collision_group:        game["collision_group"],
	        collision_mask:         game["collision_mask"],
	        use_collision_bounds:   game["use_collision_bounds"],
	        collision_bounds_type:  game["collision_bounds_type"],
	        use_collision_compound: game["use_collision_compound"]
	    };

	    var vs = bpy_obj["b4w_vehicle_settings"];
	    if (vs)
	        obj.vehicle_settings = {
	            name: vs["name"],
	            part: vs["part"],
	            suspension_rest_length: vs["suspension_rest_length"],
	            suspension_compression: vs["suspension_compression"],
	            suspension_stiffness: vs["suspension_stiffness"],
	            suspension_damping: vs["suspension_damping"],
	            wheel_friction: vs["wheel_friction"],
	            roll_influence: vs["roll_influence"],
	            max_suspension_travel_cm: vs["max_suspension_travel_cm"],
	            force_max: vs["force_max"],
	            brake_max: vs["brake_max"],
	            steering_max: vs["steering_max"],
	            max_speed_angle: vs["max_speed_angle"],
	            delta_tach_angle: vs["delta_tach_angle"],
	            speed_ratio: vs["speed_ratio"],
	            steering_ratio: vs["steering_ratio"],
	            inverse_control: vs["inverse_control"],
	            floating_factor: vs["floating_factor"],
	            water_lin_damp: vs["water_lin_damp"],
	            water_rot_damp: vs["water_rot_damp"],
	            synchronize_position: vs["synchronize_position"]
	        };

	    var fs = bpy_obj["b4w_floating_settings"];
	    if (fs) 
	        obj.floating_settings = {
	            name: fs["name"],
	            part: fs["part"],
	            floating_factor: fs["floating_factor"],
	            water_lin_damp: fs["water_lin_damp"],
	            water_rot_damp: fs["water_rot_damp"],
	            synchronize_position: fs["synchronize_position"]
	        };

	    var cs = bpy_obj["b4w_character_settings"];
	    if (cs)
	        obj.character_settings = {
	            walk_speed: cs["walk_speed"],
	            run_speed: cs["run_speed"],
	            step_height: cs["step_height"],
	            jump_strength: cs["jump_strength"],
	            waterline: cs["waterline"]
	        };

	    for (var i = 0; i < bpy_obj["constraints"].length; i++) {
	        var cons = bpy_obj["constraints"][i];

	        if (cons["type"] != "RIGID_BODY_JOINT")
	            continue;

	        obj.physics_constraints.push({
	            target:              cons["target"]._object,
	            pivot_type:          cons["pivot_type"],
	            pivot_x:             cons["pivot_x"],
	            pivot_y:             cons["pivot_y"],
	            pivot_z:             cons["pivot_z"],
	            axis_x:              cons["axis_x"],
	            axis_y:              cons["axis_y"],
	            axis_z:              cons["axis_z"],
	            use_limit_x:         cons["use_limit_x"],
	            use_limit_y:         cons["use_limit_y"],
	            use_limit_z:         cons["use_limit_z"],
	            use_angular_limit_x: cons["use_angular_limit_x"],
	            use_angular_limit_y: cons["use_angular_limit_y"],
	            use_angular_limit_z: cons["use_angular_limit_z"],
	            limit_max_x:         cons["limit_max_x"],
	            limit_max_y:         cons["limit_max_y"],
	            limit_max_z:         cons["limit_max_z"],
	            limit_min_x:         cons["limit_min_x"],
	            limit_min_y:         cons["limit_min_y"],
	            limit_min_z:         cons["limit_min_z"],
	            limit_angle_max_x:   cons["limit_angle_max_x"],
	            limit_angle_max_y:   cons["limit_angle_max_y"],
	            limit_angle_max_z:   cons["limit_angle_max_z"],
	            limit_angle_min_x:   cons["limit_angle_min_x"],
	            limit_angle_min_y:   cons["limit_angle_min_y"],
	            limit_angle_min_z:   cons["limit_angle_min_z"]
	        });
	    }
	}

	exports.get_bpy_def_action_slots = function(bpy_obj, is_world) {
	    var def_action_slots = [];

	    var obj_anim_data = bpy_obj["animation_data"];
	    var data_anim_data = bpy_obj["data"] ? bpy_obj["data"]["animation_data"] : null;

	    if (obj_anim_data && obj_anim_data["action"]) {
	        var action = obj_anim_data["action"];

	        if (action._render.type == m_anim.OBJ_ANIM_TYPE_OBJECT ||
	                action._render.type == m_anim.OBJ_ANIM_TYPE_ARMATURE && bpy_obj["type"] == "ARMATURE" ||
	                action._render.type == m_anim.OBJ_ANIM_TYPE_LIGHT && bpy_obj["type"] == "LAMP" ||
	                action._render.type == m_anim.OBJ_ANIM_TYPE_ENVIRONMENT && is_world)
	            def_action_slots.push(m_anim.init_action_slot(null, action));
	    }

	    if (data_anim_data && data_anim_data["action"] && (bpy_obj["type"] == "SPEAKER"
	            || bpy_obj["type"] == "LAMP"))
	        def_action_slots.push(m_anim.init_action_slot(null,
	                                    data_anim_data["action"]));

	    // NOTE: nla material tracks are considered during the nla's object updating
	    // and aren't present in the def_action_slots property
	    if (bpy_obj["type"] == "MESH")
	        def_action_slots.push.apply(def_action_slots,
	                m_anim.get_bpy_material_actions(bpy_obj));
	    if (is_world)
	        def_action_slots.push.apply(def_action_slots,
	                m_anim.get_bpy_world_material_actions(bpy_obj));

	    return def_action_slots;
	};

	function prepare_vertex_anim(bpy_obj, obj) {
	    for (var i = 0; i < bpy_obj["data"]["b4w_vertex_anim"].length; i++) {
	        var va = bpy_obj["data"]["b4w_vertex_anim"][i];
	        obj.vertex_anim.push({
	            name: va["name"],
	            frame_start: va["frame_start"],
	            frame_end: va["frame_end"],
	            averaging: va["averaging"],
	            averaging_interval: va["averaging_interval"],
	            allow_nla: va["allow_nla"]
	        });
	    }

	    obj.render.vertex_anim = obj.vertex_anim.length ? true : false;
	}

	function prepare_parenting_props(bpy_obj, obj) {
	    if (bpy_obj["parent"]) {
	        obj.parent = bpy_obj["parent"]._object;

	        if (bpy_obj["parent_type"] == "BONE" &&
	                   bpy_obj["parent"]["type"] == "ARMATURE")
	            obj.parent_bone = bpy_obj["parent_bone"];

	        if (bpy_obj["pinverse_tsr"]) {
	            obj.pinverse_tsr = m_tsr.create();
	            m_tsr.copy(bpy_obj["pinverse_tsr"], obj.pinverse_tsr);
	        }
	    } else if (bpy_obj["dg_parent"]) {
	        obj.parent = bpy_obj["dg_parent"]._object;
	        obj.parent_is_dupli = true;
	    }
	}

	exports.update_boundings = function(obj) {
	    
	    var render = obj.render;
	    var obj_bb = null;

	    //TODO: process all scenes_data
	    var batches = obj.scenes_data[0].batches;
	    for (var i = 0; i < batches.length; i++) {

	        var batch = batches[i];
	        var batch_world_bounds = obj.scenes_data[0].batch_world_bounds[i];

	        if (!batch.bufs_data || !(batch_world_bounds.be && batch_world_bounds.bb))
	            continue;

	        var type = m_geom.get_vbo_type_by_attr_name("a_position");
	        var vbo_source = m_geom.get_vbo_source_by_type(batch.bufs_data.vbo_source_data, type);
	        if (!vbo_source)
	            continue;

	        var from = batch.bufs_data.pointers["a_position"].offset;
	        var to = batch.bufs_data.pointers["a_position"].length + from;
	        m_batch.update_local_bounds_from_pos(batch, vbo_source.subarray(from, to));
	        m_obj_util.update_world_bounds_from_batch_tsr(batch, render.world_tsr, 
	                batch_world_bounds);

	        if (batch.type == "MAIN") {
	            if (!obj_bb)
	                obj_bb = m_bounds.clone_bb(batch.bounds_local.bb);
	            else
	                m_bounds.expand_bounding_box(obj_bb, batch.bounds_local.bb);
	        }
	    }

	    obj_bb = obj_bb || m_bounds.create_bb();

	    if (render.billboard)
	        m_obj_util.update_render_bounds_billboard(obj, obj_bb);
	    else {
	        var pos_buffers = [];
	        for (var i = 0; i < batches.length; i++) {
	            var batch = batches[i];

	            if (batch.type != "MAIN")
	                continue;

	            var type = m_geom.get_vbo_type_by_attr_name("a_position");
	            var vbo_source = m_geom.get_vbo_source_by_type(batch.bufs_data.vbo_source_data, type);
	            if (!vbo_source)
	                continue;

	            var pointers = batches[i].bufs_data.pointers;
	            var from = pointers["a_position"].offset;
	            var to = pointers["a_position"].length + from;
	            pos_buffers.push(vbo_source.subarray(from, to));
	        }

	        m_obj_util.update_render_bounds_from_pos_arrays(obj, obj_bb, pos_buffers);
	    }

	    if (cfg_def.debug_view)
	        for (var i = 0; i < batches.length; i++) {
	            if (batches[i].type === "DEBUG_VIEW" && batches[i].debug_sphere) {
	                var be = render.be_local;
	                var submesh = m_primitives.generate_uv_sphere(16, 8, 1, be.center,
	                        false, false);
	                var scale = [be.axis_x[0], be.axis_y[1], be.axis_z[2]];
	                m_geom.scale_submesh_xyz(submesh, scale, be.center);
	                m_geom.submesh_drop_indices(submesh, 1, true);
	                submesh.va_common["a_polyindex"] = m_geom.extract_polyindices(submesh);
	                m_batch.update_batch_geometry(batches[i], submesh);
	                break;
	            }
	        }
	};

	exports.get_scene_objs = get_scene_objs;
	function get_scene_objs(scene, type, data_id) {
	    var objs_by_type = _all_objects[type] || [];
	    var objs = [];
	    for (var i = 0; i < objs_by_type.length; i++) {

	        var obj = objs_by_type[i];
	        if (obj.render.data_id != data_id && data_id != DATA_ID_ALL)
	            continue;

	        var scenes_data = obj.scenes_data;
	        for (var j = 0; j < scenes_data.length; j++) {
	            var sc_data = scenes_data[j];
	            if (sc_data.scene == scene)
	                objs.push(obj);
	        }
	    }
	    return objs;
	}

	/**
	 * Get all objects derived from the source bpy objects on a certain scene.
	 */
	exports.get_scene_objs_derived = function(scene, type, data_id) {
	    var objs_by_type = _all_objects[type] || [];
	    var objs = [];
	    for (var i = 0; i < objs_by_type.length; i++) {
	        var obj = objs_by_type[i];
	        if (obj.render.data_id != data_id && data_id != DATA_ID_ALL || obj.is_meta)
	            continue;

	        var scenes_data = obj.scenes_data;
	        for (var j = 0; j < scenes_data.length; j++) {
	            var sc_data = scenes_data[j];
	            if (sc_data.scene == scene)
	                objs.push(obj);
	        }
	    }
	    return objs;
	};

	exports.get_all_objects = get_all_objects;
	function get_all_objects(type, data_id) {
	    var all_objs = _all_objects[type] || [];
	    if (data_id == DATA_ID_ALL)
	        return all_objs;

	    var objs = [];
	    for (var i = 0; i < all_objs.length; i++) {
	        var obj = all_objs[i];
	        if (obj.render.data_id == data_id)
	            objs.push(obj);
	    }
	    return objs;
	}

	exports.get_first_character = function(scene) {

	    var mesh_objs = _all_objects["MESH"];
	    if (mesh_objs)
	        for (var i = 0; i < mesh_objs.length; i++) {
	            var obj = mesh_objs[i];

	            if (!m_phy.has_character_physics(obj))
	                continue;

	            var scenes_data = obj.scenes_data;

	            for (var j = 0; j < scenes_data.length; j++) {
	                var sc_data = scenes_data[j];
	                if (sc_data.scene == scene)
	                    return obj;
	            }
	        }

	    return null;
	};

	exports.obj_switch_cleanup_flags = obj_switch_cleanup_flags;
	function obj_switch_cleanup_flags(obj, cleanup_bufs, cleanup_shader, cleanup_nodemat) {
	    for (var i = 0; i < obj.scenes_data.length; i++) {
	        var batches = obj.scenes_data[i].batches;
	        for (var j = 0; j < batches.length; j++) {
	            var batch = batches[j];

	            // ibo/vbo buffs
	            if (batch.bufs_data)
	                batch.bufs_data.cleanup_gl_data_on_unload = cleanup_bufs;

	            // vao batch
	            batch.cleanup_gl_data_on_unload = cleanup_bufs;

	            // shader
	            if (batch.shader)
	                batch.shader.cleanup_gl_data_on_unload = cleanup_shader;

	            // nodemat graph
	            if (batch.ngraph_proxy_id !== "") {
	                var ngraph_proxy = m_nodemat.get_ngraph_proxy_cached(batch.ngraph_proxy_id);
	                if (ngraph_proxy)
	                    ngraph_proxy.cleanup_on_unload = cleanup_nodemat;
	            }
	        }
	    }
	}

	exports.get_selectable_objects = function() {
	    var sel_objects = [];
	    var objects = _all_objects["MESH"];
	    if (objects)
	        for (var i = 0; i < objects.length; i++) {
	            var obj = objects[i];
	            if (obj.render.selectable && !obj.is_meta)
	                sel_objects.push(obj);
	        }
	    return sel_objects;
	};

	exports.get_outlining_objects = function() {
	    var outlining_objects = [];
	    var objects = _all_objects["MESH"];
	    if (objects)
	        for (var i = 0; i < objects.length; i++) {
	            var obj = objects[i];
	            if (obj.render.outlining && !obj.is_meta)
	                outlining_objects.push(obj);
	        }
	    return outlining_objects;
	};

	exports.get_object = function() {
	    var obj_found = null;
	    var objs = _all_objects["ALL"];

	    // NOTE: filter meta is needed only for get_object_by_name, the others with 
	    // the parenting relations already don't work for meta objects
	    switch (arguments[0]) {
	    case exports.GET_OBJECT_BY_NAME:
	        obj_found = get_object_by_name(arguments[1], objs, true, arguments[2], 
	                arguments[3]);
	        break;
	    case exports.GET_OBJECT_BY_DUPLI_NAME:
	        obj_found = get_object_by_dupli_name(arguments[1], arguments[2], objs,
	                arguments[3]);
	        break;
	    case exports.GET_OBJECT_BY_DUPLI_NAME_LIST:
	        obj_found = get_object_by_dupli_name_list(arguments[1], objs, 
	                arguments[2]);
	        break;
	    default:
	        break;
	    }

	    return obj_found;
	};

	function get_object_by_name(name, objects, use_origin_name, data_id, filter_meta) {
	    var obj_found = null;

	    for (var i = 0; i < objects.length; i++) {
	        var obj = objects[i];
	        var obj_name = (use_origin_name) ? obj.origin_name : obj.name;
	        if (obj_name == name && (obj.render.data_id == data_id 
	                || data_id == DATA_ID_ALL) && (!filter_meta || !obj.is_meta)) {
	            obj_found = obj;

	            // NOTE: prefer non-duplicated object
	            if (!m_obj_util.get_dg_parent(obj_found))
	                break;
	        }
	    }

	    return obj_found;
	}

	function get_object_by_dupli_name(empty_name, dupli_name, objects, data_id) {
	    for (var i = 0; i < objects.length; i++) {
	        var obj = objects[i];
	        if (obj.origin_name == dupli_name && (obj.render.data_id == data_id 
	                || data_id == DATA_ID_ALL)) {
	            var dg_parent = m_obj_util.get_dg_parent(obj);
	            if (dg_parent && dg_parent.origin_name == empty_name)
	                return obj;
	        }
	    }

	    return null;
	}

	function get_object_by_dupli_name_list(name_list, objects, data_id) {
	    for (var i = 0; i < objects.length; i++) {
	        var obj = objects[i];
	        
	        var j = name_list.length - 1;
	        var curr_obj = obj;
	        var is_valid = true;
	        while (j >= 0 && is_valid) {
	            is_valid = curr_obj && (curr_obj.origin_name == name_list[j] 
	                    && (curr_obj.render.data_id == data_id || data_id == DATA_ID_ALL));
	            if (curr_obj)
	                curr_obj = m_obj_util.get_dg_parent(curr_obj);
	            j--;
	        }

	        // successfully iterated over the whole list && the object doesn't have further hierarchy
	        if (is_valid && !curr_obj)
	            return obj;
	    }
	    return null;
	}

	exports.get_world_by_name = function (name, data_id) {
	    var full_name = "%meta_world%" + name;
	    var wrds = _all_objects["WORLD"];
	    return get_object_by_name(full_name, wrds, true, data_id);
	};

	exports.get_world_name = function(world_obj) {
	    return world_obj.origin_name.replace("%meta_world%", "");
	};

	function update_obj_outline_intensity(obj, timeline) {
	    var outline_intensity = 0;
	    var oa = obj.outline_animation;
	    if (oa.time_start == 0)
	        oa.time_start = timeline;

	    var dt = timeline - oa.time_start;
	    if (oa.relapses && dt / oa.period >= oa.relapses) {
	        clear_outline_anim(obj);
	        return;
	    }

	    var periodic_time = dt % oa.period;
	    if (periodic_time < oa.outline_time) {
	        var outline_time = periodic_time / (oa.outline_time / 5);
	        var stage = Math.floor(outline_time);

	        switch (stage) {
	        case 0:
	            outline_intensity = (outline_time - stage) / 2;
	            break;
	        case 1:
	            outline_intensity = (outline_time - stage) / 2 + 0.5;
	            break;
	        case 2:
	            outline_intensity = 1;
	            break;
	        case 3:
	            outline_intensity = 1 - (outline_time - stage) / 2;
	            break;
	        case 4:
	            outline_intensity = 0.5 - (outline_time - stage) / 2;
	            break;
	        }
	    }
	    obj.render.outline_intensity = outline_intensity;
	}

	exports.pick_object = function(canvas_x, canvas_y) {

	    var main_scene = m_scenes.get_main();
	    if (!main_scene) {
	        m_print.error("No active scene");
	        return null;
	    }

	    var subs_stereo = m_scenes.get_subs(main_scene, m_subs.STEREO);
	    if (subs_stereo)
	        if (subs_stereo.enable_hmd_stereo) {
	            var canvas = m_cont.get_canvas();
	            canvas_x = canvas.clientHeight / 2;
	            canvas_y = canvas.clientWidth / 2;
	        }

	    var anchor = m_anchors.pick_anchor(canvas_x, canvas_y);

	    if (anchor)
	        return anchor;

	    var color = m_scenes.pick_color(main_scene, canvas_x, canvas_y);

	    if (!color)
	        return null;

	    // find objects having the same color
	    var sobjs = get_scene_objs(main_scene, "MESH", DATA_ID_ALL);
	    for (var i = 0; i < sobjs.length; i++) {
	        var render = sobjs[i].render;
	        var color_id = render.color_id;
	        if (color_id) {
	            if (Math.abs(255 * color_id[0] - color[0]) < COLOR_ID_THRESHOLD &&
	                    Math.abs(255 * color_id[1] - color[1]) < COLOR_ID_THRESHOLD &&
	                    Math.abs(255 * color_id[2] - color[2]) < COLOR_ID_THRESHOLD) {

	                if (render.outlining && render.outline_on_select) {
	                    if (cfg_out.outlining_overview_mode)
	                        exports.apply_outline_anim(sobjs[i], cfg_out.outline_duration,
	                                cfg_out.outline_period, cfg_out.outline_relapses);
	                    else {
	                        var oa_set = render.outline_anim_settings_default;
	                        exports.apply_outline_anim(sobjs[i], oa_set.outline_duration,
	                                oa_set.outline_period, oa_set.outline_relapses);
	                    }
	                }
	                return sobjs[i];
	            }
	        }
	    }

	    return null;
	};

	exports.set_wind_params = function(scene, wind_params) {

	    // TODO: Consider rewriting this method. All 3 axes needed.
	    // Wind should be controlled by wind objects transformation.

	    // get wind object
	    var objs = get_scene_objs(scene, "EMPTY", DATA_ID_ALL);
	    for (var i = 0; i < objs.length; i++) {
	        var obj = objs[i];
	        if (obj.field && obj.field.type === "WIND") {
	            var wind_obj = obj;
	            break;
	        }
	    }

	    if (!wind_obj) {
	        m_print.error("There is no wind on the scene");
	        return 0;
	    }

	    if (typeof wind_params.wind_dir == "number") {
	        var angle =  m_util.deg_to_rad(wind_params.wind_dir);
	        m_vec3.set(Math.sin(angle), -Math.cos(angle), 0, _vec3_tmp);
	        m_util.dir_to_quat(_vec3_tmp, m_util.AXIS_Z, _quat_tmp);

	        m_trans.set_rotation(wind_obj, _quat_tmp);
	    }

	    if (typeof wind_params.wind_strength == "number") {
	        wind_obj.field.strength = wind_params.wind_strength;
	    }
	    update_force(wind_obj);
	};

	exports.remove_object = function(obj) {
	    if (m_cons.check_constraint(obj))
	        m_cons.remove(obj);
	    objects_storage_remove(obj);
	};

	exports.objects_storage_add = objects_storage_add;
	function objects_storage_add(obj) {
	    _all_objects["ALL"].push(obj);

	    if(!_all_objects[obj.type])
	        _all_objects[obj.type] = [];

	    _all_objects[obj.type].push(obj);

	    var plane_refl_id = obj.render.plane_reflection_id;

	    if (plane_refl_id != null)
	        for (var i = 0; i < _refl_plane_objs.length; i++) {
	            var refl_plane = _refl_plane_objs[i];
	            if (refl_plane.render.plane_reflection_id == plane_refl_id) {
	                refl_plane.reflective_objs.push(obj);
	            }
	        }
	}

	function objects_storage_remove(obj) {
	    var all_objs = _all_objects["ALL"];
	    var typed_objs = _all_objects[obj.type];
	    var ind_all = all_objs.indexOf(obj);
	    var ind_typed = typed_objs.indexOf(obj);

	    if (ind_all != -1)
	        all_objs.splice(ind_all, 1);
	    if (ind_typed != -1)
	        typed_objs.splice(ind_typed, 1);
	}

	exports.objects_storage_check = function(obj) {
	    return _all_objects[obj.type] && _all_objects[obj.type].indexOf(obj) > -1;
	};

	exports.update_lod_scene = function(lod_obj, scene) {
	    var render = lod_obj.render;
	    if (render.is_lod)
	        init_obj_lod_settings(lod_obj, scene);
	};

	/**
	 * uses _vec3_tmp
	 * @returns {boolean} Is LOD visible or not.
	 */
	exports.update_lod_visibility = update_lod_visibility;
	function update_lod_visibility(batch, obj_render, eye) {
	    // NOTE: accessing elements from a TypedArray in this function can lead to a 
	    // serious performance drop in Chrome - may be a bug or an unclear 
	    // deoptimization in V8

	    if (!obj_render.is_lod)
	        return true;

	    var lod_set = batch.lod_settings;

	    if (lod_set.dest_coverage != lod_set.coverage) {
	        if (lod_set.use_smoothing) {
	            var sign = m_util.sign(lod_set.dest_coverage - lod_set.coverage);
	            lod_set.coverage += sign * m_time.get_delta() / LOD_TRANSITION_TIME;
	            lod_set.coverage = m_util.clamp(lod_set.coverage, 0, 1);
	        } else 
	            lod_set.coverage = lod_set.dest_coverage;
	    }

	    if (obj_render.type == "STATIC")
	        var center = obj_render.lod_center;
	    else {
	        // DYNAMIC objects should use bs_world, because it is constantly 
	        // updated unlike the lod_center property
	        var center = m_vec3.add(obj_render.bs_world.center, 
	                obj_render.main_lod_offset, _vec3_tmp);
	    }

	    var dist = m_vec3.dist(center, eye);
	    if (lod_set.hyst_prev_state == 0) {
	        var d_min = Math.max(obj_render.lod_dist_min - lod_set.hyst_interval_min / 2, 0);
	        var d_max = obj_render.lod_dist_max + lod_set.hyst_interval_max / 2;
	    } else if (lod_set.hyst_prev_state == -1) {
	        var d_min = obj_render.lod_dist_min + lod_set.hyst_interval_min / 2;
	        var d_max = obj_render.lod_dist_max + lod_set.hyst_interval_max / 2;
	    } else {
	        var d_min = Math.max(obj_render.lod_dist_min - lod_set.hyst_interval_min / 2, 0);
	        var d_max = Math.max(obj_render.lod_dist_max - lod_set.hyst_interval_max / 2, 0);
	    }

	    if (dist < d_min)
	        lod_set.hyst_prev_state = -1;
	    else if (dist < d_max)
	        lod_set.hyst_prev_state = 0;
	    else
	        lod_set.hyst_prev_state = 1;

	    lod_set.dest_coverage = (dist < d_min || dist > d_max) ? 0: 1;
	    lod_set.cmp_logic = lod_set.dest_coverage == 0 ? -1: 1;

	    if (Math.abs(dist - lod_set.prev_dist) > cfg_def.lod_leap_smooth_threshold 
	            && (lod_set.coverage == 0 || lod_set.coverage == 1))
	        lod_set.coverage = lod_set.dest_coverage;

	    lod_set.prev_dist = dist;

	    return lod_set.dest_coverage != 0 || lod_set.coverage != 0;
	}

	/**
	 * uses _vec3_tmp
	 */
	function init_obj_lod_settings(obj, scene) {
	    var obj_render = obj.render;
	    var sc_render = scene._render;

	    if (obj_render.is_lod) {
	        var cam_eye = m_trans.get_translation(scene._camera, _vec3_tmp);
	        for (var i = 0; i < obj.scenes_data.length; i++)
	            if (obj.scenes_data[i].scene == scene)
	                for (var j = 0; j < obj.scenes_data[i].batches.length; j++) {
	                    var batch = obj.scenes_data[i].batches[j];
	                    var lod_set = batch.lod_settings;

	                    // if SHADOW RECEIVE depth is not reused then we don't need
	                    // smoothing discard in the SHADOW RECEIVE shader
	                    var disable_smoothing = batch.type == "SHADOW" 
	                            && batch.subtype == "RECEIVE" 
	                            && !cfg_def.reuse_depth_optimization;

	                    if (cfg_def.lod_smooth_transitions && !disable_smoothing) {
	                        var sm_type = sc_render.lod_smooth_type;
	                        if (sm_type == "ALL" || sm_type == "NON-OPAQUE" 
	                                && (batch.blend || batch.alpha_clip))
	                            lod_set.use_smoothing = true;
	                    }
	                    
	                    update_lod_visibility(batch, obj_render, cam_eye);
	                    lod_set.coverage = lod_set.dest_coverage;

	                    // hysteresis interval limit depends on the lengths of the lod levels
	                    lod_set.hyst_interval_min = Math.min(sc_render.lod_hyst_interval, 
	                            2 * LOD_HYST_INTERVAL_LIMIT_COEFF * obj_render.lod_lower_border_range);
	                    lod_set.hyst_interval_max = Math.min(sc_render.lod_hyst_interval, 
	                            2 * LOD_HYST_INTERVAL_LIMIT_COEFF * obj_render.lod_upper_border_range);
	                }
	    }
	}

	exports.set_hair_particles_wind_bend_params = function(obj) {
	    var render = obj.render;
	    var amp         = render.wind_bending_amp;
	    var main_freq   = render.wind_bending_freq;
	    var detail_freq = render.detail_bending_freq;
	    var detail_amp  = render.detail_bending_amp;
	    var branch_amp  = render.branch_bending_amp;

	    var scenes_data = obj.scenes_data;
	    for (var i = 0; i < scenes_data.length; i++) {
	        var batches = scenes_data[i].batches;
	        for (var j = 0; j < batches.length; j++) {
	            var batch = batches[j];
	            var bufs_data = batch.bufs_data;
	            var pointers = bufs_data.pointers;
	            var ma_pointer = pointers["au_wind_bending_amp"];
	            var mf_pointer = pointers["au_wind_bending_freq"];
	            var da_pointer = pointers["au_detail_bending_amp"];
	            var df_pointer = pointers["au_detail_bending_freq"];
	            var ba_pointer = pointers["au_branch_bending_amp"];

	            if (mf_pointer) {
	                var data = Array.apply(null, Array(mf_pointer.length)).map(function(){return main_freq});
	                m_geom.update_gl_buffer_sub_data(bufs_data, m_geom.VBO_FLOAT, new Float32Array(data), mf_pointer.offset);
	            }
	            if (ma_pointer) {
	                var data = Array.apply(null, Array(ma_pointer.length)).map(function(){return amp});
	                m_geom.update_gl_buffer_sub_data(bufs_data, m_geom.VBO_FLOAT, new Float32Array(data), ma_pointer.offset);
	            }
	            if (da_pointer) {
	                var data = Array.apply(null, Array(da_pointer.length)).map(function(){return detail_amp});
	                m_geom.update_gl_buffer_sub_data(bufs_data, m_geom.VBO_FLOAT, new Float32Array(data), da_pointer.offset);
	            }
	            if (df_pointer) {
	                var data = Array.apply(null, Array(df_pointer.length)).map(function(){return detail_freq});
	                m_geom.update_gl_buffer_sub_data(bufs_data, m_geom.VBO_FLOAT, new Float32Array(data), df_pointer.offset);
	            }
	            if (ba_pointer) {
	                var data = Array.apply(null, Array(ba_pointer.length)).map(function(){return branch_amp});
	                m_geom.update_gl_buffer_sub_data(bufs_data, m_geom.VBO_FLOAT, new Float32Array(data), ba_pointer.offset);
	            }
	        }
	    }
	};

	exports.inherit_material = function(obj_from, mat_from_name, obj_to, mat_to_name) {

	    // NOTE: temporary backward compatibility for old unreexported INHERIT_MAT nodes
	    if (!obj_from.render.dynamic_geometry || !obj_to.render.dynamic_geometry)
	        return;

	    // gather some information before inheritance
	    var main_batch_from = m_batch.find_batch_material(obj_from, mat_from_name, "MAIN");
	    var psys_dict = null;
	    var psys_cb = function(batch) {
	        if (!psys_dict)
	            psys_dict = {};
	        if (batch.particles_data)
	            psys_dict[batch.particles_data.name] = batch.particles_data;
	    };
	    m_batch.iterate_batches_by_mat(obj_to, mat_to_name, psys_cb, "PARTICLES");

	    // prepare "to" object
	    var old_link_to_obj = process_inherit_obj_before(obj_to, mat_to_name);

	    // prepare materials 
	    var old_bpy_mat_name = process_inherit_bpy_mat_before(obj_from, 
	            mat_from_name, obj_to, mat_to_name);

	    var curr_active_scene = m_scenes.get_active();
	    for (var i = 0; i < obj_to.scenes_data.length; i++) {
	        var scene = obj_to.scenes_data[i].scene;
	        m_scenes.set_active(scene);

	        var lamps = get_scene_objs(scene, "LAMP", 0);
	        var existed_batches = obj_to.scenes_data[i].batches;
	        obj_to.scenes_data[i].batches = [];
	        obj_to.scenes_data[i].batch_world_bounds = [];

	        m_batch.generate_main_batches(scene, [obj_to._bpy_obj], lamps, []);
	        m_batch.create_forked_batches(obj_to, m_scenes.get_graph(scene), scene);

	        m_scenes.assign_scene_data_subs(scene, [obj_to]);
	        m_scenes.append_object(scene, obj_to, false, true);

	        for (var j = 0; j < existed_batches.length; j++)
	            m_obj_util.append_batch(obj_to, scene, existed_batches[j]);
	    }

	    // revert materials
	    process_inherit_bpy_mat_after(obj_from, mat_from_name, obj_to, old_bpy_mat_name);

	    // revert "to" object
	    process_inherit_obj_after(obj_to, old_link_to_obj);

	    recover_batch_state(obj_to, mat_to_name, obj_from, psys_dict, main_batch_from);

	    m_scenes.set_active(curr_active_scene);
	};

	function process_inherit_obj_before(obj_to, mat_to_name) {
	    // delete old batches
	    obj_switch_cleanup_flags(obj_to, true, false, true);
	    var objs = get_all_objects("ALL", DATA_ID_ALL);
	    for (var i = 0; i < objs.length; i++) {
	        var obj = objs[i];
	        if (obj != obj_to)
	            obj_switch_cleanup_flags(obj, false, false, false);
	    }

	    m_scenes.remove_object_bundles(obj_to, mat_to_name);
	    for (var i = 0; i < obj_to.scenes_data.length; i++)
	        for (var j = obj_to.scenes_data[i].batches.length - 1; j >= 0; j--) {
	            var batch = obj_to.scenes_data[i].batches[j];
	            if (batch.material_names.length == 0 
	                    || batch.material_names.indexOf(mat_to_name) != -1)
	                m_obj_util.scene_data_remove_batch(obj_to.scenes_data[i], j);
	        }
	    if (m_phy.obj_has_physics(obj_to))
	        m_phy.remove_object(obj_to);

	    for (var i = 0; i < objs.length; i++)
	        if (objs[i] != obj_to)
	            obj_switch_cleanup_flags(objs[i], true, true, true);

	    m_anim.delete_cached_anim_data_by_mat(obj_to, mat_to_name);

	    //NOTE: copied objects don't have their bpy objects referenced to them;
	    // important for batching
	    var old_link_to_obj = obj_to._bpy_obj._object;
	    obj_to._bpy_obj._object = obj_to;
	    return old_link_to_obj;
	}

	function process_inherit_obj_after(obj_to, old_link_to_obj) {
	    obj_to._bpy_obj._object = old_link_to_obj;
	    obj_switch_cleanup_flags(obj_to, true, true, true);
	}

	function process_inherit_bpy_mat_before(obj_from, mat_from_name, obj_to, mat_to_name) {
	    var bpy_mat_from_index = obj_from.mat_inheritance_data.original_mat_names.indexOf(mat_from_name);
	    var bpy_mat_to_index = obj_to.mat_inheritance_data.original_mat_names.indexOf(mat_to_name);
	    var bpy_mat_from = obj_from.materials[bpy_mat_from_index];

	    // store a new material for the object
	    obj_to.materials[bpy_mat_to_index] = bpy_mat_from;

	    // NOTE: assign proper name to keep it in batch.material_names
	    var old_bpy_mat_name = bpy_mat_from.name;
	    bpy_mat_from.name = mat_to_name;

	    // NOTE: prevent excessive batching through disabling the corresponding 
	    // materials
	    for (var i = 0; i < obj_to.materials.length; i++)
	        obj_to.mat_inheritance_data.is_disabled[i] = !(i == bpy_mat_to_index);

	    return old_bpy_mat_name;
	}

	function process_inherit_bpy_mat_after(obj_from, mat_from_name, obj_to, old_bpy_mat_name) {
	    // enable all bpy materials
	    for (var i = 0; i < obj_to.materials.length; i++)
	        obj_to.mat_inheritance_data.is_disabled[i] = false;

	    // revert old name of the inherited bpy material
	    var bpy_mat_from_index = obj_from.mat_inheritance_data.original_mat_names.indexOf(mat_from_name);
	    obj_from.materials[bpy_mat_from_index].name = old_bpy_mat_name;
	}

	function recover_batch_state(obj_to, mat_to_name, obj_from, psys_dict, main_batch_from) {

	    // update shape keys
	    for (var i = 1; i < obj_to.render.shape_keys_values.length; i++) {
	        var name = obj_to.render.shape_keys_values[i]["name"];
	        var val = obj_to.render.shape_keys_values[i]["value"];
	        m_geom.apply_shape_key(obj_to, name, val);
	    }

	    // update animations
	    if (m_anim.is_animated(obj_to))
	        for (var i = 0; i < obj_to.anim_slots.length; i++) {
	            var slot = obj_to.anim_slots[i];
	            if (slot)
	                switch (slot.type) {
	                // update particle emission animations
	                case m_anim.OBJ_ANIM_TYPE_PARTICLES:
	                    var frame = m_anim.get_current_frame_float(obj_to, i);
	                    m_anim.set_frame(obj_to, frame, i);
	                    break;

	                // remove old batches from material animations
	                case m_anim.OBJ_ANIM_TYPE_MATERIAL:
	                    if (slot.node_batches)
	                        for (var j = slot.node_batches.length - 1; j >= 0; j--) {
	                            var batch = slot.node_batches[j];
	                            if (batch.material_names.indexOf(mat_to_name) != -1)
	                                slot.node_batches.splice(j, 1);
	                        }
	                    break;
	                }
	        }

	    // update particles data
	    if (psys_dict) {
	        var psys_cb = function(batch) {
	            if (batch.particles_data) {
	                var name = batch.particles_data.name;
	                if (psys_dict[name]) {
	                    var need_factor_update = batch.particles_data.count_factor 
	                            != psys_dict[name].count_factor;

	                    batch.particles_data = m_particles.clone_particles_data(psys_dict[name]);

	                    if (need_factor_update)
	                        m_particles.set_factor(obj_to, name, 
	                                batch.particles_data.count_factor);
	                }
	            }
	        };
	        m_batch.iterate_batches_by_mat(obj_to, mat_to_name, psys_cb, "PARTICLES");
	    }

	    // update batch properties, that can be changed via API on the source batch
	    if (main_batch_from) {
	        var main_batch_to = m_batch.find_batch_material(obj_to, mat_to_name, "MAIN");
	        if (main_batch_to) {
	            // common stack params
	            main_batch_to.diffuse_color.set(main_batch_from.diffuse_color);
	            main_batch_to.diffuse_intensity = main_batch_from.diffuse_intensity;
	            main_batch_to.diffuse_color_factor = main_batch_from.diffuse_color_factor;
	            main_batch_to.diffuse_params.set(main_batch_from.diffuse_params);

	            main_batch_to.specular_color.set(main_batch_from.specular_color);
	            main_batch_to.specular_color_factor = main_batch_from.specular_color_factor;
	            main_batch_to.specular_params.set(main_batch_from.specular_params);
	            main_batch_to.specular_alpha = main_batch_from.specular_alpha;

	            main_batch_to.emit = main_batch_from.emit;
	            main_batch_to.ambient = main_batch_from.ambient;

	            main_batch_to.alpha_factor = main_batch_from.alpha_factor;
	            main_batch_to.mirror_factor = main_batch_from.mirror_factor;
	            main_batch_to.normal_factor = main_batch_from.normal_factor;
	            main_batch_to.reflect_factor = main_batch_from.reflect_factor;
	            main_batch_to.refr_bump = main_batch_from.refr_bump;
	            main_batch_to.fresnel_params.set(main_batch_from.fresnel_params);

	            main_batch_to.parallax_scale = main_batch_from.parallax_scale;
	            main_batch_to.texture_scale.set(main_batch_from.texture_scale);

	            main_batch_to.shallow_water_col.set(main_batch_from.shallow_water_col);
	            main_batch_to.shallow_water_col_fac = main_batch_from.shallow_water_col_fac;
	            main_batch_to.shore_water_col.set(main_batch_from.shore_water_col);
	            main_batch_to.shore_water_col_fac = main_batch_from.shore_water_col_fac;
	            main_batch_to.foam_factor = main_batch_from.foam_factor;
	            main_batch_to.water_norm_uv_velocity = main_batch_from.water_norm_uv_velocity;

	            // Value/RGB nodes
	            main_batch_to.node_values = main_batch_from.node_values.slice();
	            main_batch_to.node_rgbs = main_batch_from.node_rgbs.slice();
	        }
	    }

	    // transfer possibly changed textures
	    var tex_cb = function(batch) {
	        for (var i = 0; i < batch.bpy_tex_names.length; i++) {
	            var tex_name = batch.bpy_tex_names[i];
	            var tex_to = batch.textures[i];

	            if (tex_to.source != "IMAGE" && tex_to.source != "ENVIRONMENT")
	                continue;

	            var tex_from = m_tex.get_texture_by_name(obj_from, tex_name);
	            // tex_from can be null if the source object has "do_not_render" flag
	            if (!tex_from || tex_to.img_full_filepath == tex_from.img_full_filepath)
	                continue;

	            m_tex.set_texture_by_name(obj_to, tex_name, tex_from);
	        }
	    };
	    m_batch.iterate_batches_by_mat(obj_to, mat_to_name, tex_cb);
	}

	// CHECK
	exports.create_line = function(name) {
	    name = name || "";

	    name += get_name_suff_unique(name);

	    var line = m_obj_util.create_object(name, "LINE");

	    line.render = m_obj_util.create_render("EMPTY");

	    line.is_dynamic = true;

	    m_batch.generate_line_batches(m_scenes.get_main(), [line]);

	    m_scenes.append_object(m_scenes.get_main(), line);

	    objects_storage_add(line);

	    return line;
	};

	exports.generate_mesh_render_boundings = function(bpy_obj, obj) {
	    var render = obj.render;
	    var bb_local = m_bounds.clone_bb(render.bb_original);

	    if (render.billboard)
	        m_obj_util.update_render_bounds_billboard(obj, bb_local);
	    else
	        m_obj_util.update_render_bounds_from_bpy(obj, bb_local, 
	                bpy_obj["data"]["b4w_boundings"]);
	};

	exports.set_nodemat_value = function(obj, mat_name, ind, value) {
	    var is_world = m_obj_util.is_world(obj);

	    for (var i = 0; i < obj.scenes_data.length; i++) {
	        var batches = obj.scenes_data[i].batches;
	        for (var j = 0; j < batches.length; j++) {
	            var batch = batches[j];
	            if (!is_world && batch.material_names.indexOf(mat_name) == -1)
	                continue;

	            batch.node_values[ind] = value;
	        }
	    }

	    if (is_world)
	        m_scenes.update_sky_texture(obj);
	};

	exports.set_nodemat_rgb = function(obj, mat_name, ind, r, g, b) {
	    var is_world = m_obj_util.is_world(obj);

	    for (var i = 0; i < obj.scenes_data.length; i++) {
	        var batches = obj.scenes_data[i].batches;
	        for (var j = 0; j < batches.length; j++) {
	            var batch = batches[j];
	            if (!is_world && batch.material_names.indexOf(mat_name) == -1)
	                continue;

	            batch.node_rgbs[3 * ind]     = r;
	            batch.node_rgbs[3 * ind + 1] = g;
	            batch.node_rgbs[3 * ind + 2] = b;
	        }
	    }

	    if (is_world)
	        m_scenes.update_sky_texture(obj);
	};

	exports.get_nodemat_value = function (batch, ind) {
	    return batch.node_values[ind];
	};

	exports.get_nodemat_rgb = function (batch, ind, dest) {
	    dest[0] = batch.node_rgbs[3 * ind];
	    dest[1] = batch.node_rgbs[3 * ind + 1];
	    dest[2] = batch.node_rgbs[3 * ind + 2];
	    return dest;
	};

	exports.get_node_val_ind_by_name_list = get_node_val_ind_by_name_list;
	function get_node_val_ind_by_name_list(inds, name_list, prefix_offset) {
	    var id = node_id_from_name_list(name_list, prefix_offset);
	    for (var i = 0; i < inds.length; i+=3) {
	        if (inds[i] == id)
	            return inds[i+1] * 4 + inds[i+2];
	    }
	    return null;
	}

	exports.get_node_rgb_ind_by_name_list = get_node_rgb_ind_by_name_list;
	function get_node_rgb_ind_by_name_list(inds, name_list, prefix_offset) {
	    var id = node_id_from_name_list(name_list, prefix_offset);
	    for (var i = 0; i < inds.length; i+=2) {
	        if (inds[i] == id)
	            return inds[i+1];
	    }
	    return null;
	}

	function node_id_from_name_list(name_list, prefix_offset) {
	    var id = name_list[prefix_offset];
	    for (var i = prefix_offset+1; i < name_list.length; i++)
	        id += "%join%" + name_list[i];
	    return id;
	}

	}

	var int_objects_factory = register("__objects", Int_objects);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Textures internal API.
	 * Don't forget to register GL context by setup_context() function.
	 * @name textures
	 * @namespace
	 * @exports exports as textures
	 */
	function Int_textures(ns, exports) {

	var m_compat    = int_compat_factory(ns);
	var m_cfg       = int_config_factory(ns);
	var m_texcomp   = int_texcomp_factory(ns);
	var m_debug     = int_debug_factory(ns);
	var m_ext       = int_extensions_factory(ns);
	var m_print     = print_factory(ns);
	var m_time      = int_time_factory(ns);
	var m_util      = int_util_factory(ns);
	var m_ren       = int_renderer_factory(ns);
	var m_objs      = int_objects_factory(ns);
	var m_obj_util  = int_obj_util_factory(ns);
	var m_curve     = int_curve_factory(ns);
	var m_vec3      = vec3_factory(ns);
	var m_scs       = int_scenes_factory(ns);

	var cfg_def = m_cfg.defaults;
	var cfg_lim = m_cfg.context_limits;
	var cfg_sfx = m_cfg.sfx;

	var _tmpcanvas = null;

	var _w_texture_tmp = null;
	var _w_framebuffer_tmp = null;

	// texture filters, proper values assigned by setup_context()

	// mag & min
	exports.TF_NEAREST = 0;
	exports.TF_LINEAR = 0;
	// min only
	exports.TF_NEAREST_MIPMAP_NEAREST = 0;
	exports.TF_LINEAR_MIPMAP_NEAREST = 0;
	exports.TF_NEAREST_MIPMAP_LINEAR = 0;
	exports.TF_LINEAR_MIPMAP_LINEAR = 0;

	// texture types
	exports.TT_RGBA_INT    = 10;
	exports.TT_RGB_INT     = 20;
	exports.TT_RGBA_FLOAT  = 30;
	exports.TT_RGB_FLOAT   = 40;
	exports.TT_DEPTH       = 50;
	exports.TT_RB_RGBA     = 60;
	exports.TT_RB_DEPTH    = 70;
	exports.TT_RB_RGBA_MS  = 80;
	exports.TT_RB_DEPTH_MS = 90;

	exports.CURVE_NODES_TEXT_SIZE = 128;
	exports.COLORRAMP_TEXT_SIZE = 128;
	exports.PART_COLORRAMP_TEXT_SIZE = 128;

	var _img_textures_cache = {
	    textures: [],
	    loaded_status: []
	};

	var _canvas_textures_cache = {};
	var _video_textures_cache = {};

	var PLAYBACK_RATE = 2;

	var _gl = null;

	// texture quality
	var LEVELS;
	var BEZIER_ROOT_PRECISION = 0.001;
	var FLT_EPSILON = 0.00000001;

	var CUBE_MAP_TARGETS = [
	    "TEXTURE_CUBE_MAP_POSITIVE_X",
	    "TEXTURE_CUBE_MAP_NEGATIVE_X",
	    "TEXTURE_CUBE_MAP_POSITIVE_Y",
	    "TEXTURE_CUBE_MAP_NEGATIVE_Y",
	    "TEXTURE_CUBE_MAP_POSITIVE_Z",
	    "TEXTURE_CUBE_MAP_NEGATIVE_Z"
	];

	/* offsets for Blender-packed Environment map
	 ----------------
	 | -X | -Y | +X |
	 ----------------
	 | -Z | +Z | +Y |
	 ----------------
	*/
	var CUBE_MAP_OFFSETS = [[2, 0], [0, 0], [2, 1],
	                        [1, 0], [1, 1], [0, 1]];

	/**
	 * Setup WebGL context
	 */
	exports.setup_context = function(gl) {
	    LEVELS = [
	        gl.NEAREST_MIPMAP_NEAREST,
	        gl.NEAREST_MIPMAP_LINEAR,
	        gl.LINEAR_MIPMAP_NEAREST, // faster than gl.NEAREST_MIPMAP_LINEAR
	        gl.LINEAR_MIPMAP_LINEAR
	    ];

	    exports.TF_NEAREST = gl.NEAREST;
	    exports.TF_LINEAR = gl.LINEAR;
	    // min only
	    exports.TF_NEAREST_MIPMAP_NEAREST = gl.NEAREST_MIPMAP_NEAREST;
	    exports.TF_LINEAR_MIPMAP_NEAREST = gl.LINEAR_MIPMAP_NEAREST;
	    exports.TF_NEAREST_MIPMAP_LINEAR = gl.NEAREST_MIPMAP_LINEAR;
	    exports.TF_LINEAR_MIPMAP_LINEAR = gl.LINEAR_MIPMAP_LINEAR;

	    _gl = gl;
	};

	exports.get_canvas_context = function(id, data_id) {
	    if (data_id in _canvas_textures_cache && id in _canvas_textures_cache[data_id])
	        return _canvas_textures_cache[data_id][id].canvas_context;
	    else
	        return null;
	};

	exports.update_canvas_context = function(id, data_id) {
	    if (data_id in _canvas_textures_cache && id in _canvas_textures_cache[data_id]) {
	        update_texture_canvas(_canvas_textures_cache[data_id][id]);
	        return true;
	    } else
	        return false;
	};

	function get_framebuffer_tmp() {
	    if (!_w_framebuffer_tmp)
	        _w_framebuffer_tmp = _gl.createFramebuffer();
	    return _w_framebuffer_tmp;
	}

	function get_wtex_tmp() {
	    if (!_w_texture_tmp)
	        _w_texture_tmp = _gl.createTexture();
	    return _w_texture_tmp;
	}

	function init_texture() {
	    var texture = {
	        type: 0,

	        source: "",
	        source_id: "",
	        width: 0,
	        height: 0,
	        compress_ratio: 1,
	        anisotropic_filtering: 0,

	        source_size: 1024,
	        enable_canvas_mipmapping: false,
	        canvas_context: null,

	        w_target: 0,
	        w_texture: null,
	        w_renderbuffer: null,

	        // movie properties
	        is_movie: false,

	        vtex_data_id: -1,

	        video_file: null,
	        video_tex_name: "",
	        movie_length: 0,
	        fps: 0,
	        frame_start: 0,
	        frame_offset: 0,
	        frame_duration: 0,
	        need_resize: false,
	        scale_fac: 1.0,

	        use_mipmap: false,
	        mipmap_count: 0.0,

	        seq_video: null,
	        seq_movie_length: 0,
	        seq_fps: 0,
	        seq_cur_frame: -1,
	        seq_video_played: false,
	        seq_last_discrete_mark: -1,

	        video_was_stopped: false,

	        use_auto_refresh: false,
	        use_cyclic : false,
	        use_nla: false,

	        repeat: true,

	        img_full_filepath: "",

	        img_filepath: "",
	        img_uuid: "",
	        img_source: "",
	        img_name: "",
	        img_comp_method: ""
	    };

	    return texture;
	}

	// NOTE: this operation puts texture into the image texture cache
	exports.append_img_info = append_img_info;
	function append_img_info(texture, image, dir_path) {
	    texture.img_uuid = image["uuid"];
	    texture.img_filepath = image["filepath"];
	    texture.img_source = image["source"];
	    texture.img_name = image["name"];
	    texture.img_full_filepath = m_util.normpath_preserve_protocol(
	                                            dir_path + image["filepath"]);
	    texture.img_comp_method = image._comp_method;

	    if (_img_textures_cache.textures.indexOf(texture) == -1) {
	        _img_textures_cache.textures.push(texture);
	        // always false, bcz images are loaded after appending this info
	        _img_textures_cache.loaded_status.push(false);
	    }
	}

	function clone_texture(texture) {
	    var texture_new = init_texture();

	    texture_new.type = texture.type;
	    texture_new.anisotropic_filtering = texture.anisotropic_filtering;

	    texture_new.source = texture.source;
	    texture_new.source_id = texture.source_id;
	    texture_new.width = texture.width;
	    texture_new.height = texture.height;
	    texture_new.compress_ratio = texture.compress_ratio;

	    texture_new.source_size = texture.source_size;
	    texture_new.enable_canvas_mipmapping = texture.enable_canvas_mipmapping;
	    texture_new.canvas_context = texture.canvas_context;

	    texture_new.w_target = texture.w_target;
	    texture_new.w_texture = texture.w_texture;
	    texture_new.w_renderbuffer = texture.w_renderbuffer;

	    // movie properties
	    texture_new.is_movie = texture.is_movie;

	    texture_new.vtex_data_id = texture.vtex_data_id;

	    texture_new.video_file = texture.video_file;
	    texture_new.video_tex_name = texture.video_tex_name;
	    texture_new.movie_length = texture.movie_length;
	    texture_new.fps = texture.fps;
	    texture_new.frame_start = texture.frame_start;
	    texture_new.frame_offset = texture.frame_offset;
	    texture_new.frame_duration = texture.frame_duration;
	    texture_new.need_resize = texture.need_resize;
	    texture_new.scale_fac = texture.scale_fac;

	    texture_new.seq_video = texture.seq_video;
	    texture_new.seq_movie_length = texture.seq_movie_length;
	    texture_new.seq_fps = texture.seq_fps;
	    texture_new.seq_cur_frame = texture.seq_cur_frame;
	    texture_new.seq_video_played = texture.seq_video_played;
	    texture_new.seq_last_discrete_mark = texture.seq_last_discrete_mark;

	    texture_new.video_was_stopped = texture.video_was_stopped;

	    texture_new.use_auto_refresh = texture.use_auto_refresh;
	    texture_new.use_cyclic = texture.use_cyclic;
	    texture_new.use_nla = texture.use_nla;

	    texture_new.repeat = texture.repeat;

	    texture_new.img_filepath = texture.img_filepath;
	    texture_new.img_full_filepath = texture.img_full_filepath;
	    texture_new.img_uuid = texture.img_uuid;
	    texture_new.img_source = texture.img_source;
	    texture_new.img_name = texture.img_name;
	    texture_new.img_comp_method = texture.img_comp_method;

	    return texture_new;
	}

	function set_params_by_img_path(texture, path, full_path) {
	    var is_dds = path.indexOf(".dds") > -1;
	    var is_pvr = path.indexOf(".pvr") > -1;

	    if (is_dds)
	        texture.img_comp_method = "dds";
	    else if (is_pvr)
	        texture.img_comp_method = "pvr";
	    else
	        texture.img_comp_method = "";

	    texture.img_filepath = path;
	    texture.img_full_filepath = full_path;
	    texture.img_uuid = m_util.gen_uuid();
	    _img_textures_cache.textures.push(texture);
	    _img_textures_cache.loaded_status.push(true);
	}

	function clone_w_texture(texture, texture_new) {
	    // NOTE: transfer parameters only
	    _gl.bindTexture(texture.w_target, texture.w_texture);
	    var texture_mag_filter = _gl.getTexParameter(texture.w_target, _gl.TEXTURE_MAG_FILTER);
	    var texture_min_filter = _gl.getTexParameter(texture.w_target, _gl.TEXTURE_MIN_FILTER);
	    var texture_wrap_s = _gl.getTexParameter(texture.w_target, _gl.TEXTURE_WRAP_S);
	    var texture_wrap_t = _gl.getTexParameter(texture.w_target, _gl.TEXTURE_WRAP_T);

	    texture_new.w_texture = _gl.createTexture();
	    _gl.bindTexture(texture_new.w_target, texture_new.w_texture);
	    _gl.texParameteri(texture_new.w_target, _gl.TEXTURE_MAG_FILTER, texture_mag_filter);
	    _gl.texParameteri(texture_new.w_target, _gl.TEXTURE_MIN_FILTER, texture_min_filter);
	    _gl.texParameteri(texture_new.w_target, _gl.TEXTURE_WRAP_S, texture_wrap_s);
	    _gl.texParameteri(texture_new.w_target, _gl.TEXTURE_WRAP_T, texture_wrap_t);

	    _gl.bindTexture(texture_new.w_target, null);
	}

	/**
	 * Create empty b4w texture.
	 */
	exports.create_texture = create_texture;
	function create_texture(type, use_comparison, use_mipmap) {

	    var texture = init_texture();
	    texture.type = type;
	    texture.source = "NONE";
	    texture.use_mipmap = use_mipmap;

	    if (    type == exports.TT_RB_RGBA ||
	            type == exports.TT_RB_DEPTH ||
	            type == exports.TT_RB_RGBA_MS ||
	            type == exports.TT_RB_DEPTH_MS) {
	        texture.w_renderbuffer = _gl.createRenderbuffer();
	    } else {
	        var w_target = _gl.TEXTURE_2D;
	        var w_texture = _gl.createTexture();

	        _gl.bindTexture(w_target, w_texture);

	        // NOTE: standard params suitable for POT and NPOT textures
	        _gl.texParameteri(w_target, _gl.TEXTURE_MAG_FILTER, _gl.LINEAR);
	        if (use_mipmap)
	            _gl.texParameteri(w_target, _gl.TEXTURE_MIN_FILTER, LEVELS[cfg_def.texture_min_filter]);
	        else
	            _gl.texParameteri(w_target, _gl.TEXTURE_MIN_FILTER, _gl.LINEAR);
	        _gl.texParameteri(w_target, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);
	        _gl.texParameteri(w_target, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);

	        var format = get_image2d_format(texture);
	        var iformat = get_image2d_iformat(texture);
	        var tex_type = get_image2d_type(texture);
	        if (type == exports.TT_DEPTH)
	            var image_data = null;
	        else
	            var image_data = new Uint8Array([0.8*255, 0.8*255, 0.8*255, 1*255]);

	        _gl.texImage2D(w_target, 0, iformat, 1, 1, 0, format, tex_type, image_data);

	        if (cfg_def.compared_mode_depth && use_comparison)
	            _gl.texParameterf(w_target, _gl.TEXTURE_COMPARE_MODE,
	                    _gl.COMPARE_REF_TO_TEXTURE);

	        _gl.bindTexture(w_target, null);

	        texture.w_target = w_target;
	        texture.w_texture = w_texture;
	    }

	    return texture;
	}

	/**
	 * Create cubemap b4w texture.
	 */
	exports.create_cubemap_texture = function(size, use_mipmap) {

	    var w_texture = _gl.createTexture();

	    var w_target = _gl.TEXTURE_CUBE_MAP;

	    _gl.bindTexture(w_target, w_texture);

	    // NOTE: standard params suitable for POT and NPOT textures
	    _gl.texParameteri(w_target, _gl.TEXTURE_MAG_FILTER, _gl.LINEAR);
	    if (use_mipmap)
	        _gl.texParameteri(w_target, _gl.TEXTURE_MIN_FILTER, LEVELS[cfg_def.texture_min_filter]);
	    else
	        _gl.texParameteri(w_target, _gl.TEXTURE_MIN_FILTER, _gl.LINEAR);
	    _gl.texParameteri(w_target, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);
	    _gl.texParameteri(w_target, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);

	    for (var i = 0; i < 6; i++) {
	        var info = CUBE_MAP_TARGETS[i];
	        _gl.texImage2D(_gl[info], 0, _gl.RGBA,
	            size, size, 0, _gl.RGBA, _gl.UNSIGNED_BYTE, null);
	    }

	    _gl.bindTexture(w_target, null);

	    var texture = init_texture();

	    texture.type = exports.TT_RGBA_INT;
	    texture.source = "NONE";
	    texture.width = 3*size;
	    texture.height = 2*size;
	    texture.compress_ratio = 1;
	    texture.use_mipmap = use_mipmap;

	    texture.w_texture = w_texture;
	    texture.w_target = _gl.TEXTURE_CUBE_MAP;

	    return texture;
	};


	/**
	 * Set cubemap dimensions.
	 */
	exports.set_cubemap_tex_size = function(cube_texture, size) {

	    var w_texture = cube_texture.w_texture;

	    var w_target = cube_texture.w_target;

	    _gl.bindTexture(w_target, w_texture);
	    for (var i = 0; i < 6; i++) {
	        var info = CUBE_MAP_TARGETS[i];
	        _gl.texImage2D(_gl[info], 0, _gl.RGBA,
	            size, size, 0, _gl.RGBA, _gl.UNSIGNED_BYTE, null);
	    }

	    _gl.bindTexture(w_target, null);

	    cube_texture.width = 3*size;
	    cube_texture.height = 2*size;
	};

	/**
	 * Set texture MIN/MAG filters (TF_*)
	 */
	exports.set_filters = function(texture, min_filter, mag_filter) {

	    var w_target = texture.w_target;
	    var w_texture = texture.w_texture;

	    _gl.bindTexture(w_target, w_texture);

	    if (min_filter)
	        _gl.texParameteri(w_target, _gl.TEXTURE_MIN_FILTER, min_filter);

	    if (mag_filter)
	        _gl.texParameteri(w_target, _gl.TEXTURE_MAG_FILTER, mag_filter);

	    _gl.bindTexture(w_target, null);
	};

	exports.resize = function(texture, width, height) {
	    width = Math.max(width, 1);
	    height = Math.max(height, 1);

	    if (texture.width == width && texture.height == height)
	        return;

	    switch (texture.type) {
	    case exports.TT_RB_RGBA:
	        _gl.bindRenderbuffer(_gl.RENDERBUFFER, texture.w_renderbuffer);
	        // NOTE: maximum internal format in WebGL 1
	        _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.RGB565,
	                width, height);
	        _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
	        break;
	    case exports.TT_RB_DEPTH:
	        _gl.bindRenderbuffer(_gl.RENDERBUFFER, texture.w_renderbuffer);
	        _gl.renderbufferStorage(_gl.RENDERBUFFER, get_depth_format(cfg_lim.depth_bits),
	                width, height);
	        _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
	        break;
	    case exports.TT_RB_RGBA_MS:
	        _gl.bindRenderbuffer(_gl.RENDERBUFFER, texture.w_renderbuffer);
	        _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER,
	                cfg_def.msaa_samples, _gl.RGBA8,
	                width, height);

	        _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
	        break;
	    case exports.TT_RB_DEPTH_MS:
	        _gl.bindRenderbuffer(_gl.RENDERBUFFER, texture.w_renderbuffer);
	        _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER,
	                cfg_def.msaa_samples, get_depth_format(cfg_lim.depth_bits),
	                width, height);
	        _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
	        break;
	    default:
	        var w_tex = texture.w_texture;
	        var w_target = texture.w_target;

	        _gl.bindTexture(w_target, w_tex);
	        var format = get_image2d_format(texture);
	        var iformat = get_image2d_iformat(texture);
	        var type = get_image2d_type(texture);

	        if (texture.use_mipmap) {
	            if (!cfg_def.webgl2) {
	                var size = Math.max(width, height);
	                width = calc_pot_size(size);
	                height = calc_pot_size(size);
	            }
	            texture.mipmap_count = Math.round(Math.log(Math.max(width, height)) / Math.log(2.0) + 0.5);
	        }

	        _gl.texImage2D(w_target, 0, iformat, width, height, 0, format, type, null);

	        _gl.bindTexture(w_target, null);
	        break;
	    }

	    if (check_texture_size(width, height)) {
	        m_util.panic("Slink texture \"" + texture.type
	                + "\" has unsupported size: " + width + "x" + height
	                + ". Max available: " + cfg_lim.max_texture_size + "x"
	                + cfg_lim.max_texture_size + ".");
	        return;
	    }

	    texture.width = width;
	    texture.height = height;
	};

	/**
	 * Create b4w texture object with 1-pixel image as placeholder
	 */
	exports.create_texture_bpy =
	function (bpy_texture, global_af, bpy_scenes, thread_id, dir_path) {

	    var tex_type = bpy_texture["type"];

	    if (tex_type == "BLEND")
	        return null;

	    var image = bpy_texture["image"];

	    var texture = init_texture();

	    texture.type = exports.TT_RGBA_INT;
	    texture.width = 1;
	    texture.height = 1;

	    setup_anisotropic_filtering(texture, bpy_texture, global_af);
	    setup_texture_repeat(texture, bpy_texture);

	    if (image) {
	        // NOTE: check cache after all texture params are computed
	        if (tex_type == "IMAGE" && image["source"] == "MOVIE")
	            setup_tex_movie_props(texture, bpy_texture);

	        texture.source = tex_type;

	        var norm_path = m_util.normpath_preserve_protocol(dir_path + image["filepath"]);
	        var cached_tex = find_similar_tex(norm_path, texture);
	        if (cached_tex)
	            return cached_tex;

	        append_img_info(texture, image, dir_path);
	    }

	    var image_data = new Uint8Array([0.8*255, 0.8*255, 0.8*255, 1*255]);

	    switch (tex_type) {
	    case "IMAGE":
	        var w_texture = _gl.createTexture();
	        var w_target = _gl.TEXTURE_2D;
	        _gl.bindTexture(w_target, w_texture);
	        _gl.texImage2D(w_target, 0, _gl.RGBA, 1, 1, 0, _gl.RGBA, _gl.UNSIGNED_BYTE, image_data);
	        break;

	    case "NONE":
	        // check if this texture can be used for offscreen rendering
	        if (bpy_texture["b4w_source_type"] == "NONE")
	            return null;

	        var w_texture = _gl.createTexture();
	        var w_target = _gl.TEXTURE_2D;

	        texture.source = bpy_texture["b4w_source_type"];

	        if (texture.source == "SCENE") {
	            if (!bpy_texture["b4w_source_id"])
	                return null;

	            var name = bpy_texture["b4w_source_id"];
	            var scene = m_util.keysearch("name", name, bpy_scenes);

	            if (!scene)
	                return null;

	            texture.source_id = bpy_texture["b4w_source_id"];
	            texture.source_size = bpy_texture["b4w_source_size"];
	            scene._render_to_textures = scene._render_to_textures || [];
	            scene._render_to_textures.push(texture);
	            _gl.bindTexture(w_target, w_texture);
	            _gl.texImage2D(w_target, 0, _gl.RGBA, 1, 1, 0, _gl.RGBA,
	                           _gl.UNSIGNED_BYTE, image_data);

	        } else if (texture.source == "CANVAS") {
	            setup_tex_canvas(texture, bpy_texture, thread_id);
	            _gl.bindTexture(w_target, w_texture);
	        }
	        break;

	    case "ENVIRONMENT_MAP":
	        var w_texture = _gl.createTexture();
	        var w_target = _gl.TEXTURE_CUBE_MAP;
	        _gl.bindTexture(w_target, w_texture);
	        var targets = [
	            "POSITIVE_X", "NEGATIVE_X",
	            "POSITIVE_Y", "NEGATIVE_Y",
	            "POSITIVE_Z", "NEGATIVE_Z"
	        ];
	        for (var i = 0; i < 6; i++)
	            _gl.texImage2D(_gl["TEXTURE_CUBE_MAP_" + targets[i]], 0, _gl.RGBA,
	                    1, 1, 0, _gl.RGBA, _gl.UNSIGNED_BYTE, image_data);
	        break;

	    default:
	        m_print.error("texture \"" + bpy_texture["name"] +
	            "\" has unsupported type \"" + tex_type + "\"");
	        return null;
	    }

	    texture.w_texture = w_texture;
	    texture.w_target = w_target;

	    if (tex_type == "NONE") {
	        // canvas texture is not updated with update_texture so set the props now
	        if (!texture.enable_canvas_mipmapping)
	            _gl.texParameteri(w_target, _gl.TEXTURE_MIN_FILTER, _gl.LINEAR);
	        else
	            _gl.texParameteri(w_target, _gl.TEXTURE_MIN_FILTER, LEVELS[cfg_def.texture_min_filter]);
	        if (texture.anisotropic_filtering)
	            _gl.texParameterf(w_target, m_ext.get_aniso().TEXTURE_MAX_ANISOTROPY_EXT,
	                              texture.anisotropic_filtering);

	        if (texture.source == "CANVAS")
	            update_texture_canvas(texture);
	    } else {
	        _gl.generateMipmap(w_target);
	        _gl.bindTexture(w_target, null);
	    }

	    return texture;
	};

	function setup_anisotropic_filtering(texture, bpy_texture, global_af) {

	    if (cfg_def.anisotropic_available) {

	        // possible values: DEFAULT, OFF, 2x, 4x, 8x, 16x
	        var af = bpy_texture["b4w_anisotropic_filtering"];

	        // individual textures override global AF value when b4w_anisotropic_filtering is not DEFAULT
	        if (af === "DEFAULT")
	            af = global_af;

	        if (af !== "OFF" && cfg_def.anisotropic_filtering) {
	            var af_value = parseFloat(af.split("x")[0]);
	            texture.anisotropic_filtering = af_value;
	        }
	    }
	}

	function setup_texture_repeat(texture, bpy_texture) {
	    var tex_extension = bpy_texture["extension"];
	    if (tex_extension != "REPEAT" || bpy_texture["b4w_shore_dist_map"])
	        texture.repeat = false;
	}

	function setup_tex_movie_props(texture, bpy_texture) {
	    texture.is_movie = true;
	    texture.video_tex_name = bpy_texture["name"];
	    texture.frame_start = bpy_texture["frame_start"];
	    texture.frame_offset = bpy_texture["frame_offset"];
	    texture.frame_duration = bpy_texture["frame_duration"];
	    texture.use_auto_refresh = bpy_texture["use_auto_refresh"];
	    texture.use_cyclic = bpy_texture["use_cyclic"];
	    texture.movie_length = bpy_texture["movie_length"];
	    texture.use_nla = bpy_texture["b4w_nla_video"];

	    if (texture.frame_offset != 0)
	        m_print.warn("Frame offset for texture \"" + bpy_texture["name"] +
	                "\" has a nonzero value. Can lead to undefined behaviour" +
	                " for mobile devices.");
	}

	function setup_tex_canvas(texture, bpy_texture, thread_id) {

	    var id = bpy_texture["b4w_source_id"];
	    var size = bpy_texture["b4w_source_size"];

	    texture.source_id = id;
	    texture.enable_canvas_mipmapping = bpy_texture["b4w_enable_canvas_mipmapping"];

	    var canvas = document.createElement("canvas");
	    canvas.width  = size;
	    canvas.height = size;
	    texture.canvas_context = canvas.getContext("2d");

	    if (!(thread_id in _canvas_textures_cache))
	        _canvas_textures_cache[thread_id] = {};
	    _canvas_textures_cache[thread_id][id] = texture;
	}

	exports.update_texture_canvas = update_texture_canvas;
	function update_texture_canvas(texture) {

	    var w_texture = texture.w_texture;
	    var w_target = texture.w_target;

	    _gl.bindTexture(w_target, w_texture);

	    var w_format = get_image2d_format(texture);
	    var w_iformat = get_image2d_iformat(texture);
	    var w_type = get_image2d_type(texture);
	    var canvas = texture.canvas_context.canvas;
	    _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, true);
	    _gl.texImage2D(w_target, 0, w_iformat, w_format, w_type, canvas);
	    _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, false);
	    if (texture.enable_canvas_mipmapping)
	        _gl.generateMipmap(w_target);
	    _gl.bindTexture(w_target, null);

	    texture.width = canvas.width;
	    texture.height = canvas.height;
	}

	exports.update_video_texture = update_video_texture;
	function update_video_texture(texture) {
	    var w_texture = texture.w_texture;
	    var w_target = texture.w_target;

	    _gl.bindTexture(w_target, w_texture);

	    _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, true);
	    if (texture.video_file.length != 4) {
	        if (texture.need_resize)
	            draw_resized_image(texture, texture.video_file,
	                    texture.width * texture.scale_fac,
	                    texture.height * texture.scale_fac, false);
	        else
	            _gl.texImage2D(w_target, 0, _gl.RGBA, _gl.RGBA,
	                    _gl.UNSIGNED_BYTE, texture.video_file);
	    } else
	        _gl.texImage2D(w_target, 0, _gl.RGBA, 1, 1, 0, _gl.RGBA, _gl.UNSIGNED_BYTE,
	                texture.video_file);

	  _gl.bindTexture(w_target, null);

	}

	exports.update_seq_video_texture = update_seq_video_texture;
	function update_seq_video_texture(texture) {
	    var w_texture = texture.w_texture;
	    var w_target = texture.w_target;

	    _gl.bindTexture(w_target, w_texture);

	    _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, true);
	    if (texture.need_resize)
	        draw_resized_image(texture, texture.seq_video[texture.seq_cur_frame],
	                texture.width * texture.scale_fac,
	                texture.height * texture.scale_fac, false);
	    else
	        _gl.texImage2D(w_target, 0, _gl.RGBA, _gl.RGBA,
	                _gl.UNSIGNED_BYTE, texture.seq_video[texture.seq_cur_frame]);

	    _gl.bindTexture(w_target, null);
	}

	function get_tmp_canvas() {
	    if (!_tmpcanvas)
	        _tmpcanvas = document.createElement("canvas");
	    return _tmpcanvas;
	}

	function draw_resized_image(texture, image_data, width, height, is_dds) {
	    if (!is_dds) {
	        setup_resized_tex_data(_gl.TEXTURE_2D);
	        _gl.texImage2D(_gl.TEXTURE_2D, 0, _gl.RGBA, _gl.RGBA, _gl.UNSIGNED_BYTE, image_data);
	    }
	    _gl.bindTexture(_gl.TEXTURE_2D, null);
	    
	    var fbuf_tmp = get_framebuffer_tmp();
	    var wtex_tmp = get_wtex_tmp();
	    m_ren.draw_resized_texture(texture, width, height, fbuf_tmp, wtex_tmp, "NONE");
	}

	function resize_cube_map(texture, image_data, pot_dim, img_dim) {
	    setup_resized_tex_data(_gl.TEXTURE_2D);
	    _gl.texImage2D(_gl.TEXTURE_2D, 0, _gl.RGBA, _gl.RGBA, _gl.UNSIGNED_BYTE, image_data);
	    _gl.bindTexture(_gl.TEXTURE_2D, null);

	    // NOTE: Cube map texture must be initiated before using
	    for (var i = 0; i < 6; i++)
	        _gl.texImage2D(_gl["TEXTURE_CUBE_MAP_POSITIVE_X"] + i, 0, _gl.RGBA, pot_dim, pot_dim, 0,
	                _gl.RGBA, _gl.UNSIGNED_BYTE, null);

	    _gl.bindTexture(texture.w_target, null);
	    var fbuf_tmp = get_framebuffer_tmp();
	    _gl.bindFramebuffer(_gl.FRAMEBUFFER, fbuf_tmp);

	    var wtex_tmp = get_wtex_tmp();
	    for (var i = 0; i < 6; i++) {
	        m_ren.draw_resized_cubemap_texture(texture, _gl[CUBE_MAP_TARGETS[i]], pot_dim,
	                img_dim, wtex_tmp, i);
	    }
	    _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);

	    _gl.bindTexture(texture.w_target, texture.w_texture);

	    _gl.texParameteri(texture.w_target, _gl.TEXTURE_MIN_FILTER, LEVELS[cfg_def.texture_min_filter]);
	    _gl.texParameteri(texture.w_target, _gl.TEXTURE_MAG_FILTER, _gl.LINEAR);
	}

	function resize_cube_map_canvas(texture, image_data, img_dim, pot_dim) {
	    for (var i = 0; i < 6; i++) {
	        var target = CUBE_MAP_TARGETS[i];
	        var offset = CUBE_MAP_OFFSETS[i];
	        var tmpcanvas = get_tmp_canvas();
	        tmpcanvas.width = pot_dim;
	        tmpcanvas.height = pot_dim;
	        var ctx = tmpcanvas.getContext("2d");
	        ctx.translate(pot_dim / 2, pot_dim / 2);

	        if (target == "TEXTURE_CUBE_MAP_POSITIVE_X") {
	            ctx.rotate(Math.PI/2);
	            ctx.scale(1, -1);
	        } else if (target == "TEXTURE_CUBE_MAP_NEGATIVE_X") {
	            ctx.rotate(Math.PI/2);
	            ctx.scale(-1, 1);
	        } else if (target == "TEXTURE_CUBE_MAP_POSITIVE_Y" ||
	                target == "TEXTURE_CUBE_MAP_POSITIVE_Z") {
	            ctx.scale(1, -1);
	        } else if (target == "TEXTURE_CUBE_MAP_NEGATIVE_Y" ||
	                target == "TEXTURE_CUBE_MAP_NEGATIVE_Z") {
	            ctx.scale(-1, 1);
	        }

	        ctx.drawImage(image_data, offset[0] * img_dim, offset[1] * img_dim,
	                      img_dim, img_dim, -pot_dim/2, -pot_dim/2, pot_dim, pot_dim);

	        if (cfg_def.d3d9_canvas_resizing_hack)
	            _gl.texImage2D(_gl[target], 0, _gl.RGBA, pot_dim, pot_dim, 0, 
	                    _gl.RGBA, _gl.UNSIGNED_BYTE, new Uint8Array(ctx.getImageData(
	                    0, 0, pot_dim, pot_dim).data.buffer));
	        else
	            _gl.texImage2D(_gl[target], 0, _gl.RGBA, _gl.RGBA, _gl.UNSIGNED_BYTE,
	                    tmpcanvas);
	    }
	}

	function setup_resized_tex_data(w_target) {
	    _gl.bindTexture(w_target, null);

	    var wtex_tmp = get_wtex_tmp();
	    _gl.bindTexture(w_target, wtex_tmp);
	    prepare_npot_texture(w_target);
	}

	/**
	 * Load image data into texture object
	 * texture object
	 */
	exports.update_texture = update_texture;
	function update_texture(texture, image_data, thread_id) {
	    var tex_type = texture.source;
	    var w_texture = texture.w_texture;
	    var w_target = texture.w_target;
	    var comp_method = texture.img_comp_method;
	    var filepath = texture.img_filepath;

	    var width = 1;
	    var height = 1;

	    _gl.bindTexture(w_target, w_texture);

	    if (texture.repeat) {
	        _gl.texParameteri(w_target, _gl.TEXTURE_WRAP_S, _gl.REPEAT);
	        _gl.texParameteri(w_target, _gl.TEXTURE_WRAP_T, _gl.REPEAT);
	    } else {
	        _gl.texParameteri(w_target, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);
	        _gl.texParameteri(w_target, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);
	    }

	    if (texture.is_movie || tex_type == "NODE_TEX")
	        _gl.texParameteri(w_target, _gl.TEXTURE_MIN_FILTER, _gl.LINEAR);
	    else
	        _gl.texParameteri(w_target, _gl.TEXTURE_MIN_FILTER, LEVELS[cfg_def.texture_min_filter]);

	    if (texture.anisotropic_filtering)
	        _gl.texParameterf(w_target, m_ext.get_aniso().TEXTURE_MAX_ANISOTROPY_EXT,
	                          texture.anisotropic_filtering);

	    if (image_data.length == 4) {
	        var update_color = true;
	        image_data = new Uint8Array([
	            image_data[0] * 255,
	            image_data[1] * 255,
	            image_data[2] * 255,
	            image_data[3] * 255
	        ]);
	    }

	    if (tex_type == "IMAGE") {
	        if (update_color) {
	            _gl.texImage2D(w_target, 0, _gl.RGBA, 1, 1, 0, _gl.RGBA, _gl.UNSIGNED_BYTE,
	                    image_data);
	            texture.width = 1;
	            texture.height = 1;
	        } else if (comp_method) {
	            var comp_img_wh = m_texcomp.get_width_height(image_data, comp_method);
	            var is_npot = m_util.check_npot(comp_img_wh.width)
	                    || m_util.check_npot(comp_img_wh.height);

	            if (check_texture_size(comp_img_wh.width, comp_img_wh.height)) {
	                m_print.error("Image \"" + filepath
	                        + "\" has unsupported size: " + comp_img_wh.width + "x"
	                        + comp_img_wh.height + ". Max available: "
	                        + cfg_lim.max_texture_size + "x"
	                        + cfg_lim.max_texture_size + ".");
	                return;
	            }

	            width = comp_img_wh.width;
	            height = comp_img_wh.height;

	            if (is_npot || comp_method == "pvr") {
	                texture.need_resize = true;
	                setup_resized_tex_data(w_target);
	                width = calc_pot_size(width * texture.scale_fac);
	                height = calc_pot_size(height * texture.scale_fac);
	            }

	            if (comp_method == "dds")
	                m_texcomp.upload_dds_levels(_gl, m_ext.get_s3tc(), image_data, true);
	            else if (comp_method == "pvr")
	                m_texcomp.upload_pvr_levels(_gl, m_ext.get_pvr(), image_data, true);

	            if (texture.need_resize) {
	                draw_resized_image(texture, null, width, height, true);
	                _gl.bindTexture(w_target, w_texture);
	                _gl.generateMipmap(w_target);
	            }

	            texture.width = width;
	            texture.height = height;
	            texture.compress_ratio = m_texcomp.get_compress_ratio(image_data, comp_method);
	        } else {
	            _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, true);
	            if (texture.is_movie) {
	                if (cfg_def.seq_video_fallback) {
	                    width = image_data[0].width;
	                    height = image_data[0].height;
	                } else {
	                    width = image_data.videoWidth;
	                    height = image_data.videoHeight;
	                }
	            } else {
	                width = image_data.width;
	                height = image_data.height;
	            }

	            texture.width = width;
	            texture.height = height;

	            if (check_texture_size(width, height)) {
	                m_print.warn("Image \"" + filepath
	                        + "\" has unsupported size: " + width + "x"
	                        + height + ". Max available: "
	                        + cfg_lim.max_texture_size + "x"
	                        + cfg_lim.max_texture_size +
	                        ". Reduced image size will be used.");
	                texture.scale_fac = Math.min(cfg_lim.max_texture_size / width,
	                        cfg_lim.max_texture_size / height);
	                texture.need_resize = true;
	            }

	            if (texture.is_movie) {
	                if (!(thread_id in _video_textures_cache))
	                    _video_textures_cache[thread_id] = {};

	                _video_textures_cache[thread_id][texture.video_tex_name] = texture;

	                if (!cfg_def.seq_video_fallback) {
	                    texture.video_file = image_data;
	                    // NOTE: looping needed to prevent a cycle video from
	                    // stopping accidentally due to frame/timeline errors
	                    texture.video_file.loop = texture.use_cyclic;
	                    // NOTE: image_data.duration can't be available?
	                    texture.fps = image_data.duration ?
	                            texture.movie_length / image_data.duration :
	                            m_time.get_framerate();

	                    if (!cfg_sfx.disable_playback_rate_hack) {
	                        image_data.playbackRate = m_time.get_framerate() / texture.fps;
	                        if (cfg_sfx.clamp_playback_rate_hack && image_data.playbackRate >
	                                    PLAYBACK_RATE)
	                            image_data.playbackRate = PLAYBACK_RATE;
	                    }
	                    var draw_data = image_data;
	                    create_oncanplay_handler(texture);
	                } else {

	                    texture.seq_video = image_data;
	                    texture.seq_movie_length = image_data.length;
	                    texture.fps = texture.seq_fps * texture.movie_length / image_data.length;

	                    var draw_data = image_data[0];
	                }
	            } else
	                var draw_data = image_data;

	            width = calc_pot_size(texture.width * texture.scale_fac);
	            height = calc_pot_size(texture.height * texture.scale_fac);

	            if (texture.need_resize || cfg_def.resize_texture_canvas_hack) {
	                var canvas = get_tmp_canvas();
	                var ctx = canvas.getContext("2d");
	                canvas.width = width;
	                canvas.height = height;
	                ctx.drawImage(draw_data, 0, 0, texture.width, texture.height,
	                        0, 0, width, height);

	                if (cfg_def.d3d9_canvas_resizing_hack)
	                    _gl.texImage2D(w_target, 0, _gl.RGBA, width, height, 0, _gl.RGBA, _gl.UNSIGNED_BYTE,
	                            new Uint8Array(ctx.getImageData(0, 0, width, height).data.buffer));
	                else
	                    _gl.texImage2D(w_target, 0, _gl.RGBA, _gl.RGBA, _gl.UNSIGNED_BYTE, canvas);
	            
	            } else if (!cfg_def.webgl2 && (m_util.check_npot(texture.width) 
	                    || m_util.check_npot(texture.height))) {
	                draw_resized_image(texture, draw_data, width, height, false);
	                texture.need_resize = true;

	            } else
	                _gl.texImage2D(w_target, 0, _gl.RGBA, _gl.RGBA, _gl.UNSIGNED_BYTE, draw_data);

	            texture.width = width;
	            texture.height = height;

	            if (!texture.is_movie) {
	                _gl.bindTexture(w_target, w_texture);
	                _gl.generateMipmap(w_target);
	            }
	        }

	    } else if (tex_type == "ENVIRONMENT_MAP") {

	        if (update_color) {
	            for (var i = 0; i < 6; i++) {
	                var target = CUBE_MAP_TARGETS[i];
	                _gl.texImage2D(_gl["TEXTURE_CUBE_MAP_" + target], 0, _gl.RGBA,
	                    1, 1, 0, _gl.RGBA, _gl.UNSIGNED_BYTE, image_data);
	            }

	            texture.width = 3;
	            texture.height = 2;
	        } else {
	            // Restore default OpenGL state in case it was changed earlier
	            _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, false);

	            if (image_data.width % 3 || image_data.height % 2) {
	                m_print.error("Cubemap Image \"" + filepath
	                        + "\" has unsupported size: " + image_data.width + "x"
	                        + image_data.height + ". The width must be multiple" +
	                        " of three and the height - multiple of two.");
	                return;
	            }

	            var img_dim = image_data.width / 3;

	            if (check_cube_map_size(img_dim)) {
	                m_print.warn("Cubemap Image \"" + filepath
	                        + "\" has unsupported size: " + image_data.width + "x"
	                        + image_data.height + ". Max available: "
	                        + cfg_lim.max_cube_map_texture_size * 3 + "x"
	                        + cfg_lim.max_cube_map_texture_size * 2 + ". "
	                        + "Reduced image size will be used.");
	                var scale_fac = cfg_lim.max_cube_map_texture_size / img_dim;
	                var tex_dim = calc_pot_size(img_dim * scale_fac);
	                texture.need_resize = true;
	            } else {
	                var tex_dim = calc_pot_size(img_dim);
	                if (!cfg_def.webgl2 && check_texture_size(3 * tex_dim, 2 * tex_dim))
	                    texture.need_resize = true;
	            }
	            if (texture.need_resize || cfg_def.resize_cubemap_canvas_hack)
	                resize_cube_map_canvas(texture, image_data, img_dim, tex_dim);
	            else
	                resize_cube_map(texture, image_data, tex_dim, img_dim);

	            if (m_debug.check_ff_cubemap_out_of_memory()) {
	                // NOTE: the state of the context and/or objects is undefined 
	                // after the GL_OUT_OF_MEMORY error;
	                // see: https://www.opengl.org/wiki/OpenGL_Error#Side_effects
	                m_print.warn("Firefox detected, setting max cubemap size to 256, use canvas for resizing.");
	                resize_cube_map_canvas(texture, image_data, img_dim, 
	                        m_compat.NVIDIA_OLD_GPU_CUBEMAP_MAX_SIZE);
	            }

	            texture.width = 3 * tex_dim;
	            texture.height = 2 * tex_dim;
	            _gl.generateMipmap(w_target);
	        }
	    } else if (tex_type == "NODE_TEX") {
	        _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, false);
	        _gl.texImage2D(w_target, 0, _gl.RGBA, image_data.width, image_data.height, 0,
	                       _gl.RGBA, _gl.UNSIGNED_BYTE, image_data.data);
	        texture.width = image_data.width;
	        texture.height = image_data.height;
	    }

	    _gl.bindTexture(w_target, null);
	}

	function create_oncanplay_handler(tex) {
	    tex.video_file.oncanplay = function() {
	        // NOTE: setting new frame for an HTML5 video texture forces it
	        // to seek at that point which requires some time, so it can be
	        // updated only on the next frame after this operation.
	        if (video_update_is_available(tex))
	            update_video_texture(tex);
	    };
	}

	function prepare_npot_texture(tex_target) {
	    _gl.texParameteri(tex_target, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);
	    _gl.texParameteri(tex_target, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);
	    _gl.texParameteri(tex_target, _gl.TEXTURE_MAG_FILTER, _gl.LINEAR);
	    _gl.texParameteri(tex_target, _gl.TEXTURE_MIN_FILTER, _gl.LINEAR);
	}

	exports.calc_pot_size = calc_pot_size;
	function calc_pot_size(num) {
	    if (m_util.check_npot(num)) {
	        // NOTE: force casting to int for non-integral numbers
	        var size =  Math.pow(2, (num | 0).toString(2).length);
	        return m_util.clamp(size, 2, cfg_lim.max_texture_size);
	    }
	    return num;
	}

	/**
	 * Get format for texImage2D()
	 */
	function get_image2d_format(texture) {

	    var format;

	    switch (texture.type) {
	    case exports.TT_RGBA_INT:
	        format = _gl.RGBA;
	        break;
	    case exports.TT_RGB_INT:
	        format = _gl.RGB;
	        break;
	    case exports.TT_RGBA_FLOAT:
	        format = _gl.RGBA;
	        break;
	    case exports.TT_RGB_FLOAT:
	        format = _gl.RGB;
	        break;
	    case exports.TT_DEPTH:
	        format = _gl.DEPTH_COMPONENT;
	        break;
	    default:
	        m_util.panic("Wrong texture type");
	        break;
	    }

	    return format;
	}

	/**
	 * Get internalformat for texImage2D()
	 */
	function get_image2d_iformat(texture) {

	    var format;

	    switch (texture.type) {
	    case exports.TT_RGBA_INT:
	        format = cfg_def.webgl2 ? _gl.RGBA8 : _gl.RGBA;
	        break;
	    case exports.TT_RGB_INT:
	        format = cfg_def.webgl2 ? _gl.RGB8 : _gl.RGB;
	        break;
	    case exports.TT_RGBA_FLOAT:
	        format = cfg_def.webgl2 ? _gl.RGBA8 : _gl.RGBA;
	        break;
	    case exports.TT_RGB_FLOAT:
	        format = cfg_def.webgl2 ? _gl.RGB8 : _gl.RGB;
	        break;
	    case exports.TT_DEPTH:
	        format = cfg_def.webgl2 ? get_depth_format(cfg_lim.depth_bits) : _gl.DEPTH_COMPONENT;
	        break;
	    default:
	        m_util.panic("Wrong texture type");
	        break;
	    }

	    return format;
	}

	function get_depth_format(depth_bits) {
	    var format;

	    switch (depth_bits) {
	    case 16:
	        format = _gl.DEPTH_COMPONENT16;
	        break;
	    case 24:
	        // WebGL2
	        format = _gl.DEPTH_COMPONENT24;
	        break;
	    case 32:
	        // WebGL2
	        format = _gl.DEPTH_COMPONENT32F;
	        break;
	    default:
	        // WebGL2
	        format = _gl.DEPTH_COMPONENT24;
	        break;
	    }
	    return format;
	}

	/**
	 * Get type for texImage2D()
	 */
	function get_image2d_type(texture) {

	    var type;

	    switch (texture.type) {
	    case exports.TT_RGBA_INT:
	        type = _gl.UNSIGNED_BYTE;
	        break;
	    case exports.TT_RGB_INT:
	        type = _gl.UNSIGNED_BYTE;
	        break;
	    case exports.TT_RGBA_FLOAT:
	        type = _gl.FLOAT;
	        break;
	    case exports.TT_RGB_FLOAT:
	        type = _gl.FLOAT;
	        break;
	    case exports.TT_DEPTH:
	        type = _gl.UNSIGNED_INT;
	        break;
	    default:
	        m_util.panic("Wrong texture type");
	        break;
	    }

	    return type;
	}

	function delete_texture(tex) {
	    if (tex.w_texture)
	        _gl.deleteTexture(tex.w_texture);
	    var ind = _img_textures_cache.textures.indexOf(tex);
	    if (ind != -1) {
	        _img_textures_cache.textures.splice(ind, 1);
	        _img_textures_cache.loaded_status.splice(ind, 1);
	    }
	}

	/**
	 * Check if object is a texture, renderbuffer is also a texture.
	 */
	exports.is_texture = function(tex) {
	    if (tex && (tex.w_texture || tex.w_renderbuffer))
	        return true;
	    else
	        return false;
	};

	/**
	 * Check if object is a renderbuffer
	 */
	exports.is_renderbuffer = is_renderbuffer;
	function is_renderbuffer(tex) {
	    if (tex && tex.w_renderbuffer)
	        return true;
	    else
	        return false;
	}

	exports.is_float = function(tex) {
	    if (tex.type == exports.TT_RGBA_FLOAT || tex.type == exports.TT_RGB_FLOAT)
	        return true;
	    else
	        return false;
	};

	/**
	 * Get an amount of bytes occupied by one texel.
	 */
	exports.get_texture_texel_size = function(tex) {
	    var size = 0;

	    switch (tex.type) {
	    case exports.TT_RGBA_INT:
	    case exports.TT_RGB_INT:
	        size = 4;
	        break;
	    case exports.TT_RGBA_FLOAT:
	    case exports.TT_RGB_FLOAT:
	        size = 16;
	        break;
	    case exports.TT_DEPTH:
	        size = 3;
	        break;
	    case exports.TT_RB_RGBA:
	    case exports.TT_RB_DEPTH:
	        size = 2;
	        break;
	    case exports.TT_RB_RGBA_MS:
	        size = 4 * cfg_def.msaa_samples;
	        break;
	    case exports.TT_RB_DEPTH_MS:
	        size = 3 * cfg_def.msaa_samples;
	        break;
	    }

	    return size;
	};

	function check_texture_size(width, height) {
	    return (width > cfg_lim.max_texture_size || height > cfg_lim.max_texture_size);
	}

	function check_cube_map_size(size) {
	    return size > cfg_lim.max_cube_map_texture_size;
	}

	exports.cleanup = function() {
	    if (!cfg_def.seq_video_fallback)
	        for (var data_id in _video_textures_cache)
	            for (var tex in _video_textures_cache[data_id]) {
	                _video_textures_cache[data_id][tex].video_file.pause();
	                _video_textures_cache[data_id][tex].video_file.src = "";
	                _video_textures_cache[data_id][tex].video_file.load();
	            }

	    _img_textures_cache.textures.length = 0;
	    _img_textures_cache.loaded_status.length = 0;
	    _canvas_textures_cache = {};
	    _video_textures_cache = {};
	};

	exports.pause = function() {
	    for (var data_id in _video_textures_cache)
	        for (var vtex_name in _video_textures_cache[data_id]) {
	            var vtex = _video_textures_cache[data_id][vtex_name];
	            if (!video_is_played(vtex))
	                continue;

	            pause_video(vtex);
	        }
	};

	exports.reset = function() {
	    for (var data_id in _video_textures_cache)
	        for (var vtex_name in _video_textures_cache[data_id]) {
	            var vtex = _video_textures_cache[data_id][vtex_name];
	            reset_video(vtex);
	        }
	};

	exports.play = function(resume_stopped_only) {
	    for (var data_id in _video_textures_cache)
	        for (var vtex_name in _video_textures_cache[data_id]) {
	            var vtex = _video_textures_cache[data_id][vtex_name];
	            if (resume_stopped_only && !vtex.video_was_stopped)
	                continue;
	            play_video(vtex);
	        }
	};

	exports.get_video_texture = get_video_texture;
	function get_video_texture(vtex_name, data_id) {
	    if (data_id in _video_textures_cache &&
	            vtex_name in _video_textures_cache[data_id])
	        return _video_textures_cache[data_id][vtex_name];
	    return null;
	}

	exports.video_allow_nla = video_allow_nla;
	function video_allow_nla(vtex) {
	    return vtex.use_nla;
	}

	exports.play_video = play_video;
	function play_video(vtex) {
	    if (vtex.video_file)
	        vtex.video_file.play();
	    else if (vtex.seq_video)
	        vtex.seq_video_played = true;
	    vtex.video_was_stopped = false;
	}

	exports.pause_video = pause_video;
	function pause_video(vtex) {
	    if (vtex.video_file)
	        vtex.video_file.pause();
	    else if (vtex.seq_video)
	        vtex.seq_video_played = false;
	    vtex.video_was_stopped = true;
	}

	/**
	 * Reset video texture considering its frame offset.
	 */
	exports.reset_video = reset_video;
	function reset_video(vtex) {
	    if (vtex.video_file) {
	        vtex.video_file.currentTime = vtex.frame_offset / vtex.fps;
	        // normal video will be updated through the oncanplay handler
	    } else if (vtex.seq_video) {
	        vtex.seq_cur_frame = video_frame_to_seq_frame(vtex, vtex.frame_offset);
	        update_seq_video_texture(vtex);
	    }
	}

	/**
	 * Need to pass sequential frame for a sequential video
	 */
	exports.set_frame_video = function(vtex_name, frame, data_id) {
	    if (data_id in _video_textures_cache && vtex_name in _video_textures_cache[data_id]) {
	        var vtex = _video_textures_cache[data_id][vtex_name];
	        if (vtex.video_file) {
	            vtex.video_file.currentTime = frame / vtex.fps;
	            // normal video will be updated through the oncanplay handler
	        } else if (vtex.seq_video) {
	            vtex.seq_cur_frame = frame;
	            update_seq_video_texture(vtex);
	        }
	        return true;
	    } else
	        return false;
	};

	exports.video_is_played = video_is_played;
	function video_is_played(vtex) {
	    if (vtex.video_file)
	        return !vtex.video_file.paused;
	    else if (vtex.seq_video)
	        return vtex.seq_video_played;
	    else
	        return false;
	}

	exports.video_update_is_available = video_update_is_available;
	function video_update_is_available(vtex) {
	    if (!vtex.video_file && !vtex.seq_video)
	        return 0;

	    if (vtex.video_file)
	        return vtex.video_file.readyState >= 2;
	    else
	        return true;
	}

	exports.video_get_current_frame = function(vtex) {
	    if (!vtex.video_file && !vtex.seq_video)
	        return 0;

	    if (vtex.video_file)
	        return Math.round(vtex.video_file.currentTime * vtex.fps);
	    else
	        return vtex.seq_cur_frame;
	};

	exports.video_get_start_frame = function(vtex) {
	    if (!vtex.video_file && !vtex.seq_video)
	        return 0;

	    if (vtex.video_file)
	        return vtex.frame_offset;
	    else
	        return video_frame_to_seq_frame(vtex, vtex.frame_offset);
	};

	exports.video_get_end_frame = function(vtex) {
	    if (!vtex.video_file && !vtex.seq_video)
	        return 0;

	    var duration = Math.min(vtex.frame_duration, vtex.movie_length
	            - vtex.frame_offset);
	    if (vtex.video_file)
	        return vtex.frame_offset + duration;
	    else
	        return video_frame_to_seq_frame(vtex, vtex.frame_offset + duration);
	};

	/**
	 * Convert continuous time to a discrete mark. Suitable for a frame changing detection.
	 */
	exports.seq_video_get_discrete_timemark = function(vtex, time) {
	    return Math.round((time * vtex.seq_fps) * (m_time.get_framerate() / vtex.fps));
	};

	/**
	 * Not for sequential video, result is needed to convert.
	 */
	exports.video_get_duration = function(vtex) {
	    return Math.min(vtex.frame_duration, vtex.movie_length - vtex.frame_offset);
	};

	exports.video_frame_to_seq_frame = video_frame_to_seq_frame;
	function video_frame_to_seq_frame(vtex, frame) {
	    return Math.round(frame * vtex.seq_movie_length / vtex.movie_length);
	}

	exports.get_canvas_context_by_object = function(object, texture_name) {

	    var texture = get_texture_by_name(object, texture_name);
	    if (texture && texture.source == "CANVAS")
	        return texture.canvas_context;
	    else
	        return null;
	};

	exports.get_texture_by_name = get_texture_by_name;
	function get_texture_by_name(object, texture_name) {

	    if (m_obj_util.is_dynamic(object))
	        return get_texture_by_name_obj(object, texture_name);
	    else {
	        var objects = object.meta_objects;
	        for (var i = 0; i < objects.length; i++) {
	            var texture = get_texture_by_name_obj(objects[i], texture_name);
	            if (texture)
	                return texture;
	        }
	    }
	    return null;
	}

	exports.set_texture_by_name = set_texture_by_name;
	function set_texture_by_name(object, texture_name, new_texture) {
	    if (m_obj_util.is_dynamic(object))
	        set_texture_by_name_obj(object, texture_name, new_texture);
	    else {
	        var objects = object.meta_objects;
	        for (var i = 0; i < objects.length; i++)
	            set_texture_by_name_obj(objects[i], texture_name, new_texture);
	    }
	}

	exports.get_texture_names = function(object) {
	    var tex_names = [];
	    if (m_obj_util.is_dynamic(object))
	        find_texture_names(object, tex_names);
	    else {
	        var objects = object.meta_objects;
	        for (var i = 0; i < objects.length; i++)
	            find_texture_names(objects[i], tex_names);
	    }
	    return tex_names;
	};

	function get_texture_by_name_obj(obj, texture_name) {
	    var scenes_data = obj.scenes_data;
	    if (scenes_data.length) {
	        var scene_data = scenes_data[0];
	        var batches = scene_data.batches;
	        for (var k = 0; k < batches.length; k++) {
	            var batch = batches[k];
	            if (batch.type == "MAIN" || batch.type == "SKY")
	                for (var p = 0; p < batch.textures.length; p++)
	                    if (batch.bpy_tex_names[p] == texture_name)
	                        return batch.textures[p];
	        }
	    }
	    return null;
	}

	function set_texture_by_name_obj(obj, texture_name, new_texture) {
	    var scenes_data = obj.scenes_data;
	    if (scenes_data.length) {
	        var scene_data = scenes_data[0];
	        var batches = scene_data.batches;
	        for (var i = 0; i < batches.length; i++) {
	            var batch = batches[i];
	            if (batch.type == "MAIN") {
	                for (var j = 0; j < batch.textures.length; j++) {
	                    var tex_name = batch.bpy_tex_names[j];
	                    if (tex_name == texture_name) {
	                        var old_tex = batch.textures[j];
	                        batch.textures[j] = new_texture;
	                        cleanup_unused(old_tex);
	                    }
	                }
	            }
	        }
	    }
	}

	function find_texture_names(obj, names) {
	    var scenes_data = obj.scenes_data;
	    if (scenes_data.length) {
	        var scene_data = scenes_data[0];
	        var batches = scene_data.batches;
	        for (var k = 0; k < batches.length; k++) {
	            var batch = batches[k];
	            if (batch.type == "MAIN")
	                for (var p = 0; p < batch.textures.length; p++) {
	                    var tex = batch.textures[p];
	                    var tex_name = batch.bpy_tex_names[p];
	                    if (names.indexOf(tex_name) == -1 && tex.source != "NODE_TEX")
	                        names.push(tex_name);
	                }
	        }
	    }
	}

	function copy_canvas_texture(texture) {

	    var new_texture = init_texture();
	    new_texture.source = "CANVAS";
	    new_texture.width = texture.width;
	    new_texture.height = texture.height;
	    new_texture.enable_canvas_mipmapping = texture.enable_canvas_mipmapping;
	    new_texture.type = texture.type;

	    var canvas = document.createElement("canvas");
	    canvas.width  = new_texture.width;
	    canvas.height = new_texture.height;

	    new_texture.canvas_context = canvas.getContext("2d");

	    new_texture.w_target = _gl.TEXTURE_2D;
	    new_texture.w_texture = _gl.createTexture();

	    _gl.bindTexture(_gl.TEXTURE_2D, new_texture.w_texture);

	    if (new_texture.enable_canvas_mipmapping)
	        _gl.texParameteri(_gl.TEXTURE_2D, _gl.TEXTURE_MIN_FILTER, LEVELS[cfg_def.texture_min_filter]);
	    else
	        _gl.texParameteri(_gl.TEXTURE_2D, _gl.TEXTURE_MIN_FILTER, _gl.LINEAR);
	    _gl.texParameteri(_gl.TEXTURE_2D, _gl.TEXTURE_MAG_FILTER, _gl.LINEAR);

	    _gl.bindTexture(_gl.TEXTURE_2D, null);

	    // update_texture_canvas will be called later

	    return new_texture;
	}

	exports.share_batch_canvas_textures = function(batches) {

	    var canvas_textures = {};

	    for (var i = 0; i < batches.length; i++) {
	        var textures = batches[i].textures;
	        var texture_names = batches[i].texture_names;
	        var batch_textures = [];
	        var batch_texture_names = [];

	        for (var j = 0; j < textures.length; j++) {
	            var texture = textures[j];
	            var texture_name = texture_names[j];
	            if (texture.source == "CANVAS") {
	                if (texture_name in canvas_textures)
	                    texture = canvas_textures[texture_name];
	                else {
	                    texture = copy_canvas_texture(textures[j]);
	                    draw_canvas_to_canvas(texture, textures[j]);
	                    canvas_textures[texture_name] = texture;
	                }
	            }
	            batch_textures.push(texture);
	            batch_texture_names.push(texture_name);
	        }
	        batches[i].textures = batch_textures;
	    }
	};

	function draw_canvas_to_canvas(new_tex, old_tex) {

	    var old_ctx = old_tex.canvas_context;
	    var new_ctx = new_tex.canvas_context;
	    new_ctx.drawImage(old_ctx.canvas, 0, 0);
	    update_texture_canvas(new_tex);

	}

	exports.extract_col_ramps_data = function(nodes, points_num) {

	    var texture = [];

	    for (var j = 0; j < nodes.length; j++) {
	        var bpy_node = nodes[j].data.value;
	        calc_color_ramp_data(bpy_node["color_ramp"], points_num, texture);
	    }

	    return new Uint8Array(texture.map(function(val) {return m_util.clamp(val * 255,
	        0, 255)}));
	};

	exports.calc_color_ramp_data = calc_color_ramp_data;
	function calc_color_ramp_data(color_ramp, points_num, texture) {
	    var elements = color_ramp["elements"];
	    var type = color_ramp["interpolation"];
	    for (var i = 0; i < points_num; i++) {

	        var curr_position = i / (points_num - 1);

	        var left_elem = find_left_elem(elements, curr_position, true);
	        var right_elem = find_right_elem(elements, curr_position, true);

	        if (left_elem && right_elem)
	            if (type == "CONSTANT")
	                texture.push.apply(texture, left_elem.color);
	            else
	                create_linear_middle(texture, left_elem, right_elem, curr_position);

	        if (right_elem && !left_elem)
	            texture.push.apply(texture, right_elem.color);

	        if (left_elem && !right_elem)
	            texture.push.apply(texture, left_elem.color);
	    }
	}

	function create_linear_middle(texture, left_elem, right_elem, curr_position) {
	    if (left_elem == right_elem)
	        texture.push.apply(texture, left_elem["color"]);
	    else {
	        var r = m_curve.linear_interpolation(right_elem["color"][0], right_elem["position"],
	                left_elem["color"][0], left_elem["position"], curr_position);
	        texture.push(r);
	        var g = m_curve.linear_interpolation(right_elem["color"][1], right_elem["position"],
	                left_elem["color"][1], left_elem["position"], curr_position);
	        texture.push(g);
	        var b = m_curve.linear_interpolation(right_elem["color"][2], right_elem["position"],
	                left_elem["color"][2], left_elem["position"], curr_position);
	        texture.push(b);
	        var a = m_curve.linear_interpolation(right_elem["color"][3], right_elem["position"],
	                left_elem["color"][3], left_elem["position"], curr_position);
	        texture.push(a);
	    }
	}

	function find_left_elem(elements, curr_pos, is_color_ramp) {
	    var left_elem = null;
	    for (var i = 0; i < elements.length; i++) {
	        if (is_color_ramp)
	            var dist = curr_pos - elements[i]["position"];
	        else
	            var dist = curr_pos - elements[i][1][0];
	        if (dist >= 0)
	            if (left_elem) {
	                if (is_color_ramp)
	                    var cur_dist = curr_pos - left_elem["position"];
	                else
	                    var cur_dist = curr_pos - elements[i][1][0];
	                if (dist <= cur_dist)
	                    left_elem = elements[i];
	            } else
	                left_elem = elements[i];
	    }
	    return left_elem;
	}

	function find_right_elem(elements, curr_pos, is_color_ramp) {
	    var right_elem = null;
	    for (var i = 0; i < elements.length; i++) {
	        if (is_color_ramp)
	            var dist = elements[i]["position"] - curr_pos;
	        else
	            var dist = elements[i][1][0] - curr_pos;
	        if (dist >= 0)
	            if (right_elem) {
	                if (is_color_ramp)
	                    var cur_dist = right_elem["position"] - curr_pos;
	                else
	                    var cur_dist = right_elem[1][0] - curr_pos;
	                if (dist <= cur_dist)
	                    right_elem = elements[i];
	            } else
	                right_elem = elements[i];
	    }
	    return right_elem;
	}

	exports.extract_vec_curves_data = function(nodes, points_num) {

	    var _vec3_tmp = new Float32Array(3);
	    var vec = new Float32Array(3);

	    var textures = [];

	    for (var q = 0; q < nodes.length; q++) {

	        var bpy_node = nodes[q].data.value;
	        var channels = [];
	        var curves = bpy_node["curve_mapping"]["curves_data"];
	        var points_ext_types = bpy_node["curve_mapping"]["curve_extend"];
	        var curves_handle_types = bpy_node["curve_mapping"]["curves_handle_types"];

	        for (var i = 0; i < curves.length; i++) {
	            var type = points_ext_types[i];
	            var curve = curves[i];
	            var bezts = [];
	            var curve_handle_types = curves_handle_types[i];
	            for (var j = 0; j < curve.length; j++)
	                bezts.push([
	                    new Float32Array(3),
	                    new Float32Array(curve[j].concat(0)),
	                    new Float32Array(3)
	                    ]);

	            m_curve.calchandle_curvemap(bezts[0], null, bezts[1], curve_handle_types[0],
	                    curve_handle_types[0]);
	            for (var j = 1; j < bezts.length - 1; j++)
	                m_curve.calchandle_curvemap(bezts[j], bezts[j - 1], bezts[j + 1], curve_handle_types[j],
	                        curve_handle_types[j]);
	            m_curve.calchandle_curvemap(bezts[bezts.length - 1], bezts[bezts.length - 2], null,
	                    curve_handle_types[bezts.length - 1], curve_handle_types[bezts.length - 1]);

	            if (bezts.length > 2) {
	                if (curve_handle_types[0] == "AUTO") {
	                    m_vec3.subtract(bezts[0][2], bezts[0][1], _vec3_tmp);
	                    var hlen = m_vec3.length(_vec3_tmp);

	                    m_vec3.copy(bezts[1][0], vec);
	                    if (vec[0] < bezts[0][1][0])
	                        vec[0] = bezts[0][1][0];
	                    m_vec3.subtract(vec, bezts[0][1], vec);
	                    var nlen = m_vec3.length(vec);
	                    if (nlen > FLT_EPSILON) {
	                        m_vec3.scale(vec, hlen / nlen, vec);
	                        m_vec3.add(bezts[0][1], vec, bezts[0][2]);
	                        m_vec3.subtract(bezts[0][1], vec, bezts[0][0]);
	                    }
	                }

	                var a = bezts.length - 1;
	                if (curve_handle_types[0] == "AUTO") {
	                    m_vec3.subtract(bezts[a][0], bezts[a][1], _vec3_tmp);
	                    var hlen = m_vec3.length(_vec3_tmp);

	                    m_vec3.copy(bezts[a - 1][2], vec);
	                    if (vec[0] > bezts[a][1][0])
	                        vec[0] = bezts[a][1][0];

	                    m_vec3.subtract(vec, bezts[a][1], vec);
	                    var nlen = m_vec3.length(vec);

	                    if (nlen > FLT_EPSILON) {
	                        m_vec3.scale(vec, hlen / nlen, vec);
	                        m_vec3.add(bezts[a][1], vec, bezts[a][0]);
	                        m_vec3.subtract(bezts[a][1], vec, bezts[a][2]);
	                    }
	                }
	            }

	            for (var a = 0; a < bezts.length - 1; a++)
	                m_curve.correct_bezpart(bezts[a][1], bezts[a][2], bezts[a + 1][0], bezts[a + 1][1]);

	            var texture = [];
	            if (curves.length <= 3) {
	                var start = Math.round(- points_num/ 2);
	                var end = Math.round(points_num / 2);
	            } else {
	                var start = 0;
	                var end = points_num;
	            }
	            for (var j = start; j < end; j++) {

	                var curr_position = j / (end - 1);

	                var left_elem = find_left_elem(bezts, curr_position, false);
	                var right_elem = find_right_elem(bezts, curr_position, false);

	                if (left_elem && right_elem)
	                    texture.push(m_curve.bezier(curr_position, left_elem[1], left_elem[2],
	                            right_elem[0], right_elem[1], BEZIER_ROOT_PRECISION));
	                else if (right_elem && !left_elem)
	                        if (type == "EXTRAPOLATED") {
	                            var val = right_elem[1][0] == right_elem[2][0] ? right_elem[1][1]
	                                    : m_curve.linear(curr_position, right_elem[1], right_elem[2]);
	                            texture.push(val);
	                        } else
	                            texture.push(right_elem[1][1]);
	                    else if (left_elem && !right_elem)
	                        if (type == "EXTRAPOLATED") {
	                            var val = left_elem[0][0] == left_elem[1][0] ? left_elem[1][1]
	                                    : m_curve.linear(curr_position, left_elem[0], left_elem[1]);
	                            texture.push(val);
	                        } else
	                            texture.push(left_elem[1][1]);
	            }
	            channels.push(texture);
	        }
	        textures.push(channels);
	    }

	    var tex = [];
	    for (var j = 0; j < textures.length; j++) {
	        var channels = textures[j];
	        for (var i = 0; i < channels[0].length; i++) {
	            if (channels.length <= 3) {
	                var r = m_util.clamp((channels[0][i] + 1) * 127.5, 0, 255);
	                var g = m_util.clamp((channels[1][i] + 1) * 127.5, 0, 255);
	                var b = m_util.clamp((channels[2][i] + 1) * 127.5, 0, 255);
	                var a = 255;
	            } else {
	                var r = m_util.clamp(channels[0][i] * 255, 0, 255);
	                var g = m_util.clamp(channels[1][i] * 255, 0, 255);
	                var b = m_util.clamp(channels[2][i] * 255, 0, 255);
	                var a = m_util.clamp(channels[3][i] * 255, 0, 255);
	            }
	            tex.push(r, g, b, a);
	        }
	    }
	    return new Uint8Array(tex);
	};

	/**
	 * Combines several ramps one below another on a single texture
	 */
	exports.create_color_ramp_texture = function(image_data, width) {
	    var tex = create_texture(exports.TT_RGBA_INT, false);
	    tex.source = "NODE_TEX";
	    tex.repeat = false;
	    var tex_data = {
	        width: width,
	        height: image_data.length / (width * 4),
	        data: image_data
	    };
	    update_texture(tex, tex_data);
	    return tex;
	};

	exports.change_image = function(object, texture, texture_name, image, path) {
	    var norm_path = m_util.normpath_preserve_protocol(path);
	    if (object.type != "WORLD") {
	        var cached_tex = find_similar_tex(norm_path, texture);
	        if (cached_tex)
	            var texture_new = cached_tex;
	        else {
	            var texture_new = clone_texture(texture);
	            clone_w_texture(texture, texture_new);
	            set_params_by_img_path(texture_new, path, norm_path);
	            update_texture(texture_new, image, 0);
	        }
	        set_texture_by_name(object, texture_name, texture_new);
	    } else {
	        var texture_new = texture;
	        set_params_by_img_path(texture_new, path, norm_path);
	        update_texture(texture_new, image, 0);
	        m_scs.update_cube_sky_dim(object, texture_new);
	        m_scs.update_sky_texture(object);
	    }
	};

	exports.cleanup_unused = cleanup_unused;
	function cleanup_unused(tex) {
	    // NOTE: need to detach the texture from a batch before this check to 
	    // not count an additional user
	    if (!cfg_def.enable_texture_cache && !check_users(tex))
	        delete_texture(tex);
	}

	function check_users(tex) {
	    var objs = m_objs.get_all_objects("ALL", m_objs.DATA_ID_ALL);

	    for (var i = 0; i < objs.length; i++) {
	        var obj = objs[i];
	        if (check_users_by_obj(obj, tex))
	            return true;
	        var meta_objs = obj.meta_objects;
	        for (var j = 0; j < meta_objs.length; j++) {
	            if (check_users_by_obj(meta_objs[j], tex))
	                return true;
	        }
	    }
	    return false;
	}

	function check_users_by_obj(obj, tex) {
	    for (var j = 0; j < obj.scenes_data.length; j++) {
	        var batches = obj.scenes_data[j].batches;
	        for (var k = 0; k < batches.length; k++) {
	            var batch = batches[k];
	            var textures = batch.textures;
	            for (var m = 0; m < textures.length; m++) {
	                if (textures[m] == tex)
	                    return true;
	            }
	        }
	    }
	}

	function find_similar_tex(img_path, texture) {
	    for (var i = 0; i < _img_textures_cache.textures.length; i++) {
	        var tex = _img_textures_cache.textures[i];
	        if (tex.img_full_filepath == img_path &&
	                tex.type == texture.type &&
	                tex.source == texture.source &&
	                tex.repeat == texture.repeat &&
	                tex.anisotropic_filtering == texture.anisotropic_filtering &&
	                tex.use_nla == texture.use_nla)
	            return tex;
	    }
	    return null;
	}

	/**
	 * Extract b4w texture from slot
	 */
	exports.get_batch_texture = function(texture_slot) {
	    var bpy_texture = texture_slot["texture"];
	    return bpy_texture._render;
	};

	exports.reset_mod = function() {
	    _gl = null;
	};

	exports.get_img_textures = function() {
	    return _img_textures_cache.textures;
	};

	exports.get_cache_loaded_status = function(tex) {
	    var ind = _img_textures_cache.textures.indexOf(tex);
	    return ind == -1 ? false : _img_textures_cache.loaded_status[ind];
	};

	exports.set_cache_loaded_status = function(tex, is_loaded) {
	    var ind = _img_textures_cache.textures.indexOf(tex);
	    if (ind != -1)
	        _img_textures_cache.loaded_status[ind] = is_loaded;
	};

	}

	var int_textures_factory = register("__textures", Int_textures);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Rendering internal API.
	 * Performs most of GPU (WebGL) operations.
	 * GL context is registered by setup_context() function.
	 * @name renderer
	 * @namespace
	 * @exports exports as renderer
	 */
	function Int_renderer(ns, exports) {

	var m_batch    = int_batch_factory(ns);
	var m_cam      = int_camera_factory(ns);
	var m_cfg      = int_config_factory(ns);
	var m_debug    = int_debug_factory(ns);
	var m_ext      = int_extensions_factory(ns);
	var m_geom     = int_geometry_factory(ns);
	var m_quat     = quat_factory(ns);
	var m_subs     = int_subscene_factory(ns);
	var m_textures = int_textures_factory(ns);
	var m_tsr      = int_tsr_factory(ns);
	var m_util     = int_util_factory(ns);
	var m_ver      = int_version_factory(ns);
	var m_vec3     = vec3_factory(ns);

	var USE_BACKFACE_CULLING = true;

	// special backgroud color for shadow map
	var SHADOW_BG_COLOR = [1, 0, 0, 1];
	var DEPTH_BG_COLOR = [1, 1, 1, 1];
	var COLOR_PICKING_BG_COLOR = [0,0,0,1];
	var BLACK_BG_COLOR = [0,0,0,0];

	var SKY_HACK_COLOR = new Uint8Array([0.36*255, 0.56*255, 0.96*255, 255]);

	var CUBEMAP_UPPER_SIDE = 4;
	var CUBEMAP_BOTTOM_SIDE = 5;

	// smaa stuff
	var DEBUG_VIEW_RT_SMOOTH_INTERVALS = 15;

	var _gl = null;
	var _gl_draw_elems_inst = null;
	var _gl_vert_attr_div = null;
	var _gl_draw_array = null;

	var _gl_bind_vertex_array = null;

	var _draw_batch = null;

	var _vec3_tmp  = new Float32Array(3);
	var _quat_tmp  = m_quat.create();
	var _ivec4_tmp = new Uint8Array(4);

	var cfg_def = m_cfg.defaults;

	/**
	 * Setup WebGL context
	 * @param gl WebGL context
	 */
	exports.setup_context = function(gl) {

	    var bc = cfg_def.background_color;
	    gl.clearColor(bc[0], bc[1], bc[2], bc[3]);
	    gl.clearDepth(1.0);
	    gl.enable(gl.DEPTH_TEST);
	    gl.depthFunc(gl.LEQUAL);

	    if (USE_BACKFACE_CULLING) {
	        gl.enable(gl.CULL_FACE);
	        gl.frontFace(gl.CCW);
	        gl.cullFace(gl.BACK);
	    } else {
	        gl.disable(gl.CULL_FACE);
	    }
	    gl.enable(gl.BLEND);

	    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

	    // http://stackoverflow.com/questions/11521035/blending-with-html-background-in-webgl
	    //gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

	    _gl = gl;
	};


	/**
	 * Draw renders and batch to camera
	 */
	exports.draw = function(subscene) {

	    if (!subscene.do_render || subscene.force_do_not_render)
	        return;

	    if (subscene.type == m_subs.RESOLVE) {
	        m_debug.render_time_start_subs(subscene);
	        draw_resolve(subscene);
	        m_debug.render_time_stop_subs(subscene);

	        m_debug.check_gl("draw resolve");
	    } else if (subscene.type == m_subs.COPY) {
	        m_debug.render_time_start_subs(subscene);
	        draw_copy(subscene);
	        m_debug.render_time_stop_subs(subscene);

	        m_debug.check_gl("draw copy");
	    } else {
	        m_debug.render_time_start_subs(subscene);
	        prepare_subscene(subscene);

	        if (subscene.type == m_subs.MAIN_CUBE_REFLECT || subscene.type == m_subs.MAIN_CUBE_REFLECT_BLEND)
	            draw_cube_reflection_subs(subscene);
	        else
	            draw_subs(subscene);

	        m_debug.render_time_stop_subs(subscene);

	        m_debug.check_gl("draw subscene: " + m_subs.subs_label(subscene));
	        // NOTE: fix for strange issue with skydome rendering
	        // NOTE: commented below code was checked on Windows. All is fine.
	        // _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
	    }
	};

	function draw_cube_reflection_subs(subscene) {
	    var camera           = subscene.camera;
	    var color_attachment = camera.color_attachment;
	    var w_tex            = color_attachment.w_texture;

	    // cube reflections are rendered in 6 directions
	    for (var i = 0; i < 6; i++) {
	        var w_target = get_cube_target_by_id(i);
	        camera.view_matrix = subscene.cube_view_matrices[i];
	        m_tsr.from_mat4(camera.view_matrix, camera.view_tsr);

	        m_cam.calc_sky_vp_inverse(camera);

	        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0,
	            w_target, w_tex, 0);

	        clear_binded_framebuffer(subscene);

	        var draw_data = subscene.draw_data;
	        for (var j = 0; j < draw_data.length; j++)
	            for (var k = 0; k < draw_data[j].bundles.length; k++) {
	                var bundle = draw_data[j].bundles[k];
	                bundle.do_render = bundle.do_render_cube[i];
	            }
	        draw_subs(subscene);
	    }
	}

	function draw_resolve(subscene) {
	    var camera = subscene.camera;

	    _gl.bindFramebuffer(_gl.READ_FRAMEBUFFER, camera.framebuffer_prev);
	    _gl.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, camera.framebuffer);

	    var blit_mask = 0;

	    if (camera.color_attachment)
	        blit_mask |= _gl.COLOR_BUFFER_BIT;

	    if (camera.depth_attachment)
	        blit_mask |= _gl.DEPTH_BUFFER_BIT;

	    _gl.blitFramebuffer(
	            0, 0, camera.width, camera.height,
	            0, 0, camera.width, camera.height,
	            blit_mask, _gl.NEAREST);
	}

	function draw_copy(subscene) {
	    var camera = subscene.camera;

	    _gl.bindFramebuffer(_gl.FRAMEBUFFER, camera.framebuffer_prev);

	    var tex = camera.color_attachment;
	    var w_tex = tex.w_texture;
	    _gl.bindTexture(_gl.TEXTURE_2D, w_tex);

	    _gl.copyTexSubImage2D(_gl.TEXTURE_2D, 0,
	            0, 0, 0, 0, camera.width, camera.height, 0);
	}

	function draw_subs(subscene) {
	    var camera = subscene.camera;
	    var draw_data = subscene.draw_data;
	    var current_program = null;

	    var eye = m_tsr.get_trans(camera.world_tsr, _vec3_tmp);

	    for (var i = 0; i < draw_data.length; i ++) {

	        var ddata = draw_data[i];

	        if (!ddata.do_render)
	            continue;

	        var shader = ddata.shader;
	        var bundles = ddata.bundles;

	        if (shader.program != current_program) {
	            _gl.useProgram(shader.program);
	            setup_scene_uniforms(subscene, camera, shader);
	            current_program = shader.program;
	        }

	        if (ddata.alpha_antialiasing) {
	            _gl.enable(_gl.SAMPLE_ALPHA_TO_COVERAGE);
	            if (!subscene.blend)
	                _gl.enable(_gl.BLEND);
	        } else {
	            _gl.disable(_gl.SAMPLE_ALPHA_TO_COVERAGE);
	            if (!subscene.blend)
	                _gl.disable(_gl.BLEND);
	        }

	        for (var j = 0; j < bundles.length; j++) {
	            var bundle = bundles[j];
	            if (bundle.do_render) {
	                var obj_render = bundle.obj_render;
	                var batch = bundle.batch;

	                m_debug.render_time_start_batch(batch);
	                if (m_debug.is_debug_view_render_time_mode() && batch.type == "DEBUG_VIEW")
	                    batch.debug_main_batch_render_time = m_util.smooth(
	                            m_batch.batch_get_debug_storage(batch.debug_main_batch_id),
	                            batch.debug_main_batch_render_time, 1, DEBUG_VIEW_RT_SMOOTH_INTERVALS);

	                if (cfg_def.alpha_sort && batch.z_sort) // do it right before drawing
	                    zsort(batch, obj_render, bundle.info_for_z_sort_updates, eye);

	                draw_bundle(subscene, obj_render, batch, shader);

	                m_debug.render_time_stop_batch(batch);
	                if (m_debug.is_debug_view_render_time_mode() && batch.type == "MAIN")
	                    m_batch.batch_set_debug_storage(batch.id, batch.debug_render_time);
	            }
	        }
	    }
	}

	function setup_scene_uniforms(subs, camera, shader) {
	    var transient_sc_uniform_setters = shader.transient_sc_uniform_setters;
	    var i = transient_sc_uniform_setters.length;
	    while (i--) {
	        var setter = transient_sc_uniform_setters[i];
	        setter.fun(_gl, setter.loc, subs, camera);
	    }

	    if (shader.need_uniforms_update && !shader.no_permanent_uniforms) {
	        if (!shader.permanent_sc_uniform_setters.length)
	            assign_uniform_setters(shader);

	        var permanent_sc_uniform_setters = shader.permanent_sc_uniform_setters;
	        var j = permanent_sc_uniform_setters.length;
	        while (j--) {
	            var setter = permanent_sc_uniform_setters[j];
	            setter.fun(_gl, setter.loc, subs, camera);
	        }
	    }
	}

	exports.clear = function(subscene) {
	    var camera = subscene.camera;
	    _gl.bindFramebuffer(_gl.FRAMEBUFFER, camera.framebuffer);
	    clear_binded_framebuffer(subscene);
	};

	function prepare_subscene(subscene) {

	    var camera = subscene.camera;

	    _gl.bindFramebuffer(_gl.FRAMEBUFFER, camera.framebuffer);

	    if (subscene.assign_texture) {
	        var tex = camera.color_attachment;
	        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0,
	            tex.w_target, tex.w_texture, 0);
	    }

	    _gl.viewport(0, 0, camera.width, camera.height);

	    if (subscene.type != m_subs.MAIN_CUBE_REFLECT && subscene.type != m_subs.MAIN_CUBE_REFLECT_BLEND)
	        clear_binded_framebuffer(subscene);

	    if (subscene.blend)
	        _gl.enable(_gl.BLEND);
	    else
	        _gl.disable(_gl.BLEND);

	    if (subscene.depth_test)
	        _gl.enable(_gl.DEPTH_TEST);
	    else
	        _gl.disable(_gl.DEPTH_TEST);

	    // prevent self-shadow issues
	    switch (subscene.type) {
	    case m_subs.SHADOW_CAST:
	        _gl.enable(_gl.POLYGON_OFFSET_FILL);
	        _gl.polygonOffset(subscene.self_shadow_polygon_offset,
	                subscene.self_shadow_polygon_offset);
	        /*
	         * bad as it leads to impossibility to use backface culling
	         * for some objects.
	         * _gl.cullFace(_gl.FRONT);
	         */
	        _gl.cullFace(_gl.BACK);
	        break;
	    case m_subs.MAIN_PLANE_REFLECT:
	    case m_subs.MAIN_PLANE_REFLECT_BLEND:
	        _gl.disable(_gl.POLYGON_OFFSET_FILL);
	        _gl.cullFace(_gl.FRONT);
	        break;
	    case m_subs.DEBUG_VIEW:
	        // to overlap other batches
	        _gl.enable(_gl.POLYGON_OFFSET_FILL);
	        _gl.polygonOffset(-4, -4);
	        _gl.cullFace(_gl.BACK);
	        break;
	    case m_subs.MAIN_GLOW:
	        if (cfg_def.msaa_samples > 1 || cfg_def.safari_glow_hack) {
	            // correct resolved depth offset
	            _gl.enable(_gl.POLYGON_OFFSET_FILL);
	            _gl.polygonOffset(-2, -2);
	            break;
	        }
	        // else continue to default
	    default:
	        _gl.disable(_gl.POLYGON_OFFSET_FILL);
	        _gl.cullFace(_gl.BACK);
	    }

	    // NOTE: temoporary disabled T2X mode due to artifacts with blend objects
	    //if (cfg_def.smaa)
	    //    setup_smaa_jitter(subscene);
	}

	function clear_binded_framebuffer(subscene) {
	    if (subscene) {
	        var bitfield = (subscene.clear_color ? _gl.COLOR_BUFFER_BIT : 0) |
	            (subscene.clear_depth ? _gl.DEPTH_BUFFER_BIT : 0);

	        // do nothing
	        if (!bitfield)
	            return;

	        // NOTE: place in graph module?
	        switch (subscene.type) {
	        case m_subs.MAIN_GLOW:
	            var bc = BLACK_BG_COLOR;
	            break;
	        case m_subs.SHADOW_CAST:
	            var bc = SHADOW_BG_COLOR;
	            break;
	        case m_subs.SHADOW_RECEIVE:
	            var bc = DEPTH_BG_COLOR;
	            break;
	        case m_subs.COLOR_PICKING:
	        case m_subs.COLOR_PICKING_XRAY:
	        case m_subs.ANCHOR_VISIBILITY:
	            var bc = COLOR_PICKING_BG_COLOR;
	            break;
	        case m_subs.OUTLINE_MASK:
	        case m_subs.SMAA_BLENDING_WEIGHT_CALCULATION:
	        case m_subs.SMAA_EDGE_DETECTION:
	            var bc = BLACK_BG_COLOR;
	            break;
	        default:
	            var bc = cfg_def.background_color;
	            break;
	        }
	    } else {
	        var bitfield = _gl.COLOR_BUFFER_BIT | _gl.DEPTH_BUFFER_BIT;
	        var bc = cfg_def.background_color;
	    }

	    // NOTE: activate them to make proper clean
	    _gl.colorMask(true, true, true, true);
	    _gl.depthMask(true);

	    _gl.clearColor(bc[0], bc[1], bc[2], bc[3]);
	    _gl.clear(bitfield);
	}

	function draw_bundle(subscene, obj_render, batch, shader) {
	    // setup uniforms
	    var transient_uniform_setters = shader.transient_uniform_setters;
	    var i = transient_uniform_setters.length;
	    while (i--) {
	        var setter = transient_uniform_setters[i];
	        setter.fun(_gl, setter.loc, obj_render, batch);
	    }

	    if (shader.need_uniforms_update && !shader.no_permanent_uniforms) {
	        if (!shader.permanent_uniform_setters.length)
	            assign_uniform_setters(shader);

	        var permanent_uniform_setters = shader.permanent_uniform_setters;
	        var j = permanent_uniform_setters.length;
	        while (j--) {
	            var setter = permanent_uniform_setters[j];
	            setter.fun(_gl, setter.loc, obj_render, batch);
	        }
	        shader.need_uniforms_update = false;
	    }

	    _gl.depthMask(batch.depth_mask);

	    if (USE_BACKFACE_CULLING) {
	        if (batch.use_backface_culling)
	            _gl.enable(_gl.CULL_FACE);
	        else
	            _gl.disable(_gl.CULL_FACE);
	    }

	    setup_textures(batch.textures);

	    if (subscene.type == m_subs.SKY || subscene.type == m_subs.IRRADIANCE) {
	        draw_sky(subscene, batch, shader);
	        subscene.debug_render_calls+=6;
	    } else if (subscene.type == m_subs.ROUGHNESS_CONVOLUTION) {
	        draw_r_convolution(subscene, batch, shader);
	        subscene.debug_render_calls+=6*5;
	    } else {
	        _draw_batch(batch, obj_render.va_frame);
	        subscene.debug_render_calls++;
	    }
	}

	/**
	 * Perform Z-sort when camera moves
	 */
	function zsort(batch, obj_render, info, eye) {

	    var bufs_data = batch.bufs_data;

	    // update if camera shifted enough
	    var cam_shift = m_vec3.dist(eye, info.zsort_eye_last);

	    // take batch geometry size into account
	    var shift_param = cfg_def.alpha_sort_threshold * Math.min(info.bb_min_side, 1);
	    var batch_cam_updated = cam_shift > shift_param;

	    if (!batch_cam_updated && !obj_render.force_zsort)
	        return;

	    m_geom.update_buffers_movable(bufs_data, info, obj_render.world_tsr, eye);

	    // remember new coords
	    m_vec3.copy(eye, info.zsort_eye_last);

	    obj_render.force_zsort = false;
	}

	function draw_sky(subscene, batch, shader) {

	    var camera = subscene.camera;
	    var uniforms = shader.uniforms;
	    var color_attachment = camera.color_attachment;
	    var w_tex            = color_attachment.w_texture;
	    var w_tar            = color_attachment.w_target;

	    var v_matrs = subscene.cube_view_matrices;

	    for (var i = 0; i < 6; i++) {
	        var w_target = get_cube_target_by_id(i);

	        if (cfg_def.clear_procedural_sky_hack) {
	            var w_target_cube = _gl.TEXTURE_CUBE_MAP;
	            _gl.bindTexture(w_target_cube, w_tex);
	            _gl.texImage2D(w_target, 0, _gl.RGBA,
	                    1, 1, 0, _gl.RGBA, _gl.UNSIGNED_BYTE, SKY_HACK_COLOR);
	        } else {
	            _gl.uniformMatrix4fv(uniforms["u_cube_view_matrix"], false, v_matrs[i]);

	            _gl.uniform4fv(uniforms["u_sky_tex_fac"], subscene.sky_tex_fac);
	            _gl.uniform3fv(uniforms["u_sky_tex_color"], subscene.sky_tex_color);
	            _gl.uniform1f(uniforms["u_sky_tex_dvar"], subscene.sky_tex_default_value);
	            _gl.uniform3fv(uniforms["u_horizon_color"], subscene.horizon_color);
	            _gl.uniform3fv(uniforms["u_zenith_color"], subscene.zenith_color);

	            _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0,
	                w_target, w_tex, 0);
	            _draw_batch(batch, 0);
	        }
	        if (subscene.need_fog_update && i != CUBEMAP_BOTTOM_SIDE)
	            update_subs_sky_fog(subscene, i);
	    }

	    if (cfg_def.texture_lod_available) {
	        _gl.bindTexture(w_tar, w_tex);
	        _gl.generateMipmap(w_tar);
	        _gl.texParameteri(w_tar, _gl.TEXTURE_MIN_FILTER, m_textures.TF_LINEAR_MIPMAP_LINEAR);
	    }
	}

	function draw_r_convolution(subscene, batch, shader) {
	    var camera = subscene.camera;
	    var uniforms = shader.uniforms;
	    var color_attachment = camera.color_attachment;
	    var w_tex            = color_attachment.w_texture;
	    var w_tar            = color_attachment.w_target;

	    var v_matrs = subscene.cube_view_matrices;

	    if (cfg_def.texture_lod_available) {
	        _gl.activeTexture(_gl.TEXTURE7);
	        _gl.bindTexture(w_tar, w_tex);
	        _gl.generateMipmap(w_tar);
	        _gl.texParameteri(w_tar, _gl.TEXTURE_MIN_FILTER, m_textures.TF_LINEAR_MIPMAP_LINEAR);
	    }


	    var maxMipLevels = 5;
	    for (var mip = 0; mip < maxMipLevels; ++mip) {
	        var mip_width  = 128 * Math.pow(0.5, mip);
	        var mip_height = 128 * Math.pow(0.5, mip);

	        _gl.viewport(0, 0, mip_width, mip_height);

	        var roughness = mip / (maxMipLevels - 1);

	        for (var i = 0; i < 6; i++) {
	            var w_target = get_cube_target_by_id(i);

	            _gl.uniformMatrix4fv(uniforms["u_cube_view_matrix"], false, v_matrs[i]);

	            _gl.uniform1f(uniforms["u_roughness"], roughness);

	            _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0,
	                w_target, w_tex, mip);

	            _draw_batch(batch, 0);
	        }
	    }
	}

	function update_subs_sky_fog(subscene, cubemap_side_ind) {
	    // get pixel from every side of cubemap for procedural fog calculation
	    var col = _ivec4_tmp;

	    if (cfg_def.clear_procedural_sky_hack)
	        col.set(SKY_HACK_COLOR);
	    else {
	        // TODO: Avoid read pixels here. Better to recalculate it manually
	        _gl.readPixels(191, 191, 1, 1, _gl.RGBA, _gl.UNSIGNED_BYTE, col);
	        if (col[0] == 255 || col[1] == 255 || col[2] == 255) {
	            _gl.readPixels(191, 220, 1, 1, _gl.RGBA, _gl.UNSIGNED_BYTE, col);
	        }
	    }

	    var res_r = col[0]; var res_g = col[1]; var res_b = col[2];

	    res_r /= 255;
	    res_g /= 255;
	    res_b /= 255;

	    if (cubemap_side_ind === CUBEMAP_UPPER_SIDE) {
	        subscene.cube_fog[3]  = res_r;
	        subscene.cube_fog[7]  = res_g;
	        subscene.cube_fog[11] = res_b;
	    } else {
	        subscene.cube_fog[4 * cubemap_side_ind] = res_r;
	        subscene.cube_fog[4 * cubemap_side_ind + 1] = res_g;
	        subscene.cube_fog[4 * cubemap_side_ind + 2] = res_b;
	    }
	}

	function get_cube_target_by_id(id) {
	    switch (id) {
	    case 0:
	        return _gl.TEXTURE_CUBE_MAP_POSITIVE_X;
	    case 1:
	        return _gl.TEXTURE_CUBE_MAP_NEGATIVE_X;
	    case 2:
	        return _gl.TEXTURE_CUBE_MAP_POSITIVE_Y;
	    case 3:
	        return _gl.TEXTURE_CUBE_MAP_NEGATIVE_Y;
	    case 4:
	        return _gl.TEXTURE_CUBE_MAP_POSITIVE_Z;
	    case 5:
	        return _gl.TEXTURE_CUBE_MAP_NEGATIVE_Z;
	    }
	}

	exports.assign_attribute_setters = function(batch) {
	    var attr_setters = batch.attribute_setters;
	    attr_setters.length = 0;

	    var bufs_data = batch.bufs_data;
	    var shader = batch.shader;

	    var pointers = bufs_data.pointers;
	    var attributes = shader.attributes;

	    for (var name in attributes) {
	        var p = pointers[name];
	        var vbo_type = m_geom.get_vbo_type_by_attr_name(name);
	        var gl_type = m_geom.get_gl_type_by_attr_name(name);
	        var type_size = m_geom.get_type_size_by_attr_name(name);

	        var setter = {
	            vbo_type: vbo_type,
	            gl_type: gl_type,
	            loc: attributes[name],
	            base_offset: p.offset * type_size,
	            frame_length: p.frames > 1 ? p.length * type_size : 0,
	            num_comp: p.num_comp,
	            divisor: p.divisor
	        };
	        attr_setters.push(setter);
	    }

	    if (m_ver.type() == "DEBUG")
	        for (var name in pointers) {
	            var vbo_type = m_geom.get_vbo_type_by_attr_name(name);
	            var index = m_geom.search_vbo_index_by_type(bufs_data.vbo_data, vbo_type);
	            var vbo_obj = bufs_data.vbo_data[index];

	            var sh_pair_str = batch.shaders_info.vert + " | " + batch.shaders_info.frag;
	            var byte_size = pointers[name].length * pointers[name].frames 
	                    * m_geom.get_type_size_by_attr_name(name);
	            m_debug.fill_vbo_garbage_info(vbo_obj.debug_id, sh_pair_str, name, 
	                    byte_size, name in attributes);
	        }

	    if (cfg_def.allow_vao_ext)
	        assign_vao(batch);
	};

	exports.assign_vao = assign_vao;
	function assign_vao(batch) {
	    var vao_ext = m_ext.get_vertex_array_object();
	    var attr_setters = batch.attribute_setters;
	    var bufs_data = batch.bufs_data;
	    var pointers = bufs_data.pointers;

	    batch.vaos.length = 0;

	    var frames = 1;
	    // find the maximum frame length among all pointers to create enough VAOs
	    for (var name in pointers)
	        frames = Math.max(frames, pointers[name].frames);

	    for (var i = 0; i < frames; i++) {

	        var vao = vao_ext.createVertexArray();
	        _gl_bind_vertex_array(vao);

	        if (bufs_data.ibo)
	            _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, bufs_data.ibo);

	        for (var j = 0; j < bufs_data.vbo_data.length; j++) {
	            _gl.bindBuffer(_gl.ARRAY_BUFFER, bufs_data.vbo_data[j].vbo);

	            for (var k = 0; k < attr_setters.length; k++) {
	                var setter = attr_setters[k];
	                if (setter.vbo_type == bufs_data.vbo_data[j].type) {
	                    _gl.enableVertexAttribArray(setter.loc);
	                    var offset = setter.base_offset + setter.frame_length * i;

	                    var normalized = setter.gl_type == _gl.FLOAT ? false : true;
	                    _gl.vertexAttribPointer(setter.loc, setter.num_comp, 
	                            setter.gl_type, normalized, 0, offset);
	                    _gl_vert_attr_div(setter.loc, setter.divisor);
	                }
	            }
	        }

	        _gl_bind_vertex_array(null);

	        batch.vaos.push(vao);
	    }
	}

	exports.cleanup_vao = function(batch) {
	    var ext = m_ext.get_vertex_array_object();
	    for (var i = 0; i < batch.vaos.length; i++)
	        ext.deleteVertexArray(batch.vaos[i]);
	    batch.vaos.length = 0;
	};

	exports.clone_attribute_setters = function(setters) {
	    var setters_new = [];

	    for (var i = 0; i < setters.length; i++) {
	        var setter = setters[i];

	        var setter_new = {
	            vbo_type: setter.vbo_type,
	            gl_type: setter.gl_type,
	            loc: setter.loc,
	            base_offset: setter.base_offset,
	            frame_length: setter.frame_length,
	            num_comp: setter.num_comp,
	            divisor: setter.divisor
	        };

	        setters_new.push(setter_new);
	    }
	    return setters_new;
	};

	exports.assign_uniform_setters = assign_uniform_setters;
	function assign_uniform_setters(shader) {
	    var uniforms = shader.uniforms;

	    var transient_uniform_setters = shader.transient_uniform_setters;
	    var permanent_uniform_setters = shader.permanent_uniform_setters;
	    var transient_sc_uniform_setters = shader.transient_sc_uniform_setters;
	    var permanent_sc_uniform_setters = shader.permanent_sc_uniform_setters;

	    transient_uniform_setters.length = 0;
	    permanent_uniform_setters.length = 0;
	    transient_sc_uniform_setters.length = 0;
	    permanent_sc_uniform_setters.length = 0;

	    for (var uni in uniforms) {
	        var transient_uni = false;

	        var scene_fun = null;
	        var fun = null;

	        switch (uni) {
	        // from camera
	        case "u_proj_matrix":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniformMatrix4fv(loc, false, camera.proj_matrix);
	            };
	            transient_uni = true;
	            break;
	        case "u_view_refl_matrix":
	            // NOTE: used for reflection
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniformMatrix4fv(loc, false, camera.view_refl_matrix);
	            };
	            transient_uni = true;
	            break;
	        case "u_view_tsr":
	        case "u_view_tsr_frag":
	            scene_fun = function(gl, loc, subscene, camera) {
	                if (camera.reflection_plane)
	                    gl.uniformMatrix3fv(loc, false, camera.real_view_tsr);
	                else
	                    gl.uniformMatrix3fv(loc, false, camera.view_tsr);
	            };
	            transient_uni = true;
	            break;
	        case "u_view_tsr_inverse":
	            scene_fun = function(gl, loc, subscene, camera) {
	                if (camera.reflection_plane)
	                    gl.uniformMatrix3fv(loc, false, camera.real_view_tsr_inv);
	                else
	                    gl.uniformMatrix3fv(loc, false, camera.view_tsr_inv);
	            };
	            transient_uni = true;
	            break;
	        case "u_shadow_cast_billboard_view_tsr":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniformMatrix3fv(loc, false, camera.shadow_cast_billboard_view_tsr);
	            };
	            transient_uni = true;
	            break;
	        case "u_view_proj_prev":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniformMatrix4fv(loc, false, camera.prev_view_proj_matrix);
	            };
	            transient_uni = true;
	            break;
	        case "u_view_proj_matrix":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniformMatrix4fv(loc, false, camera.view_proj_matrix);
	            };
	            transient_uni = true;
	            break;
	        case "u_view_proj_inverse":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniformMatrix4fv(loc, false, camera.view_proj_inv_matrix);
	            };
	            transient_uni = true;
	            break;
	        case "u_sky_vp_inverse":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniformMatrix4fv(loc, false, camera.sky_vp_inv_matrix);
	            };
	            transient_uni = true;
	            break;
	        case "u_camera_eye":
	        case "u_camera_eye_frag":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform3fv(loc, m_tsr.get_trans(camera.world_tsr, _vec3_tmp));
	            };
	            transient_uni = true;
	            break;
	        case "u_camera_quat":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform4fv(loc, m_tsr.get_quat(camera.world_tsr, _quat_tmp));
	            };
	            transient_uni = true;
	            break;
	        case "u_view_max_depth":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform1f(loc, camera.far);
	            };
	            transient_uni = true;
	            break;
	        case "u_camera_range":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform2f(loc, camera.near, camera.far);
	            };
	            transient_uni = true;
	            break;
	        case "u_csm_center_dists":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform4fv(loc, camera.csm_center_dists);
	            };
	            break;
	        case "u_height":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform1f(loc, camera.height);
	            };
	            transient_uni = true;
	            break;
	        case "u_pcf_blur_radii":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform4fv(loc, camera.pcf_blur_radii);
	            };
	            break;
	        // depth of field
	        case "u_dof_dist":
	            scene_fun = function(gl, loc, subscene, camera) {
	                if (camera.dof_on)
	                    gl.uniform1f(loc, camera.dof_distance);
	                else
	                    gl.uniform1f(loc, 0);
	            };
	            transient_uni = true;
	            break;
	        case "u_dof_front_start":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform1f(loc, camera.dof_front_start);
	            };
	            transient_uni = true;
	            break;
	        case "u_dof_front_end":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform1f(loc, camera.dof_front_end);
	            };
	            transient_uni = true;
	            break;
	        case "u_dof_rear_start":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform1f(loc, camera.dof_rear_start);
	            };
	            transient_uni = true;
	            break;
	        case "u_dof_rear_end":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform1f(loc, camera.dof_rear_end);
	            };
	            transient_uni = true;
	            break;
	        case "u_dof_bokeh_intensity":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform1f(loc, camera.dof_bokeh_intensity);
	            };
	            transient_uni = true;
	            break;
	        case "u_camera_direction":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform3fv(loc, camera.direction);
	            };
	            transient_uni = true;
	            break;

	        case "u_cam_water_depth":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform1f(loc, subscene.cam_water_depth);
	            };
	            transient_uni = true;
	            break;
	        case "u_fog_color_density":
	            scene_fun = function(gl, loc, subscene, camera) {
	                // NOTE: unused alpha channel
	                gl.uniform4fv(loc, subscene.fog_color_density);
	            };
	            break;
	        case "u_fog_params":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform4fv(loc, subscene.fog_params);
	            };
	            break;
	        case "u_underwater_fog_color_density":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform4fv(loc, subscene.water_fog_color_density);
	            };
	            break;
	        case "u_bloom_key":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform1f(loc, subscene.bloom_key);
	            };
	            break;
	        case "u_average_lum_val":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform1f(loc, subscene.average_luminance);
	            };
	            break;
	        case "u_mipmap_1x1":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform1f(loc, subscene.last_mip_map_ind);
	            };
	            break;
	        case "u_bloom_edge_lum":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform1f(loc, subscene.bloom_edge_lum);
	            };
	            break;

	        case "u_time":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform1f(loc, subscene.time);
	            };
	            transient_uni = true;
	            break;
	        case "u_wind":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform3fv(loc, subscene.wind);
	            };
	            transient_uni = true;
	            break;

	        case "u_sky_tex_dvar":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform1f(loc, subscene.sky_tex_default_value);
	            };
	            break;
	        case "u_sky_tex_fac":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform4fv(loc, subscene.sky_tex_fac);
	            };
	            break;
	        case "u_sky_tex_color":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform3fv(loc, subscene.sky_tex_color);
	            };
	            break;
	        case "u_horizon_color":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform3fv(loc, subscene.horizon_color);
	            };
	            break;
	        case "u_zenith_color":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform3fv(loc, subscene.zenith_color);
	            };
	            break;
	        case "u_environment_energy":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform1f(loc, subscene.environment_energy);
	            };
	            break;
	        case "u_bsdf_cube_sky_dim":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform1f(loc, subscene.bsdf_cube_sky_dim);
	            };
	            transient_uni = true;
	            break;

	        // sky
	        case "u_sky_color":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform3fv(loc, subscene.sky_color);
	            };
	            break;
	        case "u_rayleigh_brightness":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform1f(loc, subscene.rayleigh_brightness);
	            };
	            break;
	        case "u_mie_brightness":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform1f(loc, subscene.mie_brightness);
	            };
	            break;
	        case "u_spot_brightness":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform1f(loc, subscene.spot_brightness);
	            };
	            break;
	        case "u_scatter_strength":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform1f(loc, subscene.scatter_strength);
	            };
	            break;
	        case "u_rayleigh_strength":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform1f(loc, subscene.rayleigh_strength);
	            };
	            break;
	        case "u_mie_strength":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform1f(loc, subscene.mie_strength);
	            };
	            break;
	        case "u_rayleigh_collection_power":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform1f(loc, subscene.rayleigh_collection_power);
	            };
	            break;
	        case "u_mie_collection_power":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform1f(loc, subscene.mie_collection_power);
	            };
	            break;
	        case "u_mie_distribution":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform1f(loc, subscene.mie_distribution);
	            };
	            break;

	        // light
	        case "u_light_positions":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform4fv(loc, subscene.light_positions);
	            };
	            break;
	        case "u_light_directions":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform3fv(loc, subscene.light_directions);
	            };
	            break;
	        case "u_light_color_intensities":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform4fv(loc, subscene.light_color_intensities);
	            };
	            break;
	        case "u_sun_quaternion":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform4fv(loc, subscene.sun_quaternion);
	            };
	            break;
	        case "u_sun_intensity":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform3fv(loc, subscene.sun_intensity);
	            };
	            break;
	        case "u_sun_direction":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform3fv(loc, subscene.sun_direction);
	            };
	            break;

	        // debug (subscene)
	        case "u_debug_view_mode":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform1i(loc, subscene.debug_view_mode);
	            };
	            break;
	        case "u_debug_colors_seed":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform1f(loc, subscene.debug_colors_seed);
	            };
	            break;
	        case "u_debug_render_time_threshold":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform1f(loc, subscene.debug_render_time_threshold);
	            };
	            break;

	        case "u_subpixel_jitter":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform2fv(loc, subscene.jitter_projection_space);
	            };
	            transient_uni = true;
	            break;
	        case "u_subsample_indices":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform4fv(loc, subscene.jitter_subsample_ind);
	            };
	            transient_uni = true;
	            break;

	        // god_rays
	        case "u_radial_blur_step":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform1f(loc, subscene.radial_blur_step);
	            };
	            break;
	        case "u_god_rays_intensity":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform1f(loc, subscene.god_rays_intensity);
	            };
	            break;

	        // ssao
	        case "u_ssao_radius_increase":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform1f(loc, subscene.ssao_radius_increase);
	            };
	            break;
	        case "u_ssao_blur_discard_value":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform1f(loc, subscene.ssao_blur_discard_value);
	            };
	            transient_uni = true;
	            break;
	        case "u_ssao_influence":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform1f(loc, subscene.ssao_influence);
	            };
	            break;
	        case "u_ssao_dist_factor":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform1f(loc, subscene.ssao_dist_factor);
	            };
	            break;
	        case "u_texel_size":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform2fv(loc, subscene.texel_size);
	            };
	            transient_uni = true;
	            break;
	        // shadow receive subscene
	        case "u_normal_offset":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform1f(loc, subscene.self_shadow_normal_offset);
	            };
	            break;
	        case "u_v_light_ts":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform4fv(loc, subscene.v_light_ts);
	            };
	            transient_uni = true;
	            break;
	        case "u_v_light_r":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform4fv(loc, subscene.v_light_r);
	            };
	            transient_uni = true;
	            break;
	        case "u_v_light_tsr":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniformMatrix3fv(loc, false, subscene.v_light_tsr);
	            };
	            transient_uni = true;
	            break;
	        // NOTE: add more if needed
	        case "u_p_light_matrix0":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniformMatrix4fv(loc, false, subscene.p_light_matrix[0]);
	            };
	            transient_uni = true;
	            break;
	        case "u_p_light_matrix1":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniformMatrix4fv(loc, false, subscene.p_light_matrix[1]);
	            };
	            transient_uni = true;
	            break;
	        case "u_p_light_matrix2":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniformMatrix4fv(loc, false, subscene.p_light_matrix[2]);
	            };
	            transient_uni = true;
	            break;
	        case "u_p_light_matrix3":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniformMatrix4fv(loc, false, subscene.p_light_matrix[3]);
	            };
	            transient_uni = true;
	            break;
	        case "u_outline_color":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform3fv(loc, subscene.outline_color);
	            };
	            break;
	        case "u_draw_outline":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform1f(loc, subscene.draw_outline_flag);
	            };
	            transient_uni = true;
	            break;

	        // for glow
	        case "u_glow_mask_small_coeff":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform1f(loc, subscene.small_glow_mask_coeff);
	            };
	            transient_uni = true;
	            break;
	        case "u_glow_mask_large_coeff":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform1f(loc, subscene.large_glow_mask_coeff);
	            };
	            transient_uni = true;
	            break;

	        // color correction
	        case "u_brightness":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform1f(loc, subscene.brightness);
	            };
	            break;
	        case "u_contrast":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform1f(loc, subscene.contrast);
	            };
	            break;
	        case "u_exposure":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform1f(loc, subscene.exposure);
	            };
	            break;
	        case "u_saturation":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform1f(loc, subscene.saturation);
	            };
	            break;

	        // hmd params
	        case "u_enable_hmd_stereo":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform1i(loc, subscene.enable_hmd_stereo);
	            };
	            break;
	        case "u_distortion_params":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform4fv(loc, subscene.distortion_params);
	            };
	            break;
	        case "u_chromatic_aberration_coefs":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform4fv(loc, subscene.chromatic_aberration_coefs);
	            };
	            break
	        case "u_motion_blur_exp":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform1f(loc, subscene.motion_blur_exp);
	            };
	            transient_uni = true;
	            break;
	        case "u_motion_blur_decay_threshold":
	            scene_fun = function(gl, loc, subscene, camera) {
	                gl.uniform1f(loc, subscene.mb_decay_threshold);
	            };
	            transient_uni = true;
	            break;

	        // obj render
	        case "u_model_tsr":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniformMatrix3fv(loc, false, obj_render.world_tsr);
	            };
	            transient_uni = true;
	            break;
	        case "u_model_tsr_inverse":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniformMatrix3fv(loc, false, obj_render.world_tsr_inv);
	            };
	            transient_uni = true;
	            break;
	        case "u_transb":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform4fv(loc, obj_render.trans_before);
	            };
	            transient_uni = true;
	            break;
	        case "u_transa":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform4fv(loc, obj_render.trans_after);
	            };
	            transient_uni = true;
	            break;
	        case "u_arm_rel_trans":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform4fv(loc, obj_render.arm_rel_trans);
	            };
	            transient_uni = true;
	            break;
	        case "u_arm_rel_quat":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform4fv(loc, obj_render.arm_rel_quat);
	            };
	            transient_uni = true;
	            break;
	        case "u_quat":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform4fv(loc, m_tsr.get_quat(obj_render.world_tsr, _quat_tmp));
	            };
	            transient_uni = true;
	            break;
	        case "u_quatsb":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform4fv(loc, obj_render.quats_before);
	            };
	            transient_uni = true;
	            break;
	        case "u_quatsa":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform4fv(loc, obj_render.quats_after);
	            };
	            transient_uni = true;
	            break;
	        case "u_frame_factor":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform1f(loc, obj_render.frame_factor);
	            };
	            transient_uni = true;
	            break;

	        case "au_center_pos":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform3fv(loc, obj_render.center_pos);
	            };
	            transient_uni = true;
	            break;
	        case "au_wind_bending_amp":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform1f(loc, obj_render.wind_bending_amp);
	            };
	            transient_uni = true;
	            break;
	        case "au_wind_bending_freq":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform1f(loc, obj_render.wind_bending_freq);
	            };
	            transient_uni = true;
	            break;
	        case "au_detail_bending_freq":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform1f(loc, obj_render.detail_bending_freq);
	            };
	            transient_uni = true;
	            break;
	        case "au_detail_bending_amp":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform1f(loc, obj_render.detail_bending_amp);
	            };
	            transient_uni = true;
	            break;
	        case "au_branch_bending_amp":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform1f(loc, obj_render.branch_bending_amp);
	            };
	            transient_uni = true;
	            break;
	        case "u_node_values":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform4fv(loc, batch.node_values);
	            };
	            transient_uni = true;
	            break;
	        case "u_node_rgbs":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform3fv(loc, batch.node_rgbs);
	            };
	            transient_uni = true;
	            break;
	        case "u_lod_coverage":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform1f(loc, batch.lod_settings.coverage);
	            };
	            transient_uni = true;
	            break;
	        case "u_lod_cmp_logic":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform1f(loc, batch.lod_settings.cmp_logic);
	            };
	            transient_uni = true;
	            break;

	        // batch
	        case "u_diffuse_color":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform4fv(loc, batch.diffuse_color);
	            };
	            transient_uni = true;
	            break;
	        case "u_diffuse_intensity":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform1f(loc, batch.diffuse_intensity);
	            };
	            transient_uni = true;
	            break;
	        case "u_diffuse_params":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform2fv(loc, batch.diffuse_params);
	            };
	            transient_uni = true;
	            break;
	        case "u_emit":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform1f(loc, batch.emit);
	            };
	            transient_uni = true;
	            break;
	        case "u_ambient":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform1f(loc, batch.ambient);
	            };
	            transient_uni = true;
	            break;
	        case "u_specular_color":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform3fv(loc, batch.specular_color);
	            };
	            transient_uni = true;
	            break;
	        case "u_specular_alpha":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform1f(loc, batch.specular_alpha);
	            };
	            transient_uni = true;
	        break;
	        case "u_specular_params":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform3fv(loc, batch.specular_params);
	            };
	            transient_uni = true;
	            break;
	        case "u_reflect_factor":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform1f(loc, batch.reflect_factor);
	            };
	            transient_uni = true;
	            break;
	        case "u_mirror_factor":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform1f(loc, batch.mirror_factor);
	            };
	            transient_uni = true;
	            break;
	        case "u_grass_map_dim":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform3fv(loc, batch.grass_map_dim);
	            };
	            transient_uni = true;
	            break;
	        case "u_grass_size":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform1f(loc, batch.grass_size);
	            };
	            transient_uni = true;
	            break;
	        case "u_scale_threshold":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform1f(loc, batch.grass_scale_threshold);
	            };
	            transient_uni = true;
	            break;
	        case "u_cube_fog":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniformMatrix4fv(loc, false, batch.cube_fog);
	            };
	            break;
	        case "u_jitter_amp":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform1f(loc, batch.jitter_amp);
	            };
	            transient_uni = true;
	            break;
	        case "u_jitter_freq":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform1f(loc, batch.jitter_freq);
	            };
	            transient_uni = true;
	            break;
	        case "u_wireframe_edge_color":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform3fv(loc, batch.wireframe_edge_color);
	            };
	            break;
	        case "u_cluster_id":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform1f(loc, batch.cluster_id);
	            };
	            transient_uni = true;
	            break;
	        case "u_batch_debug_id_color":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform1f(loc, batch.debug_id_color);
	            };
	            transient_uni = true;
	            break;
	        case "u_batch_debug_main_render_time":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform1f(loc, batch.debug_main_batch_render_time);
	            };
	            transient_uni = true;
	            break;
	        case "u_refr_bump":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform1f(loc, batch.refr_bump);
	            };
	            transient_uni = true;
	            break;
	        case "u_line_width":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform1f(loc, batch.line_width);
	            };
	            transient_uni = true;
	            break;

	        // lamp_data
	        case "u_lamp_light_positions":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform3fv(loc, batch.lamp_light_positions);
	            };
	            break;
	        case "u_lamp_light_directions":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform3fv(loc, batch.lamp_light_directions);
	            };
	            break;
	        case "u_lamp_light_color_intensities":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform3fv(loc, batch.lamp_light_color_intensities);
	            };
	            break;

	        // halo
	        case "u_halo_size":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform1f(loc, batch.halo_size);
	            };
	            transient_uni = true;
	            break;
	        case "u_halo_hardness":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform1f(loc, batch.halo_hardness);
	            };
	            transient_uni = true;
	            break;
	        case "u_halo_rings_color":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform3fv(loc, batch.halo_rings_color);
	            };
	            transient_uni = true;
	            break;
	        case "u_halo_lines_color":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform3fv(loc, batch.halo_lines_color);
	            };
	            transient_uni = true;
	            break;
	        case "u_halo_stars_blend":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform1f(loc, batch.halo_stars_blend);
	            };
	            transient_uni = true;
	            break;
	        case "u_halo_stars_height":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform1f(loc, batch.halo_stars_height);
	            };
	            transient_uni = true;
	            break;
	        case "u_fresnel_params":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform2fv(loc, batch.fresnel_params);
	            };
	            transient_uni = true;
	            break;
	        case "u_texture_scale":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform3fv(loc, batch.texture_scale);
	            };
	            transient_uni = true;
	            break;
	        case "u_parallax_scale":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform1f(loc, batch.parallax_scale);
	            };
	            transient_uni = true;
	            break;
	        case "u_color_id":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform3fv(loc, obj_render.color_id);
	            };
	            transient_uni = true;
	            break;

	        // texture factors
	        case "u_diffuse_color_factor":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform1f(loc, batch.diffuse_color_factor);
	            };
	            transient_uni = true;
	            break;
	        case "u_alpha_factor":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform1f(loc, batch.alpha_factor);
	            };
	            transient_uni = true;
	            break;
	        case "u_specular_color_factor":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform1f(loc, batch.specular_color_factor);
	            };
	            transient_uni = true;
	            break;
	        case "u_normal_factor":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform1f(loc, batch.normal_factor);
	            };
	            transient_uni = true;
	            break;

	        case "u_normalmap0_scale":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform2fv(loc, batch.normalmap_scales[0]);
	            };
	            transient_uni = true;
	            break;
	        case "u_normalmap1_scale":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform2fv(loc, batch.normalmap_scales[1]);
	            };
	            transient_uni = true;
	            break;
	        case "u_normalmap2_scale":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform2fv(loc, batch.normalmap_scales[2]);
	            };
	            transient_uni = true;
	            break;
	        case "u_normalmap3_scale":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform2fv(loc, batch.normalmap_scales[3]);
	            };
	            transient_uni = true;
	            break;
	        case "u_foam_factor":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform1f(loc, batch.foam_factor);
	            };
	            transient_uni = true;
	            break;
	        case "u_foam_uv_freq":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform2fv(loc, batch.foam_uv_freq);
	            };
	            transient_uni = true;
	            break;
	        case "u_foam_mag":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform2fv(loc, batch.foam_mag);
	            };
	            transient_uni = true;
	            break;
	        case "u_foam_scale":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform2fv(loc, batch.foam_scale);
	            };
	            transient_uni = true;
	            break;
	        case "u_water_norm_uv_velocity":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform1f(loc, batch.water_norm_uv_velocity);
	            };
	            transient_uni = true;
	            break;
	        case "u_shallow_water_col":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform3fv(loc, batch.shallow_water_col);
	            };
	            transient_uni = true;
	            break;
	        case "u_shore_water_col":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform3fv(loc, batch.shore_water_col);
	            };
	            transient_uni = true;
	            break;
	        case "u_water_shallow_col_fac":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform1f(loc, batch.shallow_water_col_fac);
	            };
	            transient_uni = true;
	            break;
	        case "u_water_shore_col_fac":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform1f(loc, batch.shore_water_col_fac);
	            };
	            transient_uni = true;
	            break;

	        case "u_p_length":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform1f(loc, batch.particles_data.time_length);
	            };
	            transient_uni = true;
	            break;
	        case "u_p_cyclic":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform1i(loc, batch.particles_data.cyclic);
	            };
	            transient_uni = true;
	            break;
	        case "u_p_max_lifetime":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform1f(loc, batch.particles_data.lifetime);
	            };
	            transient_uni = true;
	            break;
	        case "u_p_fade_in":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform1f(loc, batch.particles_data.fade_in);
	            };
	            transient_uni = true;
	            break;
	        case "u_p_fade_out":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform1f(loc, batch.particles_data.fade_out);
	            };
	            transient_uni = true;
	            break;
	        case "u_p_size":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform1f(loc, batch.particles_data.size);
	            };
	            transient_uni = true;
	            break;
	        case "u_p_alpha_start":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform1f(loc, batch.particles_data.alpha_start);
	            };
	            transient_uni = true;
	            break;
	        case "u_p_alpha_end":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform1f(loc, batch.particles_data.alpha_end);
	            };
	            transient_uni = true;
	            break;
	        case "u_p_nfactor":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform1f(loc, batch.particles_data.nfactor);
	            };
	            transient_uni = true;
	            break;
	        case "u_p_gravity":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform1f(loc, batch.particles_data.gravity);
	            };
	            transient_uni = true;
	            break;
	        case "u_p_mass":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform1f(loc, batch.particles_data.mass);
	            };
	            transient_uni = true;
	            break;
	        case "u_p_color_ramp":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform4fv(loc, batch.particles_data.color_ramp);
	            };
	            transient_uni = true;
	            break;
	        case "u_p_wind_fac":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform1f(loc, batch.particles_data.wind_factor);
	            };
	            transient_uni = true;
	            break;

	        case "u_p_time":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform1f(loc, batch.particles_data.time);
	            };
	            transient_uni = true;
	            break;

	        case "u_p_tilt":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform1f(loc, batch.particles_data.tilt);
	            };
	            transient_uni = true;
	            break;

	        case "u_p_tilt_rand":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform1f(loc, batch.particles_data.tilt_rand);
	            };
	            transient_uni = true;
	            break;

	        // anchor visibility
	        case "u_position":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform3fv(loc, batch.anchor_positions);
	            };
	            transient_uni = true;
	            break;

	        // for vertex anim
	        case "u_va_frame_factor":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform1f(loc, obj_render.va_frame_factor);
	            };
	            transient_uni = true;
	            break;

	        case "u_refl_plane":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform4fv(loc, obj_render.reflection_plane);
	            };
	            transient_uni = true;
	            break;


	        // for outline
	        case "u_outline_intensity":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform1f(loc, obj_render.outline_intensity);
	            };
	            transient_uni = true;
	            break;

	        case "u_obj_info":
	            fun = function(gl, loc, obj_render, batch) {
	                gl.uniform3fv(loc, batch.obj_info_params);
	            };
	            transient_uni = true;
	            break;
	        default:
	            break;
	        }

	        if (fun) {
	            var setter = {
	                name: uni,
	                fun: fun,
	                loc: uniforms[uni]
	            };

	            if (transient_uni)
	                transient_uniform_setters.push(setter);
	            else
	                permanent_uniform_setters.push(setter);
	        }

	        if (scene_fun) {
	            var setter = {
	                name: uni,
	                fun: scene_fun,
	                loc: uniforms[uni]
	            };
	            if (transient_uni)
	                transient_sc_uniform_setters.push(setter);
	            else
	                permanent_sc_uniform_setters.push(setter);
	        }
	    }
	    if (permanent_uniform_setters.length || permanent_sc_uniform_setters.length) {
	        var table = shader.permanent_uniform_setters_table;

	        for (var i in table)
	            delete table[i];

	        for (var i = 0; i < permanent_uniform_setters.length; i++) {
	            var setter = permanent_uniform_setters[i];
	            table[setter.name] = setter;
	        }
	        for (var i = 0; i < permanent_sc_uniform_setters.length; i++) {
	            var setter = permanent_sc_uniform_setters[i];
	            table[setter.name] = setter;
	        }
	    } else
	        // optimization
	        shader.no_permanent_uniforms = true;
	}

	exports.assign_texture_uniforms = function(batch) {
	    var shader = batch.shader;
	    var textures = batch.textures;
	    var names = batch.texture_names;

	    _gl.useProgram(shader.program);

	    for (var i = 0; i < textures.length; i++) {
	        var name = names[i];
	        // NOTE: may cause a bug if textures on different batches sharing
	        // the same shader are out of order
	        _gl.uniform1i(shader.uniforms[name], i);
	    }
	};

	function setup_textures(textures) {

	    var gl = _gl;

	    for (var i = 0; i < textures.length; i++) {
	        var tex = textures[i];
	        gl.activeTexture(gl.TEXTURE0 + i);
	        gl.bindTexture(tex.w_target, tex.w_texture);
	        if (tex.use_mipmap)
	            gl.generateMipmap(tex.w_target);
	    }
	}

	exports.read_pixels = read_pixels;
	/**
	 * Get pixels from the framebuffer. Used for objects picking.
	 * @param framebuffer FBO
	 * @param x x-coord starting from left
	 * @param y y-coord starting from bottom
	 * @param width Width of rectangle to read
	 * @param height Height of rectangle to read
	 * @param {Uint8Array} storage Destination array of pixel channels
	 * @returns {Uint8Array} Destination array of pixel channels
	 */
	function read_pixels(framebuffer, x, y, width, height, storage) {

	    _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
	    _gl.readPixels(x, y, width, height, _gl.RGBA, _gl.UNSIGNED_BYTE, storage);
	    _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);

	    return storage;
	}

	exports.update_batch_permanent_uniform = function(batch, uni_name) {

	    var shader = batch.shader;
	    if (shader.no_permanent_uniforms)
	        return;

	    _gl.useProgram(shader.program);

	    if (!shader.permanent_uniform_setters.length)
	        assign_uniform_setters(shader);

	    var setter = shader.permanent_uniform_setters_table[uni_name];
	    setter.fun(_gl, setter.loc, null, batch);
	};

	/**
	 * Unified function to create new render target.
	 * if specified attachments must have the same size
	 * use texture.resize() method
	 */
	exports.render_target_create = function(color_attachment, depth_attachment) {
	    var framebuffer = _gl.createFramebuffer();
	    _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);

	    // renderbuffer/texture/null
	    if (m_textures.is_renderbuffer(color_attachment)) {
	        var renderbuffer = color_attachment.w_renderbuffer;

	        _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0,
	                _gl.RENDERBUFFER, renderbuffer);
	    } else if (m_textures.is_texture(color_attachment)) {
	        var texture = color_attachment;

	        var w_tex = texture.w_texture;
	        var w_target = (texture.w_target == _gl.TEXTURE_CUBE_MAP) ?
	                        _gl.TEXTURE_CUBE_MAP_NEGATIVE_Z : texture.w_target;

	        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0,
	                w_target, w_tex, 0);
	    }

	    // renderbuffer/texture/null
	    if (m_textures.is_renderbuffer(depth_attachment)) {
	        var renderbuffer = depth_attachment.w_renderbuffer;

	        _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT,
	                _gl.RENDERBUFFER, renderbuffer);
	    } else if (m_textures.is_texture(depth_attachment)) {
	        var texture = depth_attachment;

	        var w_tex = texture.w_texture;
	        var w_target = texture.w_target;

	        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, w_target,
	                w_tex, 0);
	    }
	    m_debug.check_bound_fb();

	    // switch back to the window-system provided framebuffer
	    _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);

	    return framebuffer;
	};

	exports.render_target_cleanup = function(framebuffer, color_attachment,
	        depth_attachment, width, height) {

	    // handle simple case first
	    if (framebuffer == null) {
	        _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
	        _gl.viewport(0, 0, width, height);
	        _gl.clear(_gl.COLOR_BUFFER_BIT | _gl.DEPTH_BUFFER_BIT);

	        return;
	    }

	    if (m_textures.is_renderbuffer(color_attachment))
	        _gl.deleteRenderbuffer(color_attachment.w_renderbuffer);
	    else if (m_textures.is_texture(color_attachment))
	        _gl.deleteTexture(color_attachment.w_texture);

	    if (m_textures.is_renderbuffer(depth_attachment))
	        _gl.deleteRenderbuffer(depth_attachment.w_renderbuffer);
	    else if (m_textures.is_texture(depth_attachment))
	        _gl.deleteTexture(depth_attachment.w_texture);

	    _gl.deleteFramebuffer(framebuffer);
	};

	exports.increment_subpixel_index = function() {
	    
	};

	exports.draw_resized_cubemap_texture = function(texture, w_target, pot_dim, img_dim, w_tex,
	        tex_num) {
	    var w_texture = texture.w_texture;

	    _gl.viewport(0, 0, pot_dim, pot_dim);

	    _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0,
	            w_target, w_texture, 0);

	    var batch = m_batch.create_postprocessing_batch("FLIP_CUBEMAP_COORDS");
	    var shader = batch.shader;

	    _gl.activeTexture(_gl.TEXTURE0);
	    _gl.bindTexture(_gl.TEXTURE_2D, w_tex);

	    var delta_x = 0;
	    var delta_y = 0;
	    if (pot_dim != img_dim) {
	        delta_x = 1.0 / (6 * img_dim);
	        delta_y = 1.0 / (4 * img_dim);
	    }
	    _gl.uniform1i(shader.uniforms["u_tex_number"], tex_num);
	    _gl.uniform2fv(shader.uniforms["u_delta"], [delta_x, delta_y]);

	    _gl.useProgram(shader.program);
	    _draw_batch(batch, 0);

	    _gl.bindTexture(_gl.TEXTURE_2D, null);
	};

	exports.draw_resized_texture = function(texture, size_x, size_y, fbo, w_tex,
	            batch_type) {
	    _gl.bindFramebuffer(_gl.FRAMEBUFFER, fbo);

	    var w_texture = texture.w_texture;
	    var w_target = texture.w_target;
	    _gl.bindTexture(w_target, w_texture);

	    _gl.viewport(0, 0, size_x, size_y);

	    _gl.texImage2D(w_target, 0, _gl.RGBA, size_x, size_y, 0, _gl.RGBA,
	            _gl.UNSIGNED_BYTE, null);

	    _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0,
	            w_target, w_texture, 0);

	    var batch = m_batch.create_postprocessing_batch(batch_type);
	    var shader = batch.shader;

	    _gl.activeTexture(_gl.TEXTURE0);
	    _gl.bindTexture(w_target, w_tex);

	    _gl.useProgram(shader.program);
	    _draw_batch(batch, 0);

	    _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
	    _gl.bindTexture(w_target, null);
	};

	/**
	 * Perform module cleanup
	 */
	exports.cleanup = function() {
	    
	};

	exports.set_draw_methods = function() {
	    var inst_arr = m_ext.get_instanced_arrays();
	    var vao_ext = m_ext.get_vertex_array_object();
	    cfg_def.allow_instanced_arrays_ext = inst_arr? true: false;
	    cfg_def.allow_vao_ext = vao_ext? true: false;

	    if (inst_arr) {
	        _gl_draw_elems_inst = function(count, type, offset, primcount) {
	            inst_arr.drawElementsInstanced(_gl.TRIANGLES, count, type, offset, primcount);
	        };
	        _gl_vert_attr_div = function(loc, div) {
	            inst_arr.vertexAttribDivisor(loc, div);
	        };
	        _gl_draw_array = function(first, count, primcount) {
	            inst_arr.drawArraysInstanced(_gl.TRIANGLES, first, count, primcount);
	        };
	    } else {
	        _gl_draw_elems_inst = function(count, type, offset) {
	            _gl.drawElements(_gl.TRIANGLES, count, type, offset);
	        };
	        _gl_vert_attr_div = function(loc, div) {
	            //pass
	        };
	        _gl_draw_array = function(first, count, primcount) {
	            _gl.drawArrays(_gl.TRIANGLES, first, count);
	        };
	    }

	    if (vao_ext) {
	        _gl_bind_vertex_array = function(vao) {
	            vao_ext.bindVertexArray(vao);
	        };
	        _draw_batch = function(batch, frame) {
	            var bufs_data = batch.bufs_data;
	            _gl_bind_vertex_array(batch.vaos[frame]);

	            // draw
	            if (bufs_data.ibo) {
	                _gl_draw_elems_inst(bufs_data.count, bufs_data.ibo_type, 0,
	                        bufs_data.instance_count);
	            } else
	                _gl_draw_array(0, bufs_data.count, bufs_data.instance_count);

	            _gl_bind_vertex_array(null);
	        };
	    } else {
	        _draw_batch = function(batch, frame) {
	            var bufs_data = batch.bufs_data;
	            var attr_setters = batch.attribute_setters;

	            for (var i = 0; i < bufs_data.vbo_data.length; i++) {
	                _gl.bindBuffer(_gl.ARRAY_BUFFER, bufs_data.vbo_data[i].vbo);

	                for (var j = 0; j < attr_setters.length; j++) {
	                    var setter = attr_setters[j];
	                    if (setter.vbo_type == bufs_data.vbo_data[i].type) {
	                        _gl.enableVertexAttribArray(setter.loc);
	                        var offset = setter.base_offset + setter.frame_length * frame;

	                        var normalized = setter.gl_type == _gl.FLOAT ? false : true;
	                        _gl.vertexAttribPointer(setter.loc, setter.num_comp, 
	                                setter.gl_type, normalized, 0, offset);
	                        _gl_vert_attr_div(setter.loc, setter.divisor);
	                    }
	                }
	            }

	            // draw
	            if (bufs_data.ibo) {
	                _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, bufs_data.ibo);
	                _gl_draw_elems_inst(bufs_data.count, bufs_data.ibo_type, 0,
	                        bufs_data.instance_count);
	            } else
	                _gl_draw_array(0, bufs_data.count, bufs_data.instance_count);

	            // cleanup attributes
	            for (var i = 0; i < attr_setters.length; i++) {
	                var setter = attr_setters[i];
	                _gl.disableVertexAttribArray(setter.loc);
	            }
	        };
	    }
	};

	exports.reset = function() {
	    _gl = null;
	    _gl_draw_elems_inst = null;
	    _gl_vert_attr_div = null;
	    _gl_draw_array = null;
	    _gl_bind_vertex_array = null;
	};

	}

	var int_renderer_factory = register("__renderer", Int_renderer);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Compatibility internal API.
	 * @name compat
	 * @namespace
	 * @exports exports as compat
	 */
	function Int_compat(ns, exports) {

	var m_cfg   = int_config_factory(ns);
	var m_debug = int_debug_factory(ns);
	var m_ext   = int_extensions_factory(ns);
	var m_print = print_factory(ns);
	var m_render= int_renderer_factory(ns);

	var MIN_VARYINGS_REQUIRED = 10;
	var AMD_MESA_RENDER_NAMES = ["R600", "RV610", "RV630", "RV620", "RV635", "RV670",
	        "RS780", "RS880", "RV770", "RV730", "RV710", "RV740", "CEDAR", "REDWOOD",
	        "JUNIPER", "CYPRESS", "PALM (Wrestler/Ontario)", "SUMO (Llano)",
	        "SUMO2 (Llano)", "ARUBA (Trinity/Richland)", "BARTS", "TURKS", "CAICOS",
	        "CAYMAN"];

	exports.NVIDIA_OLD_GPU_CUBEMAP_MAX_SIZE = 256;

	var cfg_anim = m_cfg.animation;
	var cfg_def = m_cfg.defaults;
	var cfg_dbg = m_cfg.debug_subs;
	var cfg_ctx = m_cfg.context;
	var cfg_lim = m_cfg.context_limits;
	var cfg_sfx = m_cfg.sfx;
	var cfg_phy = m_cfg.physics;
	var cfg_ldr = m_cfg.assets;

	exports.detect_tegra_invalid_enum_issue = function(gl) {
	    // this hardware don't like context.antialias = true
	    // get and ignore such error
	    if (gl.getError() == gl.INVALID_ENUM)
	        m_print.warn("Possible Tegra invalid enum issue detected, ignoring");
	};

	exports.set_hardware_defaults = function(gl, print_warnings) {

	    var warn = function(msg) {
	        if (print_warnings)
	            m_print.warn(msg);
	    };
	    cfg_lim.max_combined_texture_image_units =
	            gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
	    cfg_lim.max_fragment_uniform_vectors =
	            gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
	    cfg_lim.max_texture_image_units =
	            gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
	    cfg_lim.max_varying_vectors =
	            gl.getParameter(gl.MAX_VARYING_VECTORS);
	    cfg_lim.max_vertex_attribs =
	            gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
	    cfg_lim.max_vertex_texture_image_units =
	            gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
	    cfg_lim.max_vertex_uniform_vectors =
	            gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);

	    cfg_lim.max_cube_map_texture_size =
	            gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
	    cfg_lim.max_renderbuffer_size =
	            gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);
	    cfg_lim.max_texture_size = gl.getParameter(gl.MAX_TEXTURE_SIZE);
	    cfg_lim.max_viewport_dims = gl.getParameter(gl.MAX_VIEWPORT_DIMS);

	    var rinfo = m_ext.get_renderer_info();
	    if (rinfo) {
	        var vendor = gl.getParameter(rinfo.UNMASKED_VENDOR_WEBGL);
	        var renderer = gl.getParameter(rinfo.UNMASKED_RENDERER_WEBGL);

	        if (vendor.indexOf("Qualcomm") > -1 && renderer.indexOf("330") > -1 &&
	                (check_user_agent("Chrome") || check_user_agent("Firefox"))) {
	            warn("Chrome/Firefox and Qualcomm 330 detected, " +
	                    "force enable WebGL 1, disable blending cascaded shadow maps.");
	            cfg_def.webgl2 = false;
	            cfg_def.chrome_csm_blend_hack = true;
	        }
	    }

	    cfg_lim.depth_bits = cfg_def.webgl2 ? 24 : 16;

	    if (cfg_def.webgl2 && !cfg_dbg.enabled)
	        cfg_def.compared_mode_depth = true;

	    if (!cfg_def.webgl2)
	        cfg_def.msaa_samples = 1;
	    else {
	        cfg_def.msaa_samples = Math.min(cfg_def.msaa_samples,
	                gl.getParameter(gl.MAX_SAMPLES));
	        if (check_user_agent("Firefox")) {
	            warn("Firefox and WebGL 2 detected, applying framebuffer hack.");
	            cfg_def.check_framebuffer_hack = true;
	        }
	        if (check_user_agent("Windows") && check_user_agent("Chrome")) {
	            warn("Windows, Chrome and WebGL 2 detected, applying " +
	                    "multisample hack, disabling MSAA.");
	            cfg_def.msaa_samples = 1;
	        }
	    }

	    if (check_user_agent("Firefox") && cfg_def.stereo !== "NONE") {
	        warn("Firefox and Stereo rendering detected, disable texture reusage");
	        cfg_def.firefox_tex_reuse_hack = true;
	    }

	    // TODO: need to check Firefox MSAA --> "Coin Flip" demo shadows.
	    if (cfg_def.webgl2 && m_debug.check_multisample_issue() ||
	            check_user_agent("Firefox")) {
	        warn("Firefox detected, disabling multisample");
	        cfg_def.msaa_samples = 1;
	    }

	    if (check_user_agent("Mac OS X") && check_user_agent("Chrome/60")) {
	        warn("macOS and Chrome 60 detected, disabling multisample");
	        cfg_def.msaa_samples = 1;
	    }

	    m_render.set_draw_methods();

	    var depth_tex_available = Boolean(m_ext.get_depth_texture());
	    // HACK: fix depth issue in Firefox 28
	    if (check_user_agent("Firefox/28.0") &&
	            (check_user_agent("Linux") || check_user_agent("Macintosh"))) {
	        warn("Firefox 28 detected, applying depth hack");
	        depth_tex_available = false;
	    }

	    if (!check_user_agent("Windows Phone"))
	        if (check_user_agent("iPad") || check_user_agent("iPhone")) {
	            warn("iOS detected, applying alpha hack, applying vertex "
	                    + "animation mix normals hack, disable smaa. Disable ssao " 
	                    + "for performance. Initialize WebAudio context with empty sound. "
	                    + "Applying glow hack.");
	            if (!cfg_ctx.alpha)
	                cfg_def.background_color[3] = 1.0;

	            // NOTE: temporary disable this hack because it can lead to rendering 
	            // bugs in case of using the zero alpha value in the GLOW_OUTPUT node
	            // cfg_def.safari_glow_hack = true;
	            cfg_def.ios_copy_tex_hack = true;
	            cfg_def.vert_anim_mix_normals_hack = true;
	            cfg_def.smaa = false;
	            cfg_def.ssao = false;
	            cfg_def.init_wa_context_hack = true;
	            if (Boolean(m_ext.get_pvr()) && cfg_ldr.pvr_available)
	                cfg_def.compress_format = "pvr";

	        } else if (check_user_agent("Mac OS X") && check_user_agent("Safari")
	                && !check_user_agent("Chrome")) {
	            warn("OS X / Safari detected, force to wait complete loading. " +
	                    "Applying playback rate hack for video textures. " +
	                    "Applying canvas alpha hack.");
	            cfg_def.safari_canvas_alpha_hack = true;
	            cfg_sfx.audio_loading_hack = true;
	            cfg_sfx.clamp_playback_rate_hack = true;
	        }
	    if ((check_user_agent("Windows"))
	             &&(check_user_agent("Chrome/40") ||
	                check_user_agent("Firefox/33") ||
	                check_user_agent("Firefox/34") ||
	                check_user_agent("Firefox/35") ||
	                check_user_agent("Firefox/36"))) {
	        warn("Windows/Chrome40 or Firefox33-36 detected. Applying clear procedural skydome hack.");
	        cfg_def.clear_procedural_sky_hack = true;
	    }

	    if (check_user_agent("Chrome") && !detect_mobile() && m_cfg.is_built_in_data()) {
	        warn("Chrome (non-mobile) was detected for a single HTML-exported " 
	                + "file. \"Background Music\" speakers were changed to \"Background Sound\".");
	        cfg_def.chrome_html_bkg_music_hack = true;
	    }

	    if (check_user_agent("Mac OS X")) {
	        cfg_def.mac_os_shadow_hack = true;
	        warn("OS X detected, applying shadows hack.");
	    }

	    if (detect_mobile()) {
	        warn("Mobile detected, applying various hacks for video textures.");
	        cfg_def.is_mobile_device = true;
	        if (!(check_user_agent("iPad") || check_user_agent("iPhone"))
	                    && !check_user_agent("Windows Phone")) {
	            warn("Mobile (not iOS) detected, disable playback rate for video textures.");
	            cfg_sfx.disable_playback_rate_hack = true;
	        }
	    }

	    if (check_user_agent("iPad")) {
	        warn("iPad detected, use \"autoplay\" hack for video textures.");
	        cfg_def.ipad_video_hack = true;
	    }

	    if ((check_user_agent("Firefox/35.0") || check_user_agent("Firefox/36.0")) &&
	            check_user_agent("Windows")) {
	        warn("Windows/Firefox 35/36 detected, applying shadows slink hack");
	        cfg_def.shadows_color_slink_hack = true;
	    }

	    if (check_user_agent("iPhone") || is_ie11()) {
	        warn("iPhone or IE11 detected. Enable sequential video fallback for video textures.");
	        cfg_def.seq_video_fallback = true;
	    }

	    if (cfg_lim.max_varying_vectors < MIN_VARYINGS_REQUIRED) {
	        warn("Not enough varyings, disable shadows on blend objects");
	        cfg_def.disable_blend_shadows_hack = true;
	    }

	    if (check_user_agent("Windows Phone")) {
	        warn("Windows Phone detected. Disable debug view mode, "
	                    + "glow materials, ssao, smaa, shadows, reflections, refractions.");
	        cfg_def.debug_view = false;
	        cfg_def.glow_materials = false;
	        cfg_def.ssao = false;
	        cfg_def.smaa = false;
	        cfg_def.shadows = false;
	        cfg_def.reflections = false;
	        cfg_def.refractions = false;
	        cfg_def.quality_aa_method = false;
	    }

	    // TODO: check mobile Firefox
	    if (check_user_agent("UCBrowser") ||
	            check_user_agent("Chrome") && check_user_agent("Nexus") && cfg_def.is_mobile_device) {
	        warn("Mobile Nexus Chrome or UCBrowser detected, disable workers.");
	        cfg_phy.use_workers = false;
	    }

	    if (check_user_agent("Firefox")) {
	        warn("Firefox detected, disabling workers");
	        cfg_phy.use_workers = false;
	    }

	    if (is_ie11() || check_user_agent("Edge")) {
	        warn("IE11 or Edge detected, disabling workers");
	        cfg_phy.use_workers = false;
	    }

	    if (check_user_agent("Chrome") && check_user_agent("Linux")) {
	        warn("Chrome and Linux detected, disabling wasm physics.");
	        cfg_phy.use_wasm = false;
	    }

	    // NOTE: check compatibility for particular device
	    if (rinfo) {
	        var vendor = gl.getParameter(rinfo.UNMASKED_VENDOR_WEBGL);
	        var renderer = gl.getParameter(rinfo.UNMASKED_RENDERER_WEBGL);
	        var mali_4x_re = /\b4\d{2}\b/;

	        if (check_user_agent("Chrome") && renderer.indexOf("Mali-T720") > -1) {
	            warn("Chrome and ARM Mali-T720 detected, changing " 
	                    + "\"Alpha Anti-Aliasing\" materials to \"Alpha Clip\".");
	            cfg_def.mali_alpha_antialias_hack = true;
	        }

	        if (renderer.indexOf("AMD") > -1 && check_user_agent("Windows") 
	                && check_user_agent("Firefox")) {
	            warn("AMD, Windows and Firefox detected, disabling depth textures.");
	            depth_tex_available = false;
	        }

	        if (vendor.indexOf("ARM") > -1 && mali_4x_re.test(renderer)) {
	            warn("ARM Mali-400 series detected, applying lamps, depth and frames blending hacks");
	            depth_tex_available = false;
	            cfg_anim.frames_blending_hack = true;
	            cfg_def.mali4_lamps_hack = true;
	        }
	        if (vendor.indexOf("ARM") > -1 && renderer.indexOf("Mali-T604") > -1) {
	            warn("ARM Mali-T604 detected, disabling shadows.");
	            cfg_def.shadows = false;
	        }
	        if (vendor.indexOf("ARM") > -1 && renderer.indexOf("Mali-T760") > -1) {
	            warn("ARM Mali-T760 detected, disabling SSAO.");
	            cfg_def.ssao = false;
	            cfg_def.skinning_hack = true;
	            if (cfg_def.webgl2) {
	                cfg_def.msaa_samples = 1;
	                warn("ARM Mali-T760 and WebGL 2 detected, switching MSAA samples to 1.");
	            }
	        }

	        if (vendor.indexOf("ARM") > -1 && renderer.indexOf("Mali-T720") > -1) {
	            warn("ARM Mali-T720 detected, disabling depth textures.");
	            depth_tex_available = false;
	            if (cfg_def.webgl2) {
	                cfg_def.msaa_samples = 1;
	                warn("ARM Mali-T720 and WebGL 2 detected, switching MSAA samples to 1.");
	            }
	        }

	        if (vendor.indexOf("Qualcomm") > -1 && renderer.indexOf("Adreno") > -1) {
	            warn("Qualcomm Adreno detected, applying shader constants hack.");
	            cfg_def.shader_constants_hack = true;
	            if (renderer.indexOf("420") > -1) {
	                warn("Qualcomm Adreno420 detected, setting max cubemap size to 12288x8192, "
	                        + "setting max texture size to 4096x4096.");
	                cfg_lim.max_texture_size = Math.min(cfg_lim.max_texture_size, 4096);
	                cfg_lim.max_cube_map_texture_size = Math.min(
	                        cfg_lim.max_cube_map_texture_size, 4096);
	            }

	            if (check_user_agent("Chrome") && (renderer.match(/4../) 
	                    || renderer.match(/5../))) {
	                warn("Qualcomm Adreno 4xx or 5xx detected, switch MSAA samples to 1.");
	                cfg_def.msaa_samples = 1;
	            }

	        }
	        if (vendor.indexOf("NVIDIA") > -1 && renderer.indexOf("Tegra 3") > -1) {
	            warn("NVIDIA Tegra 3 detected, force low quality for "
	                                              + "B4W_LEVELS_OF_QUALITY nodes.");
	            cfg_def.force_low_quality_nodes = true;
	        }
	        if (check_user_agent("Windows") && check_user_agent("Chrome") && !check_user_agent("Edge") &&
	                (renderer.match(/NVIDIA GeForce 8..0/) || renderer.match(/NVIDIA GeForce 9..0/)
	                || renderer.match(/NVIDIA GeForce( (G|GT|GTS|GTX))? 2../))) {
	            warn("Chrome / Windows / NVIDIA GeForce 8/9/200 series detected, " +
	                         "setting max cubemap size to 768x512, use canvas for resizing.");
	            cfg_lim.max_cube_map_texture_size = exports.NVIDIA_OLD_GPU_CUBEMAP_MAX_SIZE;
	            cfg_def.resize_cubemap_canvas_hack = true;
	        }

	        if (renderer.indexOf("PowerVR") > -1 && renderer.indexOf("SGX") > -1) {
	            warn("PowerVR SGX series detected, use canvas for resizing. " +
	                    "Disable shadows. " +
	                    "Apply skinning hack, disable skin blending between frames.");
	            cfg_def.resize_cubemap_canvas_hack = true;
	            cfg_def.skinning_hack = true;
	            cfg_def.shadows = false;
	            // NOTE: uncomment code below in case of cfg_def.shadows == true;
	            // cfg_def.shadows_color_slink_hack = true;
	        }

	        if (check_user_agent("Windows") && renderer.indexOf("Direct3D9") > -1) {
	            warn("DirectX 9.0 detected, using canvas for resizing textures/cubemap textures.");
	            cfg_def.d3d9_canvas_resizing_hack = true;
	            cfg_def.resize_cubemap_canvas_hack = true;
	            cfg_def.resize_texture_canvas_hack = true;
	        }

	        var architecture = "";
	        for (var i = 0; i < AMD_MESA_RENDER_NAMES.length; i++)
	            if (renderer.indexOf(AMD_MESA_RENDER_NAMES[i]) > -1) {
	                architecture = AMD_MESA_RENDER_NAMES[i];
	                break;
	            }

	        if (architecture) {
	            warn("Architecture " + architecture + " detected. Blending between frames" +
	                    " and shadows on blend objects will be disabled.");
	            cfg_def.skinning_hack = true;
	            cfg_def.disable_blend_shadows_hack = true;
	        }
	    }

	    if (cfg_lim.max_vertex_texture_image_units == 0) {
	        warn("Vertex textures are not allowed. Disabling vertex textures");
	        cfg_def.allow_vertex_textures = false;
	    }
	    if (!depth_tex_available) {
	        cfg_def.foam =            false;
	        cfg_def.dynamic_grass =   false;
	        cfg_def.water_dynamic =   false;
	        cfg_def.shore_smoothing = false;
	        cfg_def.shore_distance =  false;
	        cfg_def.smaa =            false;
	        cfg_def.ssao =            false;
	        cfg_def.rgba_fallback_shadows = true;
	    }

	    cfg_def.use_compression = Boolean(m_ext.get_s3tc()) || cfg_def.compress_format == "pvr";
	    cfg_def.depth_tex_available = depth_tex_available;

	    // webglreport.com
	    if (gl.getShaderPrecisionFormat)
	        var high = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
	    if (!gl.getShaderPrecisionFormat || high.precision === 0)
	        cfg_def.precision = "mediump";

	    if (is_ie11() && check_user_agent("Touch") || check_user_agent("Edge")) {
	        warn("IE11 and touchscreen or Edge detected. Behaviour of the mouse move sensor will be changed.");
	        cfg_def.ie11_edge_touchscreen_hack = true;
	    }

	    if (is_ie11() || check_user_agent("Edge")) {
	        cfg_def.ie_edge_anchors_floor_hack = true;
	        cfg_def.ie11_edge_mouseoffset_hack = true;
	        cfg_def.resize_cubemap_canvas_hack = true;
	    }

	    if (detect_mobile() && check_user_agent("Firefox")) {
	        m_print.log("Mobile firefox detected. Applying autoplay media hack."
	                + "Setting max cubemap size to 12288x8192, "
	                + "setting max texture size to 4096x4096.");
	        cfg_def.mobile_firefox_media_hack = true;
	        cfg_lim.max_texture_size = Math.min(cfg_lim.max_texture_size, 4096);
	        cfg_lim.max_cube_map_texture_size = Math.min(
	                cfg_lim.max_cube_map_texture_size, 4096);
	    }

	    var aniso_available = Boolean(m_ext.get_aniso());
	    cfg_def.anisotropic_available = aniso_available;

	    var tex_lod_available = Boolean(m_ext.get_texture_lod());
	    cfg_def.texture_lod_available = tex_lod_available;
	};

	exports.check_user_agent = check_user_agent;
	/**
	 * for user agent hacks
	 */
	function check_user_agent(str) {
	    var user_agent = navigator.userAgent;
	    if (user_agent.indexOf(str) > -1)
	        return true;
	    else
	        return false;
	}
	exports.detect_mobile = detect_mobile;
	function detect_mobile() {
	    return navigator.userAgent.match(/Windows Phone/i)
	        ||navigator.userAgent.match(/Android/i)
	        || navigator.userAgent.match(/webOS/i)
	        || navigator.userAgent.match(/iPhone/i)
	        || navigator.userAgent.match(/iPad/i)
	        || navigator.userAgent.match(/iPod/i)
	        || navigator.userAgent.match(/BlackBerry/i);
	}

	exports.apply_context_alpha_hack = function() {
	    if (check_user_agent("Firefox/35.0") && check_user_agent("Windows")) {
	        m_print.warn("Windows/Firefox 35 detected, forcing context's alpha");
	        m_cfg.context.alpha = true;
	    }
	};
	/**
	 * Detect Internet Explorer 11
	 * @see http://stackoverflow.com/questions/21825157/internet-explorer-11-detection
	 */
	exports.is_ie11 = is_ie11;
	function is_ie11() {
	    return !(window.ActiveXObject) && "ActiveXObject" in window;
	}

	}

	var int_compat_factory = register("__compat", Int_compat);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Debug routines for internal usage.
	 * Don't forget to register GL context by setup_context() function.
	 * @name debug
	 * @namespace
	 * @exports exports as debug
	 */
	function Int_debug(ns, exports) {

	var m_batch  = int_batch_factory(ns);
	var m_compat = int_compat_factory(ns);
	var m_cfg    = int_config_factory(ns);
	var m_ext    = int_extensions_factory(ns);
	var m_graph  = int_graph_factory(ns);
	var m_obj    = int_objects_factory(ns);
	var m_print  = print_factory(ns);
	var m_scenes = int_scenes_factory(ns);
	var m_subs   = int_subscene_factory(ns);
	var m_tex    = int_textures_factory(ns);
	var m_time   = int_time_factory(ns);
	var m_util   = int_util_factory(ns);

	var cfg_def = m_cfg.defaults;

	var ERRORS = {};

	var RENDER_TIME_SMOOTH_INTERVALS = 10;

	var FAKE_LOAD_INTERVAL         = 5000;
	var FAKE_LOAD_START_PERCENTAGE = 0;
	var FAKE_LOAD_END_PERCENTAGE   = 100;

	var _gl = null;

	// NOTE: possible cleanup needed
	var _exec_counters = {};
	var _telemetry_messages = [];
	var _depth_only_issue = -1;
	var _multisample_issue = -1;

	var _debug_view_subs = null;

	var _assert_struct_last_obj = null;
	var _assert_struct_init = false;

	var _vbo_garbage_info = {};

	exports.DV_NONE = 0;
	exports.DV_OPAQUE_WIREFRAME = 1;
	exports.DV_TRANSPARENT_WIREFRAME = 2;
	exports.DV_FRONT_BACK_VIEW = 3;
	exports.DV_BOUNDINGS = 4;
	exports.DV_CLUSTERS_VIEW = 5;
	exports.DV_BATCHES_VIEW = 6;
	exports.DV_RENDER_TIME = 7;

	/**
	 * Setup WebGL context
	 * @param gl webgl context
	 */
	exports.setup_context = function(gl) {
	    // WebGLRenderingContext.cpp
	    var errors = [
	        "INVALID_ENUM",                     // 1280
	        "INVALID_VALUE",                    // 1281
	        "INVALID_OPERATION",                // 1282
	        "OUT_OF_MEMORY",                    // 1285
	        "INVALID_FRAMEBUFFER_OPERATION",    // 1286
	        "CONTEXT_LOST_WEBGL"                // 37442
	    ];

	    for (var i = 0; i < errors.length; i++) {
	        var error = errors[i];
	        if (error in gl)
	            ERRORS[gl[error]] = error;
	    }

	    _gl = gl;
	};

	exports.set_debug_view_subs = set_debug_view_subs;
	function set_debug_view_subs(subs) {
	    _debug_view_subs = subs;
	}

	exports.get_debug_view_subs = get_debug_view_subs;
	function get_debug_view_subs() {
	    return _debug_view_subs;
	}

	exports.fill_vbo_garbage_info = function(vbo_id, sh_pair_str, attr_name, 
	        byte_size, is_in_usage) {
	    if (!_vbo_garbage_info[vbo_id])
	        _vbo_garbage_info[vbo_id] = { shaders: sh_pair_str, attrs: {} };

	    if (!(attr_name in _vbo_garbage_info[vbo_id].attrs))
	        _vbo_garbage_info[vbo_id].attrs[attr_name] = byte_size;

	    if (is_in_usage)
	        _vbo_garbage_info[vbo_id].attrs[attr_name] = 0;
	};

	exports.calc_vbo_garbage_byte_size = function() {
	    var size = 0;
	    for (var vbo_id in _vbo_garbage_info)
	        for (var name in _vbo_garbage_info[vbo_id].attrs)
	            size += _vbo_garbage_info[vbo_id].attrs[name];
	    return size;
	};

	exports.show_vbo_garbage_info = function() {
	    var info_obj = {};
	    for (var vbo_id in _vbo_garbage_info)
	        for (var name in _vbo_garbage_info[vbo_id].attrs) {
	            var byte_size = _vbo_garbage_info[vbo_id].attrs[name];
	            if (byte_size) {
	                var sh_str = _vbo_garbage_info[vbo_id].shaders;
	                if (!(sh_str in info_obj))
	                    info_obj[sh_str] = { total_size: 0, attrs: {} };

	                if (!(name in info_obj[sh_str].attrs))
	                    info_obj[sh_str].attrs[name] = 0;
	                info_obj[sh_str].attrs[name] += byte_size;
	                info_obj[sh_str].total_size += byte_size;
	            }
	        }

	    for (var sh_str in info_obj) {
	        m_print.groupCollapsed(sh_str, info_obj[sh_str].total_size);
	        for (var name in info_obj[sh_str].attrs)
	            m_print.log_raw(name, info_obj[sh_str].attrs[name]);

	        m_print.groupEnd();
	    }
	};

	exports.print_batches_stat = function() {
	    var batches_props = {};
	    
	    // properties that don't affect batching
	    var excluded_props = [
	        "bounds_local", "bufs_data", "id", "attribute_setters", "num_vertices", 
	        "num_triangles", "material_names", "shader", "bpy_tex_names"
	    ];

	    var static_count = 0;
	    var dynamic_count = 0;

	    var objs = m_obj.get_scene_objs(m_scenes.get_main(), "MESH", m_obj.DATA_ID_ALL);
	    for (var i = 0; i < objs.length; i++) {
	        for (var j = 0; j < objs[i].scenes_data.length; j++)
	            for (var k = 0; k < objs[i].scenes_data[j].batches.length; k++) {

	                var batch = m_batch.clone_batch(objs[i].scenes_data[j].batches[k]);
	                
	                var shader_pair = batch.shaders_info.vert + "/" + batch.shaders_info.frag;
	                batch["shaders_info.directives"] = batch.shaders_info.directives;
	                batch["shaders_info.node_elements"] = batch.shaders_info.node_elements;
	                delete batch.shaders_info;
	                for (var l = 0; l < excluded_props.length; l++)
	                    delete batch[excluded_props[l]];

	                if (objs[i].is_dynamic) {
	                    dynamic_count++;
	                    continue;
	                } else
	                    static_count++;

	                if (!(batch.type in batches_props))
	                    batches_props[batch.type] = {};

	                if (!(shader_pair in batches_props[batch.type]))
	                    batches_props[batch.type][shader_pair] = {};

	                for (var prop in batch) {
	                    if (!(prop in batches_props[batch.type][shader_pair]))
	                        batches_props[batch.type][shader_pair][prop] = {};

	                    var str_val = JSON.stringify(batch[prop]);

	                    if (!(str_val in batches_props[batch.type][shader_pair][prop]))
	                        batches_props[batch.type][shader_pair][prop][str_val] = 0;

	                    batches_props[batch.type][shader_pair][prop][str_val]++;
	                }
	            }
	    }

	    m_print.group("Batches statistics:");
	    m_print.log_raw("STATIC/DYNAMIC count:", static_count + "/" + dynamic_count);
	    m_print.group("STATIC batches diversity:");

	    for (var type in batches_props)
	        for (var shader_pair in batches_props[type])
	            print_batches_stat_props(batches_props[type][shader_pair], type, shader_pair);

	    m_print.groupEnd();
	    m_print.groupEnd();
	};

	function print_batches_stat_props(props_dict, type, shader_pair) {
	    var props_array = [];
	    for (var prop in props_dict)
	        if (m_util.get_dict_length(props_dict[prop]) > 1)
	            props_array.push([prop, props_dict[prop]]);

	    props_array.sort(function(a, b) {
	        var a_len = m_util.get_dict_length(a[1]);
	        var b_len = m_util.get_dict_length(b[1]);
	        if (b_len != a_len)
	            return b_len - a_len;
	        return a < b ? -1 : b < a ? 1 : 0;
	    });

	    if (props_array.length) {
	        m_print.groupCollapsed(type + " " + shader_pair);
	        m_print.log_raw("Property different variants (>1) | Property name");
	        for (var i = 0; i < props_array.length; i++) {
	            m_print.groupCollapsed(m_util.get_dict_length(props_array[i][1]), props_array[i][0]);
	            print_batches_stat_props_values(props_array[i][1]);
	        }
	        m_print.groupEnd();
	    }
	}

	function print_batches_stat_props_values(values_dict) {
	    m_print.log_raw("Batches count for this property value | Property value");

	    var values_array = [];
	    for (var value in values_dict)
	        values_array.push([value, values_dict[value]]);

	    values_array.sort(function(a, b) {
	        if (b[1] != a[1])
	            return b[1] - a[1];
	        return a[0] < b[0] ? -1 : b[0] < a[0] ? 1 : 0;
	    });

	    for (var j = 0; j < values_array.length; j++)
	        m_print.log_raw(values_array[j][1], values_array[j][0]);
	    m_print.groupEnd();
	}

	/**
	 * Get GL error, throw exception if any.
	 */
	exports.check_gl = function(msg) {
	    if (!cfg_def.gl_debug)
	        return;

	    var error = _gl.getError();
	    if (error == _gl.NO_ERROR)
	        return;
	    if (error in ERRORS) 
	        m_util.panic("GL Error: " + error + ", gl." + ERRORS[error] + " (" + msg + ")");
	    else
	        m_util.panic("Unknown GL error: " + error + " (" + msg + ")");
	};

	/**
	 * Check status of currently bounded framebuffer object,
	 * Print error if framebuffer is incomplete.
	 * @returns {boolean} true if framebuffer complete
	 */
	exports.check_bound_fb = function() {

	    if (!cfg_def.gl_debug && !cfg_def.check_framebuffer_hack)
	        return true;

	    switch (_gl.checkFramebufferStatus(_gl.FRAMEBUFFER)) {
	    case _gl.FRAMEBUFFER_COMPLETE:
	        return true;
	    case _gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
	        m_print.error("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_ATTACHMENT");
	        return false;
	    case _gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
	        m_print.error("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
	        return false;
	    case _gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
	        m_print.error("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
	        return false;
	    case _gl.FRAMEBUFFER_UNSUPPORTED:
	        m_print.error("Incomplete framebuffer: FRAMEBUFFER_UNSUPPORTED");
	        return false;
	    case _gl.FRAMEBUFFER_INCOMPLETE_MULTISAMPLE:
	        m_print.error("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_MULTISAMPLE");
	        return false;
	    default:
	        m_print.error("FRAMEBUFFER CHECK FAILED");
	        return false;
	    }
	};

	/**
	 * Check for issue with incomplete depth-only framebuffer.
	 * found on some old GPUs. (Found on Intel, AMD and NVIDIA)
	 */
	exports.check_depth_only_issue = function() {
	    // use cached result
	    if (_depth_only_issue != -1)
	        return _depth_only_issue;

	    var framebuffer = _gl.createFramebuffer();
	    _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);

	    var texture = m_tex.create_texture(m_tex.TT_DEPTH, false);
	    m_tex.resize(texture, 1, 1);

	    var w_tex = texture.w_texture;
	    var w_target = texture.w_target;

	    _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, w_target, 
	            w_tex, 0);

	    if (_gl.checkFramebufferStatus(_gl.FRAMEBUFFER) != _gl.FRAMEBUFFER_COMPLETE) {
	        _depth_only_issue = true;
	        m_print.warn("depth-only issue was found");
	    } else
	        _depth_only_issue = false;

	    // switch back to the window-system provided framebuffer
	    _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);

	    _gl.deleteFramebuffer(framebuffer);

	    return _depth_only_issue;
	};

	/**
	 * Check for issue with failing multisample renderbuffers.
	 * Found on Firefox 46.
	 */
	exports.check_multisample_issue = function() {
	    // msaa is disabled
	    if (cfg_def.msaa_samples == 1)
	        return false;

	    // use cached result
	    if (_multisample_issue != -1)
	        return _multisample_issue;

	    var rb = _gl.createRenderbuffer();
	    _gl.bindRenderbuffer(_gl.RENDERBUFFER, rb);
	    _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, cfg_def.msaa_samples,
	            _gl.RGBA8, 1, 1);

	    var num_samples = _gl.getRenderbufferParameter(_gl.RENDERBUFFER,
	            _gl.RENDERBUFFER_SAMPLES);

	    if (num_samples != cfg_def.msaa_samples) {
	        _multisample_issue = true;
	        m_print.warn("multisample issue was found: requested " +
	                cfg_def.msaa_samples + ", got " + num_samples);
	        if (_gl.getError() == _gl.INVALID_OPERATION)
	            m_print.warn("the error from multisample issue detected, ignoring");
	    } else
	        _multisample_issue = false;

	    _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);

	    return _multisample_issue;
	};

	/**
	 * Check for Firefox cubemap issue found on some old GPUs.
	 * (Found on NVIDIA 8000/9000/200 series).
	 */
	exports.check_ff_cubemap_out_of_memory = function() {
	    if (m_compat.check_user_agent("Firefox") 
	            && _gl.getError() == _gl.OUT_OF_MEMORY) {
	        m_print.warn("Firefox/old GPUs cubemap issue was found.");
	        return true;
	    }

	    return false;

	};

	/**
	 * Prints shader text numbered lines and error.
	 * @param {WebGLShader} shader Shader object
	 * @param {string} shader_id Shader id
	 * @param {string} shader_text Shader text
	 */
	exports.report_shader_compiling_error = function(shader, shader_id, shader_text) {

	    if (!cfg_def.gl_debug)
	        return;

	    shader_text = supply_line_numbers(shader_text);

	    m_print.error("shader compilation failed:\n" + shader_text + "\n" +
	        _gl.getShaderInfoLog(shader) + " (" + shader_id + ")");
	};

	function supply_line_numbers(text) {

	    var lines = text.split("\n");
	    for (var i = 0; i < lines.length; i++) 
	        lines[i] = (i + 1) + " " + lines[i];
	    text = lines.join("\n");

	    return text;
	}  

	/**
	 * Prints shader text numbered lines and error.
	 * @param {WebGLProgram} program Shader program object
	 * @param {string} shader_id Shader id
	 * @param {string} vshader_text Vertex shader text
	 * @param {string} fshader_text Fragment shader text
	 */
	exports.report_shader_linking_error = function(program, shader_id,
	        vshader_text, fshader_text) {

	    if (!cfg_def.gl_debug)
	        return;

	    vshader_text = supply_line_numbers(vshader_text);
	    fshader_text = supply_line_numbers(fshader_text);

	    m_print.error("shader linking failed:\n" + vshader_text + "\n\n\n" +
	        fshader_text + "\n" +
	        _gl.getProgramInfoLog(program) + " (" + shader_id + ")");
	};

	exports.render_time_start_subs = function(subs) {
	    if (!(cfg_def.show_hud_debug_info || subs.type == m_subs.PERFORMANCE))
	        return;

	    if (subs.do_not_debug)
	        return;

	    subs.debug_render_time_queries.push(create_render_time_query());
	};

	exports.render_time_start_batch = function(batch) {
	    if (!(batch.type == "MAIN" && is_debug_view_render_time_mode()))
	        return;

	    batch.debug_render_time_queries.push(create_render_time_query());   
	};

	function create_render_time_query() {
	    var ext = m_ext.get_disjoint_timer_query();

	    if (ext) {
	        var query = ext.createQuery();
	        ext.beginQuery(query);
	    } else
	        var query = performance.now();

	    return query;
	}

	exports.render_time_stop_subs = function(subs) {
	    if (!(cfg_def.show_hud_debug_info || subs.type == m_subs.PERFORMANCE))
	        return;

	    if (subs.do_not_debug)
	        return;

	    var render_time = calc_render_time(subs.debug_render_time_queries, 
	            subs.debug_render_time, true);
	    if (render_time)
	        subs.debug_render_time = render_time;
	};

	exports.render_time_stop_batch = function(batch) {
	    if (!(batch.type == "MAIN" && is_debug_view_render_time_mode()))
	        return;

	    var render_time = calc_render_time(batch.debug_render_time_queries, 
	            batch.debug_render_time, true);
	    if (render_time)
	        batch.debug_render_time = render_time;
	};

	exports.is_debug_view_render_time_mode = is_debug_view_render_time_mode;
	function is_debug_view_render_time_mode() {
	    var subs_debug_view = get_debug_view_subs();
	    return subs_debug_view && subs_debug_view.debug_view_mode == exports.DV_RENDER_TIME;
	}

	/**
	 * External method for debugging purposes
	 */
	exports.process_timer_queries = function(subs) {
	    var render_time = calc_render_time(subs.debug_render_time_queries, 
	            subs.debug_render_time, false);
	    if (render_time)
	        subs.debug_render_time = render_time;
	};

	function calc_render_time(queries, prev_render_time, end_query) {
	    var ext = m_ext.get_disjoint_timer_query();
	    var render_time = 0;

	    if (ext) {
	        if (end_query)
	            ext.endQuery();

	        for (var i = 0; i < queries.length; i++) {
	            var query = queries[i];

	            var available = ext.getQueryAvailable(query);

	            var disjoint = _gl.getParameter(ext.getDisjoint());

	            if (available && !disjoint) {
	                var elapsed = ext.getQueryObject(query);
	                render_time = elapsed / 1000000;
	                if (prev_render_time)
	                    render_time = m_util.smooth(render_time,
	                            prev_render_time, 1, RENDER_TIME_SMOOTH_INTERVALS);

	                queries.splice(i, 1);
	                i--;
	            }
	        }
	    } else {
	        render_time = performance.now() - queries.pop();
	        if (prev_render_time)
	            render_time = m_util.smooth(render_time,
	                    prev_render_time, 1, RENDER_TIME_SMOOTH_INTERVALS);
	    }

	    return render_time;
	}

	/**
	 * Print number of executions per frame.
	 * @param {string} counter ID
	 */
	exports.exec_count = function(counter) {
	    if (counter in _exec_counters)
	        _exec_counters[counter] += 1;
	    else
	        _exec_counters[counter] = 1;
	};

	/**
	 * Executed each frame.
	 */
	exports.update = function() {
	    for (var i in _exec_counters) {
	        m_print.log(i, _exec_counters[i]);
	        _exec_counters[i] = 0;
	    }
	};

	/**
	 * Flashback telemetry message prepended by precise time
	 */
	exports.fbmsg = function() {
	    var msg = [performance.now()];

	    for (var i = 0; i < arguments.length; i++) {
	        var arg = arguments[i];

	        if (m_util.is_vector(arg)) {
	            for (var j = 0; j < arg.length; j++)
	                msg.push(arg[j]);
	        } else
	            msg.push(arguments[i]);
	    }

	    _telemetry_messages.push(msg);
	};

	/**
	 * Simple telemetry message prepended by id counter
	 */
	exports.msg = function() {

	    var id_count = 1;
	    for (var i = 0; i < _telemetry_messages.length; i++) {
	        var msg = _telemetry_messages[i];
	        if (msg[1] == arguments[0])
	            id_count++;
	    }

	    var msg = [id_count];

	    for (var i = 0; i < arguments.length; i++) {
	        var arg = arguments[i];

	        if (m_util.is_vector(arg)) {
	            for (var j = 0; j < arg.length; j++)
	                msg.push(arg[j]);
	        } else
	            msg.push(arguments[i]);
	    }

	    _telemetry_messages.push(msg);
	};


	var COLORS = ["color: #3366FF", "color: #CC33FF", "color: #FF3366", "color: #33FF66", "color: #FFCC33"];

	exports.print_telemetry = function(time) {
	    if (!time)
	        time = 1.0;

	    var color_counter = 0;
	    var color_by_id = {};

	    var start_time_ms = Math.max(0.0, performance.now() - time * 1000.0);
	    for (var i = 0; i < _telemetry_messages.length; i++) {
	        var msg = _telemetry_messages[i];

	        time = msg[0];

	        if (time < start_time_ms)
	            continue;

	        var id = String(msg[1]);

	        if (!color_by_id[id])
	            color_by_id[id] = COLORS[(color_counter++) % COLORS.length];

	        var color = color_by_id[id];

	        var console_args = ["%c" + (time / 1000).toFixed(6), color, id];
	        for (var j = 2; j < msg.length; j++)
	            console_args.push(msg[j]);

	        m_print.log.apply(this, console_args);
	    }

	    // clear
	    _telemetry_messages.splice(0);
	};

	exports.plot_telemetry = function(time) {
	    if (!time)
	        time = 1.0;

	    var msg_by_id = {};

	    var start_time_ms = Math.max(0.0, performance.now() - time * 1000.0);

	    for (var i = 0; i < _telemetry_messages.length; i++) {
	        var msg = _telemetry_messages[i];

	        time = msg[0];

	        if (time < start_time_ms)
	            continue;

	        for (var j = 2; j < msg.length; j++) {
	            var id = String(msg[1]);
	            if (msg.length > 3)
	                id += "_" + String(j-2);
	            
	            if (!msg_by_id[id])
	                msg_by_id[id] = id + "\n";

	            msg_by_id[id] += String(time) + " " + msg[j] + "\n";
	        }
	    }

	    var plot_str = "";

	    for (var id in msg_by_id)
	        plot_str += msg_by_id[id] + "\n\n";

	    m_print.log(plot_str);

	    // clear
	    _telemetry_messages.splice(0);
	};

	/**
	 * Check browser by searching name in user agent.
	 * unreliable method, use only for debug purposes
	 */
	exports.check_browser = function(name) {
	    var user_agent = navigator.userAgent.toLowerCase();

	    var check_ua = function(name) {
	        if (user_agent.indexOf(name) > -1)
	            return true;
	        else
	            return false;
	    };

	    switch (name.toLowerCase()) {
	    case "chrome":
	        return (check_ua("mozilla") && check_ua("applewebkit") && check_ua("chrome"));
	    case "firefox":
	        return (check_ua("mozilla") && check_ua("gecko") && check_ua("firefox"));
	    case "msie":
	        return (check_ua("mozilla") && check_ua("trident") && check_ua("msie"));
	    case "opera":
	        return (check_ua("opera") && check_ua("presto"));
	    case "safari":
	        return (check_ua("mozilla") && check_ua("applewebkit") &&
	                check_ua("safari") && !check_ua("chrome"));
	    default:
	        return false;
	    }
	};

	exports.check_finite = function(o) {
	    if (m_util.is_vector(o)) {
	        for (var i = 0; i < o.length; i++)
	            if (!isFinite(o[i]))
	                return false;
	        // empty vector is not finite
	        return Boolean(o.length);
	    } else if (!isFinite(o)) {
	            return false;
	    } else {
	        return true;
	    }
	};

	exports.assert_cons = function(value, constructor) {
	    if (value.constructor != constructor)
	        m_util.panic("Type assertion failed: value <" + value + "> has type <"
	                + value.constructor + ">, required <" + constructor + ">");
	};

	/**
	 * Check whether the two objects have the same structure with proper values.
	 */
	exports.assert_struct = assert_struct;
	function assert_struct(obj1, obj2) {

	    if (!is_valid(obj1))
	        m_util.panic("Structure assertion failed: invalid first object value");

	    if (!is_valid(obj2))
	        m_util.panic("Structure assertion failed: invalid second object value");

	    if (!cmp_type(obj1, obj2))
	        m_util.panic("Structure assertion failed: incompatible types");

	    // continue with objects
	    if (!(obj1 != null && obj2 != null && typeof obj1 == "object" &&
	                !m_util.is_arr_buf_view(obj1) && !(obj1 instanceof Array)))
	        return;

	    for (var i in obj1) {
	        if (!is_valid(obj1[i]))
	            m_util.panic("Structure assertion failed: invalid value for key " +
	                    "in the first object: " + i);
	        if (!(i in obj2))
	            m_util.panic("Structure assertion failed: missing key in the first object: " + i);
	    }

	    for (var i in obj2) {
	        if (!is_valid(obj2[i]))
	            m_util.panic("Structure assertion failed: invalid value for key " +
	                    "in the second object: " + i);
	        if (!(i in obj1))
	            m_util.panic("Structure assertion failed: missing key in the second object: " + i);
	        if (!cmp_type(obj1[i], obj2[i]))
	            m_util.panic("Structure assertion failed: incompatible types for key " + i);
	    }
	}

	function is_valid(obj) {
	    if (typeof obj == "undefined")
	        return false;
	    else if (typeof obj == "number" && isNaN(obj))
	        return false;
	    else
	        return true;
	}

	function cmp_type(obj1, obj2) {
	    var type1 = typeof obj1;
	    var type2 = typeof obj2;

	    if (type1 != type2)
	        return false;

	    // additional checks for js arrays or array buffers
	    if (obj1 != null && obj2 != null && typeof obj1 == "object") {
	        var is_arr1 = obj1 instanceof Array;
	        var is_arr2 = obj2 instanceof Array;

	        if ((is_arr1 && !is_arr2) || (!is_arr1 && is_arr2))
	            return false;

	        var is_abv1 = m_util.is_arr_buf_view(obj1);
	        var is_abv2 = m_util.is_arr_buf_view(obj2);

	        if ((is_abv1 && !is_abv2) || (!is_abv1 && is_abv2))
	            return false;
	    }

	    return true;
	}

	/**
	 * Assert object stucture - sequential form.
	 * There is no cleanup, so always reload the page.
	 */
	exports.assert_struct_seq = function(obj) {
	    if (!_assert_struct_init)
	        _assert_struct_init = true;
	    else
	        assert_struct(obj, _assert_struct_last_obj);

	    if (obj != null && typeof obj == "object")
	        _assert_struct_last_obj = m_util.clone_object_nr(obj);
	    else
	        _assert_struct_last_obj = obj;
	};

	exports.fake_load = function(stageload_cb, interval, start, end, loaded_cb) {
	    stageload_cb = stageload_cb || null;

	    if (!stageload_cb)
	        m_util.panic("Stage load callback is undefined");

	    interval = interval || FAKE_LOAD_INTERVAL;
	    start    = start || FAKE_LOAD_START_PERCENTAGE;
	    end      = end || FAKE_LOAD_END_PERCENTAGE;

	    if (end > 100)
	        m_util.panic("Max percentage must be less than 100");

	    if (start < 0)
	        m_util.panic("Min percentage must be greater than 0");

	    if (start > end)
	        m_util.panic("Max percentage must be greater than min percentage");

	    var animator = m_time.animate(start, end, interval, function(e) {
	        var rounded_percentage = e.toFixed();

	        stageload_cb(rounded_percentage);

	        if (rounded_percentage == 100) {
	            m_time.clear_animation(animator);

	            if (loaded_cb)
	                loaded_cb();

	            return;
	        }
	    });
	};

	exports.nodegraph_to_dot = function(graph, detailed_print) {

	    if (detailed_print) {
	        var get_data_info = function(attr) {
	            var data_info = "";
	            switch (attr.type) {
	            case "GEOMETRY_UV":
	                data_info = "\nuv_layer: " + attr.data.value;
	                break;
	            case "TEXTURE_COLOR":
	            case "TEXTURE_NORMAL":
	                data_info = "\ntexture: " + attr.data.value.name + "\n(" 
	                        + attr.data.value.img_filepath + ")";
	                break;
	            }

	            if (data_info == "")
	                data_info = "\n---";

	            return data_info;
	        };

	        var nodes_label_cb = function (id, attr) {
	            var node_text = attr.type + "(" + attr.name + ")";

	            var inputs = attr.inputs;
	            node_text += "\n\nINPUTS:";
	            if (inputs.length)
	                for (var i = 0; i < inputs.length; i++) {
	                    node_text += "\n" + inputs[i].identifier + ": ";
	                    if (inputs[i].is_linked) {
	                        node_text += "linked";
	                    } else
	                        node_text += inputs[i].default_value;
	                }
	            else
	                node_text += "\n---";

	            var outputs = attr.outputs;
	            node_text += "\n\nOUTPUTS:";
	            if (outputs.length)
	                for (var i = 0; i < outputs.length; i++) {
	                    node_text += "\n" + outputs[i].identifier + ": ";
	                    if (outputs[i].is_linked) {
	                        node_text += "linked(default " + outputs[i].default_value + ")";
	                    } else
	                        node_text += "not used";
	                }
	            else
	                node_text += "\n---";

	            node_text += "\n\nDATA:";
	            node_text += get_data_info(attr);

	            return node_text;
	        };

	        var edges_label_cb = function (id1, id2, attr) {
	            var node1 = m_graph.get_node_attr(graph, id1);
	            var node2 = m_graph.get_node_attr(graph, id2);
	            var out1 = node1.outputs[attr[0]];
	            var in2 = node2.inputs[attr[1]];
	            return out1.identifier + "\n==>\n" + in2.identifier;
	        };
	    } else {
	        var nodes_label_cb = function (id, attr) {
	            return attr.type;
	        };
	        var edges_label_cb = function (id1, id2, attr) {
	            var node1 = m_graph.get_node_attr(graph, id1);
	            var node2 = m_graph.get_node_attr(graph, id2);
	            var out1 = node1.outputs[attr[0]];
	            var in2 = node2.inputs[attr[1]];
	            return out1.identifier + "\n==>\n" + in2.identifier;
	        };
	    }

	    return m_graph.debug_dot(graph, nodes_label_cb, edges_label_cb);
	};

	/**
	 * NOTE: need to find better place for this internal method
	 */
	exports.get_gl = function() {
	    return _gl;
	};

	exports.cleanup = function() {
	    _debug_view_subs = null;
	    _vbo_garbage_info = {};
	};

	exports.reset = function() {
	    _gl = null;
	};

	}

	var int_debug_factory = register("__debug", Int_debug);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Node material internal routines.
	 * @name nodemat
	 * @namespace
	 * @exports exports as nodemat
	 */
	function Int_nodemat(ns, exports) {

	var m_cfg     = int_config_factory(ns);
	var m_debug   = int_debug_factory(ns);
	var m_graph   = int_graph_factory(ns);
	var m_mat3    = mat3_factory(ns);
	var m_mat4    = mat4_factory(ns);
	var m_obj     = int_objects_factory(ns);
	var m_print   = print_factory(ns);
	var m_shaders = int_shaders_factory(ns);
	var m_scenes  = int_scenes_factory(ns);
	var m_util    = int_util_factory(ns);
	var m_vec3    = vec3_factory(ns);
	var m_tex     = int_textures_factory(ns);

	var _shader_ident_counters = {};
	var _composed_ngraph_proxies = {};
	var _composed_stack_graphs = {};
	var _lamp_indexes = {};
	var _lamp_index = 0;

	var cfg_def = m_cfg.defaults;

	var DEBUG_NODE_GRAPHS = false;

	var VECTOR_VALUE = 0;
	var SCALAR_VALUE = 1;

	var CURVE_POINT_EPS = 0.01;

	// NOTE: keep constants synchronized with:
	//          shaders/include/std.glsl
	//          src/batch.js : update_batch_material_nodes
	var VT_POINT  = 0;
	var VT_VECTOR = 1;
	var VT_NORMAL = 2;

	var VT_WORLD_TO_WORLD   = 0;
	var VT_WORLD_TO_OBJECT  = 1;
	var VT_WORLD_TO_CAMERA  = 2;
	var VT_OBJECT_TO_WORLD  = 3;
	var VT_OBJECT_TO_OBJECT = 4;
	var VT_OBJECT_TO_CAMERA = 5;
	var VT_CAMERA_TO_WORLD  = 6;
	var VT_CAMERA_TO_OBJECT = 7;
	var VT_CAMERA_TO_CAMERA = 8;
	exports.VT_WORLD_TO_WORLD   = VT_WORLD_TO_WORLD;
	exports.VT_WORLD_TO_OBJECT  = VT_WORLD_TO_OBJECT;
	exports.VT_WORLD_TO_CAMERA  = VT_WORLD_TO_CAMERA;
	exports.VT_OBJECT_TO_WORLD  = VT_OBJECT_TO_WORLD;
	exports.VT_OBJECT_TO_OBJECT = VT_OBJECT_TO_OBJECT;
	exports.VT_OBJECT_TO_CAMERA = VT_OBJECT_TO_CAMERA;
	exports.VT_CAMERA_TO_WORLD  = VT_CAMERA_TO_WORLD;
	exports.VT_CAMERA_TO_OBJECT = VT_CAMERA_TO_OBJECT;
	exports.VT_CAMERA_TO_CAMERA = VT_CAMERA_TO_CAMERA;

	var NM_TANGENT        = 0;
	var NM_OBJECT         = 1;
	var NM_WORLD          = 2;
	var NM_BLENDER_OBJECT = 3;
	var NM_BLENDER_WORLD  = 4;
	exports.NM_TANGENT        = NM_TANGENT;
	exports.NM_OBJECT         = NM_OBJECT;
	exports.NM_WORLD          = NM_WORLD;
	exports.NM_BLENDER_OBJECT = NM_BLENDER_OBJECT;
	exports.NM_BLENDER_WORLD  = NM_BLENDER_WORLD;

	// output_material node input sockets
	var OMI_SURFACE      = 0;
	// var OMI_VOLUME       = 1;
	var OMI_DISPLACEMENT = 2;

	exports.get_ngraph_proxy_cached = function(ngraph_id) {
	    return _composed_ngraph_proxies[ngraph_id];
	};

	exports.cleanup_ngraph_proxy = function(ngraph_id) {
	    delete _composed_ngraph_proxies[ngraph_id];   
	};

	exports.compose_ngraph_proxy = compose_ngraph_proxy;
	function compose_ngraph_proxy(node_tree, source_id, is_node_group, mat_user_name,
	        mat_name, shader_type, active_layer_names) {

	    var ngraph_proxy = compose_ngraph_proxy_rec(node_tree, source_id, 
	            is_node_group, shader_type, active_layer_names);

	    if (DEBUG_NODE_GRAPHS)
	        print_node_graph(ngraph_proxy.graph, mat_user_name, mat_name);
	    return ngraph_proxy;
	}

	function compose_ngraph_proxy_rec(node_tree, source_id, is_node_group, 
	        shader_type, active_layer_names) {
	    var scene_uuid = "";
	    if (m_scenes.check_active()) {
	        var active_scene = m_scenes.get_active();
	        scene_uuid = active_scene["uuid"];
	    }
	    var ntree_graph_id = generate_graph_id(source_id, shader_type, scene_uuid, 
	            active_layer_names);

	    if (ntree_graph_id in _composed_ngraph_proxies)
	        return _composed_ngraph_proxies[ntree_graph_id];

	    var ngraph_proxy = {
	        graph: null,
	        id: ntree_graph_id,
	        cleanup_on_unload: true
	    };

	    if (!is_node_group) {
	        // reset lamps counter
	        _lamp_indexes = {};
	        _lamp_index = 0;
	    }

	    if (shader_type != "SHADOW" && shader_type != "COLOR_ID") {
	        var graph = m_graph.create();

	        var bpy_nodes = node_tree["nodes"];

	        for (var i = 0; i < bpy_nodes.length; i++) {
	            var bpy_node = bpy_nodes[i];
	            if (append_nmat_node(graph, bpy_node, 0, shader_type, 
	                    active_layer_names) == null) {
	                _composed_ngraph_proxies[ntree_graph_id] = null;
	                return ngraph_proxy;
	            }
	        }

	        if (is_node_group)
	            if (find_node_id(node_tree, graph, "GROUP_OUTPUT", "group") == -1)
	                return ngraph_proxy;

	        var node_groups = trace_group_nodes(graph);
	        // NOTE: don't change source node_tree (node_group_tree is already copied)
	        var links = is_node_group ? node_tree["links"] : node_tree["links"].slice();
	        if (!append_node_groups_graphs(graph, links, node_groups))
	            return ngraph_proxy;

	        if (is_node_group) {
	            ngraph_proxy.graph = graph;
	            return ngraph_proxy;
	        }

	        for (var i = 0; i < links.length; i++) {
	            var link = links[i];

	            // multiple node IDs for single bpy_node will in case of node splitting
	            // e.g GEOMETRY node splitting
	            var node_ids1 = nmat_node_ids(link["from_node"], graph);
	            var node_ids2 = nmat_node_ids(link["to_node"], graph);

	            for (var j = 0; j < node_ids1.length; j++) {
	                for (var k = 0; k < node_ids2.length; k++) {
	                    var node_id1 = node_ids1[j];
	                    var node_id2 = node_ids2[k];

	                    var node_attr1 = m_graph.get_node_attr(graph, node_id1);
	                    var node_attr2 = m_graph.get_node_attr(graph, node_id2);

	                    if (!append_nmat_edge(graph, node_id1, node_id2,
	                            node_attr1, node_attr2, link)) {
	                        _composed_ngraph_proxies[ntree_graph_id] = null;
	                        return ngraph_proxy;
	                    }
	                }
	            }
	        }

	        complete_edges(graph);

	        var is_world_mat = false;
	        var output_id = -1;
	        if (shader_type == "GLOW") {
	            output_id = find_node_id(node_tree, graph, "B4W_GLOW_OUTPUT",
	                                         "material", true);
	        } else {
	            output_id = find_node_id(node_tree, graph, "OUTPUT",
	                                         "material", false, true);
	            if (output_id == -1) {
	                output_id = find_node_id(node_tree, graph, "OUTPUT_MATERIAL",
	                                         "material", false, true);
	            }

	            if (output_id == -1) {
	                output_id = find_node_id(node_tree, graph, "OUTPUT_WORLD",
	                                         "material", false, true);
	                is_world_mat = true;
	            }

	        }
	        if (output_id == -1) {
	            graph = create_default_nmat_graph();
	            output_id = 0;
	        }

	        nmat_cleanup_graph(graph);
	        var graph_out = m_graph.subgraph_node_conn(graph, output_id,
	                                                   m_graph.BACKWARD_DIR);

	        if (!is_world_mat) {
	            split_material_nodes(graph_out, shader_type);
	            split_cycles_output_nodes(graph_out, shader_type);
	        } else {
	            split_world_output_nodes(graph_out, shader_type);
	            replace_world_shader_nodes_with_rgbs(graph_out, shader_type);
	            remove_unsupported_world_nodes(graph_out);
	            remove_inconsistent_world_links(graph_out);
	        }

	        clean_sockets_linked_property(graph_out);

	        merge_nodes(graph_out);

	        optimize_geometry(graph_out);

	        fix_socket_types(graph_out, shader_type);
	        create_node_textures(graph_out);

	    } else {
	        var main_ngraph_proxy = compose_ngraph_proxy_rec(node_tree, source_id, 
	                is_node_group, "MAIN", active_layer_names);

	        var nodes_cb = function(node) {
	            var new_node = m_util.clone_object_nr(node);
	            new_node.inputs = m_util.clone_object_r(node.inputs);
	            new_node.outputs = m_util.clone_object_r(node.outputs);
	            return new_node;
	        };

	        var ntree_graph = m_graph.clone(main_ngraph_proxy.graph, nodes_cb);
	        var output_id = find_node_id(node_tree, ntree_graph, "OUTPUT",
	                                     "material", false, true);
	        if (output_id == -1)
	                output_id = find_node_id(node_tree, ntree_graph, "OUTPUT_MATERIAL",
	                                         "material", false, true);
	        remove_color_output(ntree_graph, output_id);

	        var graph_out = m_graph.subgraph_node_conn(ntree_graph, output_id,
	                                                   m_graph.BACKWARD_DIR);
	        clean_sockets_linked_property(graph_out);
	    }


	    ngraph_proxy.graph = graph_out;
	    _composed_ngraph_proxies[ntree_graph_id] = ngraph_proxy;

	    return ngraph_proxy;
	}

	exports.create_lighting_graph = function(source_id, data) {
	    var active_scene = m_scenes.get_active();
	    var ntree_graph_id = generate_graph_id(source_id, "MAIN", active_scene["uuid"]);

	    if (ntree_graph_id in _composed_stack_graphs)
	        return _composed_stack_graphs[ntree_graph_id];

	    var graph = m_graph.create();

	    var bpy_node = {"name": "LIGHTING_BEGIN",
	                    "type": "LIGHTING_BEGIN"};
	    var begin_node_id = append_nmat_node(graph, bpy_node, 0, null, null);

	    bpy_node = {"name": "LIGHTING_END",
	                "type": "LIGHTING_END"};
	    var end_node_id = append_nmat_node(graph, bpy_node, 0, null, null);
	    var translucency_edges = [[begin_node_id, [8, 10]],
	                             [begin_node_id, [9, 6]]];
	    add_lighting_subgraph(graph, data, begin_node_id, end_node_id, 
	            translucency_edges);
	    clean_sockets_linked_property(graph);
	    _composed_stack_graphs[ntree_graph_id] = graph;
	    return graph;
	};

	function split_material_nodes(graph, shader_type) {
	    var material_nodes = [];
	    m_graph.traverse(graph, function(id, node) {
	        if (node.type == "MATERIAL" || node.type == "MATERIAL_EXT") {
	            var material = {
	                node_id: id,
	                node: node
	            };
	            material_nodes.push(material);
	        }
	    });

	    for (var i = 0; i < material_nodes.length; ++i) {
	        var node_id = material_nodes[i].node_id;
	        var node = material_nodes[i].node;

	        var material_begin_id = m_graph.gen_node_id(graph);
	        m_graph.append_node(graph, material_begin_id, node.data.material_begin);
	        var material_end_id = m_graph.gen_node_id(graph);
	        m_graph.append_node(graph, material_end_id, node.data.material_end);

	        // normal
	        m_graph.append_edge(graph, material_begin_id, material_end_id, [4,2]);

	        var material_socket_map = {
	            5: ["LIGHTING_APPLY", 10], // translucency_color
	            6: ["LIGHTING_APPLY", 6], // translucency_params
	            7: ["MATERIAL_END", 3], // reflect_factor
	            8: ["MATERIAL_END", 4], // specular_alpha
	            9: ["MATERIAL_END", 5] // alpha_in
	        };

	        var in_count = m_graph.in_edge_count(graph, node_id);
	        var remove_edges_in = [];
	        var append_edges_in = [];
	        var translucency_edges = [];

	        // process every edges ingoing to material/material_ext node
	        var edges_in_counter = {};
	        for (var k = 0; k < in_count; k++) {
	            var in_id = m_graph.get_in_edge(graph, node_id, k);

	            if (!(in_id in edges_in_counter))
	                edges_in_counter[in_id] = 0;
	            var edge_attr = m_graph.get_edge_attr(graph, in_id,
	                    node_id, edges_in_counter[in_id]++);

	            // removing/appending edges affects graph traversal
	            remove_edges_in.push([in_id, node_id, edge_attr]);

	            var dest = material_socket_map[edge_attr[1]];
	            if (dest)
	                switch (dest[0]) {
	                case "MATERIAL_END":
	                    append_edges_in.push([in_id, material_end_id, [edge_attr[0], dest[1]]]);
	                    break;
	                case "LIGHTING_APPLY":
	                    translucency_edges.push([in_id, [edge_attr[0], dest[1]]]);
	                    break;
	                }
	            else
	                append_edges_in.push([in_id, material_begin_id, edge_attr]);
	        }

	        add_lighting_subgraph(graph, node.data.value, material_begin_id, 
	                material_end_id, translucency_edges);

	        for (var k = 0; k < remove_edges_in.length; k++) 
	            m_graph.remove_edge_by_attr(graph, remove_edges_in[k][0],
	                    remove_edges_in[k][1], remove_edges_in[k][2]);
	        for (var k = 0; k < append_edges_in.length; k++)
	            m_graph.append_edge(graph, append_edges_in[k][0],
	                    append_edges_in[k][1], append_edges_in[k][2]);

	        var out_count = m_graph.out_edge_count(graph, node_id);
	        var remove_out_edges = [];
	        var append_out_edges = [];
	        // process every outgoing edge
	        var edges_out_counter = {};
	        for (var k = 0; k < out_count; k++) {
	            var out_id = m_graph.get_out_edge(graph, node_id, k);

	            if (!(out_id in edges_out_counter))
	                edges_out_counter[out_id] = 0;
	            var edge_attr = m_graph.get_edge_attr(graph, node_id,
	                    out_id, edges_out_counter[out_id]++);

	            // removing/appending edges affects graph traversal
	            remove_out_edges.push([node_id, out_id, edge_attr]);
	            append_out_edges.push([material_end_id, out_id, edge_attr]);
	        }

	        for (var k = 0; k < remove_out_edges.length; k++)
	            m_graph.remove_edge_by_attr(graph, remove_out_edges[k][0],
	                    remove_out_edges[k][1], remove_out_edges[k][2]);

	        for (var k = 0; k < append_out_edges.length; k++)
	            m_graph.append_edge(graph, append_out_edges[k][0],
	                    append_out_edges[k][1], append_out_edges[k][2]);

	        m_graph.remove_node(graph, node_id);
	    }
	}

	function add_lighting_subgraph(graph, data, begin_node_id, end_node_id,
	        translucency_edges) {
	    var bpy_node = {"name": "LIGHTING_AMBIENT",
	                    "type": "LIGHTING_AMBIENT"};
	    var curr_node_id = append_nmat_node(graph, bpy_node, 0, null, null);
	    var prev_node_id = curr_node_id;

	    link_edge_by_ident(graph, begin_node_id, curr_node_id, "E");
	    link_edge_by_ident(graph, begin_node_id, curr_node_id, "A");
	    link_edge_by_ident(graph, begin_node_id, curr_node_id, "D");

	    var scene = m_scenes.get_active();
	    var lamps = m_obj.get_scene_objs(scene, "LAMP", m_obj.DATA_ID_ALL);

	    if (!data.use_shadeless) {
	        var lamp_node_id;
	        var lighting_apply_node_id;
	        var shade_spec_node_id;
	        var shade_dif_node_id;

	        for (var i = 0; i < lamps.length; i++) {
	            var light = lamps[i].light;

	            bpy_node = {"name": "LIGHTING_LAMP",
	                        "type": "LIGHTING_LAMP"};
	            lamp_node_id = append_nmat_node(graph, bpy_node, 0, null, null);
	            bpy_node = {"name": "LIGHTING_APPLY",
	                        "type": "LIGHTING_APPLY"};
	            lighting_apply_node_id = append_nmat_node(graph, bpy_node, 0, null, null);

	            // LIGHTING_APPLY inputs
	            link_edge_by_ident(graph, prev_node_id, lighting_apply_node_id, "color");
	            link_edge_by_ident(graph, prev_node_id, lighting_apply_node_id, "specular");
	            link_edge_by_ident(graph, lamp_node_id, lighting_apply_node_id, "ldir");
	            link_edge_by_ident(graph, begin_node_id, lighting_apply_node_id, "normal");
	            link_edge_by_ident(graph, begin_node_id, lighting_apply_node_id, "D");
	            link_edge_by_ident(graph, begin_node_id, lighting_apply_node_id, "S");
	            link_edge_by_ident(graph, lamp_node_id, lighting_apply_node_id, "lcolorint");

	            // LIGHTING_LAMP input
	            link_edge_by_ident(graph, begin_node_id, lamp_node_id, "shadow_factor");

	            var spec_name = "SPECULAR_" + data.specular_shader;
	            bpy_node = {"name": spec_name,
	                        "type": spec_name,
	                        "use_tangent_shading" : data.use_tangent_shading};
	            shade_spec_node_id = append_nmat_node(graph, bpy_node, 0, null, null);

	            // SPECULAR inputs
	            link_edge_by_ident(graph, lamp_node_id, shade_spec_node_id, "ldir");
	            link_edge_by_ident(graph, lamp_node_id, shade_spec_node_id, "lfac");
	            link_edge_by_ident(graph, begin_node_id, shade_spec_node_id, "normal");

	            // SPECULAR output
	            link_edge_by_ident(graph, shade_spec_node_id, lighting_apply_node_id, "sfactor");

	            link_edge_by_ident(graph, lamp_node_id, shade_spec_node_id, "norm_fac");
	            link_edge_by_ident(graph, begin_node_id, shade_spec_node_id, "sp_params");

	            if (light.type == "HEMI")
	                var dif_name = "DIFFUSE_LAMBERT";
	            else
	                var dif_name = "DIFFUSE_" + data.diffuse_shader;

	            bpy_node = {"name": dif_name, 
	                        "type": dif_name,
	                        "use_tangent_shading" : data.use_tangent_shading};
	            shade_dif_node_id = append_nmat_node(graph, bpy_node, 0, null, null);

	            // DIFFUSE inputs
	            link_edge_by_ident(graph, lamp_node_id, shade_dif_node_id, "ldir");
	            link_edge_by_ident(graph, lamp_node_id, shade_dif_node_id, "lfac");
	            link_edge_by_ident(graph, begin_node_id, shade_dif_node_id, "normal");
	            link_edge_by_ident(graph, lamp_node_id, shade_dif_node_id, "norm_fac");

	            // DIFFUSE output
	            link_edge_by_ident(graph, shade_dif_node_id, lighting_apply_node_id, "lfactor");
	            
	            if (dif_name != "DIFFUSE_LAMBERT")
	                link_edge_by_ident(graph, begin_node_id, shade_dif_node_id, "dif_params");

	            for (var j = 0; j < translucency_edges.length; j++) {
	                var in_node_id = translucency_edges[j][0];
	                var edge_attr = translucency_edges[j][1];
	                m_graph.append_edge(graph, in_node_id, lighting_apply_node_id, edge_attr);
	            }

	            prev_node_id = lighting_apply_node_id;
	        }
	    }
	    link_edge_by_ident(graph, prev_node_id, end_node_id, "color");
	    link_edge_by_ident(graph, prev_node_id, end_node_id, "specular");
	}

	function link_edge_by_ident(graph, id1, id2, inout_ident) {
	    var node1 = m_graph.get_node_attr(graph, id1);
	    var node2 = m_graph.get_node_attr(graph, id2);

	    var in2 = -1;
	    var n2_inputs = node2.inputs;
	    for (var i = 0; i < n2_inputs.length; i++) {
	        var input = n2_inputs[i];
	        if (inout_ident == input.identifier) {
	            in2 = i;
	            break;
	        }
	    }

	    if (in2 == -1)
	        return;

	    var out1 = -1;
	    var n1_outputs = node1.outputs;
	    for (var i = 0; i < n1_outputs.length; i++) {
	        var output = n1_outputs[i];
	        if (inout_ident == output.identifier) {
	            out1 = i;
	            break;
	        }
	    }

	    if (out1 == -1)
	        return;

	    m_graph.append_edge(graph, id1, id2, [out1, in2]);
	    n1_outputs[out1].is_linked = true;
	    n2_inputs[in2].is_linked = true;
	}

	function split_cycles_output_nodes(graph, shader_type) {
	    var output_material_nodes = [];
	    m_graph.traverse(graph, function(id, node) {
	        if (node.type == "OUTPUT_MATERIAL") {
	            var out_mat = {
	                node_id: id,
	                node: node
	            };
	            output_material_nodes.push(out_mat);
	        }
	    });

	    for (var i = 0; i < output_material_nodes.length; ++i) {
	        var om_id = output_material_nodes[i].node_id;
	        var om_node = output_material_nodes[i].node;
	        var use_surface = false;
	        var use_displacement = false;

	        var srf_output_id = m_graph.gen_node_id(graph);
	        m_graph.append_node(graph, srf_output_id, om_node.data.output_surface);

	        var in_count = m_graph.in_edge_count(graph, om_id);
	        var remove_edges_in = [];
	        var append_edges_in = [];

	        // process every edges ingoing to output_material nodes
	        var edges_in_counter = {};
	        for (var j = 0; j < in_count; j++) {
	            var in_id = m_graph.get_in_edge(graph, om_id, j);

	            if (!(in_id in edges_in_counter))
	                edges_in_counter[in_id] = 0;
	            var edge_attr = m_graph.get_edge_attr(graph, in_id,
	                    om_id, edges_in_counter[in_id]++);

	            // removing/appending edges affects graph traversal
	            remove_edges_in.push([in_id, om_id, edge_attr]);

	            switch (edge_attr[1]) {
	            case OMI_SURFACE:
	                use_surface = true;
	                append_edges_in.push([in_id, srf_output_id, edge_attr]);
	                break;
	            case OMI_DISPLACEMENT:
	                use_displacement = true;
	                var dsp_bump_id = m_graph.gen_node_id(graph);
	                m_graph.append_node(graph, dsp_bump_id, om_node.data.displacement_bump);
	                // height input of dsp bump
	                append_edges_in.push([in_id, dsp_bump_id, [edge_attr[0], 0]]);
	                break;
	            }
	        }

	        for (var j = 0; j < remove_edges_in.length; j++)
	            m_graph.remove_edge_by_attr(graph, remove_edges_in[j][0],
	                    remove_edges_in[j][1], remove_edges_in[j][2]);
	        for (var j = 0; j < append_edges_in.length; j++)
	            m_graph.append_edge(graph, append_edges_in[j][0],
	                    append_edges_in[j][1], append_edges_in[j][2]);

	        m_graph.remove_node(graph, om_id);

	        if (use_surface) {
	            if (use_displacement)
	                separate_displacement_bump_subgraph(graph, srf_output_id, dsp_bump_id);

	            split_surface_output_nodes(graph, shader_type);

	        } else {
	            var dummy_output = m_graph.get_node_attr(graph, srf_output_id);

	            graph.nodes = [0, dummy_output];
	            graph.edges = [];
	        }
	    }
	}

	function separate_displacement_bump_subgraph(graph, srf_output_id, dsp_bump_id) {
	    var srf_graph = m_graph.subgraph_node_conn(graph, srf_output_id,
	                                                   m_graph.BACKWARD_DIR);
	    var dn_id_arr = get_def_normal_nodes_ids(srf_graph);

	    if (dn_id_arr.length) {
	        var dsp_bump_subgraph = m_graph.subgraph_node_conn(graph, dsp_bump_id,
	                                                       m_graph.BACKWARD_DIR);
	        var dsp_bump_subgraph_clone = clone_nmat_graph(dsp_bump_subgraph);

	        m_graph.traverse(dsp_bump_subgraph_clone, function(id, node) {
	            var new_name = "displacement%join%" + node.name;
	            node.name = new_name;
	        });

	        m_graph.append_subgraph(dsp_bump_subgraph_clone, srf_graph, [], []);

	        var new_dsp_bump_id = -1;
	        m_graph.traverse(srf_graph, function(id, node) {
	            if (node.type == "DISPLACEMENT_BUMP") {
	                new_dsp_bump_id = id;
	                return 1;
	            }
	        });

	        for (var i = 0; i < dn_id_arr.length; i++) {
	            var dn_id = dn_id_arr[i];
	            var dn_node = m_graph.get_node_attr(srf_graph, dn_id);

	            link_edge_by_ident(srf_graph, new_dsp_bump_id, dn_id, "Normal");
	            override_node_dir_value(dn_node, "USE_NORMAL_IN", 1);
	        }
	    }

	    graph.nodes = srf_graph.nodes;
	    graph.edges = srf_graph.edges;
	}

	function override_node_dir_value(node, dir_name, dir_value) {
	    var dirs = node.dirs;
	    for (var i = 0; i < dirs.length; i++) {
	        var dir = dirs[i];
	        if (dir[0] == dir_name)
	            dir[1] = dir_value;
	    }
	}

	function get_def_normal_nodes_ids(graph) {
	    //all nodes which will use default/geometry normal
	    var def_normal_nodes = [];
	    m_graph.traverse(graph, function(id, node) {
	        var has_unused_normal_input = false;
	        var inputs = node.inputs;
	        for (var i = 0; i < inputs.length; i++) {
	            if (inputs[i].identifier == "Normal") {
	                has_unused_normal_input = !inputs[i].is_linked;
	                break;
	            }
	        }

	        if (has_unused_normal_input) {
	            def_normal_nodes.push(id);
	        }

	    });

	    return def_normal_nodes;
	}

	function split_surface_output_nodes(graph, shader_type) {
	    var output_surface_nodes = [];
	    m_graph.traverse(graph, function(id, node) {
	        if (node.type == "OUTPUT_SURFACE") {
	            var out_mat = {
	                node_id: id,
	                node: node
	            };
	            output_surface_nodes.push(out_mat);
	        }
	    });

	    var mix_shader_nodes = [];
	    if (output_surface_nodes.length)
	        m_graph.traverse(graph, function(id, node) {
	            if (node.type == "MIX_SHADER") {
	                var mix_sh = {
	                    node_id: id,
	                    node: node
	                };
	                mix_shader_nodes.push(mix_sh);
	            }
	        });

	    for (var i = 0; i < output_surface_nodes.length; ++i) {
	        var node_id = output_surface_nodes[i].node_id;
	        var node = output_surface_nodes[i].node;

	        var bsdf_begin_id = m_graph.gen_node_id(graph);
	        m_graph.append_node(graph, bsdf_begin_id, node.data.bsdf_begin);
	        var bsdf_end_id = m_graph.gen_node_id(graph);
	        m_graph.append_node(graph, bsdf_end_id, node.data.bsdf_end);

	        // normal
	        m_graph.append_edge(graph, bsdf_begin_id, bsdf_end_id, [4,2]);

	        // var bsdf_socket_map = {
	        //     // 5: ["LIGHTING_APPLY", 10], // translucency_color
	        //     // 6: ["LIGHTING_APPLY", 6], // translucency_params
	        //     // 7: ["BSDF_END", 3], // reflect_factor
	        //     // 8: ["BSDF_END", 4], // specular_alpha
	        //     // 9: ["BSDF_END", 5], // alpha_in
	        // }

	        var in_count = m_graph.in_edge_count(graph, node_id);
	        var remove_edges_in = [];
	        var append_edges_in = [];
	        var translucency_edges = [];

	        // process every edges ingoing to output_surface nodes
	        var edges_in_counter = {};
	        for (var k = 0; k < in_count; k++) {
	            var in_id = m_graph.get_in_edge(graph, node_id, k);
	            var in_node = m_graph.get_node_attr(graph, in_id);

	            if (!(in_id in edges_in_counter))
	                edges_in_counter[in_id] = 0;
	            var edge_attr = m_graph.get_edge_attr(graph, in_id,
	                    node_id, edges_in_counter[in_id]++);

	            // removing/appending edges affects graph traversal
	            remove_edges_in.push([in_id, node_id, edge_attr]);

	            // var dest = bsdf_socket_map[edge_attr[1]]
	            // if (dest)
	            //     switch (dest[0]) {
	            //     case "BSDF_END":
	            //         append_edges_in.push([in_id, bsdf_end_id, [edge_attr[0], dest[1]]]);
	            //         break;
	            //     case "LIGHTING_APPLY":
	            //         translucency_edges.push([in_id, [edge_attr[0], dest[1]]]);
	            //         break;
	            //     }
	            // else
	            append_edges_in.push([in_id, bsdf_begin_id, edge_attr]);

	            if (in_node.type == "BSDF_GLOSSY" || in_node.type == "BSDF_DIFFUSE" || in_node.type == "MIX_SHADER" ||
	                    in_node.type == "EMISSION" || in_node.type == "BSDF_TRANSPARENT") {
	                // d_color
	                append_edges_in.push([in_id, bsdf_begin_id, [1, 1]]);
	                // d_roughness
	                append_edges_in.push([in_id, bsdf_begin_id, [2, 2]]);
	                // s_color
	                append_edges_in.push([in_id, bsdf_begin_id, [3, 3]]);
	                // s_roughness
	                append_edges_in.push([in_id, bsdf_begin_id, [4, 4]]);
	                // metalness
	                append_edges_in.push([in_id, bsdf_begin_id, [5, 5]]);
	                // normal
	                append_edges_in.push([in_id, bsdf_begin_id, [6, 6]]);
	                // e_color
	                append_edges_in.push([in_id, bsdf_begin_id, [7, 7]]);
	                // emission
	                append_edges_in.push([in_id, bsdf_begin_id, [8, 8]]);
	                // a_color
	                append_edges_in.push([in_id, bsdf_begin_id, [9, 9]]);
	                // alpha
	                append_edges_in.push([in_id, bsdf_begin_id, [10, 10]]);

	                // additional links between all bsdf and shader mixing nodes
	                for (var j = 0; j < mix_shader_nodes.length; ++j) {
	                    var mix_node_id = mix_shader_nodes[j].node_id;
	                    var mix_in_count = m_graph.in_edge_count(graph, mix_node_id);

	                    for (var m = 0; m < mix_in_count; m++) {
	                        var mix_in_id = m_graph.get_in_edge(graph, mix_node_id, m);
	                        var mix_in_node = m_graph.get_node_attr(graph, mix_in_id);
	                        var mix_in_edge_attr = m_graph.get_edge_attr(graph, mix_in_id, mix_node_id, 0);
	                        // not Factor input
	                        if (mix_in_edge_attr[1] != 0) {
	                            if (mix_in_node.type == "BSDF_GLOSSY" || mix_in_node.type == "BSDF_DIFFUSE" || mix_in_node.type == "MIX_SHADER" ||
	                                    mix_in_node.type == "EMISSION" || mix_in_node.type == "BSDF_TRANSPARENT") {

	                                // inputs 0-2 standard (Factor, Shader, Shader)
	                                var edge_attr_offset = mix_in_edge_attr[1] == 1 ? 3 : 13;

	                                // d_color
	                                append_edges_in.push([mix_in_id, mix_node_id, [1, edge_attr_offset]]);
	                                // d_roughness
	                                append_edges_in.push([mix_in_id, mix_node_id, [2, edge_attr_offset+1]]);
	                                // s_color
	                                append_edges_in.push([mix_in_id, mix_node_id, [3, edge_attr_offset+2]]);
	                                // s_roughness
	                                append_edges_in.push([mix_in_id, mix_node_id, [4, edge_attr_offset+3]]);
	                                // metalness
	                                append_edges_in.push([mix_in_id, mix_node_id, [5, edge_attr_offset+4]]);
	                                // normal
	                                append_edges_in.push([mix_in_id, mix_node_id, [6, edge_attr_offset+5]]);
	                                // e_color
	                                append_edges_in.push([mix_in_id, mix_node_id, [7, edge_attr_offset+6]]);
	                                // emission
	                                append_edges_in.push([mix_in_id, mix_node_id, [8, edge_attr_offset+7]]);
	                                // a_color
	                                append_edges_in.push([mix_in_id, mix_node_id, [9, edge_attr_offset+8]]);
	                                // alpha
	                                append_edges_in.push([mix_in_id, mix_node_id, [10, edge_attr_offset+9]]);
	                            }
	                        }
	                    }
	                }
	            }
	        }

	        add_bsdf_subgraph(graph, node.data.value, bsdf_begin_id, bsdf_end_id, translucency_edges);

	        append_edges_in.push([bsdf_end_id, node_id, [0,0]]);

	        for (var k = 0; k < remove_edges_in.length; k++)
	            m_graph.remove_edge_by_attr(graph, remove_edges_in[k][0],
	                    remove_edges_in[k][1], remove_edges_in[k][2]);
	        for (var k = 0; k < append_edges_in.length; k++)
	            m_graph.append_edge(graph, append_edges_in[k][0],
	                    append_edges_in[k][1], append_edges_in[k][2]);
	    }
	}

	function add_bsdf_subgraph(graph, data, begin_node_id, end_node_id, translucency_edges) {
	    var bpy_node = {"name": "LIGHTING_AMBIENT",
	                    "type": "LIGHTING_AMBIENT"};
	    var curr_node_id = append_nmat_node(graph, bpy_node, 0, null, null);
	    var prev_node_id = curr_node_id;

	    link_edge_by_ident(graph, begin_node_id, curr_node_id, "E");
	    link_edge_by_ident(graph, begin_node_id, curr_node_id, "A");
	    link_edge_by_ident(graph, begin_node_id, curr_node_id, "D");

	    var scene = m_scenes.get_active();
	    var lamps = m_obj.get_scene_objs(scene, "LAMP", m_obj.DATA_ID_ALL);

	    var lamp_node_id;
	    var lighting_apply_node_id;
	    var shade_dif_node_id;

	    for (var i = 0; i < lamps.length; i++) {
	        bpy_node = {"name": "LIGHTING_LAMP",
	                    "type": "LIGHTING_LAMP"};
	        lamp_node_id = append_nmat_node(graph, bpy_node, 0, null, null);
	        bpy_node = {"name": "LIGHTING_APPLY",
	                    "type": "LIGHTING_APPLY"};
	        lighting_apply_node_id = append_nmat_node(graph, bpy_node, 0, null, null);

	        // LIGHTING_APPLY inputs
	        link_edge_by_ident(graph, prev_node_id, lighting_apply_node_id, "color");
	        link_edge_by_ident(graph, prev_node_id, lighting_apply_node_id, "specular");
	        link_edge_by_ident(graph, lamp_node_id, lighting_apply_node_id, "ldir");
	        link_edge_by_ident(graph, begin_node_id, lighting_apply_node_id, "normal");
	        link_edge_by_ident(graph, begin_node_id, lighting_apply_node_id, "D");
	        link_edge_by_ident(graph, begin_node_id, lighting_apply_node_id, "S");
	        link_edge_by_ident(graph, lamp_node_id, lighting_apply_node_id, "lcolorint");

	        // LIGHTING_LAMP input
	        link_edge_by_ident(graph, begin_node_id, lamp_node_id, "shadow_factor");

	        var bsdf_name = data.bsdf_shader;

	        bpy_node = {"name": bsdf_name,
	                    "type": bsdf_name};
	        shade_dif_node_id = append_nmat_node(graph, bpy_node, 0, null, null);

	        // BSDF inputs
	        link_edge_by_ident(graph, lamp_node_id, shade_dif_node_id, "ldir");
	        link_edge_by_ident(graph, lamp_node_id, shade_dif_node_id, "lfac");
	        link_edge_by_ident(graph, begin_node_id, shade_dif_node_id, "normal");
	        link_edge_by_ident(graph, lamp_node_id, shade_dif_node_id, "norm_fac");
	        link_edge_by_ident(graph, begin_node_id, shade_dif_node_id, "bsdf_params");

	        // BSDF output
	        link_edge_by_ident(graph, shade_dif_node_id, lighting_apply_node_id, "lfactor");
	        link_edge_by_ident(graph, shade_dif_node_id, lighting_apply_node_id, "sfactor");

	        for (var j = 0; j < translucency_edges.length; j++) {
	            var in_node_id = translucency_edges[j][0];
	            var edge_attr = translucency_edges[j][1];
	            m_graph.append_edge(graph, in_node_id, lighting_apply_node_id, edge_attr);
	        }

	        prev_node_id = lighting_apply_node_id;
	    }

	    link_edge_by_ident(graph, begin_node_id, end_node_id, "bsdf_params");
	    link_edge_by_ident(graph, begin_node_id, end_node_id, "d_color");
	    link_edge_by_ident(graph, begin_node_id, end_node_id, "s_color");
	    link_edge_by_ident(graph, begin_node_id, end_node_id, "e_color");
	    link_edge_by_ident(graph, begin_node_id, end_node_id, "emission");
	    link_edge_by_ident(graph, begin_node_id, end_node_id, "a_color");
	    link_edge_by_ident(graph, begin_node_id, end_node_id, "alpha");

	    link_edge_by_ident(graph, prev_node_id, end_node_id, "color");
	    link_edge_by_ident(graph, prev_node_id, end_node_id, "specular");
	}

	function split_world_output_nodes(graph, shader_type) {
	    var output_world_nodes = [];
	    m_graph.traverse(graph, function(id, node) {
	        if (node.type == "OUTPUT_WORLD") {
	            var out_mat = {
	                node_id: id,
	                node: node
	            };
	            output_world_nodes.push(out_mat);
	        }
	    });

	    for (var i = 0; i < output_world_nodes.length; ++i) {
	        var ow_id = output_world_nodes[i].node_id;
	        var ow_node = output_world_nodes[i].node;

	        var srf_output_id = m_graph.gen_node_id(graph);
	        m_graph.append_node(graph, srf_output_id, ow_node.data.output_world_surface);

	        var in_count = m_graph.in_edge_count(graph, ow_id);
	        var remove_edges_in = [];
	        var append_edges_in = [];

	        // process every edges ingoing to output_material nodes
	        var edges_in_counter = {};
	        for (var j = 0; j < in_count; j++) {
	            var in_id = m_graph.get_in_edge(graph, ow_id, j);

	            if (!(in_id in edges_in_counter))
	                edges_in_counter[in_id] = 0;
	            var edge_attr = m_graph.get_edge_attr(graph, in_id,
	                    ow_id, edges_in_counter[in_id]++);

	            // removing/appending edges affects graph traversal
	            remove_edges_in.push([in_id, ow_id, edge_attr]);

	            switch (edge_attr[1]) {
	            case OMI_SURFACE:
	                append_edges_in.push([in_id, srf_output_id, edge_attr]);
	                break;
	            }
	        }

	        for (var j = 0; j < remove_edges_in.length; j++)
	            m_graph.remove_edge_by_attr(graph, remove_edges_in[j][0],
	                    remove_edges_in[j][1], remove_edges_in[j][2]);
	        for (var j = 0; j < append_edges_in.length; j++)
	            m_graph.append_edge(graph, append_edges_in[j][0],
	                    append_edges_in[j][1], append_edges_in[j][2]);

	        m_graph.remove_node(graph, ow_id);
	    }
	}

	function replace_world_shader_nodes_with_rgbs(graph, shader_type) {
	    var remove_nodes = [];
	    m_graph.traverse(graph, function(id, node) {
	        if (node.type == "MIX_SHADER" || node.type == "ADD_SHADER") {
	            var shader_node = {
	                node_id: id,
	                node: node
	            };
	            remove_nodes.push(shader_node);
	        }
	    });

	    if (remove_nodes.length) {
	        var bpy_node = {"name": "RGB_WORLD_NODE",
	                        "type": "RGB_WORLD_NODE",
	                        "factor": 0.5};

	        for (var i = 0; i < remove_nodes.length; i++) {
	            var node_id = remove_nodes[i].node_id;
	            var node = remove_nodes[i].node;

	            bpy_node["name"] = node.name;
	            bpy_node["fac"]= node.inputs[0].default_value;
	            bpy_node["fac_is_linked"] = node.inputs[0].is_linked;
	            bpy_node["color1_is_linked"] = node.inputs[1].is_linked;
	            bpy_node["color2_is_linked"] = node.inputs[2].is_linked;
	            switch (node.type) {
	            case "ADD_SHADER":
	                bpy_node["type"] = "ADD_WORLD_RGB";
	                break;
	            case "MIX_SHADER":
	                bpy_node["type"] = "MIX_WORLD_RGB";
	                break;
	            }

	            var rgb_world_id = append_nmat_node(graph, bpy_node, 0, shader_type, null);


	            var in_count = m_graph.in_edge_count(graph, node_id);
	            var remove_edges_in = [];
	            var append_edges_in = [];
	            // process every ingoing edge
	            var edges_in_counter = {};
	            for (var k = 0; k < in_count; k++) {
	                var in_id = m_graph.get_in_edge(graph, node_id, k);

	                if (!(in_id in edges_in_counter))
	                    edges_in_counter[in_id] = 0;
	                var edge_attr = m_graph.get_edge_attr(graph, in_id,
	                        node_id, edges_in_counter[in_id]++);

	                // removing/appending edges affects graph traversal
	                remove_edges_in.push([in_id, node_id, edge_attr]);
	                append_edges_in.push([in_id, rgb_world_id, edge_attr]);
	            }

	            for (var k = 0; k < remove_edges_in.length; k++)
	                m_graph.remove_edge_by_attr(graph, remove_edges_in[k][0],
	                        remove_edges_in[k][1], remove_edges_in[k][2]);
	            for (var k = 0; k < append_edges_in.length; k++)
	                m_graph.append_edge(graph, append_edges_in[k][0],
	                        append_edges_in[k][1], append_edges_in[k][2]);


	            var out_count = m_graph.out_edge_count(graph, node_id);
	            var remove_out_edges = [];
	            var append_out_edges = [];
	            // process every outgoing edge
	            var edges_out_counter = {};
	            for (var k = 0; k < out_count; k++) {
	                var out_id = m_graph.get_out_edge(graph, node_id, k);

	                if (!(out_id in edges_out_counter))
	                    edges_out_counter[out_id] = 0;
	                var edge_attr = m_graph.get_edge_attr(graph, node_id,
	                        out_id, edges_out_counter[out_id]++);

	                // removing/appending edges affects graph traversal
	                remove_out_edges.push([node_id, out_id, edge_attr]);
	                append_out_edges.push([rgb_world_id, out_id, edge_attr]);
	            }

	            for (var k = 0; k < remove_out_edges.length; k++)
	                m_graph.remove_edge_by_attr(graph, remove_out_edges[k][0],
	                        remove_out_edges[k][1], remove_out_edges[k][2]);

	            for (var k = 0; k < append_out_edges.length; k++)
	                m_graph.append_edge(graph, append_out_edges[k][0],
	                        append_out_edges[k][1], append_out_edges[k][2]);

	            m_graph.remove_node(graph, node_id);
	        }
	    }
	}

	function remove_unsupported_world_nodes(graph) {
	    var output_ws_id = -1;
	    var remove_nodes = [];
	    var remove_edges = [];

	    var supported_world_node_types = [
	            "OUTPUT_WORLD_SURFACE", "BACKGROUND", "RGB", "VALUE", "ADD_WORLD_RGB", "MIX_WORLD_RGB", "TEXTURE_ENVIRONMENT_EQUIRECTANGULAR",
	            "TEXTURE_ENVIRONMENT_MIRROR_BALL", "GEOMETRY_NO", "GEOMETRY_TRN", "GEOMETRY_GL", "GEOMETRY_IN", "TEXTURE_COLOR",
	            "TEX_COORD_GE", "TEX_COORD_OB", "TEX_COORD_NO",
	            "COMBRGB", "COMBHSV", "CURVE_RGB", "CURVE_VEC", "B4W_LINEAR_TO_SRGB", "B4W_NORMAL_VIEW", "B4W_VECTOR_VIEW",
	            "B4W_SRGB_TO_LINEAR", "B4W_REFLECT", "B4W_CLAMP", "B4W_TIME", "B4W_SMOOTHSTEP", "NORMAL", "MAPPING",
	            "MATH_ADD", "MATH_SUBTRACT", "MATH_MULTIPLY", "MATH_DIVIDE", "MATH_SINE", "MATH_COSINE",
	            "MATH_TANGENT", "MATH_ARCSINE", "MATH_ARCCOSINE", "MATH_ARCTANGENT", "MATH_POWER", "MATH_LOGARITHM", "MATH_MINIMUM",
	            "MATH_MAXIMUM", "MATH_ROUND", "MATH_LESS_THAN", "MATH_GREATER_THAN", "MATH_MODULO","MATH_ABSOLUTE",
	            "MIX_RGB_MIX", "MIX_RGB_ADD", "MIX_RGB_MULTIPLY", "MIX_RGB_SUBTRACT", "MIX_RGB_SCREEN", "MIX_RGB_DIVIDE",
	            "MIX_RGB_DIFFERENCE", "MIX_RGB_DARKEN", "MIX_RGB_LIGHTEN", "MIX_RGB_OVERLAY", "MIX_RGB_DODGE", "MIX_RGB_BURN",
	            "MIX_RGB_HUE", "MIX_RGB_SATURATION", "MIX_RGB_VALUE", "MIX_RGB_COLOR", "MIX_RGB_SOFT_LIGHT", "MIX_RGB_LINEAR_LIGHT",
	            "SEPRGB", "SEPHSV", "VALTORGB", "VECT_TRANSFORM", "VECT_MATH_ADD",
	            "VECT_MATH_SUBTRACT", "VECT_MATH_AVERAGE", "VECT_MATH_DOT_PRODUCT", "VECT_MATH_CROSS_PRODUCT", "VECT_MATH_NORMALIZE"
	    ];

	    m_graph.traverse(graph, function(id, node) {
	        var node_type = node.type;

	        switch (supported_world_node_types.indexOf(node_type)) {
	        case -1: // not supported
	            var useless_node = {
	                node_id: id,
	                node: node
	            };
	            remove_nodes.push(useless_node);
	            break;
	        case 0: // OUTPUT_WORLD_SURFACE
	            output_ws_id = id;
	            break;
	        }
	    });

	    for (var i = 0; i < remove_nodes.length; i++) {
	        var node_id = remove_nodes[i].node_id;
	        // var node = remove_nodes[i].node;

	        var out_count = m_graph.out_edge_count(graph, node_id);
	        var edges_out_counter = {};
	        for (var j = 0; j < out_count; j++) {
	            var out_id = m_graph.get_out_edge(graph, node_id, j);
	            // var out_node = m_graph.get_node_attr(graph, out_id);

	            if (!(out_id in edges_out_counter))
	                edges_out_counter[out_id] = 0;
	            var edge_attr = m_graph.get_edge_attr(graph, node_id,
	                    out_id, edges_out_counter[out_id]++);

	            // removing/appending edges affects graph traversal
	            remove_edges.push([node_id, out_id, edge_attr]);
	        }
	    }

	    // TODO: replace def values for unlinked inputs with zeros
	    for (var i = 0; i < remove_edges.length; i++)
	        m_graph.remove_edge_by_attr(graph, remove_edges[i][0],
	                remove_edges[i][1], remove_edges[i][2]);

	    if (remove_edges.length) {
	        var world_graph = m_graph.subgraph_node_conn(graph, output_ws_id,
	                                                           m_graph.BACKWARD_DIR);
	        graph.nodes = world_graph.nodes;
	        graph.edges = world_graph.edges;
	    }
	}

	function remove_inconsistent_world_links(graph) {
	    var output_ws_id = -1;
	    var suspicious_nodes = [];
	    var remove_edges = [];

	    m_graph.traverse(graph, function(id, node) {
	        var node_type = node.type;

	        switch (node_type) {
	        case "ADD_WORLD_RGB":
	        case "MIX_WORLD_RGB":
	            var susp_node = {
	                node_id: id,
	                node: node
	            };
	            suspicious_nodes.push(susp_node);
	            break;
	        case "OUTPUT_WORLD_SURFACE":
	            output_ws_id = id;
	            var susp_node = {
	                node_id: id,
	                node: node
	            };
	            suspicious_nodes.push(susp_node);
	            break;
	        }
	    });

	    for (var i = 0; i < suspicious_nodes.length; i++) {
	        var node_id = suspicious_nodes[i].node_id;
	        var node = suspicious_nodes[i].node;

	        var in_count = m_graph.in_edge_count(graph, node_id);
	        var edges_in_counter = {};
	        for (var j = 0; j < in_count; j++) {
	            var in_id = m_graph.get_in_edge(graph, node_id, j);
	            var in_node = m_graph.get_node_attr(graph, in_id);

	            if (!(in_id in edges_in_counter))
	                edges_in_counter[in_id] = 0;
	            var edge_attr = m_graph.get_edge_attr(graph, in_id,
	                    node_id, edges_in_counter[in_id]++);

	            if((node.type == "OUTPUT_WORLD_SURFACE" || edge_attr[1] != 0) &&
	                    in_node.type != "ADD_WORLD_RGB" && in_node.type != "MIX_WORLD_RGB" &&
	                    in_node.type != "BACKGROUND")
	                remove_edges.push([in_id, node_id, edge_attr]); // removing edges affects graph traversal
	        }
	    }

	    // TODO: replace def values for unlinked inputs with zeros
	    for (var i = 0; i < remove_edges.length; i++)
	        m_graph.remove_edge_by_attr(graph, remove_edges[i][0],
	                remove_edges[i][1], remove_edges[i][2]);

	    if (remove_edges.length) {
	        var world_graph = m_graph.subgraph_node_conn(graph, output_ws_id,
	                                                           m_graph.BACKWARD_DIR);
	        graph.nodes = world_graph.nodes;
	        graph.edges = world_graph.edges;
	    }
	}

	function generate_graph_id(graph_id, shader_type, scene_id, active_layer_names) {

	    graph_id = graph_id + scene_id;

	    switch (shader_type) {
	    case "GLOW":
	        // use color output, it is glow
	        graph_id += "11";
	    case "COLOR_ID":
	    case "SHADOW":
	        // don't use color output, it isn't glow
	        graph_id += "00";
	    default:
	        // use color output, it isn't glow
	        graph_id += "10";
	    }

	    if (active_layer_names && active_layer_names.vc_name)
	        graph_id += active_layer_names.vc_name;

	    if (active_layer_names && active_layer_names.uv_name)
	        graph_id += active_layer_names.uv_name;

	    return graph_id;
	}

	function remove_color_output(graph, output_id) {

	    m_graph.traverse_edges(graph, function(id1, id2, attr) {
	        var out_node = m_graph.get_node_attr(graph, id2);
	        if (id2 == output_id && out_node.inputs[attr[1]].identifier == "Color")
	            m_graph.remove_edge_by_attr(graph, id1, id2, attr);
	    });

	}

	function create_default_nmat_graph() {
	    var graph = m_graph.create();
	    var input_color = {
	        default_value: new Float32Array([0, 0, 0]),
	        identifier: "Color",
	        is_linked: false,
	        name: "Color"
	    };
	    var input_alpha = {
	        default_value: 1,
	        identifier: "Alpha",
	        is_linked: false,
	        name: "Alpha"
	    };
	    var node = {
	        data: null,
	        dirs: [],
	        params: [],
	        inputs: [input_color, input_alpha],
	        outputs: [],
	        type: "OUTPUT",
	        vparams: []
	    };
	    m_graph.append_node(graph, 0, node);
	    return graph;
	}

	function clone_nmat_graph(graph) {
	    return m_graph.clone(graph, clone_nmat_node, clone_nmat_edge_attr);
	}

	function clean_sockets_linked_property(graph) {
	    m_graph.traverse(graph, function(id, node) {
	        var inputs  = node.inputs;
	        var outputs = node.outputs;

	        for (var i = 0; i < inputs.length; i++)
	            fix_socket_property(graph, inputs[i], id, i, 1);

	        for (var i = 0; i < outputs.length; i++)
	            fix_socket_property(graph, outputs[i], id, i, 0);
	    });
	}

	function fix_socket_property(graph, connection, id, num, check_in_edge) {

	    if (connection.is_linked) {
	        var clear_linked = true;

	        m_graph.traverse_edges(graph, function(in_edge, out_edge, sockets) {
	            if ((!check_in_edge && in_edge == id && sockets[0] == num) ||
	                (check_in_edge && out_edge == id && sockets[1] == num))
	                clear_linked = false;
	        });

	        if (clear_linked)
	            connection.is_linked = false;
	    }
	}

	function fix_socket_types(graph, shader_type) {
	    var edge_data = [];
	    m_graph.traverse_edges(graph, function(in_edge, out_edge, sockets) {
	        var in_node = m_graph.get_node_attr(graph, in_edge);
	        var out_node = m_graph.get_node_attr(graph, out_edge);

	        var is_output_vec = m_util.is_vector(in_node.outputs[sockets[0]].default_value);
	        var is_input_vec = m_util.is_vector(out_node.inputs[sockets[1]].default_value);
	        if (is_output_vec != is_input_vec) {
	            var trans_node;
	            var vector = {
	                "default_value": [0, 0, 0],
	                "identifier": "Vector",
	                "is_linked": true,
	                "name": "Vector"
	            };

	            var value = {
	                "default_value": 0,
	                "identifier": "Value",
	                "is_linked": true,
	                "name": "Value"
	            };

	            if (is_output_vec && !is_input_vec)
	                trans_node = init_bpy_node("vector_to_scalar", "B4W_VECTOSCAL",
	                        [vector], [value]);
	            else if (!is_output_vec && is_input_vec)
	                trans_node = init_bpy_node("scalar_to_vector", "B4W_SCALTOVEC",
	                        [value], [vector]);

	            append_nmat_node(graph, trans_node, 0, shader_type, null);
	            edge_data.push([in_edge, out_edge, graph.nodes[graph.nodes.length - 2], sockets]);
	        }
	    });

	    for (var i = 0; i < edge_data.length; ++i) {
	        m_graph.remove_edge_by_attr(graph, edge_data[i][0], edge_data[i][1], edge_data[i][3]);
	        m_graph.append_edge(graph, edge_data[i][0], edge_data[i][2], [edge_data[i][3][0], 0]);
	        m_graph.append_edge(graph, edge_data[i][2], edge_data[i][1], [0, edge_data[i][3][1]]);
	    }
	}

	/**
	 * Adding special edges to graph
	 */
	function complete_edges(graph) {
	    var appended_edges = [];

	    m_graph.traverse(graph, function(id, attr) {
	        switch (attr.type) {
	        case "B4W_TRANSLUCENCY":
	            m_graph.traverse_edges(graph, function(edge_from, edge_to, edge_attr) {
	                var attr_to = m_graph.get_node_attr(graph, edge_to);
	                if (edge_from == id && attr_to.type == "MATERIAL_EXT") {
	                    var from_socket_index = edge_attr[0];
	                    if (attr.outputs[from_socket_index].name == "Translucency")
	                        appended_edges.push(edge_from, edge_to, [edge_attr[0] + 1,
	                                edge_attr[1] + 1]);
	                }
	            });
	            break;
	        }
	    });
	    for (var i = 0; i < appended_edges.length; i += 3)
	        m_graph.append_edge(graph, appended_edges[i], appended_edges[i + 1],
	                appended_edges[i + 2]);
	}

	function nmat_node_ids(bpy_node, graph) {

	    var node_ids = [];

	    m_graph.traverse(graph, function(id, attr) {
	        if (attr.name == bpy_node["name"])
	            node_ids.push(id);
	    });

	    if (node_ids.length)
	        return node_ids;
	    else
	        m_util.panic("Node not found");
	}

	function nmat_cleanup_graph(graph) {
	    var id_attr = [];
	    // collect
	    m_graph.traverse(graph, function(id, attr) {
	        if (attr.type == "B4W_PARALLAX" || attr.type == "REROUTE")
	            id_attr.push(id, attr);
	    });

	    for (var i = 0; i < id_attr.length; i+=2) {
	        var id = id_attr[i];
	        var attr = id_attr[i+1];
	        if (attr.type == "B4W_PARALLAX")
	            process_parallax_texture(graph, id, attr);

	        else if(attr.type == "REROUTE") {
	            var input_id = m_graph.get_in_edge(graph, id, 0);
	            var out_edge_count = m_graph.out_edge_count(graph, id);
	            var removed_edges  = [];
	            var output_ids     = [];
	            var edges_quantity = [];

	            for (var j = 0; j < out_edge_count; j++) {
	                var output_id = m_graph.get_out_edge(graph, id, j);
	                var id_place  = output_ids.indexOf(output_id);

	                // replace deff values
	                var edge_num = id_place >= 0 ? edges_quantity[id_place] : 0;
	                var rem_edge = m_graph.get_edge_attr(graph, id, output_id,
	                        edge_num);
	                if (rem_edge) {
	                    var out_soc_num = rem_edge[1];
	                    var def_value = attr.inputs[0].default_value;
	                    var out_node = m_graph.get_node_attr(graph, output_id);
	                    var input = out_node.inputs[out_soc_num];
	                    switch(typeof(def_value)) {
	                    case "number":
	                        if (typeof(input.default_value) == "object") {
	                            var vec = input.default_value;
	                            for (var k = 0; k < vec.length; k++)
	                                vec[k] = def_value;
	                        } else if (typeof(input.default_value) == "number")
	                            input.default_value = def_value;
	                        break;
	                    case "object":
	                        if (typeof(input.default_value) == "object") {
	                            var vec = input.default_value;
	                            for (var k = 0; k < vec.length; k++)
	                                vec[k] = def_value[k];
	                        } else if (typeof(input.default_value) == "number")
	                            input.default_value = 0.35 * def_value[0] + 0.45 * def_value[1]
	                                + 0.2 * def_value[2];
	                        break;
	                    }
	                }

	                var outputs = attr.outputs;
	                for (var k = 0; k < outputs.length; k++)
	                    outputs[k].default_value = attr.inputs[0].default_value;

	                if (id_place != -1)
	                    edges_quantity[id_place] += 1;
	                else {
	                    output_ids.push(output_id);
	                    edges_quantity.push(1);
	                    removed_edges.push(id, output_id);
	                }
	            }

	            if (input_id != -1) {
	                var from_index = m_graph.get_edge_attr(graph, input_id, id, 0)[0];

	                for (var j = 0; j < output_ids.length; j++) {
	                    for (var k = 0; k < edges_quantity[j]; k++) {
	                        var to_index = m_graph.get_edge_attr(graph, id, output_ids[j], k)[1];

	                        m_graph.append_edge(graph, input_id, output_ids[j], [from_index, to_index]);
	                    }
	                }
	            }

	            for (var j = 0; j < removed_edges.length; j +=2)
	                m_graph.remove_edge(graph, removed_edges[j], removed_edges[j+1], -1);
	        }
	    }
	}

	function process_parallax_texture(graph, id, attr) {
	    var input_id1 = get_in_edge_by_input_num(graph, id, 1);
	    if (input_id1 != -1) {

	        // steal texture from the input texture node
	        var input1_attr = m_graph.get_node_attr(graph, input_id1);
	        attr.data = input1_attr.data;

	        // remove edges
	        m_graph.remove_edge(graph, input_id1, id, -1);
	        if (m_graph.out_edge_count(graph, input_id1) == 0) {
	            var input_input_id = m_graph.get_in_edge(graph, input_id1, 0);
	            if (input_input_id != -1)
	                m_graph.remove_edge(graph, input_input_id, input_id1, -1);
	            m_graph.remove_node(graph, input_id1);
	        }
	    }
	    // remove HeightMap(color) input
	    attr.inputs.splice(1, 1);
	}

	function get_in_edge_by_input_num(graph, node, input_num) {
	    var edges = graph.edges;

	    for (var i = 0; i < edges.length; i+=3) {
	        if (edges[i+1] == node) {
	            var num = edges[i+2][1];
	            if (num == input_num)
	                return edges[i];
	        }
	    }
	    return -1;
	}

	function merge_nodes(graph) {
	    merge_geometry(graph);
	    merge_textures(graph);
	    merge_uvs(graph);
	    // merge_displacement_values_and_rgb(graph);
	}

	function merge_uvs(graph, shader_type) {

	    var uv_counter = {};
	    m_graph.traverse(graph, function(id, attr) {
	        if (attr.type == "GEOMETRY_UV" || attr.type == "UVMAP"
	                || attr.type == "TEX_COORD_UV") {
	            var uv_name = attr.data.value;
	            if (!(uv_name in uv_counter))
	                uv_counter[uv_name] = [];
	            uv_counter[uv_name].push(id, attr);
	        }
	    });

	    for (var uv_name in uv_counter) {
	        var id_attr = uv_counter[uv_name];

	        //NOTE: we don't need to merge single UVs
	        if (id_attr.length > 2) {
	            var bpy_node = create_uv_merged_bpy_node(uv_name);
	            var node_id = append_nmat_node(graph, bpy_node, 0, shader_type, null);
	            var node = m_graph.get_node_attr(graph, node_id);

	            for (var i = 0; i < id_attr.length; i+=2) {
	                var id = id_attr[i];
	                var attr = id_attr[i + 1];

	                var removed_edges = [];
	                
	                var edges_out_counter = {};
	                var out_num = m_graph.out_edge_count(graph, id);
	                for (var j = 0; j < out_num; j++) {
	                    var out_id = m_graph.get_out_edge(graph, id, j);

	                    if (!(out_id in edges_out_counter))
	                        edges_out_counter[out_id] = 0;

	                    var edge_attr = m_graph.get_edge_attr(graph, id, out_id,
	                            edges_out_counter[out_id]);
	                    edges_out_counter[out_id]++;

	                    removed_edges.push(id, out_id, edge_attr);

	                    var new_edge_attr = edge_attr.splice(0, edge_attr.length);
	                    switch (attr.type) {
	                        case "GEOMETRY_UV":
	                            new_edge_attr[0] = 0;
	                            node.outputs[0].is_linked = true;
	                            break;
	                        case "UVMAP":
	                        case "TEX_COORD_UV":
	                            new_edge_attr[0] = 1;
	                            node.outputs[1].is_linked = true;
	                            break;
	                    }
	                    m_graph.append_edge(graph, node_id, out_id, new_edge_attr);
	                }

	                for (var j = 0; j < removed_edges.length; j += 3)
	                    m_graph.remove_edge(graph, removed_edges[j],
	                            removed_edges[j + 1], 0);

	                m_graph.remove_node(graph, id);
	            }
	        }
	    }
	}

	function create_uv_merged_bpy_node(uv_name) {
	    var UV_geom = {
	        "default_value": [0, 0, 0],
	        "identifier": "UV_geom",
	        "is_linked": false,
	        "name": "UV_geom"
	    };
	    var UV_cycles = {
	        "default_value": [0, 0, 0],
	        "identifier": "UV_cycles",
	        "is_linked": false,
	        "name": "UV_cycles"
	    };

	    var node = init_bpy_node("merged_uv", "UV_MERGED", [], [UV_geom, UV_cycles]);
	    node["uv_layer"] = uv_name;

	    return node;
	}

	function merge_geometry(graph) {

	    var id_attr = [];
	    m_graph.traverse(graph, function(id, attr) {
	        if (attr.type == "GEOMETRY_VC" || attr.type == "GEOMETRY_NO"
	                || attr.type == "GEOMETRY_FB" || attr.type == "GEOMETRY_VW"
	                || attr.type == "GEOMETRY_GL" || attr.type == "GEOMETRY_LO"
	                || attr.type == "GEOMETRY_OR" || attr.type == "GEOMETRY_BF"
	                || attr.type == "GEOMETRY_IN")
	            id_attr.push(id, attr);
	    });

	    var unique_nodes = [];

	    for (var i = 0; i < id_attr.length; i+=2) {
	        var id_current = id_attr[i];
	        var attr_current = id_attr[i+1];

	        var is_unique = true;

	        for (var j = 0; j < unique_nodes.length; j++) {
	            var unode = unique_nodes[j];

	            // check nodes coincidence
	            if (can_merge_nodes(attr_current, unode.attr)) {

	                var removed_edges = [];
	                var out_num = m_graph.out_edge_count(graph, id_current);

	                // process every outgoing edge
	                for (var k = 0; k < out_num; k++) {
	                    var out_id = m_graph.get_out_edge(graph, id_current, k);
	                    var edge_attr = m_graph.get_edge_attr(graph, id_current, out_id, 0);

	                    // removing edges affects graph traversal
	                    removed_edges.push(id_current, out_id, edge_attr);

	                    m_graph.append_edge(graph, unode.id, out_id, edge_attr);
	                }

	                for (var k = 0; k < removed_edges.length; k += 3)
	                    m_graph.remove_edge(graph, removed_edges[k],
	                            removed_edges[k + 1], 0);

	                m_graph.remove_node(graph, id_current);

	                is_unique = false;
	                break;
	            }
	        }

	        if (is_unique) {
	            var unode = {
	                id: id_current,
	                attr: attr_current
	            };
	            unique_nodes.push(unode);
	        }
	    }
	}

	function get_nodes_ascendants(graph) {
	    var nodes_ascendants = {};

	    for (var i = 0; i < graph.nodes.length; i += 2) {
	        var id = graph.nodes[i];
	        nodes_ascendants[id] = { ascs_ids: {}, is_completed: false };
	    }

	    // collect nearest parent for each node
	    for (var i = 0; i < graph.edges.length; i += 3) {
	        var id_from = graph.edges[i];
	        var id_to = graph.edges[i + 1];
	        nodes_ascendants[id_to].ascs_ids[id_from] = true;
	    }

	    // collect all the ascendants
	    for (var id in nodes_ascendants)
	        collect_node_ascs(id, nodes_ascendants);

	    for (var id in nodes_ascendants)
	        nodes_ascendants[id] = Object.keys(nodes_ascendants[id].ascs_ids).map(function(str){return parseInt(str, 10)});

	    return nodes_ascendants;
	}

	function collect_node_ascs(node_id, nodes_ascendants) {
	    var node = nodes_ascendants[node_id];

	    if (!node.is_completed) {
	        var node_clone = m_util.clone_object_r(node);
	        
	        for (var asc_id in node.ascs_ids) {
	            collect_node_ascs(asc_id, nodes_ascendants);
	            var asc_node = nodes_ascendants[asc_id];
	            for (var asc_asc_id in asc_node.ascs_ids)
	                node_clone.ascs_ids[asc_asc_id] = true;
	        }

	        node_clone.is_completed = true;
	        nodes_ascendants[node_id] = node_clone;
	    }
	}

	function merge_textures(graph) {

	    var id_attr = [];
	    m_graph.traverse(graph, function(id, attr) {
	        if (attr.type == "TEXTURE_COLOR" || attr.type == "TEXTURE_NORMAL")
	            id_attr.push(id, attr);
	    });

	    if (!id_attr.length)
	        return;

	    var ascs = get_nodes_ascendants(graph);

	    var unique_nodes = [];

	    for (var i = 0; i < id_attr.length; i+=2) {
	        var id_current = id_attr[i];
	        var attr_current = id_attr[i+1];

	        var is_unique = true;

	        for (var j = 0; j < unique_nodes.length; j++) {
	            var unode = unique_nodes[j];

	            // NOTE: every 4 texture nodes merged: first found (main) and others
	            if (unode.merged_nodes.length >= 3)
	                continue;

	            // check nodes coincidence
	            if (!can_merge_nodes(attr_current, unode.attr))
	                continue;

	            // merged nodes can't be reachable from the each other in a directed graph
	            if (ascs[id_current].indexOf(unode.id) > -1 ||
	                    ascs[unode.id].indexOf(id_current) > -1)
	                continue;
	            var is_reachable = false;
	            for (var k = 0; k < unode.merged_nodes.length; k++) {
	                var merged_id = unode.merged_nodes[k].id;
	                if (ascs[id_current].indexOf(merged_id) > -1 ||
	                    ascs[merged_id].indexOf(id_current) > -1) {
	                    is_reachable = true;
	                    break;
	                }
	            }
	            if (is_reachable)
	                continue;

	            var removed_edges_in = [];
	            var in_num = m_graph.in_edge_count(graph, id_current);

	            // process every ingoing edge
	            var edges_in_counter = {};
	            for (k = 0; k < in_num; k++) {
	                var in_id = m_graph.get_in_edge(graph, id_current, k);

	                if (!(in_id in edges_in_counter))
	                    edges_in_counter[in_id] = 0;
	                var edge_attr = m_graph.get_edge_attr(graph, in_id,
	                        id_current, edges_in_counter[in_id]++);

	                // removing edges affects graph traversal; save edge_attr
	                // for further merging
	                removed_edges_in.push(in_id, id_current, edge_attr);
	            }

	            var removed_edges_out = [];
	            var out_num = m_graph.out_edge_count(graph, id_current);

	            // process every outgoing edge
	            var edges_out_counter = {};
	            for (k = 0; k < out_num; k++) {
	                var out_id = m_graph.get_out_edge(graph, id_current, k);

	                if (!(out_id in edges_out_counter))
	                    edges_out_counter[out_id] = 0;
	                var edge_attr = m_graph.get_edge_attr(graph, id_current,
	                        out_id, edges_out_counter[out_id]++);

	                // removing edges affects graph traversal; save edge_attr
	                // for further merging
	                removed_edges_out.push(id_current, out_id, edge_attr);
	            }

	            var removed_edges = removed_edges_in.concat(removed_edges_out);
	            for (var k = 0; k < removed_edges.length; k += 3)
	                m_graph.remove_edge(graph, removed_edges[k],
	                        removed_edges[k + 1], 0);
	            m_graph.remove_node(graph, id_current);

	            var mnode = {
	                id: id_current,
	                attr: attr_current,
	                edges_in: removed_edges_in,
	                edges_out: removed_edges_out
	            };
	            unode.merged_nodes.push(mnode);

	            is_unique = false;
	            break;
	        }

	        if (is_unique) {
	            var unode = {
	                id: id_current,
	                attr: attr_current,
	                merged_nodes: []
	            };
	            unique_nodes.push(unode);
	        }
	    }

	    // NOTE: merge texture nodes data
	    for (var i = 0; i < unique_nodes.length; i++) {
	        var unode = unique_nodes[i];

	        var mnodes_count = unode.merged_nodes.length;

	        // NOTE: merge similar nodes and unique node
	        for (var j = 0; j < mnodes_count; j++) {
	            var merged_data = unode.merged_nodes[j];
	            var mnode = merged_data.attr;
	            var edges_in = merged_data.edges_in;
	            var edges_out = merged_data.edges_out;

	            unode.attr.inputs[j + 1].is_linked = mnode.inputs[0].is_linked;
	            unode.attr.inputs[j + 1].default_value = mnode.inputs[0].default_value;
	            unode.attr.outputs[2 * (j + 1)].is_linked = mnode.outputs[0].is_linked;
	            unode.attr.outputs[2 * (j + 1)].default_value = mnode.outputs[0].default_value;
	            unode.attr.outputs[2 * (j + 1) + 1].is_linked = mnode.outputs[1].is_linked;
	            unode.attr.outputs[2 * (j + 1) + 1].default_value = mnode.outputs[1].default_value;

	            // NOTE: change edge attributes indices for similar links
	            for (var k = 0; k < edges_in.length; k += 3) {
	                var in_id = edges_in[k];
	                var edge_attr = edges_in[k + 2];
	                edge_attr[1] += (j + 1);
	                m_graph.append_edge(graph, in_id, unode.id, edge_attr);
	            }

	            for (var k = 0; k < edges_out.length; k += 3) {
	                var out_id = edges_out[k + 1];
	                var edge_attr = edges_out[k + 2];
	                edge_attr[0] += (j + 1) * 2;
	                m_graph.append_edge(graph, unode.id, out_id, edge_attr);
	            }

	            unode.attr.dirs.push(["USE_uv" + (j + 2), 1]);
	        }

	        m_graph.remove_node(graph, unode.id);
	        m_graph.append_node(graph, unode.id, unode.attr);
	    }
	}

	function can_merge_nodes(attr1, attr2) {
	    if (attr1.type !== attr2.type)
	        return false;

	    switch (attr1.type) {
	    case "GEOMETRY_VC":
	        return attr1.data.value == attr2.data.value;
	    case "GEOMETRY_NO":
	        return check_dir_value_identity(attr1, attr2, "USE_NORMAL_IN");
	    case "GEOMETRY_FB":
	    case "GEOMETRY_VW":
	    case "GEOMETRY_GL":
	    case "GEOMETRY_LO":
	    case "GEOMETRY_OR":
	    case "GEOMETRY_BF":
	    case "GEOMETRY_IN":
	        return true;
	    case "TEXTURE_COLOR":
	    case "TEXTURE_NORMAL":
	        return attr1.data.bpy_uuid == attr2.data.bpy_uuid &&
	               // NOTE: Cycles textures are merged depending on images uuid
	               attr1.data.value.img_uuid == attr2.data.value.img_uuid;
	    case "VALUE":
	    case "RGB":
	        return attr1.origin_name == attr2.origin_name; 
	    default:
	        return false;
	    }
	}

	function check_dir_value_identity(node1, node2, dir_name) {
	    var dirs1 = node1.dirs;
	    var dir1_value = -1;
	    for (var i = 0; i < dirs1.length; i++) {
	        var dir1 = dirs1[i];
	        if (dir1[0] == dir_name) {
	            dir1_value = dir1[1];
	            break;
	        }
	    }

	    var dirs2 = node2.dirs;
	    var dir2_value = -1;
	    for (var i = 0; i < dirs2.length; i++) {
	        var dir2 = dirs2[i];
	        if (dir2[0] == dir_name) {
	            dir2_value = dir2[1];
	            break;
	        }
	    }

	    return dir1_value === dir2_value;
	}

	// NOTE: unused
	function optimize_geometry(graph) {
	    var id_attr_vc = [];
	    var id_attr_vw = [];

	    m_graph.traverse(graph, function(id, attr) {
	        if (attr.type == "GEOMETRY_VC")
	            id_attr_vc.push(id, attr);
	        if (attr.type == "GEOMETRY_VW")
	            id_attr_vw.push(id, attr);
	    });

	    optimize_geometry_vcol(graph, id_attr_vc);
	    optimize_geometry_view(graph, id_attr_vw);
	}

	function optimize_geometry_vcol(graph, id_attr_vc) {
	    for (var i = 0; i < id_attr_vc.length; i+=2) {
	        var geom_id = id_attr_vc[i];
	        var geom_attr = id_attr_vc[i+1];

	        var need_optimize = false;
	        var removed_edges = [];
	        var removed_seprgb_nodes = [];
	        var channels_usage = [[], [], []];

	        var geometry_out_num = m_graph.out_edge_count(graph, geom_id);
	        for (var j = 0; j < geometry_out_num; j++) {
	            var out_id = m_graph.get_out_edge(graph, geom_id, j);
	            var out_node = m_graph.get_node_attr(graph, out_id);

	            // optimize if it has only SEPRGB nodes as outputs
	            if (out_node.type != "SEPRGB") {
	                need_optimize = false;
	                break;
	            }

	            removed_edges.push(geom_id, out_id);

	            var edges_out_num = {};
	            var seprgb_out_num = m_graph.out_edge_count(graph, out_id);
	            for (var k = 0; k < seprgb_out_num; k++) {

	                var seprgb_out_id = m_graph.get_out_edge(graph, out_id, k);
	                if (!(seprgb_out_id in edges_out_num))
	                    edges_out_num[seprgb_out_id] = 0;

	                var edge_attr = m_graph.get_edge_attr(graph, out_id,
	                        seprgb_out_id, edges_out_num[seprgb_out_id]++);

	                removed_edges.push(out_id, seprgb_out_id);
	                channels_usage[edge_attr[0]].push(geom_id, seprgb_out_id, edge_attr);

	            }

	            removed_seprgb_nodes.push(out_id);
	            need_optimize = true;
	        }

	        if (need_optimize) {
	            var channels_count = 0;
	            var mask = 0;
	            for (var j = 0; j < channels_usage.length; j++)
	                if (channels_usage[j].length) {
	                    channels_count++;
	                    mask |= 1 << (2 - j);
	                }

	            if (channels_count) {
	                // change GEOMETRY_VC outputs and type
	                geom_attr.type += channels_count;

	                geom_attr.outputs = [];
	                for (var j = 0; j < channels_usage.length; j++) {
	                    if (channels_usage[j].length) {
	                        geom_attr.outputs.push({
	                            default_value: 0,
	                            identifier: "RGB"[j],
	                            is_linked: true,
	                            name: "RGB"[j]
	                        });
	                        for (var k = 0; k < channels_usage[j].length; k += 3)
	                            channels_usage[j][k + 2][0]
	                                    = m_util.rgb_mask_get_channel_presence_index(
	                                    mask, j);
	                    }
	                }

	                // remove unused edges
	                for (var j = 0; j < removed_edges.length; j += 2)
	                    m_graph.remove_edge(graph, removed_edges[j],
	                            removed_edges[j + 1], 0);

	                // remove SEPRGB nodes
	                for (var j = 0; j < removed_seprgb_nodes.length; j++)
	                    m_graph.remove_node(graph, removed_seprgb_nodes[j]);

	                // add new edges
	                for (var j = 0; j < channels_usage.length; j++)
	                    for (var k = 0; k < channels_usage[j].length; k += 3)
	                        m_graph.append_edge(graph, channels_usage[j][k],
	                                channels_usage[j][k + 1], channels_usage[j][k + 2]);
	            }
	        }

	    }
	}

	function optimize_geometry_view(graph, id_attr_vw) {
	    for (var i = 0; i < id_attr_vw.length; i+=2) {
	        var geom_id = id_attr_vw[i];

	        var need_remove_geom_vw = true;
	        var optimized_node_pairs = [];

	        var geometry_out_num = m_graph.out_edge_count(graph, geom_id);
	        for (var j = 0; j < geometry_out_num; j++) {
	            var out_id = m_graph.get_out_edge(graph, geom_id, j);
	            var out_node = m_graph.get_node_attr(graph, out_id);

	            // delete GEOMETRY_VW if it has only B4W_REFLECT nodes as outputs
	            if (out_node.type == "B4W_REFLECT") {
	                // maximum two edges between GEOMETRY_VC and B4W_REFLECT
	                var edge_attr1 = m_graph.get_edge_attr(graph, geom_id, out_id, 0);
	                var edge_attr2 = m_graph.get_edge_attr(graph, geom_id, out_id, 1);

	                // optimize if GEOMETRY_VC used only in the first B4W_REFLECT input
	                if (edge_attr1 && edge_attr1[1] == 1 || edge_attr2 && edge_attr2[1] == 1)
	                    need_remove_geom_vw = false;
	                else
	                    optimized_node_pairs.push(geom_id, out_id);
	            } else
	                need_remove_geom_vw = false;
	        }

	        // optimize B4W_REFLECT nodes
	        for (var j = 0; j < optimized_node_pairs.length; j += 2)
	            optimize_reflect_node(graph, optimized_node_pairs[j], optimized_node_pairs[j+1]);

	        // remove GEOMETRY_VW node
	        if (need_remove_geom_vw)
	            m_graph.remove_node(graph, geom_id);
	    }
	}

	function optimize_reflect_node(graph, geom_id, refl_id) {
	    var refl_node = m_graph.get_node_attr(graph, refl_id);
	    refl_node.type += "_WORLD";

	    // remove unused edge
	    m_graph.remove_edge(graph, geom_id, refl_id, 0);

	    // remove unused node input and correct the second edge
	    refl_node.inputs.splice(0, 1);
	    var in_id = m_graph.get_in_edge(graph, refl_id, 0);
	    if (in_id != m_graph.NULL_NODE) {
	        var edge_attr = m_graph.get_edge_attr(graph, in_id, refl_id, 0);
	        edge_attr[1] = 0;
	    }
	}

	function find_node_id(node_tree, graph, type, source_type, is_group_node,
	        suppress_errors) {
	    var bpy_nodes = node_tree["nodes"];

	    // find last OUTPUT
	    var last_output_node = null;

	    // search in original bpy_nodes
	    for (var i = 0; i < bpy_nodes.length; i++) {
	        var bpy_node = bpy_nodes[i];

	        if (is_group_node) {
	            if (bpy_node["type"] == "GROUP" && bpy_node["node_tree_name"] == type)
	                last_output_node = bpy_node;
	        } else {
	            if (bpy_node["type"] == type)
	                last_output_node = bpy_node;
	        }
	    }

	    if (!last_output_node) {
	        if (!suppress_errors)
	            m_print.error("No \"" + type + "\" node in node " + source_type);
	        return -1;
	    }

	    // seems always unique
	    return nmat_node_ids(last_output_node, graph)[0];
	}

	function init_bpy_node(name, type, inputs, outputs) {
	    var node = {
	        "name": name,
	        "type": type,
	        "inputs": inputs,
	        "outputs": outputs
	    };
	    return node;
	}

	function init_bpy_link(from_node, from_socket, to_node, to_socket) {
	    var link = {
	        "from_node": from_node,
	        "from_socket": from_socket,
	        "to_node": to_node,
	        "to_socket": to_socket
	    };
	    return link;
	}

	function create_nmat_node() {
	    var nmat_node = {
	        name: "",
	        origin_name: "",
	        type: "",

	        vparams: [],

	        inputs: [],
	        outputs: [],
	        params: [],

	        data: null,

	        dirs: []
	    };
	    return nmat_node;
	}

	function clone_nmat_node(nmat_node) {
	    var new_nmat_node = create_nmat_node();

	    new_nmat_node.name = nmat_node.name;
	    new_nmat_node.origin_name = nmat_node.origin_name;
	    new_nmat_node.type = nmat_node.type;

	    var new_vparams = new_nmat_node.vparams;
	    var vparams = nmat_node.vparams;
	    for (var i = 0; i < vparams.length; i++) {
	        var vparam = vparams[i];
	        new_vparams.push(clone_node_param(vparam));
	    }
	    var new_params = new_nmat_node.params;
	    var params = nmat_node.params;
	    for (var i = 0; i < params.length; i++) {
	        var param = params[i];
	        new_params.push(clone_node_param(param));
	    }

	    var new_inputs = new_nmat_node.inputs;
	    var inputs = nmat_node.inputs;
	    for (var i = 0; i < inputs.length; i++) {
	        var input = inputs[i];
	        new_inputs.push(clone_node_inout(input));
	    }
	    var new_outputs = new_nmat_node.outputs;
	    var outputs = nmat_node.outputs;
	    for (var i = 0; i < outputs.length; i++) {
	        var output = outputs[i];
	        new_outputs.push(clone_node_inout(output));
	    }

	    var new_dirs = new_nmat_node.dirs;
	    var dirs = nmat_node.dirs;
	    for (var i = 0; i < dirs.length; i++) {
	        var dir = dirs[i];
	        new_dirs.push(dir.slice());
	    }

	    new_nmat_node.data = nmat_node.data;

	    return new_nmat_node;
	}

	function append_nmat_node(graph, bpy_node, output_num, shader_type, 
	        active_layer_names) {
	    var name = bpy_node["name"];
	    var origin_name = bpy_node["name"];
	    var type = bpy_node["type"];
	    var vparams = [];
	    var inputs = [];
	    var outputs = [];
	    var params = [];

	    var data = null;

	    var bpy_node_uv_layer_name = "uv_layer" in bpy_node ? bpy_node["uv_layer"] 
	            || active_layer_names && active_layer_names.uv_name || "" : "";
	    var bpy_node_vc_layer_name = "color_layer" in bpy_node ? bpy_node["color_layer"] 
	            || active_layer_names && active_layer_names.vc_name || "" : "";

	    var dirs = [];
	    switch (type) {
	    case "BSDF_ANISOTROPIC":
	    case "BSDF_GLASS":
	    case "BSDF_HAIR":
	    case "BSDF_TRANSLUCENT":
	    case "BSDF_REFRACTION":
	    case "BSDF_TOON":
	    case "BSDF_VELVET":
	    case "SUBSURFACE_SCATTERING":
	    case "AMBIENT_OCCLUSION":
	    case "VOLUME_ABSORPTION":
	    case "VOLUME_SCATTER":
	    case "BLACKBODY":
	    case "WAVELENGTH":
	    case "SEPXYZ":
	    case "COMBXYZ":
	    case "LIGHT_FALLOFF":
	    case "TEX_SKY":
	    case "TEX_NOISE":
	    case "TEX_WAVE":
	    case "TEX_MUSGRAVE":
	    case "TEX_GRADIENT":
	    case "TEX_MAGIC":
	    case "TEX_CHECKER":
	    case "TEX_BRICK":
	    case "WIREFRAME":
	    case "TANGENT":
	    case "LIGHT_PATH":
	    case "ATTRIBUTE":
	    case "HOLDOUT":
	    case "HAIR_INFO":
	    case "SCRIPT":
	        inputs = node_inputs_bpy_to_b4w(bpy_node);
	        outputs = node_outputs_bpy_to_b4w(bpy_node);
	        m_print.warn(type + " node is not fully supported.");
	        break;
	    case "BRIGHTCONTRAST":
	    case "ADD_SHADER":
	        inputs = node_inputs_bpy_to_b4w(bpy_node);
	        outputs = node_outputs_bpy_to_b4w(bpy_node);
	        break;
	    case "MIX_SHADER":
	        inputs.push(node_input_by_ident(bpy_node, "Fac"));
	        var shader_input = node_input_by_ident(bpy_node, "Shader");
	        var shader_input_is_linked = shader_input.is_linked;
	        inputs.push(shader_input);
	        var shader1_input = node_input_by_ident(bpy_node, "Shader_001");
	        // backward compatibility with old blend files
	        if (!shader1_input)
	            shader1_input = node_input_by_ident(bpy_node, "Shader.001");
	        var shader1_input_is_linked = shader1_input.is_linked;
	        inputs.push(shader1_input);

	        inputs.push(default_node_inout("d_color1", "d_color1", [0, 0, 0], shader_input_is_linked));
	        inputs.push(default_node_inout("d_roughness1", "d_roughness1", 0, shader_input_is_linked));
	        inputs.push(default_node_inout("s_color1", "s_color1", [0, 0, 0], shader_input_is_linked));
	        inputs.push(default_node_inout("s_roughness1", "s_roughness1", 0, shader_input_is_linked));
	        inputs.push(default_node_inout("metalness1", "metalness1", 0, shader_input_is_linked));
	        inputs.push(default_node_inout("normal1", "normal1", [0, 0, 0], shader_input_is_linked));
	        inputs.push(default_node_inout("e_color1", "e_color1", [0, 0, 0], shader_input_is_linked));
	        inputs.push(default_node_inout("emission1", "emission1", 0, shader_input_is_linked));
	        inputs.push(default_node_inout("a_color1", "a_color1", [0, 0, 0], shader_input_is_linked));
	        inputs.push(default_node_inout("alpha1", "alpha1", 1, shader_input_is_linked));

	        inputs.push(default_node_inout("d_color2", "d_color2", [0, 0, 0], shader1_input_is_linked));
	        inputs.push(default_node_inout("d_roughness2", "d_roughness2", 0, shader1_input_is_linked));
	        inputs.push(default_node_inout("s_color2", "s_color2", [0, 0, 0], shader1_input_is_linked));
	        inputs.push(default_node_inout("s_roughness2", "s_roughness2", 0, shader1_input_is_linked));
	        inputs.push(default_node_inout("metalness2", "metalness2", 0, shader1_input_is_linked));
	        inputs.push(default_node_inout("normal2", "normal2", [0, 0, 0], shader1_input_is_linked));
	        inputs.push(default_node_inout("e_color2", "e_color2", [0, 0, 0], shader1_input_is_linked));
	        inputs.push(default_node_inout("emission2", "emission2", 0, shader1_input_is_linked));
	        inputs.push(default_node_inout("a_color2", "a_color2", [0, 0, 0], shader1_input_is_linked));
	        inputs.push(default_node_inout("alpha2", "alpha2", 1, shader1_input_is_linked));

	        var shader_output = node_output_by_ident(bpy_node, "Shader");
	        var shader_output_is_linked = shader_output.is_linked;
	        outputs = [shader_output,
	                   default_node_inout("d_color", "d_color", [0, 0, 0], shader_output_is_linked),
	                   default_node_inout("d_roughness", "d_roughness", 0, shader_output_is_linked),
	                   default_node_inout("s_color", "s_color", [0, 0, 0], shader_output_is_linked),
	                   default_node_inout("s_roughness", "s_roughness", 0, shader_output_is_linked),
	                   default_node_inout("metalness", "metalness", 0, shader_output_is_linked),
	                   default_node_inout("normal", "normal", [0, 0, 0], shader_output_is_linked),
	                   default_node_inout("e_color", "e_color", [0, 0, 0], shader_output_is_linked),
	                   default_node_inout("emission", "emission", 0, shader_output_is_linked),
	                   default_node_inout("a_color", "a_color", [0, 0, 0], shader_output_is_linked),
	                   default_node_inout("alpha", "alpha", 1, shader_output_is_linked)];
	        break;
	    case "OBJECT_INFO":
	        inputs = node_inputs_bpy_to_b4w(bpy_node);
	        outputs = [];
	        var output_location = node_output_by_ident(bpy_node, "Location");
	        var output_obj_ind = node_output_by_ident(bpy_node, "Object Index");
	        var output_mat_ind = node_output_by_ident(bpy_node, "Material Index");
	        var output_random = node_output_by_ident(bpy_node, "Random");
	        outputs.push(output_location);
	        outputs.push(output_obj_ind);
	        outputs.push(output_mat_ind);
	        outputs.push(output_random);
	        dirs.push(["USE_LOCATION_OUT", output_location.is_linked | 0]);
	        dirs.push(["USE_OBJ_IND_OUT", output_obj_ind.is_linked | 0]);
	        dirs.push(["USE_MAT_IND_OUT", output_mat_ind.is_linked | 0]);
	        dirs.push(["USE_RANDOM_OUT", output_random.is_linked | 0]);
	        break;
	    case "UVMAP":
	        if (!bpy_node_uv_layer_name)
	            type = "EMPTY_UV";

	        if (type != "EMPTY_UV") {
	            var uv_name = shader_ident("param_" + type + "_a");
	            var uv_tra_name = shader_ident("param_" + type + "_v");

	            vparams.push(node_param(uv_name));
	            vparams.push(node_param(uv_tra_name));

	            params.push(node_param(uv_tra_name));

	            data = {
	                name: uv_name,
	                value: bpy_node_uv_layer_name
	            };
	        }
	        outputs = node_outputs_bpy_to_b4w(bpy_node);
	        break;
	    case "UV_MERGED":
	        var uv_name = shader_ident("param_UV_MERGED_a");
	        var uv_tra_name = shader_ident("param_UV_MERGED_v");

	        vparams.push(node_param(uv_name));
	        vparams.push(node_param(uv_tra_name));

	        outputs.push(node_output_by_ident(bpy_node, "UV_geom"));
	        outputs.push(node_output_by_ident(bpy_node, "UV_cycles"));
	        params.push(node_param(uv_tra_name));

	        data = {
	            name: uv_name,
	            value: bpy_node_uv_layer_name
	        };
	        break;
	    case "CAMERA":
	        inputs = [];
	        outputs = node_outputs_bpy_to_b4w(bpy_node);
	        break;
	    case "COMBRGB":
	    case "COMBHSV":
	        inputs = node_inputs_bpy_to_b4w(bpy_node);
	        outputs = node_outputs_bpy_to_b4w(bpy_node);
	        break;
	    case "CURVE_RGB":
	    case "CURVE_VEC":
	        if (type == "CURVE_RGB") {
	            if (check_curve_usage(bpy_node, 0, 0.0, 1.0))
	                dirs.push(["READ_R", 1]);
	            if (check_curve_usage(bpy_node, 1, 0.0, 1.0))
	                dirs.push(["READ_G", 1]);
	            if (check_curve_usage(bpy_node, 2, 0.0, 1.0))
	                dirs.push(["READ_B", 1]);
	            if (check_curve_usage(bpy_node, 3, 0.0, 1.0))
	                dirs.push(["READ_A", 1]);
	        } else {
	            if (check_curve_usage(bpy_node, 0, -1.0, 1.0))
	                dirs.push(["READ_R", 1]);
	            if (check_curve_usage(bpy_node, 1, -1.0, 1.0))
	                dirs.push(["READ_G", 1]);
	            if (check_curve_usage(bpy_node, 2, -1.0, 1.0))
	                dirs.push(["READ_B", 1]);
	        }
	        inputs = node_inputs_bpy_to_b4w(bpy_node);
	        outputs = node_outputs_bpy_to_b4w(bpy_node);
	        data = {
	            value: bpy_node
	        };
	        break;
	    case "PARTICLE_INFO":
	        inputs = node_inputs_bpy_to_b4w(bpy_node);
	        outputs = node_outputs_bpy_to_b4w(bpy_node);
	        for (var k = 0; k < bpy_node["outputs"].length; k++) {
	            var output = bpy_node["outputs"][k];
	            var identifier = output["identifier"];
	            var v_name = node_param("v_param_PART_INFO_" + identifier.replace(" ", ""));
	            if (output["is_linked"]) {
	                switch(identifier) {
	                case "Size":
	                    dirs.push(["PART_INFO_SIZE", m_shaders.glsl_value(1)]);
	                    break;
	                case "Age":
	                    dirs.push(["PART_INFO_AGE", m_shaders.glsl_value(1)]);
	                    break;
	                case "Lifetime":
	                    dirs.push(["PART_INFO_LT", m_shaders.glsl_value(1)]);
	                    break;
	                case "Location":
	                    dirs.push(["PART_INFO_LOC", m_shaders.glsl_value(1)]);
	                    break;
	                case "Index":
	                    var a_name = node_param("a_param_PART_INFO_" + output.identifier.replace(" ", ""));
	                    data = a_name;
	                    dirs.push(["PART_INFO_IND", m_shaders.glsl_value(1)]);
	                    break;
	                case "Velocity":
	                    dirs.push(["PART_INFO_VEL", m_shaders.glsl_value(1)]);
	                    break;
	                case "Angular Velocity":
	                    dirs.push(["PART_INFO_A_VEL", m_shaders.glsl_value(1)]);
	                    break;
	                }
	            }
	            if (identifier != "Age" && identifier != "Lifetime" && identifier != "Size") {
	                vparams.push(v_name);
	                params.push(v_name);
	            }
	        }
	        if (a_name)
	            vparams.push(a_name);
	        break;
	    case "NEW_GEOMETRY":
	    case "GEOMETRY":

	        if (!check_input_node_outputs(bpy_node))
	            return true;

	        type = geometry_node_type(bpy_node, output_num);
	        if (!type) {
	            m_print.error("Geometry output is not supported");
	            return null;
	        }

	        switch (type) {
	        case "GEOMETRY_UV":
	            if (!bpy_node_uv_layer_name)
	                type = "EMPTY_UV";

	            if (type != "EMPTY_UV") {
	                var uv_name = shader_ident("param_GEOMETRY_UV_a");
	                var uv_tra_name = shader_ident("param_GEOMETRY_UV_v");

	                vparams.push(node_param(uv_name));
	                vparams.push(node_param(uv_tra_name));

	                params.push(node_param(uv_tra_name));

	                data = {
	                    name: uv_name,
	                    value: bpy_node_uv_layer_name
	                };
	            }
	            outputs.push(node_output_by_ident(bpy_node, "UV"));
	            break;
	        case "GEOMETRY_VC":
	            if (!bpy_node_vc_layer_name)
	                type = "EMPTY_VC";

	            if (type != "EMPTY_VC") {
	                var vc_name = shader_ident("param_GEOMETRY_VC_a");
	                var vc_tra_name = shader_ident("param_GEOMETRY_VC_v");

	                vparams.push(node_param(vc_name));
	                vparams.push(node_param(vc_tra_name));

	                params.push(node_param(vc_tra_name));

	                data = {
	                    name: vc_name,
	                    value: bpy_node_vc_layer_name
	                };
	            }
	            outputs.push(node_output_by_ident(bpy_node, "Vertex Color"));
	            break;
	        case "GEOMETRY_NO":
	            // fake input, used only with displacement_bump
	            inputs.push(default_node_inout("Normal", "Normal", [0, 0, 0], false));
	            dirs.push(["USE_NORMAL_IN", 0]);
	            outputs.push(node_output_by_ident(bpy_node, "Normal"));
	            break;
	        case "GEOMETRY_TRN":
	            type = "GEOMETRY_NO";
	            // fake input, used only with displacement_bump
	            inputs.push(default_node_inout("Normal", "Normal", [0, 0, 0], false));
	            outputs.push(node_output_by_ident(bpy_node, "True Normal"));
	            dirs.push(["USE_NORMAL_IN", 0]);
	            m_print.warn("Geometry True Normal output is not fully supported.");
	            break;
	        case "GEOMETRY_FB":
	            outputs.push(node_output_by_ident(bpy_node, "Front/Back"));
	            break;
	        case "GEOMETRY_VW":
	            outputs.push(node_output_by_ident(bpy_node, "View"));
	            break;
	        case "GEOMETRY_GL":
	            outputs.push(node_output_by_ident(bpy_node, "Global") ||
	                         node_output_by_ident(bpy_node, "Position"));
	            break;
	        case "GEOMETRY_LO":
	            outputs.push(node_output_by_ident(bpy_node, "Local"));
	            break;
	        case "GEOMETRY_OR":
	            var or_tra_name = shader_ident("param_GEOMETRY_OR_v");
	            vparams.push(node_param(or_tra_name));

	            outputs.push(node_output_by_ident(bpy_node, "Orco"));
	            params.push(node_param(or_tra_name));
	            break;
	        case "GEOMETRY_IN":
	            outputs.push(node_output_by_ident(bpy_node, "Incoming"));
	            break;
	        case "GEOMETRY_BF":
	            outputs.push(node_output_by_ident(bpy_node, "Backfacing"));
	            break;
	        }
	        break;
	    case "TEX_COORD":

	        if (!check_input_node_outputs(bpy_node))
	            return true;

	        type = tex_coord_node_type(bpy_node, output_num);

	        switch (type) {
	        case "TEX_COORD_UV":
	            if (!bpy_node_uv_layer_name)
	                type = "EMPTY_UV";

	            if (type != "EMPTY_UV") {
	                var uv_name = shader_ident("param_TEX_COORD_UV_a");
	                var uv_tra_name = shader_ident("param_TEX_COORD_UV_v");

	                vparams.push(node_param(uv_name));
	                vparams.push(node_param(uv_tra_name));

	                params.push(node_param(uv_tra_name));

	                data = {
	                    name: uv_name,
	                    value: bpy_node_uv_layer_name
	                };
	            }
	            outputs.push(node_output_by_ident(bpy_node, "UV"));
	            break;
	        case "TEX_COORD_NO":
	            outputs.push(node_output_by_ident(bpy_node, "Normal"));
	            break;
	        case "TEX_COORD_GE":
	            var ge_tra_name = shader_ident("param_TEX_COORD_GE_v");
	            vparams.push(node_param(ge_tra_name));

	            outputs.push(node_output_by_ident(bpy_node, "Generated"));
	            params.push(node_param(ge_tra_name));
	            break;
	        case "TEX_COORD_OB":
	            outputs.push(node_output_by_ident(bpy_node, "Object"));
	            break;
	        case "TEX_COORD_CA":
	            outputs.push(node_output_by_ident(bpy_node, "Camera"));
	            break;
	        case "TEX_COORD_WI":
	            outputs.push(node_output_by_ident(bpy_node, "Window"));
	            break;
	        case "TEX_COORD_RE":
	            outputs.push(node_output_by_ident(bpy_node, "Reflection"));
	            break;
	        }
	        break;
	    case "GROUP":
	        var node_name = bpy_node["node_tree_name"];
	        switch (node_name) {
	        case "B4W_LINEAR_TO_SRGB":
	            if (!validate_custom_node_group(bpy_node, [1], [1])) {
	                data = process_node_group(bpy_node, shader_type, 
	                        active_layer_names);
	                break;
	            }
	            type = "B4W_LINEAR_TO_SRGB";
	            break;
	        case "B4W_NORMAL_VIEW":
	        case "B4W_VECTOR_VIEW":
	            if (!validate_custom_node_group(bpy_node, [1], [1])) {
	                data = process_node_group(bpy_node, shader_type, 
	                        active_layer_names);
	                break;
	            }
	            type = "B4W_VECTOR_VIEW";
	            break;
	        case "B4W_SRGB_TO_LINEAR":
	            if (!validate_custom_node_group(bpy_node, [1], [1])) {
	                data = process_node_group(bpy_node, shader_type, 
	                        active_layer_names);
	                break;
	            }
	            type = "B4W_SRGB_TO_LINEAR";
	            break;
	        case "B4W_REFLECT":
	            if (!validate_custom_node_group(bpy_node, [1,1], [1])) {
	                data = process_node_group(bpy_node, shader_type, 
	                        active_layer_names);
	                break;
	            }
	            type = "B4W_REFLECT";
	            break;
	        case "B4W_REFRACTION":
	            if (!validate_custom_node_group(bpy_node, [1,0], [1])) {
	                data = process_node_group(bpy_node, shader_type, 
	                        active_layer_names);
	                break;
	            }
	            type = "B4W_REFRACTION";
	            break;
	        case "B4W_PARALLAX":
	            if (!validate_custom_node_group(bpy_node, [1,1,0,0,0], [1])) {
	                data = process_node_group(bpy_node, shader_type, 
	                        active_layer_names);
	                break;
	            }
	            var tex_name = shader_ident("param_B4W_PARALLAX_texture");
	            params.push(node_param(tex_name));
	            type = "B4W_PARALLAX";
	            break;
	        case "B4W_CLAMP":
	            if (!validate_custom_node_group(bpy_node, [1], [1])) {
	                data = process_node_group(bpy_node, shader_type, 
	                        active_layer_names);
	                break;
	            }
	            type = "B4W_CLAMP";
	            break;
	        case "B4W_TRANSLUCENCY":
	            if (!validate_custom_node_group(bpy_node, [0,0,0,0,0], [0])) {
	                data = process_node_group(bpy_node, shader_type, 
	                        active_layer_names);
	                break;
	            }
	            type = "B4W_TRANSLUCENCY";
	            break;
	        case "B4W_TIME":
	            if (!validate_custom_node_group(bpy_node, [], [0])) {
	                data = process_node_group(bpy_node, shader_type, 
	                        active_layer_names);
	                break;
	            }
	            type = "B4W_TIME";
	            break;
	        case "B4W_SMOOTHSTEP":
	            if (!validate_custom_node_group(bpy_node, [0,0,0], [0])) {
	                data = process_node_group(bpy_node, shader_type, 
	                        active_layer_names);
	                break;
	            }
	            type = "B4W_SMOOTHSTEP";
	            break;
	        case "B4W_GLOW_OUTPUT":
	            type = "B4W_GLOW_OUTPUT";
	            break;
	        default:
	            data = process_node_group(bpy_node, shader_type, 
	                    active_layer_names);
	        }
	        inputs = node_inputs_bpy_to_b4w(bpy_node);
	        outputs = node_outputs_bpy_to_b4w(bpy_node);
	        // NOTE: additional translucency output
	        if (node_name == "B4W_TRANSLUCENCY") {
	            var out = default_node_inout("TranslucencyParams", "TranslucencyParams", [0,0,0,0]);
	            out.is_linked = outputs[0].is_linked;
	            outputs.push(out);
	        }
	        break;
	    case "LAMP":
	        var bpy_lamp = bpy_node["lamp"];
	        if (!bpy_lamp) {
	            m_print.error("There is no lamp in node: " + bpy_node["name"]);
	            dirs.push(["LAMP_INDEX", -1]);
	        } else {
	            if (!(bpy_lamp["uuid"] in _lamp_indexes)) {
	                _lamp_indexes[bpy_lamp["uuid"]] = _lamp_index;
	                dirs.push(["LAMP_INDEX", String(_lamp_index++)]);
	            } else
	                dirs.push(["LAMP_INDEX", String(_lamp_indexes[bpy_lamp["uuid"]])]);
	            data = _lamp_indexes;
	        }
	        outputs.push(node_output_by_ident(bpy_node, "Color"));
	        outputs.push(node_output_by_ident(bpy_node, "Light Vector"));
	        outputs.push(node_output_by_ident(bpy_node, "Distance"));
	        outputs.push(node_output_by_ident(bpy_node, "Visibility Factor"));
	        break;

	    case "LIGHTING_AMBIENT":
	        inputs = [default_node_inout("E", "E", [0,0,0], true),
	                  default_node_inout("A", "A", [0,0,0], true),
	                  default_node_inout("D", "D", [0,0,0], true)];
	        outputs = [default_node_inout("color", "color", [0,0,0], true),
	                   default_node_inout("specular", "specular", [0,0,0], true)];
	        break;
	    case "LIGHTING_BEGIN":
	        outputs = [default_node_inout("E", "E", [0,0,0], true),
	                  default_node_inout("A", "A", [0,0,0], true),
	                  default_node_inout("D", "D", [0,0,0], true),
	                  default_node_inout("S", "S", [0,0,0], true),
	                  default_node_inout("normal", "normal", [0,0,0], true),
	                  default_node_inout("dif_params", "dif_params", [0,0], true),
	                  default_node_inout("sp_params", "sp_params", [0,0], true),
	                  default_node_inout("shadow_factor", "shadow_factor", 0, true),
	                  default_node_inout("translucency_color", "translucency_color", 0, true),
	                  default_node_inout("translucency_params", "translucency_params", [0,0,0,0], true)];
	        break;
	    case "LIGHTING_END":
	        inputs = [default_node_inout("color", "color", [0,0,0], true),
	                  default_node_inout("specular", "specular", [0,0,0], true)];
	        break;
	    case "LIGHTING_LAMP":
	        inputs = [default_node_inout("shadow_factor", "shadow_factor", 0, true)];
	        outputs = [default_node_inout("ldir", "ldir", [0,0,0], true),
	                   default_node_inout("lfac", "lfac", [0,0], true),
	                   default_node_inout("lcolorint", "lcolorint", [0,0,0], true),
	                   default_node_inout("norm_fac", "norm_fac", 0, true)];
	        break;
	    case "DIFFUSE_LAMBERT":
	        inputs = [default_node_inout("ldir", "ldir", [0,0,0], true),
	                  default_node_inout("lfac", "lfac", [0,0], true),
	                  default_node_inout("normal", "normal", [0,0,0], true),
	                  default_node_inout("norm_fac", "norm_fac", 0, true)];
	        outputs = [default_node_inout("lfactor", "lfactor", 0, true)];
	        dirs.push(["MAT_USE_TBN_SHADING", bpy_node["use_tangent_shading"] | 0]);
	        break;
	    case "DIFFUSE_FRESNEL":
	    case "DIFFUSE_MINNAERT":
	    case "DIFFUSE_OREN_NAYAR":
	    case "DIFFUSE_TOON":
	        inputs = [default_node_inout("ldir", "ldir", [0,0,0], true),
	                  default_node_inout("lfac", "lfac", [0,0], true),
	                  default_node_inout("normal", "normal", [0,0,0], true),
	                  default_node_inout("norm_fac", "norm_fac", 0, true),
	                  default_node_inout("dif_params", "dif_params", [0,0], true)];
	        outputs = [default_node_inout("lfactor", "lfactor", 0, true)];
	        dirs.push(["MAT_USE_TBN_SHADING", bpy_node["use_tangent_shading"] | 0]);
	        break;
	    case "SPECULAR_BLINN":
	    case "SPECULAR_PHONG":
	    case "SPECULAR_COOKTORR":
	        inputs = [default_node_inout("ldir", "ldir", [0,0,0], true),
	                  default_node_inout("lfac", "lfac", [0,0], true),
	                  default_node_inout("normal", "normal", [0,0,0], true),
	                  default_node_inout("norm_fac", "norm_fac", 0, true),
	                  default_node_inout("sp_params", "sp_params", [0,0], true)];
	        outputs = [default_node_inout("sfactor", "sfactor", 0, true)];
	        dirs.push(["MAT_USE_TBN_SHADING", bpy_node["use_tangent_shading"] | 0]);
	        break;
	    case "SPECULAR_TOON":
	    case "SPECULAR_WARDISO":
	        inputs = [default_node_inout("ldir", "ldir", [0,0,0], true),
	                  default_node_inout("lfac", "lfac", [0,0], true),
	                  default_node_inout("normal", "normal", [0,0,0], true),
	                  default_node_inout("norm_fac", "norm_fac", 0, true),
	                  default_node_inout("sp_params", "sp_params", [0,0], true)];
	        outputs = [default_node_inout("sfactor", "sfactor", 0, true)];
	        dirs.push(["MAT_USE_TBN_SHADING", bpy_node["use_tangent_shading"] | 0]);
	        break;
	    case "BSDF_COMPUTE":
	        inputs = [default_node_inout("ldir", "ldir", [0,0,0], true),
	                  default_node_inout("lfac", "lfac", [0,0], true),
	                  default_node_inout("normal", "normal", [0,0,0], true),
	                  default_node_inout("norm_fac", "norm_fac", 0, true),
	                  default_node_inout("bsdf_params", "bsdf_params", [0,0,0,0], true)];
	        outputs = [default_node_inout("lfactor", "lfactor", 0, true),
	                   default_node_inout("sfactor", "sfactor", 0, true)];
	        break;
	    case "LIGHTING_APPLY":
	        inputs = [default_node_inout("color", "color", [0,0,0,0], true),
	                  default_node_inout("specular", "specular", [0,0,0], true),
	                  default_node_inout("lfactor", "lfactor", 0, true),
	                  default_node_inout("sfactor", "sfactor", 0, true),
	                  default_node_inout("ldir", "ldir", [0,0,0], true),
	                  default_node_inout("normal", "normal", [0,0,0], true),
	                  default_node_inout("translucency_params", "translucency_params", [0,0,0,0], true),
	                  default_node_inout("D", "D", [0,0,0], true),
	                  default_node_inout("S", "S", [0,0,0], true),
	                  default_node_inout("lcolorint", "lcolorint", [0,0,0], true),
	                  default_node_inout("translucency_color", "translucency_color", 0, true)];
	        outputs = [default_node_inout("color", "color", [0,0,0,0], true),
	                   default_node_inout("specular", "specular", [0,0,0], true)];
	        break;
	    case "NORMAL":
	        inputs = node_inputs_bpy_to_b4w(bpy_node);
	        outputs = node_outputs_bpy_to_b4w(bpy_node);

	        var output_norm = node_output_by_ident(bpy_node, "Normal");
	        params.push(node_param(shader_ident("param_NORMAL_Normal"),
	                output_norm.default_value, 3));
	        break;
	    case "MAPPING":
	        var vector_type = bpy_node["vector_type"];

	        type = "MAPPING";

	        inputs.push(node_input_by_ident(bpy_node, "Vector"));
	        outputs.push(node_output_by_ident(bpy_node, "Vector"));

	        var rot = m_util.f32(bpy_node["rotation"]);
	        var scale = m_util.f32(bpy_node["scale"]);
	        var trans = m_util.f32(bpy_node["translation"]);
	        var trs_matrix = m_mat3.create();

	        // rotation
	        var rot_matrix = m_util.euler_to_rotation_matrix(rot, m_mat3.create());

	        // HACK: set non-zero scale to allow matrix inverse
	        if (vector_type == "TEXTURE" || vector_type == "NORMAL") {
	            scale[0] = scale[0] || 1.0;
	            scale[1] = scale[1] || 1.0;
	            scale[2] = scale[2] || 1.0;
	        }

	        // scale
	        var scale_matrix = new Float32Array([scale[0],0,0,0,scale[1],0,0,0,scale[2]]);

	        m_mat3.multiply(rot_matrix, scale_matrix, trs_matrix);
	        trs_matrix = m_util.mat3_to_mat4(trs_matrix, m_mat4.create());
	        switch (vector_type) {
	        case "POINT":
	            // order of transforms: translation -> rotation -> scale
	            // translation
	            trs_matrix[12] = trans[0];
	            trs_matrix[13] = trans[1];
	            trs_matrix[14] = trans[2];
	            break;
	        case "TEXTURE":
	            // order of transforms: translation -> rotation -> scale -> invert
	            // translation
	            trs_matrix[12] = trans[0];
	            trs_matrix[13] = trans[1];
	            trs_matrix[14] = trans[2];
	            trs_matrix = m_mat4.invert(trs_matrix, trs_matrix);
	            break;
	        case "NORMAL":
	            // order of transforms: rotation -> scale -> invert ->transpose
	            m_mat4.invert(trs_matrix, trs_matrix);
	            m_mat4.transpose(trs_matrix, trs_matrix);
	            break;
	        }

	        switch (vector_type) {
	        case "NORMAL":
	            dirs.push(["MAPPING_IS_NORMAL", 1]);
	        case "TEXTURE":
	            dirs.push(["MAPPING_TRS_MATRIX_DEF", 1]);
	            dirs.push(["MAPPING_TRS_MATRIX", m_shaders.glsl_value(trs_matrix, 16)]);
	            break;
	        case "POINT":
	            if (m_vec3.length(rot) !== 0) {
	                dirs.push(["MAPPING_TRS_MATRIX_DEF", 1]);
	                dirs.push(["MAPPING_TRS_MATRIX", m_shaders.glsl_value(trs_matrix, 16)]);
	            } else {
	                if (m_vec3.sqrDist(scale, m_util.VEC3_UNIT) !== 0) {
	                    dirs.push(["MAPPING_SCALE_DEF", 1]);
	                    dirs.push(["MAPPING_SCALE", m_shaders.glsl_value(scale, 3)]);
	                }
	                if (m_vec3.length(trans) !== 0) {
	                    dirs.push(["MAPPING_TRANS_DEF", 1]);
	                    dirs.push(["MAPPING_TRANS", m_shaders.glsl_value(trans, 3)]);
	                }
	            }
	            break;
	        case "VECTOR":
	            if (m_vec3.length(rot) !== 0) {
	                dirs.push(["MAPPING_TRS_MATRIX_DEF", 1]);
	                dirs.push(["MAPPING_TRS_MATRIX", m_shaders.glsl_value(trs_matrix, 16)]);
	            } else if (m_vec3.sqrDist(scale, m_util.VEC3_UNIT) !== 0) {
	                dirs.push(["MAPPING_SCALE_DEF", 1]);
	                dirs.push(["MAPPING_SCALE", m_shaders.glsl_value(scale, 3)]);
	            }
	            break;
	        }

	        // clipping
	        if (bpy_node["use_min"]) {
	            dirs.push(["MAPPING_MIN_CLIP_DEF", 1]);
	            dirs.push(["MAPPING_MIN_CLIP", m_shaders.glsl_value(bpy_node["min"], 3)]);
	        }

	        if (bpy_node["use_max"]) {
	            dirs.push(["MAPPING_MAX_CLIP_DEF", 1]);
	            dirs.push(["MAPPING_MAX_CLIP", m_shaders.glsl_value(bpy_node["max"], 3)]);
	        }
	        break;
	    case "MATERIAL":
	    case "MATERIAL_EXT":
	        var material_begin_dirs = [];
	        var material_end_dirs = [];

	        // MATERIAL BEGIN main inputs/outputs
	        var material_begin_inputs = [];
	        var material_begin_outputs = [default_node_inout("E", "E", [0, 0, 0], true), 
	                                      default_node_inout("A", "A", [0, 0, 0], true),
	                                      default_node_inout("D", "D", [0, 0, 0], true),
	                                      default_node_inout("S", "S", [0, 0, 0], true),
	                                      default_node_inout("normal", "normal", [0, 0, 0], true),
	                                      default_node_inout("dif_params", "dif_params", [0, 0], true),
	                                      default_node_inout("sp_params", "sp_params", [0, 0], true),
	                                      default_node_inout("shadow_factor", "shadow_factor", 0, true)];

	        // MATERIAL END main inputs/outputs/params
	        var material_end_inputs = [default_node_inout("color", "color", [0, 0, 0], true),
	                                   default_node_inout("specular", "specular", [0, 0, 0], true),
	                                   default_node_inout("normal", "normal", [0, 0, 0], true)];
	        var material_end_outputs = [node_output_by_ident(bpy_node, "Color"),
	                                    node_output_by_ident(bpy_node, "Alpha"),
	                                    node_output_by_ident(bpy_node, "Normal")];

	        var material_end_params = [];


	        // MATERIAL BEGIN INPUT 0
	        var input = node_input_by_ident(bpy_node, "Color");
	        input.default_value.splice(3); // vec4 -> vec3
	        material_begin_inputs.push(input);
	        inputs.push(input);

	        // MATERIAL BEGIN INPUT 1
	        input = node_input_by_ident(bpy_node, "Spec");
	        input.default_value.splice(3); // vec4 -> vec3
	        material_begin_inputs.push(input);
	        inputs.push(input);

	        // MATERIAL BEGIN INPUT 2
	        input = node_input_by_ident(bpy_node, "DiffuseIntensity");

	        // NOTE: Blender doesn't update the identifier of this node for old files
	        if (!input)
	            input = node_input_by_ident(bpy_node, "Refl");

	        // NOTE: Blender doesn't the default value of this node for old files
	        input.default_value = bpy_node["diffuse_intensity"];

	        material_begin_inputs.push(input);
	        inputs.push(input);

	        // MATERIAL BEGIN INPUT 3
	        var input_norm = node_input_by_ident(bpy_node, "Normal");
	        input_norm.default_value.splice(3); // vec4 -> vec3
	        material_begin_inputs.push(input_norm);
	        inputs.push(input_norm);

	        if (type == "MATERIAL_EXT") {
	            // additional inputs/outputs for extended materials

	            // MATERIAL BEGIN INPUT 4
	            input = node_input_by_ident(bpy_node, "Emit");
	            if (!input)
	                input = default_node_inout("Emit", "Emit", 0);
	            material_begin_inputs.push(input);
	            inputs.push(input);

	            // NOTE: additional inputs from translucency node
	            input = node_input_by_ident(bpy_node, "Translucency");
	            if (input) {
	                input.default_value = 0;
	                input.name = "Translucency";
	                input.identifier = "Translucency";
	            } else
	                input = default_node_inout("Translucency", "Translucency", 0);
	            inputs.push(input);

	            input = node_input_by_ident(bpy_node, "Translucency");
	            if (input) {
	                input.default_value = [0, 0, 0, 0];
	                input.name = "TranslucencyParams";
	                input.identifier = "TranslucencyParams";
	            } else
	                input = default_node_inout("TranslucencyParams", "TranslucencyParams", [0, 0, 0, 0]);
	            inputs.push(input);

	            // MATERIAL END INPUT 4

	            // NOTE: Blender version >= 2.74: Reflectivity
	            // Blender version < 2.74: Ray Mirror
	            var input_new = node_input_by_ident(bpy_node, "Reflectivity");
	            var input_old = node_input_by_ident(bpy_node, "Ray Mirror");

	            if (input_new) {
	                input = input_new;
	                var input_name = "Reflectivity";
	            } else if (input_old) {
	                input = input_old;
	                var input_name = "Ray Mirror";
	            } else {
	                input = input_new;
	                var input_name = "Reflectivity";
	            }

	            if (!input)
	                input = default_node_inout(input_name, input_name, 0);
	            inputs.push(input);
	            material_end_inputs.push(input);

	            // MATERIAL END INPUT 5
	            input = node_input_by_ident(bpy_node, "SpecTra");
	            if (!input)
	                input = default_node_inout("SpecTra", "SpecTra", 0);
	            inputs.push(input);
	            material_end_inputs.push(input);

	            // MATERIAL END INPUT 6
	            input = node_input_by_ident(bpy_node, "Alpha");
	            if (!input)
	                input = default_node_inout("Alpha", "Alpha", bpy_node["alpha"]);
	            inputs.push(input);
	            material_end_inputs.push(input);

	            material_end_outputs.push(node_output_by_ident(bpy_node, "Diffuse"));
	            material_end_outputs.push(node_output_by_ident(bpy_node, "Spec"));

	            material_begin_dirs.push(["MATERIAL_EXT", 1]);
	            material_end_dirs.push(["MATERIAL_EXT", 1]);
	        } else {
	            material_begin_inputs.push(default_node_inout("emit_intensity", "emit_intensity", 0));
	            
	            material_end_inputs.push(default_node_inout("reflect_factor", "reflect_factor", 0));
	            material_end_inputs.push(default_node_inout("specular_alpha", "specular_alpha", 0));
	            material_end_inputs.push(default_node_inout("alpha_in", "alpha_in", 0));

	            material_end_outputs.push(default_node_inout("diffuse_out", "diffuse_out", 0));
	            material_end_outputs.push(default_node_inout("spec_out", "spec_out", 0));
	            material_begin_dirs.push(["MATERIAL_EXT", 0]);
	            material_end_dirs.push(["MATERIAL_EXT", 0]);
	        }
	        
	        material_end_params.push(node_param(shader_ident("param_MATERIAL_alpha"),
	                               bpy_node["alpha"]));
	        material_end_params.push(node_param(shader_ident("param_MATERIAL_spec_alpha"),
	                               bpy_node["specular_alpha"]));
	        
	        // MATERIAL outputs
	        outputs = material_end_outputs;

	        // MATERIAL dirs
	        material_begin_dirs.push(["USE_MATERIAL_NORMAL", input_norm.is_linked | 0]);

	        if (bpy_node["use_diffuse"]) {
	            material_begin_dirs.push(["USE_MATERIAL_DIFFUSE", 1]);
	            material_end_dirs.push(["USE_MATERIAL_DIFFUSE", 1]);
	        }

	        if (bpy_node["use_specular"])
	            material_end_dirs.push(["USE_MATERIAL_SPECULAR", 1]);

	        // MATERIAL BEGIN params
	        var material_begin_params = [];
	        var spec_param_0;
	        var spec_param_1 = 0;
	        switch (bpy_node["specular_shader"]) {
	        case "COOKTORR":
	        case "PHONG":
	            spec_param_0 = bpy_node["specular_hardness"];
	            break;
	        case "WARDISO":
	            spec_param_0 = bpy_node["specular_slope"];
	            break;
	        case "TOON":
	            spec_param_0 = bpy_node["specular_toon_size"];
	            spec_param_1 = bpy_node["specular_toon_smooth"];
	            break;
	        case "BLINN":
	            spec_param_0 = bpy_node["specular_ior"];
	            spec_param_1 = bpy_node["specular_hardness"];
	            break;
	        default:
	            m_print.error("unsupported specular shader: " +
	                bpy_node["specular_shader"] + " (material \"" +
	                bpy_node["material_name"] + "\")");
	            spec_param_0 = bpy_node["specular_hardness"];
	            break;
	        }

	        var diffuse_param;
	        var diffuse_param2;
	        switch (bpy_node["diffuse_shader"]) {
	        case "LAMBERT":
	            diffuse_param = 0.0;
	            diffuse_param2 = 0.0;
	            break;
	        case "OREN_NAYAR":
	            diffuse_param = bpy_node["roughness"];
	            diffuse_param2 = 0.0;
	            break;
	        case "FRESNEL":
	            diffuse_param = bpy_node["diffuse_fresnel"];
	            diffuse_param2 = bpy_node["diffuse_fresnel_factor"];
	            break;
	        case "MINNAERT":
	            diffuse_param = bpy_node["darkness"];
	            diffuse_param2 = 0.0;
	            break;
	        case "TOON":
	            diffuse_param = bpy_node["diffuse_toon_size"];
	            diffuse_param2 = bpy_node["diffuse_toon_smooth"];
	            break;
	        default:
	            m_print.error("unsupported diffuse shader: " +
	                bpy_node["diffuse_shader"] + " (material \"" +
	                bpy_node["material_name"] + "\")");
	            diffuse_param = 0.0;
	            diffuse_param2 = 0.0;
	            break;
	        }

	        material_begin_params.push(node_param(shader_ident("param_MATERIAL_diffuse"),
	                                [diffuse_param, diffuse_param2], 2));

	        material_begin_params.push(node_param(shader_ident("param_MATERIAL_spec"),
	                               [bpy_node["specular_intensity"],
	                                spec_param_0, spec_param_1], 3));

	        material_begin_dirs.push(["SHADELESS_MAT", bpy_node["use_shadeless"]? 1: 0]);

	        var path_data = {
	            name: bpy_node["name"],
	            value: {
	                specular_shader: bpy_node["specular_shader"],
	                diffuse_shader: bpy_node["diffuse_shader"],
	                use_shadeless: bpy_node["use_shadeless"],
	                use_tangent_shading: bpy_node["use_tangent_shading"]
	            }
	        };

	        // MATERIAL BEGIN
	        var material_begin = {
	            "name": "material_begin",
	            "type": "MATERIAL_BEGIN",
	            inputs: material_begin_inputs,
	            outputs: material_begin_outputs,
	            params: material_begin_params,
	            data: path_data,
	            dirs: material_begin_dirs,
	            vparams: []
	        };

	        // MATERIAL END        
	        var material_end = {
	            "name": "material_end",
	            "type": "MATERIAL_END",
	            inputs: material_end_inputs,
	            outputs: material_end_outputs,
	            params: material_end_params,
	            data: path_data,
	            dirs: material_end_dirs,
	            vparams: []
	        };

	        // MATERIAL data
	        data = {
	            name: bpy_node["name"],
	            value: {
	                specular_shader: bpy_node["specular_shader"],
	                diffuse_shader: bpy_node["diffuse_shader"],
	                use_shadeless: bpy_node["use_shadeless"],
	                use_tangent_shading: bpy_node["use_tangent_shading"]
	            },
	            material_begin: material_begin,
	            material_end: material_end
	        };

	        break;
	    case "BSDF_DIFFUSE":
	        inputs = node_inputs_bpy_to_b4w(bpy_node);
	        dirs.push(["USE_NORMAL_IN", inputs[2].is_linked | 0]);
	        var bsdf_output = node_output_by_ident(bpy_node, "BSDF");
	        var bsdf_output_is_linked = bsdf_output.is_linked;
	        outputs = [bsdf_output,
	                   default_node_inout("d_color", "d_color", [0, 0, 0], bsdf_output_is_linked),
	                   default_node_inout("d_roughness", "d_roughness", 0, bsdf_output_is_linked),
	                   default_node_inout("s_color", "s_color", [0, 0, 0], bsdf_output_is_linked),
	                   default_node_inout("s_roughness", "s_roughness", 0, bsdf_output_is_linked),
	                   default_node_inout("metalness", "metalness", 0, bsdf_output_is_linked),
	                   default_node_inout("normal", "normal", [0, 0, 0], bsdf_output_is_linked),
	                   default_node_inout("e_color", "e_color", [0, 0, 0], bsdf_output_is_linked),
	                   default_node_inout("emisson", "emisson", 0, bsdf_output_is_linked),
	                   default_node_inout("a_color", "a_color", [0, 0, 0], bsdf_output_is_linked),
	                   default_node_inout("alpha", "alpha", 1, bsdf_output_is_linked)];
	        break;
	    case "BSDF_GLOSSY":
	        inputs = node_inputs_bpy_to_b4w(bpy_node);
	        dirs.push(["USE_NORMAL_IN", inputs[2].is_linked | 0]);
	        var bsdf_output = node_output_by_ident(bpy_node, "BSDF");
	        var bsdf_output_is_linked = bsdf_output.is_linked;
	        outputs = [bsdf_output,
	                   default_node_inout("d_color", "d_color", [0, 0, 0], bsdf_output_is_linked),
	                   default_node_inout("d_roughness", "d_roughness", 0, bsdf_output_is_linked),
	                   default_node_inout("s_color", "s_color", [0, 0, 0], bsdf_output_is_linked),
	                   default_node_inout("s_roughness", "s_roughness", 0, bsdf_output_is_linked),
	                   default_node_inout("metalness", "metalness", 1, bsdf_output_is_linked),
	                   default_node_inout("normal", "normal", [0, 0, 0], bsdf_output_is_linked),
	                   default_node_inout("e_color", "e_color", [0, 0, 0], bsdf_output_is_linked),
	                   default_node_inout("emisson", "emisson", 0, bsdf_output_is_linked), 
	                   default_node_inout("a_color", "a_color", [0, 0, 0], bsdf_output_is_linked),
	                   default_node_inout("alpha", "alpha", 1, bsdf_output_is_linked)];
	        break;
	    case "BSDF_TRANSPARENT":
	        inputs = node_inputs_bpy_to_b4w(bpy_node);
	        var bsdf_output = node_output_by_ident(bpy_node, "BSDF");
	        var bsdf_output_is_linked = bsdf_output.is_linked;
	        outputs = [bsdf_output,
	                   default_node_inout("d_color", "d_color", [0, 0, 0], bsdf_output_is_linked),
	                   default_node_inout("d_roughness", "d_roughness", 0, bsdf_output_is_linked),
	                   default_node_inout("s_color", "s_color", [0, 0, 0], bsdf_output_is_linked),
	                   default_node_inout("s_roughness", "s_roughness", 0, bsdf_output_is_linked),
	                   default_node_inout("metalness", "metalness", 0, bsdf_output_is_linked),
	                   default_node_inout("normal", "normal", [0, 0, 0], bsdf_output_is_linked),
	                   default_node_inout("e_color", "e_color", [0, 0, 0], bsdf_output_is_linked),
	                   default_node_inout("emisson", "emisson", 0, bsdf_output_is_linked),
	                   default_node_inout("a_color", "a_color", [0, 0, 0], bsdf_output_is_linked),
	                   default_node_inout("alpha", "alpha", 1, bsdf_output_is_linked)];
	        break;
	    case "EMISSION":
	        inputs = node_inputs_bpy_to_b4w(bpy_node);
	        var emission_output = node_output_by_ident(bpy_node, "Emission");
	        var emission_output_is_linked = emission_output.is_linked;
	        outputs = [emission_output,
	                   default_node_inout("d_color", "d_color", [0, 0, 0], emission_output_is_linked),
	                   default_node_inout("d_roughness", "d_roughness", 0, emission_output_is_linked),
	                   default_node_inout("s_color", "s_color", [0, 0, 0], emission_output_is_linked),
	                   default_node_inout("s_roughness", "s_roughness", 0, emission_output_is_linked),
	                   default_node_inout("metalness", "metalness", 1, emission_output_is_linked),
	                   default_node_inout("normal", "normal", [0, 0, 0], emission_output_is_linked),
	                   default_node_inout("e_color", "e_color", [0, 0, 0], emission_output_is_linked),
	                   default_node_inout("emisson", "emisson", 1, emission_output_is_linked),
	                   default_node_inout("a_color", "a_color", [0, 0, 0], bsdf_output_is_linked),
	                   default_node_inout("alpha", "alpha", 1, bsdf_output_is_linked)];
	        break;
	    case "MATH":
	        switch (bpy_node["operation"]) {
	        case "ADD":
	            type = "MATH_ADD";
	            break;
	        case "SUBTRACT":
	            type = "MATH_SUBTRACT";
	            break;
	        case "MULTIPLY":
	            type = "MATH_MULTIPLY";
	            break;
	        case "DIVIDE":
	            type = "MATH_DIVIDE";
	            break;
	        case "SINE":
	            type = "MATH_SINE";
	            break;
	        case "COSINE":
	            type = "MATH_COSINE";
	            break;
	        case "TANGENT":
	            type = "MATH_TANGENT";
	            break;
	        case "ARCSINE":
	            type = "MATH_ARCSINE";
	            break;
	        case "ARCCOSINE":
	            type = "MATH_ARCCOSINE";
	            break;
	        case "ARCTANGENT":
	            type = "MATH_ARCTANGENT";
	            break;
	        case "POWER":
	            type = "MATH_POWER";
	            break;
	        case "LOGARITHM":
	            type = "MATH_LOGARITHM";
	            break;
	        case "MINIMUM":
	            type = "MATH_MINIMUM";
	            break;
	        case "MAXIMUM":
	            type = "MATH_MAXIMUM";
	            break;
	        case "ROUND":
	            type = "MATH_ROUND";
	            break;
	        case "LESS_THAN":
	            type = "MATH_LESS_THAN";
	            break;
	        case "GREATER_THAN":
	            type = "MATH_GREATER_THAN";
	            break;
	        case "MODULO":
	            type = "MATH_MODULO";
	            break;
	        case "ABSOLUTE":
	            type = "MATH_ABSOLUTE";
	            break;
	        default:
	            m_print.error("Unsupported MATH operation: " +
	                    bpy_node["operation"]);
	            return null;
	        }
	        dirs.push(["MATH_USE_CLAMP", Number(bpy_node["use_clamp"])]);
	        inputs = node_inputs_bpy_to_b4w(bpy_node);
	        outputs = node_outputs_bpy_to_b4w(bpy_node);
	        break;
	    case "MIX_RGB":
	        switch (bpy_node["blend_type"]) {
	        case "MIX":
	            type = "MIX_RGB_MIX";
	            break;
	        case "ADD":
	            type = "MIX_RGB_ADD";
	            break;
	        case "MULTIPLY":
	            type = "MIX_RGB_MULTIPLY";
	            break;
	        case "SUBTRACT":
	            type = "MIX_RGB_SUBTRACT";
	            break;
	        case "SCREEN":
	            type = "MIX_RGB_SCREEN";
	            break;
	        case "DIVIDE":
	            type = "MIX_RGB_DIVIDE";
	            break;
	        case "DIFFERENCE":
	            type = "MIX_RGB_DIFFERENCE";
	            break;
	        case "DARKEN":
	            type = "MIX_RGB_DARKEN";
	            break;
	        case "LIGHTEN":
	            type = "MIX_RGB_LIGHTEN";
	            break;
	        case "OVERLAY":
	            type = "MIX_RGB_OVERLAY";
	            break;
	        case "DODGE":
	            type = "MIX_RGB_DODGE";
	            break;
	        case "BURN":
	            type = "MIX_RGB_BURN";
	            break;
	        case "HUE":
	            type = "MIX_RGB_HUE";
	            break;
	        case "SATURATION":
	            type = "MIX_RGB_SATURATION";
	            break;
	        case "VALUE":
	            type = "MIX_RGB_VALUE";
	            break;
	        case "COLOR":
	            type = "MIX_RGB_COLOR";
	            break;
	        case "SOFT_LIGHT":
	            type = "MIX_RGB_SOFT_LIGHT";
	            break;
	        case "LINEAR_LIGHT":
	            type = "MIX_RGB_LINEAR_LIGHT";
	            break;
	        default:
	            m_print.error("Unsupported MIX_RGB blend type: " +
	                    bpy_node["blend_type"]);
	            return null;
	        }
	        dirs.push(["MIX_RGB_USE_CLAMP", Number(bpy_node["use_clamp"])]);
	        inputs = node_inputs_bpy_to_b4w(bpy_node);
	        outputs = node_outputs_bpy_to_b4w(bpy_node);

	        break;
	    case "MIX_WORLD_RGB":
	    case "ADD_WORLD_RGB":
	        inputs = [default_node_inout("Factor", "Factor", bpy_node["fac"], bpy_node["fac_is_linked"]),
	                  default_node_inout("Color1", "Color1", [0,0,0], bpy_node["color1_is_linked"]),
	                  default_node_inout("Color2", "Color1", [0,0,0], bpy_node["color2_is_linked"])];
	        outputs = [default_node_inout("Color", "Color", [0,0,0], true)];
	        break;
	    case "OUTPUT":
	        inputs = node_inputs_bpy_to_b4w(bpy_node);
	        outputs = [];
	        break;
	    case "OUTPUT_MATERIAL":
	        inputs = node_inputs_bpy_to_b4w(bpy_node);
	        outputs = [];

	        var surface_input = node_input_by_ident(bpy_node, "Surface");
	        var surface_inp_is_linked = surface_input.is_linked;

	        var bsdf_begin_dirs = [];
	        var bsdf_end_dirs = [];
	        // BSDF BEGIN main inputs/outputs
	        var bsdf_begin_inputs = [surface_input,
	                                 default_node_inout("d_color", "d_color", [0, 0, 0], surface_inp_is_linked),
	                                 default_node_inout("d_roughness", "d_roughness", 0, surface_inp_is_linked),
	                                 default_node_inout("s_color", "s_color", [0, 0, 0], surface_inp_is_linked),
	                                 default_node_inout("s_roughness", "s_roughness", 0, surface_inp_is_linked),
	                                 default_node_inout("metalness", "metalness", 0, surface_inp_is_linked),
	                                 default_node_inout("normal", "normal", [0, 0, 0], surface_inp_is_linked),
	                                 default_node_inout("e_color", "e_color", [0, 0, 0], surface_inp_is_linked),
	                                 default_node_inout("emission", "emission", 0, surface_inp_is_linked),
	                                 default_node_inout("a_color", "a_color", [0, 0, 0], surface_inp_is_linked),
	                                 default_node_inout("alpha", "alpha", 0, surface_inp_is_linked)];

	        var bsdf_begin_outputs = [default_node_inout("E", "E", [0, 0, 0], true),
	                                  default_node_inout("A", "A", [0, 0, 0], true),
	                                  default_node_inout("D", "D", [0, 0, 0], true),
	                                  default_node_inout("S", "S", [0, 0, 0], true),
	                                  default_node_inout("normal", "normal", [0, 0, 0], true),
	                                  default_node_inout("bsdf_params", "bsdf_params", [0, 0, 0, 0], true),
	                                  default_node_inout("shadow_factor", "shadow_factor", 0, true),
	                                  default_node_inout("d_color", "d_color", [0, 0, 0], true),
	                                  default_node_inout("s_color", "s_color", [0, 0, 0], true),
	                                  default_node_inout("e_color", "e_color", [0, 0, 0], true),
	                                  default_node_inout("emission", "emission", 0, true),
	                                  default_node_inout("a_color", "a_color", [0, 0, 0], true),
	                                  default_node_inout("alpha", "alpha", 0, true)];

	        // BSDF END main inputs/outputs/params
	        var bsdf_end_inputs = [default_node_inout("color", "color", [0, 0, 0], true),
	                               default_node_inout("specular", "specular", [0, 0, 0], true),
	                               default_node_inout("normal", "normal", [0, 0, 0], true),
	                               default_node_inout("bsdf_params", "bsdf_params", [0, 0, 0, 0], true),
	                               default_node_inout("d_color", "d_color", [0, 0, 0], true),
	                               default_node_inout("s_color", "s_color", [0, 0, 0], true),
	                               default_node_inout("e_color", "e_color", [0, 0, 0], true),
	                               default_node_inout("emission", "emission", 0, true),
	                               default_node_inout("a_color", "a_color", [0, 0, 0], true),
	                               default_node_inout("alpha", "alpha", 0, true)];
	        var bsdf_end_outputs = [default_node_inout("color", "color", [0, 0, 0], surface_inp_is_linked)];
	        var bsdf_begin_params = [];
	        var bsdf_end_params = [];

	        // BSDF BEGIN
	        var bsdf_begin = {
	            "name": "bsdf_begin",
	            "type": "BSDF_BEGIN",
	            inputs: bsdf_begin_inputs,
	            outputs: bsdf_begin_outputs,
	            params: bsdf_begin_params,
	            data: null,
	            dirs: bsdf_begin_dirs,
	            vparams: []
	        };

	        // BSDF END
	        var bsdf_end = {
	            "name": "bsdf_end",
	            "type": "BSDF_END",
	            inputs: bsdf_end_inputs,
	            outputs: bsdf_end_outputs,
	            params: bsdf_end_params,
	            data: null,
	            dirs: bsdf_end_dirs,
	            vparams: []
	        };


	        // OUTPUT_SURFACE main inputs/outputs/params
	        var output_surface_inputs = [surface_input];
	        var output_surface_outputs = [];
	        var output_surface_params = [];
	        var output_surface_dirs = [];

	        // OUTPUT_SURFACE
	        var output_surface = {
	            "name": "output_surface",
	            "type": "OUTPUT_SURFACE",
	            inputs: output_surface_inputs,
	            outputs: output_surface_outputs,
	            params: output_surface_params,
	            data: {
	                value: {
	                    bsdf_shader: "BSDF_COMPUTE"
	                },
	                bsdf_begin: bsdf_begin,
	                bsdf_end: bsdf_end
	            },
	            dirs: output_surface_dirs,
	            vparams: []
	        };


	        // DISPLACEMENT_BUMP main inputs/outputs/params
	        var displacement_bump_inputs = [default_node_inout("Height", "Height", 0, true)];
	        var displacement_bump_outputs = [default_node_inout("Normal", "Normal", [0, 0, 0], false)];
	        var displacement_bump_params = [];
	        var displacement_bump_dirs = [];

	        // DISPLACEMENT_BUMP
	        var displacement_bump = {
	            "name": "displacement_bump",
	            "type": "DISPLACEMENT_BUMP",
	            inputs: displacement_bump_inputs,
	            outputs: displacement_bump_outputs,
	            params: displacement_bump_params,
	            data: null,
	            dirs: displacement_bump_dirs,
	            vparams: []
	        };

	        // BSDF data
	        data = {
	            name: bpy_node["name"],
	            output_surface: output_surface,
	            displacement_bump: displacement_bump
	        };
	        break;
	    case "OUTPUT_WORLD":
	        inputs = node_inputs_bpy_to_b4w(bpy_node);
	        outputs = node_outputs_bpy_to_b4w(bpy_node);

	        var surface_input = node_input_by_ident(bpy_node, "Surface");

	        // OUTPUT_WORLD_SURFACE main inputs/outputs/params
	        var output_world_surface_inputs = [surface_input];
	        var output_world_surface_outputs = [];
	        var output_world_surface_params = [];
	        var output_world_surface_dirs = [];

	        // OUTPUT_WORLD_SURFACE
	        var output_surface = {
	            "name": "output_world_surface",
	            "type": "OUTPUT_WORLD_SURFACE",
	            inputs: output_world_surface_inputs,
	            outputs: output_world_surface_outputs,
	            params: output_world_surface_params,
	            data: null,
	            dirs: output_world_surface_dirs,
	            vparams: []
	        };

	        data = {
	            name: bpy_node["name"],
	            output_world_surface: output_surface
	        };
	        break;
	    case "RGB":
	        var param_name = bpy_node["name"];
	        var param = {
	            name: "-1",
	            value: param_name
	        };
	        params.push(param);

	        outputs.push(node_output_by_ident(bpy_node, "Color"));

	        break;
	    case "SEPRGB":
	    case "SEPHSV":
	        inputs = node_inputs_bpy_to_b4w(bpy_node);
	        outputs = node_outputs_bpy_to_b4w(bpy_node);
	        break;
	    case "TEX_ENVIRONMENT":
	        var image = bpy_node["image"];
	        if (!image)
	            type = "TEXTURE_EMPTY";
	        else {
	            type = "TEXTURE_ENVIRONMENT_" + bpy_node["projection"];

	            if (bpy_node["color_space"] == "NONE")
	                dirs.push(["NON_COLOR", 1]);
	            else
	                dirs.push(["NON_COLOR", 0]);

	            inputs.push(node_input_by_ident(bpy_node, "Vector"));
	            dirs.push(["USE_VECTOR_IN", inputs[0].is_linked | 0]);
	            outputs.push(node_output_by_ident(bpy_node, "Color"));

	            var tex_name = shader_ident("param_TEXTURE_texture");
	            params.push(node_param(tex_name));

	            var tex = m_tex.create_texture(m_tex.TT_RGBA_INT, false);
	            tex.repeat = true;
	            tex.source = "IMAGE";
	            if (cfg_def.anisotropic_available)
	                tex.anisotropic_filtering = 16;

	            m_tex.append_img_info(tex, image);

	            data = {
	                bpy_name: bpy_node["name"],
	                bpy_uuid: "", // cycles textures do not have uuid
	                name: tex_name,
	                value: tex
	            };
	        }
	        break;
	    case "TEX_IMAGE":
	        var image = bpy_node["image"];
	        if (!image)
	            type = "TEXTURE_EMPTY";
	        else {
	            type = "TEXTURE_COLOR";

	            if (bpy_node["color_space"] == "NONE")
	                dirs.push(["NON_COLOR", 1]);
	            else
	                dirs.push(["NON_COLOR", 0]);

	            dirs.push(["CONVERT_UV", 0]);

	            for (var i = 0; i < 4; ++i) {
	                var input, output1, output2;

	                if (i) {
	                    input = default_node_inout("Vector" + i, "Vector" + i, [0,0,0], false);
	                    output1 = default_node_inout("Color" + i, "Color" + i, [0,0,0], false);
	                    output2 = default_node_inout("Alpha" + i, "Alpha" + i, 0, false);
	                } else {
	                    input = node_input_by_ident(bpy_node, "Vector");
	                    output1 = node_output_by_ident(bpy_node, "Color");
	                    output2 = node_output_by_ident(bpy_node, "Alpha");
	                }

	                inputs.push(input);
	                outputs.push(output1);
	                outputs.push(output2);
	            }

	            var tex_name = shader_ident("param_TEXTURE_texture");
	            params.push(node_param(tex_name));

	            var tex = m_tex.create_texture(m_tex.TT_RGBA_INT, false);
	            tex.repeat = bpy_node["extension"] == "REPEAT";
	            tex.source = "IMAGE";
	            m_tex.append_img_info(tex, image);

	            data = {
	                bpy_name: bpy_node["name"],
	                bpy_uuid: "", // cycles textures do not have uuid
	                name: tex_name,
	                value: tex
	            };
	        }
	        break
	    case "TEXTURE":

	        type = texture_node_type(bpy_node);

	        if (type == "TEXTURE_EMPTY") {
	            outputs.push(node_output_by_ident(bpy_node, "Color"));
	            outputs.push(node_output_by_ident(bpy_node, "Normal"));
	            outputs.push(node_output_by_ident(bpy_node, "Value"));
	        } else if (type == "TEXTURE_ENVIRONMENT_CUBE") {
	            inputs.push(node_input_by_ident(bpy_node, "Vector"));
	            outputs.push(node_output_by_ident(bpy_node, "Color"));
	            outputs.push(node_output_by_ident(bpy_node, "Value"));
	        } else {
	            if (type == "TEXTURE_NORMAL") {
	                if (bpy_node["texture"]["type"] == "ENVIRONMENT_MAP") {
	                    m_print.error("Wrong output for ENVIRONMENT_MAP texture: " + bpy_node["name"]);
	                    return null;
	                }
	            }
	            if (type == "TEXTURE_COLOR") {
	                var non_color = false;
	                var bpy_image = bpy_node["texture"]["image"];
	                if (bpy_image && (bpy_image["colorspace_settings_name"] == "Non-Color"
	                      || bpy_image["colorspace_settings_name"] == "Non-Colour Data"))
	                    non_color = true;
	                dirs.push(["NON_COLOR", Number(non_color)]);
	                dirs.push(["CONVERT_UV", 1]);
	            }

	            for (var i = 0; i < 4; ++i) {
	                var input, output1, output2;

	                var out1_name = type == "TEXTURE_COLOR"? "Color": "Normal";

	                if (i) {
	                    input = default_node_inout("Vector" + i, "Vector" + i, [0,0,0], false);
	                    output1 = default_node_inout(out1_name + i, out1_name + i, [0,0,0], false);
	                    output2 = default_node_inout("Value" + i, "Value" + i, 0, false);
	                } else {
	                    input = node_input_by_ident(bpy_node, "Vector");
	                    output1 = node_output_by_ident(bpy_node, out1_name);
	                    output2 = node_output_by_ident(bpy_node, "Value");
	                }

	                inputs.push(input);
	                outputs.push(output1);
	                outputs.push(output2);
	            }
	        }
	        if (type != "TEXTURE_EMPTY") {
	            var tex_name = shader_ident("param_TEXTURE_texture");
	            params.push(node_param(tex_name));

	            var tex = bpy_node["texture"]._render;
	            data = {
	                bpy_name: bpy_node["texture"]["name"],
	                bpy_uuid: bpy_node["texture"]["uuid"],
	                name: tex_name,
	                value: tex
	            };
	        }

	        break;
	    case "VALTORGB":
	        inputs = node_inputs_bpy_to_b4w(bpy_node);
	        outputs = node_outputs_bpy_to_b4w(bpy_node);
	        data = {
	            value: bpy_node
	        };
	        var interpolation = bpy_node["color_ramp"]["interpolation"];
	        if (interpolation != "CONSTANT" && interpolation != "LINEAR")
	            m_print.warn("Color Ramp node is not fully supported.");
	        break;
	    case "VALUE":

	        type = "VALUE";

	        var param_name = bpy_node["name"];
	        var param = {
	            name: "-1",
	            value: param_name
	        };
	        params.push(param);

	        outputs.push(node_output_by_ident(bpy_node, "Value"));

	        break;
	    case "VECT_MATH":
	        switch (bpy_node["operation"]) {
	        case "ADD":
	            type = "VECT_MATH_ADD";
	            break;
	        case "SUBTRACT":
	            type = "VECT_MATH_SUBTRACT";
	            break;
	        case "AVERAGE":
	            type = "VECT_MATH_AVERAGE";
	            break;
	        case "DOT_PRODUCT":
	            type = "VECT_MATH_DOT_PRODUCT";
	            break;
	        case "CROSS_PRODUCT":
	            type = "VECT_MATH_CROSS_PRODUCT";
	            break;
	        case "NORMALIZE":
	            type = "VECT_MATH_NORMALIZE";
	            break;
	        default:
	            m_print.error("Unsupported VECT_MATH operation: " +
	                    bpy_node["operation"]);
	            return null;
	        }
	        inputs = node_inputs_bpy_to_b4w(bpy_node);
	        outputs = node_outputs_bpy_to_b4w(bpy_node);

	        break;
	    case "VECT_TRANSFORM":
	        switch (bpy_node["vector_type"]) {
	        case "POINT":
	            dirs.push(["VECTOR_TYPE", m_shaders.glsl_value(VT_POINT)]);
	            break;
	        case "VECTOR":
	            dirs.push(["VECTOR_TYPE", m_shaders.glsl_value(VT_VECTOR)]);
	            break;
	        case "NORMAL":
	            dirs.push(["VECTOR_TYPE", m_shaders.glsl_value(VT_NORMAL)]);
	            break;
	        default:
	            m_print.error("Unsupported VECT_TRANSFORM vector_type: " +
	                    bpy_node["vector_type"]);
	            return null;
	        }
	        var convert_from = bpy_node["convert_from"];
	        var convert_to = bpy_node["convert_to"];

	        var conv_type = VT_WORLD_TO_WORLD;
	        if (convert_from == "WORLD") {
	            if (convert_to == "WORLD")
	                conv_type = VT_WORLD_TO_WORLD;
	            else if (convert_to == "OBJECT")
	                conv_type = VT_WORLD_TO_OBJECT;
	            else if (convert_to == "CAMERA")
	                conv_type = VT_WORLD_TO_CAMERA;
	            else {
	                m_print.error("Unsupported VECT_TRANSFORM convert_to: " +
	                     bpy_node["convert_to"]);
	                return null;
	            }
	        } else if (convert_from == "OBJECT") {
	            if (convert_to == "WORLD")
	                conv_type = VT_OBJECT_TO_WORLD;
	            else if (convert_to == "OBJECT")
	                conv_type = VT_OBJECT_TO_OBJECT;
	            else if (convert_to == "CAMERA")
	                conv_type = VT_OBJECT_TO_CAMERA;
	            else {
	                m_print.error("Unsupported VECT_TRANSFORM convert_to: " +
	                        bpy_node["convert_to"]);
	                return null;
	            }
	        } else if (convert_from == "CAMERA") {
	            if (convert_to == "WORLD")
	                conv_type = VT_CAMERA_TO_WORLD;
	            else if (convert_to == "OBJECT")
	                conv_type = VT_CAMERA_TO_OBJECT;
	            else if (convert_to == "CAMERA")
	                conv_type = VT_CAMERA_TO_CAMERA;
	            else {
	                m_print.error("Unsupported VECT_TRANSFORM convert_to: " +
	                        bpy_node["convert_to"]);
	                return null;
	            }
	        } else {
	            m_print.error("Unsupported VECT_TRANSFORM convert_from: " +
	                    bpy_node["convert_from"]);
	            return null;
	        }

	        dirs.push(["CONVERT_TYPE", m_shaders.glsl_value(conv_type)]);

	        inputs = node_inputs_bpy_to_b4w(bpy_node);
	        outputs = node_outputs_bpy_to_b4w(bpy_node);

	        break;
	    case "NORMAL_MAP":
	        var space = NM_TANGENT;
	        switch (bpy_node["space"]) {
	        case "TANGENT":
	            space = NM_TANGENT;
	            break;
	        case "OBJECT":
	            space = NM_OBJECT;
	            break;
	        case "WORLD":
	            space = NM_WORLD;
	            break;
	        case "BLENDER_OBJECT":
	            space = NM_BLENDER_OBJECT;
	            break;
	        case "BLENDER_WORLD":
	            space = NM_BLENDER_WORLD;
	            break;
	        default:
	            m_print.error("Unsupported NORMAL_MAP space: " +
	                    bpy_node["space"]);
	            return null;
	        }
	        dirs.push(["SPACE", m_shaders.glsl_value(space)]);

	        inputs.push(node_input_by_ident(bpy_node, "Strength"));
	        inputs.push(node_input_by_ident(bpy_node, "Color"));
	        // fake input, used only with displacement_bump
	        inputs.push(default_node_inout("Normal", "Normal", [0, 0, 0], false));
	        dirs.push(["USE_NORMAL_IN", 0]);
	        outputs.push(node_output_by_ident(bpy_node, "Normal"));

	        break;
	    case "FRESNEL":
	        var input_norm = node_input_by_ident(bpy_node, "Normal");

	        inputs.push(node_input_by_ident(bpy_node, "IOR"));
	        inputs.push(input_norm);
	        outputs.push(node_output_by_ident(bpy_node, "Fac"));

	        dirs.push(["USE_FRESNEL_NORMAL", input_norm.is_linked | 0]);
	        break;
	    case "LAYER_WEIGHT":
	        var input_norm = node_input_by_ident(bpy_node, "Normal");

	        inputs.push(node_input_by_ident(bpy_node, "Blend"));
	        inputs.push(input_norm);
	        outputs = node_outputs_bpy_to_b4w(bpy_node);

	        dirs.push(["USE_NORMAL_IN", input_norm.is_linked | 0]);
	        break;
	    case "BUMP":
	        var input_norm = node_input_by_ident(bpy_node, "Normal");
	        dirs.push(["INVERT", bpy_node["invert"]? 1: 0]);
	        dirs.push(["USE_NORMAL_IN", input_norm.is_linked | 0]);

	        inputs = node_inputs_bpy_to_b4w(bpy_node);
	        outputs = node_outputs_bpy_to_b4w(bpy_node);
	        break;
	    case "BACKGROUND":
	        inputs = node_inputs_bpy_to_b4w(bpy_node);
	        outputs = node_outputs_bpy_to_b4w(bpy_node);
	        break;
	    default:
	        inputs = node_inputs_bpy_to_b4w(bpy_node);
	        outputs = node_outputs_bpy_to_b4w(bpy_node);

	        break;
	    }

	    var attr = {
	        name: name,
	        origin_name: origin_name,
	        type: type,

	        vparams: vparams,

	        inputs: inputs,
	        outputs: outputs,
	        params: params,

	        data: data,

	        dirs: dirs
	    };

	    var new_node_id = m_graph.gen_node_id(graph);
	    m_graph.append_node(graph, new_node_id, attr);

	    // recursively split GEOMETRY or TEX_COORD node
	    if ((bpy_node["type"] == "GEOMETRY" || bpy_node["type"] == "TEX_COORD" ||
	         bpy_node["type"] == "NEW_GEOMETRY") &&
	            node_output_check_next(bpy_node, output_num))
	        if (append_nmat_node(graph, bpy_node, ++output_num, shader_type, 
	                active_layer_names) == null)
	            return null;

	    return new_node_id;
	}

	function validate_custom_node_group(bpy_node, inputs_map, outputs_map) {

	    var bpy_inputs = bpy_node["inputs"];
	    var bpy_outputs = bpy_node["outputs"];
	    var node_name = bpy_node["node_tree_name"];

	    for (var i = 0; i < inputs_map.length; i++) {
	        var input = bpy_inputs[i];
	        var need_vec_in = inputs_map[i];
	        if (!input || input["default_value"] instanceof Array != need_vec_in) {
	            m_print.warn("Wrong inputs for custom node group \"" +
	                bpy_node["name"] + "\" of type: \"", node_name, "\"." +
	                "Processing as general node group.");
	            return false;
	        }
	    }
	    for (var i = 0; i < outputs_map.length; i++) {
	        var output = bpy_outputs[i];
	        var need_vec_out = outputs_map[i];
	        if (!output || output["default_value"] instanceof Array != need_vec_out) {
	            m_print.warn("Wrong outputs for custom node group \"" +
	                bpy_node["name"] + "\" of type: \"", node_name, "\"." +
	                "Processing as general node group.");
	            return false;
	        }
	    }

	    return true;
	}

	function process_node_group(bpy_node, shader_type, active_layer_names) {
	    // NOTE: Node tree is cloned here for a node group to prevent modifying the 
	    // source node tree. Modifying is needed to store some information about the 
	    // node group because we don't create a graph for it and just gather the 
	    // corresponding data.
	    var node_tree = clone_node_tree(bpy_node["node_group"]["node_tree"]);

	    var node_name = bpy_node["node_tree_name"];

	    if (node_name == "B4W_REPLACE" || node_name == "B4W_LEVELS_OF_QUALITY") {
	        var gi = init_bpy_node("Group input", "GROUP_INPUT", [], bpy_node["inputs"]);
	        var go = init_bpy_node("Group output", "GROUP_OUTPUT", bpy_node["outputs"], []);

	        var link = null;
	        if (node_name == "B4W_REPLACE" ||
	            node_name == "B4W_LEVELS_OF_QUALITY" &&
	            (cfg_def.quality == m_cfg.P_LOW || cfg_def.force_low_quality_nodes)) {
	            link = init_bpy_link(gi, gi["outputs"][1], go, go["inputs"][0]);
	        } else
	            link = init_bpy_link(gi, gi["outputs"][0], go, go["inputs"][0]);

	        node_tree["nodes"] = [gi, go];
	        node_tree["links"] = [link];
	    }

	    rename_node_group_nodes(bpy_node["name"], node_tree);
	    var ngraph_proxy_group = compose_ngraph_proxy_rec(node_tree,
	            bpy_node["node_group"]["uuid"], true, shader_type, active_layer_names);
	    var data = {
	        node_group_graph: ngraph_proxy_group.graph,
	        node_group_links: node_tree["links"]
	    };
	    return data;
	}

	function reset_shader_ident_counters() {
	    _shader_ident_counters = {};
	}

	function copy_obj(obj) {
	    var type = typeof(obj);
	    if (type == "string" || type == "number" || type == "boolean" || !obj)
	        return obj;
	    return m_util.clone_object_nr(obj);
	}

	function clone_node_tree(tree) {
	    var new_tree = {};

	    for (var i in tree) {
	        if (i == "links" || i == "nodes") {
	            new_tree[i] = [];
	            for (var j = 0; j < tree[i].length; j++) {
	                new_tree[i][j] = {};
	                for (var k in tree[i][j]) {
	                    if (i == "links") {
	                        new_tree[i][j][k] = {};
	                        for (var l in tree[i][j][k])
	                            new_tree[i][j][k][l] = copy_obj(tree[i][j][k][l]);
	                    } else
	                        new_tree[i][j][k] = copy_obj(tree[i][j][k]);
	                }
	            }
	        } else
	            new_tree[i] = copy_obj(tree[i]);
	    }

	    return new_tree;
	}

	/**
	 * Compose unique shader identifier based on given name.
	 */
	function shader_ident(name_base) {
	    if (!_shader_ident_counters[name_base])
	        _shader_ident_counters[name_base] = 0;

	    var name = name_base + "_" + _shader_ident_counters[name_base];
	    // remove slash and space symbols
	    name = name.replace(/ /g, "_").replace(/\//g, "_");

	    _shader_ident_counters[name_base]++;

	    return name;
	}

	function check_input_node_outputs(bpy_node) {
	    var outputs = bpy_node["outputs"];
	    for (var i = 0; i < outputs.length; i++) {
	        var output = outputs[i];
	        if (output["is_linked"])
	            return true;
	    }
	    return false;
	}

	function geometry_node_type(bpy_node, output_num) {
	    var outputs = bpy_node["outputs"];
	    var out_counter = 0;
	    for (var i = 0; i < outputs.length; i++) {
	        var output = outputs[i];

	        if (!output["is_linked"])
	            continue;

	        if ((out_counter++) < output_num)
	            continue;

	        switch (output["identifier"]) {
	        case "UV":
	            return "GEOMETRY_UV";
	        case "Vertex Color":
	            return "GEOMETRY_VC";
	        case "Normal":
	            return "GEOMETRY_NO";
	        case "True Normal":
	            return "GEOMETRY_TRN";
	        case "Front/Back":
	            return "GEOMETRY_FB";
	        case "View":
	            return "GEOMETRY_VW";
	        case "Global":
	        case "Position":
	            return "GEOMETRY_GL";
	        case "Local":
	            return "GEOMETRY_LO";
	        case "Orco":
	            return "GEOMETRY_OR";
	        case "Incoming":
	            return "GEOMETRY_IN";
	        case "Backfacing":
	            return "GEOMETRY_BF";
	        default:
	            return null;
	        }
	    }
	}

	function tex_coord_node_type(bpy_node, output_num) {
	    var outputs = bpy_node["outputs"];
	    var out_counter = 0;
	    for (var i = 0; i < outputs.length; i++) {
	        var output = outputs[i];

	        if (!output["is_linked"])
	            continue;

	        if ((out_counter++) < output_num)
	            continue;

	        switch (output["identifier"]) {
	        case "Camera":
	            return "TEX_COORD_CA";
	        case "Generated":
	            return "TEX_COORD_GE";
	        case "Normal":
	            return "TEX_COORD_NO";
	        case "Object":
	            return "TEX_COORD_OB";
	        case "Reflection":
	            return "TEX_COORD_RE";
	        case "UV":
	            return "TEX_COORD_UV";
	        case "Window":
	            return "TEX_COORD_WI";
	        default:
	            return null;
	        }
	    }
	}

	function node_output_check_next(bpy_node, output_num) {
	    var outputs = bpy_node["outputs"];
	    var out_counter = 0;
	    for (var i = 0; i < outputs.length; i++) {
	        var output = outputs[i];

	        if (!output["is_linked"])
	            continue;

	        // next linked available
	        if ((out_counter++) > output_num)
	            return true;
	    }

	    return false;
	}


	function texture_node_type(bpy_node) {
	    if (!bpy_node["texture"] || !bpy_node["texture"]._render)
	        return "TEXTURE_EMPTY";

	    var outputs = bpy_node["outputs"];
	    var node_color  = false;
	    var node_normal = false;
	    var node_value  = false;
	    for (var i = 0; i < outputs.length; i++) {
	        var output = outputs[i];

	        if (!output["is_linked"])
	            continue;

	        var ident = output["identifier"];

	        switch (ident) {
	        case "Color":
	            node_color = true;
	            break;
	        case "Normal":
	            node_normal = true;
	            break;
	        case "Value":
	            node_value = true;
	            break;
	        default:
	            m_util.panic("Unknown texture output");
	        }
	    }

	    if (node_color) {
	        if (node_normal)
	            m_print.warn("Node \"" + bpy_node["name"] + "\" has both Color " +
	                         "and Normal outputs. Normal will be omitted.");

	        if (bpy_node["texture"]["type"] == "ENVIRONMENT_MAP")
	            return "TEXTURE_ENVIRONMENT_CUBE";
	        else
	            return "TEXTURE_COLOR";

	    } else if (node_normal) {
	        return "TEXTURE_NORMAL"

	    } else if (node_value) {
	        if (bpy_node["texture"]["type"] == "ENVIRONMENT_MAP")
	            return "TEXTURE_ENVIRONMENT_CUBE";
	        else
	            return "TEXTURE_COLOR";
	    }
	}

	function node_input_by_ident(bpy_node, ident) {
	    var inputs = bpy_node["inputs"];
	    for (var i = 0; i < inputs.length; i++) {
	        var input = inputs[i];

	        if (input["identifier"] == ident)
	            return node_inout_bpy_to_b4w(input);
	    }
	    return null;
	}

	function node_output_by_ident(bpy_node, ident) {
	    var outputs = bpy_node["outputs"];
	    for (var i = 0; i < outputs.length; i++) {
	        var output = outputs[i];

	        if (output["identifier"] == ident)
	            return node_inout_bpy_to_b4w(output);
	    }
	    return null;
	}

	function node_inout_bpy_to_b4w(bpy_node_inout) {
	    return {
	        name: bpy_node_inout["name"],
	        identifier: bpy_node_inout["identifier"],
	        is_linked: bpy_node_inout["is_linked"],
	        default_value: bpy_to_b4w_value(bpy_node_inout["default_value"])
	    }
	}

	function default_node_inout(name, identifier, default_value, is_linked) {
	    return {
	        name: name,
	        identifier: identifier,
	        is_linked: is_linked,
	        default_value: default_value
	    }
	}

	function clone_node_inout(node_inout) {
	    return default_node_inout(node_inout.name, node_inout.identifier,
	        node_inout.default_value, node_inout.is_linked);
	}

	function bpy_to_b4w_value(value) {

	    if (m_util.is_vector(value))
	        return value.slice(0);

	    return value;
	}

	function node_inputs_bpy_to_b4w(bpy_node) {
	    var inputs = [];

	    for (var i = 0; i < bpy_node["inputs"].length; i++) {
	        var input = node_inout_bpy_to_b4w(bpy_node["inputs"][i]);
	        // NOTE: trim all vec4 to vec3
	        if (input.default_value.length)
	            input.default_value.splice(3);
	        inputs.push(input);
	    }

	    return inputs;
	}

	function node_outputs_bpy_to_b4w(bpy_node) {
	    var outputs = [];

	    for (var i = 0; i < bpy_node["outputs"].length; i++) {
	        var output = node_inout_bpy_to_b4w(bpy_node["outputs"][i]);
	        outputs.push(output);
	    }

	    return outputs;
	}


	/**
	 * value = null - do not assign param value
	 */
	function node_param(name, value, dim) {

	    if (value === null || value === undefined)
	        var pval = null;
	    else
	        var pval = m_shaders.glsl_value(value, dim);

	    var param = {
	        name: name,
	        value: pval
	    };

	    return param;
	}

	function clone_node_param(param) {
	    var new_param = {
	        name: param.name,
	        value: param.value
	    };

	    return new_param;
	}

	function replace_zero_unity_vals(str_val) {
	    // HACK: for better global replacing
	    str_val = str_val.replace(/(,)/g, "$1 ");

	    str_val = str_val.replace(/(^|[^0-9]|\s)(0\.0)($|[^0-9]|\s)/g, "$1_0_0$3");
	    str_val = str_val.replace(/(^|[^0-9]|\s)(1\.0)($|[^0-9]|\s)/g, "$1_1_0$3");
	    str_val = str_val.replace(/\s+/g, "");

	    return str_val;
	}

	function clone_nmat_edge_attr(nmat_edge_attr) {
	    return nmat_edge_attr.slice();
	}

	function append_nmat_edge(graph, id1, id2, attr1, attr2, bpy_link) {
	    // pair [node1_output_index, node2_input_index]
	    var attr = [];

	    var ident1 = bpy_link["from_socket"]["identifier"];
	    var ident2 = bpy_link["to_socket"]["identifier"];

	    var outputs1 = attr1.outputs;
	    for (var i = 0; i < outputs1.length; i++) {
	        var out1 = outputs1[i];
	        if (out1.identifier == ident1) {
	            attr.push(i);
	            break;
	        }
	    }

	    var inputs2 = attr2.inputs;
	    for (var i = 0; i < inputs2.length; i++) {
	        var in2 = inputs2[i];
	        if (in2.identifier == ident2) {
	            attr.push(i);
	            break;
	        }
	    }

	    if (attr.length == 2)
	        m_graph.append_edge(graph, id1, id2, attr);

	    return true;
	}

	/**
	 * Compose node elements for use in shader
	 */
	exports.compose_node_elements = function(graph) {

	    var node_elements = [];

	    var node_elem_map = {};

	    reset_shader_ident_counters();

	    var sgraph = m_graph.topsort(graph);
	    m_graph.traverse(sgraph, function(id, attr) {
	        var elem = init_node_elem(attr);
	        node_elements.push(elem);
	        node_elem_map[id] = elem;
	    });

	    m_graph.traverse_edges(sgraph, function(id1, id2, attr) {
	        var node1 = m_graph.get_node_attr(sgraph, id1);
	        var out1 = node1.outputs[attr[0]];

	        var elem1_outputs = node_elem_map[id1].outputs;
	        var elem2_inputs = node_elem_map[id2].inputs;
	        // name after (unique) node output
	        var name = elem1_outputs[attr[0]] ||
	                shader_ident("out_" + node1.type + "_" 
	                        + normalize_socket_ident(out1.identifier));

	        elem1_outputs[attr[0]] = name;
	        elem2_inputs[attr[1]] = name;
	    });
	    return node_elements;
	};

	function init_node_elem(mat_node) {

	    var finputs = [];
	    var finput_values = [];

	    var foutputs = [];

	    var fparams = [];
	    var fparam_values = [];

	    var vparams = [];

	    for (var i = 0; i < mat_node.inputs.length; i++) {
	        var input = mat_node.inputs[i];

	        if (input.is_linked) {
	            finputs.push(null);
	            finput_values.push(null);
	        } else {
	            finputs.push(shader_ident("in_" + mat_node.type + "_" 
	                    + normalize_socket_ident(input.identifier)));

	            var input_val = m_shaders.glsl_value(input.default_value, 0);
	            // HACK: too many vertex shader constants issue
	            if (cfg_def.shader_constants_hack)
	                if (mat_node.type.indexOf("MIX_RGB_") >= 0
	                        && (input.identifier == "Color1"
	                        || input.identifier == "Color2"
	                        || input.identifier == "Fac") ||
	                        mat_node.type.indexOf("MATH_") >= 0
	                        && (input.identifier == "Value"
	                        || input.identifier == "Value_001"
	                        || input.identifier == "Value.001") ||
	                        mat_node.type.indexOf("VECT_MATH_") >= 0
	                        && (input.identifier == "Vector_001"
	                        || input.identifier == "Vector.001") ||
	                        mat_node.type.indexOf("LIGHTING_APPLY") >= 0 ||
	                        mat_node.type.indexOf("MATERIAL_END") >= 0 ||
	                        mat_node.type.indexOf("MATERIAL_BEGIN") >= 0)
	                    input_val = replace_zero_unity_vals(input_val);

	            finput_values.push(input_val);
	        }
	    }

	    for (var i = 0; i < mat_node.outputs.length; i++) {
	        var output = mat_node.outputs[i];

	        if (output.is_linked)
	            foutputs.push(null);
	        else
	            foutputs.push(shader_ident("out_" + mat_node.type + "_" 
	                    + normalize_socket_ident(output.identifier)));
	    }

	    for (var i = 0; i < mat_node.params.length; i++) {
	        var param = mat_node.params[i];
	        fparams.push(param.name);
	        fparam_values.push(param.value);
	    }

	    for (var i = 0; i < mat_node.vparams.length; i++) {
	        var vparam = mat_node.vparams[i];
	        vparams.push(vparam.name);
	    }

	    var elem = {
	        id: mat_node.type,
	        inputs: finputs,
	        input_values: finput_values,
	        outputs: foutputs,
	        params: fparams,
	        param_values: fparam_values,
	        vparams: vparams,
	        dirs: JSON.parse(JSON.stringify(mat_node.dirs)) // deep copy
	    };

	    return elem;
	}

	function normalize_socket_ident(node_identifier) {
	    // NOTE: sometimes node sockets may have identifiers with the ".00N" postfix 
	    // for an unknown reason, make it just "00N"
	    return node_identifier.replace(/\./g, "");
	}

	function create_new_name(type, group_name, name) {
	    if (type == "GROUP_INPUT")
	        return group_name + "*GI*" + name;      // for search
	    else if (type == "GROUP_OUTPUT")
	        return group_name + "*GO*" + name;
	    return group_name + "%join%" + name;
	}

	function rename_node_group_nodes(node_group_name, node_tree) {
	    var nodes = node_tree["nodes"];
	    var links = node_tree["links"];
	    for (var i = 0; i < nodes.length; i++)
	        nodes[i]["name"] = create_new_name(nodes[i].type, node_group_name, nodes[i].name);
	    for (var i = 0; i < links.length; i++) {
	        links[i]["from_node"]["name"] = create_new_name(links[i]["from_node"]["type"],
	                                                node_group_name, links[i]["from_node"]["name"]);
	        links[i]["to_node"]["name"] = create_new_name(links[i]["to_node"]["type"],
	                                                node_group_name, links[i]["to_node"]["name"]);
	    }
	}

	function trace_group_nodes(graph){
	    var node_groups = [];
	    m_graph.traverse(graph, function(id, node) {
	        if (node["type"] == "GROUP")
	            node_groups.push(node);
	    });
	    return node_groups;
	}

	function append_node_groups_graphs(graph, links, node_groups) {
	    for (var i = 0; i < node_groups.length; i++) {
	        var node_group_graph = node_groups[i].data.node_group_graph;
	        var node_group_links = node_groups[i].data.node_group_links;
	        if (!node_group_graph)
	            return false;

	        m_graph.traverse(node_group_graph, function(id, node) {
	            m_graph.append_node(graph, m_graph.gen_node_id(graph), node);
	        });

	        for (var j = 0; j < node_group_links.length; j++)
	            links.push(node_group_links[j]);

	        change_node_groups_links(node_groups[i], links, graph);
	    }
	    return true;
	}

	function distribute_link(property, group_name, link, node_group_links,
	                    node_group_input_links, node_group_output_links) {
	    switch (property.type) {
	    case "GROUP":
	        if (property["name"] == group_name)
	            node_group_links.push(link);
	        break;
	    case "GROUP_INPUT":
	        if (!property["name"].indexOf(group_name + "*GI*"))
	            node_group_input_links.push(link);
	        break;
	    case "GROUP_OUTPUT":
	        if (!property["name"].indexOf(group_name + "*GO*"))
	            node_group_output_links.push(link);
	        break;
	    }
	}

	// change links, return links for cut
	function relink(links, input_links, output_links) {
	    var unused_links = [];
	    for (var i = 0; i < output_links.length; i++) {
	        var output = output_links[i];
	        var input = null;
	        for (var j = 0; j < input_links.length; j++)
	            if (output["from_socket"]["identifier"] ==
	                input_links[j]["to_socket"]["identifier"]) {
	                input = input_links[j];
	                break;
	            }
	        if (input) {
	            output["from_node"] = input["from_node"];
	            output["from_socket"] = input["from_socket"];
	        } else
	            unused_links.push(output);
	    }
	    // remove links to node group or to group_output
	    for (var i = 0; i < input_links.length; i++)
	        links.splice(links.indexOf(input_links[i]), 1);
	    return unused_links;
	}

	function add_unused_input_links(links, unused_links) {
	    if (!unused_links.length)
	        return;
	    var gi_name = unused_links[0]["from_node"]["name"];
	    for (var i = 0; i < links.length; i++)
	        if (links[i]["from_node"]["name"] == gi_name)
	            unused_links.push(links[i]);
	}

	function set_input_default_value(link, graph, value) {
	    var node_ids = nmat_node_ids(link["to_node"], graph);
	    for (var i = 0; i < node_ids.length; i++) {
	        var node_attr = m_graph.get_node_attr(graph, node_ids[i]);
	        for (var j = 0; j < node_attr.inputs.length; j++) {
	            var input = node_attr.inputs[j];
	            if (input.identifier == link["to_socket"]["identifier"]) {

	                var old_val_type = get_socket_value_type(input.default_value);
	                var new_val_type = get_socket_value_type(value);

	                if (new_val_type == old_val_type)
	                    input.default_value = value;
	                else
	                    switch (old_val_type) {
	                    case VECTOR_VALUE:
	                        scalar_to_vector(value, input.default_value);
	                        break;
	                    case SCALAR_VALUE:
	                        input.default_value = vector_to_scalar(value);
	                        break;
	                    }

	                break;
	            }
	        }
	    }
	}

	function change_default_values(links, graph, node, unused_links) {
	    for (var i = 0; i < unused_links.length; i++) {
	        var link = unused_links[i];
	        var value;
	        for (var j = 0; j < node.inputs.length; j++)
	            if (link["from_socket"]["identifier"] == node.inputs[j].identifier) {
	                value = node.inputs[j].default_value;
	                break;
	            }
	        set_input_default_value(link, graph, value);
	        var index = links.indexOf(link);
	        if (index != -1)
	            links.splice(index, 1);
	    }
	}

	// get type for a node input/output.
	function get_socket_value_type(value) {
	    return value instanceof Object ? VECTOR_VALUE : SCALAR_VALUE;
	}

	// convert scalar socket value to vector
	function scalar_to_vector(scalar, vector) {
	    vector[0] = vector[1] = vector[2] = scalar;
	    return vector;
	}

	// convert vector socket value to scalar
	function vector_to_scalar(vector) {
	    return (vector[0] + vector[1] + vector[2]) / 3.0;
	}

	function change_node_groups_links(node, links, graph) {
	    var group_name = node.name;

	    var node_group_links_from = [];     // node outputs
	    var node_group_links_to = [];       // node inputs
	    var node_group_input_links = [];
	    var node_group_output_links = [];

	    // find links to/from node_group, group_input, group_output
	    for (var i = 0; i < links.length; i++) {
	        var link = links[i];
	        distribute_link(link["from_node"], group_name, link, node_group_links_from,
	            node_group_input_links, node_group_output_links);
	        distribute_link(link["to_node"], group_name, link, node_group_links_to,
	            node_group_input_links, node_group_output_links);
	    }
	    // remove links to node_group; connect group_input links to nodes of removed links
	    var unused_input_links = relink(links, node_group_links_to, node_group_input_links);
	    // remove links to group_output; connect links from node_group to nodes of removed links
	    var unused_output_links = relink(links, node_group_output_links, node_group_links_from);
	    // if last relink makes new links with group input
	    add_unused_input_links(links, unused_input_links);

	    // change default value of group nodes connected to group_input
	    change_default_values(links, graph, node, unused_input_links);
	    // change default value of node with links from node_group
	    if (unused_output_links.length) {
	        var output_node;
	        m_graph.traverse(graph, function(id, node) {
	            if (node.type == "GROUP_OUTPUT" &&
	                !node.name.indexOf(group_name + "*GO*"))
	                output_node = node;
	        });
	        change_default_values(links, graph, output_node, unused_output_links);
	    }
	}

	exports.check_material_glow_output = function(mat) {
	    if (mat.node_tree)
	        for (var i = 0; i < mat.node_tree["nodes"].length; i++) {
	            var node = mat.node_tree["nodes"][i];
	            if (node.type == "GROUP" && node["node_tree_name"] == "B4W_GLOW_OUTPUT")
	                return true;
	        }
	    return false;
	};

	exports.print_node_graph = print_node_graph;
	function print_node_graph(node_graph, mat_user_name, mat_name) {
	    m_print.log("\n====== USER: " + mat_user_name + ", MATERIAL: " 
	            + mat_name + " ======" 
	            + "\n" + m_debug.nodegraph_to_dot(node_graph, true)
	            + "\n=============================================================");
	}

	exports.cleanup = cleanup;
	function cleanup() {
	    for (var graph_id in _composed_ngraph_proxies) {
	        delete _composed_ngraph_proxies[graph_id];
	    }
	    for (var graph_id in _composed_stack_graphs) {
	        delete _composed_stack_graphs[graph_id];
	    }

	    for (var key in _lamp_indexes)
	        delete _lamp_indexes[key];
	    _lamp_index = 0;
	}

	function create_node_textures(nmat_graph) {
	    var color_ramp_nodes = [];
	    var curves_nodes = [];
	    m_graph.traverse(nmat_graph, function(node, attr) {
	        switch (attr.type) {
	        case "VALTORGB":
	            color_ramp_nodes.push(attr);
	            break;
	        case "CURVE_VEC":
	        case "CURVE_RGB":
	            curves_nodes.push(attr);
	            break;
	        }
	    });
	    var row = 0;
	    var col_ramp_data = null;
	    var curve_data = null;
	    var length = color_ramp_nodes.length + curves_nodes.length;
	    if (color_ramp_nodes.length) {
	        col_ramp_data = m_tex.extract_col_ramps_data(color_ramp_nodes,
	                m_tex.COLORRAMP_TEXT_SIZE);
	        for (var i = 0; i < color_ramp_nodes.length; i++) {
	            color_ramp_nodes[i].dirs.push(["NODE_TEX_ROW", m_shaders.glsl_value((row + 0.5) /
	                    length)]);
	            row++;
	        }
	    }
	    if (curves_nodes.length) {
	        curve_data = m_tex.extract_vec_curves_data(curves_nodes,
	                m_tex.CURVE_NODES_TEXT_SIZE);
	        for (var i = 0; i < curves_nodes.length; i++) {
	            curves_nodes[i].dirs.push(["NODE_TEX_ROW", m_shaders.glsl_value((row + 0.5) /
	                    length)]);
	            row++;
	        }
	    }
	    var image_data = null;
	    if (col_ramp_data && curve_data) {
	        image_data = new Uint8Array(col_ramp_data.length + curve_data.length);
	        image_data.set(col_ramp_data);
	        image_data.set(curve_data, col_ramp_data.length);
	    } else if (col_ramp_data)
	        image_data = col_ramp_data;
	    else
	        image_data = curve_data;

	    if (image_data)
	        var tex = m_tex.create_color_ramp_texture(image_data, m_tex.CURVE_NODES_TEXT_SIZE);
	    else
	        var tex = null;

	    for (var i = 0; i < color_ramp_nodes.length; i++)
	        color_ramp_nodes[i].data.texture = tex;
	    for (var i = 0; i < curves_nodes.length; i++)
	        curves_nodes[i].data.texture = tex;
	}

	exports.get_max_env_texture_height = get_max_env_texture_height;
	function get_max_env_texture_height(graph) {
	    var max_height = -1;
	    m_graph.traverse(graph, function(id, node) {
	        if (node.type == "TEXTURE_ENVIRONMENT_EQUIRECTANGULAR" || node.type == "TEXTURE_ENVIRONMENT_MIRROR_BALL") {
	            var tex_height = node.data.value.height;
	            max_height = Math.max(max_height, tex_height);
	        }
	    });

	    return  max_height;
	}

	function check_curve_usage(bpy_node, ind, start, end) {
	    var curve = bpy_node["curve_mapping"]["curves_data"][ind];
	    if (curve.length == 2 && curve[0][0] < start + CURVE_POINT_EPS
	            && curve[0][1] < start + CURVE_POINT_EPS 
	            && curve[1][0] > end - CURVE_POINT_EPS
	            && curve[1][1] > end - CURVE_POINT_EPS)
	        return false;
	    return true;
	}

	}

	var int_nodemat_factory = register("__nodemat", Int_nodemat);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Batch internal API.
	 * @name batch
	 * @namespace
	 * @exports exports as batch
	 */
	function Int_batch(ns, exports) {

	var m_bounds     = int_boundings_factory(ns);
	var m_cfg        = int_config_factory(ns);
	var m_print      = print_factory(ns);
	var m_extensions = int_extensions_factory(ns);
	var m_graph      = int_graph_factory(ns);
	var m_mat3       = mat3_factory(ns);
	var m_nodemat    = int_nodemat_factory(ns);
	var m_obj_util   = int_obj_util_factory(ns);
	var m_particles  = int_particles_factory(ns);
	var m_primitives = int_primitives_factory(ns);
	var m_quat       = quat_factory(ns);
	var m_reformer   = int_reformer_factory(ns);
	var m_render     = int_renderer_factory(ns);
	var m_scenegraph = int_scenegraph_factory(ns);
	var m_shaders    = int_shaders_factory(ns);
	var m_subs       = int_subscene_factory(ns);
	var m_textures   = int_textures_factory(ns);
	var m_tsr        = int_tsr_factory(ns);
	var m_geom       = int_geometry_factory(ns);
	var m_util       = int_util_factory(ns);
	var m_vec3       = vec3_factory(ns);
	var m_vec4       = vec4_factory(ns);

	var cfg_def = m_cfg.defaults;
	var cfg_lim = m_cfg.context_limits;
	var cfg_scs = m_cfg.scenes;
	var cfg_hmd = m_cfg.hmd_params;

	var DEBUG_SAVE_SUBMESHES = false;
	var DEBUG_KEEP_BUFS_DATA_ARRAYS = false;
	var DEBUG_DO_NOT_BATCH = false;

	var STREE_CELL_COUNT = 20;

	// rotation quat around Z axis for particles system
	var DEFAULT_PART_SYS_QUAT = new Float32Array([0, 0, -Math.sqrt(0.5), Math.sqrt(0.5)]);

	var MAX_PARTICLES_COEF = 2 * 100 * 1000;
	var SINGLE_INST_ARR = 1;
	var WH_GR_INST_ARR = 2;

	var _vec3_tmp = new Float32Array(3);
	var _vec3_tmp2 = new Float32Array(3);
	var _vec3_tmp3 = new Float32Array(3);
	var _vec4_tmp = new Float32Array(4);

	var _tsr_tmp = m_tsr.create();
	var _mat3_tmp = m_mat3.create();

	var _batch_debug_storage = {};

	var _bb_corners_tmp = new Float32Array(24);

	exports.batch_get_debug_storage = batch_get_debug_storage;
	function batch_get_debug_storage(batch_id) {
	    return _batch_debug_storage[batch_id] || null;
	}

	exports.batch_set_debug_storage = batch_set_debug_storage;
	function batch_set_debug_storage(batch_id, value) {
	    _batch_debug_storage[batch_id] = value;
	}

	/**
	 * Create abstract batch
	 */
	function init_batch(type) {

	    // initialize properties (do not consider values as default!)
	    var batch = {
	        type: type,
	        subtype: "",

	        id: 0,
	        data_id: 0,
	        cluster_id: -1,
	        odd_id_prop: "",

	        // properties for DEBUG_VIEW batch
	        debug_id_color: -1,
	        debug_main_batch_id: -1, // link to the MAIN batch with the same material
	        debug_main_batch_render_time: 0,
	        debug_render_time: 0,
	        debug_render_time_queries: [],

	        textures: [],
	        texture_names: [],
	        bpy_tex_names: [],
	        material_names: [],

	        common_attributes: [],
	        uv_maps_usage: null,
	        vertex_colors_usage: {},

	        shader: null,
	        shaders_info: m_shaders.init_shaders_info(),
	        ngraph_proxy_id: "",
	        attribute_setters: [],
	        bufs_data: null,
	        vaos: m_util.create_non_smi_array(),

	        use_shape_keys: false,

	        debug_sphere: false,
	        debug_sphere_dynamic: false,
	        num_vertices: 0,
	        num_triangles: 0,
	        jitter_amp: 0,
	        jitter_freq: 0,
	        dynamic_grass: false,
	        grass_scale_threshold: 0,
	        grass_size: 0,
	        grass_map_dim: new Float32Array(3),
	        cube_fog: new Float32Array(16),

	        // rendering properties
	        alpha_clip: false,
	        alpha_antialiasing: false,
	        blend: false,
	        depth_mask: false,
	        xray: false,
	        use_backface_culling: false,
	        use_shadeless: false,
	        dynamic_geometry: false,
	        shadow_cast: false,
	        shadow_cast_only: false,
	        shadow_receive: false,
	        reflexible: false,
	        reflexible_only: false,
	        reflective: false,
	        draw_mode: m_geom.DM_DEFAULT,
	        z_sort: false,
	        forked_batch : false,
	        do_not_cull: false,
	        caustics: false,

	        lod_dist_max: m_obj_util.LOD_DIST_MAX_INFINITY,
	        lod_dist_min: 0,
	        lod_lower_border_range: 0,
	        lod_upper_border_range: 0,

	        lod_settings: init_lod_settings(),

	        cube_reflection_id: -1,
	        plane_reflection_id: -1,

	        // halo material properties
	        halo: false,
	        halo_size: 0,
	        halo_hardness: 0,
	        halo_stars_blend: 0,
	        halo_stars_height: 0,
	        halo_rings_color: new Float32Array(3),
	        halo_lines_color: new Float32Array(3),

	        halo_particles: false,

	        // common material/texture properties
	        ambient: 0,
	        emit: 0,
	        diffuse_intensity: 1,
	        reflect_factor: 0,
	        specular_color_factor: 0,
	        specular_alpha: 1,
	        parallax_scale: 0,
	        diffuse_color_factor: 0,
	        alpha_factor: 1,
	        normal_factor: 0,
	        mirror_factor: 0,
	        offset_z: 0,
	        refr_bump: 0,
	        diffuse_params: new Float32Array(2),
	        specular_params: new Float32Array(3),
	        texture_scale: new Float32Array(3),
	        specular_color: new Float32Array(3),
	        diffuse_color: new Float32Array(4),
	        fresnel_params: new Float32Array(2),
	        lamp_uuid_indexes: null,
	        lamp_light_positions: null,
	        lamp_light_directions: null,
	        lamp_light_color_intensities: null,
	        has_nodes: false,

	        wireframe_edge_color: m_vec3.create(),

	        // water material properties
	        water: false,
	        water_dynamic: false,
	        water_shore_smoothing: false,
	        water_generated_mesh: false,
	        water_num_cascads: 0,
	        water_subdivs: 0,
	        water_detailed_dist: 0,
	        water_norm_uv_velocity: 0.1,
	        shallow_water_col_fac: 0,
	        shore_water_col_fac: 0,
	        foam_factor: 0,
	        foam_uv_freq: new Float32Array(2),
	        foam_mag: new Float32Array(2),
	        foam_scale: new Float32Array(2),
	        shallow_water_col: new Float32Array(3),
	        shore_water_col: new Float32Array(3),
	        normalmap_scales: null,
	        refractive: false,

	        // sky-specific properties
	        is_sky: false,
	        draw_proc_sky: false,

	        // emitter particles data
	        particles_data: null,

	        // line params
	        line_width: 0,

	        // anchor params
	        anchor_positions: null,

	        part_node_data : null,

	        node_values: [],
	        node_value_inds: [],
	        node_rgbs: [],
	        node_rgb_inds: [],

	        bounds_local: m_bounds.init_boundings(),
	        use_be: false,

	        submesh: null,

	        cleanup_gl_data_on_unload: true,

	        inst_array_state: 0,

	        obj_info_params: new Float32Array(3)
	    };

	    // setting default values
	    batch.diffuse_color[3] = 1;
	    batch.depth_mask = true;
	    batch.line_width = 1.0;
	    batch.lod_settings.hyst_prev_state = -1;

	    return batch;
	}

	exports.clone_batch = clone_batch;
	function clone_batch(batch) {

	    var batch_new = init_batch(batch.type);

	    batch_new.subtype = batch.subtype;

	    batch_new.id = batch.id;
	    batch_new.cluster_id = batch.cluster_id;
	    batch_new.odd_id_prop = batch.odd_id_prop;

	    // properties for DEBUG_VIEW batch
	    batch_new.debug_id_color = batch.debug_id_color;
	    batch_new.debug_main_batch_id = batch.debug_main_batch_id;
	    batch_new.debug_main_batch_render_time = batch.debug_main_batch_render_time;
	    batch_new.debug_render_time = batch.debug_render_time;
	    batch_new.debug_render_time_queries = [];

	    batch_new.textures = batch.textures.slice();
	    batch_new.texture_names = batch.texture_names.slice();
	    batch_new.bpy_tex_names = batch.bpy_tex_names.slice();
	    batch_new.material_names = batch.material_names.slice();

	    batch_new.common_attributes = batch.common_attributes.slice();
	    batch_new.uv_maps_usage = m_util.clone_object_r(batch.uv_maps_usage);
	    batch_new.vertex_colors_usage = m_util.clone_object_r(batch.vertex_colors_usage);

	    // NOTE: by link
	    batch_new.shader = batch.shader;
	    batch_new.shaders_info = m_shaders.clone_shaders_info(batch.shaders_info);

	    batch_new.ngraph_proxy_id = batch.ngraph_proxy_id;
	    batch_new.attribute_setters =
	            m_render.clone_attribute_setters(batch.attribute_setters);
	    // NOTE: by link
	    batch_new.bufs_data = batch.bufs_data;

	    batch_new.use_shape_keys = batch.use_shape_keys;

	    batch_new.debug_sphere = batch.debug_sphere;
	    batch_new.debug_sphere_dynamic = batch.debug_sphere_dynamic;
	    batch_new.num_vertices = batch.num_vertices;
	    batch_new.num_triangles = batch.num_triangles;
	    batch_new.jitter_amp = batch.jitter_amp;
	    batch_new.jitter_freq = batch.jitter_freq;
	    batch_new.grass_scale_threshold = batch.grass_scale_threshold;
	    batch_new.grass_size = batch.grass_size;
	    // NOTE: a link from subscene
	    batch_new.grass_map_dim = batch.grass_map_dim;
	    // NOTE: a link from subscene
	    batch_new.cube_fog = batch.cube_fog;

	    // rendering properties
	    batch_new.alpha_clip = batch.alpha_clip;
	    batch_new.alpha_antialiasing = batch.alpha_antialiasing;
	    batch_new.blend = batch.blend;
	    batch_new.depth_mask = batch.depth_mask;
	    batch_new.xray = batch.xray;
	    batch_new.use_backface_culling = batch.use_backface_culling;
	    batch_new.use_shadeless = batch.use_shadeless;
	    batch_new.dynamic_geometry = batch.dynamic_geometry;
	    batch_new.shadow_cast = batch.shadow_cast;
	    batch_new.shadow_cast_only = batch.shadow_cast_only;
	    batch_new.shadow_receive = batch.shadow_receive;
	    batch_new.reflexible = batch.reflexible;
	    batch_new.reflexible_only = batch.reflexible_only;
	    batch_new.reflective = batch.reflective;
	    batch_new.dynamic_grass = batch.dynamic_grass;
	    batch_new.draw_mode = batch.draw_mode;
	    batch_new.z_sort = batch.z_sort;
	    batch_new.forked_batch = batch.forked_batch;

	    batch_new.do_not_cull = batch.do_not_cull;
	    batch_new.caustics = batch.caustics;

	    batch_new.lod_dist_max = batch.lod_dist_max;
	    batch_new.lod_dist_min = batch.lod_dist_min;
	    batch_new.lod_lower_border_range = batch.lod_lower_border_range;
	    batch_new.lod_upper_border_range = batch.lod_upper_border_range;

	    batch_new.lod_settings = clone_batch_lod_settings(batch.lod_settings);

	    batch_new.cube_reflection_id = batch.cube_reflection_id;
	    batch_new.plane_reflection_id = batch.plane_reflection_id;

	    // halo material properties
	    batch_new.halo = batch.halo;
	    batch_new.halo_size = batch.halo_size;
	    batch_new.halo_hardness = batch.halo_hardness;
	    batch_new.halo_stars_blend = batch.halo_stars_blend;
	    batch_new.halo_stars_height = batch.halo_stars_height;
	    m_vec3.copy(batch.halo_rings_color, batch_new.halo_rings_color);
	    m_vec3.copy(batch.halo_lines_color, batch_new.halo_lines_color);

	    batch_new.halo_particles = batch.halo_particles;

	    // common material/texture properties
	    batch_new.ambient = batch.ambient;
	    batch_new.emit = batch.emit;
	    batch_new.diffuse_intensity = batch.diffuse_intensity;
	    batch_new.reflect_factor = batch.reflect_factor;
	    batch_new.specular_color_factor = batch.specular_color_factor;
	    batch_new.specular_alpha = batch.specular_alpha;
	    batch_new.parallax_scale = batch.parallax_scale;
	    batch_new.diffuse_color_factor = batch.diffuse_color_factor;
	    batch_new.alpha_factor = batch.alpha_factor;
	    batch_new.normal_factor = batch.normal_factor;
	    batch_new.mirror_factor = batch.mirror_factor;
	    batch_new.offset_z = batch.offset_z;
	    batch_new.refr_bump = batch.refr_bump;
	    batch_new.diffuse_params[0] = batch.diffuse_params[0];
	    batch_new.diffuse_params[1] = batch.diffuse_params[1];
	    m_vec3.copy(batch.specular_params, batch_new.specular_params);
	    m_vec3.copy(batch.texture_scale, batch_new.texture_scale);
	    m_vec3.copy(batch.specular_color, batch_new.specular_color);
	    m_vec4.copy(batch.diffuse_color, batch_new.diffuse_color);
	    batch_new.fresnel_params.set(batch.fresnel_params);

	    batch_new.lamp_uuid_indexes = m_util.clone_object_r(batch.lamp_uuid_indexes);
	    if (batch.lamp_light_positions) {
	        batch_new.lamp_light_positions = new Float32Array(batch.lamp_light_positions);
	        batch_new.lamp_light_directions = new Float32Array(batch.lamp_light_directions);
	        batch_new.lamp_light_color_intensities =
	                new Float32Array(batch.lamp_light_color_intensities);
	    }

	    batch_new.has_nodes = batch.has_nodes;

	    m_vec3.copy(batch.wireframe_edge_color, batch_new.wireframe_edge_color);

	    // water material properties
	    batch_new.water = batch.water;
	    batch_new.water_dynamic = batch.water_dynamic;
	    batch_new.water_shore_smoothing = batch.water_shore_smoothing;
	    batch_new.water_generated_mesh = batch.water_generated_mesh;
	    batch_new.water_num_cascads = batch.water_num_cascads;
	    batch_new.water_subdivs = batch.water_subdivs;
	    batch_new.water_detailed_dist = batch.water_detailed_dist;
	    batch_new.water_norm_uv_velocity = batch.water_norm_uv_velocity;
	    batch_new.shallow_water_col_fac = batch.shallow_water_col_fac;
	    batch_new.shore_water_col_fac = batch.shore_water_col_fac;
	    batch_new.foam_factor = batch.foam_factor;
	    batch_new.foam_uv_freq.set(batch.foam_uv_freq);
	    batch_new.foam_mag.set(batch.foam_mag);
	    batch_new.foam_scale.set(batch.foam_scale);
	    m_vec3.copy(batch.shallow_water_col, batch_new.shallow_water_col);
	    m_vec3.copy(batch.shore_water_col, batch_new.shore_water_col);
	    batch_new.normalmap_scales = m_util.clone_object_r(batch.normalmap_scales);
	    batch_new.refractive = batch.refractive;

	    // sky-specific properties
	    batch_new.is_sky = batch.is_sky;
	    batch_new.draw_proc_sky = batch.draw_proc_sky;

	    // emitter particles data
	    // NOTE: can be null
	    if (batch.particles_data)
	        batch_new.particles_data = m_particles.clone_particles_data(batch.particles_data);

	    // line params
	    batch_new.line_width = batch.line_width;

	    // anchor params
	    if (batch.anchor_positions)
	        batch_new.anchor_positions = new Float32Array(batch.anchor_positions);

	    batch_new.part_node_data = m_util.clone_object_r(batch.part_node_data);

	    batch_new.node_values = batch.node_values.slice();
	    batch_new.node_value_inds = batch.node_value_inds.slice();
	    batch_new.node_rgbs = batch.node_rgbs.slice();
	    batch_new.node_rgb_inds = batch.node_rgb_inds.slice();

	    m_bounds.copy_boundings(batch.bounds_local, batch_new.bounds_local);

	    batch_new.use_be = batch.use_be;

	    batch_new.cleanup_gl_data_on_unload = batch.cleanup_gl_data_on_unload;

	    batch_new.obj_info_params = batch.obj_info_params;

	    return batch_new;
	}

	function init_lod_settings() {
	    var lod_settings = {
	        use_smoothing: false,
	        coverage: 0,
	        cmp_logic: 0,
	        dest_coverage: 0, // for changing the coverage level over time

	        // for the distance check: <0 - was in front of this lod, >0 - was beyond 
	        // this lod, 0 - was at this lod
	        hyst_prev_state: 0,
	        // adaptive hysteresis intervals for dist_min and dist_max borders
	        hyst_interval_min: 0,
	        hyst_interval_max: 0,
	        // check distance to change LODs immediately without smoothing (teleporting case)
	        prev_dist: 0
	    };

	    lod_settings.cmp_logic = 1;

	    return lod_settings;
	}

	function clone_batch_lod_settings(lod_set) {
	    var new_lod_set = init_lod_settings();

	    new_lod_set.use_smoothing = lod_set.use_smoothing;
	    new_lod_set.coverage = lod_set.coverage;
	    new_lod_set.cmp_logic = lod_set.cmp_logic;
	    new_lod_set.dest_coverage = lod_set.dest_coverage;
	    new_lod_set.hyst_prev_state = lod_set.hyst_prev_state;
	    new_lod_set.hyst_interval_min = lod_set.hyst_interval_min;
	    new_lod_set.hyst_interval_max = lod_set.hyst_interval_max;
	    new_lod_set.prev_dist = lod_set.prev_dist;
	    return new_lod_set;
	}

	/**
	 * Generate object batches for graph subscenes.
	 * NOTE: bpy objects are expressly preferred than the new ones for the
	 * batching as parameters (as proxy objects) because of specific
	 * linking: bpy_obj._object->obj; nevertheless many "low-level" operations,
	 * some utility functions and the final batching actions rely on the new objects
	 */
	exports.generate_main_batches = function(scene, bpy_mesh_objects, lamps,
	        meta_objects) {

	    // create merged metabatches
	    var metabatches = make_metabatches(bpy_mesh_objects, scene._render.graph);
	    metabatches = merge_metabatches(metabatches);
	    for (var i = 0; i < metabatches.length; i++) {
	        var batch = metabatches[i].batch;

	        batch.material_names = metabatches[i].mat_names;
	        update_batch_geometry(batch, metabatches[i].submesh);
	        update_batch_lights(batch, lamps, scene);

	        if (metabatches[i].render.type == "STATIC" && batch.type != "COLOR_ID") {
	            // create meta-objects and attach static batches
	            var unique_name = m_util.unique_name("%meta%" + batch.type + "%" +
	                    batch.material_names.join("%") + "%");
	            var meta_obj = m_obj_util.create_object(unique_name, "MESH");
	            m_obj_util.meta_obj_append_render(meta_obj, metabatches[i].render);

	            m_obj_util.append_scene_data(meta_obj, scene);

	            m_obj_util.append_batch(meta_obj, scene, batch);
	            meta_objects.push(meta_obj);

	            if (batch.type == "MAIN")
	                for (var j = 0; j < metabatches[i].rel_bpy_objects.length; j++) {
	                    var obj = metabatches[i].rel_bpy_objects[j]._object;
	                    obj.meta_objects.push(meta_obj);
	                }
	        } else {
	            // attach dynamic batches and static COLOR_ID batches to object 
	            // (always single)
	            var obj = metabatches[i].rel_bpy_objects[0]._object;
	            m_obj_util.append_batch(obj, scene, batch);
	        }
	    }

	    if (cfg_def.debug_view) {
	        // create debug sphere batches around dynamic objects
	        for (var i = 0; i < metabatches.length; i++) {
	            // same as obj.render for dynamic objects
	            var render = metabatches[i].render;
	            if (render.type == "DYNAMIC") {
	                // single object for dynamic batch
	                var obj = metabatches[i].rel_bpy_objects[0]._object;
	                var batch = metabatches[i].batch;
	                if (batch.type == "MAIN") {

	                    // every object can have only one debug sphere
	                    var sc_data = m_obj_util.get_scene_data(obj, scene);
	                    var batches = sc_data.batches;
	                    var has_debug_sphere = false;
	                    for (var j = 0; j < batches.length; j++)
	                        if (batches[j].debug_sphere) {
	                            has_debug_sphere = true;
	                            continue;
	                        }
	                    if (has_debug_sphere)
	                        continue;

	                    var ds_batch = create_bounding_ellipsoid_batch(
	                            render, obj.name, true, batch);
	                    m_obj_util.append_batch(obj, scene, ds_batch);
	                }
	            }
	        }

	        // create debug sphere batches around meta-objects
	        for (var i = 0; i < meta_objects.length; i++) {
	            var obj = meta_objects[i];
	            var render = obj.render;
	            var sc_data = m_obj_util.get_scene_data(obj, scene);
	            // every meta object has one batch
	            var batch = sc_data.batches[0];
	            if (batch.type == "MAIN") {
	                var ds_batch = create_bounding_ellipsoid_batch(
	                        render, obj.name, false, batch);
	                m_obj_util.append_batch(obj, scene, ds_batch);
	            }
	        }

	        // assign simple short id for coloring
	        for (var i = 0; i < metabatches.length; i++) {
	            var batch = metabatches[i].batch;
	            if (batch.type == "DEBUG_VIEW")
	                batch.debug_id_color = i;
	        }
	    }

	    for (var i = 0; i < bpy_mesh_objects.length; i++) {
	        var sc_data = m_obj_util.get_scene_data(bpy_mesh_objects[i]._object, scene);
	        var batches = sc_data.batches;
	        for (var j = 0; j < batches.length; j++)
	            update_batch_subtype(batches[j]);
	    }
	    for (var i = 0; i < meta_objects.length; i++) {
	        var sc_data = m_obj_util.get_scene_data(meta_objects[i], scene);
	        var batches = sc_data.batches;
	        for (var j = 0; j < batches.length; j++)
	            update_batch_subtype(batches[j]);
	    }
	};

	exports.append_sky_batch_to_world = function(scene, sky, world) {
	    var wls = scene._render.world_light_set;
	    var batch = init_batch("MAIN");
	    apply_shader(batch, "sky.glslv", "sky.glslf");

	    batch.is_sky = true;
	    batch.depth_mask = false;

	    if (sky.procedural_skydome) {
	        set_batch_directive(batch, "PROCEDURAL_SKYDOME", 1);
	        batch.draw_proc_sky = true;
	    } else {
	        // sky texture has priority
	        var sts = wls.sky_texture_param;
	        var subs_sky = m_scenegraph.find_subs(scene._render.graph, m_subs.SKY);
	        var tex = subs_sky.camera.color_attachment;
	        append_texture(batch, tex, "u_sky");

	        // var subs_irradiance = m_scenegraph.find_subs(scene._render.graph, m_subs.IRRADIANCE);
	        // if (subs_irradiance) {
	            // var tex_irrad = subs_irradiance.camera.color_attachment;
	            // append_texture(batch, tex_irrad, "u_irradiance");
	        // }

	        if (sts) {
	            set_batch_directive(batch, "WO_SKYTEX", 1);
	            if (sts.invert)
	                set_batch_directive(batch, "MTEX_NEGATIVE", 1);
	            if (sts.use_rgb_to_intensity)
	                set_batch_directive(batch, "MTEX_RGBTOINT", 1);
	            set_batch_directive(batch, "BLENDTYPE", sts.blend_type);
	            // if (sts.stencil)
	            //     set_batch_directive(batch, "MTEX_STENCIL", 1);
	            if (sts.use_map_blend)
	                set_batch_directive(batch, "WOMAP_BLEND", 1);
	            if (sts.use_map_horizon)
	                set_batch_directive(batch, "WOMAP_HORIZ", 1);
	            if (sts.use_map_zenith_up)
	                set_batch_directive(batch, "WOMAP_ZENUP", 1);
	            if (sts.use_map_zenith_down)
	                set_batch_directive(batch, "WOMAP_ZENDOWN", 1);
	        }
	        if (wls.use_sky_blend)
	            set_batch_directive(batch, "WO_SKYBLEND", 1);
	        if (wls.use_sky_paper)
	            set_batch_directive(batch, "WO_SKYPAPER", 1);
	        if (wls.use_sky_real)
	            set_batch_directive(batch, "WO_SKYREAL", 1);
	    }
	    if (sky.reflexible) {
	        batch.reflexible = true;
	        if (sky.reflexible_only)
	            batch.reflexible_only = true;
	    }

	    set_batch_c_attr(batch, "a_position");

	    var submesh = m_primitives.generate_fullscreen_quad();
	    update_batch_geometry(batch, submesh);
	    update_batch_subtype(batch);

	    batch.do_not_cull = true;

	    update_batch_id(batch);

	    m_obj_util.append_batch(world, scene, batch);

	    // create DEBUG_VIEW batch for the sky
	    var debug_view_subs = m_scenegraph.find_subs(scene._render.graph, m_subs.DEBUG_VIEW);
	    if (debug_view_subs) {
	        var dv_batch = clone_batch(batch);
	        dv_batch.type = "DEBUG_VIEW";
	        dv_batch.subtype = "";

	        update_batch_material_debug_view(dv_batch);
	        set_batch_directive(dv_batch, "DEBUG_VIEW_SPECIAL_SKYDOME", 1);

	        submesh.va_common["a_polyindex"] = m_geom.extract_polyindices(submesh);
	        update_batch_geometry(dv_batch, submesh);

	        dv_batch.debug_main_batch_id = batch.id;
	        update_batch_id(dv_batch);

	        m_obj_util.append_batch(world, scene, dv_batch);
	    }
	};

	/**
	 * Batch type->subtype relation:
	 * MAIN/PARTICLES -> OPAQUE/BLEND/XRAY/REFLECT
	 * SHADOW         -> RECEIVE/CAST
	 * COLOR_ID       -> COLOR_ID/COLOR_ID_XRAY/OUTLINE
	 * others         -> "" (default)
	 */
	function update_batch_subtype(batch) {
	    switch (batch.type) {
	    case "MAIN":
	    case "PARTICLES":
	    case "LINE":
	        if (batch.blend) {
	            if (batch.xray)
	                batch.subtype = "XRAY";
	            else
	                batch.subtype = "BLEND";
	        } else
	            batch.subtype = "OPAQUE";
	        break;
	    case "SHADOW":
	        // NOTE: Cast only > Receive Shadows
	        // other cast batches will be created by forking the RECEIVE batches
	        if (batch.shadow_cast_only)
	            batch.subtype = "CAST";
	        else
	            batch.subtype = "RECEIVE";
	        break;
	    case "COLOR_ID":
	        if (batch.xray)
	            batch.subtype = "COLOR_ID_XRAY";
	        else
	            batch.subtype = "COLOR_ID";
	        break;
	    }
	}

	exports.create_forked_batches = function(obj, graph, scene) {
	    var scene_data = m_obj_util.get_scene_data(obj, scene);
	    var batches = scene_data.batches;
	    var forked_batches = [];
	    var main_reflect_subs = m_scenegraph.find_subs(graph, m_subs.MAIN_PLANE_REFLECT);
	    var cube_reflect_subs = m_scenegraph.find_subs(graph, m_subs.MAIN_CUBE_REFLECT);
	    var outline_mask_subs = m_scenegraph.find_subs(graph, m_subs.OUTLINE_MASK);
	    var picking_mask_subs = m_scenegraph.find_subs(graph, m_subs.COLOR_PICKING);
	    for (var j = 0; j < batches.length; j++) {
	        var batch_src = batches[j];
	        var batch = null;

	        if (batch_src.type == "SHADOW" && batch_src.subtype == "RECEIVE" 
	                && batch_src.shadow_cast) {
	            batch = clone_batch(batch_src);
	            batch.subtype = "CAST";
	        }

	        if ((batch_src.type == "MAIN" || batch_src.type == "PARTICLES")
	                && (main_reflect_subs || cube_reflect_subs)
	                && batch_src.reflexible) {
	            batch = clone_batch(batch_src);
	            batch.subtype = "REFLECT";

	            batch.refractive = false;
	            if (batch.z_sort) {
	                batch.z_sort = false;
	                batch.depth_mask = false;
	            }
	            // NOTE: required to be by link?
	            batch.particles_data = batch_src.particles_data;
	        }

	        if (batch_src.type == "COLOR_ID")
	            if (outline_mask_subs && obj.render.outlining)
	                if (picking_mask_subs && 
	                        obj.render.selectable) {
	                    batch = clone_batch(batch_src);
	                    batch.subtype = "OUTLINE";    
	                } else
	                    batch_src.subtype = "OUTLINE";

	        if (batch) {
	            batch.forked_batch = true;
	            update_batch_id(batch);
	            forked_batches.push(batch);
	        }
	    }

	    for (var i = 0; i < forked_batches.length; i++)
	        m_obj_util.append_batch(obj, scene, forked_batches[i]);
	};

	function make_metabatches(bpy_mesh_objects, graph) {
	    var metabatches = [];

	    for (var i = 0; i < bpy_mesh_objects.length; i++) {
	        var bpy_obj = bpy_mesh_objects[i];
	        var obj = bpy_obj._object;
	        var render = obj.render;

	        if (obj.is_hair_dupli)
	            continue;

	        metabatches.push.apply(metabatches, make_object_metabatches(bpy_obj, render, graph));
	    }

	    return metabatches;
	}

	/**
	 * Create batches and metadata for single object
	 */
	function make_object_metabatches(bpy_obj, render, graph) {
	    var metabatches = [];

	    var obj = bpy_obj._object;

	    // NOTE: generate all batches
	    var batch_types = get_batch_types(graph, render, !render.do_not_render, false);
	    var mesh = bpy_obj["data"];
	    var materials = obj.materials;
	    var batches_main = new Array(materials.length);
	    var batches_debug_view = new Array(materials.length);
	    var physics_navmesh_submeshes = [];
	    var subs_main = m_scenegraph.find_subs(graph, m_subs.MAIN_OPAQUE);
	    var has_lamp = false;

	    if (subs_main)
	        has_lamp = subs_main.light_positions.length ? true : false;

	    for (var i = 0; i < batch_types.length; i++) {
	        var type = batch_types[i];
	        
	        // j == submesh index == material index
	        for (var j = 0; j < materials.length; j++) {
	            var material = materials[j];

	            if (bpy_mat_is_disabled_for_obj(obj, j))
	                continue;

	            if (m_geom.has_empty_submesh(mesh, j))
	                continue;

	            if (type == "PHYSICS" && bpy_obj["b4w_collision"] 
	                    && bpy_obj["game"]["physics_type"] == "NAVMESH") {
	                physics_navmesh_submeshes.push(m_geom.extract_submesh(mesh, j, 
	                        [], render.bone_skinning_info, {}, null));
	                continue;
	            }

	            if (material.is_lens_flares && !has_lamp)
	                continue;

	            var batch = init_batch(type);

	            if (type == "MAIN")
	                batches_main[j] = batch;
	            else if (type == "DEBUG_VIEW")
	                batches_debug_view[j] = batch;

	            batch.cluster_id = bpy_obj["b4w_cluster_data"]["cluster_id"];

	            var is_valid_output = batch_material_output_is_valid(batch, material);
	            if (!is_valid_output)
	                continue;

	            var is_valid_mat = update_batch_material(batch, material, mesh);
	            if (!is_valid_mat)
	                continue;

	            if (type == "SHADOW" && batches_main[j]) {
	                // Override
	                batch.use_shadeless = batches_main[j].use_shadeless;
	            }

	            batch.draw_mode = (render.use_shape_keys || render.dynamic_geometry) ?
	                    m_geom.DM_DYNAMIC_TRIANGLES : m_geom.DM_DEFAULT;

	            update_batch_render(batch, render);
	            update_batch_particle_systems(batch, bpy_obj["particle_systems"]);

	            if (render.type == "DYNAMIC" || batch.type == "COLOR_ID")
	                batch.odd_id_prop = generate_odd_id(batch, render, bpy_obj["uuid"]);

	            batch.do_not_cull = bpy_obj["b4w_do_not_cull"];

	            if (batch.type == "MAIN")
	                batch.caustics = bpy_obj["b4w_caustics"];

	            var disable_fogging = (type != "COLOR_ID" && type != "SHADOW" 
	                    && bpy_obj["b4w_disable_fogging"]);
	            set_batch_directive(batch, "DISABLE_FOG", disable_fogging | 0);

	            var submesh = m_geom.extract_submesh(mesh, j,
	                    batch.common_attributes, render.bone_skinning_info,
	                    batch.vertex_colors_usage, batch.uv_maps_usage);

	            if (material.use_tangent_shading
	                    && !("a_shade_tangs" in submesh.va_frames[0])) {
	                set_batch_directive(batch, "CALC_TBN", 1);
	                set_batch_c_attr(batch, "a_tbn");
	            }

	            if (material.is_lens_flares)
	                submesh = m_particles.prepare_lens_flares(submesh);

	            update_batch_id(batch);

	            metabatches.push({
	                batch: batch,
	                obj_render: render,
	                batch_render: render,
	                submesh: submesh,
	                mat_names: [material.name],
	                rel_bpy_objects: [bpy_obj]
	            });
	        }
	    }

	    // in case of navigation mesh just join all submeshes
	    if (physics_navmesh_submeshes.length) {
	        var batch = init_batch("PHYSICS");
	        batch.subtype = "NAVMESH";
	        batch.odd_id_prop = generate_odd_id(batch, render, bpy_obj["uuid"]);

	        var submesh = m_geom.submesh_list_join(physics_navmesh_submeshes);

	        var mat_names = [];
	        for (var i = 0; i < materials.length; i++)
	            mat_names.push(materials[i].name);

	        update_batch_id(batch);

	        metabatches.push({
	            batch: batch,
	            obj_render: render,
	            batch_render: render,
	            submesh: submesh,
	            mat_names: mat_names,
	            rel_bpy_objects: [bpy_obj]
	        });
	    }

	    // NOTE: using a special property to make batching for DEBUG_VIEW batches the 
	    // same as for MAIN batches
	    for (var i = 0; i < batches_debug_view.length; i++)
	        if (batches_debug_view[i]) {
	            batches_debug_view[i].debug_main_batch_id = batches_main[i].id;
	            update_batch_id(batches_debug_view[i]);
	        }

	    // process particle system batches
	    var psystems = bpy_obj["particle_systems"];

	    if (psystems.length > 0) {
	        var render_emitter = false;
	        var need_emitter_submesh = false;

	        for (var i = 0; i < psystems.length; i++) {
	            var psys = psystems[i];
	            var pset = psys["settings"];

	            if (pset["use_render_emitter"] && metabatches.length)
	                render_emitter = true;

	            if (pset["type"] == "HAIR" && (pset["render_type"] == "OBJECT"
	                    || pset["render_type"] == "GROUP"
	                    || !psys["transforms"].length))
	                need_emitter_submesh = true;

	            if (render_emitter && need_emitter_submesh)
	                break;
	        }

	        if (metabatches.length)
	            var em_metabatch = metabatches[0];
	        else
	            var em_metabatch = create_tmp_metabatch(mesh, render, psystems);

	        // NOTE: need only inherited vcols and bending vcols which are the same
	        // on every batch
	        var emitter_vc = em_metabatch.batch.vertex_colors_usage;

	        if (need_emitter_submesh)
	            if (materials.length > 1)
	                // NOTE: build common submesh with combined vertex colors
	                // for inheritance
	                var em_submesh = build_emitter_submesh(mesh, psystems, emitter_vc,
	                        bpy_obj._object.render);
	            else
	                var em_submesh = em_metabatch.submesh;
	        else
	            var em_submesh = null;

	        var particles_metabatches = make_particles_metabatches(bpy_obj, render,
	                graph, emitter_vc, em_submesh);

	        if (render_emitter)
	            metabatches.push.apply(metabatches, particles_metabatches);
	        else
	            metabatches = particles_metabatches;
	    }
	    return metabatches;
	}

	function create_tmp_metabatch(mesh, render, psystems) {
	    var batch = init_batch("TMP");
	    update_batch_particle_systems(batch, psystems);

	    var submesh = m_geom.extract_submesh(mesh, 0,
	        batch.common_attributes, render.bone_skinning_info,
	        batch.vertex_colors_usage, batch.uv_maps_usage);

	    return {
	        batch: batch,
	        submesh: submesh
	    };
	}

	function build_emitter_submesh(mesh, psystems, emitter_vc, render) {
	    var emitter_inherit_vc_usage = {};

	    for (var i = 0; i < psystems.length; i++) {
	        var pset = psystems[i]["settings"];
	        if (pset["type"] == "HAIR" && (pset["render_type"] == "OBJECT"
	                || pset["render_type"] == "GROUP")) {

	            var vcol_from = pset["b4w_vcol_from_name"];
	            var vcol_to = pset["b4w_vcol_to_name"];

	            if (vcol_from !== "" && vcol_to !== "")
	                // NOTE: every emitter batch has all inherited vertex colors
	                // and they are fully exported
	                emitter_inherit_vc_usage[vcol_from] =
	                        m_util.clone_object_r(emitter_vc[vcol_from]);
	        }
	    }

	    if ("a_bending_col_main" in emitter_vc)
	        emitter_inherit_vc_usage["a_bending_col_main"] =
	                        m_util.clone_object_r(emitter_vc["a_bending_col_main"]);
	    if ("a_bending_col_detail" in emitter_vc)
	        emitter_inherit_vc_usage["a_bending_col_detail"] =
	                        m_util.clone_object_r(emitter_vc["a_bending_col_detail"]);

	    return m_geom.extract_submesh_all_mats(mesh, [], emitter_inherit_vc_usage);
	}

	/**
	 * Create batches and metadata for object particle systems
	 */
	function make_particles_metabatches(bpy_obj, render, graph, emitter_vc,
	                                    em_submesh) {
	    var obj = bpy_obj._object;
	    var metabatches = [];

	    var psystems = bpy_obj["particle_systems"];
	    var mesh = bpy_obj["data"];

	    for (var i = 0; i < psystems.length; i++) {
	        var psys = psystems[i];
	        var pset = psys["settings"];

	        // ignore empty particle systems
	        if (!pset["count"])
	            continue;

	        if (pset["type"] == "EMITTER") {
	            if (render.type == "DYNAMIC") {

	                var batch = init_batch("PARTICLES");
	                //by link
	                batch.bounds_local.bb = render.bb_local;
	                batch.bounds_local.be = render.be_local;
	                batch.bounds_local.bs = render.bs_local;

	                var pindex = get_psys_material_index(psys, obj.materials);
	                var pmaterial = obj.materials[pindex];

	                if (bpy_mat_is_disabled_for_obj(obj, pindex))
	                    continue;

	                if (psys["settings"]["render_type"] === "HALO"
	                        && pmaterial.type == "HALO")
	                    batch.halo_particles = true;

	                var is_valid_pmat = update_batch_material(batch, pmaterial, mesh);
	                if (!is_valid_pmat)
	                    continue;

	                update_batch_particles_emitter(batch, psys, obj);

	                // NOTE: dynamic_geometry for dynamic particles on EMITTER psys
	                batch.dynamic_geometry = true;

	                batch.do_not_cull = bpy_obj["b4w_do_not_cull"];

	                batch.odd_id_prop = generate_odd_id(batch, render, obj.name + "_" + pset["uuid"]);

	                m_particles.create_particles_data(batch, psys, pmaterial);
	                var submesh = m_particles.generate_emitter_particles_submesh(
	                        batch, mesh, psys, obj.render);
	                m_particles.update_particles_submesh(submesh, batch, pset["count"]);

	                m_particles.update_particles_objs_cache(obj);
	                update_batch_render(batch, obj.render);
	                update_batch_id(batch);

	                metabatches.push({
	                    batch: batch,
	                    obj_render: render,
	                    batch_render: render,
	                    submesh: submesh,
	                    mat_names: [pmaterial.name],
	                    rel_bpy_objects: [bpy_obj]
	                });
	            }

	        } else if (pset["type"] == "HAIR") {
	            var seed = m_util.init_rand_r_seed(psys["seed"]);

	            var use_particles_rotation = m_reformer.check_particles_bin_format(cfg_def.loaded_data_version)
	                    && !pset["b4w_initial_rand_rotation"] && !pset["b4w_hair_billboard"];

	            var data_len = 4;
	            if (use_particles_rotation)
	                data_len = 8;

	            if (psys["transforms"].length) {
	                var ptrans = psys["transforms"];
	            } else {
	                var points = m_geom.geometry_random_points(em_submesh,
	                        pset["count"], false, seed);

	                var ptrans = new Float32Array(points.length * data_len);
	                for (var j = 0; j < points.length; j++) {
	                    // NOTE: +/- 25%
	                    var scale = 0.75 + 0.5 * m_util.rand_r(seed);
	                    ptrans[j * data_len] = points[j][0];
	                    ptrans[j * data_len + 1] = points[j][1];
	                    ptrans[j * data_len + 2] = points[j][2];
	                    ptrans[j * data_len + 3] = scale;
	                    if (use_particles_rotation) {
	                        ptrans[j * data_len + 4] = 1;
	                        ptrans[j * data_len + 5] = 0;
	                        ptrans[j * data_len + 6] = 0;
	                        ptrans[j * data_len + 7] = 0;
	                    }
	                }
	            }

	            var use_grass_map = m_scenegraph.find_subs(graph, m_subs.GRASS_MAP) ?
	                    true : false;

	            if (pset["render_type"] == "OBJECT") {
	                var particles_batch_types = [get_batch_types(graph,
	                        pset["dupli_object"]._object.render, 
	                        !render.do_not_render, true)];

	                var hair_metabatches = make_hair_particles_metabatches(
	                        bpy_obj, render, emitter_vc, em_submesh,
	                        [pset["dupli_object"]], particles_batch_types,
	                        [ptrans], pset, psys, use_grass_map, seed, false);

	                metabatches.push.apply(metabatches, hair_metabatches);

	            } else if (pset["render_type"] == "GROUP") {
	                var bpy_part_objs = pset["dupli_group"]["objects"];
	                var particles_batch_types = [];
	                for (var j = 0; j < bpy_part_objs.length; j++) {
	                    var btypes = get_batch_types(graph,
	                            bpy_part_objs[j]._object.render, 
	                            !render.do_not_render, true);
	                    particles_batch_types.push(btypes);
	                }

	                var reset_seed = false;
	                var part_objs = [];
	                for (var j = 0; j < bpy_part_objs.length; j++)
	                    part_objs.push(bpy_part_objs[j]._object);

	                if (pset["use_whole_group"]) {
	                    var ptrans_dist = distribute_ptrans_group(ptrans,
	                            part_objs, use_particles_rotation, data_len);
	                    reset_seed = true;
	                } else if (pset["use_group_count"]) {
	                    var ptrans_dist = distribute_ptrans_by_dupli_weights(
	                            ptrans, part_objs, pset["dupli_weights"], seed,
	                            use_particles_rotation, data_len);
	                } else {
	                    var ptrans_dist = distribute_ptrans_equally(ptrans,
	                        part_objs, seed, use_particles_rotation, data_len);
	                }

	                var hair_metabatches = make_hair_particles_metabatches(
	                        bpy_obj, render, emitter_vc, em_submesh, bpy_part_objs,
	                        particles_batch_types, ptrans_dist, pset, psys,
	                        use_grass_map, seed, reset_seed);

	                metabatches.push.apply(metabatches, hair_metabatches);
	            }

	            if (pset["b4w_wind_bend_inheritance"] == "INSTANCE" && obj.render.wind_bending)
	                m_print.warn("Emitter object \"" + obj.name + "\" has a particle"
	                        + " system with wind bending inheritance from the "
	                        + "particle instance. Wind bending on the emitter isn't "
	                        + "disabled. Expect unforeseen behavior.");
	        } else
	            m_util.panic("Unknown particle settings type");
	    }

	    return metabatches;
	}

	function get_psys_material_index(psys, materials) {
	    var mat_index = psys["settings"]["material"] - 1;
	    if (mat_index >= materials.length) {
	        m_print.warn("Wrong material used for rendering particle " +
	                "system \"" + psys["name"] + "\"");
	        mat_index = 0;
	    }

	    return mat_index;
	}

	function merge_metabatches(metabatches) {
	    var merged_metabatches = [];

	    var unique_data = [];
	    var batches_ids = {};

	    // collect unique batches and data
	    for (var i = 0; i < metabatches.length; i++) {
	        var batch = metabatches[i].batch;

	        var batch_data = null;
	        if (batch.id in batches_ids) {
	            var index = batches_ids[batch.id];
	            var collision_batch = unique_data[index].batch;

	            var pass_col_batch_cb = function(batch) {
	                var cmp_cb = function(collision_batch) {
	                    if (m_util.strict_objs_is_equal(batch, collision_batch)
	                            && batch.inst_array_state != SINGLE_INST_ARR)
	                        batch_data = unique_data[index];
	                };
	                batch_strip_bad_props_cb(collision_batch, cmp_cb);
	            };
	            batch_strip_bad_props_cb(batch, pass_col_batch_cb);

	            if (!batch_data)
	                do {
	                    batch.id++;
	                } while (batches_ids[batch.id]);
	        }

	        // new unique or collided batch
	        if (!batch_data || DEBUG_DO_NOT_BATCH) {
	            batch_data = {
	                batch: batch,

	                // matched with each other
	                obj_renders_ordered: [],
	                batch_renders_ordered: [],
	                submeshes_ordered: [],

	                rel_bpy_objects: [],
	                rel_bpy_objects_uuids: [],
	                mat_names: []
	            };
	            batches_ids[batch.id] = unique_data.length;
	            unique_data.push(batch_data);
	        }

	        // NOTE: ignore empty submeshes - is it needed at all?
	        if (metabatches[i].submesh && metabatches[i].submesh.base_length) {
	            batch_data.obj_renders_ordered.push(metabatches[i].obj_render);
	            batch_data.batch_renders_ordered.push(metabatches[i].batch_render);
	            batch_data.submeshes_ordered.push(metabatches[i].submesh);

	            for (var j = 0; j < metabatches[i].rel_bpy_objects.length; j++) {
	                var bpy_obj = metabatches[i].rel_bpy_objects[j];
	                if (batch_data.rel_bpy_objects_uuids.indexOf(bpy_obj["uuid"]) == -1) {
	                    batch_data.rel_bpy_objects.push(bpy_obj);                
	                    batch_data.rel_bpy_objects_uuids.push(bpy_obj["uuid"]);
	                }
	            }

	            for (var j = 0; j < metabatches[i].mat_names.length; j++) {
	                var mat_name = metabatches[i].mat_names[j];
	                if (batch_data.mat_names.indexOf(mat_name) == -1)
	                    batch_data.mat_names.push(mat_name);
	            }
	        }

	        // not mandatory, just for logging
	        batch_data.mat_names.sort();
	    }

	    // calculate submeshes for unique batches
	    for (var i = 0; i < unique_data.length; i++) {
	        var batch = unique_data[i].batch;
	        var obj_renders = unique_data[i].obj_renders_ordered;
	        var batch_renders = unique_data[i].batch_renders_ordered;
	        var submeshes = unique_data[i].submeshes_ordered;

	        var meta_render = get_meta_render(batch_renders, batch);

	        if (meta_render.type == "STATIC" && batch.type != "COLOR_ID") {
	            for (var j = 0; j < obj_renders.length; j++) {
	                var obj_render = obj_renders[j];
	                var batch_render = batch_renders[j];
	                var submesh = submeshes[j];

	                // apply tsr to a STATIC object, even if it isn't batched with 
	                // others - for optimization
	                var tsr = m_tsr.identity(_tsr_tmp);

	                // NOTE: use obj_render (that is emitter render for particles) to
	                // get the tsr
	                if (obj_render.billboard && !obj_render.billboard_pres_glob_orientation) {
	                    var obj_transcale = m_tsr.get_transcale(obj_render.world_tsr, _vec4_tmp);
	                    m_tsr.set_transcale(obj_transcale, tsr);
	                } else
	                    m_tsr.copy(obj_render.world_tsr, tsr);

	                if (!batch_render.is_hair_particles)
	                    m_geom.submesh_apply_transform(submesh, tsr);
	                else if (!submesh.instanced_array_data) {
	                    if (batch_render.billboard)
	                        m_geom.submesh_apply_particle_transform(submesh, tsr);
	                    else
	                        m_geom.submesh_apply_transform(submesh, tsr);
	                }

	                if (batch_render.is_hair_particles) {
	                    set_batch_directive(batch, "AU_QUALIFIER", "GLSL_IN");

	                    // NOTE: submesh params for particles applied in
	                    // make_hair_particles_metabatches() function

	                } else if (unique_data[i].rel_bpy_objects.length > 1) {
	                    var params = {};
	                    if (batch_render.wind_bending || batch_render.billboard)
	                        params["au_center_pos"] = [tsr[0], tsr[1], tsr[2]];
	                    if (batch_render.wind_bending) {
	                        params["au_wind_bending_amp"] = [batch_render.wind_bending_amp];
	                        params["au_wind_bending_freq"] = [batch_render.wind_bending_freq];
	                        params["au_detail_bending_amp"] = [batch_render.detail_bending_amp];
	                        params["au_detail_bending_freq"] = [batch_render.detail_bending_freq];
	                        params["au_branch_bending_amp"] = [batch_render.branch_bending_amp];
	                    }

	                    m_geom.submesh_apply_params(submesh, params);
	                    set_batch_directive(batch, "AU_QUALIFIER", "GLSL_IN");
	                } else {
	                    meta_render.center_pos.set(tsr.subarray(0, 3));
	                    set_batch_directive(batch, "AU_QUALIFIER", "uniform");
	                }
	            }
	        }

	        if (submeshes.length == 0)
	            var submesh = m_geom.init_submesh(m_util.unique_name("%empty"));
	        else if (submeshes.length == 1) {
	            var submesh = submeshes[0];
	        } else {
	            var short_submeshes = [];
	            for (var j = 0; j < submeshes.length; j++)
	                if (!m_geom.is_long_submesh(submeshes[j]))
	                    short_submeshes.push(j);
	            if (short_submeshes.length < submeshes.length)
	                for (var j = 0; j < short_submeshes.length; j++)
	                    m_geom.submesh_drop_indices(submeshes[short_submeshes[j]]);
	            var submesh = m_geom.submesh_list_join(submeshes);
	        }

	        if (meta_render.type == "STATIC") {
	            if (batch.type != "COLOR_ID") {
	                var bounding_verts = [];
	                for (var j = 0; j < unique_data[i].rel_bpy_objects.length; j++) {
	                    var obj = unique_data[i].rel_bpy_objects[j]._object;
	                    m_bounds.extract_rot_bb_corners(obj.render.bbr_world,
	                            bounding_verts);
	                }
	                m_bounds.bb_from_coords(bounding_verts, 0, 
	                        bounding_verts.length, meta_render.bb_world);

	                m_bounds.copy_bb(meta_render.bb_world, meta_render.bb_local);
	                meta_render.be_world = m_bounds.create_be_by_bb(m_util.f32(bounding_verts), true);
	                m_bounds.copy_be(meta_render.be_world, meta_render.be_local);
	                meta_render.bs_world = m_bounds.create_bs_by_be(meta_render.be_world);
	                m_bounds.copy_bs(meta_render.bs_world, meta_render.bs_local);

	                // no need to recalc bb_original, bcyl_local, bcap_local, bcon_local,
	                // bbr_local and bbr_world for STATIC objects 
	            }
	            
	            if (meta_render.is_lod) {
	                var cluster_data = unique_data[i].rel_bpy_objects[0]["b4w_cluster_data"];

	                if (cluster_data["cluster_center"])
	                    meta_render.lod_center.set(cluster_data["cluster_center"]);
	                else
	                    meta_render.lod_center.set(meta_render.bs_world.center);
	            }
	        }

	        // calculate batch boundings from submesh/render
	        if (batch.type != "PARTICLES") {
	            var submesh_bd = submesh.submesh_bd;

	            if (meta_render.billboard) {
	                m_bounds.copy_bb(meta_render.bb_local, batch.bounds_local.bb);
	                m_bounds.copy_be(meta_render.be_local, batch.bounds_local.be);
	                m_bounds.copy_bs(meta_render.bs_local, batch.bounds_local.bs);
	                batch.use_be = false;
	            } else {
	                m_bounds.copy_bb(submesh_bd.bb_local, batch.bounds_local.bb);
	                m_bounds.copy_be(submesh_bd.be_local, batch.bounds_local.be);

	                // NOTE: take a sphere from the object if it has smaller volume
	                if (meta_render.bs_local.radius < submesh_bd.bs_local.radius) {
	                    if (meta_render.type == "STATIC" && batch.type != "COLOR_ID")
	                        m_bounds.copy_bs(meta_render.bs_world, batch.bounds_local.bs);
	                    else
	                        m_bounds.copy_bs(meta_render.bs_local, batch.bounds_local.bs);
	                } else
	                    m_bounds.copy_bs(submesh_bd.bs_local, batch.bounds_local.bs);

	                batch.use_be = m_bounds.is_be_optimized(batch.bounds_local.be, 
	                        batch.bounds_local.bs);
	            }
	        }

	        var metabatch = {
	            batch: batch,
	            render: meta_render,
	            submesh: submesh,
	            mat_names: unique_data[i].mat_names,
	            rel_bpy_objects: unique_data[i].rel_bpy_objects
	        };
	        merged_metabatches.push(metabatch);
	    }

	    return merged_metabatches;
	}

	function get_meta_render(batch_renders, batch) {
	    // batches on a dynamic object or COLOR_ID batch on a static object
	    if (batch_renders[0].type == "DYNAMIC" || batch.type == "COLOR_ID")
	        return batch_renders[0];

	    // other batches on a static object
	    return m_obj_util.clone_render(batch_renders[0]);
	}

	exports.wb_angle_to_amp = wb_angle_to_amp;
	function wb_angle_to_amp(angle, bbox, scale) {

	    var height = scale * (bbox.max_z - bbox.min_z);

	    if (height == 0)
	        return 0;

	    var delta = height * Math.tan(angle);

	    // root for equation: delta = (amp+1)^4 - (amp+1)^2
	    var amp = Math.sqrt(2*Math.sqrt(4*delta+1)+2) / 2 - 1;

	    return 0.5 * amp / height; // moved 0.5 from shader
	}

	exports.wb_amp_to_angle = wb_amp_to_angle;
	function wb_amp_to_angle(amp, bbox, scale) {

	    var height = scale * (bbox.max_z - bbox.min_z);

	    if (height == 0)
	        return 0;

	    amp = 2 * height * amp;

	    var delta = Math.pow((amp+1), 4) - Math.pow((amp+1), 2);

	    var angle = Math.atan(delta / height);

	    return angle;
	}

	exports.bb_bpy_to_b4w = bb_bpy_to_b4w;
	function bb_bpy_to_b4w(bpy_bb) {
	    var bb = m_bounds.create_bb();
	    bb.max_x = bpy_bb["max_x"];
	    bb.min_x = bpy_bb["min_x"];
	    bb.max_y = bpy_bb["max_y"];
	    bb.min_y = bpy_bb["min_y"];
	    bb.max_z = bpy_bb["max_z"];
	    bb.min_z = bpy_bb["min_z"];

	    return bb;
	}

	function exclude_batch_types(batch_types, unwanted_types) {

	    for (var i = 0; i < unwanted_types.length; i++) {
	        var index = batch_types.indexOf(unwanted_types[i]);
	        if (index !== -1)
	            batch_types.splice(index, 1);
	    }

	    return batch_types;
	}

	function get_batch_types(graph, render, is_rendered, is_hair_particles) {
	    var batch_types = [];

	    if (!is_hair_particles)
	        if (render.selectable && m_scenegraph.find_subs(graph, m_subs.COLOR_PICKING) ||
	                render.outlining && m_scenegraph.find_subs(graph, m_subs.OUTLINE_MASK))
	            batch_types.push("COLOR_ID");

	    // NOTE: "is_rendered" doesn't always match with !do_not_render object flag,
	    // it depends on the emitter render for particle system batches
	    if (is_rendered) {
	        batch_types.push("MAIN");
	        batch_types.push("NODES_GLOW");

	        if (m_scenegraph.find_subs(graph, m_subs.DEBUG_VIEW))
	            batch_types.push("DEBUG_VIEW");

	        if (m_scenegraph.find_subs(graph, m_subs.SHADOW_RECEIVE))
	            batch_types.push("SHADOW");

	        if (m_scenegraph.find_subs(graph, m_subs.GRASS_MAP))
	            batch_types.push("GRASS_MAP");
	    }

	    // NOTE: need condition
	    batch_types.push("PHYSICS");

	    if (render.shadow_cast_only || render.reflexible_only) {
	        var unwanted_types = null;

	        if (render.shadow_cast_only)
	            unwanted_types = ["MAIN", "NODES_GLOW", "COLOR_ID",
	                              "PHYSICS", "DEBUG_VIEW"];
	        if (render.reflexible_only) {
	            var types = ["COLOR_ID", "PHYSICS", "SHADOW", "DEBUG_VIEW"];
	            if (unwanted_types !== null)
	                unwanted_types = m_util.array_intersect(unwanted_types, types);
	            else
	                unwanted_types = types;
	        }

	        batch_types = exclude_batch_types(batch_types, unwanted_types);
	    }

	    return batch_types;
	}

	/**
	 * Init batch according to blender material
	 */
	function update_batch_material(batch, material, mesh) {

	    var ret;
	    switch (batch.type) {
	    case "MAIN":
	        ret = update_batch_material_main(batch, material, mesh);
	        break;
	    case "NODES_GLOW":
	        ret = update_batch_material_nodes(batch, material, mesh, "GLOW");
	        break;
	    case "SHADOW":
	        ret = update_batch_material_shadow_receive(batch, material, mesh);
	        break;
	    case "PHYSICS":
	        ret = update_batch_material_physics(batch, material);
	        break;
	    case "COLOR_ID":
	        ret = update_batch_material_color_id(batch, material, mesh);
	        break;
	    case "GRASS_MAP":
	        ret = update_batch_material_grass_map(batch, material);
	        break;
	    case "DEBUG_VIEW":
	        ret = update_batch_material_debug_view(batch, material);
	        break;
	    case "PARTICLES":
	        ret = update_batch_material_particles(batch, material, mesh);
	        break;
	    default:
	        m_util.panic("Wrong batch type: " + batch.type);
	    }

	    return ret;
	}

	function update_batch_material_main(batch, material, mesh) {
	    if (material.do_not_render)
	        return false;

	    if (material.use_nodes && material.type != "HALO") {
	        update_batch_material_nodes(batch, material, mesh, "MAIN");
	        return true;
	    }

	    update_batch_blend_mode(batch, material);
	    batch.use_backface_culling = material.use_backface_culling;

	    batch.xray = material.render_above_all && material.blend_mode != "OPAQUE"
	            && material.blend_mode != "CLIP" 
	            && material.blend_mode != "ALPHA_ANTIALIASING";

	    batch.offset_z = material.offset_z;

	    // NOTE: for multitexturing storage of 5 vec3's is used instead
	    batch.texture_scale.set([1, 1, 1]);

	    var texture_slots = material.texture_slots;

	    batch.diffuse_color.set(material.diffuse_color);
	    batch.diffuse_color[3] = material.alpha;

	    if (material.is_lens_flares) {
	        apply_shader(batch, "lens_flares.glslv", "lens_flares.glslf");
	        set_batch_c_attr(batch, "a_position");
	        set_batch_c_attr(batch, "a_texcoord");
	        var tex = m_textures.get_batch_texture(texture_slots[0]);
	        var bpy_tex = texture_slots[0]["texture"];
	        append_texture(batch, tex, "u_sampler", bpy_tex["name"]);
	    } else {
	        apply_shader(batch, "main.glslv", "main_stack.glslf");
	        if (!material.use_shadeless) {
	            var data = {
	                use_shadeless: material.use_shadeless,
	                diffuse_shader: material.diffuse_shader,
	                specular_shader: material.specular_shader,
	                use_tangent_shading: material.use_tangent_shading
	            };
	            var nmat_graph = m_nodemat.create_lighting_graph(material.uuid, 
	                    data);
	            batch.shaders_info.node_elements =
	                    m_nodemat.compose_node_elements(nmat_graph);
	        }

	        // find which one is color map, spec map etc
	        var colormaps = find_valid_tex_slots("use_map_color_diffuse", true, texture_slots);
	        var specmaps   = find_valid_tex_slots("use_map_color_spec", true, texture_slots);
	        var normalmaps = find_valid_tex_slots("use_map_normal", true, texture_slots);
	        var mirrormaps = find_valid_tex_slots("use_map_mirror", true, texture_slots);
	        var stencilmaps = find_valid_tex_slots("use_stencil", true, texture_slots);

	        var colormap0  = colormaps[0];
	        var specmap0   = specmaps[0];
	        var normalmap0 = normalmaps[0];
	        var mirrormap0 = mirrormaps[0];

	        var colormap1 = colormaps[1];
	        var stencil0  = stencilmaps[0] &&
	                        find_valid_tex_slots("use_rgb_to_intensity", true, texture_slots)[0];

	        if (colormap0) {
	            var bpy_tex = colormap0["texture"];
	            switch (colormap0["blend_type"]) {
	            case "MIX":
	                set_batch_directive(batch, "TEXTURE_BLEND_TYPE", "TEXTURE_BLEND_TYPE_MIX");
	                break;
	            case "MULTIPLY":
	                set_batch_directive(batch, "TEXTURE_BLEND_TYPE", "TEXTURE_BLEND_TYPE_MULTIPLY");
	                break;
	            }

	            var tex = m_textures.get_batch_texture(colormap0);
	            append_texture(batch, tex, "u_colormap0", bpy_tex["name"]);

	            // assumed there is only one color texture per material
	            batch.diffuse_color_factor = colormap0["diffuse_color_factor"];
	            if (colormap0["use_map_alpha"])
	                batch.alpha_factor = colormap0["alpha_factor"];
	            else
	                batch.alpha_factor = 0.0;

	            batch.texture_scale.set(colormap0["scale"]);
	        }

	        // specular color can be packed into the alpha channel of a color map
	        var alpha_as_spec = colormap0 && (colormap0 == specmap0);

	        if (specmap0) {
	            if (!alpha_as_spec) {
	                var bpy_tex = specmap0["texture"];
	                var tex = m_textures.get_batch_texture(specmap0);
	                append_texture(batch, tex, "u_specmap0", bpy_tex["name"]);
	            }
	            batch.specular_color_factor = specmap0["specular_color_factor"];
	        }

	        if (normalmap0) {
	            var bpy_tex = normalmap0["texture"];
	            set_batch_c_attr(batch, "a_tbn");
	            var tex = m_textures.get_batch_texture(normalmap0);
	            append_texture(batch, tex, "u_normalmap0", bpy_tex["name"]);
	            batch.normal_factor = normalmap0["normal_factor"];

	            if (bpy_tex["b4w_use_map_parallax"] && cfg_def.parallax) {

	                var steps = m_shaders.glsl_value(bpy_tex["b4w_parallax_steps"]);
	                var lod_dist =
	                        m_shaders.glsl_value(bpy_tex["b4w_parallax_lod_dist"]);

	                set_batch_directive(batch, "PARALLAX", 1);
	                set_batch_directive(batch, "PARALLAX_STEPS", steps);
	                set_batch_directive(batch, "PARALLAX_LOD_DIST", lod_dist);
	                batch.parallax_scale = bpy_tex["b4w_parallax_scale"];
	            }
	        }

	        if (mirrormap0) {
	            var bpy_tex = mirrormap0["texture"];
	            var tex = m_textures.get_batch_texture(mirrormap0);
	            append_texture(batch, tex, "u_mirrormap", bpy_tex["name"]);
	            batch.mirror_factor = mirrormap0["mirror_factor"];
	        }

	        var TEXTURE_STENCIL_ALPHA_MASK = colormap0 && colormap1 && stencil0 ? 1 : 0;

	        if (TEXTURE_STENCIL_ALPHA_MASK) {
	            var tex = m_textures.get_batch_texture(colormap1);
	            var bpy_tex = colormap1["texture"];
	            append_texture(batch, tex, "u_colormap1", bpy_tex["name"]);
	            
	            tex = m_textures.get_batch_texture(stencil0);
	            bpy_tex = stencil0["texture"];
	            append_texture(batch, tex, "u_stencil0", bpy_tex["name"]);
	        }

	        // setup texture scale using one of available textures
	        var some_tex = colormap0 || specmap0 || normalmap0;
	        if (some_tex)
	            batch.texture_scale.set(some_tex["scale"]);

	        // assign directives
	        set_batch_directive(batch, "TEXTURE_SPEC", specmap0 == undefined ? 0 : 1);
	        set_batch_directive(batch, "ALPHA_AS_SPEC", alpha_as_spec ? 1 : 0);
	        set_batch_directive(batch, "TEXTURE_STENCIL_ALPHA_MASK", TEXTURE_STENCIL_ALPHA_MASK);

	        set_batch_c_attr(batch, "a_position");
	        set_batch_c_attr(batch, "a_tbn");

	        if (colormap0 || specmap0 || normalmap0)
	            set_batch_c_attr(batch, "a_texcoord");

	        if (material.water_settings.is_water)
	            init_water_material(material, batch);

	        if (material.type === "HALO") {
	            apply_shader(batch, "halo.glslv", "halo.glslf");

	            set_batch_halo_data(batch, material);

	            batch.common_attributes = ["a_position"];
	        }

	        if (material.use_tangent_shading) {
	            set_batch_directive(batch, "USE_TBN_SHADING", 1);
	            set_batch_c_attr(batch, "a_shade_tangs");
	        }

	        set_batch_directive(batch, "TEXCOORD", 0);
	        set_batch_directive(batch, "NORMAL_TEXCOORD", 0);
	        if (colormap0)
	            set_batch_texcoord_directive(batch, colormap0, "TEXTURE_COLOR0_CO");
	        if (colormap1)
	            set_batch_texcoord_directive(batch, colormap1, "TEXTURE_COLOR1_CO");
	        if (stencil0)
	            set_batch_texcoord_directive(batch, stencil0,
	                                         "TEXTURE_STENCIL_ALPHA_MASK_CO");
	        if (specmap0)
	            set_batch_texcoord_directive(batch, specmap0, "TEXTURE_SPEC_CO");
	        if (normalmap0)
	            set_batch_texcoord_directive(batch, normalmap0, "TEXTURE_NORM_CO");

	        set_batch_directive(batch, "SHADELESS", material.use_shadeless ? 1 : 0);

	        batch.use_shadeless = material.use_shadeless;
	    }

	    set_batch_directive(batch, "ALPHA", (material.blend_mode === "OPAQUE") ? 0 : 1);
	    set_batch_directive(batch, "ALPHA_CLIP", (material.blend_mode === "CLIP") ? 1 : 0);

	    set_batch_directive(batch, "DOUBLE_SIDED_LIGHTING",
	            (material.use_double_sided_lighting) ? 1 : 0);

	    if (material.use_vertex_color_paint) {
	        set_batch_directive(batch, "VERTEX_COLOR", 1);
	        set_batch_c_attr(batch, "a_color");
	    } else
	        set_batch_directive(batch, "VERTEX_COLOR", 0);

	    batch.ambient = material.ambient;
	    batch.diffuse_intensity = material.diffuse_intensity;
	    batch.emit = material.emit;
	    batch.specular_color.set(material.specular_color);
	    batch.specular_alpha = material.specular_alpha;

	    update_batch_specular_params(batch, material);
	    update_batch_diffuse_params(batch, material);

	    if (material.is_wettable) {
	        set_batch_directive(batch, "WETTABLE", 1);
	    } else
	        set_batch_directive(batch, "WETTABLE", 0);

	    update_batch_fresnel_params(batch, material);

	    if (material.is_refractive && !batch.blend) {
	        m_print.warn("Material \"" + material.name + "\" is not blend. " +
	                     "Disabling refractions.");
	        batch.refractive = false;
	    } else
	        batch.refractive = material.is_refractive;

	    batch.refr_bump = material.refr_bump;

	    return true;
	}

	function set_batch_halo_data(batch, material) {
	    var hs = material.halo_settings;
	    set_batch_directive(batch, "NUM_RINGS", hs.ring_count);
	    set_batch_directive(batch, "NUM_LINES", hs.line_count);
	    set_batch_directive(batch, "NUM_STARS", hs.star_tip_count);
	    set_batch_directive(batch, "SKY_STARS", hs.is_sky_stars ? 1 : 0);

	    batch.halo_size = hs.size;
	    // NOTE: hardness works not similiar to blender's one
	    batch.halo_hardness = hs.hardness / 20;
	    batch.halo_rings_color.set(hs.rings_color);
	    batch.halo_lines_color.set(hs.lines_color);
	    batch.halo_stars_blend = 1.0 / hs.stars_blend_height;
	    batch.halo_stars_height = hs.stars_min_height;
	    batch.halo = true;
	}

	function set_batch_texcoord_directive(batch, texture, directive_name) {
	    switch (texture["texture_coords"]) {
	    case "UV":
	    case "ORCO":
	        set_batch_directive(batch, directive_name, "TEXTURE_COORDS_UV_ORCO");
	        set_batch_directive(batch, "TEXCOORD", 1);
	        break;
	    case "NORMAL":
	        set_batch_directive(batch, directive_name, "TEXTURE_COORDS_NORMAL");
	        set_batch_directive(batch, "NORMAL_TEXCOORD", 1);
	        break;
	    default:
	        set_batch_directive(batch, directive_name, "TEXTURE_COORDS_NONE");
	    }
	}

	/**
	 * Common for all batch types
	 */
	function update_batch_blend_mode(batch, material) {
	    switch (material.blend_mode) {
	    case "ALPHA_ANTIALIASING": // Alpha Anti-Aliasing  don't sort  don't blend
	        batch.blend = false;
	        batch.z_sort = false;
	        batch.depth_mask = true;
	        batch.alpha_clip = false;
	        batch.alpha_antialiasing = true;
	        break;
	    case "ALPHA_SORT":         // Alpha Sort           sort        blend
	        batch.blend = true;
	        batch.z_sort = true;
	        batch.depth_mask = true;
	        batch.alpha_clip = false;
	        batch.alpha_antialiasing = false;
	        break;
	    case "ALPHA":              // Alpha Blend          don't sort  blend
	        batch.blend = true;
	        batch.z_sort = false;
	        batch.depth_mask = true;
	        batch.alpha_clip = false;
	        batch.alpha_antialiasing = false;
	        break;
	    case "CLIP":               // Alpha Clip           don't sort  discard
	        batch.blend = false;
	        batch.z_sort = false;
	        batch.depth_mask = true;
	        batch.alpha_clip = true;
	        batch.alpha_antialiasing = false;
	        break;
	    case "ADD":                // Add                  don't sort  blend, depthMask(false)
	        batch.blend = true;
	        batch.z_sort = false;
	        batch.depth_mask = false;
	        batch.alpha_clip = false;
	        batch.alpha_antialiasing = false;
	        break;
	    case "OPAQUE":             // Opaque               don't sort  don't blend
	        batch.blend = false;
	        batch.z_sort = false;
	        batch.depth_mask = true;
	        batch.alpha_clip = false;
	        batch.alpha_antialiasing = false;
	        break;
	    default:
	        m_util.panic("Unknown alpha blend mode: " + material.blend_mode);
	    }
	}

	/**
	 * Return array of valid textures
	 */
	function find_valid_tex_slots(key, value, slots) {
	    var results = [];

	    var len = slots.length;
	    for (var i = 0; i < len; i++) {
	        var slot = slots[i];
	        if (slot[key] == value && slot["texture"] && slot["texture"]._render)
	            results.push(slot);
	    }
	    return results;
	}

	function init_water_material(material, batch) {

	    batch.water = true;
	    batch.water_dynamic = material.water_settings.is_dynamic;

	    if (material.water_settings.shore_smoothing && !batch.blend) {
	        m_print.warn("Material: \"" + material.name + "\" is opaque.",
	                     "Disabling water shore smoothing.");
	        batch.water_shore_smoothing = false;
	    } else
	        batch.water_shore_smoothing = batch.subtype != "REFLECT" 
	                ? material.water_settings.shore_smoothing: false;

	    apply_shader(batch, "water.glslv", "water.glslf");

	    var data = {
	        use_shadeless: false,
	        diffuse_shader: material.diffuse_shader,
	        specular_shader: material.specular_shader,
	        use_tangent_shading: material.use_tangent_shading
	    };
	    var nmat_graph = m_nodemat.create_lighting_graph(material.uuid, data);
	    batch.shaders_info.node_elements =
	            m_nodemat.compose_node_elements(nmat_graph);

	    set_batch_c_attr(batch, "a_position");

	    // debug wireframe mode
	    if (cfg_def.water_wireframe_debug) {
	        set_batch_c_attr(batch, "a_polyindex");
	        batch.depth_mask = true;
	        m_vec3.set(0, 0, 0, batch.wireframe_edge_color);

	        if (m_extensions.get_standard_derivatives())
	            set_batch_directive(batch, "DEBUG_WIREFRAME", 1);
	        else
	            set_batch_directive(batch, "DEBUG_WIREFRAME", 2);
	    } else
	        set_batch_directive(batch, "DEBUG_WIREFRAME", 0);

	    var texture_slots = material.texture_slots;
	    var normalmaps = find_valid_tex_slots("use_map_normal", true, texture_slots);
	    var mirrormap0 = find_valid_tex_slots("use_map_mirror", true, texture_slots)[0];

	    if (normalmaps.length) {
	        var tex_nm = m_textures.get_batch_texture(normalmaps[0]);
	        var bpy_tex = normalmaps[0]["texture"];
	        append_texture(batch, tex_nm, "u_normalmap0", bpy_tex["name"]);
	        batch.water_norm_uv_velocity = material.water_settings.norm_uv_velocity;
	    }

	    set_batch_directive(batch, "NUM_NORMALMAPS", normalmaps.length);

	    batch.normalmap_scales = new Array(normalmaps.length);
	    for (var i = 0; i < normalmaps.length; i++) {
	        batch.normalmap_scales[i] = new Float32Array(2);
	        batch.normalmap_scales[i].set([normalmaps[i]["scale"][0], normalmaps[i]["scale"][1]]);
	    }

	    if (mirrormap0) {
	        var tex_mm = m_textures.get_batch_texture(mirrormap0);
	        var bpy_tex = mirrormap0["texture"];
	        append_texture(batch, tex_mm, "u_mirrormap", bpy_tex["name"]);
	        batch.mirror_factor = mirrormap0["mirror_factor"];
	    }

	    var foam = null;

	    if (cfg_def.foam)
	        for (var i = 0; i < texture_slots.length; i++) {
	            // find first foam texture
	            var texture = texture_slots[i];
	            if (texture["texture"]["b4w_water_foam"] === true) {
	               foam = texture;
	               break;
	            }
	        }

	    if (foam) {
	        set_batch_directive(batch, "FOAM", 1);
	        var tex_foam = m_textures.get_batch_texture(foam);
	        var bpy_tex = foam["texture"];
	        append_texture(batch, tex_foam, "u_foam", bpy_tex["name"]);

	        batch.foam_factor = material.water_settings.foam_factor;
	        batch.foam_uv_freq.set(bpy_tex["b4w_foam_uv_freq"]);
	        batch.foam_mag.set(bpy_tex["b4w_foam_uv_magnitude"]);
	        // vec3 -> vec2
	        batch.foam_scale[0] = foam["scale"][0];
	        batch.foam_scale[1] = foam["scale"][1];
	    }

	    for (var i = 0; i < texture_slots.length; i++) {
	        // find first shore distance texture
	        var texture = texture_slots[i];
	        if (texture["texture"]["b4w_shore_dist_map"] === true) {
	            var shore_dist_map = texture;
	            break;
	        }
	    }

	    if (shore_dist_map && cfg_def.allow_vertex_textures) {
	        var tex_shr0 = m_textures.get_batch_texture(shore_dist_map);
	        var bpy_tex = shore_dist_map["texture"];
	        append_texture(batch, tex_shr0, "u_shore_dist_map", bpy_tex["name"]);
	        set_batch_directive(batch, "SHORE_PARAMS", 1);

	        var sh_bounds = texture["texture"]["b4w_shore_boundings"];

	        set_batch_directive(batch, "MAX_SHORE_DIST", m_shaders.glsl_value(
	                                    texture["texture"]["b4w_max_shore_dist"]));

	        set_batch_directive(batch, "SHORE_MAP_SIZE_X", m_shaders.glsl_value(
	                                    sh_bounds[0] - sh_bounds[1]));

	        set_batch_directive(batch, "SHORE_MAP_SIZE_Y", m_shaders.glsl_value(
	                                    sh_bounds[2] - sh_bounds[3]));

	        set_batch_directive(batch, "SHORE_MAP_CENTER_X",m_shaders.glsl_value(
	                                    (sh_bounds[0] + sh_bounds[1]) / 2));

	        set_batch_directive(batch, "SHORE_MAP_CENTER_Y", m_shaders.glsl_value(
	                                    (sh_bounds[2] + sh_bounds[3]) / 2));
	    }

	    if (material.water_settings.is_generated_mesh) {
	        set_batch_directive(batch, "GENERATED_MESH", 1);
	        batch.water_generated_mesh = true;
	        batch.water_num_cascads    = material.water_settings.num_cascads;
	        batch.water_subdivs        = material.water_settings.num_subdivs;
	        batch.water_detailed_dist  = material.water_settings.detailed_dist;
	    } else {
	        set_batch_c_attr(batch, "a_tbn");
	        if (foam || normalmaps.length)
	            set_batch_c_attr(batch, "a_texcoord");
	        set_batch_directive(batch, "GENERATED_MESH", 0);
	    }

	    if (material.water_settings.is_dynamic) {
	        // setup dynamic water params
	        var dst_noise_scale0  = m_shaders.glsl_value(material.water_settings.dst_noise_scale0);
	        var dst_noise_scale1  = m_shaders.glsl_value(material.water_settings.dst_noise_scale1);
	        var dst_noise_freq0   = m_shaders.glsl_value(material.water_settings.dst_noise_freq0);
	        var dst_noise_freq1   = m_shaders.glsl_value(material.water_settings.dst_noise_freq1);
	        var dir_min_shore_fac = m_shaders.glsl_value(material.water_settings.dir_min_shore_fac);
	        var dir_freq          = m_shaders.glsl_value(material.water_settings.dir_freq);
	        var dir_noise_scale   = m_shaders.glsl_value(material.water_settings.dir_noise_scale);
	        var dir_noise_freq    = m_shaders.glsl_value(material.water_settings.dir_noise_freq);
	        var dir_min_noise_fac = m_shaders.glsl_value(material.water_settings.dir_min_noise_fac);
	        var dst_min_fac       = m_shaders.glsl_value(material.water_settings.dst_min_fac);
	        var waves_hor_fac     = m_shaders.glsl_value(material.water_settings.waves_hor_fac);

	        set_batch_directive(batch, "DST_NOISE_SCALE_0", dst_noise_scale0);
	        set_batch_directive(batch, "DST_NOISE_SCALE_1", dst_noise_scale1);
	        set_batch_directive(batch, "DST_NOISE_FREQ_0",  dst_noise_freq0);
	        set_batch_directive(batch, "DST_NOISE_FREQ_1",  dst_noise_freq1);
	        set_batch_directive(batch, "DIR_MIN_SHR_FAC",   dir_min_shore_fac);
	        set_batch_directive(batch, "DIR_FREQ",          dir_freq);
	        set_batch_directive(batch, "DIR_NOISE_SCALE",   dir_noise_scale);
	        set_batch_directive(batch, "DIR_NOISE_FREQ",    dir_noise_freq);
	        set_batch_directive(batch, "DIR_MIN_NOISE_FAC", dir_min_noise_fac);
	        set_batch_directive(batch, "DST_MIN_FAC",       dst_min_fac);
	        set_batch_directive(batch, "WAVES_HOR_FAC",     waves_hor_fac);
	    }

	    update_batch_specular_params(batch, material);
	    update_batch_diffuse_params(batch, material);

	    batch.shallow_water_col.set(material.water_settings.shallow_col);
	    batch.shore_water_col.set(material.water_settings.shore_col);
	    batch.shallow_water_col_fac = material.water_settings.shallow_col_fac;
	    batch.shore_water_col_fac   = material.water_settings.shore_col_fac;

	    set_batch_directive(batch, "ABSORB",
	                       m_shaders.glsl_value(material.water_settings.absorb_factor));
	    set_batch_directive(batch, "SSS_STRENGTH",
	                       m_shaders.glsl_value(material.water_settings.sss_strength));
	    set_batch_directive(batch, "SSS_WIDTH",
	                       m_shaders.glsl_value(material.water_settings.sss_width));
	}

	function update_batch_fresnel_params(batch, material) {
	    var rm = material.raytrace_mirror;
	    // used for non-transparent reflective objects
	    batch.reflect_factor = rm.reflect_factor;
	    batch.fresnel_params[0] = rm.fresnel;
	    // map [0.0 - 5.0] to [0.0 - 1.0]
	    batch.fresnel_params[1] = 1 - rm.fresnel_factor / 5;
	}

	function update_batch_specular_params(batch, material) {
	    var spec_param_0;
	    var spec_param_1 = 0;
	    switch (material.specular_shader) {
	    case "PHONG":
	    case "COOKTORR":
	        spec_param_0 = material.specular_hardness;
	        break;
	    case "WARDISO":
	        spec_param_0 = material.specular_slope;
	        break;
	    case "TOON":
	        spec_param_0 = material.specular_toon_size;
	        spec_param_1 = material.specular_toon_smooth;
	        break;
	    case "BLINN":
	        spec_param_0 = material.specular_ior;
	        spec_param_1 = material.specular_hardness;
	        break;
	    default:
	        m_print.error("unsupported specular shader: " +
	            material.specular_shader + " (material \"" +
	            material.name + "\")");
	        spec_param_0 = material.specular_hardness;
	        break;
	    }
	    batch.specular_params[0] = material.specular_intensity;
	    batch.specular_params[1] = spec_param_0;
	    batch.specular_params[2] = spec_param_1;
	}

	function update_batch_diffuse_params(batch, material) {
	    switch (material.diffuse_shader) {
	    case "LAMBERT":
	        batch.diffuse_params[0] = 0.0;
	        batch.diffuse_params[1] = 0.0;
	        break;
	    case "OREN_NAYAR":
	        batch.diffuse_params[0] = material.roughness;
	        batch.diffuse_params[1] = 0.0;
	        break;
	    case "FRESNEL":
	        batch.diffuse_params[0] = material.diffuse_fresnel;
	        batch.diffuse_params[1] = material.diffuse_fresnel_factor;
	        break;
	    case "MINNAERT":
	        batch.diffuse_params[0] = material.darkness;
	        batch.diffuse_params[1] = 0.0;
	        break;
	    case "TOON":
	        batch.diffuse_params[0] = material.diffuse_toon_size;
	        batch.diffuse_params[1] = material.diffuse_toon_smooth;
	        break;
	    default:
	        m_print.error("unsupported diffuse shader: " +
	            material.diffuse_shader + " (material \"" +
	            material.name + "\")");
	        batch.diffuse_params[0] = 0.0;
	        batch.diffuse_params[1] = 0.0;
	        break;
	    }
	}

	function update_batch_material_nodes(batch, material, mesh, shader_type) {
	    if (!material.use_nodes || material.do_not_render)
	        return false;

	    var is_glow_output;
	    switch (shader_type) {
	    case "MAIN":
	        apply_shader(batch, "main.glslv", "main.glslf");
	        is_glow_output = false;
	        break;
	    case "GLOW":
	        apply_shader(batch, "main.glslv", "main.glslf");
	        is_glow_output = true;
	        break;
	    case "SHADOW":
	        apply_shader(batch, "shadow.glslv", "shadow.glslf");
	        is_glow_output = false;
	        break;
	    case "COLOR_ID":
	        apply_shader(batch, "color_id.glslv", "color_id.glslf");
	        is_glow_output = false;
	        break;
	    }

	    var node_tree = material.node_tree;
	    var uuid = material.uuid;
	    var ngraph_proxy = m_nodemat.compose_ngraph_proxy(node_tree, uuid,
	            false, mesh["name"], material.name, shader_type,
	            { vc_name: mesh["active_vcol_name"], uv_name: mesh["active_uv_name"] });
	    if (!ngraph_proxy.graph) {
	        m_print.error("Failed to create node graph for material \"" +
	                material.name + "\", disable nodes");
	        update_batch_material_error(batch, material);
	        return true;
	    }
	    batch.ngraph_proxy_id = ngraph_proxy.id;

	    batch.has_nodes = true;
	    set_batch_directive(batch, "NODES", 1);

	    // some common stuff
	    set_batch_directive(batch, "DOUBLE_SIDED_LIGHTING",
	            (material.use_double_sided_lighting) ? 1 : 0);

	    set_batch_c_attr(batch, "a_position");

	    if (material.use_orco_tex_coord)
	        set_batch_c_attr(batch, "a_orco_tex_coord");

	    update_batch_blend_mode(batch, material);
	    batch.use_backface_culling = material.use_backface_culling;
	    batch.offset_z = material.offset_z;

	    if (is_glow_output) {
	        set_batch_directive(batch, "ALPHA", 1);
	        set_batch_directive(batch, "ALPHA_CLIP", 0);
	    } else {
	        set_batch_directive(batch, "ALPHA", (material.blend_mode === "OPAQUE") ? 0 : 1);
	        set_batch_directive(batch, "ALPHA_CLIP", (material.blend_mode === "CLIP") ? 1 : 0);
	    }

	    batch.xray = material.render_above_all && material.blend_mode != "OPAQUE"
	            && material.blend_mode != "CLIP" 
	            && material.blend_mode != "ALPHA_ANTIALIASING";

	    batch.emit = material.emit;
	    batch.ambient = material.ambient;
	    update_batch_fresnel_params(batch, material);

	    if (material.is_wettable) {
	        set_batch_directive(batch, "WETTABLE", 1);
	    } else
	        set_batch_directive(batch, "WETTABLE", 0);

	    var node_texture = null;
	    var has_shading_nodes = false;
	    m_graph.traverse(ngraph_proxy.graph, function(node, attr) {
	        switch (attr.type) {
	        case "UVMAP":
	        case "TEX_COORD_UV":
	        case "GEOMETRY_UV":
	        case "UV_MERGED":
	            var name = attr.data.name;
	            var uv_layer = attr.data.value;
	            // NOTE: will fail in case of multiple names for single uv layer
	            if (!batch.uv_maps_usage)
	                batch.uv_maps_usage = {};
	            batch.uv_maps_usage[uv_layer] = name;
	            break;
	        case "GEOMETRY_VC":
	        case "GEOMETRY_VC1":
	        case "GEOMETRY_VC2":
	        case "GEOMETRY_VC3":
	            var name = attr.data.name;
	            var vc_layer = attr.data.value;

	            // NOTE: will fail in case of multiple names for single vc layer
	            batch.vertex_colors_usage[name] = {
	                generate_buffer: true,
	                src: [{ name: vc_layer}]
	            };

	            var mask = 0;
	            if (attr.type == "GEOMETRY_VC")
	                mask = 7;
	            else {
	                for (var i = 0; i < attr.outputs.length; i++) {
	                    var index = "RGB".indexOf(attr.outputs[i].identifier);
	                    if (index > -1)
	                        mask |= 1 << (2 - index);
	                }
	            }
	            batch.vertex_colors_usage[name].src[0].mask = mask;
	            break;
	        case "TEX_COORD_NO":
	        case "TEX_COORD_RE":
	        case "GEOMETRY_NO":
	        case "FRESNEL":
	        case "LAYER_WEIGHT":
	            set_batch_c_attr(batch, "a_tbn");
	            break;

	        case "TEX_COORD_OB":
	             set_batch_directive(batch, "USE_MODEL_TSR_INVERSE", 1);
	             break;

	        case "TEX_COORD_WI":
	            set_batch_directive(batch, "USE_POSITION_CLIP", 1);
	            break;

	        case "MATERIAL_BEGIN":
	            var mat_data = attr.data.value;
	            if (mat_data.use_tangent_shading) {
	                set_batch_directive(batch, "USE_TBN_SHADING", 1);
	                if (batch.type != "PARTICLES")
	                    set_batch_c_attr(batch, "a_shade_tangs");
	            }
	            set_batch_c_attr(batch, "a_tbn");
	            has_shading_nodes = true;
	            break;
	        case "BSDF_BEGIN":
	            has_shading_nodes = true;
	            set_batch_c_attr(batch, "a_tbn");
	            break;
	        case "TEXTURE_COLOR":
	        case "TEXTURE_ENVIRONMENT_CUBE":
	        case "TEXTURE_ENVIRONMENT_EQUIRECTANGULAR":
	        case "TEXTURE_ENVIRONMENT_MIRROR_BALL":
	            var name = attr.data.name;
	            var bpy_name = attr.data.bpy_name;
	            var tex = attr.data.value;
	            append_texture(batch, tex, name, bpy_name);

	            break;
	        case "TEXTURE_NORMAL":
	        case "B4W_PARALLAX":
	            set_batch_directive(batch, "CALC_TBN_SPACE", 1);
	            set_batch_c_attr(batch, "a_tbn");
	            if (attr.data) {
	                var name = attr.data.name;
	                var bpy_name = attr.data.bpy_name;
	                var tex = attr.data.value;
	                append_texture(batch, tex, name, bpy_name);
	            }

	            break;
	        case "NORMAL_MAP":
	            set_batch_c_attr(batch, "a_tbn");

	            var space = Number(attr.dirs[0][1]);
	            // NOTE: keep synchronized with nodemat.js:append_nmat_node
	            switch (space) {
	            case m_nodemat.NM_TANGENT:
	                set_batch_directive(batch, "CALC_TBN_SPACE", 1);
	                break;
	            case m_nodemat.NM_OBJECT:
	            case m_nodemat.NM_BLENDER_OBJECT:
	                set_batch_directive(batch, "USE_MODEL_TSR", 1);
	                break;
	            }
	            break;
	        case "LAMP":
	            if (attr.data)
	                batch.lamp_uuid_indexes = attr.data;
	            break;
	        case "B4W_REFRACTION":
	            if (batch.blend)
	                batch.refractive = true;
	            else {
	                batch.refractive = false;
	                m_print.warn("Material \"" + material.name + "\" is not blend. " +
	                             "Disabling refractions.");
	            }
	            set_batch_directive(batch, "USE_POSITION_CLIP", 1);
	            break;
	        case "VALTORGB":
	        case "CURVE_VEC":
	        case "CURVE_RGB":
	            if (!node_texture)
	                node_texture = attr.data.texture;
	            break;
	        case "PARTICLE_INFO":
	            if (batch.type == "PARTICLES" && attr.data)
	                batch.part_node_data = attr.data;
	            break;
	        case "VECT_TRANSFORM":
	            var conv_type = Number(attr.dirs[1][1]);
	            // NOTE: keep synchronized with nodemat.js:append_nmat_node
	            switch (conv_type) {
	            case m_nodemat.VT_WORLD_TO_OBJECT:
	                 set_batch_directive(batch, "USE_MODEL_TSR_INVERSE", 1);
	                 break;
	            case m_nodemat.VT_WORLD_TO_CAMERA:
	                 set_batch_directive(batch, "USE_VIEW_TSR", 1);
	                 break;
	            case m_nodemat.VT_OBJECT_TO_WORLD:
	                 set_batch_directive(batch, "USE_MODEL_TSR", 1);
	                 break;
	            case m_nodemat.VT_OBJECT_TO_CAMERA:
	                 set_batch_directive(batch, "USE_MODEL_TSR", 1);
	                 set_batch_directive(batch, "USE_VIEW_TSR", 1);
	                 break;
	            case m_nodemat.VT_CAMERA_TO_WORLD:
	                 set_batch_directive(batch, "USE_VIEW_TSR_INVERSE", 1);
	                 break;
	            case m_nodemat.VT_CAMERA_TO_OBJECT:
	                 set_batch_directive(batch, "USE_MODEL_TSR_INVERSE", 1);
	                 set_batch_directive(batch, "USE_VIEW_TSR_INVERSE", 1);
	                 break;
	            }
	            break;
	        case "OBJECT_INFO":
	            set_batch_directive(batch, "USE_MODEL_TSR", 1);
	            batch.obj_info_params[1] = material.pass_index;
	            batch.obj_info_params[2] = Math.random();
	            break;
	        case "B4W_VECTOR_VIEW":
	        case "GEOMETRY_VW":
	            set_batch_directive(batch, "USE_VIEW_TSR", 1);
	            break;
	        case "B4W_REFLECT":
	            set_batch_directive(batch, "USE_VIEW_TSR_INVERSE", 1);
	            break;
	        case "BUMP":
	        case "DISPLACEMENT_BUMP":
	            set_batch_c_attr(batch, "a_tbn");
	            if (m_extensions.get_standard_derivatives())
	                set_batch_directive(batch, "USE_DERIVATIVES_EXT", 1);
	            else
	                m_print.warn("\"OES_standard_derivatives\" extension is not available. "
	                        + "Disabling the BUMP node in the \"" + material.name 
	                        + "\" material.");
	            break;
	        case "BSDF_TRANSPARENT":
	            batch.blend = true;
	            batch.refractive  = true;
	            break;
	        case "BSDF_GLOSSY":
	        case "BSDF_DIFFUSE":
	            set_batch_directive(batch, "USE_BSDF_SKY_DIM", 1);
	            if (m_extensions.get_texture_lod())
	                set_batch_directive(batch, "USE_TEXTURE_LOD_EXT", 1);
	        }
	    });

	    if (node_texture)
	        append_texture(batch, node_texture, "u_nodes_texture");

	    if (!has_shading_nodes)
	        batch.use_shadeless = true;

	    var node_elems = batch.shaders_info.node_elements =
	          m_nodemat.compose_node_elements(ngraph_proxy.graph);

	    prepare_nodemats_containers(ngraph_proxy.graph, batch, material.name);

	    var node_value_inds = batch.node_value_inds;
	    var node_rgb_inds = batch.node_rgb_inds;

	    for (var i = 0; i < node_elems.length; i++) {
	        var node = node_elems[i];
	        switch (node.id) {
	        case "VALUE":
	            var ind = node.param_values[0];
	            if (ind) {
	                for (var j = 0; j < node_value_inds.length; j+=3) {
	                    if (node_value_inds[j] == ind) {
	                        node.dirs.push(["VALUE_ROW_IND", node_value_inds[j+1]]);
	                        node.dirs.push(["VALUE_COL_IND", node_value_inds[j+2]]);
	                        break;
	                    }
	                }
	            }
	            break;
	        case "RGB":
	            var ind = node.param_values[0];
	            if (ind) {
	                for (var j = 0; j < node_rgb_inds.length; j+=2) {
	                    if (node_rgb_inds[j] == ind) {
	                        node.dirs.push(["RGB_IND", node_rgb_inds[j+1]]);
	                        break;
	                    }
	                }
	            }
	            break;
	        default:
	        }
	    }

	    set_batch_directive(batch, "NUM_VALUES", batch.node_values.length / 4);
	    set_batch_directive(batch, "NUM_RGBS", batch.node_rgbs.length);

	    return true;
	}

	function update_batch_world_nodes(batch, scene) {
	    var wls = scene._render.world_light_set;

	    if (wls.ngraph_proxy_id != "") {
	        batch.has_nodes = true;
	        batch.ngraph_proxy_id = wls.ngraph_proxy_id;

	        var ngraph_proxy = m_nodemat.get_ngraph_proxy_cached(wls.ngraph_proxy_id);
	        var ngraph = ngraph_proxy.graph;

	        if (!ngraph) {
	            m_print.error("Failed to create node graph for world \"" +
	                    scene["world"]["name"] + "\", disable nodes");
	            update_batch_material_error(batch, scene["world"]["name"] );
	            return true;
	        }

	        var node_texture = null;
	        m_graph.traverse(ngraph, function(node, attr) {
	            switch (attr.type) {
	            case "TEXTURE_COLOR":
	            case "TEXTURE_ENVIRONMENT_EQUIRECTANGULAR":
	            case "TEXTURE_ENVIRONMENT_MIRROR_BALL":
	                var name = attr.data.name;
	                var bpy_name = attr.data.bpy_name;
	                var tex = attr.data.value;
	                append_texture(batch, tex, name, bpy_name);
	                break;
	            case "VALTORGB":
	            case "CURVE_VEC":
	            case "CURVE_RGB":
	                if (!node_texture)
	                    node_texture = attr.data.texture;
	                break;
	            case "VECT_TRANSFORM":
	                var conv_type = Number(attr.dirs[1][1]);
	                // NOTE: keep synchronized with nodemat.js:append_nmat_node
	                switch (conv_type) {
	                case m_nodemat.VT_WORLD_TO_OBJECT:
	                     set_batch_directive(batch, "USE_MODEL_TSR_INVERSE", 1);
	                     break;
	                case m_nodemat.VT_WORLD_TO_CAMERA:
	                     set_batch_directive(batch, "USE_VIEW_TSR", 1);
	                     break;
	                case m_nodemat.VT_OBJECT_TO_WORLD:
	                     set_batch_directive(batch, "USE_MODEL_TSR", 1);
	                     break;
	                case m_nodemat.VT_OBJECT_TO_CAMERA:
	                     set_batch_directive(batch, "USE_MODEL_TSR", 1);
	                     set_batch_directive(batch, "USE_VIEW_TSR", 1);
	                     break;
	                case m_nodemat.VT_CAMERA_TO_WORLD:
	                     set_batch_directive(batch, "USE_VIEW_TSR_INVERSE", 1);
	                     break;
	                case m_nodemat.VT_CAMERA_TO_OBJECT:
	                     set_batch_directive(batch, "USE_MODEL_TSR_INVERSE", 1);
	                     set_batch_directive(batch, "USE_VIEW_TSR_INVERSE", 1);
	                     break;
	                }
	                break;
	            case "B4W_VECTOR_VIEW":
	                set_batch_directive(batch, "USE_VIEW_TSR", 1);
	                break;
	            case "B4W_REFLECT":
	                set_batch_directive(batch, "USE_VIEW_TSR_INVERSE", 1);
	                break;
	            }
	        });

	        if (node_texture)
	            append_texture(batch, node_texture, "u_nodes_texture");

	        var node_elems = batch.shaders_info.node_elements =
	              m_nodemat.compose_node_elements(ngraph);

	        prepare_nodemats_containers(ngraph, batch, scene["world"]["name"]);

	        var node_value_inds = batch.node_value_inds;
	        var node_rgb_inds = batch.node_rgb_inds;

	        for (var i = 0; i < node_elems.length; i++) {
	            var node = node_elems[i];
	            switch (node.id) {
	            case "VALUE":
	                var ind = node.param_values[0];
	                if (ind) {
	                    for (var j = 0; j < node_value_inds.length; j+=3) {
	                        if (node_value_inds[j] == ind) {
	                            node.dirs.push(["VALUE_ROW_IND", node_value_inds[j+1]]);
	                            node.dirs.push(["VALUE_COL_IND", node_value_inds[j+2]]);
	                            break;
	                        }
	                    }
	                }
	                break;
	            case "RGB":
	                var ind = node.param_values[0];
	                if (ind) {
	                    for (var j = 0; j < node_rgb_inds.length; j+=2) {
	                        if (node_rgb_inds[j] == ind) {
	                            node.dirs.push(["RGB_IND", node_rgb_inds[j+1]]);
	                            break;
	                        }
	                    }
	                }
	                break;
	            default:
	            }
	        }

	        set_batch_directive(batch, "NUM_VALUES", batch.node_values.length / 4);
	        set_batch_directive(batch, "NUM_RGBS", batch.node_rgbs.length);

	        return true;
	    } else

	    return false;
	}

	function prepare_nodemats_containers(ngraph, batch, mat_name) {

	    var node_values = [];
	    var node_value_inds = [];
	    var node_rgbs = [];
	    var node_rgb_inds = [];

	    gather_node_values_r(ngraph, "",
	                         node_values, node_value_inds,
	                         node_rgbs, node_rgb_inds);

	    batch.node_values = node_values;
	    batch.node_value_inds = node_value_inds;

	    batch.node_rgbs = node_rgbs;
	    batch.node_rgb_inds = node_rgb_inds;

	}

	function gather_node_values_r(ngraph, names_str,
	                              node_values, value_inds,
	                              node_rgbs, rgb_inds) {

	    // collect all VALUE and RGB nodes
	    m_graph.traverse(ngraph, function(id, node) {
	        if (node.type == "VALUE") {
	            var param_name = join_name(names_str, node.name);
	            node_values.push(node.outputs[0].default_value);
	            var ind = value_inds.length / 3;
	            var row = parseInt(ind / 4.0);
	            var col = parseInt(ind % 4.0);
	            value_inds.push(param_name, row, col);

	        } else if (node.type == "RGB") {
	            var param_name = join_name(names_str, node.name);
	            var def_value = node.outputs[0].default_value.slice(0,3);
	            node_rgbs.push(def_value[0], def_value[1], def_value[2]);
	            rgb_inds.push(param_name, rgb_inds.length / 2);

	        }
	    });
	    var len = node_values.length + 4 - node_values.length % 4;
	    for (var i = node_values.length; i < len; i++)
	        node_values.push(0);
	}



	function join_name(name1, name2) {
	    var new_name = name1 ? name1 + "%join%": "";
	    new_name += name2;
	    return new_name;
	}

	exports.update_batch_material_error = update_batch_material_error;
	function update_batch_material_error(batch, material) {

	    switch (batch.type) {
	    case "SHADOW":
	        apply_shader(batch, "shadow.glslv", "shadow.glslf");
	        break;
	    case "COLOR_ID":
	        apply_shader(batch, "color_id.glslv", "color_id.glslf");
	        break;
	    default:
	        apply_shader(batch, "main.glslv", "main_stack.glslf");
	        break;
	    }

	    set_batch_directive(batch, "SHADELESS", 1);
	    set_batch_c_attr(batch, "a_position");
	    set_batch_c_attr(batch, "a_tbn");
	    m_vec4.set(1, 0, 1, 1, batch.diffuse_color);

	    if (material) {
	        set_batch_directive(batch, "ALPHA", (material.blend_mode === "OPAQUE") ? 0 : 1);
	        set_batch_directive(batch, "ALPHA_CLIP", (material.blend_mode === "CLIP") ? 1 : 0);

	        set_batch_directive(batch, "VERTEX_COLOR", 0);

	        batch.offset_z = material.offset_z;

	        update_batch_blend_mode(batch, material);
	        batch.use_backface_culling = material.use_backface_culling;
	    }

	    return true;
	}

	function update_batch_material_shadow_receive(batch, material, mesh) {

	    if (material.is_lens_flares || material.water_settings.is_water ||
	            material.do_not_render || material.type == "HALO")
	        return false;

	    update_batch_blend_mode(batch, material);
	    batch.use_backface_culling = material.use_backface_culling;

	    if (batch.blend)
	        return false;

	    if (material.use_nodes && (material.blend_mode == "CLIP" 
	            || material.blend_mode == "ALPHA_ANTIALIASING"))
	        update_batch_material_nodes(batch, material, mesh, "SHADOW");
	    else
	        apply_shader(batch, "shadow.glslv", "shadow.glslf");

	    // NOTE: Don't save depth for ALPHA_ANTIALIASING materials in Shadow Recieve.
	    batch.depth_mask = batch.depth_mask && !(cfg_def.reuse_depth_optimization &&
	            material.blend_mode == "ALPHA_ANTIALIASING");

	    m_vec4.set(0, 0, 0, material.alpha, batch.diffuse_color);

	    set_batch_c_attr(batch, "a_position");
	    set_batch_c_attr(batch, "a_tbn");

	    var alpha = (material.blend_mode === "OPAQUE") ? 0 : 1;
	    set_batch_directive(batch, "ALPHA", alpha);

	    batch.texture_scale.set([1, 1, 1]);

	    var texture_slots = material.texture_slots;
	    var colormap0 = find_valid_tex_slots("use_map_color_diffuse", true, 
	            texture_slots)[0];
	    // var alpha_clip = (material.blend_mode === "CLIP") ? 1 : 0;
	    // set_batch_directive(batch, "ALPHA_CLIP", alpha_clip);

	    if (colormap0 && (material.blend_mode == "CLIP" 
	            || material.blend_mode == "ALPHA_ANTIALIASING")) {

	        switch (colormap0["blend_type"]) {
	        case "MIX":
	            set_batch_directive(batch, "TEXTURE_BLEND_TYPE", "TEXTURE_BLEND_TYPE_MIX");
	            break;
	        case "MULTIPLY":
	            set_batch_directive(batch, "TEXTURE_BLEND_TYPE", "TEXTURE_BLEND_TYPE_MULTIPLY");
	            break;
	        }

	        batch.texture_scale.set(colormap0["scale"]);
	        set_batch_directive(batch, "TEXTURE_COLOR", 1);
	        set_batch_c_attr(batch, "a_texcoord");

	        var tex = m_textures.get_batch_texture(colormap0);
	        var bpy_tex = colormap0["texture"];

	        if (tex.source == "IMAGE" || tex.source == "ENVIRONMENT_MAP" ||
	                tex.source == "CANVAS" || tex.source == "NONE")
	            append_texture(batch, tex, "u_colormap0", bpy_tex["name"]);

	    } else
	        set_batch_directive(batch, "TEXTURE_COLOR", 0);

	    return true;
	}

	function update_batch_material_physics(batch, material) {

	    var ps = material.physics_settings;
	    var ws = material.water_settings;

	    if (ps.use_coll_physics) {
	        batch.use_ghost = ps.use_ghost;
	        batch.collision_id = ps.collision_id;
	        batch.collision_margin = ps.collision_margin;
	        batch.collision_group = ps.collision_group;
	        batch.collision_mask = ps.collision_mask;
	        batch.friction = ps.friction;
	        batch.elasticity = ps.elasticity;
	        return true;

	    } else if (ws.is_water) {
	        // setup dynamic water params
	        batch.water = true;
	        batch.water_dynamics    = ws.is_dynamic;
	        batch.dst_noise_scale0  = ws.dst_noise_scale0;
	        batch.dst_noise_scale1  = ws.dst_noise_scale1;
	        batch.dst_noise_freq0   = ws.dst_noise_freq0;
	        batch.dst_noise_freq1   = ws.dst_noise_freq1;
	        batch.dir_min_shore_fac = ws.dir_min_shore_fac;
	        batch.dir_freq          = ws.dir_freq;
	        batch.dir_noise_scale   = ws.dir_noise_scale;
	        batch.dir_noise_freq    = ws.dir_noise_freq;
	        batch.dir_min_noise_fac = ws.dir_min_noise_fac;
	        batch.dst_min_fac       = ws.dst_min_fac;
	        batch.waves_hor_fac     = ws.waves_hor_fac;
	        return true;

	    } else
	        return false;
	}

	function update_batch_material_color_id(batch, material, mesh) {
	    if (material.is_lens_flares || material.type == "HALO")
	        return false;

	    // Alpha Anti-Aliasing should be Alpha Clip for COLOR_ID batches
	    var src_blend_mode = material.blend_mode;
	    var blend_mode = src_blend_mode;
	    if (blend_mode == "ALPHA_ANTIALIASING") {
	        blend_mode = "CLIP";
	        material.blend_mode = "CLIP";
	    }

	    update_batch_blend_mode(batch, material);
	    batch.use_backface_culling = material.use_backface_culling;

	    batch.z_sort = false;
	    batch.depth_mask = true;

	    // blend allowed but rendered as non-blend
	    batch.blend = false;
	    
	    batch.xray = material.render_above_all && blend_mode != "OPAQUE"
	            && blend_mode != "CLIP";

	    if (material.use_nodes && blend_mode == "CLIP")
	        update_batch_material_nodes(batch, material, mesh, "COLOR_ID");
	    else
	        apply_shader(batch, "color_id.glslv", "color_id.glslf");

	    m_vec4.set(0, 0, 0, material.alpha, batch.diffuse_color);

	    set_batch_c_attr(batch, "a_position");

	    var alpha = (blend_mode === "OPAQUE") ? 0 : 1;
	    set_batch_directive(batch, "ALPHA", alpha);

	    batch.texture_scale.set([1, 1, 1]);

	    var texture_slots = material.texture_slots;
	    var colormap0 = find_valid_tex_slots("use_map_color_diffuse", true, texture_slots)[0];

	    var alpha_clip = (blend_mode === "CLIP") ? 1 : 0;
	    set_batch_directive(batch, "ALPHA_CLIP", alpha_clip);

	    if (colormap0 && blend_mode == "CLIP") {

	        switch (colormap0["blend_type"]) {
	        case "MIX":
	            set_batch_directive(batch, "TEXTURE_BLEND_TYPE", "TEXTURE_BLEND_TYPE_MIX");
	            break;
	        case "MULTIPLY":
	            set_batch_directive(batch, "TEXTURE_BLEND_TYPE", "TEXTURE_BLEND_TYPE_MULTIPLY");
	            break;
	        }
	        batch.texture_scale.set(colormap0["scale"]);
	        set_batch_directive(batch, "TEXTURE_COLOR", 1);
	        set_batch_c_attr(batch, "a_texcoord");

	        var tex = m_textures.get_batch_texture(colormap0);
	        var bpy_tex = colormap0["texture"];

	        if (tex.source == "IMAGE" || tex.source == "ENVIRONMENT_MAP" ||
	                tex.source == "CANVAS" || tex.source == "NONE")
	            append_texture(batch, tex, "u_colormap0", bpy_tex["name"]);

	    } else
	        set_batch_directive(batch, "TEXTURE_COLOR", 0);

	    // restore original blend_mode type
	    material.blend_mode = src_blend_mode;

	    return true;
	}

	function update_batch_material_debug_view(batch, material) {
	    if (material && (material.is_lens_flares || material.do_not_render))
	        return false;

	    apply_shader(batch, "debug_view.glslv", "debug_view.glslf");
	    set_batch_c_attr(batch, "a_position");
	    set_batch_c_attr(batch, "a_tbn");
	    set_batch_c_attr(batch, "a_polyindex");

	    batch.depth_mask = true;

	    m_vec3.set(0, 0, 0, batch.wireframe_edge_color);

	    return true;
	}

	function update_batch_material_grass_map(batch, material) {
	    if (!material.terrain_settings.is_terrain || material.do_not_render)
	        return false;

	    update_batch_blend_mode(batch, material);
	    batch.use_backface_culling = material.use_backface_culling;
	    
	    // override some gs
	    batch.blend = false;
	    batch.z_sort = false;
	    batch.depth_mask = true;

	    apply_shader(batch, "grass_map.glslv", "grass_map.glslf");
	    set_batch_c_attr(batch, "a_position");

	    if (material.terrain_settings.dynamic_grass_size)
	        var vc_usage_gr_size = material.terrain_settings.dynamic_grass_size;
	    else
	        var vc_usage_gr_size = null;
	    
	    if (material.terrain_settings.dynamic_grass_color)
	        var vc_usage_gr_color = material.terrain_settings.dynamic_grass_color;
	    else
	        var vc_usage_gr_color = null;

	    batch.vertex_colors_usage["a_grass_size"] = {
	        generate_buffer: true,
	        src: []
	    };
	    if (vc_usage_gr_size) {
	        batch.vertex_colors_usage["a_grass_size"].src.push({
	                name: vc_usage_gr_size, mask: 4 });
	        set_batch_directive(batch, "DYNAMIC_GRASS_SIZE", 1);
	    } else
	        set_batch_directive(batch, "DYNAMIC_GRASS_SIZE", 0);

	    batch.vertex_colors_usage["a_grass_color"] = {
	        generate_buffer: true,
	        src: []
	    };
	    if (vc_usage_gr_color) {
	        batch.vertex_colors_usage["a_grass_color"].src.push({
	                name: vc_usage_gr_color, mask: 7 });
	        set_batch_directive(batch, "DYNAMIC_GRASS_COLOR", 1);
	    } else
	        set_batch_directive(batch, "DYNAMIC_GRASS_COLOR", 0);

	    var grass_tex_size = cfg_scs.grass_tex_size;
	    set_batch_directive(batch, "GRASS_TEXTURE_SIZE", m_shaders.glsl_value(grass_tex_size));

	    return true;
	}

	function update_batch_material_particles(batch, material, mesh) {
	    if (material.do_not_render)
	        return false;

	    var texture_slots = material.texture_slots;

	    if (batch.halo_particles) {
	        apply_shader(batch, "particle_system.glslv", "particle_system_stack.glslf");
	        set_batch_directive(batch, "HALO_PARTICLES", 1);
	        set_batch_halo_data(batch, material);
	    } else {
	        
	        var data = {
	            use_shadeless: false,
	            diffuse_shader: material.diffuse_shader,
	            specular_shader: material.specular_shader,
	            use_tangent_shading: material.use_tangent_shading
	        };
	        if (material.use_nodes) {
	            apply_shader(batch, "particle_system.glslv", "particle_system.glslf");
	            update_batch_material_nodes(batch, material, mesh, "PARTICLES");
	            return true;
	        } else {
	            apply_shader(batch, "particle_system.glslv", "particle_system_stack.glslf");
	            var nmat_graph = m_nodemat.create_lighting_graph(material.uuid, data);
	            batch.shaders_info.node_elements =
	                    m_nodemat.compose_node_elements(nmat_graph);
	        }

	        var colormap = find_valid_tex_slots("use_map_color_diffuse", true, texture_slots)[0];

	        if (colormap) {
	            set_batch_directive(batch, "TEXTURE_COLOR", 1);

	            switch (colormap["blend_type"]) {
	            case "MIX":
	                set_batch_directive(batch, "TEXTURE_BLEND_TYPE", "TEXTURE_BLEND_TYPE_MIX");
	                break;
	            case "MULTIPLY":
	                set_batch_directive(batch, "TEXTURE_BLEND_TYPE", "TEXTURE_BLEND_TYPE_MULTIPLY");
	                break;
	            }

	            batch.diffuse_color_factor = colormap["diffuse_color_factor"];
	            if (colormap["use_map_alpha"])
	                batch.alpha_factor = colormap["alpha_factor"];
	            else
	                batch.alpha_factor = 0.0;

	            var tex = m_textures.get_batch_texture(colormap);
	            var name = "default" + String(batch.textures.length);
	            var bpy_tex = colormap["texture"];

	            append_texture(batch, tex, name, bpy_tex["name"]);
	        }
	    }

	    batch.diffuse_color.set(material.diffuse_color);
	    batch.diffuse_color[3] = material.alpha;

	    batch.ambient = material.ambient;
	    batch.diffuse_intensity = material.diffuse_intensity;
	    batch.emit = material.emit;
	    batch.specular_color.set(material.specular_color);
	    batch.specular_alpha = material.specular_alpha;

	    set_batch_c_attr(batch, "a_position");
	    set_batch_c_attr(batch, "a_tbn");

	    set_batch_directive(batch, "ALPHA", (material.blend_mode === "OPAQUE") ? 0 : 1);
	    set_batch_directive(batch, "ALPHA_CLIP", (material.blend_mode === "CLIP") ? 1 : 0);

	    set_batch_directive(batch, "PARTICLES_SHADELESS",
	                        material.use_shadeless ? 1 : 0);

	    update_batch_specular_params(batch, material);
	    update_batch_diffuse_params(batch, material);

	    update_batch_blend_mode(batch, material);
	    batch.use_backface_culling = material.use_backface_culling;

	    batch.xray = material.render_above_all && material.blend_mode != "OPAQUE"
	            && material.blend_mode != "CLIP" 
	            && material.blend_mode != "ALPHA_ANTIALIASING";

	    batch.offset_z = material.offset_z;

	    return true;
	}

	/**
	 * Update batch from object render
	 */
	function update_batch_render(batch, render) {

	    batch.data_id = render.data_id;

	    if (batch.type === "PHYSICS")
	        return;

	    if (render.type == "DYNAMIC" || batch.type == "COLOR_ID") {
	        if (render.is_hair_particles)
	            set_batch_directive(batch, "AU_QUALIFIER", "GLSL_IN");
	        else
	            set_batch_directive(batch, "AU_QUALIFIER", "uniform");
	        set_batch_directive(batch, "STATIC_BATCH", 0);
	    } else {
	        set_batch_directive(batch, "AU_QUALIFIER", "GLSL_IN");
	        set_batch_directive(batch, "STATIC_BATCH", 1);
	    }

	    if (batch.type == "DEBUG_VIEW") {
	        if (m_extensions.get_standard_derivatives())
	            set_batch_directive(batch, "WIREFRAME_QUALITY", 1);
	        else
	            set_batch_directive(batch, "WIREFRAME_QUALITY", 0);

	        if (batch.debug_sphere) {
	            set_batch_directive(batch, "DEBUG_SPHERE", 1);
	            if (batch.debug_sphere_dynamic)
	                set_batch_directive(batch, "DEBUG_SPHERE_DYNAMIC", 1);
	            else
	                set_batch_directive(batch, "DEBUG_SPHERE_DYNAMIC", 0);
	        } else
	            set_batch_directive(batch, "DEBUG_SPHERE", 0);

	        set_batch_directive(batch, "ALPHA", 1);
	    }

	    if (render.use_shape_keys && batch.type != "PARTICLES" 
	            && !render.is_hair_particles)
	        batch.use_shape_keys = render.use_shape_keys;

	    if (render.wind_bending) {
	        if (render.main_bend_col !== "") {

	            batch.vertex_colors_usage["a_bending_col_main"] = {
	                generate_buffer: true,
	                src: [{ name: render.main_bend_col, mask: 4 }]
	            };

	            set_batch_c_attr(batch, "a_bending_col_main");

	            if (render.detail_bend_col.leaves_stiffness      !== "" &&
	                    render.detail_bend_col.leaves_phase      !== "" &&
	                    render.detail_bend_col.overall_stiffness !== "") {

	                batch.vertex_colors_usage["a_bending_col_detail"] = {
	                    generate_buffer: true,
	                    src: [
	                        { name: render.detail_bend_col.leaves_stiffness, mask: 4 },
	                        { name: render.detail_bend_col.leaves_phase, mask: 2 },
	                        { name: render.detail_bend_col.overall_stiffness, mask: 1 }
	                    ]
	                };
	                set_batch_c_attr(batch, "a_bending_col_detail");
	                set_batch_c_attr(batch, "a_tbn");

	                set_batch_directive(batch, "DETAIL_BEND", 1);
	            } else
	                set_batch_directive(batch, "DETAIL_BEND", 0);

	            set_batch_directive(batch, "MAIN_BEND_COL", 1);
	        } else
	            set_batch_directive(batch, "MAIN_BEND_COL", 0);

	        if (render.bend_center_only)
	            set_batch_directive(batch, "BEND_CENTER_ONLY", 1);
	        else
	            set_batch_directive(batch, "BEND_CENTER_ONLY", 0);

	        set_batch_directive(batch, "WIND_BEND", 1);
	    } else
	        set_batch_directive(batch, "WIND_BEND", 0);

	    set_batch_directive(batch, "BILLBOARD_PRES_GLOB_ORIENTATION",
	            render.billboard_pres_glob_orientation | 0);

	    if (render.billboard)
	        set_batch_directive(batch, "BILLBOARD", 1);
	    else
	        set_batch_directive(batch, "BILLBOARD", 0);

	    if (render.billboard && render.is_hair_particles)
	        set_batch_directive(batch, "HAIR_BILLBOARD", 1);
	    else
	        set_batch_directive(batch, "HAIR_BILLBOARD", 0);

	    if (render.billboard_spherical)
	        set_batch_directive(batch, "BILLBOARD_SPHERICAL", 1);
	    else
	        set_batch_directive(batch, "BILLBOARD_SPHERICAL", 0);

	    switch (render.billboard_type) {
	    case "RANDOM":
	        set_batch_directive(batch, "BILLBOARD_RANDOM", 1);
	        set_batch_directive(batch, "BILLBOARD_JITTERED", 0);
	        break;
	    case "JITTERED":
	        set_batch_directive(batch, "BILLBOARD_RANDOM", 0);
	        set_batch_directive(batch, "BILLBOARD_JITTERED", 1);
	        break;
	    default:
	        set_batch_directive(batch, "BILLBOARD_RANDOM", 0);
	        set_batch_directive(batch, "BILLBOARD_JITTERED", 0);
	        break;
	    }

	    if (render.dynamic_grass && cfg_def.allow_vertex_textures)
	        set_batch_directive(batch, "DYNAMIC_GRASS", 1);
	    else
	        set_batch_directive(batch, "DYNAMIC_GRASS", 0);

	    // set flag to recognize it during subs addition
	    // maybe should analize directive instead
	    batch.dynamic_grass = render.dynamic_grass;

	    if (batch.type != "PARTICLES")
	        batch.dynamic_geometry = render.dynamic_geometry;

	    batch.shadow_cast = render.shadow_cast;
	    batch.shadow_cast_only = render.shadow_cast_only;
	    // NOTE: Will be overriden for DEPTH and COLOR_ID node batches
	    batch.shadow_receive = render.shadow_receive && !batch.use_shadeless &&
	        !(batch.blend && cfg_def.disable_blend_shadows_hack);

	    if (cfg_def.rgba_fallback_shadows) {
	        if (batch.type == "MAIN" && batch.shadow_receive ||
	                batch.type == "SHADOW")
	            set_batch_directive(batch, "RGBA_SHADOWS", 1);
	    } else
	        set_batch_directive(batch, "RGBA_SHADOWS", 0);

	    batch.reflexible = render.reflexible;
	    batch.reflexible_only = render.reflexible_only;
	    batch.reflective = render.reflective;

	    batch.obj_info_params[0] = render.pass_index;

	    // copy LOD properties that should divide batches
	    batch.lod_dist_max = render.lod_dist_max;
	    batch.lod_dist_min = render.lod_dist_min;
	    batch.lod_lower_border_range = render.lod_lower_border_range;
	    batch.lod_upper_border_range = render.lod_upper_border_range;

	    batch.cube_reflection_id = render.cube_reflection_id;
	    batch.plane_reflection_id = render.plane_reflection_id;

	    if (render.is_skinning) {
	        set_batch_c_attr(batch, "a_influence");
	        set_batch_directive(batch, "SKINNED", 1);
	        if (cfg_def.skinning_hack) {
	            set_batch_directive(batch, "DISABLE_TANGENT_SKINNING", 1);
	            set_batch_directive(batch, "FRAMES_BLENDING", 0);
	        } else {
	            set_batch_directive(batch, "DISABLE_TANGENT_SKINNING", 0);
	            if (render.frames_blending)
	                set_batch_directive(batch, "FRAMES_BLENDING", 1);
	            else
	                set_batch_directive(batch, "FRAMES_BLENDING", 0);
	        }
	        set_batch_directive(batch, "MAX_BONES", render.max_bones);
	    } else {
	        set_batch_directive(batch, "SKINNED", 0);
	        set_batch_directive(batch, "FRAMES_BLENDING", 0);
	        set_batch_directive(batch, "DISABLE_TANGENT_SKINNING", 0);
	    }

	    if (render.vertex_anim) {
	        set_batch_directive(batch, "VERTEX_ANIM", 1);
	        if (cfg_def.vert_anim_mix_normals_hack)
	            set_batch_directive(batch, "VERTEX_ANIM_MIX_NORMALS_FACTOR", 0.5);
	        else
	            set_batch_directive(batch, "VERTEX_ANIM_MIX_NORMALS_FACTOR",
	                    "u_va_frame_factor");
	    } else
	        set_batch_directive(batch, "VERTEX_ANIM", 0);

	    if (render.is_skinning && render.vertex_anim)
	        m_util.panic("Skinning and vertex animation are mutually exlusive");
	}

	exports.update_batch_lights = update_batch_lights;
	function update_batch_lights(batch, lamps, scene) {
	    if (!lamps.length)
	        return;

	    var use_ssao = cfg_def.ssao && scene["b4w_enable_ssao"];
	    var shadow_lamps = m_obj_util.get_shadow_lamps(lamps, use_ssao);
	    var shaders_info = batch.shaders_info;
	    var lamp_uuid_inds = batch.lamp_uuid_indexes;

	    var lamp_index = 0;
	    for (var i = 0; i < batch.shaders_info.node_elements.length; i++) {
	        var node = batch.shaders_info.node_elements[i];
	        if (node.id == "LIGHTING_LAMP") {
	            var lamp = lamps[lamp_index++ % lamps.length];
	            var light = lamp.light;

	            var lamp_sc_data = m_obj_util.get_scene_data(lamp, scene);

	            if (light.type == "SPOT" || light.type == "POINT")
	                var sp_size = Math.cos(light.spot_size / 2.0);

	            if (light.type == "SPOT")
	                var blend = light.spot_blend * (1.0 - sp_size);

	            var index = lamp_sc_data.light_index;

	            var shadow_map_ind = shadow_lamps.indexOf(lamp);

	            node.dirs = [["LAMP_TYPE", light.type],
	                         ["LAMP_IND", index],
	                         ["LAMP_SPOT_SIZE", m_shaders.glsl_value(sp_size || 0.01)],
	                         ["LAMP_SPOT_BLEND", m_shaders.glsl_value(blend || 0.01)],
	                         ["LAMP_LIGHT_DIST", m_shaders.glsl_value(light.distance)],
	                         ["LAMP_USE_SPHERE", light.use_sphere? 1: 0],
	                         ["LAMP_SHADOW_MAP_IND", shadow_map_ind]];

	        } else if (node.id == "LAMP" && lamp_uuid_inds) {
	            // NOTE: LAMP_INDEX is already inside node.dirs
	            var lamp_ind = node.dirs[0][1];

	            for (var j = 0; j < lamps.length; j++) {
	                var lamp = lamps[j];
	                if (lamp_uuid_inds[lamp.uuid] == lamp_ind) {
	                    var light = lamp.light;

	                    if (light.type == "SPOT" || light.type == "POINT")
	                        var sp_size = Math.cos(light.spot_size / 2.0);
	                    if (light.type == "SPOT")
	                        var blend = light.spot_blend * (1.0 - sp_size);

	                    node.dirs.push(
	                     ["LAMP_TYPE", light.type],
	                     ["LAMP_SPOT_SIZE",  m_shaders.glsl_value(sp_size || 0.01)],
	                     ["LAMP_SPOT_BLEND", m_shaders.glsl_value(blend || 0.01)],
	                     ["LAMP_LIGHT_DIST", m_shaders.glsl_value(light.distance)],
	                     ["LAMP_USE_SPHERE", light.use_sphere? 1: 0]
	                    );
	                }
	            }
	        }
	    }

	    if (lamp_uuid_inds) {
	        var lamp_size = 0;
	        for (var key in lamp_uuid_inds)
	            lamp_size++;

	        batch.lamp_light_positions = new Float32Array(lamp_size * 3);
	        batch.lamp_light_directions = new Float32Array(lamp_size * 3);
	        batch.lamp_light_color_intensities = new Float32Array(lamp_size * 3);
	        m_shaders.set_directive(shaders_info, "NUM_LAMP_LIGHTS", lamp_size);

	        for (var i = 0; i < lamps.length; i++)
	            set_lamp_data(batch, lamps[i]);
	    }
	}

	exports.set_lamp_data = set_lamp_data;
	function set_lamp_data(batch, lamp) {
	    if (lamp.uuid in batch.lamp_uuid_indexes) {
	        var data_lamp_index = batch.lamp_uuid_indexes[lamp.uuid];
	        var lamp_trans = m_tsr.get_trans_view(lamp.render.world_tsr);
	        batch.lamp_light_positions.set(lamp_trans, data_lamp_index * 3);
	        batch.lamp_light_directions.set(lamp.light.direction, data_lamp_index * 3);
	        batch.lamp_light_color_intensities.set(lamp.light.color_intensity, data_lamp_index * 3);
	    }
	}

	function update_batch_particle_systems(batch, psystems) {
	    for (var i = 0; i < psystems.length; i++) {
	        var emitter_col_name = psystems[i]["settings"]["b4w_vcol_from_name"];
	        var particle_col_name = psystems[i]["settings"]["b4w_vcol_to_name"];

	        if (emitter_col_name !== "" && particle_col_name !== "")
	            batch.vertex_colors_usage[emitter_col_name] = {
	                generate_buffer: false,
	                src: [{ name: emitter_col_name, mask: 7 }]
	            };
	    }
	}

	exports.assign_shadow_receive_dirs = function(batch, shadow_params, subs_cast) {
	    set_batch_directive(batch, "CSM_SECTION1", 0);
	    set_batch_directive(batch, "CSM_SECTION2", 0);
	    set_batch_directive(batch, "CSM_SECTION3", 0);
	    set_batch_directive(batch, "NUM_CAST_LAMPS", 0);

	    if (shadow_params) {
	        var num_cast_lamps = shadow_params.lamp_types.length;
	        set_batch_directive(batch, "NUM_CAST_LAMPS", num_cast_lamps);
	        if (cfg_def.mac_os_shadow_hack)
	            set_batch_directive(batch, "MAC_OS_SHADOW_HACK", 1);

	        for (var i = 1; i < shadow_params.csm_num; i++)
	            set_batch_directive(batch, "CSM_SECTION" + String(i), 1);

	        set_batch_directive(batch, "SHADOW_TEX_RES", m_shaders.glsl_value(
	                shadow_params.csm_resolution));
	        set_batch_directive(batch, "CSM_FADE_LAST_CASCADE",
	                shadow_params.fade_last_cascade ? 1 : 0);
	        set_batch_directive(batch, "CSM_BLEND_BETWEEN_CASCADES",
	                shadow_params.blend_between_cascades &&
	                !cfg_def.chrome_csm_blend_hack ? 1 : 0);
	    } else {
	        set_batch_directive(batch, "SHADOW_TEX_RES", 0);
	        set_batch_directive(batch, "CSM_FADE_LAST_CASCADE", 0);
	        set_batch_directive(batch, "CSM_BLEND_BETWEEN_CASCADES", 0);
	    }
	};

	/**
	 * For convenience
	 */
	function set_batch_c_attr(batch, name) {
	    var cattrs = batch.common_attributes;

	    if (cattrs.indexOf(name) == -1)
	        cattrs.push(name);

	    batch.common_attributes = cattrs.sort();
	}

	exports.set_batch_directive = set_batch_directive;
	/**
	 * Set batch directive. Needs shader applied to batch
	 * @methodOf batch
	 */
	function set_batch_directive(batch, name, value) {
	    m_shaders.set_directive(batch.shaders_info, name, value);
	}

	exports.get_batch_directive = get_batch_directive;
	/**
	 * Get batch directive.
	 * @methodOf batch
	 */
	function get_batch_directive(batch, name) {
	    return m_shaders.get_directive(batch.shaders_info, name);
	}

	/**
	 * Update batch geometry from submesh
	 */
	exports.update_batch_geometry = update_batch_geometry;
	function update_batch_geometry(batch, submesh) {
	    if (batch.type == "PHYSICS") {
	        if (batch.subtype == "NAVMESH") {
	            batch.bufs_data = m_geom.submesh_to_bufs_data(submesh,
	            m_geom.DM_DEFAULT, []);
	        } else {
	            if (submesh.shape_keys.length > 0)
	                m_geom.submesh_init_shape_keys(submesh, submesh.va_frames[0]);
	            batch.submesh = submesh;
	        }
	        return;
	    }

	    var draw_mode = batch.draw_mode;

	    if (batch.halo && batch.type != "PARTICLES")
	        submesh = m_geom.extract_halo_submesh(submesh);

	    if (batch.water_generated_mesh) {
	        var num_cascads   = batch.water_num_cascads;
	        var subdivs       = batch.water_subdivs;
	        var detailed_dist = batch.water_detailed_dist;
	        submesh = m_primitives.generate_cascaded_grid(num_cascads,
	                subdivs, detailed_dist);
	    }

	    var bufs_data = m_geom.submesh_to_bufs_data(submesh,
	            draw_mode, batch.vertex_colors_usage);

	    batch.bufs_data = bufs_data;

	    if (!(DEBUG_KEEP_BUFS_DATA_ARRAYS || batch.dynamic_geometry ||
	            batch.z_sort || batch.use_shape_keys)) {
	        bufs_data.ibo_array = null;
	        bufs_data.vbo_source_data.length = 0;
	    }

	    var frames = submesh.va_frames.length;

	    batch.num_vertices = submesh.base_length * frames;

	    // NOTE: only triangle batches counted
	    if (is_triangle_batch(batch)) {
	        if (m_geom.is_indexed(submesh))
	            batch.num_triangles = submesh.indices.length / 3 * frames;
	        else
	            batch.num_triangles = submesh.base_length / 3 * frames;
	    } else
	        batch.num_triangles = 0;
	    if (DEBUG_SAVE_SUBMESHES)
	        batch.submesh = submesh;
	}

	function is_triangle_batch(batch) {
	    switch(batch.draw_mode) {
	    case m_geom.DM_DEFAULT:
	    case m_geom.DM_TRIANGLES:
	    case m_geom.DM_DYNAMIC_TRIANGLES:
	        return true;
	    default:
	        return false;
	    }
	}

	/**
	 * Update batch from EMITTER particle system/settings
	 */
	function update_batch_particles_emitter(batch, psystem, obj) {
	    var pset = psystem["settings"];
	    switch(pset["b4w_billboard_align"]) {
	    case "VIEW":
	        set_batch_directive(batch, "BILLBOARD_ALIGN", "BILLBOARD_ALIGN_VIEW");
	        break;
	    case "XY":
	        set_batch_directive(batch, "BILLBOARD_ALIGN", "BILLBOARD_ALIGN_XY");
	        break;
	    case "YZ":
	        set_batch_directive(batch, "BILLBOARD_ALIGN", "BILLBOARD_ALIGN_YZ");
	        break;
	    case "ZX":
	        set_batch_directive(batch, "BILLBOARD_ALIGN", "BILLBOARD_ALIGN_ZX");
	        break;
	    default:
	        m_util.panic("Wrong billboard align value");
	        break;
	    }
	    // NOTE: disable standard billboarding
	    set_batch_directive(batch, "BILLBOARD", 0);

	    var obj_soft_particles = pset["b4w_enable_soft_particles"] &&
	            m_obj_util.check_obj_soft_particles_accessibility(obj, pset);

	    var enable_softness = pset["b4w_particles_softness"] > 0 &&
	                          obj_soft_particles &&
	                          cfg_def.depth_tex_available;
	    set_batch_directive(batch, "SOFT_PARTICLES", enable_softness? 1: 0);
	    set_batch_directive(batch, "SOFT_STRENGTH",
	                        m_shaders.glsl_value(pset["b4w_particles_softness"]));

	    var world_space = pset["b4w_coordinate_system"] == "WORLD"? 1: 0;
	    m_shaders.set_directive(batch.shaders_info, "WORLD_SPACE", world_space);
	}

	/**
	 * Create all possible batch slots for object and clone it by ptrans array
	 */
	function make_hair_particles_metabatches(bpy_em_obj, render, emitter_vc, 
	        em_submesh, bpy_part_objs, batch_types_arr, objs_ptrans, pset, psys, 
	        use_grass_map, seed, reset_seed) {

	    var em_obj = bpy_em_obj._object;
	    var metabatches = [];

	    // do not render dynamic grass if grass map was not requested
	    var dyn_grass = pset["b4w_dynamic_grass"];
	    if (!use_grass_map && dyn_grass)
	        return metabatches;

	    var inst_inherit_bend = pset["b4w_wind_bend_inheritance"] == "INSTANCE";
	    var inst_inherit_shadow = pset["b4w_shadow_inheritance"] == "INSTANCE";
	    var inst_inherit_reflection = pset["b4w_reflection_inheritance"]
	            == "INSTANCE";

	    // prepare hair_render arrays and tsr_arrays
	    // for objects which particle system composed from
	    var objs_hair_render = [];
	    var objs_tsr_array = [];

	    for (var i = 0; i < bpy_part_objs.length; i++) {
	        var part_render = bpy_part_objs[i]._object.render;

	        // NOTE: partially override emitter's render
	        var hair_render = m_obj_util.clone_render(render);

	        // NOTE: override object billboard properties, use properties from
	        // particle system
	        hair_render.billboard = pset["b4w_hair_billboard"];
	        hair_render.billboard_type = pset["b4w_hair_billboard_type"];
	        hair_render.billboard_spherical =
	                pset["b4w_hair_billboard_geometry"] == "SPHERICAL";

	        hair_render.dynamic_grass = dyn_grass;
	        hair_render.is_hair_particles = true;

	        if (inst_inherit_bend) {
	            hair_render.wind_bending = part_render.wind_bending;
	            hair_render.wind_bending_angle = part_render.wind_bending_angle;
	            hair_render.wind_bending_freq = part_render.wind_bending_freq;
	            hair_render.detail_bending_freq = part_render.detail_bending_freq;
	            hair_render.main_bend_col = part_render.main_bend_col;
	            hair_render.detail_bending_amp = part_render.detail_bending_amp;
	            hair_render.branch_bending_amp = part_render.branch_bending_amp;
	            hair_render.wind_bending_amp = part_render.wind_bending_amp;
	            // by link, doesn't matter
	            hair_render.detail_bend_col = part_render.detail_bend_col;
	            hair_render.bend_center_only = false;
	        } else {
	            hair_render.wind_bending = em_obj.render.wind_bending;
	            hair_render.wind_bending_angle = em_obj.render.wind_bending_angle;
	            hair_render.wind_bending_freq = em_obj.render.wind_bending_freq;
	            hair_render.detail_bending_freq = em_obj.render.detail_bending_freq;
	            hair_render.main_bend_col = em_obj.render.main_bend_col;
	            hair_render.detail_bending_amp = em_obj.render.detail_bending_amp;
	            hair_render.branch_bending_amp = em_obj.render.branch_bending_amp;
	            hair_render.wind_bending_amp = em_obj.render.wind_bending_amp;
	            // by link, doesn't matter
	            hair_render.detail_bend_col = em_obj.render.detail_bend_col;
	            hair_render.bend_center_only = true;
	        }

	        if (inst_inherit_shadow) {
	            hair_render.shadow_cast = part_render.shadow_cast;
	            hair_render.shadow_cast_only = part_render.shadow_cast_only;
	            hair_render.shadow_receive = part_render.shadow_receive;
	        } else {
	            hair_render.shadow_cast = em_obj.render.shadow_cast;
	            hair_render.shadow_cast_only = em_obj.render.shadow_cast_only;
	            hair_render.shadow_receive = em_obj.render.shadow_receive;
	        }

	        if (inst_inherit_reflection) {
	            hair_render.reflexible = part_render.reflexible;
	            hair_render.reflexible_only = part_render.reflexible_only;
	            hair_render.reflective = part_render.reflective;
	            hair_render.cube_reflection_id = part_render.cube_reflection_id;
	            hair_render.plane_reflection_id = part_render.plane_reflection_id;
	            hair_render.reflection_type = part_render.reflection_type;
	        } else {
	            hair_render.reflexible = em_obj.render.reflexible;
	            hair_render.reflexible_only = em_obj.render.reflexible_only;
	            hair_render.reflective = em_obj.render.reflective;
	            hair_render.cube_reflection_id = em_obj.render.cube_reflection_id;
	            hair_render.plane_reflection_id = em_obj.render.plane_reflection_id;
	            hair_render.reflection_type = em_obj.render.reflection_type;
	        }
	        objs_hair_render.push(hair_render);

	        var ptrans = objs_ptrans[i];
	        if (!ptrans)
	            ptrans = new Float32Array();

	        if (reset_seed)
	            m_util.init_rand_r_seed(psys["seed"], seed);

	        var trans = new Float32Array(3);
	        var quat = new Float32Array([0, 0, 0, 1]);
	        var tsr_array = [];

	        var use_particles_rotation = m_reformer.check_particles_bin_format(cfg_def.loaded_data_version)
	                && !pset["b4w_initial_rand_rotation"] && !pset["b4w_hair_billboard"];
	        var data_len = 4;
	        if (use_particles_rotation)
	            data_len = 8;

	        for (var j = 0; j < ptrans.length; j+=data_len) {
	            trans[0] = ptrans[j];
	            trans[1] = ptrans[j+1];
	            trans[2] = ptrans[j+2];

	            // NOTE: apply particle scale
	            var scale = ptrans[j+3] * m_tsr.get_scale(part_render.world_tsr);

	            if (pset["b4w_initial_rand_rotation"]) {
	                switch (pset["b4w_rotation_type"]) {
	                case "XYZ":
	                    var axis = new Float32Array([m_util.rand_r(seed),
	                            m_util.rand_r(seed), m_util.rand_r(seed)]);
	                    m_vec3.normalize(axis, axis);
	                    break;
	                case "Z":
	                    var axis = new Float32Array([0, 0, 1]);
	                    break;
	                default:
	                    m_util.panic("Unsupported random rotation type: "
	                             + pset["b4w_rotation_type"]);
	                    break;
	                }
	                var strength = pset["b4w_rand_rotation_strength"];
	                m_quat.setAxisAngle(axis, strength * (2 * Math.PI
	                        * m_util.rand_r(seed) - Math.PI), quat);
	            } else if (use_particles_rotation) {
	                quat.set(ptrans.subarray(j+4, j+8));
	                m_util.quat_bpy_b4w(quat, quat);

	                if (!pset["use_whole_group"])
	                    if (pset["use_rotation_dupli"]) {
	                        var part_quat = m_tsr.get_quat_view(part_render.world_tsr);
	                        m_quat.multiply(quat, part_quat, quat);
	                    } else
	                        m_quat.multiply(quat, DEFAULT_PART_SYS_QUAT, quat);
	            }
	            var tsr = m_tsr.set_sep(trans, scale, quat, m_tsr.create());

	            // in object space
	            tsr_array.push(tsr);
	        }
	        objs_tsr_array.push(tsr_array);
	    }
	    // get info for instancing
	    var part_mat_data = {};
	    var mat_number = 0;
	    for (var i = 0; i < bpy_part_objs.length; i++) {
	        var materials = bpy_part_objs[i]._object.materials;
	        for (var j = 0; j < materials.length; j++)
	            if (materials[j].name in part_mat_data)
	                part_mat_data[materials[j].name]++;
	            else {
	                part_mat_data[materials[j].name] = 1;
	                mat_number++;
	            }
	    }
	    mat_number = mat_number ? mat_number : 1;

	    // spatial tree object for searching nearest emitter vertices
	    // will be calculated only once
	    var spatial_tree = {};
	    for (var i = 0; i < bpy_part_objs.length; i++) {
	        var bpy_obj = bpy_part_objs[i];

	        var btypes = batch_types_arr[i];
	        var hair_render = objs_hair_render[i];

	        var submesh_params = {};
	        if (hair_render.wind_bending) {
	            submesh_params["au_wind_bending_amp"] = [hair_render.wind_bending_amp];
	            submesh_params["au_wind_bending_freq"] = [hair_render.wind_bending_freq];
	            submesh_params["au_detail_bending_freq"] = [hair_render.detail_bending_freq];
	            submesh_params["au_detail_bending_amp"] = [hair_render.detail_bending_amp];
	            submesh_params["au_branch_bending_amp"] = [hair_render.branch_bending_amp];

	            // clear render properties to improve batching
	            // (they would be converted to attributes later)
	            hair_render.wind_bending_amp = 0;
	            hair_render.wind_bending_freq = 0;
	            hair_render.detail_bending_freq = 0;
	            hair_render.detail_bending_amp = 0;
	            hair_render.branch_bending_amp = 0;
	        }

	        var tsr_array = objs_tsr_array[i];

	        if (!tsr_array.length)
	            continue

	        var mesh = bpy_obj["data"];
	        var materials = bpy_obj._object.materials;

	        var batches_main = new Array(materials.length);
	        var batches_debug_view = new Array(materials.length);

	        for (var j = 0; j < materials.length; j++) {

	            if (bpy_mat_is_disabled_for_obj(em_obj, j))
	                continue;

	            if (m_geom.has_empty_submesh(mesh, j))
	                continue;

	            for (var k = 0; k < btypes.length; k++) {

	                var type = btypes[k];
	                var batch = init_batch(type);
	                var material = materials[j];

	                if (type == "MAIN")
	                    batches_main[j] = batch;
	                else if (type == "DEBUG_VIEW")
	                    batches_debug_view[j] = batch;

	                batch.cluster_id = bpy_em_obj["b4w_cluster_data"]["cluster_id"];

	                var is_valid_output = batch_material_output_is_valid(batch, material);
	                if (!is_valid_output)
	                    continue;

	                var is_valid_mat = update_batch_material(batch, material, mesh);
	                if (!is_valid_mat)
	                    continue;

	                if (type == "SHADOW" && batches_main[j])
	                    // Override
	                    batch.use_shadeless = batches_main[j].use_shadeless;

	                batch.draw_mode = m_geom.DM_DEFAULT;
	                update_batch_render(batch, hair_render);

	                batch.odd_id_prop = generate_odd_id(batch, hair_render, pset["uuid"]);
	                batch.do_not_cull = bpy_em_obj["b4w_do_not_cull"] || pset["b4w_dynamic_grass"];
	                if (batch.type == "MAIN")
	                    batch.caustics = bpy_em_obj["b4w_caustics"];

	                var disable_fogging = (type != "COLOR_ID" && type != "SHADOW" 
	                    && bpy_em_obj["b4w_disable_fogging"]);
	                set_batch_directive(batch, "DISABLE_FOG", disable_fogging | 0);

	                // write batch jitter parameters
	                if (pset["b4w_hair_billboard_type"] == "JITTERED") {
	                    batch.jitter_amp = pset["b4w_hair_billboard_jitter_amp"];
	                    batch.jitter_freq = pset["b4w_hair_billboard_jitter_freq"];
	                }
	                if (dyn_grass)
	                    batch.grass_scale_threshold
	                            = pset["b4w_dynamic_grass_scale_threshold"];

	                if (!inst_inherit_bend) {
	                    delete batch.vertex_colors_usage["a_bending_col_main"];
	                    delete batch.vertex_colors_usage["a_bending_col_detail"];
	                }

	                var src_submesh = m_geom.extract_submesh(mesh, j,
	                        batch.common_attributes, render.bone_skinning_info,
	                        batch.vertex_colors_usage, batch.uv_maps_usage);

	                var stat_part_em_tsr = em_obj.render.world_tsr;

	                var realy_need_use_inst = true;
	                if (part_mat_data[material.name] > 1) {
	                    var atr_num = 0;
	                    for (var name in src_submesh.va_frames)
	                        atr_num++;
	                    realy_need_use_inst = src_submesh.indices.length
	                            * tsr_array.length * atr_num
	                            * part_mat_data[material.name] > MAX_PARTICLES_COEF * mat_number;
	                }
	                var can_use_inst = cfg_def.allow_instanced_arrays_ext &&
	                                realy_need_use_inst && batch.type != "PHYSICS";
	                if (can_use_inst) {
	                    batch.inst_array_state = pset["use_whole_group"] ?
	                        WH_GR_INST_ARR : SINGLE_INST_ARR;

	                    var submesh = m_geom.clone_submesh(src_submesh);
	                    m_geom.calc_unit_boundings(src_submesh, submesh,
	                                                   tsr_array);
	                    submesh.instanced_array_data = {
	                        tsr_array : tsr_array,
	                        stat_part_em_tsr : stat_part_em_tsr,
	                        static_hair : render.type == "STATIC",
	                        submesh_params : submesh_params,
	                        part_inh_attrs : {},
	                        dyn_grass : dyn_grass
	                    };
	                    if (hair_render.wind_bending && hair_render.bend_center_only) {
	                        var origin = m_vec3.fromValues(0, 0, 0);
	                        m_tsr.transform_vec3(origin, em_obj.render.world_tsr, origin);
	                        var center_data = [];
	                        for (var l = 0; l < tsr_array.length; l++)
	                            center_data.push(origin[0], origin[1], origin[2]);
	                        submesh.instanced_array_data.part_inh_attrs["a_emitter_center"] = {
	                            num_comp: 3,
	                            data: center_data
	                        };
	                    }
	                    m_geom.calc_unit_boundings(src_submesh, src_submesh,
	                                                   tsr_array);

	                    if (render.type == "STATIC")
	                        m_geom.bounding_data_apply_transform(submesh.submesh_bd,
	                                                               stat_part_em_tsr);
	                } else {
	                    var submesh = m_geom.make_propagated_submesh(src_submesh,
	                        submesh_params, tsr_array);
	                    submesh = fill_submesh_center_pos(submesh, tsr_array);
	                    if (hair_render.wind_bending && hair_render.bend_center_only)
	                        submesh = fill_submesh_emitter_center(submesh,
	                                em_obj.render.world_tsr);
	                }

	                var particle_inherited_attrs = get_particle_inherited_attrs(
	                            pset["b4w_vcol_from_name"], pset["b4w_vcol_to_name"],
	                            batch, emitter_vc, !inst_inherit_bend, mesh);
	                submesh = make_particle_inherited_vcols(submesh, tsr_array,
	                        em_obj.render.bb_local, em_submesh, particle_inherited_attrs,
	                        batch.vertex_colors_usage, spatial_tree, can_use_inst);

	                set_batch_directive(batch, "USE_INSTANCED_PARTCLS",
	                        submesh.instanced_array_data ? 1 : 0);

	                update_batch_id(batch);

	                metabatches.push({
	                    batch: batch,
	                    obj_render: render,
	                    batch_render: hair_render,
	                    submesh: submesh,
	                    mat_names: [material.name],
	                    rel_bpy_objects: [bpy_em_obj]
	                });
	            }
	        }

	        // NOTE: using a special property to make batching for DEBUG_VIEW batches 
	        // the same as for MAIN batches
	        for (var j = 0; j < batches_debug_view.length; j++)
	            if (batches_debug_view[j]) {
	                batches_debug_view[j].debug_main_batch_id = batches_main[j].id;
	                update_batch_id(batches_debug_view[j]);
	            }
	    }

	    return metabatches;
	}

	function batch_material_output_is_valid(batch, material) {
	    var is_valid_output = true;

	    if (batch.type == "NODES_GLOW")
	        is_valid_output = m_nodemat.check_material_glow_output(material);

	    return is_valid_output;
	}

	function make_spatial_tree(spatial_tree, obj_bb_local, positions) {
	    spatial_tree.cell_size = new Float32Array(3);
	    spatial_tree.base_point = new Float32Array(3);
	    spatial_tree.verts_indices = new Uint32Array(positions.length / 3);
	    spatial_tree.octs_indices = new Uint32Array(positions.length / 3);

	    spatial_tree.cell_size[0] = (obj_bb_local.max_x - obj_bb_local.min_x) / STREE_CELL_COUNT;
	    spatial_tree.cell_size[1] = (obj_bb_local.max_y - obj_bb_local.min_y) / STREE_CELL_COUNT;
	    spatial_tree.cell_size[2] = (obj_bb_local.max_z - obj_bb_local.min_z) / STREE_CELL_COUNT;

	    spatial_tree.base_point[0] = obj_bb_local.min_x;
	    spatial_tree.base_point[1] = obj_bb_local.min_y;
	    spatial_tree.base_point[2] = obj_bb_local.min_z;

	    for (var i = 0; i < positions.length / 3; i++) {
	        var x = positions[i * 3];
	        var y = positions[i * 3 + 1];
	        var z = positions[i * 3 + 2];

	        var num_x = m_util.trunc((x - spatial_tree.base_point[0]) / spatial_tree.cell_size[0]);
	        var num_y = m_util.trunc((y - spatial_tree.base_point[1]) / spatial_tree.cell_size[1]);
	        var num_z = m_util.trunc((z - spatial_tree.base_point[2]) / spatial_tree.cell_size[2]);

	        num_x = m_util.clamp(num_x, 0, STREE_CELL_COUNT - 1);
	        num_y = m_util.clamp(num_y, 0, STREE_CELL_COUNT - 1);
	        num_z = m_util.clamp(num_z, 0, STREE_CELL_COUNT - 1);

	        spatial_tree.verts_indices[i] = i;
	        spatial_tree.octs_indices[i] = num_z * Math.pow(STREE_CELL_COUNT, 2)
	                + num_y * STREE_CELL_COUNT + num_x;
	    }

	    m_geom.sort_two_arrays(spatial_tree.octs_indices,
	            spatial_tree.verts_indices, m_geom.SORT_NUMERIC, true);

	    spatial_tree.verts_offsets = new Uint32Array(Math.pow(STREE_CELL_COUNT, 3));
	    for (var i = 0; i < spatial_tree.octs_indices.length; i++) {
	        var index = spatial_tree.octs_indices[i];
	        spatial_tree.verts_offsets[index]++;
	    }
	    delete spatial_tree.octs_indices;

	    for (var i = 1; i < spatial_tree.verts_offsets.length; i++)
	        spatial_tree.verts_offsets[i] += spatial_tree.verts_offsets[i - 1];

	    return spatial_tree;
	}


	function get_particle_inherited_attrs(vc_name_from, vc_name_to, batch, emitter_vc,
	        bend_inheritance, particle_mesh) {
	    var inherited_attrs = [];

	    // vertex color inheritance
	    if (vc_name_from !== "" && vc_name_to !== "") {

	        var col_usage_data = get_vcol_usage_data_by_name(vc_name_to,
	                batch.vertex_colors_usage);

	        if (col_usage_data.length > 0)
	            for (var i = 0; i < col_usage_data.length; i += 3)
	                inherited_attrs.push({
	                    emitter_attr: vc_name_from,
	                    emitter_mask: 7,
	                    particle_attr: col_usage_data[i],
	                    particle_mask: col_usage_data[i + 1],
	                    dst_channel_offset: col_usage_data[i + 2]
	                });
	        else
	            if (m_geom.has_attr(batch.common_attributes, "a_color"))
	                if (vc_name_to == particle_mesh["active_vcol_name"])
	                    inherited_attrs.push({
	                        emitter_attr: vc_name_from,
	                        emitter_mask: 7,
	                        particle_attr: "a_color",
	                        particle_mask: 7,
	                        dst_channel_offset: 0
	                    });
	    }

	    // bending inheritance
	    if (bend_inheritance) {
	        if ("a_bending_col_main" in emitter_vc)
	            inherited_attrs.push({
	                emitter_attr: "a_bending_col_main",
	                emitter_mask: 4,
	                particle_attr: "a_bending_col_main",
	                particle_mask: 4,
	                dst_channel_offset: 0
	            });
	        if ("a_bending_col_detail" in emitter_vc)
	            inherited_attrs.push({
	                emitter_attr: "a_bending_col_detail",
	                emitter_mask: 7,
	                particle_attr: "a_bending_col_detail",
	                particle_mask: 7,
	                dst_channel_offset: 0
	            });
	    }

	    return inherited_attrs;
	}

	function get_vcol_usage_data_by_name(color_name, vc_usage) {
	    var data = [];

	    for (var attr_name in vc_usage) {
	        var src_colors = vc_usage[attr_name].src;
	        var dst_channel_offset = 0;
	        for (var i = 0; i < src_colors.length; i++) {
	            var mask = src_colors[i].mask;
	            if (color_name == src_colors[i].name)
	                data.push(attr_name, mask, dst_channel_offset);
	            dst_channel_offset += m_util.rgb_mask_get_channels_count(mask);
	        }
	    }

	    return data;
	}

	function fill_submesh_center_pos(submesh, transforms) {
	    submesh.va_common["au_center_pos"] = new Float32Array(submesh.base_length * 3);

	    var t_count = transforms.length;
	    var base_length = submesh.base_length / t_count;
	    for (var i = 0; i < t_count; i++) {
	        var transform = transforms[i];
	        var v_offset = base_length * 3 * i;

	        for (var j = 0; j < base_length; j++) {
	            submesh.va_common["au_center_pos"][v_offset + j*3] = transform[0];
	            submesh.va_common["au_center_pos"][v_offset + j*3 + 1] = transform[1];
	            submesh.va_common["au_center_pos"][v_offset + j*3 + 2] = transform[2];
	        }
	    }

	    return submesh;
	}

	function fill_submesh_emitter_center(submesh, em_world_tsr) {
	    submesh.va_common["a_emitter_center"] = new Float32Array(submesh.base_length * 3);
	    var origin = m_vec3.fromValues(0, 0, 0);
	    m_tsr.transform_vec3(origin, em_world_tsr, origin);

	    for (var i = 0; i < submesh.base_length; i++) {
	        submesh.va_common["a_emitter_center"][i * 3] = origin[0];
	        submesh.va_common["a_emitter_center"][i * 3 + 1] = origin[1];
	        submesh.va_common["a_emitter_center"][i * 3 + 2] = origin[2];
	    }

	    return submesh;
	}

	function make_particle_inherited_vcols(submesh, transforms, em_bb_local,
	        em_submesh, inherited_attrs, vc_usage, spatial_tree, inst_array) {

	    var calc_nearest = false;
	    for (var i = 0; i < inherited_attrs.length; i++) {
	        var em_attr = inherited_attrs[i].emitter_attr;
	        var cols = em_submesh.va_common[em_attr];
	        if (cols && cols.length > 0) {
	            calc_nearest = true;
	            break;
	        }
	    }
	    if (inst_array)
	        var part_inh_attrs = submesh.instanced_array_data.part_inh_attrs;
	    if (calc_nearest) {
	        var nearest_points = calc_emitter_nearest_points(em_bb_local,
	                em_submesh.va_frames[0]["a_position"], transforms, spatial_tree);
	        var particle_verts_count = submesh.base_length / transforms.length;

	        for (var i = 0; i < inherited_attrs.length; i++) {
	            var p_attr = inherited_attrs[i].particle_attr;
	            var p_mask = inherited_attrs[i].particle_mask;
	            var em_attr = inherited_attrs[i].emitter_attr;
	            var em_mask = inherited_attrs[i].emitter_mask;

	            var cols = em_submesh.va_common[em_attr];
	            switch (p_attr) {
	            // NOTE: bending colors may be missed on particles
	            case "a_bending_col_main":
	                var p_attr_channels_total = 1;
	                break;
	            case "a_bending_col_detail":
	                var p_attr_channels_total = 3;
	                break;
	            // a_color may be missed in vc_usage
	            case "a_color":
	                var p_attr_channels_total = 3;
	                break;
	            default:
	                var p_attr_channels_total = 0;
	                for (var j = 0; j < vc_usage[p_attr].src.length; j++)
	                    p_attr_channels_total += m_util.rgb_mask_get_channels_count(
	                            vc_usage[p_attr].src[j].mask);
	                break;
	            }

	            if (cols && cols.length > 0) {
	                var emitter_comp_count = m_util.rgb_mask_get_channels_count(em_mask);
	                var particle_comp_count = m_util.rgb_mask_get_channels_count(p_mask);

	                var mask_from = em_mask & p_mask;
	                var channel_presence_from = m_util.rgb_mask_get_channels_presence(mask_from);
	                if (mask_from != p_mask)
	                    m_print.error("Wrong color extraction from "
	                        + em_attr + " to " + p_attr + ".");

	                if (!inst_array) {
	                    // NOTE: bending buffers can be uninitialized, overwrite them anyway
	                    // if there is an inherited color, it's already have initialized buffer
	                    if (p_attr == "a_bending_col_main" || p_attr == "a_bending_col_detail")
	                        submesh.va_common[p_attr] = new Float32Array(
	                                submesh.base_length * particle_comp_count);

	                    for (var j = 0; j < transforms.length; j++) {
	                        var nearest_index = nearest_points[j];
	                        var em_vert_offset = nearest_index * emitter_comp_count;
	                        var p_offset = j * particle_verts_count * p_attr_channels_total;
	                        if (nearest_index != -1)
	                            for (var k = 0; k < particle_verts_count; k++) {
	                                var p_vert_offset = k * p_attr_channels_total;
	                                for (var l = 0; l < channel_presence_from.length; l++)
	                                    if (channel_presence_from[l]) {
	                                        var em_channel_offset = m_util.rgb_mask_get_channel_presence_index(em_mask, l);
	                                        var p_channel_offset = inherited_attrs[i].dst_channel_offset
	                                                + m_util.rgb_mask_get_channel_presence_index(p_mask, l);
	                                        submesh.va_common[p_attr][p_offset
	                                                + p_vert_offset + p_channel_offset]
	                                                = cols[em_vert_offset + em_channel_offset];
	                                    }
	                            }
	                    }
	                } else {
	                    part_inh_attrs[p_attr] = {
	                        num_comp: p_attr_channels_total,
	                        data: []
	                    };
	                    for (var j = 0; j < transforms.length; j++) {
	                        var nearest_index = nearest_points[j];
	                        var em_vert_offset = nearest_index * emitter_comp_count;
	                        for (var l = 0; l < channel_presence_from.length; l++)
	                            if (channel_presence_from[l]) {
	                                var em_channel_offset = 
	                                        m_util.rgb_mask_get_channel_presence_index(em_mask, l);
	                                part_inh_attrs[p_attr].data.push(cols[em_vert_offset
	                                        + em_channel_offset]);
	                            }
	                    }
	                }
	            } else
	                submesh.va_common[p_attr] = new Float32Array(0);
	        }

	    }

	    return submesh;
	}

	function calc_emitter_nearest_points(em_bb_local, em_positions, transforms,
	        spatial_tree) {

	    var particle_cen = new Float32Array(3);
	    var em_vert = new Float32Array(3);
	    var nearest_points = new Uint32Array(transforms.length);

	    if (!("verts_indices" in spatial_tree))
	        make_spatial_tree(spatial_tree, em_bb_local, em_positions);

	    for (var i = 0; i < transforms.length; i++) {
	        particle_cen[0] = transforms[i][0];
	        particle_cen[1] = transforms[i][1];
	        particle_cen[2] = transforms[i][2];

	        var min_dist = 1e+10;
	        var min_index = -1;

	        // use spatial tree for faster search nearest vertex
	        var num_x = m_util.trunc((particle_cen[0]
	                - spatial_tree.base_point[0]) / spatial_tree.cell_size[0]);
	        var num_y = m_util.trunc((particle_cen[1]
	                - spatial_tree.base_point[1]) / spatial_tree.cell_size[1]);
	        var num_z = m_util.trunc((particle_cen[2]
	                - spatial_tree.base_point[2]) / spatial_tree.cell_size[2]);

	        num_x = m_util.clamp(num_x, 0, STREE_CELL_COUNT - 1);
	        num_y = m_util.clamp(num_y, 0, STREE_CELL_COUNT - 1);
	        num_z = m_util.clamp(num_z, 0, STREE_CELL_COUNT - 1);

	        var oct_index = num_z * Math.pow(STREE_CELL_COUNT, 2)
	                + num_y * STREE_CELL_COUNT + num_x;

	        var from_index = (oct_index == 0) ? 0 : spatial_tree.verts_offsets[oct_index - 1];
	        var to_index = spatial_tree.verts_offsets[oct_index];

	        for (var j = from_index; j < to_index; j++) {
	            var index = spatial_tree.verts_indices[j];

	            em_vert[0] = em_positions[index * 3];
	            em_vert[1] = em_positions[index * 3 + 1];
	            em_vert[2] = em_positions[index * 3 + 2];

	            m_vec3.sub(em_vert, particle_cen, em_vert);
	            var sq_len = m_vec3.sqrLen(em_vert);
	            if (sq_len <= min_dist) {
	                min_dist = sq_len;
	                min_index = index;
	            }
	        }

	        // standard search for nearest vertex
	        if (min_index == -1) {
	            for (var j = 0; j < em_positions.length / 3; j++) {
	                em_vert[0] = em_positions[j * 3];
	                em_vert[1] = em_positions[j * 3 + 1];
	                em_vert[2] = em_positions[j * 3 + 2];

	                m_vec3.sub(em_vert, particle_cen, em_vert);
	                var sq_len = m_vec3.sqrLen(em_vert);
	                if (sq_len <= min_dist) {
	                    min_dist = sq_len;
	                    min_index = j;
	                }
	            }
	        }

	        nearest_points[i] = min_index;
	    }

	    return nearest_points;
	}

	/**
	 * Fair distribution among dupli_objects
	 */
	function distribute_ptrans_equally(ptrans, dupli_objects, seed, use_particles_rotation, data_len) {

	    var objs_count = dupli_objects.length;
	    var ptrans_dist = {};

	    for (var i = 0; i < ptrans.length; i+=data_len) {
	        var index = Math.floor(objs_count * m_util.rand_r(seed));

	        ptrans_dist[index] = ptrans_dist[index] || [];
	        ptrans_dist[index].push(ptrans[i], ptrans[i+1], ptrans[i+2], ptrans[i+3]);
	        if (use_particles_rotation)
	            ptrans_dist[index].push(ptrans[i+4], ptrans[i+5], ptrans[i+6], ptrans[i+7]);
	    }

	    for (var index in ptrans_dist)
	        ptrans_dist[index] = new Float32Array(ptrans_dist[index]);
	    return ptrans_dist;
	}

	function distribute_ptrans_group(ptrans, dupli_objects, use_particles_rotation, data_len) {
	    var ptrans_dist = {};
	    var quat = new Float32Array([0, 0, 0, 1]);

	    for (var i = 0; i < ptrans.length; i+=data_len) {
	        for (var j = 0; j < dupli_objects.length; j++) {

	            var obj_trans = m_vec3.create();
	            var dupli_scale = m_tsr.get_scale(dupli_objects[j].render.world_tsr);
	            var dupli_trans = m_tsr.get_trans_view(dupli_objects[j].render.world_tsr);
	            m_vec3.scale(dupli_trans, dupli_scale, obj_trans);
	            var res_trans = m_vec3.clone([ptrans[i], ptrans[i+1], ptrans[i+2]]);

	            if (!ptrans_dist[j])
	                ptrans_dist[j] = new Float32Array(ptrans.length);

	            if (use_particles_rotation) {
	                ptrans_dist[j][i + 4] = quat[0] = ptrans[i + 4];
	                ptrans_dist[j][i + 5] = quat[1] = ptrans[i + 5];
	                ptrans_dist[j][i + 6] = quat[2] = ptrans[i + 6];
	                ptrans_dist[j][i + 7] = quat[3] = ptrans[i + 7];
	                m_util.quat_bpy_b4w(quat, quat);
	                m_util.transformQuatFast(obj_trans, quat, obj_trans);
	            }

	            m_vec3.add(res_trans, obj_trans, res_trans);

	            ptrans_dist[j][i] = res_trans[0];
	            ptrans_dist[j][i + 1] = res_trans[1];
	            ptrans_dist[j][i + 2] = res_trans[2];
	            ptrans_dist[j][i + 3] = ptrans[i + 3];

	        }
	    }
	    return ptrans_dist;
	}

	function distribute_ptrans_by_dupli_weights(ptrans, dupli_objects,
	        dupli_weights, seed, use_particles_rotation, data_len) {

	    var ptrans_dist = {};

	    function rand_obj_index_by_weights(dupli_weights) {

	        var weight_sum_array = [0];
	        for (var i = 0; i < dupli_weights.length; i++) {
	            var weight = dupli_weights[i];
	            weight_sum_array[i+1] = weight_sum_array[i] + weight["count"];
	        }

	        var last = weight_sum_array[weight_sum_array.length-1];
	        var weight_sum_rand = last * m_util.rand_r(seed);
	        var weight_index = 0;

	        for (var i = 0; i < weight_sum_array.length; i++) {
	            if (weight_sum_rand >= weight_sum_array[i] &&
	                    weight_sum_rand < weight_sum_array[i+1]) {
	                weight_index = i;
	                break;
	            }
	        }

	        //var weight_name = dupli_weights[weight_index]["name"];
	        return weight_index;
	        //return weight_name;
	    }

	    var dupli_weights_sorted = [];

	    for (var i = 0; i < dupli_objects.length; i++) {
	        var dg_obj = dupli_objects[i];
	        var name = dg_obj.origin_name || dg_obj.name;

	        for (var j = 0; j < dupli_weights.length; j++) {
	            var weight = dupli_weights[j];
	            if (name == weight["name"])
	                dupli_weights_sorted.push(weight);
	        }
	    }

	    if (dupli_weights.length != dupli_weights_sorted.length)
	        m_print.error("dupli weights match failed");

	    for (var i = 0; i < ptrans.length; i+=data_len) {
	        var index = rand_obj_index_by_weights(dupli_weights_sorted);
	        ptrans_dist[index] = ptrans_dist[index] || [];
	        ptrans_dist[index].push(ptrans[i], ptrans[i+1], ptrans[i+2], ptrans[i+3]);
	        if (use_particles_rotation)
	            ptrans_dist[index].push(ptrans[i+4], ptrans[i+5], ptrans[i+6], ptrans[i+7]);

	    }

	    for (var index in ptrans_dist)
	        ptrans_dist[index] = new Float32Array(ptrans_dist[index]);

	    return ptrans_dist;
	}

	exports.update_batch_id = update_batch_id;
	function update_batch_id(batch) {

	    var update_cb = function(batch) {
	        // reset batch.id for proper id calculation
	        batch.id = 0;
	        batch.id = m_util.calc_variable_id(batch, 0);
	    };

	    batch_strip_bad_props_cb(batch, update_cb);
	}

	function batch_strip_bad_props_cb(batch, cb) {
	    // NOTE: remove specific properties (complex circular structure)
	    var ctx_storage = null;
	    var velem_storage = null;
	    var tex_num_users = [];

	    for (var i = 0; i < batch.textures.length; i++) {
	        var tex = batch.textures[i];
	        var ctx = tex.canvas_context;
	        if (ctx) {
	            if (!ctx_storage)
	                ctx_storage = {};
	            ctx_storage[i] = ctx;
	            tex.canvas_context = null;
	        }
	        var video = tex.video_file;
	        if (video) {
	            if(!velem_storage)
	                velem_storage = {};
	            velem_storage[i] = video;
	            tex.video_file = null;
	        }
	        tex_num_users.push(tex.num_users);
	        tex.num_users = 0;
	    }

	    // NOTE: remove mandatory unique batch properties
	    var bounds_local = batch.bounds_local;
	    batch.bounds_local = null;

	    var vaos = batch.vaos;
	    batch.vaos = null;

	    // NOTE: optimization: remove properties that can make calculation slower 
	    // (not needed in calculation anyway)
	    var bufs_data = batch.bufs_data;
	    batch.bufs_data = null;
	    var submesh = batch.submesh;
	    batch.submesh = null;
	    
	    cb(batch);

	    batch.bufs_data = bufs_data;
	    batch.submesh = submesh;

	    batch.vaos = vaos;

	    // return removed properties
	    batch.bounds_local = bounds_local;

	    if (ctx_storage)
	        for (var i in ctx_storage)
	            batch.textures[i].canvas_context = ctx_storage[i];
	    if (velem_storage)
	        for (var i in velem_storage)
	            batch.textures[i].video_file = velem_storage[i];

	    for (var i = 0; i < batch.textures.length; i++)
	        batch.textures[i].num_users = tex_num_users[i];
	}

	/**
	 * Create special batch for bounding ellipsoid/sphere debug rendering
	 */
	function create_bounding_ellipsoid_batch(render, obj_name, is_dynamic, src_batch) {

	    var batch = init_batch("DEBUG_VIEW");

	    apply_shader(batch, "debug_view.glslv", "debug_view.glslf");

	    batch.debug_sphere = true;

	    batch.depth_mask = true;
	    batch.odd_id_prop = generate_odd_id(batch, render, obj_name);

	    batch.debug_sphere_dynamic = is_dynamic;

	    update_batch_render(batch, render);
	    update_batch_id(batch);

	    if (src_batch.use_be) {
	        var be = src_batch.bounds_local.be;

	        var center = m_vec3.create();
	        var submesh = m_primitives.generate_uv_sphere(16, 8, 1, center,
	                                                    false, false);
	        var scale = m_vec3.fromValues(m_vec3.length(be.axis_x),
	                m_vec3.length(be.axis_y), m_vec3.length(be.axis_z));

	        m_geom.scale_submesh_xyz(submesh, scale, center);
	        
	        var axis_x = m_vec3.normalize(be.axis_x, _vec3_tmp);
	        var axis_y = m_vec3.normalize(be.axis_y, _vec3_tmp2);
	        var axis_z = m_vec3.normalize(be.axis_z, _vec3_tmp3);

	        // if an object has zero dimension on some axis - recalculate it
	        if (!scale[0] && scale[1] && scale[2])
	            m_vec3.cross(axis_y, axis_z, axis_x);
	        else if (!scale[1] && scale[0] && scale[2])
	            m_vec3.cross(axis_z, axis_x, axis_y);
	        else if (!scale[2] && scale[0] && scale[1])
	            m_vec3.cross(axis_x, axis_y, axis_z);

	        var ellipsoid_mat = m_util.ellipsoid_axes_to_mat3(axis_x, axis_y,
	                axis_z, _mat3_tmp);
	        m_mat3.invert(ellipsoid_mat, ellipsoid_mat);
	        var quat = m_quat.fromMat3(ellipsoid_mat, _vec4_tmp);
	        m_tsr.set_quat(quat, _tsr_tmp);
	        m_tsr.set_scale(1, _tsr_tmp);
	        m_tsr.set_trans(be.center, _tsr_tmp);
	        m_geom.submesh_apply_transform(submesh, _tsr_tmp);
	    } else {
	        var bs = src_batch.bounds_local.bs;
	        var submesh = m_primitives.generate_uv_sphere(16, 8, bs.radius,
	                bs.center, false, false);
	    }

	    m_bounds.copy_boundings(src_batch.bounds_local, batch.bounds_local);

	    m_geom.submesh_drop_indices(submesh, 1, true);
	    submesh.va_common["a_polyindex"] = m_geom.extract_polyindices(submesh);
	    update_batch_geometry(batch, submesh);

	    return batch;
	}

	exports.update_local_bounds_from_pos = function(batch, positions) {
	    batch.bounds_local.bb = m_bounds.bb_from_coords(positions, 0, 
	            positions.length, batch.bounds_local.bb);
	    var points = m_bounds.extract_bb_corners(batch.bounds_local.bb, _bb_corners_tmp);
	    batch.bounds_local.be = m_bounds.create_be_by_bb(points, true);
	    batch.bounds_local.bs = m_bounds.create_bs_by_be(batch.bounds_local.be);

	    batch.use_be = m_bounds.is_be_optimized(batch.bounds_local.be, 
	            batch.bounds_local.bs);
	};

	exports.apply_shader = apply_shader;
	function apply_shader(batch, vert, frag) {
	    batch.shaders_info.vert = vert;
	    batch.shaders_info.frag = frag;

	    m_shaders.set_default_directives(batch.shaders_info);
	}

	exports.append_texture = append_texture;
	/**
	 * Append texture to batch.
	 * @param texture Texture ID
	 * @param [name] Uniform name for appended texture
	 */
	function append_texture(batch, texture, name, bpy_name) {
	    bpy_name = bpy_name || "";
	    // unique only
	    if (batch.texture_names.indexOf(name) == -1) {
	        batch.textures.push(texture);
	        batch.texture_names.push(name);
	        batch.bpy_tex_names.push(bpy_name);
	    }

	    // if something is appended after shader compilation
	    if (batch.shader)
	        m_render.assign_texture_uniforms(batch);
	}

	exports.replace_texture = function(batch, texture, name) {
	    var index = batch.texture_names.indexOf(name);
	    if (index > -1)
	        batch.textures[index] = texture;
	};

	/**
	 * Create special shadeless batch for submesh debugging purposes
	 */
	exports.create_shadeless_batch = function(submesh, color, alpha) {

	    var batch = init_batch("MAIN");

	    if (alpha < 1)
	        batch.blend = true;
	    m_vec4.set(color[0], color[1], color[2], alpha, batch.diffuse_color);

	    batch.draw_mode = m_geom.DM_TRIANGLES;

	    update_batch_geometry(batch, submesh);

	    apply_shader(batch, "main.glslv", "main_stack.glslf");
	    set_batch_directive(batch, "SHADELESS", 1);
	    update_shader(batch);

	    return batch;
	};

	exports.update_shader = update_shader;
	/**
	 * Update shader id for batch
	 * @methodOf batch
	 */
	function update_shader(batch) {
	    if (!batch.shaders_info)
	        m_util.panic("No shaders info for batch " + batch.name);

	    batch.shader = m_shaders.get_compiled_shader(batch.shaders_info);

	    validate_batch(batch);

	    if (batch.shaders_info.status === m_shaders.VALID) {
	        m_render.assign_uniform_setters(batch.shader);

	        m_render.assign_attribute_setters(batch);

	        // also do that in append_texture()
	        m_render.assign_texture_uniforms(batch);

	        return true;
	    }

	    return false;
	}

	function validate_batch(batch) {
	    var shaders_info = batch.shaders_info;

	    if (shaders_info.status === m_shaders.VALID) {
	        var shader = batch.shader;
	        var attributes = shader.attributes;
	        var pointers = batch.bufs_data.pointers;

	        for (var attr in attributes) {
	            var p = pointers[attr];
	            if (!p)
	                m_util.panic("missing data for \"" + attr + "\" attribute");
	        }
	    }

	    if (shaders_info.status & m_shaders.INVALID_TEX_IMAGE_UNITS)
	        m_print.error("Texture limit exceeded for shader - "
	                + shaders_info.frag
	                + ", materials: \"" + batch.material_names.join(", ")
	                + "\". "
	                + "Maximum texture count: "
	                + cfg_lim.max_texture_image_units
	                + ", actual texture count: "
	                + shaders_info.texture_count);

	    if (shaders_info.status & m_shaders.INVALID_F_UNIFORM_VECTORS)
	        m_print.error("Fragment uniform limit exceeded for shader - "
	                + shaders_info.frag
	                + ", materials: \"" + batch.material_names.join(", ") + "\". ");

	    if (shaders_info.status & m_shaders.INVALID_V_UNIFORM_VECTORS)
	        m_print.error("Vertex uniform limit exceeded for shader - "
	                + shaders_info.vert
	                + ", materials: \"" + batch.material_names.join(", ") + "\". ");

	    if (shaders_info.status & m_shaders.INVALID_VERTEX_ATTRIBS)
	        m_print.error("Vertex attribute limit exceeded for shader - "
	                + shaders_info.vert
	                + ", materials: \"" + batch.material_names.join(", ")
	                + "\". "
	                + "Maximum attribute count: "
	                + cfg_lim.max_vertex_attribs
	                + ", actual attribute count: "
	                + shaders_info.attribute_count);

	    if (shaders_info.status & m_shaders.INVALID_VARYING_VECTORS)
	        warn_batch_varyings(batch);

	    if (shaders_info.status & m_shaders.COMPILATION_ERROR)
	        m_print.error("Shader compilation/linking error: "
	                + shaders_info.vert
	                + ", " + shaders_info.frag
	                + ", materials: \"" + batch.material_names.join(", ")
	                + "\"");
	}

	function warn_batch_varyings(batch) {
	    if (batch.type == "MAIN" && !batch.has_nodes)
	        m_print.error("Varying limit exceeded for shader - "
	                + batch.shaders_info.frag + ", materials: \"" + batch.material_names.join(", ")
	                + "\"");

	    if (batch.type == "MAIN" && batch.has_nodes
	            || batch.type == "NODES_GLOW") {
	        var used_uv = 0;
	        var used_vc = 0;
	        if (batch.uv_maps_usage)
	            used_uv = m_util.get_dict_length(batch.uv_maps_usage);
	        if (batch.vertex_colors_usage)
	            used_vc = m_util.get_dict_length(batch.vertex_colors_usage);

	        m_print.error("Varying limit exceeded for node shader - "
	                + batch.shaders_info.frag + ", uv: " + used_uv + ", vc: " + used_vc
	                + ", materials: \"" + batch.material_names.join(", ") + "\"");
	    }
	}

	exports.generate_line_batches = function(scene, line_objects) {
	    for (var i = 0; i < line_objects.length; i++) {
	        var line_obj = line_objects[i];

	        var batch = init_batch("LINE");
	        apply_shader(batch, "line.glslv", "line.glslf");
	        // slightly decreases performance but allows alpha diffuse component
	        batch.blend = true;
	        batch.do_not_cull = true;

	        var submesh = m_primitives.generate_line();
	        update_batch_geometry(batch, submesh);
	        update_batch_subtype(batch);

	        m_obj_util.append_scene_data(line_obj, scene);
	        m_obj_util.append_batch(line_obj, scene, batch);

	        update_shader(batch);
	    }
	};

	/**
	 * Check if batch's shader has permanent uniform setter with given name
	 */
	exports.check_batch_perm_uniform = function(batch, uniform_name) {

	    if (!batch.shader.permanent_uniform_setters.length)
	        return false;

	    if (batch.shader.permanent_uniform_setters_table[uniform_name])
	        return true;

	    return false;
	};

	exports.create_depth_pack_batch = function(tex) {

	    var batch = init_batch("DEPTH_PACK");

	    batch.use_backface_culling = true;
	    batch.depth_mask = false;

	    var submesh = m_primitives.generate_fullscreen_tri();
	    update_batch_geometry(batch, submesh);

	    apply_shader(batch, "postprocessing/postprocessing.glslv",
	            "postprocessing/depth_pack.glslf");
	    update_shader(batch);

	    return batch;
	};

	exports.create_postprocessing_batch = function(post_effect) {

	    var batch = init_batch("POSTPROCESSING");

	    apply_shader(batch, "postprocessing/postprocessing.glslv",
	            "postprocessing/postprocessing.glslf");

	    switch (post_effect) {
	    case "NONE":
	        set_batch_directive(batch, "POST_EFFECT", "POST_EFFECT_NONE");
	        break;
	    case "GRAYSCALE":
	        set_batch_directive(batch, "POST_EFFECT", "POST_EFFECT_GRAYSCALE");
	        break;
	    case "X_BLUR":
	    case "Y_BLUR":
	        set_batch_directive(batch, "POST_EFFECT", "POST_EFFECT_BLUR");
	        break;
	    case "X_GLOW_BLUR":
	    case "Y_GLOW_BLUR":
	    case "X_BLOOM_BLUR":
	    case "Y_BLOOM_BLUR":
	        set_batch_directive(batch, "POST_EFFECT", "POST_EFFECT_GLOW_BLUR");
	        break;
	    case "X_DOF_BLUR":
	    case "Y_DOF_BLUR":
	        set_batch_directive(batch, "POST_EFFECT", "POST_EFFECT_DOF_BLUR");
	        break;
	    case "X_ALPHA_BLUR":
	    case "Y_ALPHA_BLUR":
	        set_batch_directive(batch, "POST_EFFECT", "POST_EFFECT_ALPHA_BLUR");
	        break;
	    case "X_EXTEND":
	    case "Y_EXTEND":
	        set_batch_directive(batch, "POST_EFFECT", "POST_EFFECT_EXTEND");
	        break;
	    case "FLIP_CUBEMAP_COORDS":
	        set_batch_directive(batch, "POST_EFFECT", "FLIP_CUBEMAP_COORDS");
	        break;
	    default:
	        m_util.panic("Wrong postprocessing effect: " + post_effect);
	        break;
	    }
	    set_batch_directive(batch, "SHADOW_USAGE", "NO_SHADOWS");

	    batch.use_backface_culling = true;
	    batch.depth_mask = false;

	    var submesh = m_primitives.generate_fullscreen_tri();
	    update_batch_geometry(batch, submesh);

	    update_shader(batch);

	    return batch;
	};

	exports.create_ssao_batch = function(subs) {

	    var batch = init_batch("SSAO");

	    batch.depth_mask = false;
	    batch.use_backface_culling = true;

	    var submesh = m_primitives.generate_fullscreen_tri();
	    update_batch_geometry(batch, submesh);

	    apply_shader(batch, "postprocessing/postprocessing.glslv",
	            "postprocessing/ssao.glslf");

	    set_batch_directive(batch, "SSAO_QUALITY", "SSAO_QUALITY_" + subs.ssao_samples);
	    set_batch_directive(batch, "SSAO_HEMISPHERE", subs.ssao_hemisphere ? 1 : 0);
	    set_batch_directive(batch, "SHADOW_USAGE", "NO_SHADOWS");

	    var random_vector_table = {
	        width: 4,
	        height: 4,
	        data: new Uint8Array([ 150, 123, 254, 0,
	                               127,   3,  97, 0,
	                               164, 246,  99, 0,
	                               155, 177,  14, 0,

	                                54,  83, 221, 0,
	                                 2, 142, 143, 0,
	                                32,  57,  79, 0,
	                                49, 160,  32, 0,

	                                57, 232, 115, 0,
	                               178, 216, 203, 0,
	                                70, 196, 218, 0,
	                               241, 164,  82, 0,

	                               225,  58,  85, 0,
	                               233,  88, 189, 0,
	                               144,  25, 203, 0,
	                               117,  73,  12, 0 ]) };

	    var tex = m_textures.create_texture(m_textures.TT_RGBA_INT, false);
	    tex.source = "NODE_TEX";
	    m_textures.update_texture(tex, random_vector_table, 0);

	    append_texture(batch, tex, "u_ssao_special_tex");
	    update_shader(batch);

	    return batch;
	};

	exports.create_ssao_blur_batch = function(subs) {

	    var batch = init_batch("SSAO_BLUR");

	    batch.depth_mask = false;
	    batch.use_backface_culling = true;

	    var submesh = m_primitives.generate_fullscreen_tri();
	    update_batch_geometry(batch, submesh);

	    apply_shader(batch, "postprocessing/postprocessing.glslv",
	            "postprocessing/ssao_blur.glslf");

	    set_batch_directive(batch, "SSAO_BLUR_DEPTH", subs.ssao_blur_depth ? 1 : 0);
	    set_batch_directive(batch, "SHADOW_USAGE", "NO_SHADOWS");

	    update_shader(batch);

	    return batch;
	};

	exports.create_coc_batch = function(coc_type) {

	    var batch = init_batch("COC");

	    batch.depth_mask = false;
	    batch.use_backface_culling = true;

	    var submesh = m_primitives.generate_fullscreen_tri();
	    update_batch_geometry(batch, submesh);

	    apply_shader(batch, "postprocessing/postprocessing.glslv",
	            "postprocessing/coc.glslf");
	    set_batch_directive(batch, "DEPTH_RGBA", 1);

	    switch (coc_type) {
	    case "COC_ALL":
	        set_batch_directive(batch, "COC_TYPE", "COC_ALL");
	        break;
	    case "COC_FOREGROUND":
	        set_batch_directive(batch, "COC_TYPE", "COC_FOREGROUND");
	        break;
	    case "COC_COMBINE":
	        set_batch_directive(batch, "COC_TYPE", "COC_COMBINE");
	        break;
	    }
	    set_batch_directive(batch, "SHADOW_USAGE", "NO_SHADOWS");
	    update_shader(batch);

	    return batch;
	};


	exports.create_dof_batch = function(subs) {

	    var batch = init_batch("DOF");

	    batch.depth_mask = false;
	    batch.use_backface_culling = true;

	    var submesh = m_primitives.generate_fullscreen_tri();
	    update_batch_geometry(batch, submesh);

	    apply_shader(batch, "postprocessing/postprocessing.glslv",
	            "postprocessing/dof.glslf");
	    if (subs.camera.dof_bokeh)
	        set_batch_directive(batch, "DOF_TYPE", "DOF_BOKEH");
	    else {
	        set_batch_directive(batch, "DOF_TYPE", "DOF_SIMPLE");
	        set_batch_directive(batch, "DEPTH_RGBA", 1);
	    }
	    set_batch_directive(batch, "SHADOW_USAGE", "NO_SHADOWS");
	    update_shader(batch);

	    return batch;
	};

	exports.create_outline_batch = function() {

	    var batch = init_batch("OUTLINE");

	    batch.depth_mask = false;
	    batch.use_backface_culling = true;

	    var submesh = m_primitives.generate_fullscreen_tri();
	    update_batch_geometry(batch, submesh);

	    apply_shader(batch, "postprocessing/postprocessing.glslv",
	            "postprocessing/outline.glslf");

	    update_shader(batch);

	    return batch;
	};

	exports.create_glow_combine_batch = function() {

	    var batch = init_batch("GLOW_COMBINE");

	    batch.depth_mask = false;
	    batch.use_backface_culling = true;

	    var submesh = m_primitives.generate_fullscreen_tri();
	    update_batch_geometry(batch, submesh);

	    apply_shader(batch, "postprocessing/postprocessing.glslv",
	            "postprocessing/glow.glslf");
	    update_shader(batch);
	    return batch;
	};

	exports.create_god_rays_batch = function(pack, water, steps) {

	    var batch = init_batch("GOD_RAYS");

	    batch.depth_mask = false;
	    batch.use_backface_culling = true;

	    var submesh = m_primitives.generate_billboard();
	    update_batch_geometry(batch, submesh);

	    apply_shader(batch, "postprocessing/god_rays.glslv",
	            "postprocessing/god_rays.glslf");
	    set_batch_directive(batch, "DEPTH_RGBA", pack ? 1: 0);
	    set_batch_directive(batch, "WATER_EFFECTS", water ? 1: 0);
	    set_batch_directive(batch, "STEPS_PER_PASS", m_shaders.glsl_value(steps, 1));
	    set_batch_directive(batch, "SHADOW_USAGE", "NO_SHADOWS");
	    update_shader(batch);

	    return batch;
	};

	exports.create_god_rays_combine_batch = function() {

	    var batch = init_batch("GOD_RAYS_COM");

	    batch.depth_mask = false;
	    batch.use_backface_culling = true;

	    var submesh = m_primitives.generate_fullscreen_tri();
	    update_batch_geometry(batch, submesh);

	    apply_shader(batch, "postprocessing/postprocessing.glslv",
	            "postprocessing/god_rays_combine.glslf");
	    set_batch_directive(batch, "SAFARI_CANVAS_ALPHA_HACK", cfg_def.safari_canvas_alpha_hack ? 1: 0);
	    update_shader(batch);

	    return batch;
	};

	exports.create_cube_sky_batch = function(scene, subs) {

	    var batch = init_batch("SKY");

	    batch.depth_mask = false;
	    batch.use_backface_culling = false;

	    var submesh = m_primitives.generate_plane(1, 1);
	    update_batch_geometry(batch, submesh);
	    if (subs.sky_ngraph_proxy_id != "") {
	        apply_shader(batch, "skybox.glslv",
	                "node_skybox.glslf");

	        set_batch_directive(batch, "IS_WORLD", 1);
	        update_batch_world_nodes(batch, scene);
	    } else if (subs.procedural_skydome) {
	        apply_shader(batch, "skybox.glslv",
	                "proc_skybox.glslf");
	        set_batch_directive(batch, "WATER_EFFECTS", 1);
	    } else {
	        apply_shader(batch, "skybox.glslv",
	                "tex_skybox.glslf");
	        if (scene) {
	            var wls = scene._render.world_light_set;
	            if (wls.sky_texture_slot) {
	                var bpy_tex = wls.sky_texture_slot["texture"];
	                var tex = m_textures.get_batch_texture(wls.sky_texture_slot, null);
	                append_texture(batch, tex, "u_sky_texture", bpy_tex["name"]);
	            }
	            if (wls.sky_texture_param)
	                set_batch_directive(batch, "WO_SKYTEX", 1);
	        }

	        if (subs.sky_invert)
	            set_batch_directive(batch, "MTEX_NEGATIVE", 1);
	        if (subs.sky_use_rgb_to_intensity)
	            set_batch_directive(batch, "MTEX_RGBTOINT", 1);
	        set_batch_directive(batch, "BLENDTYPE", subs.sky_blend_type);
	        // if (subs.sky_stencil)
	        //     set_batch_directive(batch, "MTEX_STENCIL", 1);
	        if (subs.sky_use_map_blend)
	            set_batch_directive(batch, "WOMAP_BLEND", 1);
	        if (subs.sky_use_map_horizon)
	            set_batch_directive(batch, "WOMAP_HORIZ", 1);
	        if (subs.sky_use_map_zenith_up)
	            set_batch_directive(batch, "WOMAP_ZENUP", 1);
	        if (subs.sky_use_map_zenith_down)
	            set_batch_directive(batch, "WOMAP_ZENDOWN", 1);

	        if (subs.use_sky_blend)
	            set_batch_directive(batch, "WO_SKYBLEND", 1);
	        if (subs.use_sky_paper)
	            set_batch_directive(batch, "WO_SKYPAPER", 1);
	        if (subs.use_sky_real)
	            set_batch_directive(batch, "WO_SKYREAL", 1);
	    }
	    
	    update_shader(batch);

	    return batch;
	};

	exports.append_cube_sky_batch_to_world = function(scene, world) {
	    // we have to do this because we can change world textures via API
	    var subs_sky = m_scenegraph.find_subs(scene._render.graph, m_subs.SKY);
	    if (subs_sky) {
	        var batch = subs_sky.draw_data[0].bundles[0].batch;
	        m_obj_util.append_batch(world, scene, batch);
	    }
	};

	exports.create_cube_irradiance_batch = function(scene, subs) {

	    var batch = init_batch("IRRADIANCE");

	    batch.depth_mask = false;
	    batch.use_backface_culling = false;

	    var submesh = m_primitives.generate_plane(1, 1);
	    update_batch_geometry(batch, submesh);

	    apply_shader(batch, "skybox.glslv", "irradiance_skybox.glslf");
	    update_shader(batch);

	    return batch;
	};

	exports.create_cube_roughness_convolution_batch = function(scene, subs) {

	    var batch = init_batch("R_CONVOLUTION");

	    batch.depth_mask = false;
	    batch.use_backface_culling = false;

	    var submesh = m_primitives.generate_plane(1, 1);
	    update_batch_geometry(batch, submesh);

	    apply_shader(batch, "skybox.glslv", "r_convolution_skybox.glslf");
	    update_shader(batch);

	    return batch;
	};

	exports.create_brdf_batch = function(scene, subs) {

	    var batch = init_batch("BRDF");

	    batch.depth_mask = false;
	    batch.use_backface_culling = false;

	    var submesh = m_primitives.generate_plane(1, 1);
	    update_batch_geometry(batch, submesh);

	    apply_shader(batch, "postprocessing/postprocessing.glslv", "postprocessing/precompute_brdf.glslf");
	    update_shader(batch);

	    return batch;
	};

	exports.create_antialiasing_batch = function(subs) {
	    var batch = init_batch("ANTIALIASING");

	    batch.depth_mask = false;
	    batch.use_backface_culling = true;

	    var submesh = m_primitives.generate_fullscreen_tri();
	    update_batch_geometry(batch, submesh);

	    apply_shader(batch, "postprocessing/postprocessing.glslv",
	            "postprocessing/antialiasing.glslf");

	    if (cfg_def.quality_aa_method) {
	        set_batch_directive(batch, "AA_METHOD", "AA_METHOD_FXAA_QUALITY");
	        set_batch_directive(batch, "AA_QUALITY", subs.fxaa_quality);
	    } else
	        set_batch_directive(batch, "AA_METHOD", "AA_METHOD_FXAA_LIGHT");

	    update_shader(batch);

	    return batch;
	};

	exports.create_smaa_batch = function(type) {
	    var batch = init_batch("SMAA");

	    var submesh = m_primitives.generate_fullscreen_tri();
	    update_batch_geometry(batch, submesh);

	    apply_shader(batch, "postprocessing/smaa.glslv",
	            "postprocessing/smaa.glslf");

	    set_batch_directive(batch, "AA_METHOD", "AA_METHOD_SMAA_HIGH");
	    set_batch_directive(batch, "SMAA_PASS", type);
	    set_batch_directive(batch, "SMAA_PREDICATION", 0);

	    // NOTE: temporary disabled T2X mode due to artifacts with blend objects
	    set_batch_directive(batch, "SMAA_REPROJECTION", 0);
	    //if (m_cfg.context.alpha)
	    //    set_batch_directive(batch, "SMAA_REPROJECTION", 0);
	    //else
	    //    set_batch_directive(batch, "SMAA_REPROJECTION", 1);

	    update_shader(batch);

	    batch.depth_mask = false;
	    batch.use_backface_culling = true;

	    return batch;
	};

	exports.create_compositing_batch = function() {
	    var batch = init_batch("COMPOSITING");

	    batch.depth_mask = false;
	    batch.use_backface_culling = true;

	    var submesh = m_primitives.generate_fullscreen_tri();
	    update_batch_geometry(batch, submesh);

	    apply_shader(batch, "postprocessing/postprocessing.glslv",
	            "postprocessing/compositing.glslf");

	    update_shader(batch);

	    return batch;
	};

	exports.create_motion_blur_batch = function(decay_threshold) {

	    var batch = init_batch("MOTION_BLUR");

	    batch.use_backface_culling = true;
	    batch.depth_mask = false;

	    var submesh = m_primitives.generate_fullscreen_tri();
	    update_batch_geometry(batch, submesh);

	    apply_shader(batch, "postprocessing/postprocessing.glslv",
	            "postprocessing/motion_blur.glslf");
	    update_shader(batch);

	    return batch;
	};

	exports.create_stereo_batch = function(stereo_type) {

	    var batch = init_batch("STEREO");

	    batch.use_backface_culling = true;
	    batch.depth_mask = false;

	    var submesh = m_primitives.generate_fullscreen_tri();
	    update_batch_geometry(batch, submesh);

	    apply_shader(batch, "postprocessing/postprocessing.glslv",
	            "postprocessing/stereo.glslf");

	    set_batch_directive(batch, "ANAGLYPH", stereo_type === "ANAGLYPH" ? 1 : 0);
	    set_batch_directive(batch, "SIDEBYSIDE", stereo_type === "SIDEBYSIDE" ? 1 : 0);
	    set_batch_directive(batch, "DISTOR_SCALE", cfg_hmd["nonwebvr"].distor_scale);

	    update_shader(batch);

	    return batch;
	};

	exports.create_luminance_batch = function() {

	    var batch = init_batch("LUMINANCE");

	    batch.depth_mask = false;
	    batch.use_backface_culling = true;

	    var submesh = m_primitives.generate_fullscreen_tri();
	    update_batch_geometry(batch, submesh);

	    apply_shader(batch, "postprocessing/postprocessing.glslv",
	            "postprocessing/luminance.glslf");
	    update_shader(batch);

	    return batch;
	};

	exports.create_average_luminance_batch = function() {

	    var batch = init_batch("LUMINANCE");

	    batch.depth_mask = false;
	    batch.use_backface_culling = true;

	    var submesh = m_primitives.generate_fullscreen_tri();
	    update_batch_geometry(batch, submesh);

	    apply_shader(batch, "postprocessing/postprocessing.glslv",
	            "postprocessing/luminance_av.glslf");
	    update_shader(batch);

	    return batch;
	};

	exports.create_luminance_truncated_batch = function(adaptive_bloom) {

	    var batch = init_batch("LUMINANCE_X_BLUR");

	    batch.depth_mask = false;
	    batch.use_backface_culling = true;

	    var submesh = m_primitives.generate_fullscreen_tri();
	    update_batch_geometry(batch, submesh);

	    apply_shader(batch, "postprocessing/postprocessing.glslv",
	            "postprocessing/luminance_truncated.glslf");
	    if (adaptive_bloom)
	        m_shaders.set_directive(batch.shaders_info, "ADAPTIVE_BLOOM", 1);
	    update_shader(batch);

	    return batch;
	};

	exports.create_bloom_combine_batch = function(bloom_blur_num) {

	    var batch = init_batch("BLOOM");

	    batch.depth_mask = false;
	    batch.use_backface_culling = true;

	    var submesh = m_primitives.generate_fullscreen_tri();
	    update_batch_geometry(batch, submesh);

	    apply_shader(batch, "postprocessing/postprocessing.glslv",
	            "postprocessing/bloom_combine.glslf");

	    if (bloom_blur_num == 1)
	        var blur_pass = "BLUR_PASS_1";
	    else if (bloom_blur_num == 2)
	        var blur_pass = "BLUR_PASS_2";
	    else if (bloom_blur_num == 3)
	        var blur_pass = "BLUR_PASS_3";
	    else if (bloom_blur_num == 4)
	        var blur_pass = "BLUR_PASS_4";
	    else if (bloom_blur_num == 5)
	        var blur_pass = "BLUR_PASS_5";

	    m_shaders.set_directive(batch.shaders_info, "BLUR_PASS_NUM", blur_pass);

	    update_shader(batch);

	    return batch;
	};

	exports.create_velocity_batch = function() {
	    var batch = init_batch("VELOCITY");

	    batch.depth_mask = false;
	    batch.use_backface_culling = true;

	    var submesh = m_primitives.generate_fullscreen_tri();
	    update_batch_geometry(batch, submesh);

	    apply_shader(batch, "postprocessing/postprocessing.glslv",
	            "postprocessing/velocity.glslf");

	    update_shader(batch);

	    return batch;
	};

	exports.create_anchor_visibility_batch = function() {
	    var batch = init_batch("ANCHOR_VISIBILITY");

	    batch.depth_mask = true;
	    batch.use_backface_culling = true;

	    batch.draw_mode = m_geom.DM_TRIANGLES;

	    apply_shader(batch, "anchors.glslv", "anchors.glslf");

	    var submesh = m_primitives.generate_index(1);
	    update_batch_geometry(batch, submesh);

	    set_batch_directive(batch, "ANCHOR_NUM", 1);
	    update_shader(batch);

	    // NOTE: Prevent crash when there are no anchors but visibility is enabled
	    batch.anchor_positions = new Float32Array(3);

	    return batch;
	};

	exports.create_performance_batch = function() {
	    var batch = init_batch("PERFORMANCE");

	    batch.depth_mask = false;
	    batch.use_backface_culling = true;

	    var submesh = m_primitives.generate_fullscreen_tri();
	    update_batch_geometry(batch, submesh);

	    apply_shader(batch, "postprocessing/postprocessing.glslv",
	            "postprocessing/performance.glslf");

	    update_shader(batch);

	    return batch;
	};

	exports.update_anchor_visibility_batch = function(batch, positions) {
	    var num = positions.length / 3;

	    // optimization
	    if (num != batch.anchor_positions.length / 3) {
	        var submesh = m_primitives.generate_index(num);
	        update_batch_geometry(batch, submesh);
	        set_batch_directive(batch, "ANCHOR_NUM", num);
	        update_shader(batch);
	    }

	    batch.anchor_positions = positions;
	};

	exports.get_first_batch = function(obj) {
	    if (!obj.scenes_data.length)
	       return null; 
	    
	    var scene_data = obj.scenes_data[0];

	    if (scene_data.batches.length)
	        return scene_data.batches[0];
	    else
	        return null;

	};

	/**
	 * Find batch regardless if it is forked or not
	 */
	exports.find_batch_material_any = find_batch_material_any;
	function find_batch_material_any(obj, mat_name, type) {
	    var scene_data = obj.scenes_data[0];
	    var batches = scene_data.batches;
	    for (var i = 0; i < batches.length; i++)
	        if (batches[i].type == type &&
	                batches[i].material_names.indexOf(mat_name) != -1)
	            return batches[i];
	    return null;
	}

	/**
	 * Find batch by object ID, material name and
	 * batch type
	 */
	exports.find_batch_material = find_batch_material;
	function find_batch_material(obj, mat_name, type) {
	    //NOTE: Searches for batches only on the first scene
	    var scene_data = obj.scenes_data[0];
	    var batches = scene_data.batches;
	    for (var i = 0; i < batches.length; i++)
	        if (batches[i].type == type && !batches[i].forked_batch
	                && batches[i].material_names.indexOf(mat_name) != -1)
	            return batches[i];
	    return null;
	}

	exports.find_batch_material_forked = find_batch_material_forked;
	function find_batch_material_forked(obj, mat_name, type) {
	    //NOTE: Searches for batches only on the first scene
	    var scene_data = obj.scenes_data[0];
	    var batches = scene_data.batches;
	    for (var i = 0; i < batches.length; i++)
	        if (batches[i].type == type && batches[i].forked_batch
	                && batches[i].material_names.indexOf(mat_name) != -1)
	            return batches[i];
	    return null;
	}

	// return any positive value to finish the iteration
	exports.iterate_batches_by_mat = iterate_batches_by_mat;
	function iterate_batches_by_mat(obj, mat_name, batch_cb, type) {
	    //NOTE: iterate for batches only on the first scene
	    var scene_data = obj.scenes_data[0];
	    var batches = scene_data.batches;

	    for (var i = 0; i < batches.length; i++) {
	        var batch = batches[i];
	        if (batch.material_names.indexOf(mat_name) != -1)
	            if (!type || batch.type == type)
	                if (batch_cb(batch))
	                    return;
	    }
	}

	exports.check_batch_type = function(obj, type) {
	    //NOTE: Searches for batches only on the first scene
	    var scene_data = obj.scenes_data[0];
	    var batches = scene_data.batches;
	    for (var i = 0; i < batches.length; i++)
	        if (batches[i].type == type)
	            return true;
	    return false;
	};

	exports.get_batch_by_type = get_batch_by_type;
	function get_batch_by_type(obj, type, scene) {
	    var scene_data = scene ? m_obj_util.get_scene_data(obj, scene) : obj.scenes_data[0];
	    var batches = scene_data.batches;
	    for (var i = 0; i < batches.length; i++) {
	        if (batches[i].type == type)
	            return batches[i];
	    }

	    return null;
	}

	/**
	 * Delete all GL objects from the batch
	 */
	exports.clear_batch = function(batch) {
	    var textures = batch.textures;
	    batch.textures = [];
	    for (var i = 0; i < textures.length; i++)
	        m_textures.cleanup_unused(textures[i]);
	    batch.textures = textures;

	    if (batch.bufs_data && batch.bufs_data.cleanup_gl_data_on_unload)
	        m_geom.cleanup_bufs_data(batch.bufs_data);

	    if (batch.cleanup_gl_data_on_unload && batch.vaos.length)
	        m_render.cleanup_vao(batch);

	    if (batch.shader && batch.shader.cleanup_gl_data_on_unload)
	        m_shaders.cleanup_shader(batch.shader);

	    if (batch.ngraph_proxy_id) {
	        var ngraph_proxy = m_nodemat.get_ngraph_proxy_cached(batch.ngraph_proxy_id);
	        if (ngraph_proxy && ngraph_proxy.cleanup_on_unload)
	            m_nodemat.cleanup_ngraph_proxy(batch.ngraph_proxy_id);
	    }
	};

	exports.generate_odd_id = generate_odd_id;
	function generate_odd_id(batch, render, odd_id_prop) {

	    var odd_id = odd_id_prop;

	    // all navmeshes must have the same batch id - hence the same odd_id_prop
	    if (batch.subtype == "NAVMESH")
	        return odd_id;

	    // dynamic geometry totally prevents batching for an object
	    if (render.dynamic_geometry)
	        return "_odd_id_" + m_util.unique_id();

	    return odd_id;
	}

	function bpy_mat_is_disabled_for_obj(obj, bpy_mat_index) {
	    // use index instead of indexOf because of duplicated by link materials
	    return bpy_mat_index >= 0 && bpy_mat_index < obj.mat_inheritance_data.is_disabled.length 
	            && obj.mat_inheritance_data.is_disabled[bpy_mat_index];
	}

	exports.cleanup = function() {
	    _batch_debug_storage = {};
	};

	}

	var int_batch_factory = register("__batch", Int_batch);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Anchors internal API.
	 * @name anchors
	 * @namespace
	 * @exports exports as scenes
	 */
	function Int_anchors(ns, exports) {

	var m_batch  = int_batch_factory(ns);
	var m_cam    = int_camera_factory(ns);
	var m_cfg    = int_config_factory(ns);
	var m_cont   = int_container_factory(ns);
	var m_input  = int_input_factory(ns);
	var m_obj    = int_objects_factory(ns);
	var m_obj_util = int_obj_util_factory(ns);
	var m_print  = print_factory(ns);
	var m_render = int_renderer_factory(ns);
	var m_scenes = int_scenes_factory(ns);
	var m_subs   = int_subscene_factory(ns);
	var m_time   = int_time_factory(ns);
	var m_trans  = int_transform_factory(ns);
	var m_tsr    = int_tsr_factory(ns);
	var m_vec3   = vec3_factory(ns);

	var cfg_def = m_cfg.defaults;

	var _anchors      = [];
	var _is_paused    = false;
	var _clicked_elem = null;
	var _in_use       = false;
	var _is_anim      = false;

	var _anchor_batch_pos = new Float32Array(0);
	var _pixels           = new Uint8Array(16);

	var _vec2_tmp = new Float32Array(2);
	var _vec3_tmp = new Float32Array(3);
	var _vec3_tmp2 = new Float32Array(3);

	exports.append = function(obj) {
	    if (is_anchor(obj))
	        return;

	    // NOTE: depends on subscene here because not supported for dynamically loaded data
	    var det_vis = obj.anchor.detect_visibility &&
	            Boolean(m_scenes.get_subs(m_scenes.get_main(), m_subs.ANCHOR_VISIBILITY));

	    var anchor = {
	        type: obj.anchor.type,
	        obj: obj,
	        x: 0,
	        y: 0,
	        depth: 0,
	        appearance: "out",
	        detect_visibility: det_vis,
	        element: null,
	        move_cb: null,
	        annotation_max_width: obj.anchor.max_width,
	        element_id: obj.anchor.element_id
	    };

	    switch (anchor.type) {
	    case "ANNOTATION":
	        anchor.element = create_annotation(anchor);

	        break;
	    case "ELEMENT":
	        anchor.element = document.getElementById(obj.anchor.element_id);

	        if (!anchor.element) {
	            m_print.warn("Anchor HTML element with the id '" 
	                    + obj.anchor.element_id + "' was not found, making it generic.");
	            anchor.type = "GENERIC";
	        } else {
	            for (var i = 0; i < _anchors.length; i++)
	                if (_anchors[i].type == "ELEMENT" 
	                        && _anchors[i].element_id == obj.anchor.element_id) {
	                    m_print.warn("Anchor with the id '" + obj.anchor.element_id 
	                            + "' already exists, making the new anchor generic.");
	                    anchor.type = "GENERIC";
	                }
	        }

	        break;
	    case "GENERIC":
	        break;
	    }

	    _anchors.push(anchor);
	    resize_anchor_batch_pos();

	    if (!_in_use)
	        add_click_listener();
	};

	function onmouseup(e) {
	    if (_is_anim)
	        return;

	    if (_is_paused)
	        return;

	    var anchor_cont = _clicked_elem;

	    if (!anchor_cont)
	        return;

	    if (anchor_cont.lastElementChild.style.visibility == "visible") {
	        close_descr();

	        _clicked_elem = null;

	        return;
	    }

	    if (anchor_cont.style.opacity != 1.0)
	        return;

	    var anchor_descr = anchor_cont.lastElementChild;
	    var anchor_title = anchor_cont.firstElementChild;
	    var descr_body = anchor_descr.firstElementChild;

	    var descr_width = Math.ceil(anchor_descr.getBoundingClientRect().width);
	    var descr_height = Math.ceil(anchor_descr.getBoundingClientRect().height);

	    var title_width = Math.ceil(anchor_title.getBoundingClientRect().width);
	    var title_height = Math.ceil(anchor_title.getBoundingClientRect().height);

	    anchor_descr.style.position = "absolute";
	    anchor_descr.style.visibility = "visible";

	    var width_anim = true;
	    var height_anim = true;

	    anchor_title.style.display = "none";

	    _is_anim = true;

	    if (title_width != descr_width)
	        m_time.animate(title_width, descr_width, 200, function(e) {
	            if (e == descr_width) {
	                width_anim = false;

	                if (!height_anim)
	                    show_descr();
	            }

	            anchor_descr.style.width = e + "px";
	        });
	    else {
	        width_anim = false;

	        if (!height_anim)
	            _is_anim = false;
	    }

	    if (title_height != descr_height)
	        m_time.animate(title_height, descr_height, 200, function(e) {
	            if (e == descr_height) {
	                height_anim = false;

	                if (!width_anim)
	                    show_descr();
	            }

	            anchor_descr.style.height = e + "px";
	        });
	    else {
	        height_anim = false;

	        if (!width_anim)
	            _is_anim = false;
	    }

	    function show_descr() {
	        _is_anim = false;
	        descr_body.style.visibility = "visible";
	    }
	}

	function add_click_listener() {
	    _in_use = true;

	    var canvas_cont = m_cont.get_container();

	    canvas_cont.addEventListener("mouseup", onmouseup);
	}

	function close_descr() {
	    var last_child = _clicked_elem.lastElementChild;
	    _clicked_elem.firstElementChild.style.display = "";

	    last_child.style.visibility = "hidden";
	    last_child.style.position = "relative";
	    last_child.firstElementChild.style.visibility = "hidden";
	}

	function create_annotation(anchor) {
	    var obj = anchor.obj;

	    var canvas_cont = m_cont.get_container();
	    var meta_tags = m_obj.get_meta_tags(obj);

	    var title_text = obj.name;
	    var descr_text = "";

	    var anchor_cont_elem = document.createElement("div");

	    var title_wrap_elem = anchor_cont_elem.cloneNode(false);
	    var title_elem = document.createElement("span");

	    add_cont_style(anchor_cont_elem);
	    add_title_wrap_style(title_wrap_elem);

	    anchor_cont_elem.style.visibility = "hidden";

	    if (meta_tags) {
	        descr_text = meta_tags.description || descr_text;
	        title_text = meta_tags.title || title_text;
	    }

	    title_elem.innerHTML = title_text;

	    add_noselect_style(title_elem);
	    add_inner_style(title_elem);

	    title_elem.style.whiteSpace = "nowrap";

	    title_wrap_elem.appendChild(title_elem);
	    anchor_cont_elem.appendChild(title_wrap_elem);

	    if (descr_text)
	        create_anchor_descr_elem(descr_text, anchor_cont_elem, anchor.annotation_max_width);

	    canvas_cont.appendChild(anchor_cont_elem);

	    return anchor_cont_elem;
	}

	function add_title_wrap_style(elem) {
	    elem.style.cssText +=
	        "background-color:   #000;" +
	        "border-radius:      20px 20px 20px 0px;" +
	        "box-shadow:         0px 0px 10px rgb(180, 180, 200);" +
	        "-webkit-box-shadow: 0px 0px 10px rgb(180, 180, 200);" +
	        "opacity:            1.0;" +
	        "box-sizing:         border-box;" +
	        "bottom:             0;" +
	        "left:               0;" +
	        "padding:            6px 12px 6px 12px;" +
	        "position:           absolute;";
	}

	function add_cont_style(elem) {
	    // NOTE: transform-style property needed to prevent shaking of the child
	    // elements in FF under Linux
	    elem.style.cssText +=
	        "position:        absolute;" +
	        "height:          0;" +
	        "top:             0;" +
	        "left:            0;" +
	        "transform-style: preserve-3d;";
	}

	function add_inner_style(elem) {
	    elem.style.cssText +=
	        "color:       #fff;" +
	        "font-family: Arial;"+
	        "font-size:   12px;" +
	        "font-weight: bold;" +
	        "line-height: 1.25;";
	}

	function add_descr_style(elem) {
	    elem.style.cssText +=
	        "background-color:   #000;" +
	        "border-radius:      20px 20px 20px 0px;" +
	        "bottom:             0;" +
	        "box-shadow:         0px 0px 10px rgb(180, 180, 200);" +
	        "-webkit-box-shadow: 0px 0px 10px rgb(180, 180, 200);" +
	        "left:               0;"+
	        "box-sizing:         border-box;" +
	        "opacity:            1.0;" +
	        "padding:            6px 12px 6px 12px;" +
	        "position:           relative;" +
	        "z-index:            2;";
	}

	function add_noselect_style(elem) {
	    elem.style.cssText +=
	        "-webkit-touch-callout: none;" +
	        "-webkit-user-select:   none;" +
	        "-khtml-user-select:    none;" +
	        "-moz-user-select:      none;" +
	        "-ms-user-select:       none;" +
	        "user-select:           none;" +
	        "cursor:                default;";
	}

	function create_anchor_descr_elem(descr_text, anchor_cont_elem, annotation_max_width) {
	    var descr_wrap_elem = document.createElement("div");
	    var descr_elem = document.createElement("span");

	    if (annotation_max_width)
	        descr_wrap_elem.style.maxWidth = annotation_max_width + "px";

	    add_descr_style(descr_wrap_elem);
	    add_inner_style(descr_elem);

	    descr_elem.innerHTML = descr_text;

	    descr_wrap_elem.style.visibility = "hidden";
	    descr_elem.style.visibility = "hidden";

	    descr_wrap_elem.appendChild(descr_elem);
	    anchor_cont_elem.appendChild(descr_wrap_elem);

	    m_input.add_click_listener(anchor_cont_elem, function(e) {
	        if (_is_anim)
	            return;

	        if (anchor_cont_elem == _clicked_elem)
	            return;

	        if (anchor_cont_elem.style.opacity != 1.0)
	            return;

	        if (_is_paused)
	            return;

	        if (_clicked_elem && _clicked_elem.lastElementChild.style.visibility == "visible")
	            close_descr();

	        _clicked_elem = anchor_cont_elem;
	    });
	}

	function resize_anchor_batch_pos() {
	    var num = 0;

	    for (var i = 0; i < _anchors.length; i++)
	        if (_anchors[i].detect_visibility)
	            num++;

	    _anchor_batch_pos = new Float32Array(3 * num);
	}

	exports.remove = function(obj) {
	    for (var i = 0; i < _anchors.length; i++) {
	        var anchor = _anchors[i];

	        if (anchor.obj == obj) {
	            if (anchor.type == "ANNOTATION")
	                remove_annotation(anchor);
	            _anchors.splice(i, 1);
	            resize_anchor_batch_pos();
	            i--;
	            break;
	        }
	    }
	};

	function sort_anchors_zindex(a, b) {
	    return b.depth - a.depth;
	}

	exports.update = function(force_update) {
	    var det_vis_cnt = 0;

	    for (var i = _anchors.length; i--;) {
	        var anchor = _anchors[i];

	        // update always because the anchor may change it's depth
	        if (anchor.detect_visibility) {
	            var trans = m_tsr.get_trans_view(anchor.obj.render.world_tsr);
	            _anchor_batch_pos.set(trans, 3 * det_vis_cnt++);
	        }

	        var pp = anchor_project(anchor, _vec3_tmp);
	        var x = pp[0];
	        var y = pp[1];
	        var depth = pp[2];

	        // optimization
	        if (!force_update && x == anchor.x && y == anchor.y && depth == anchor.depth)
	            continue;

	        switch (anchor.type) {
	        case "ANNOTATION":
	            // position by left down angle
	            var left = x;
	            var top = y;
	            transform_anchor_el(anchor, left, top);
	            break;
	        case "ELEMENT":
	            // position by center, no width/height optimization here, may change
	            var bounding_box = anchor.element.getBoundingClientRect();
	            var left = x - bounding_box.width / 2;
	            var top = y - bounding_box.height / 2;
	            transform_anchor_el(anchor, left, top);
	            break;
	        case "GENERIC":
	            break;
	        }

	        anchor.x = x;
	        anchor.y = y;
	        anchor.depth = depth;

	        if (anchor.move_cb)
	            anchor.move_cb(x, y, anchor.appearance, anchor.obj, anchor.element);
	    }

	    _anchors.sort(sort_anchors_zindex);

	    // NOTE: setting z-index can be very slow on iPad in case of many 
	    // overlapping elements
	    for (var i = 0; i < _anchors.length; i++) {
	        var anchor = _anchors[i];

	        if (anchor.type != "GENERIC") {
	            if (_clicked_elem == anchor.element)
	                anchor.element.style.zIndex = _anchors.length;
	            else
	                anchor.element.style.zIndex = i;
	        }
	    }

	    if (det_vis_cnt > 0) {
	        var subs_anchor = m_scenes.get_subs(m_scenes.get_main(), m_subs.ANCHOR_VISIBILITY);
	        var bundle = subs_anchor.draw_data[0].bundles[0];
	        var batch_anchor = bundle.batch;
	        m_batch.update_anchor_visibility_batch(batch_anchor, _anchor_batch_pos);
	        m_subs.append_draw_data(subs_anchor, bundle);
	    }
	};

	// subpixel smoothing works in chrome, safari and QQ by now
	function transform_anchor_el(anchor, left, top) {
	    var el = anchor.element;

	    if (cfg_def.ie_edge_anchors_floor_hack) {
	        left = Math.floor(left);
	        top = Math.floor(top);
	    }

	    if ("transform" in el.style)
	        el.style.transform = "translate3d(" + left + "px, " + top + "px, 0px)";
	    else if ("webkitTransform" in el.style)
	        el.style.webkitTransform = "translate3d(" + left + "px, " + top + "px, 0px)";
	    else {
	        el.style.left = left + "px";
	        el.style.top = top + "px";
	    }
	}

	function anchor_project(anchor, dest) {
	    var camobj = m_scenes.get_camera(m_scenes.get_main());
	    var trans = m_tsr.get_trans_view(anchor.obj.render.world_tsr);
	    m_cam.project_point(camobj, trans, dest);

	    return dest;
	}

	exports.update_visibility = function() {
	    var canvas_cont = m_cont.get_container();
	    var active_scene = m_scenes.get_active();
	    var subs_stereo = m_scenes.get_subs(active_scene, m_subs.STEREO);
	    var is_splitscreen = Boolean(subs_stereo && subs_stereo.enable_hmd_stereo);

	    for (var i = _anchors.length; i--;) {
	        var anchor = _anchors[i];
	        var obj = anchor.obj;
	        var obj_render = obj.render;

	        var x = anchor.x;
	        var y = anchor.y;
	        var depth = anchor.depth;

	        var camobj = m_scenes.get_camera(m_scenes.get_main());
	        var center = m_trans.get_translation(obj, _vec3_tmp);
	        var eye = m_trans.get_translation(camobj, _vec3_tmp2);
	        var dist = m_vec3.dist(center, eye);

	        // optimized order
	        if (x < 0 || y < 0 || depth < 0 || depth > 1 || m_scenes.is_hidden(obj) ||
	                x >= canvas_cont.clientWidth || y >= canvas_cont.clientHeight ||
	                !is_anchor_lod_visible(obj_render, dist))
	            var appearance = "out";
	        else
	            var appearance = "visible";

	        if (anchor.detect_visibility && appearance != "out") {
	            appearance = pick_anchor_visibility(anchor);
	        }

	        if (is_splitscreen)
	            appearance = "out";

	        // optimization

	        if (appearance == anchor.appearance)
	            continue;

	        switch (anchor.type) {
	        case "ANNOTATION":
	        case "ELEMENT":
	            var element = anchor.element;

	            if (!element)
	                break;

	            if (appearance == "out") {
	                element.style.visibility = "hidden";

	                if (element.children.length)
	                    element.children[0].style.visibility = "hidden";
	            } else if (appearance == "visible") {
	                element.style.visibility = "visible";

	                if (element.children.length)
	                    element.children[0].style.visibility = "visible";

	                element.style.opacity = 1.0;
	            } else {
	                element.style.visibility = "visible";
	                element.style.opacity = 0.1;

	                if (element.children.length)
	                    element.children[0].style.visibility = "visible";

	                // hide description div
	                if (anchor.type == "ANNOTATION" && element.children.length > 1)
	                    if (element.lastElementChild.style.visibility == "visible") {
	                        close_descr();

	                        if (element == _clicked_elem)
	                            _clicked_elem = null;
	                    }
	            }

	            break;
	        case "GENERIC":
	            break;
	        }

	        anchor.appearance = appearance;

	        if (anchor.move_cb)
	            anchor.move_cb(x, y, anchor.appearance, obj, element);
	    }
	};

	function pick_anchor_visibility(anchor) {
	    // NOTE: slow
	    var subs_anchor = m_scenes.get_subs(m_scenes.get_main(), m_subs.ANCHOR_VISIBILITY);
	    var anchor_cam = subs_anchor.camera;

	    var viewport_xy = m_cont.canvas_to_viewport_coords(anchor.x, anchor.y, 
	            _vec2_tmp, anchor_cam);

	    // NOTE: very slow
	    m_render.read_pixels(anchor_cam.framebuffer, viewport_xy[0], 
	            anchor_cam.height - viewport_xy[1], 2, 2, _pixels);

	    if (_pixels[0] + _pixels[4] + _pixels[8] + _pixels[12] >= 255)
	        return "visible";
	    else if (anchor.appearance == "out" || 
	            _pixels[0] + _pixels[4] + _pixels[8] + _pixels[12] == 0)
	        return "covered";
	    else
	        return anchor.appearance;
	}

	exports.attach_move_cb = function(obj, callback) {
	    for (var i = 0; i < _anchors.length; i++)
	        if (_anchors[i].obj == obj)
	            _anchors[i].move_cb = callback;
	};

	exports.detach_move_cb = function(obj) {
	    for (var i = 0; i < _anchors.length; i++)
	        if (_anchors[i].obj == obj)
	            _anchors[i].move_cb = null;
	};

	function remove_annotation(anchor) {
	    var canvas_cont = m_cont.get_container();

	    canvas_cont.removeChild(anchor.element);
	}

	exports.cleanup = function() {
	    for (var i = 0; i < _anchors.length; i++) {
	        var anchor = _anchors[i];
	        if (anchor.type == "ANNOTATION")
	            remove_annotation(anchor);
	    }

	    _anchors.length = 0;
	};

	exports.is_anchor = is_anchor;
	function is_anchor(obj) {
	    for (var i = 0; i < _anchors.length; i++)
	        if (_anchors[i].obj == obj)
	            return true;

	    return false;
	}

	exports.get_element_id = function(obj) {
	    for (var i = 0; i < _anchors.length; i++)
	        if (_anchors[i].obj == obj)
	            return _anchors[i].element_id;

	    return false;
	};

	exports.pause = function() {
	    _is_paused = true;
	};

	exports.resume = function() {
	    _is_paused = false;
	};

	exports.pick_anchor = function(x, y) {
	    var index = -1;
	    for (var i = 0; i < _anchors.length; i++)
	        if (_anchors[i].appearance == "visible" && check_anchor_coords(_anchors[i], x, y)) {
	            if (index < 0) {
	                var min_dist = _anchors[i].depth;
	                index = i;
	            } else
	                if (_anchors[i].depth < min_dist) {
	                    index = i;
	                    min_dist = _anchors[i].depth;
	                }
	        }

	    if (index < 0)
	        return null;
	    else
	        return _anchors[index].obj;
	};

	function check_anchor_coords(anchor, x, y) {
	    if (anchor.element) {
	        var width = Math.round(anchor.element.offsetWidth) || 0;
	        var height = Math.round(anchor.element.offsetHeight) || 0;
	    } else {
	        var width = 0;
	        var height = 0;
	    }

	    var a_x = anchor.x;
	    var a_y = anchor.y;

	    if (x >= a_x && x <= (a_x + width) && y < a_y && y >= (a_y - height))
	        return true;
	    else
	        return false;
	}

	function is_anchor_lod_visible(obj_render, dist) {
	    if (!obj_render.is_lod)
	        return true;

	    var dist_min = obj_render.lod_dist_min;
	    var dist_max = obj_render.lod_dist_max;
	    if (dist < dist_min)
	        return false;
	    // for objects with no lods or with infinite lod_dist_max
	    if (dist_max == m_obj_util.LOD_DIST_MAX_INFINITY)
	        return true;

	    if (dist < dist_max)
	        return true;

	    return false;
	}

	}

	var int_anchors_factory = register("__anchors", Int_anchors);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	function Int_loader(ns, exports) {

	var m_graph  = int_graph_factory(ns);
	var m_print  = print_factory(ns);
	var m_util   = int_util_factory(ns);
	var m_cfg    = int_config_factory(ns);

	var cfg_def  = m_cfg.defaults;

	var THREAD_IDLE = 0;
	var THREAD_LOADING = 1;
	var THREAD_FINISHED_NO_RESOURCES = 2;
	var THREAD_FINISHED = 3;
	var THREAD_ABORTED = 4;

	var THREAD_STAGE_BEFORE = 0;
	var THREAD_STAGE_LOOP = 1;
	var THREAD_STAGE_AFTER = 2;
	var THREAD_STAGE_IDLE = 3;

	var DEBUG_COLOR = "color: #f0f;";

	var MAX_LOAD_TIME_MS = 16;

	exports.SYNC_PRIORITY = 0;
	exports.ASYNC_PRIORITY = 1;
	exports.FINISH_PRIORITY = 2;

	var _scheduler = null;

	exports.get_scheduler = get_scheduler;
	function get_scheduler() {
	    return _scheduler;
	}

	function set_scheduler(scheduler) {
	    _scheduler = scheduler;
	}

	/**
	 * Create scheduler.
	 */
	exports.create_scheduler = function() {
	    var scheduler = {
	        threads: [],
	        current_thread_index: 0,
	        active_threads: 0,

	        start_secondary_threads: false,
	        make_idle_iteration: false
	    };

	    set_scheduler(scheduler);

	    return scheduler;
	};

	/**
	 * Create scheduler thread.
	 * @param {Object3D} stages Loading stages
	 * @param {string} path Path to main .json file
	 * @param {Function} loaded_callback Callback on all/non-background stages loading
	 * @param {Function} stageload_cb Callback on stage loading
	 * @param {Function} complete_load_cb Callback on all stages loading (currently it's a low-level service callback)
	 * @param {boolean} wait_complete_loading Perform callback on all or all non-background stages loading
	 * @param {boolean} do_not_load_resources To load or not to load application resources
	 * @param {boolean} load_hidden Hide loaded and disable physics objects
	 * @returns {number} Id of loaded data.
	 */
	exports.create_thread = function(stages, path, loaded_callback, 
	        stageload_cb, complete_load_cb, wait_complete_loading, 
	        do_not_load_resources, load_hidden, is_preloading) {

	    var scheduler = get_scheduler();

	    var id = scheduler.threads.length;
	    var thread = {
	        id: id,
	        is_primary: id == 0,
	        status: THREAD_IDLE,

	        filepath: path,
	        binary_name: "",

	        loaded_cb: loaded_callback || (function() {}),

	        load_hidden: load_hidden || false,
	        wait_complete_loading: wait_complete_loading,

	        time_load_start: 0,
	        curr_percents: 0,
	        stages_size_total: 0,
	        reset_time_cycle: false,
	        
	        stageload_cb: stageload_cb || (function() {}),
	        complete_load_cb: complete_load_cb || (function() {}),
	        
	        stage_graph: null,
	        stages_queue: null,
	        has_video_textures: false,
	        has_background_music: false,
	        init_wa_context: false,

	        is_preloading: is_preloading
	    };

	    var graph = create_loading_graph(thread.is_primary, stages, 
	            wait_complete_loading, do_not_load_resources);
	    thread.stage_graph = graph;

	    var stages_queue = [];
	    var init_nodes = m_graph.get_source_nodes(graph);
	    for (var i = 0; i < init_nodes.length; i++)
	        stages_queue.push(init_nodes[i]);
	    thread.stages_queue = stages_queue;

	    m_graph.traverse(graph, function(id, attr) {
	        if (attr.cb_before || attr.cb_loop || attr.cb_after)
	            if (stage_need_calc(thread, attr))
	                thread.stages_size_total += attr.relative_size;
	    });

	    scheduler.threads.push(thread);
	    scheduler.active_threads++;

	    return thread.id;
	};

	function create_loading_graph(is_primary, stages, wait_complete_loading, 
	        do_not_load_resources) {
	    var scheduler = get_scheduler();

	    var graph = m_graph.create();

	    for (var stage_name in stages) {
	        var stage = init_stage(stages[stage_name]);
	        // skip "resource" or "primary_only" threads if necessary
	        if (do_not_load_resources && stage.is_resource 
	                || !is_primary && stage.primary_only)
	            skip_stage(stage);
	        m_graph.append_node_attr(graph, stage);
	    }

	    for (var stage_name in stages) {
	        var stage = stages[stage_name];
	        stage.name = stage_name;
	        for (var i = 0; i < stage.inputs.length; i++)
	            m_graph.append_edge_attr(graph, stages[stage.inputs[i]], stage, 
	                    null);
	    }

	    // add finishing node (may be performed before resource nodes 
	    // if "do_not_load_resources" is true)
	    var loaded_cb_wrapper = function(bpy_data, thread, stage, cb_param,
	            cb_finish, cb_set_rate) {
	        
	        // primary thread loaded, allow to load secondary threads
	        if (thread.is_primary)
	            scheduler.start_secondary_threads = true;

	        if (!thread_is_finished(thread))
	            thread.status = THREAD_FINISHED_NO_RESOURCES;

	        thread.loaded_cb(thread.id, true);
	        cb_finish(thread, stage);
	        m_print.log("%cTHREAD " + thread.id + ": LOADED CALLBACK", DEBUG_COLOR);
	    };

	    var finish_node = init_stage({
	        name: "out",
	        priority: exports.FINISH_PRIORITY,
	        cb_before: loaded_cb_wrapper,
	        relative_size: 5
	    });

	    if (wait_complete_loading)
	        var sink_ids = m_graph.get_sink_nodes(graph);
	    else {
	        var tmp_graph = m_graph.clone(graph);
	        var sink_ids;
	        var bkg_sink_ids;

	        do {
	            sink_ids = m_graph.get_sink_nodes(tmp_graph);
	            bkg_sink_ids = [];            

	            for (var i = 0; i < sink_ids.length; i++) {
	                var id = sink_ids[i];
	                var sink_node = m_graph.get_node_attr(tmp_graph, id);
	                if (sink_node.background_loading)
	                    bkg_sink_ids.push(id);
	            }

	            for (var i = 0; i < bkg_sink_ids.length; i++)
	                m_graph.remove_node(tmp_graph, bkg_sink_ids[i]);
	            if (bkg_sink_ids.length)
	                m_graph.cleanup_loose_edges(tmp_graph);
	        } while (bkg_sink_ids.length);
	    }

	    m_graph.append_node_attr(graph, finish_node);

	    for (var i = 0; i < sink_ids.length; i++) {
	        var id = sink_ids[i];
	        var sink_node = m_graph.get_node_attr(graph, id);
	        finish_node.inputs.push(sink_node.name);
	        m_graph.append_edge_attr(graph, sink_node, finish_node, null);
	    }

	    return graph;
	}

	function init_stage(stage) {
	    stage.background_loading = stage.background_loading || false;
	    if (!(stage.priority || stage.priority === 0))
	        stage.priority = stage.SYNC_PRIORITY;
	    stage.inputs = stage.inputs || [];
	    stage.is_finished = stage.is_finished || false;
	    stage.skip = stage.skip || false;
	    stage.relative_size = stage.relative_size || 0;
	    stage.is_resource = stage.is_resource || false;
	    stage.primary_only = stage.primary_only || false;
	    
	    stage.status = THREAD_STAGE_BEFORE;
	    stage.loop_index = 0;
	    stage.load_rate = 0;
	    stage.cb_param = stage.cb_param || null;
	    
	    return stage;
	}

	exports.update_scheduler = function(bpy_data_array) {
	    var scheduler = get_scheduler();

	    if (!scheduler || is_finished())
	        return;

	    if (scheduler.make_idle_iteration) {
	        scheduler.make_idle_iteration = false;
	        return;
	    }

	    var time_start = performance.now();
	    do {
	        var thread = scheduler.threads[scheduler.current_thread_index];
	        var bpy_data = bpy_data_array[thread.id];

	        if (!thread_is_finished(thread)) {

	            // start new thread
	            if (thread.status == THREAD_IDLE) {
	                thread.status = THREAD_LOADING;
	                thread.time_load_start = performance.now();
	                thread.stageload_cb(0, 0, thread.id);
	                if (cfg_def.debug_loading)
	                    m_print.log("%cTHREAD " + thread.id 
	                            + ": 0% LOADING START 0ms", DEBUG_COLOR);
	            }

	            if (update_stages_queue(thread))
	                process_stages_queue(thread, bpy_data);
	            else
	                finish_thread(scheduler, thread, bpy_data);
	        }

	        // process secondary threads after main is loaded
	        if (scheduler.start_secondary_threads)
	            scheduler.current_thread_index = (scheduler.current_thread_index + 1) 
	                    % scheduler.threads.length;

	        // NOTE: reset time cycle for asynchronous stages
	        if (thread.reset_time_cycle) {
	            thread.reset_time_cycle = false;
	            return;
	        }

	    } while(performance.now() - time_start < MAX_LOAD_TIME_MS);
	};

	exports.abort_thread = function(thread) {
	    var scheduler = get_scheduler();
	    finish_thread(scheduler, thread, null);
	    thread.status = THREAD_ABORTED;

	    // primary thread finished, allow to load secondary threads
	    if (thread.is_primary)
	        scheduler.start_secondary_threads = true;

	    thread.loaded_cb(thread.id, false);
	};

	function finish_thread(scheduler, thread, bpy_data) {
	    // finish thread totally (including all resources)
	    thread.complete_load_cb(bpy_data, thread);
	    thread.status = THREAD_FINISHED;
	    scheduler.active_threads--;
	    if (cfg_def.debug_loading) {
	        var ms = Math.round(performance.now() 
	                - thread.time_load_start);
	        m_print.log("%cTHREAD " + thread.id + ": 100% LOADING END " 
	                + ms + "ms", 
	                DEBUG_COLOR);
	    }
	    release_thread(thread);
	}

	function process_stages_queue(thread, bpy_data) {
	    var iter_counter = thread.stages_queue.length;

	    do {
	        var stage_index = thread.stages_queue[0];
	        var stage = m_graph.get_node_attr(thread.stage_graph, stage_index);
	        var is_processed = process_stage(thread, stage, bpy_data);
	        
	        if (stage.priority == exports.ASYNC_PRIORITY)
	            thread.reset_time_cycle = true;
	        
	        var first = thread.stages_queue.shift();
	        thread.stages_queue.push(first);
	        iter_counter--;
	    } while (!(is_processed || iter_counter == 0));
	}

	function propagate_stages(thread, stage_indices) {
	    var next_indices = [];
	    var stages_to_remove = [];

	    for (var i = 0; i < stage_indices.length; i++) {
	        var stage_index = stage_indices[i];
	        var stage = m_graph.get_node_attr(thread.stage_graph, stage_index);
	        if (stage.is_finished) {
	            m_graph.traverse_outputs(thread.stage_graph, stage_index, 
	                    function(id_out, attr_out, edge_attr_out) {
	                var can_execute = true;
	                m_graph.traverse_inputs(thread.stage_graph, id_out, 
	                        function(id_in, attr_in, edge_attr_in) {
	                    if (!attr_in.is_finished) {
	                        can_execute = false;
	                        return 1;
	                    }
	                });
	                if (can_execute && next_indices.indexOf(id_out) == -1 
	                        && stage_indices.indexOf(id_out) == -1) {
	                    next_indices.push(id_out);
	                }
	            });
	            stages_to_remove.push(i);
	        }
	    }

	    for (var i = stages_to_remove.length - 1; i >= 0; i--)
	        stage_indices.splice(stages_to_remove[i], 1);

	    return next_indices;
	}

	function update_stages_queue(thread) {
	    var result_indices = [];
	    var prev_indices = thread.stages_queue;
	    var new_added = false;

	    do {
	        // prev_indices filtered here
	        var next_indices = propagate_stages(thread, prev_indices);
	        result_indices.push.apply(result_indices, prev_indices);
	        if (next_indices.length > 0)
	            new_added = true;
	        prev_indices = next_indices;
	    } while (next_indices.length > 0);


	    var priority_stage_sort = function(a, b) {
	        var stage_a = m_graph.get_node_attr(thread.stage_graph, a);
	        var stage_b = m_graph.get_node_attr(thread.stage_graph, b);

	        // handle priority
	        var result = stage_b.priority - stage_a.priority;
	        if (result == 0)
	            // !background first
	            result = stage_a.background_loading - stage_b.background_loading;
	        return result;
	    };

	    if (new_added)
	        result_indices.sort(priority_stage_sort);

	    thread.stages_queue = result_indices;
	    return thread.stages_queue.length;
	}

	/**
	 * Returns true if stage callback is executed
	 */
	function process_stage(thread, stage, bpy_data) {
	    // don't process skipped stages
	    if (stage.skip) {
	        stage.is_finished = true;
	        if (cfg_def.debug_loading)
	            m_print.log("%cTHREAD " + thread.id + ": SKIP STAGE " + stage.name, 
	                    DEBUG_COLOR);

	        stage_finish_cb(thread, stage);
	        return false;
	    }

	    // debug message for start stage loading
	    if (cfg_def.debug_loading && stage.status == THREAD_STAGE_BEFORE) {
	        var percents = get_load_percents(thread);
	        var message = "LOADING START " +  stage.name;
	        var ms = Math.round(performance.now() - thread.time_load_start);
	        m_print.log("%cTHREAD " + thread.id + ": " + percents + "% " + message 
	                + " " + ms + "ms ", DEBUG_COLOR);
	    }

	    // finish stages without any callbacks
	    if (!stage.cb_before && !stage.cb_loop && !stage.cb_after) {
	        stage_finish_cb(thread, stage);
	        return false;
	    }

	    // process stage by status
	    if (stage.status == THREAD_STAGE_BEFORE) {
	        stage.status++;
	        if (stage.cb_before) {
	            stage.cb_before(bpy_data, thread, stage, stage.cb_param, 
	                    stage_finish_cb, stage_part_finish_cb);
	            return true;
	        }
	    }

	    if (stage.status == THREAD_STAGE_LOOP) {
	        if (stage.cb_loop) {
	            stage.cb_loop(bpy_data, thread, stage, stage.cb_param, 
	                    stage_finish_cb, stage_part_finish_cb);
	            return true;
	        } else
	            stage.status++;
	    }

	    if (stage.status == THREAD_STAGE_AFTER) {
	        stage.status++;
	        if (stage.cb_after) {
	            stage.cb_after(bpy_data, thread, stage, stage.cb_param, 
	                    stage_finish_cb, stage_part_finish_cb);
	            return true;
	        }
	    }

	    return false;
	}

	function get_load_percents(thread) {
	    if (thread.stages_size_total == 0)
	        return 100;
	    
	    var loaded = 0;
	    m_graph.traverse(thread.stage_graph, function(id, attr) {
	        if (stage_need_calc(thread, attr))
	            loaded += attr.load_rate * attr.relative_size;
	    });
	    return m_util.trunc(loaded * 100 / thread.stages_size_total);
	}

	function stage_need_calc(thread, stage) {
	    // don't calc resource stages if they will not be loaded
	    return !(thread.do_not_load_resources && stage.is_resource);
	}

	function stage_finish_cb(thread, stage) {
	    stage.is_finished = true;
	    stage.status = THREAD_STAGE_IDLE;
	    stage_loading_action(thread, stage, 1);

	    if (cfg_def.debug_loading) {
	        var percents = get_load_percents(thread);
	        var message = "LOADING END " +  stage.name;
	        var ms = Math.round(performance.now() - thread.time_load_start);
	        m_print.log("%cTHREAD " + thread.id + ": " + percents + "% " + message 
	                + " " + ms + "ms ", DEBUG_COLOR);
	    }
	}

	/**
	 * Perform callback for partially loading
	 * @param {Object3D} thread Scheduler
	 * @param {Object3D} stage Stage object
	 * @param {number} rate Stage load rate
	 */
	exports.stage_part_finish_cb = stage_part_finish_cb;
	function stage_part_finish_cb(thread, stage, rate) {
	    if (rate < 1)
	        stage_loading_action(thread, stage, rate);
	    else
	        stage.status++;
	}

	function stage_loading_action(thread, stage, rate) {
	    var scheduler = get_scheduler();

	    if (stage.cb_before || stage.cb_loop || stage.cb_after) {
	        stage.load_rate = rate;
	        var percents = get_load_percents(thread);

	        if (thread.curr_percents != percents || rate == 1) {
	            thread.stageload_cb(percents, performance.now() 
	                    - thread.time_load_start, thread.id);
	            thread.curr_percents = percents;

	            // NOTE: skip next thread iteration to liquidate loading bar 
	            // freezes
	            scheduler.make_idle_iteration = true;
	        }
	    }
	}

	/**
	 * Skip certain stage
	 * @param {Object3D} thread Scheduler thread
	 * @param {string} name Stage name
	 */
	exports.skip_stage_by_name = function(thread, name) {
	    var stage = get_stage_by_name(thread, name);

	    if (stage !== null)
	        skip_stage(stage);
	};

	function get_stage_by_name(thread, name) {
	    var stage = null;

	    m_graph.traverse(thread.stage_graph, function(id, attr) {
	        if (attr.name == name) {
	            stage = attr;
	            return 1;
	        }
	    });

	    return stage;
	}

	function skip_stage(stage) {
	    stage.skip = true;
	}

	// release some thread properties not needed after thread is over; 
	// for garbage collecting
	function release_thread(thread) {
	    thread.stageload_cb = null;
	    thread.complete_load_cb = null;
	    if (!cfg_def.debug_loading)
	        thread.stage_graph = null;
	    thread.stages_queue = null;
	    // NOTE: thread.loaded_cb needed for aborted threads
	}

	exports.is_finished = is_finished;
	function is_finished() {
	    var scheduler = get_scheduler();
	    return scheduler.active_threads == 0;
	}

	exports.thread_is_finished = thread_is_finished;
	function thread_is_finished(thread) {
	    return thread && (thread.status == THREAD_FINISHED 
	            || thread.status == THREAD_ABORTED);
	}

	/**
	 * Get primary thread/scene loaded status
	 */
	exports.is_primary_loaded = function(data_id) {
	    var scheduler = get_scheduler();

	    if (!scheduler)
	        return false;

	    data_id = data_id | 0;

	    return scheduler.threads[data_id] 
	            && (scheduler.threads[data_id].status == THREAD_FINISHED ||
	                scheduler.threads[data_id].status == THREAD_FINISHED_NO_RESOURCES);
	};

	exports.graph_to_dot = function(data_id) {
	    if (!cfg_def.debug_loading) {
	        m_print.error("Debug mode isn't enabled. Can not retrieve the graph.");
	        return;
	    }

	    var scheduler = get_scheduler();
	    if (scheduler && scheduler.threads[data_id] 
	            && scheduler.threads[data_id].stage_graph)
	        return m_graph.debug_dot(scheduler.threads[data_id].stage_graph, 
	                function(node, attr) {
	                    if (attr.skip)
	                        return "SKIPPED\n(" + attr.name + ")";
	                    else {
	                        var node_label = attr.name + "\n";
	                        var props = [];
	                        props.push(attr.priority == exports.ASYNC_PRIORITY ? "ASYNC" : "SYNC");

	                        if (attr.background_loading)
	                            props.push("BKG");
	                        if (attr.is_resource)
	                            props.push("RES");
	                        return node_label + props.join(" | ");
	                    }
	                }, null);
	    else
	        return null;
	};

	exports.cleanup = function() {
	    set_scheduler(null);
	};

	}

	var int_loader_factory = register("__loader", Int_loader);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	/**
	 * @see http://www.myersdaily.org/joseph/javascript/md5-text.html
	 */

	"use strict";

	function MD5(ns, exports) {

	function md5cycle(x, k) {
	    var a = x[0], b = x[1], c = x[2], d = x[3];

	    a = ff(a, b, c, d, k[0], 7, -680876936);
	    d = ff(d, a, b, c, k[1], 12, -389564586);
	    c = ff(c, d, a, b, k[2], 17,  606105819);
	    b = ff(b, c, d, a, k[3], 22, -1044525330);
	    a = ff(a, b, c, d, k[4], 7, -176418897);
	    d = ff(d, a, b, c, k[5], 12,  1200080426);
	    c = ff(c, d, a, b, k[6], 17, -1473231341);
	    b = ff(b, c, d, a, k[7], 22, -45705983);
	    a = ff(a, b, c, d, k[8], 7,  1770035416);
	    d = ff(d, a, b, c, k[9], 12, -1958414417);
	    c = ff(c, d, a, b, k[10], 17, -42063);
	    b = ff(b, c, d, a, k[11], 22, -1990404162);
	    a = ff(a, b, c, d, k[12], 7,  1804603682);
	    d = ff(d, a, b, c, k[13], 12, -40341101);
	    c = ff(c, d, a, b, k[14], 17, -1502002290);
	    b = ff(b, c, d, a, k[15], 22,  1236535329);

	    a = gg(a, b, c, d, k[1], 5, -165796510);
	    d = gg(d, a, b, c, k[6], 9, -1069501632);
	    c = gg(c, d, a, b, k[11], 14,  643717713);
	    b = gg(b, c, d, a, k[0], 20, -373897302);
	    a = gg(a, b, c, d, k[5], 5, -701558691);
	    d = gg(d, a, b, c, k[10], 9,  38016083);
	    c = gg(c, d, a, b, k[15], 14, -660478335);
	    b = gg(b, c, d, a, k[4], 20, -405537848);
	    a = gg(a, b, c, d, k[9], 5,  568446438);
	    d = gg(d, a, b, c, k[14], 9, -1019803690);
	    c = gg(c, d, a, b, k[3], 14, -187363961);
	    b = gg(b, c, d, a, k[8], 20,  1163531501);
	    a = gg(a, b, c, d, k[13], 5, -1444681467);
	    d = gg(d, a, b, c, k[2], 9, -51403784);
	    c = gg(c, d, a, b, k[7], 14,  1735328473);
	    b = gg(b, c, d, a, k[12], 20, -1926607734);

	    a = hh(a, b, c, d, k[5], 4, -378558);
	    d = hh(d, a, b, c, k[8], 11, -2022574463);
	    c = hh(c, d, a, b, k[11], 16,  1839030562);
	    b = hh(b, c, d, a, k[14], 23, -35309556);
	    a = hh(a, b, c, d, k[1], 4, -1530992060);
	    d = hh(d, a, b, c, k[4], 11,  1272893353);
	    c = hh(c, d, a, b, k[7], 16, -155497632);
	    b = hh(b, c, d, a, k[10], 23, -1094730640);
	    a = hh(a, b, c, d, k[13], 4,  681279174);
	    d = hh(d, a, b, c, k[0], 11, -358537222);
	    c = hh(c, d, a, b, k[3], 16, -722521979);
	    b = hh(b, c, d, a, k[6], 23,  76029189);
	    a = hh(a, b, c, d, k[9], 4, -640364487);
	    d = hh(d, a, b, c, k[12], 11, -421815835);
	    c = hh(c, d, a, b, k[15], 16,  530742520);
	    b = hh(b, c, d, a, k[2], 23, -995338651);

	    a = ii(a, b, c, d, k[0], 6, -198630844);
	    d = ii(d, a, b, c, k[7], 10,  1126891415);
	    c = ii(c, d, a, b, k[14], 15, -1416354905);
	    b = ii(b, c, d, a, k[5], 21, -57434055);
	    a = ii(a, b, c, d, k[12], 6,  1700485571);
	    d = ii(d, a, b, c, k[3], 10, -1894986606);
	    c = ii(c, d, a, b, k[10], 15, -1051523);
	    b = ii(b, c, d, a, k[1], 21, -2054922799);
	    a = ii(a, b, c, d, k[8], 6,  1873313359);
	    d = ii(d, a, b, c, k[15], 10, -30611744);
	    c = ii(c, d, a, b, k[6], 15, -1560198380);
	    b = ii(b, c, d, a, k[13], 21,  1309151649);
	    a = ii(a, b, c, d, k[4], 6, -145523070);
	    d = ii(d, a, b, c, k[11], 10, -1120210379);
	    c = ii(c, d, a, b, k[2], 15,  718787259);
	    b = ii(b, c, d, a, k[9], 21, -343485551);

	    x[0] = add32(a, x[0]);
	    x[1] = add32(b, x[1]);
	    x[2] = add32(c, x[2]);
	    x[3] = add32(d, x[3]);
	}

	function cmn(q, a, b, x, s, t) {
	    a = add32(add32(a, q), add32(x, t));
	    return add32((a << s) | (a >>> (32 - s)), b);
	}

	function ff(a, b, c, d, x, s, t) {
	    return cmn((b & c) | ((~b) & d), a, b, x, s, t);
	}

	function gg(a, b, c, d, x, s, t) {
	    return cmn((b & d) | (c & (~d)), a, b, x, s, t);
	}

	function hh(a, b, c, d, x, s, t) {
	    return cmn(b ^ c ^ d, a, b, x, s, t);
	}

	function ii(a, b, c, d, x, s, t) {
	    return cmn(c ^ (b | (~d)), a, b, x, s, t);
	}

	function md51(s) {
	    var n = s.length,
	    state = [1732584193, -271733879, -1732584194, 271733878], i;
	    for (i=64; i<=s.length; i+=64) {
	        md5cycle(state, md5blk(s.substring(i-64, i)));
	    }
	    s = s.substring(i-64);
	    var tail = [0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0];
	    for (i=0; i<s.length; i++)
	        tail[i>>2] |= s.charCodeAt(i) << ((i%4) << 3);
	    tail[i>>2] |= 0x80 << ((i%4) << 3);
	    if (i > 55) {
	        md5cycle(state, tail);
	        for (i=0; i<16; i++) tail[i] = 0;
	    }
	    tail[14] = n*8;
	    md5cycle(state, tail);
	    return state;
	}

	/**
	 * there needs to be support for Unicode here,
	 * unless we pretend that we can redefine the MD-5
	 * algorithm for multi-byte characters (perhaps
	 * by adding every four 16-bit characters and
	 * shortening the sum to 32 bits). Otherwise
	 * I suggest performing MD-5 as if every character
	 * was two bytes--e.g., 0040 0025 = @%--but then
	 * how will an ordinary MD-5 sum be matched?
	 * There is no way to standardize text to something
	 * like UTF-8 before transformation; speed cost is
	 * utterly prohibitive. The JavaScript standard
	 * itself needs to look at this: it should start
	 * providing access to strings as preformed UTF-8
	 * 8-bit unsigned value arrays.
	 */
	function md5blk(s) { /* I figured global was faster.   */
	    var md5blks = [], i; /* Andy King said do it this way. */
	    for (i=0; i<64; i+=4) {
	        md5blks[i>>2] = s.charCodeAt(i) + (s.charCodeAt(i+1) << 8) +
	            (s.charCodeAt(i+2) << 16) + (s.charCodeAt(i+3) << 24);
	    }
	    return md5blks;
	}

	var hex_chr = '0123456789abcdef'.split('');

	function rhex(n) {
	    var s='', j=0;
	    for(; j<4; j++)
	        s += hex_chr[(n >> (j * 8 + 4)) & 0x0F] + hex_chr[(n >> (j * 8)) & 0x0F];
	    return s;
	}

	function hex(x) {
	    for (var i=0; i<x.length; i++)
	        x[i] = rhex(x[i]);
	    return x.join('');
	}

	/**
	 * this function is much faster, so if possible we use it. Some IEs are the
	 * only ones I know of that need the idiotic second function, generated by an
	 * if clause.
	 */
	function add32(a, b) {
	    return (a + b) & 0xFFFFFFFF;
	}
	//if (md5('hello') != '5d41402abc4b2a76b9719d911017c592') {
	//    function add32(x, y) {
	//        var lsw = (x & 0xFFFF) + (y & 0xFFFF),
	//        msw = (x >> 16) + (y >> 16) + (lsw >> 16);
	//        return (msw << 16) | (lsw & 0xFFFF);
	//    }
	//}

	exports.hexdigest = function(msg) {
	    return hex(md51(msg));
	};

	}

	var md5_factory = register("md5", MD5);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Data internal API.
	 * @name data
	 * @namespace
	 * @exports exports as data
	 */
	function Int_data(ns, exports) {

	var m_anchors   = int_anchors_factory(ns);
	var m_anim      = int_animation_factory(ns);
	var m_assets    = int_assets_factory(ns);
	var m_batch     = int_batch_factory(ns);
	var m_cfg       = int_config_factory(ns);
	var m_cons      = int_constraints_factory(ns);
	var m_ctl       = int_controls_factory(ns);
	var m_texcomp   = int_texcomp_factory(ns);
	var m_debug     = int_debug_factory(ns);
	var m_ext       = int_extensions_factory(ns);
	var m_input     = int_input_factory(ns);
	var m_loader    = int_loader_factory(ns);
	var m_mat       = int_material_factory(ns);
	var m_md5       = md5_factory(ns);
	var m_nla       = int_nla_factory(ns);
	var m_lnodes    = int_logic_nodes_factory(ns);
	var m_particles = int_particles_factory(ns);
	var m_nodemat   = int_nodemat_factory(ns);
	var m_obj       = int_objects_factory(ns);
	var m_obj_util  = int_obj_util_factory(ns);
	var m_phy       = int_physics_factory(ns);
	var m_print     = print_factory(ns);
	var m_quat      = quat_factory(ns);
	var m_reformer  = int_reformer_factory(ns);
	var m_render    = int_renderer_factory(ns);
	var m_scenes    = int_scenes_factory(ns);
	var m_sfx       = int_sfx_factory(ns);
	var m_shaders   = int_shaders_factory(ns);
	var m_subs      = int_subscene_factory(ns);
	var m_tbn       = int_tbn_factory(ns);
	var m_tex       = int_textures_factory(ns);
	var m_time      = int_time_factory(ns);
	var m_trans     = int_transform_factory(ns);
	var m_tsr       = int_tsr_factory(ns);
	var m_util      = int_util_factory(ns);
	var m_vec3      = vec3_factory(ns);
	var m_vec4      = vec4_factory(ns);

	var cfg_anim = m_cfg.animation;
	var cfg_def  = m_cfg.defaults;
	var cfg_ldr  = m_cfg.assets;
	var cfg_phy  = m_cfg.physics;
	var cfg_sfx  = m_cfg.sfx;

	var DEBUG_BPYDATA = false;

	var NORMAL_NUM_COMP  = 3;
	var TANGENT_NUM_COMP  = 4;

	var _bpy_data_array = null;
	var _all_objects_cache = null;
	var _debug_resources_root = "";

	var _primary_scene = null;
	var _dupli_obj_id_overrides = {};

	var _vec3_tmp = new Float32Array(3);
	var _vec4_tmp = new Float32Array(4);
	var _quat_tmp = new Float32Array(4);

	var _tbn_tmp = m_tbn.create();

	var PLAY_MEDIA_IMAGE_MOBILE = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALAAAACwCAYAAACvt+ReAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAbrwAAG68BXhqRHAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAABVDSURBVHic7Z15kF1Vncc/v05Ys7JIQJZ0GLaAgCzCQARGFMIwZKTiqCPBAbTEEodBhYKALJKSVWYsCpTBcgCLAdQBHWZACCCyhCElIRiWEMOSBZAkCglJOoTQyW/++J3Xfe95971+273v3fvOp6qr+5573+vT3d8+93vP+Z3fTwjUhKoKsC0wLvKxDTA68rEVMNK9ZDiwpft6PdDvvl4LvA+sBt5zn1cCy4EVwDJgpYhouj9RMZB2d6ATUdWtgD2BXvcxARgPbJ5RFzYAS4BFwGL38YqIvJ/R988NQcCAqm4LHADsA+yLibannX1KYBMm6JeBBcA8EVnZ3i61n64UsKoOAyYCh7iPCeTvd6HA68BcYA6wQEQ2trdL2ZO3P1rDqGoPsD9wNHAkMKqBt1nNoFctfV7j2ldj/rbPXdsvIuvd994S88QAIzCfHPXOHyHurRvt21PALOAFEdnUwHvkjsILWFV7gcnAUcDYWl8GvAEsZNCDLhKR91rfw4RvrjoWuyv0us97ALtS+99rFfAEMFNElqTRx06hkAJ2I94ngRMwXzsUmzCxzsP85csisja9HtaPqo7CbM9EzK/vRW1/vwXATODJ0h2hSBRKwO5hbAom3KFuw2uAZzD/+JyIrEm5ey1FVUcDB2Ee/hPU9vM+ANwnIu+m3L3MKISAVXU3YCrwNwx6zSTWArOBJ7Gn+P4q1+YGVR0OfByzSX+N+exKfAg8DtwtIm9m0L1UybWAVfWjwJcw4Vb6WRT4A3YbnV0U0VZCVTfDRDwZOJDKv5dNwGPAXSLydja9az25FLCqbg9MA44FhlW4bDXwIPYgszyrvnUSqrojJuRqlqof+C1wp4i8k1XfWkWuBKyqmwN/D3wRW7ZN4m3gfzHhfpBV3zoZNyofBXwem81I4gPgHsxabMiqb82SGwGr6lHAV7A50yQWA3cCT4c4gmRcPMeRwCnY0ngSK4BbRGRWZh1rgo4XsJtZOAvzdUm8CfwSeKxbJu+bxQl5EnAqsEuFy+YAPxKRP2fWsQboWAG7X/JJwGkMRnVFWQXcDjwchNsYbnVyMibkMQmXvA/8DLi/U+9qHSlg95B2HvCxhNP9wG+AO0SkL+F8oE7cws9UzCNvlnDJAuA6EVmWacdqoOMErKpHA98keS7zReAGEXkr2151B6q6C3A2sF/C6bWYpXgy215Vp2MErKpbYMI9NuF0H3ArNrPQkbeyouCs2wnA6SQPIo8AN3XKDE9HCFhVdwK+iwWv+DwLXF+k5c88oKrbAecAByecfh24shMsRdsFrKqHYn53pHdqAzYtdk8YdduDG40nA18DtvBOrwP+TURmZ96xCG0VsKp+DrtV+f1YDFwrIkuz7lOgHBeSej6wm38KmzP+deadcrRFwG765kxsmszncexBrXChf3nGzVScg63o+cwEftyOHSGZC9htmLwAONQ71Y/9N/9P1n0K1I6qngycQXkMyjPANVkPPJkKWFVHApcDe3un1mIPBc9n2Z9AY6jqgcBFlM9SLAAuy3J+PjMBu20yM4DdvVPLge+JyBtZ9SXQPC4G+zJsD1+U14BLs9p+lYmAXTzDFZRHQi0EZojIqiz6EWgtqroNcCmWQyPKUuDiLKY+Uxewqo4BrqL8CfZF4PKQrCPfuIe7S7Dg+ShvARekPTilKmBVHYGNvHt4p54FrshT3GmgMm4V9SJsf16URcBFae43TE3Abrbh+5Q/sM0Gri761p5uwwXNTwcO904twOxEKrMTqaRPcvO851Eu3uewqZYg3oIhIh9iVnGOd2ofYLrLhtRy0sr/dSbl/4nzMdvwYUrfM9Bm3MB0JfCCd+pQbFNCy2m5gN3ysL/CthCbWgmrawXHPdfMAF7xTk12iyAtpaUCVtXDsNiGKMuxqbIg3i7BzSzNwPbXRfmqC95qGS0TsKqOA75N/MGwjzDP25W41K+XYausA83AeS58tiW0RMCRucBo7oF+zPMWOrlcoDJudfUqIBrkMxK40KVIaJpWjcBnUR6MfkuIbQiIyDzgNq95d+AbrXj/pgWsqpMo3wb0eIgqC5Rw8cL+Xrrj3P7HpmhKwKr6EeBfvOYlwA3NvG+gkFyPxUhEOcvtQG+YhgXstpucSzykbgO2kyLMOARiOE1ci2XHLDES+I7TUkM0MwJPoTxvw63hoS1QCRFZjCVKiXIAcGKj79mQgJ11+LLX/BxwX6MdCXQN92K7N6Kc1qiVaHQE/ibx7JB9wA/D7uHAUDiN3MhgMRyArWlwqbluAbsskf5qyq0hb0OgVlwe4tu85sPcjFZd1CVgN/l8htf8IrYrNRCohwexAK8oX3OxxTVT7wg8FdghctyPbYEP1iFQF04zNzBYQxpge+Cz9bxPzQJ2qYb+wWu+NyTaCzSKW2q+32v+gttDWRP1jMDTiOfpXYUllg4EmuFOrJ5JiS2xDPI1UZOAXTWgT3vNt4f8vIFmcRq63Wv+jCtQMyS1jsCnEM/E8haWZjO3qOrDqrp/u/sRAGwSIFqzbjjwj7W8cEgBuwQWftDFfxagMvpngLmqerNbmAm0CVci4ude87GquvNQr61lBP6cd90SrCJ6ERiO7d/7o6pe0KoY1UBDPI5lJS3Rg2mvKlUF7J4Gj/Ga7yjgtNk2wNXAC6r6+XZ3phtxmvqF1/wpl/2nIkONwFOI1x7+E/B0/d3LDXsBvwz+uG08hRWqLLEZySl4B6goYLdN6ASv+b8LOPomEfxxG3Be+F6v+cRqq3PVRuCjie9xWwM82nj3ckfwx+3hYeLzwqNITqoNVBfw8d7xg10aqB78cYa46kd+bM3kStcnCtjVRNgn2gQ81Gznck7wx9kxE9NciYluOreMSiOwr/g/iMjbiVd2H8Efp4wr3+XvaPcdAZAgYJeYz/ccIVwyTvDH6ePf8Y9x2oyRNALvD4yNHPdhKVED5QR/nB5PY7XoSmwD7OtflCRgf9n4/0I61CEJ/rjFuCSB/sBZNhsRE7DL4XqEd01Rlo2zIPjj1uJrb5JvI/wReCIwOnK8GpiXQseKTPDHrWMutv5QYix2txvAF7Bf42BOsA8NE/xxkzjtzfWaYxr1BezvNvbTxQfqJ/jj5njWO45pdEDALuqnN3JuE5asJNAagj9ujGeJL2rs4YpmAvER+EDiyakXplkeqUsJ/rhOXMXP16JNRFKaRQU80XtteHhLj+CP68PX4sB8cE9So+Pl1LoTKBH8cW34WowL2BUlHB+5QIE/pt+vgCP44+rMJ+6DJ7h49YEReE/io/Ebwf9mTvDHFRCR1dhO+BLDcOWLS6Lt9V7j1/gKZEfwx8ks9I4nwKCAd/dOLkq9O4GhCP44jp84vRcqj8BBwJ1D8MeGr8legB5Xn8CPdg9lAjqL4I/jOSMAxquq9ADbAtFfyJpQWbNj6Vp/7BKoR3PxbQmM7QHGedcuy6xXgUbpVn+83DselyRg/6JA59Jt/tjX5g5BwPmnm/xx4gjs5576S0adCbSWbvDHK7zj7XqI78AAy7weyC9F9serveNRSQIOS8jFoIj+2Bfw6CDgYlM0f+xrc3QPVnC52kWB/FMUf+yPwCN7sBysUT7IqDOB7Mm7P97gHW+eJOCwC7n45NUff+gdb5YkYP+iQDHJoz9OFPBwrzGMwN1FnvxxooADgRLvt7sD9dJD+Yjrj8iBYrMSmA7sLyL3tbszQ1Bmd4djw/Lm3kX+016gePQDtwAXi8if292ZGqko4ChhBC4+jwDfFpEX292ROqlJwBVLGgVyz0Lg3BxYhUr4MyUbeihfeRtFoGjkyedWoyzsYTgJ68sZdSaQPnn0udVIFHBZhE9GnQmkS159bjV8bb4XBFw88u5zq+Hb27XDMX8UZfuMOhNoLSuBa4AfugIpRWQH7/id4ZTvM9oxo84EWkPRfG41fG0uTxKwr/JA51JEn1sNX5uJAg4jcOdTZJ9bjbId9D3Au8SD2EdFaxAEOoqizOfWjapuC4yINL0PvNcjIgos9a7vzapjgZroB34C7C0i1xT4Ia0aE7zjJSIyUPUwMfNfoCN4BDhIRL7eBQ9p1ej1jhfBYODOYu+kr/ZA9nSrz63EeO94CQwK2B+B90y9O4FKdMN8biPs5R0vhkEBvwJsxGoPAOyqqqNCnYxM6ab53LpQ1dHAzpGmjcCr4DK0i8h64jZCgH0y6l8g+Nyh2Jd4Ec7XnWZjlYkq1uIKpMZCYIqIHNdFixGN4GvxpdIX1QScx8QXeaFr53Mb5EDveECr0e1Dz2PF5EpD9d6qOsbVqg20huBz60RVxxCvoqUkjcAishJ4PXKhAB9Pu4NdRPC5jXEIcf/7SrSGi58XYm7CiwPNEXxuc/ganBM98AU8xzs+TFXDLuXGCD63SZz2fAHHBllfwAuI79AYSbAR9RLiFlrHwcTT/67CKzkbE7CIbASe8t7kk6l0rZgEn9tajvaOZ4nIpmhDUm60Wd7xEarqJ5QIxAk+t8W4bJmHec2+NhMF/DwWI1xiBHB467pWKILPTY8jga0jx+8SmT4rUSZgFx/sK/2ElnYt/wSfmz7HecdPOG3GqJRedaZ3fKCq7tSSbuWf4HNTRlV3BA7wmh9KujZRwCKyBJuRGGgCjm9J7/JL8LnZMZn44sV8EfF3DQGVR2AoH4VPUNUtm+1ZDgk+N0NUdQvKLauvxQGqCfgJ4nnTRgHHNt613BF8bns4jngGnjUkzD6UqChgEfkA+I3XPFVVu6EsQfC5bcBp67Ne831Oi4kMJcb7iecP3hE4orHu5YLgc9vLJCA6WbAB02BFqgpYRN4FHveap6mqJF2fY4LPbTNu9D3Fa340GnmWRC124G4guny3G+VLfHkl+NzO4Rhg18jxRuBXQ71oSAGLyJvAY17zNFUdlnB5nngAOCD43PbjRt8ves2/E5E/DfXaWh/I7iJejuuj5HxeWEROFBF/G1WgPZwI7BI57gd+XssLaxKwiLwN/NZrPlVVRyRdHwjUiqqOBKZ5zQ+LyLJaXl/PlNidwPrI8RjgS3W8PhBIYhrxed/12B2/JmoWsIi8gz3QRTlJVXdJuj4QGApV3Q34W6/5F272qybqXZT4FfF8wsOBbxVwWi2QMk4z/0x8Z/wy4N563qcuAbtpplu95n0I4ZaB+jmR8oQlP613KrPuZWERmQX83ms+XVW3q/e9At2Jqm4PnOY1zxaR2fW+V6NxDTcCfZHjEQQrEaiBiHWI7rZYB/x7I+/XkICdyb7daz4ImNLI+wW6ipOBQ72220TkL428WTORZfcDL3htp6tqbxPvGSgwqro78E9e8zxsVbQhGhaw25/0r8DaSPPmwPldGvgeqIKqbgWcD0R3uK/BEnmX7XWrlaZie92wf4PXvBtwbvDDgRJOC+cQXy4G+HGj1qFE08HpIvIUFgAe5QjKA5MD3ctUyhPkzBSRJ5t941btrriJeGZLgDNU1c/rGugyVPUgyn3vq8DNrXj/lgjYbfn4PvG8asOA74aHuu7FLRVPZ7D2CpjvvapVsdct298mIiuAHxAPft8auERVt2nV9wnkA1dZ83vEq2sqcJ2I+OWNG6alGzRF5DnKl5rHAZe6p9BAF6CqWwOXUV6c+6ci8mwrv1fLdxiLyK8Bf1/ZnsCMML1WfFxeh0uBv/JOPSgidQXq1EJaW+R/Avjr2hOBi13WwUABcQmpLwQ+5p2agz3ot5xUBOxyuF5HPD0VWLLsC0K61uLh/qYXUb5MPB+42uWebjmpLja4LUdXAHt4p54HZpSK1QXyjbMNF2PxMFEWAReKyNryV7WG1FfLXJnQq7EVuigvAZeLyLq0+xBID/dccwnltdzeBKYPldehWVJPEyUiq7H/Tj+74H7AFWGKLb+4qbJrKBfvUuCitMULGYzAJdzu0xmUVx1/BxuJ/ZW8QAfjFim+R/lU2WvApVkVyMw04MZ54sspLyTeB1wpIvOy7E+gMdzy8HTiixRgD2yXi0hf+avSIfOIMeeZLgA+4Z3aiC2C3NtMeF0gPVxU2VQstsHPzPR74NqsH8zbEvLoUgmdCZyUcHo2FiOa2X9xYGjcwPMtksuuPQjclNZUWTXaGrOrqicDX03ox1Lsv3lx5p0KlOF2UpxPeTzvJuA/0lhhq5W2B52r6gHYL2esd+pD4A7gnmAp2oOzDFOAM4jvpACLKvuBiPj1tTOl7QIGUNVx2CqOv34OVhv3epcZKJARbuv7OZQvToDNNFzZyqiyRukIAcNAZcZvUF4fDGyW4mfAA2E0Thc36v4d9qC2dcIlM4GbOyWXcscIuISqTgLOJl7kucR84AYReSPbXnUHbm73bCzwymcNcKPbQtYxdJyAYeD29R3Ki92B5Y69D7grzFS0BrfIdAqW7ml4wiXzsJmhpjZgpkFHChhqupWtxpKrPNSO6Zsi4LLsnwCcSjzFaYl1wG10sHXrWAGXcOvtX8cq2CSxHPgvTMibKlwTiOAGh0nAl4GdK1z2DPCjThx1o3S8gEs4b/wVbItSEkuxxMizOnW0aDduAWkSZhd2rXDZMmxu9+nMOtYEuREwDET8n4jd8pJsBdiIfC82Iod4YwaCzY8CvkD5YkSJ9Vj+57s7ZYahFnIl4BLOVkwDPk3yQwfYU/ODmJDfzqpvnYSq7oQVzp5MsscFeyh+GHsorjkzeqeQSwGXUNUdsTodn6JybLNiO0BmYjloczO6NIKbTz8SqyK1P5X/xhuB32HCbfuCRKPkWsAlXJ2OqZiQq+23W4cFC80C5opIf5Vrc4OzCAdhNuFwKtsrsCX6R7El+iHrsHU6hRBwCbe74yTMJ1e6ZZbow56052JiTn33QCtR1bHAwcAh2EbKoUqercFS4t6Xt5+1GoUScAm3yfAo7Dbq12FIfAmWr+t5bLXvZbcVqmNQ1THYCtm+2Bae3ant7zcfeAh4slrV97xSSAFHccujx2P1nbet9WXAW1j1+iVY4sIlWT3kuHoj44EJQC+WGKaecmbvAk9gGSALvexeeAGXcJP3+2Ej8yTKwzdroQ+bJ12BTdetwFYE10Q+r8PiZPtL03guGHw49qC5NWZvRkc+74DNb5c+GqmAugrz9rOAl7plLrxrBBzFTejvhXnHQ7C8FXn7XSjwCvCs+1jYjSuRefujpYLzl/tj/nIi5i/9PV/tZiNmZV7Gcmq8mNXO304mCDgBd8vfA/OfvZgXHQ9klZxwPbAY89+L3NevhpXFcoKA68BN05V86g7Adgz62NGYd90KG72Hua8B3sdG0H5MnH2YZy755ncY9NTLijTNlTb/Dz+sKh/f1rAbAAAAAElFTkSuQmCC";
	var _play_media_btn = null;
	var _play_media_bkg = null;
	var _canvas_container_z_index = 0;
	var _media_data_init = false;
	var _init_media = null;

	var SECONDARY_LOAD_TYPES_DISABLED = ["LAMP"];
	var ADD_PHY_TYPES = ["MESH", "CAMERA", "EMPTY"];

	var B4W_HEADER_OFFSET = 12;

	var FORCING_BSDF_TYPES = ["BSDF_GLOSSY", "BSDF_DIFFUSE", "BSDF_TRANSPARENT"];

	var _canvas = null;


	/**
	 * Check if primary scene is loaded (detect last loading stage)
	 */
	exports.is_primary_loaded = function(data_id) {
	    return m_loader.is_primary_loaded(data_id);
	};

	/**
	 * Executed every frame
	 */
	exports.update = function() {
	    m_loader.update_scheduler(_bpy_data_array);
	};

	function free_load_data(bpy_data, thread) {

	    //m_assets.cleanup();
	    _bpy_data_array[thread.id] = null;
	    _all_objects_cache[thread.id] = null;
	}

	function print_image_info(image_data, image_path, show_path_warning, comp_method) {

	    var w, h;

	    if (image_data instanceof ArrayBuffer) {
	        var dds_wh = m_texcomp.get_width_height(image_data, comp_method);
	        w = dds_wh.width;
	        h = dds_wh.height;
	    } else {
	        w = image_data.width;
	        h = image_data.height;
	    }

	    var color;
	    if (w > 2048 || h > 2048)
	        color = "a00";
	    else if (w > 1024 || h > 1024)
	        color = "aa0";
	    else
	        color = "0a0";
	    m_print.log("%cLOAD IMAGE " + w + "x" + h, "color: #" + color, image_path);

	    if (image_path.indexOf(_debug_resources_root) == -1 && show_path_warning)
	        m_print.warn("image", image_path, "is not from app root.");
	}

	function print_video_info(video, image_path, show_path_warning, type) {

	    if (type == m_assets.AT_VIDEO_ELEMENT) {
	        var w = video.videoWidth;
	        var h = video.videoHeight;
	    } else {
	        var w = video.images[0].width;
	        var h = video.images[0].height;
	    }

	    var color;
	    if (w > 2048 || h > 2048)
	        color = "a00";
	    else if (w > 1024 || h > 1024)
	        color = "aa0";
	    else
	        color = "0a0";
	    m_print.log("%cLOAD VIDEO " + w + "x" + h, "color: #" + color, image_path);

	    if (image_path.indexOf(_debug_resources_root) == -1 && show_path_warning)
	        m_print.warn("video", image_path, "is not from app root.");
	}


	/**
	 * Load main json
	 */
	function load_main(bpy_data, thread, stage, cb_param, cb_finish,
	        cb_set_rate) {

	    var main_path = thread.filepath;
	    if (!main_path)
	        m_util.panic("Nothing requested");

	    var asset_cb = function(loaded_bpy_data, id, type, url) {

	        // Failed to load scene main file
	        if (!loaded_bpy_data) {
	            if (type == m_assets.AT_JSON_ZIP) {
	                m_print.warn("Compressed file ", url, 
	                        "not found or invalid. Trying to load non-compressed", 
	                        main_path);
	                m_assets.enqueue([{id:main_path, type:m_assets.AT_JSON, 
	                        url:main_path, is_fetch:thread.is_preloading}], 
	                        asset_cb, null, progress_cb);
	                return;
	            } else {
	                m_loader.abort_thread(thread);
	                return;
	            }
	        }

	        m_print.log("%cLOAD METADATA", "color: #616", url);

	        check_format_version(loaded_bpy_data);
	        
	        // copy-link its properties to initial bpy_data
	        for (var prop in loaded_bpy_data)
	            bpy_data[prop] = loaded_bpy_data[prop];

	        prepare_thread_bpy(thread, bpy_data);
	        
	        show_export_errors(bpy_data, thread);
	        show_export_warnings(bpy_data, thread);

	        if (thread.is_preloading)
	            setup_dds_loading(bpy_data);

	        cb_finish(thread, stage);
	    };

	    var progress_cb = function(rate) {
	        cb_set_rate(thread, stage, rate);
	    };

	    if (cfg_def.assets_gzip_available) {
	        var asset_path = main_path + ".gz";
	        var asset_type = m_assets.AT_JSON_ZIP;
	    } else {
	        var asset_path = main_path;
	        var asset_type = m_assets.AT_JSON;
	    }

	    m_assets.enqueue([{id:asset_path, type:asset_type, url:asset_path,
	            is_fetch:thread.is_preloading}], asset_cb, null,
	            progress_cb);
	}

	function prepare_thread_bpy(thread, bpy_data) {
	    // Set primary bpy data
	    if (thread.is_primary)
	        _primary_scene = m_scenes.find_main_scene(bpy_data["scenes"]);

	    var bin_name = bpy_data["binaries"][0]["binfile"];
	    if (bin_name)
	        thread.binary_name = bin_name;
	    else {
	        m_loader.skip_stage_by_name(thread, "load_binaries");
	        m_loader.skip_stage_by_name(thread, "prepare_bindata");
	    }

	    if (!cfg_def.is_mobile_device)
	        m_loader.skip_stage_by_name(thread, "mobile_media_start");

	    if (!cfg_def.antialiasing || !cfg_def.smaa)
	        m_loader.skip_stage_by_name(thread, "load_smaa_textures");
	}

	function show_export_warnings(bpy_data, thread) {
	    if (bpy_data["b4w_export_warnings"])
	        for (var i = 0; i < bpy_data["b4w_export_warnings"].length; i++) {
	            var warn_data = bpy_data["b4w_export_warnings"][i];
	            if (thread.is_primary && warn_data["type"] == "PRIMARY" || warn_data["type"] == "ALL")
	                m_print.export_warn(warn_data["text"] +
	                    " See more details in https://www.blend4web.com/doc/en/addon.html#other-messages");
	        }
	}

	function show_export_errors(bpy_data, thread) {
	    if (bpy_data["b4w_export_errors"])
	        for (var i = 0; i < bpy_data["b4w_export_errors"].length; i++) {
	            var err_data = bpy_data["b4w_export_errors"][i];
	            if (thread.is_primary && err_data["type"] == "PRIMARY" || err_data["type"] == "ALL")
	                m_print.export_error(err_data["text"] +
	                    " See more details in https://www.blend4web.com/doc/en/addon.html#non-critical-export-errors");
	        }
	}

	/**
	 * Load binary file
	 */
	function load_binaries(bpy_data, thread, stage, cb_param, cb_finish,
	        cb_set_rate) {
	    var binary_path = dirname(thread.filepath) + thread.binary_name;

	    if (!binary_path)
	        m_util.panic("Binary data is missing");

	    var binary_cb = function(bin_data, id, type, url) {

	        // Failed to load scene binary file
	        if (!bin_data) {
	            if (type == m_assets.AT_ARRAYBUFFER_ZIP) {
	                m_print.warn("Compressed file ", url, 
	                        "not found or invalid. Trying to load non-compressed", 
	                        binary_path);
	                m_assets.enqueue([{id:binary_path, type:m_assets.AT_ARRAYBUFFER, 
	                        url:binary_path, is_fetch:thread.is_preloading}], 
	                        binary_cb, null, progress_cb);
	                return;
	            } else {
	                m_loader.abort_thread(thread);
	                return;
	            }
	        }

	        m_print.log("%cLOAD BINARY", "color: #616", url);

	        bpy_data["bin_data"] = bin_data;
	        check_bin_data_version(bin_data, bpy_data);
	        cb_finish(thread, stage);
	    };

	    var progress_cb = function(rate) {
	        cb_set_rate(thread, stage, rate);
	    };

	    if (cfg_def.assets_gzip_available) {
	        var asset_path = binary_path + ".gz";
	        var asset_type = m_assets.AT_ARRAYBUFFER_ZIP;
	    } else {
	        var asset_path = binary_path;
	        var asset_type = m_assets.AT_ARRAYBUFFER;
	    }

	    m_assets.enqueue([{id:asset_path, type:asset_type, url:asset_path,
	            is_fetch:thread.is_preloading}], binary_cb, null, progress_cb);
	}

	function wait_for_shaders(bpy_data, thread, stage, cb_param, cb_finish,
	        cb_set_rate) {

	    if (m_shaders.check_shaders_loaded())
	        cb_finish(thread, stage);
	}

	function check_format_version(loaded_bpy_data) {

	    var ver_loaded = m_util.str_to_version(loaded_bpy_data["b4w_format_version"]);
	    var cmp = m_util.version_cmp(ver_loaded, cfg_def.min_format_version);

	    switch (cmp) {
	    case -1:
	        if (ver_loaded[0] < cfg_def.min_format_version[0])
	            m_util.panic("JSON version is too old relative to B4W engine: " 
	                    + m_util.version_to_str(ver_loaded) + ", required: " 
	                    + m_util.version_to_str(cfg_def.min_format_version) + ". "
	                    + "Reexport scene with the latest B4W addon to fix it.");
	        else
	            m_print.warn("JSON version is a bit old relative to B4W engine: "
	                    + m_util.version_to_str(ver_loaded) + ", required: " 
	                    + m_util.version_to_str(cfg_def.min_format_version) 
	                    + ". Some compatibility issues can occur. "
	                    + "Reexport scene with the latest B4W addon to fix it.");
	        break;
	    case 1:
	        if (ver_loaded[0] > cfg_def.min_format_version[0])
	            m_util.panic("B4W engine version is too old relative to JSON. " 
	                    + "Can't load the scene. Update your " 
	                    + "engine version to fix it.");
	        else
	            m_print.error("B4W engine version is a bit old relative to JSON. " 
	                    + "Some compatibility issues can occur. Update " 
	                    + "your engine version to fix it.");
	        break;
	    }
	    
	    cfg_def.loaded_data_version = ver_loaded;
	}

	/**
	 * Prepare bin data after main libs loaded
	 */
	function prepare_bindata(bpy_data, thread, stage, cb_param, cb_finish,
	        cb_set_rate) {

	    var bin_data = bpy_data["bin_data"];
	    var bin_offsets = bpy_data["binaries"][0];
	    var objects = bpy_data["objects"];
	    var meshes = bpy_data["meshes"];
	    var actions = bpy_data["actions"];

	    var is_le = m_util.check_endians();

	    prepare_bindata_submeshes(bin_data, bin_offsets, meshes, is_le, B4W_HEADER_OFFSET);
	    prepare_bindata_psystems(bin_data, bin_offsets, objects, is_le, B4W_HEADER_OFFSET);
	    prepare_bindata_actions(bin_data, bin_offsets, actions, is_le, B4W_HEADER_OFFSET);

	    cb_finish(thread, stage);
	}

	function check_bin_data_version(bin_data, bpy_data) {

	    var headers = get_header(bin_data);
	    var ver_loaded = m_util.str_to_version(bpy_data["b4w_format_version"]);
	    if (headers[0] != ver_loaded[0])
	        m_util.panic("BIN version does not match to JSON version: " 
	                + m_util.version_to_str(headers) + ", required: " 
	                + m_util.version_to_str(cfg_def.min_format_version)
	                + ". Couldn't load the scene. "
	                + "Reexport scene to fix it.");
	    if (headers[1] != ver_loaded[1])
	        m_print.warn("BIN version does not match to JSON version: " + 
	                + m_util.version_to_str(headers) + ", required: " 
	                + m_util.version_to_str(cfg_def.min_format_version) 
	                + ". Some compatibility issues can occur. "
	                + "Reexport scene to fix it.");
	}

	function get_header(bin_data) {
	    var major_version = new Uint32Array(bin_data, 4, 1)[0];
	    var minor_version = new Uint32Array(bin_data, 8, 1)[0];
	    return [major_version, minor_version];
	}

	function prepare_bindata_submeshes(bin_data, bin_offsets, meshes, is_le, b4w_offset) {
	    var int_props = ["indices"];
	    var float_props = ["position", "texcoord", "texcoord2", "shade_tangs"];
	    var short_props = ["normal", "tangent"];
	    var ushort_props = ["group"];
	    var uchar_props = ["color"];

	    for (var i = 0; i < meshes.length; i++) {
	        var submeshes = meshes[i]["submeshes"];

	        for (var j = 0; j < submeshes.length; j++) {

	            for (var prop_name in submeshes[j]) {
	                var length = submeshes[j][prop_name][1];

	                if (int_props.indexOf(prop_name) != -1) {
	                    var offset = submeshes[j][prop_name][0] * m_util.INT_SIZE
	                            + bin_offsets["int"] + b4w_offset;
	                    submeshes[j][prop_name] = extract_bindata_uint(bin_data,
	                            offset, length, is_le);
	                } else if (float_props.indexOf(prop_name) != -1) {
	                    var offset = submeshes[j][prop_name][0] * m_util.FLOAT_SIZE
	                            + bin_offsets["float"] + b4w_offset;
	                    submeshes[j][prop_name] = extract_bindata_float(bin_data,
	                            offset, length, is_le);
	                } else if (short_props.indexOf(prop_name) != -1) {
	                    var offset = submeshes[j][prop_name][0] * m_util.SHORT_SIZE
	                            + bin_offsets["short"] + b4w_offset;
	                    submeshes[j][prop_name] = extract_bindata_short(bin_data,
	                            offset, length);
	                } else if (ushort_props.indexOf(prop_name) != -1) {
	                    var offset = submeshes[j][prop_name][0] * m_util.SHORT_SIZE
	                            + bin_offsets["ushort"] + b4w_offset;
	                    submeshes[j][prop_name] = extract_bindata_ushort(bin_data,
	                            offset, length);
	                } else if (uchar_props.indexOf(prop_name) != -1) {
	                    var offset = submeshes[j][prop_name][0] * m_util.BYTE_SIZE
	                            + bin_offsets["uchar"] + b4w_offset;
	                    submeshes[j][prop_name] = extract_bindata_uchar(bin_data,
	                            offset, length);
	                }
	            }

	            setup_tbn(meshes[i], submeshes[j]);
	            // not needed after calculating tbn data
	            delete submeshes[j]["normal"];
	            delete submeshes[j]["tangent"];

	            // NOTE: temporary backward compatibility
	            if ("texcoord2" in submeshes[j]) {
	                var texcoord_combined = new Float32Array(
	                        submeshes[j]["texcoord"].length + submeshes[j]["texcoord2"].length);
	                texcoord_combined.set(submeshes[j]["texcoord"]);
	                texcoord_combined.set(submeshes[j]["texcoord2"], submeshes[j]["texcoord"].length);
	                submeshes[j]["texcoord"] = texcoord_combined;
	                delete submeshes[j]["texcoord2"];
	            }
	        }
	    }
	}

	function setup_tbn(mesh, submesh) {
	    if (mesh["b4w_shape_keys"].length) {
	        var base_length = submesh["base_length"];
	        var frames = submesh["normal"].length / base_length / NORMAL_NUM_COMP;
	        var tbn_count = submesh["normal"].length / NORMAL_NUM_COMP;

	        submesh["tbn"] = m_tbn.from_norm_tan(
	                submesh["normal"].subarray(0, base_length * NORMAL_NUM_COMP),
	                submesh["tangent"].subarray(0, base_length * TANGENT_NUM_COMP),
	                m_tbn.create(tbn_count)
	        );
	        for (var i1 = 1; i1 < frames; i1++) {
	            var frame_offset = i1 * base_length;

	            for (var i2 = 0; i2 < base_length; i2++) {

	                var normal1 = submesh["normal"].subarray(
	                        i2 * NORMAL_NUM_COMP,
	                        (i2 + 1) * NORMAL_NUM_COMP);
	                var normal2 = m_vec3.add(
	                        submesh["normal"].subarray(
	                                (frame_offset + i2) * NORMAL_NUM_COMP,
	                                (frame_offset + i2 + 1) * NORMAL_NUM_COMP),
	                        normal1,
	                        _vec3_tmp);

	                var delta_tmp = m_tbn.identity(_tbn_tmp);
	                if (submesh["tangent"].length) {
	                    var tangent1 = submesh["tangent"].subarray(
	                            i2 * TANGENT_NUM_COMP,
	                            (i2 + 1) * TANGENT_NUM_COMP);
	                    var tangent2 = m_vec4.add(
	                            submesh["tangent"].subarray(
	                                    (frame_offset + i2) * TANGENT_NUM_COMP,
	                                    (frame_offset + i2 + 1) * TANGENT_NUM_COMP),
	                            tangent1,
	                            _vec4_tmp);

	                    var tbn1 = m_tbn.from_norm_tan(normal1, tangent1);
	                    var tbn2 = m_tbn.from_norm_tan(normal2, tangent2);

	                    m_tbn.multiply_tbn_inv(tbn2, tbn1, delta_tmp);
	                } else {
	                    var quat = m_quat.rotationTo(normal1, normal2, _quat_tmp);
	                    m_tbn.set_quat(delta_tmp, quat, 0);
	                }

	                m_tbn.set_item(submesh["tbn"], delta_tmp, frame_offset + i2);
	            }
	        }
	    } else {
	        submesh["tbn"] = m_tbn.from_norm_tan(
	                submesh["normal"], submesh["tangent"]
	        );
	    }
	}

	function prepare_bindata_psystems(bin_data, bin_offsets, bpy_objects, is_le, b4w_offset) {
	    for (var i = 0; i < bpy_objects.length; i++) {
	        var psystems = bpy_objects[i]["particle_systems"];

	        for (var j = 0; j < psystems.length; j++) {
	            var psys = psystems[j];
	            var offset = psys["transforms"][0] * m_util.FLOAT_SIZE
	                    + bin_offsets["float"] + b4w_offset;
	            var length = psys["transforms"][1];
	            psys["transforms"] = extract_bindata_float(bin_data,
	                    offset, length, is_le);
	        }
	    }
	}

	// make points for every frame from start to end
	function prepare_bindata_actions(bin_data, bin_offsets, actions, is_le, b4w_offset) {
	    for (var i = 0; i < actions.length; i++) {
	        var action = actions[i];
	        var fcurves = action["fcurves"];

	        var frame_range = action["frame_range"]; // same for all fcurves
	        var start = frame_range[0]; // integer
	        var end   = frame_range[1]; // integer

	        var arr_length = m_anim.get_approx_curve_length(start, end);
	        var bflags = null;

	        if (arr_length < 0)
	            arr_length = 0;

	        // HACK: do not process euler rotation if quaternion rotation exists
	        // currently applied in Blender b4w addon; temporary backward compatibility
	        var has_euler_rot = false;
	        var has_quat_rot = false;
	        for (var data_path in fcurves) {
	            has_euler_rot |= data_path.indexOf("rotation_euler") > -1;
	            has_quat_rot |= data_path.indexOf("rotation_quaternion") > -1;
	        }

	        var paths_to_rename = [];
	        for (var data_path in fcurves) {
	            // HACK: see above
	            if (has_euler_rot && has_quat_rot
	                    && data_path.indexOf("rotation_euler") > -1) {
	                delete fcurves[data_path];
	                continue;
	            }

	            var channels = fcurves[data_path];
	            for (var array_index in channels) {
	                var fcurve = channels[array_index];
	                var offset = bin_offsets["float"]
	                        + fcurve["bin_data_pos"][0] * m_util.FLOAT_SIZE + b4w_offset;
	                var fcurve_bin_data = extract_bindata_float(bin_data, offset,
	                        fcurve["bin_data_pos"][1], is_le);

	                var points = new Float32Array(arr_length);
	                // blend flags are common for all action fcurves
	                // if some channel is blended all transform will be blended
	                if (bflags === null)
	                    bflags = new Int8Array(arr_length);

	                m_anim.approximate_curve(fcurve, fcurve_bin_data,
	                        points, bflags, start, end);
	                fcurve._pierced_points = points;
	            }

	            if (data_path.indexOf("rotation_euler") > -1) {
	                m_anim.fcurve_replace_euler_by_quat(fcurves[data_path]);
	                paths_to_rename.push(data_path);
	            }
	        }
	        
	        for (var j = 0; j < paths_to_rename.length; j++) {
	            var path_old = paths_to_rename[j];
	            var path_new = path_old.replace("euler", "quaternion");
	            fcurves[path_new] = fcurves[path_old];
	            delete fcurves[path_old];
	        }

	        action._bflags = bflags;
	    }
	}

	function extract_bindata_float(bin_data, offset, length, is_le) {
	    if (is_le)
	        var arr = new Float32Array(bin_data, offset, length);
	    else {
	        var arr = new Float32Array(length);
	        var dataview = new DataView(bin_data);
	        for (var i = 0; i < length; i++)
	            arr[i] = dataview.getFloat32(offset + i * m_util.FLOAT_SIZE, true);
	    }
	    return arr;
	}

	function extract_bindata_uint(bin_data, offset, length, is_le) {
	    if (is_le)
	        var arr = new Uint32Array(bin_data, offset, length);
	    else {
	        var arr = new Uint32Array(length);
	        var dataview = new DataView(bin_data);
	        for (var i = 0; i < length; i++)
	            arr[i] = dataview.getUint32(offset + i * m_util.INT_SIZE, true);
	    }
	    return arr;
	}

	/**
	 * Extract float data packed into shorts (floats in range [-1; 1])
	 */
	function extract_bindata_short(bin_data, offset, length) {

	    var arr = new Float32Array(length);
	    var dataview = new DataView(bin_data);
	    for (var i = 0; i < length; i++)
	        arr[i] = dataview.getInt16(offset + i * m_util.SHORT_SIZE, true) / 32767;
	    return arr;
	}

	/**
	 * Extract float data packed into unsigned shorts (floats in range [0; 1])
	 */
	function extract_bindata_ushort(bin_data, offset, length) {
	    var arr = new Float32Array(length);
	    var dataview = new DataView(bin_data);
	    for (var i = 0; i < length; i++)
	        arr[i] = dataview.getUint16(offset + i * m_util.SHORT_SIZE, true) / 65535;
	    return arr;
	}

	/**
	 * Extract float data packed into unsigned char (floats in range [0; 1])
	 */
	function extract_bindata_uchar(bin_data, offset, length) {
	    var arr = new Float32Array(length);
	    var dataview = new DataView(bin_data);
	    for (var i = 0; i < length; i++)
	        arr[i] = dataview.getUint8(offset + i * m_util.BYTE_SIZE) / 255;
	    return arr;
	}

	function report_empty_submeshes(bpy_data) {

	    var already_reported = {};

	    var bpy_objects = bpy_data["objects"];

	    for (var i = 0; i < bpy_objects.length; i++) {

	        var bpy_obj = bpy_objects[i];
	        if (bpy_obj["type"] !== "MESH")
	            continue;

	        // reporting for emitters is not supported
	        if (bpy_obj["particle_systems"].length)
	            continue;

	        var mesh = bpy_obj["data"];
	        var mesh_name = mesh["name"];
	        var submeshes = mesh["submeshes"];
	        var materials = mesh["materials"];

	        for (var j = 0; j < submeshes.length; j++) {
	            if (submeshes[j]["base_length"] === 0 &&
	                    !already_reported[mesh_name]) {

	                if (materials[j])
	                    m_print.warn("material \"" + materials[j]["name"]
	                        + "\" is not assigned to any face (object \""
	                        + bpy_obj["name"] + "\").");
	                already_reported[mesh_name] = true;
	            }
	        }
	    }
	}

	function prepare_bpy_data(bpy_data, thread, stage, cb_param, cb_finish,
	        cb_set_rate) {

	    make_bpy_links(bpy_data);

	    m_reformer.check_bpy_data(bpy_data);

	    setup_dds_loading(bpy_data);
	    create_bpy_textures(bpy_data, thread);

	    report_empty_submeshes(bpy_data);

	    prepare_bpy_materials(bpy_data);
	    prepare_bpy_actions(bpy_data["actions"], thread.id);
	    prepare_bpy_lods(bpy_data);
	    prepare_bpy_scenes(bpy_data, thread);

	    prepare_bpy_logic_nodes_objects_params(bpy_data);
	    prepare_bpy_objects(bpy_data, thread);
	    prepare_bpy_worlds(bpy_data, thread);
	    prepare_bpy_node_materials(bpy_data);

	    prepare_bpy_scenes_audio(bpy_data, thread);

	    if (DEBUG_BPYDATA)
	        m_print.log("%cDEBUG BPYDATA:", "color: #a0a", bpy_data);

	    cb_finish(thread, stage);
	}

	function preload_sounds(bpy_data, thread, stage, cb_param, cb_finish,
	        cb_set_rate) {
	    var dir_path = dirname(thread.filepath);
	    var sound_assets = [];
	    var used_uuid = [];
	    for (var i = 0; i < bpy_data["speakers"].length; i++) {
	        var speaker = bpy_data["speakers"][i];
	        var uuid = speaker["sound"]["uuid"];
	        if (used_uuid.indexOf(uuid) != -1)
	            continue;
	        used_uuid.push(uuid);
	        switch(speaker["b4w_behavior"]) {
	        case "POSITIONAL":
	        case "BACKGROUND_SOUND":
	            var asset_type = m_assets.AT_AUDIOBUFFER;
	            break;
	        case "BACKGROUND_MUSIC":
	            var asset_type = m_assets.AT_AUDIO_ELEMENT;
	            break;
	        }
	        var sound_path = m_util.normpath_preserve_protocol(
	                        dir_path + speaker["sound"]["filepath"]);
	        add_sound_path(sound_assets, uuid, asset_type, sound_path,
	                thread.is_preloading);
	    }
	    var pack_cb = function() {
	        cb_finish(thread, stage);
	    };
	    if (sound_assets.length)
	        m_assets.enqueue(sound_assets, function(){}, pack_cb);
	    else
	        cb_finish(thread, stage);
	}

	function create_bpy_textures(bpy_data, thread) {
	    var dir_path = dirname(thread.filepath);
	    var bpy_textures = bpy_data["textures"];
	    var global_af = get_global_anisotropic_filtering(bpy_data, thread);
	    for (var i = 0; i < bpy_textures.length; i++) {
	        var bpy_tex = bpy_textures[i];
	        // NOTE: disable offscreen rendering for secondary loaded data
	        if ((!thread.is_primary) && (bpy_tex["b4w_source_type"] == "SCENE"))
	            bpy_tex["b4w_source_id"] = "";
	        var tex = m_tex.create_texture_bpy(bpy_tex, global_af, bpy_data["scenes"], thread.id, dir_path);
	        bpy_tex._render = tex;
	    }
	}

	function prepare_bpy_scenes(bpy_data, thread) {
	    // NOTE: save only first scene for secondary data
	    if (!thread.is_primary && bpy_data["scenes"].length > 1) {
	        bpy_data["scenes"] = [m_scenes.find_main_scene(bpy_data["scenes"])];
	        m_print.warn("loading data contains multiple scenes.",
	                "Only the first one will be loaded.");
	    }

	    if (thread.is_primary)
	        var main_scene = _primary_scene;
	    else
	        var main_scene = m_scenes.find_main_scene(bpy_data["scenes"]);

	    m_time.set_framerate(_primary_scene["fps"]);
	    if (bpy_data["scenes"].length > 1) {
	        var index_of_main_scene = bpy_data["scenes"].indexOf(_primary_scene);
	        bpy_data["scenes"].splice(index_of_main_scene, 1);
	        bpy_data["scenes"].unshift(_primary_scene);
	    }

	    for (var i = 0; i < bpy_data["scenes"].length; i++) {
	        var scene = bpy_data["scenes"][i];

	        scene._render = m_scenes.create_scene_render();
	        scene._is_main = scene == main_scene;
	        scene._is_primary_thread = thread.is_primary;

	            if (cfg_phy.enabled) {
	            if (scene["b4w_enable_physics"] == "OFF" ||
	                    scene["b4w_enable_physics"] == "AUTO" && !check_scene_physics(scene))
	                continue;

	            if (thread.is_primary ||
	                     (!m_phy.scene_has_physics(_primary_scene) &&
	                      scene == m_scenes.find_main_scene(bpy_data)))
	                m_phy.init_scene_physics(scene);
	        }
	    }
	}

	function check_scene_physics(bpy_scene) {
	    var bpy_objects = combine_scene_bpy_objects(bpy_scene, "ALL");
	    for (var i = 0; i < bpy_objects.length; i++) {
	        if (bpy_objects[i]["b4w_collision"])
	            return true;
	        var data = bpy_objects[i]["data"];
	        if (data["materials"])
	            for (var j = 0; j < data["materials"].length; j++) {
	                var mat = data["materials"][j];
	                if (mat.physics_settings.use_coll_physics)
	                    return true;
	            }
	    }
	    return false;
	}

	/**
	 * Attach scene links through combining bpy objects by scene, then cache bpy objects.
	 */
	function prepare_bpy_objects(bpy_data, thread) {
	    // process objects by scene
	    for (var i = 0; i < bpy_data["scenes"].length; i++) {
	        var bpy_scene = bpy_data["scenes"][i];
	        var scene_objs = combine_scene_bpy_objects(bpy_scene, "ALL");

	        for (var j = 0; j < scene_objs.length; j++) {
	            var bpy_obj = scene_objs[j];

	            // filter unwanted objects
	            if (m_obj.check_bpy_obj_scene_compatibility(bpy_obj, bpy_scene, bpy_data)) {
	                if (!bpy_obj._scenes)
	                    bpy_obj._scenes = [];
	                // NOTE: attach scene data from the primary scene for dynamically loaded objects
	                bpy_obj._scenes.push(thread.is_primary ? bpy_scene : _primary_scene);
	            }
	        }
	        prepare_hair_dupli_objects(scene_objs);
	    }

	    // most (all?) duplication/clone actions should be finished prior to this moment
	    create_bpy_hierarchy_cache(bpy_data, thread);

	    var bpy_objects = get_bpy_cache(thread.id);
	    for (var i = 0; i < bpy_objects.length; i++) {
	        var bpy_obj = bpy_objects[i];

	        // NOTE: disable parenting to LAMP objects
	        if (!thread.is_primary && bpy_obj["parent"] &&
	                SECONDARY_LOAD_TYPES_DISABLED.indexOf(bpy_obj["parent"]["type"]) > -1)
	            bpy_obj["parent"] = "";

	        if (bpy_obj["type"] == "MESH") {
	            var mesh = m_reformer.apply_mesh_modifiers(bpy_obj);
	            if (mesh) {
	                bpy_data["meshes"].push(mesh);
	                bpy_obj["data"] = mesh;
	            }
	        }

	        bpy_obj._def_action_slots = m_obj.get_bpy_def_action_slots(bpy_obj, false);
	        bpy_obj._is_dynamic = m_obj.bpy_obj_is_dynamic(bpy_obj);
	    }


	    // resolve LODs dynamics: one DYNAMIC LOD makes all LOD objects DYNAMIC
	    for (var i = 0; i < bpy_objects.length; i++) {
	        var bpy_obj = bpy_objects[i];

	        var is_dynamic_lods = bpy_obj._is_dynamic;
	        for (var j = 0; j < bpy_obj["lod_levels"].length; j++) {
	            var lod_obj = bpy_obj["lod_levels"][j]["object"];
	            if (!lod_obj)
	                continue;

	            is_dynamic_lods = is_dynamic_lods || lod_obj._is_dynamic;
	        }

	        if (is_dynamic_lods) {
	            bpy_obj._is_dynamic = true;
	            for (var j = 0; j < bpy_obj["lod_levels"].length; j++) {
	                var lod_obj = bpy_obj["lod_levels"][j]["object"];
	                if (!lod_obj)
	                    continue;

	                lod_obj._is_dynamic = true;
	            }
	        }
	    }
	}

	/**
	 * Attach scene links through combining bpy worlds by scene
	 */
	function prepare_bpy_worlds(bpy_data, thread) {
	    // process world by scene
	    for (var i = 0; i < bpy_data["scenes"].length; i++) {
	        var bpy_scene = bpy_data["scenes"][i];
	        var bpy_world = bpy_scene["world"];
	        if (!bpy_world._scenes)
	            bpy_world._scenes = [];
	        bpy_world._scenes.push(thread.is_primary ? bpy_scene : _primary_scene);
	    }

	    // drop worlds without scene users
	    var removed_worlds = [];
	    for (var i = 0; i < bpy_data["worlds"].length; i++) {
	        var bpy_world = bpy_data["worlds"][i];
	        if (bpy_world._scenes) {
	            bpy_world._def_action_slots = m_obj.get_bpy_def_action_slots(bpy_world, true);
	            bpy_world._is_dynamic = m_obj.bpy_obj_is_dynamic(bpy_world);
	        } else
	            removed_worlds.push(bpy_world);            
	    }

	    for (var i = 0; i < removed_worlds.length; i++) {
	        var bpy_world = removed_worlds[i];
	        var ind = bpy_data["worlds"].indexOf(bpy_world);
	        bpy_data["worlds"].splice(ind,1);
	    }
	}

	function prepare_bpy_node_materials(bpy_data) {
	    var node_groups = bpy_data["node_groups"];
	    var materials   = bpy_data["materials"];

	    // node gorups
	    for (var i = 0; i < node_groups.length; i++) {
	        var node_group = node_groups[i];

	        var node_tree = node_group["node_tree"];
	        if (!node_tree)
	            continue;

	        var bsdf_types = [];
	        get_bpy_bsdf_types(node_tree, bsdf_types, true);
	        node_tree._bsdf_types = bsdf_types;
	    }

	    // node materials
	    for (var i = 0; i < materials.length; i++) {
	        var material = materials[i];

	        var node_tree = material.node_tree;
	        if (!node_tree)
	            continue;

	        var bsdf_types = [];
	        get_bpy_bsdf_types(node_tree, bsdf_types, false);
	        node_tree._bsdf_types = bsdf_types;
	    }
	}

	function get_bpy_bsdf_types(node_tree, bsdf_types, check_groups) {
	    var nodes = node_tree["nodes"];

	    // searching for specified bsdf nodes
	    // to force props in m_objects.update_object
	    for (var i = 0; i < nodes.length; i++) {
	        var node = nodes[i];
	        var node_type = node["type"];

	        if (node_type == "GROUP" && node["node_group"]) {
	            var nested_group_node_tree = node["node_group"]["node_tree"];
	            if (!nested_group_node_tree)
	                continue;

	            // nested groups recursive check
	            if (check_groups)
	                get_bpy_bsdf_types(nested_group_node_tree, bsdf_types, true);
	            else {
	                var nested_bsdf_types = nested_group_node_tree._bsdf_types;
	                for (var j = 0; j < nested_bsdf_types.length; j++) {
	                    var nested_bsdf = nested_bsdf_types[j];
	                    if (bsdf_types.indexOf(nested_bsdf) == -1)
	                        bsdf_types.push(nested_bsdf);
	                }
	            }

	        } else if (FORCING_BSDF_TYPES.indexOf(node_type) != -1 && bsdf_types.indexOf(node_type) == -1)
	            bsdf_types.push(node_type);
	    }
	}

	/**
	 * Combine all bpy objects from the scene.
	 */
	function combine_scene_bpy_objects(bpy_scene, type) {
	    if (!type)
	        type = "ALL";

	    var scene_objs_arr = [];

	    // HACK: camera can be linked from another scene or group so append it here
	    if (bpy_scene["objects"].indexOf(bpy_scene["camera"]) == -1)
	        bpy_scene["objects"].push(bpy_scene["camera"]);

	    combine_scene_bpy_objects_iter(bpy_scene["objects"], type, scene_objs_arr);
	    return scene_objs_arr;
	}

	function combine_scene_bpy_objects_iter(bpy_objects, type, dest) {
	    // search in dupli groups
	    for (var i = 0; i < bpy_objects.length; i++) {
	        var bpy_obj = bpy_objects[i];

	        if (type == "ALL" || type == bpy_obj["type"])
	            dest.push(bpy_obj);

	        var dupli_group = bpy_obj["dupli_group"];
	        if (dupli_group) {
	            var dg_objects = dupli_group["objects"];
	            combine_scene_bpy_objects_iter(dg_objects, type, dest);
	        }
	    }
	}

	/**
	 * Make bpy_obj->bpy_scene links for HAIR dupli objects which aren't reachable 
	 * from any scene.
	 */
	function prepare_hair_dupli_objects(bpy_objects) {
	    for (var i = 0; i < bpy_objects.length; i++) {
	        var bpy_obj = bpy_objects[i];
	        if (bpy_obj._scenes && bpy_obj.type != "WORLD") {
	            var psystems = bpy_obj["particle_systems"];
	            for (var j = 0; j < psystems.length; j++) {
	                var pset = psystems[j]["settings"];

	                if (pset["type"] != "HAIR")
	                    continue;

	                if (pset["render_type"] == "OBJECT") {
	                    var dg_obj = pset["dupli_object"];

	                    // dg_obj isn't presented on any scene or already processed 
	                    // as hair dupli object, don't filter unwanted objects (needless)
	                    if (!dg_obj._scenes)
	                        dg_obj._scenes = bpy_obj._scenes.slice();

	                } else if (pset["render_type"] == "GROUP") {
	                    var dg = pset["dupli_group"];
	                    for (var k = 0; k < dg["objects"].length; k++) {
	                        var dg_obj = dg["objects"][k];
	                        if (!dg_obj._scenes)
	                            dg_obj._scenes = bpy_obj._scenes.slice();
	                    }
	                }
	            }
	        }
	    }
	}

	function prepare_bpy_logic_nodes_objects_params(bpy_data) {
	    for (var i = 0; i < bpy_data["scenes"].length; i++) {
	        var bpy_scene = bpy_data["scenes"][i];

	        if (bpy_scene["b4w_use_logic_editor"]) {
	            var scene_objs = combine_scene_bpy_objects(bpy_scene, "ALL");
	            var scene_world = bpy_scene["world"];

	            m_reformer.assign_logic_nodes_object_params(scene_objs, scene_world, bpy_scene);
	        }
	    }
	}

	function prepare_bpy_scenes_audio(bpy_data, thread) {
	    for (var i = 0; i < bpy_data["scenes"].length; i++) {
	        var scene = bpy_data["scenes"][i];
	        var scene_dst = thread.is_primary ? scene : _primary_scene;

	        // NOTE: not the fastest way to check speaker existence
	        var has_spks = Boolean(get_bpy_cache_scene(thread.id, scene_dst, "SPEAKER").length);

	        if (has_spks && !scene_dst._sfx)
	            m_sfx.attach_scene_sfx(scene_dst);
	    }
	}

	/**
	 * Update all objects hierarchical cache using breadth-first search algorithm.
	 * NOTE: do proper cache update to prevent mysterious bugs
	 */
	function create_bpy_hierarchy_cache(bpy_data, thread) {
	    var scenes = bpy_data["scenes"];

	    // double hierarchy: groups than parents
	    var object_levels = [];

	    for (var i = 0; i < scenes.length; i++) {
	        var scene_objs = scenes[i]["objects"];
	        create_bpy_hierarchy_cache_iter(scene_objs, 0, thread.is_primary,
	                object_levels);
	    }

	    _all_objects_cache[thread.id] = [];

	    for (var i = 0; i < object_levels.length; i++) {
	        var grp_level = object_levels[i];

	        for (var j = 0; j < grp_level.length; j++) {
	            var par_level = grp_level[j];

	            for (var k = 0; k < par_level.length; k++)
	                _all_objects_cache[thread.id].push(par_level[k]);
	        }
	    }

	    // process objects, that aren't reached from scenes
	    var particles = bpy_data["particles"];
	    for (var i = 0; i < particles.length; i++) {
	        var dg_obj = particles[i]["dupli_object"];
	        if (dg_obj) {
	            dg_obj._is_hair_dupli = true;
	            _all_objects_cache[thread.id].push(dg_obj);
	        }

	        var dg_group = particles[i]["dupli_group"];
	        if (dg_group) {
	            var objects = dg_group["objects"];
	            for (var j = 0; j < objects.length; j++) {
	                dg_obj = objects[j];
	                dg_obj._is_hair_dupli = true;
	                _all_objects_cache[thread.id].push(dg_obj);
	            }
	        }
	    }
	    
	    // filter cached orphan objects which don't belong to any scene
	    var cache = _all_objects_cache[thread.id];
	    for (var i = cache.length - 1; i >= 0; i--)
	        if (!cache[i]._scenes)
	            cache.splice(i, 1);
	}

	function create_bpy_hierarchy_cache_iter(bpy_objects, grp_num, is_primary, 
	        object_levels) {

	    // initialize new group level
	    object_levels[grp_num] = object_levels[grp_num] || [];
	    var group_level = object_levels[grp_num];

	    for (var i = 0; i < bpy_objects.length; i++) {
	        var bpy_obj = bpy_objects[i];

	        var pnum = parent_num(bpy_obj);

	        // initialize new parent level
	        group_level[pnum] = group_level[pnum] || [];

	        // don't process LAMP objects on secondary load
	        if (is_primary || SECONDARY_LOAD_TYPES_DISABLED.indexOf(bpy_obj["type"]) == -1)
	            // push unique (other scenes may link to same object)
	            if (group_level[pnum].indexOf(bpy_obj) == -1)
	                group_level[pnum].push(bpy_obj);

	        var dupli_group = bpy_obj["dupli_group"];
	        if (dupli_group) {
	            var dg_objects = dupli_group["objects"];
	            create_bpy_hierarchy_cache_iter(dg_objects, grp_num + 1, 
	                    is_primary, object_levels);
	        }
	    }
	}

	function get_bpy_cache(data_id) {
	    return _all_objects_cache[data_id];
	}

	function get_bpy_cache_scene(data_id, bpy_scene, obj_type) {
	    var bpy_scene_objs = [];

	    var bpy_objects = get_bpy_cache(data_id);
	    for (var i = 0; i < bpy_objects.length; i++) {
	        var bpy_obj = bpy_objects[i];

	        if (bpy_obj["type"] == obj_type || obj_type == "ALL")
	            for (var j = 0; j < bpy_obj._scenes.length; j++)
	                if (bpy_scene == bpy_obj._scenes[j])
	                    bpy_scene_objs.push(bpy_obj);
	    }

	    return bpy_scene_objs;
	}

	/**
	 * Initialize engine objects.
	 * We have a bpy_objects <-> objects bijection here so we can use them equally
	 */
	function process_objects(bpy_data, thread, stage, cb_param, cb_finish,
	        cb_set_rate) {

	    var bpy_objects = get_bpy_cache(thread.id);
	    for (var i = 0; i < bpy_objects.length; i++) {
	        var obj = m_obj.create_object_from_bpy(bpy_objects[i]);
	        obj.render.data_id = thread.id;
	    }

	    var bpy_worlds = bpy_data["worlds"];
	    for (var i = 0; i < bpy_worlds.length; i++)
	        m_obj.create_object_from_bpy(bpy_worlds[i], true);

	    var objects = m_obj.get_all_objects("ALL", thread.id);

	    // update new objects (after creating - for making links beetween 
	    // objects: parenting, duplication, ...)
	    for (var i = 0; i < bpy_objects.length; i++) {
	        var bpy_obj = bpy_objects[i];
	        var obj = bpy_obj._object;
	        m_nla.update_object(bpy_obj, obj);
	    }

	    for (var i = 0; i < bpy_worlds.length; i++) {
	        var bpy_world = bpy_worlds[i];
	        var world = bpy_world._object;
	        m_nla.update_object(bpy_world, world);
	    }

	    if (thread.is_primary)
	        calc_light_index(bpy_data, thread.id);

	    for (var i = 0; i < bpy_objects.length; i++) {
	        var bpy_obj = bpy_objects[i];
	        var obj = bpy_obj._object;
	        if (!obj.is_hair_dupli) {
	            m_cons.prepare_object_relations(bpy_obj, obj);
	            m_obj.update_object_relations(bpy_obj, obj);
	            m_trans.update_transform(obj);
	        }

	        if (obj.type == "MESH")
	            m_obj.generate_mesh_render_boundings(bpy_obj, obj);
	    }

	    prepare_lod_objects(bpy_objects);

	    link_skinned_objs(objects);
	    calc_max_bones(objects);
	    prepare_vehicles(objects);
	    prepare_floaters(objects);

	    cb_finish(thread, stage);
	}

	function calc_light_index(bpy_data, data_id) {
	    for (var i = 0; i < bpy_data["scenes"].length; i++) {
	        var scene = bpy_data["scenes"][i]; 
	        var lamps = m_obj.get_scene_objs(scene, "LAMP", data_id);

	        var lamp_indexes = new Array(lamps.length);
	        for (var j = 0; j < lamps.length; j++)
	            lamp_indexes[j] = j;

	        lamp_indexes.sort(function(a, b) {
	            var l1 = lamps[a].light;
	            var l2 = lamps[b].light;
	            if (l2.use_diffuse && l2.use_specular &&
	                !(l1.use_diffuse && l1.use_specular))
	                return 1;
	            if (!l1.use_diffuse)
	                if(l2.use_diffuse || (!l1.use_specular && l2.use_specular))
	                    return 1;
	            return 0;
	        });

	        // NOTE: sort lamps due to lamp limit (need to preserve most valuable), 
	        // sorting mainly for iPADs
	        for (var j = 0; j < lamp_indexes.length; j++) {
	            var lamp = lamps[lamp_indexes[j]];
	            var lamp_sc_data = m_obj_util.get_scene_data(lamp, scene);
	            lamp_sc_data.light_index = j;
	        }
	    }
	}

	/**
	 * use bpy objects for appending the scenes and for the batching
	 */
	function process_scenes(bpy_data, thread, stage, cb_param, cb_finish,
	        cb_set_rate) {
	    
	    create_scene_props(bpy_data);

	    for (var i = 0; i < bpy_data["scenes"].length; i++) {

	        // NOTE: dynamically loaded objects are considered to be already on the 
	        // primary main scene (have different data_id)
	        var scene_dst = thread.is_primary ? bpy_data["scenes"][i] : _primary_scene;

	        // NOTE: get lamps from the primary scene for dynamically loaded scenes
	        var lamps = thread.is_primary 
	                ? m_obj.get_scene_objs(scene_dst, "LAMP", thread.id) 
	                : m_obj.get_scene_objs(scene_dst, "LAMP", 0);

	        var scene_objs = m_obj.get_scene_objs(scene_dst, "ALL", thread.id);

	        // var bpy_scene_objs = get_bpy_cache_scene(thread.id, scene_dst, "ALL");
	        var bpy_mesh_objs = get_bpy_cache_scene(thread.id, scene_dst, "MESH");
	        var bpy_empty_objs = get_bpy_cache_scene(thread.id, scene_dst, "EMPTY");

	        if (thread.is_primary)
	            m_scenes.append_scene(scene_dst, scene_objs, lamps, bpy_mesh_objs, 
	                    bpy_empty_objs);

	        var has_wind = false;
	        for (var j = 0; j < bpy_empty_objs.length; j++) {
	            var obj = bpy_empty_objs[j]._object;
	            var scenes_data = obj.scenes_data;
	            for (var k = 0; k < scenes_data.length; k++) {
	                var scene = scenes_data[k].scene;
	                var scene_has_wind = m_scenes.update_force_scene(scene, obj);
	                if (scene_dst.name == scene.name)
	                    has_wind = has_wind || scene_has_wind;
	            }
	        }
	        if (thread.is_primary)
	            if (scene_dst._render.water_params && !has_wind)
	                m_print.warn("Scene \"" + scene_dst.name + "\" has water but has "
	                        + "no wind. Using default settings.");

	        // batching
	        var metaobjects = [];
	        m_scenes.set_active(scene_dst);
	        m_batch.generate_main_batches(scene_dst, bpy_mesh_objs, lamps, metaobjects);

	        var line_objs = m_obj.get_scene_objs(scene_dst, "LINE", thread.id);
	        m_batch.generate_line_batches(scene_dst, line_objs);

	        var scene_graph = m_scenes.get_graph(scene_dst);
	        if (thread.is_primary) {
	            // generate sky batch
	            var sky = scene_dst._render.sky_params;
	            var bpy_world = scene_dst["world"];
	            if (sky.render_sky || sky.procedural_skydome) {
	                var world = bpy_world._object;
	                m_batch.append_sky_batch_to_world(scene_dst, sky, world);
	                m_batch.create_forked_batches(world, scene_graph, scene_dst);
	            }
	            m_scenes.generate_auxiliary_batches(scene_dst, scene_graph);
	            var wls = scene_dst._render.world_light_set;
	            if (wls && (wls.use_environment_light || wls.ngraph_proxy_id))
	                m_batch.append_cube_sky_batch_to_world(scene_dst, bpy_world._object);
	        }

	        //create forked batches
	        for (var j = 0; j < bpy_mesh_objs.length; j++)
	            m_batch.create_forked_batches(bpy_mesh_objs[j]._object, scene_graph, scene_dst);
	        for (var j = 0; j < metaobjects.length; j++) {
	            m_batch.create_forked_batches(metaobjects[j], scene_graph, scene_dst);
	            m_obj.objects_storage_add(metaobjects[j]);
	        }

	        // original and meta objects both
	        scene_objs = m_obj.get_scene_objs(scene_dst, "ALL", thread.id);
	        m_scenes.assign_scene_data_subs(scene_dst, scene_objs, lamps);

	        // update boundings for shape keys objs
	        // and props for zup tsrs
	        for (var j = 0; j < scene_objs.length; j++) {
	            var obj = scene_objs[j];
	            if (obj.render.use_shape_keys && !obj.is_boundings_overridden)
	                m_obj.update_boundings(obj);

	            if (m_obj_util.check_inv_zup_tsr_is_needed(obj))
	                obj.need_inv_zup_tsr = true;

	            m_obj.update_lod_scene(obj, scene_dst);
	        }
	    }

	    m_scenes.append_scene_vtex(_primary_scene, bpy_data["textures"], thread.id);

	    // creating media controls for some devices only for primary thread
	    if (thread.is_primary)
	        if (_primary_scene._render.video_textures.length)
	            thread.has_video_textures = true;

	    cb_finish(thread, stage);
	}

	function create_scene_props(bpy_data) {
	    for (var i = 0; i < bpy_data["scenes"].length; i++) {
	        var bpy_scene = bpy_data["scenes"][i];
	        bpy_scene._camera = bpy_scene["camera"]._object;
	    }
	}

	function drop_bpy_data(bpy_data, thread) {
	    for (var i = 0; i < bpy_data["scenes"].length; i++) {
	        var bpy_scene = bpy_data["scenes"][i];
	        bpy_scene["camera"] = null;
	    }
	}

	function link_skinned_objs(objects) {

	    for (var i = 0; i < objects.length; i++) {

	        var skinned_obj = objects[i];
	        if (skinned_obj.type != "MESH")
	            continue;

	        var armobj = skinned_obj.armobj;
	        if (armobj) {
	            var render = armobj.render;
	            var skinned_render = skinned_obj.render;
	            var bone_skinning_info = skinned_render.bone_skinning_info;
	            // construct bone map for deform_bone -> bone indices compliance
	            // this structure is needed for optimization
	            var mesh_bone_map = [];
	            for (var bone_name in bone_skinning_info) {
	                var bi = bone_skinning_info[bone_name];
	                var bone_index = bi.bone_index;
	                var deform_bone_index = bi.deform_bone_index;

	                var sk_ind = 4 * deform_bone_index;
	                var ind = 4 * bone_index;
	                mesh_bone_map.push(sk_ind, ind);
	            }
	            render.mesh_to_arm_bone_maps.push(mesh_bone_map);
	            render.skinned_renders.push(skinned_obj.render);
	        }
	    }
	}

	function setup_dds_loading(bpy_data) {
	    var materials = bpy_data["materials"];

	    //need to set default compression props. They are checked during image upload
	    unset_images_dds(bpy_data["images"]);

	    // check extension for dds/pvr
	    if (!(cfg_ldr.dds_available && cfg_def.compress_format == "dds" 
	            || cfg_ldr.pvr_available && cfg_def.compress_format == "pvr") 
	            || !cfg_def.use_compression)
	        return;

	    for (var i = 0; i < materials.length; i++) {

	        var material = materials[i];

	        // setup dds for non-node materials
	        var texture_slots = material["texture_slots"];
	        for (var j = 0; j < texture_slots.length; j++) {

	            var texture_slot = texture_slots[j];
	            var texture = texture_slot["texture"];

	            if (texture["type"] != "IMAGE" && texture["type"] != "ENVIRONMENT_MAP")
	                continue;

	            var image = texture["image"];
	            if (image && !image._comp_method) {
	                var use_compression = !texture["b4w_disable_compression"] &&
	                                      !texture_slot["use_map_normal"] &&
	                                      texture["type"] != "ENVIRONMENT_MAP" &&
	                                      !texture["b4w_shore_dist_map"] &&
	                                      image["source"] != "MOVIE";
	                set_image_compress_format(image, use_compression);
	            }
	        }

	        // setup dds for node materials
	        var node_tree = material["node_tree"];
	        if (node_tree) {
	            var nodes = node_tree["nodes"];

	            for (var j = 0; j < nodes.length; j++) {
	                var node = nodes[j];
	                var use_compression = false;

	                if (node["type"] == "TEXTURE") {
	                    var tex = node["texture"];
	                    if (tex) {
	                        var image = tex["image"];
	                        if (image && !image._comp_method)
	                            use_compression = !tex["b4w_disable_compression"] &&
	                                              tex["image"]["source"] != "MOVIE" &&
	                                              tex["type"] != "ENVIRONMENT_MAP" &&
	                                              !check_normal_output(node);
	                    }
	                } else if (node["type"] == "TEX_IMAGE") {
	                    var image = node["image"];
	                    if (image && !image._comp_method)
	                        use_compression = image["source"] != "MOVIE";
	                } else if (node["type"] == "TEX_ENVIRONMENT") {
	                    use_compression = false;
	                }
	                if (image && !image._comp_method)
	                    set_image_compress_format(image, use_compression);
	            }
	        }
	    }
	}

	function check_normal_output(bpy_node) {
	    var outputs = bpy_node["outputs"];
	    for (var i = 0; i < outputs.length; i++) {
	        var output = outputs[i];
	        if (output["is_linked"] && output["identifier"] == "Normal")
	            return true;
	    }
	    return false;
	}

	function set_image_compress_format(image, use_compression) {
	    if (image["filepath"].indexOf(".dds") > -1) {
	        // dds texture was used in blender - so just mark it as dds
	        // this is mostly a debug feature, so s3tc ext check is not performed
	        image._comp_method = "dds";
	    } else {
	        if (use_compression) {
	            // check: load texture as usual or as dds; then if needed mark it as dds and adjust filepath
	            image._comp_method = cfg_def.compress_format;
	            if (cfg_def.compress_format == "dds") {
	                image["filepath"] += ".dds";
	            } else
	                image["filepath"] += ".pvr";
	        } else
	            image._comp_method = "";
	    }
	}

	function unset_images_dds(images) {
	    // mark image as dds only if it was used in blender
	    for (var i = 0; i < images.length; i++) {
	        var image = images[i];
	        var use_dds = Boolean(image["source"] == "FILE" &&
	                              image["filepath"].indexOf(".dds") > -1 &&
	                              cfg_def.compress_format == "dds");
	        if (use_dds)
	            image._comp_method = "dds";
	        else
	            image._comp_method = "";
	    }
	}

	/**
	 * global anisotropic filtering, may be overriden by individual textures
	 * use value from the first scene because it's difficult
	 * or impossible to assign textures to scenes
	 */
	function get_global_anisotropic_filtering(bpy_data, thread) {
	    if (thread.is_primary)
	        return bpy_data["scenes"][0]["b4w_anisotropic_filtering"];
	    else
	        return _primary_scene["b4w_anisotropic_filtering"];
	}

	/**
	 * Prepare object's groups.
	 * remove odd objects (proxy sources)
	 * unfold dupli_group objects
	 */
	function duplicate_objects(bpy_data, thread, stage, cb_param, cb_finish,
	        cb_set_rate) {

	    var groups = bpy_data["groups"];
	    var bpy_objects = bpy_data["objects"];

	    // save old objects to find new ones later
	    var grp_ids_old = {};
	    var obj_ids_old = {};

	    var grp_ids = {};
	    var obj_ids = {};

	    for (var i = 0; i < groups.length; i++) {
	        var group = groups[i];
	        grp_ids_old[group["uuid"]] = group;
	        grp_ids[group["uuid"]] = group;
	    }

	    for (var i = 0; i < bpy_objects.length; i++) {
	        var bpy_obj = bpy_objects[i];
	        obj_ids_old[bpy_obj["uuid"]] = bpy_obj;
	        obj_ids[bpy_obj["uuid"]] = bpy_obj;
	    }

	    var scenes = bpy_data["scenes"];

	    for (var i = 0; i < scenes.length; i++) {
	        var scene = scenes[i];
	        duplicate_objects_iter(scene["objects"], null, obj_ids, grp_ids, null);
	    }

	    for (var id in grp_ids)
	        if (!(id in grp_ids_old))
	            groups.push(grp_ids[id]);

	    for (var id in obj_ids)
	        if (!(id in obj_ids_old))
	            bpy_objects.push(obj_ids[id]);

	    cb_finish(thread, stage);
	}

	function duplicate_objects_iter(obj_links, origin_obj, obj_ids, grp_ids, cluster_data) {

	    var proxy_source_ids = [];

	    for (var i = 0; i < obj_links.length; i++) {
	        var obj_link = obj_links[i];
	        var bpy_obj = obj_ids[obj_link["uuid"]];

	        var proxy_link = bpy_obj["proxy"];
	        if (proxy_link) {
	            // save to purge later
	            if (origin_obj &&
	                    proxy_source_ids.indexOf(proxy_link["uuid"]) == -1)
	                proxy_source_ids.push(proxy_link["uuid"]);

	            var proxy = obj_ids[proxy_link["uuid"]];

	            // currently blender doesn't preserve constraints for
	            // proxy objects, so try to use constraints of proxy source
	            var consts = proxy["constraints"];
	            for (var j = 0; j < consts.length; j++) {
	                var new_cons = m_util.clone_object_r(consts[j]);
	                new_cons.name = new_cons.name + "_CLONE";
	                bpy_obj["constraints"].push(new_cons);
	            }

	            // NOTE: handle missing b4w_proxy_inherit_anim as true (temporary)
	            if (!("b4w_proxy_inherit_anim" in bpy_obj) ||
	                    bpy_obj["b4w_proxy_inherit_anim"]) {
	                var anim_data = bpy_obj["animation_data"];
	                if (anim_data)
	                    proxy["animation_data"] = m_util.clone_object_r(bpy_obj["animation_data"]);

	                proxy["b4w_use_default_animation"] = bpy_obj["b4w_use_default_animation"];
	                proxy["b4w_auto_skel_anim"] = bpy_obj["b4w_auto_skel_anim"];
	                proxy["b4w_anim_behavior"] = bpy_obj["b4w_anim_behavior"];

	                // NOTE: deprecated
	                proxy["b4w_cyclic_animation"] = bpy_obj["b4w_cyclic_animation"];
	            }
	        }
	    }

	    // purge source object links for proxies
	    for (var i = 0; i < proxy_source_ids.length; i++) {
	        var proxy_src_id = proxy_source_ids[i];

	        var obj_index = m_util.get_index_for_key_value(obj_links, "uuid",
	                proxy_src_id);
	        if (obj_index > -1)
	            obj_links.splice(obj_index, 1);
	    }

	    // for parent/constraint targets
	    var obj_id_overrides = {};

	    if (origin_obj) {
	        for (var i = 0; i < obj_links.length; i++) {
	            var obj_link = obj_links[i];
	            var bpy_obj = obj_ids[obj_link["uuid"]];

	            var bpy_obj_new = m_util.clone_object_r(bpy_obj);
	            var name = ("origin_name" in bpy_obj) ? bpy_obj["origin_name"] :
	                    bpy_obj["name"];
	            bpy_obj_new["name"] = m_obj_util.gen_dupli_name(origin_obj["name"], name);

	            bpy_obj_new["origin_name"] = name;
	            bpy_obj_new["dg_parent"] = {"uuid" : origin_obj["uuid"]};

	            assign_bpy_obj_id(bpy_obj_new);
	            obj_ids[bpy_obj_new["uuid"]] = bpy_obj_new;
	            obj_id_overrides[obj_link["uuid"]] = bpy_obj_new["uuid"];
	            obj_link["uuid"] = bpy_obj_new["uuid"];

	            if (cluster_data && cluster_data[bpy_obj["uuid"]])
	                bpy_obj_new["b4w_cluster_data"] = cluster_data[bpy_obj["uuid"]];
	        }
	    }

	    for (var i = 0; i < obj_links.length; i++) {
	        var obj_link = obj_links[i];
	        var bpy_obj = obj_ids[obj_link["uuid"]];

	        if (bpy_obj["dupli_group"]) {
	            var grp_link = bpy_obj["dupli_group"];
	            var grp = grp_ids[grp_link["uuid"]];

	            var grp_new = m_util.clone_object_r(grp);
	            grp_new["name"] = m_util.unique_name(grp["name"]+"_CLONE");
	            assign_grp_id(grp_new);
	            grp_ids[grp_new["uuid"]] = grp_new;
	            // NOTE: may affect original objects
	            // it's seams save for two-level object access
	            grp_link["uuid"] = grp_new["uuid"];

	            var dg_obj_links = grp_new["objects"];

	            duplicate_objects_iter(dg_obj_links, bpy_obj, obj_ids, grp_ids, 
	                    bpy_obj["b4w_cluster_data"]);
	        }
	    }

	    // same as non-empty obj_id_overrides
	    if (origin_obj) {
	        for (var i = 0; i < obj_links.length; i++) {
	            var obj_link = obj_links[i];
	            var bpy_obj = obj_ids[obj_link["uuid"]];

	            if (bpy_obj["parent"] && bpy_obj["parent"]["uuid"] in obj_id_overrides)
	                bpy_obj["parent"]["uuid"] = obj_id_overrides[bpy_obj["parent"]["uuid"]];
	            else if (bpy_obj["parent"]) {
	                m_print.warn("Object's \"" + bpy_obj.name
	                     + "\" parent is not in dupli group. Disabling parenting.");
	                bpy_obj["parent"] = null;
	            }

	            var consts = bpy_obj["constraints"];
	            for (var j = 0; j < consts.length; j++) {
	                var cons = consts[j];

	                if (cons["target"] && cons["target"]["uuid"] in obj_id_overrides)
	                    cons["target"]["uuid"] = obj_id_overrides[cons["target"]["uuid"]];
	            }

	            var pose = bpy_obj["pose"];
	            if (pose) {
	                var pose_bones = pose["bones"];
	                for (var j = 0; j < pose_bones.length; j++) {
	                    var pose_bone = pose_bones[j];

	                    // make links to constraint targets
	                    var constraints = pose_bone["constraints"];
	                    if (constraints) { // compatibility check
	                        for (var k = 0; k < constraints.length; k++) {
	                            var cons = constraints[k];

	                            if (cons["target"] && cons["target"]["uuid"] in obj_id_overrides)
	                                cons["target"]["uuid"] = obj_id_overrides[cons["target"]["uuid"]];
	                        }
	                    }
	                }
	            }

	            var mods = bpy_obj["modifiers"];
	            for (var j = 0; j < mods.length; j++) {
	                var mod = mods[j];

	                if (mod["object"] && (mod["object"]["uuid"] in obj_id_overrides))
	                    mod["object"]["uuid"] = obj_id_overrides[mod["object"]["uuid"]];
	            }

	            var lods = bpy_obj["lod_levels"];

	            if (lods && lods.length) {
	                for (var j = 0; j < lods.length; j++) {
	                    var lod = lods[j];

	                    if (lod["object"] && lod["object"]["uuid"] in obj_id_overrides)
	                        lod["object"]["uuid"] = obj_id_overrides[lod["object"]["uuid"]];
	                }
	            }
	        }
	    }

	    for (var key in obj_id_overrides)
	        _dupli_obj_id_overrides[key] = obj_id_overrides[key];
	}

	function assign_bpy_obj_id(bpy_obj) {
	    bpy_obj["uuid"] = m_md5.hexdigest("Object" + bpy_obj["name"]);
	}

	function assign_grp_id(grp) {
	    grp["uuid"] = m_md5.hexdigest("Group" + grp["name"]);
	}


	/**
	 * Make links for bpy_data.
	 * executed before compatibility checks from check_bpy_data()
	 */
	function make_bpy_links(bpy_data) {

	    var cameras     = bpy_data["cameras"];
	    var groups      = bpy_data["groups"];
	    var materials   = bpy_data["materials"];
	    var meshes      = bpy_data["meshes"];
	    var node_groups = bpy_data["node_groups"];
	    var objects     = bpy_data["objects"];
	    var particles   = bpy_data["particles"];
	    var scenes      = bpy_data["scenes"];
	    var speakers    = bpy_data["speakers"];
	    var lamps       = bpy_data["lamps"];
	    var textures    = bpy_data["textures"];
	    var worlds      = bpy_data["worlds"];

	    // NOTE: Temporary check. Can't do it in reformer.
	    if (!node_groups) {
	        m_print.warn("\"node_groups\" datablock undefined. reexport main scene.");
	        node_groups = bpy_data["node_groups"] = [];
	    }

	    var storage = gen_datablocks_storage(bpy_data);

	    // make links from scenes to their objects
	    for (var i = 0; i < scenes.length; i++) {
	        var scene = scenes[i];

	        var scene_objects = scene["objects"]; // names and libs
	        for (var j = 0; j < scene_objects.length; j++)
	            make_link_uuid(scene_objects, j, storage);

	        if (scene["camera"])
	            make_link_uuid(scene, "camera", storage);

	        if (scene["world"])
	            make_link_uuid(scene, "world", storage);
	    }

	    // make links from groups to their objects
	    for (var i = 0; i < groups.length; i++) {
	        var group = groups[i];

	        var group_objects = group["objects"]; // names and libs
	        for (var j = 0; j < group_objects.length; j++)
	            make_link_uuid(group_objects, j, storage);
	    }

	    /*
	     * OBJECTS
	     * make links from objects to their data (meshes, lamps, cameras)
	     * and to groups if any
	     */
	    for (var i = 0; i < objects.length; i++) {
	        var bpy_obj = objects[i];

	        if (bpy_obj["dupli_group"])
	            make_link_uuid(bpy_obj, "dupli_group", storage);

	        if (bpy_obj["parent"])
	            make_link_uuid(bpy_obj, "parent", storage);

	        if (bpy_obj["dg_parent"])
	            make_link_uuid(bpy_obj, "dg_parent", storage);

	        var adata = bpy_obj["animation_data"];
	        if (adata)
	            make_anim_data_bpy_links(adata, storage);

	        switch (bpy_obj["type"]) {
	        case "MESH":

	            if (!bpy_obj["data"])
	                m_util.panic("mesh not found for object " + bpy_obj["name"]);

	            make_link_uuid(bpy_obj, "data", storage);

	            var found_armat_mod = false;

	            // also make links for armature/curve modifiers
	            var modifiers = bpy_obj["modifiers"];
	            for (var j = 0; j < modifiers.length; j++) {
	                var modifier = modifiers[j];

	                if (modifier["type"] == "ARMATURE") {

	                    if (found_armat_mod)
	                        m_print.warn("Object \"" + bpy_obj["name"] + "\" has more " +
	                            "than one armature modifiers. Only the first one will be used.");

	                    found_armat_mod = true;
	                    make_link_uuid(modifier, "object", storage);
	                } else if (modifier["type"] == "CURVE")
	                    make_link_uuid(modifier, "object", storage);
	            }

	            // also make links for possible particle systems
	            var psystems = bpy_obj["particle_systems"];
	            if (psystems) {
	                for (var j = 0; j < psystems.length; j++) {
	                    var psys = psystems[j];
	                    make_link_uuid(psys, "settings", storage);
	                }
	            }
	            break;

	        case "ARMATURE":
	            make_link_uuid(bpy_obj, "data", storage);

	            // also make links from pose bones to armature bones
	            var pose = bpy_obj["pose"];
	            var pose_bones = pose["bones"];
	            var armature = bpy_obj["data"];
	            var armature_bones = armature["bones"];
	            for (var j = 0; j < pose_bones.length; j++) {
	                var pose_bone = pose_bones[j];
	                var bone_index = pose_bone["bone"];
	                var armature_bone = armature_bones[bone_index];
	                pose_bone["bone"] = armature_bone;

	                // make links to constraint targets
	                var constraints = pose_bone["constraints"];
	                if (constraints) { // compatibility check
	                    for (var k = 0; k < constraints.length; k++) {
	                        var cons = constraints[k];
	                        if (cons["target"])
	                            make_link_uuid(cons, "target", storage);
	                    }
	                }

	                // also make links between children and parents
	                var parent_recursive = pose_bone["parent_recursive"];
	                for (var k = 0; k < parent_recursive.length; k++) {
	                    var parent_index = parent_recursive[k];
	                    parent_recursive[k] = pose_bones[parent_index];
	                }
	            }
	            break;

	        case "LAMP":
	        case "CAMERA":
	        case "SPEAKER":
	        case "CURVE":
	            make_link_uuid(bpy_obj, "data", storage);
	            break;
	        case "EMPTY":
	        default:
	            break;
	        }

	        // make links to constraint targets
	        var constraints = bpy_obj["constraints"];
	        if (constraints) { // compatibility check
	            for (var j = 0; j < constraints.length; j++) {
	                var cons = constraints[j];
	                if (cons["target"])
	                    make_link_uuid(cons, "target", storage);
	            }
	        }

	        // make links to lods
	        var lods = bpy_obj["lod_levels"];
	        if (lods) { // compatibility check
	            for (var j = 0; j < lods.length; j++) {
	                var lod = lods[j];
	                if (lod["object"])
	                    make_link_uuid(lod, "object", storage);
	            }
	        }
	    }

	    /*
	     * MESHES
	     * make links from meshes to materials used by them
	     */
	    for (var i = 0; i < meshes.length; i++) {
	        var mesh = meshes[i];

	        var mesh_materials = mesh["materials"];
	        for (var j = 0; j < mesh_materials.length; j++)
	            make_link_uuid(mesh_materials, j, storage);
	    }

	    /*
	     * MATERIALS
	     * make links from materials to textures used by them
	     */
	    for (var i = 0; i < materials.length; i++) {
	        var material = materials[i];

	        var texture_slots = material["texture_slots"];
	        for (var j = 0; j < texture_slots.length; j++) {
	            make_link_uuid(texture_slots[j], "texture", storage);
	        }

	        // also make links for node-based materials
	        // currently MATERIAL nodes are supported
	        var node_tree = material["node_tree"];
	        if (!node_tree)
	            continue;

	        make_node_tree_bpy_links(node_tree, storage);
	    }

	    /*
	     * NODE GROUPS
	     * make links from node groups
	     */
	    for (var i = 0; i < node_groups.length; i++) {
	        var node_group = node_groups[i];

	        var node_tree = node_group["node_tree"];
	        if (!node_tree)
	            continue;

	        make_node_tree_bpy_links(node_tree, storage);
	    }

	    /*
	     * TEXTURES
	     * make links from textures to their images
	     */
	    for (var i = 0; i < textures.length; i++) {
	        var texture = textures[i];

	        var tex_type = texture["type"];
	        if (tex_type == "IMAGE" || tex_type == "ENVIRONMENT_MAP")
	            make_link_uuid(texture, "image", storage);
	    }

	    /*
	     * CAMERAS
	     */
	    for (var i = 0; i < cameras.length; i++) {
	        var camera = cameras[i];
	        if (camera["dof_object"])
	            make_link_uuid(camera, "dof_object", storage);
	    }

	    /*
	     * SPEAKERS
	     */
	    // make links from speakers to their sounds
	    for (var i = 0; i < speakers.length; i++) {
	        var speaker = speakers[i];

	        // NOTE: temporary compatibility check: allow speakers without sound
	        // can change to unconditional linking
	        if (speaker["sound"])
	            make_link_uuid(speaker, "sound", storage);

	        var adata = speaker["animation_data"];
	        if (adata)
	            make_anim_data_bpy_links(adata, storage);
	    }

	    /*
	     * PARTICLES
	     * make links from particles'es texture slots to textures
	     */
	    for (var i = 0; i < particles.length; i++) {
	        var part = particles[i];

	        var texture_slots = part["texture_slots"];
	        for (var j = 0; j < texture_slots.length; j++)
	            make_link_uuid(texture_slots[j], "texture", storage);

	        if (part["dupli_group"])
	            make_link_uuid(part, "dupli_group", storage);

	        if (part["dupli_object"])
	            make_link_uuid(part, "dupli_object", storage);
	    }

	    for (var i = 0; i < lamps.length; i++) {
	        var lamp = lamps[i];
	        var adata = lamp["animation_data"];
	        if (adata)
	            make_anim_data_bpy_links(adata, storage);
	    }

	    /*
	     * WORLDS
	     * make links from world.texture_slots to texture used by them
	     */
	    for (var i = 0; i < worlds.length; i++) {
	        var world = worlds[i];

	        var texture_slots = world["texture_slots"];
	        if (texture_slots)
	            for (var j = 0; j < texture_slots.length; j++) {
	                make_link_uuid(texture_slots[j], "texture", storage);
	            }

	        var adata = world["animation_data"];
	        if (adata)
	            make_anim_data_bpy_links(adata, storage);

	        var node_tree = world["node_tree"];
	        if (!node_tree)
	            continue;

	        make_node_tree_bpy_links(node_tree, storage);
	    }
	}

	function make_anim_data_bpy_links(adata, storage) {
	    if (adata["action"])
	        make_link_uuid(adata, "action", storage);

	    if (adata["nla_tracks"])
	        for (var j = 0; j < adata["nla_tracks"].length; j++) {
	            var track = adata["nla_tracks"][j];

	            for (var k = 0; k < track["strips"].length; k++)
	                if (track["strips"][k]["action"])
	                    make_link_uuid(track["strips"][k], "action", storage);
	        }
	}

	function make_node_tree_bpy_links(node_tree, storage) {
	    var nodes = node_tree["nodes"];
	    for (var j = 0; j < nodes.length; j++) {
	        var node = nodes[j];

	        if (node["type"] == "TEXTURE" && node["texture"])
	            make_link_uuid(node, "texture", storage);

	        if (node["type"] == "LAMP" && node["lamp"]) {
	            if (node["lamp"]["uuid"] in _dupli_obj_id_overrides)
	                node["lamp"]["uuid"] = _dupli_obj_id_overrides[node["lamp"]["uuid"]];
	            if (!storage[node["lamp"]["uuid"]])
	                node["lamp"] = null;
	        }

	        // NOTE: Check node["node_group"] for compatibility with older scenes
	        if (node["type"] == "GROUP" && node["node_group"])
	            make_link_uuid(node, "node_group", storage);

	        if ((node["type"] == "TEX_IMAGE" || node["type"] == "TEX_ENVIRONMENT")
	                && node["image"])
	            make_link_uuid(node, "image", storage);
	    }

	    var links = node_tree["links"];
	    for (var j = 0; j < links.length; j++) {
	        var link = links[j];
	        make_link_name(link, "from_node", nodes);
	        make_link_name(link, "to_node", nodes);

	        make_link_ident(link, "from_socket", link["from_node"]["outputs"]);
	        make_link_ident(link, "to_socket", link["to_node"]["inputs"]);
	    }

	    var adata = node_tree["animation_data"];
	    if (adata)
	        make_anim_data_bpy_links(adata, storage);
	}

	function gen_datablocks_storage(bpy_data) {

	    var DB_NAMES = [
	        "actions",
	        "armatures",
	        "cameras",
	        "curves",
	        "groups",
	        "images",
	        "lamps",
	        "materials",
	        "meshes",
	        "node_groups",
	        "objects",
	        "particles",
	        "scenes",
	        "sounds",
	        "speakers",
	        "textures",
	        "worlds"
	    ];

	    var storage = {};

	    for (var i = 0; i < DB_NAMES.length; i++) {
	        var db_arr = bpy_data[DB_NAMES[i]];

	        for (var j = 0; j < db_arr.length; j++) {
	            var db = db_arr[j];
	            storage[db["uuid"]] = db;
	        }
	    }

	    return storage;
	}

	function make_link_uuid(storage, prop, uuid_storage) {
	    if (storage[prop]) {
	        var entity_new = uuid_storage[storage[prop]["uuid"]];
	        if (!entity_new)
	            m_print.error("Dangling link found:", prop, storage);
	        storage[prop] = entity_new;
	    }
	}

	function make_link_name(storage, property, search_here) {
	    var entity_old = storage[property];
	    var entity_new = m_util.keysearch("name", entity_old["name"], search_here);

	    storage[property] = entity_new;
	}

	function make_link_ident(storage, property, search_here) {
	    var entity_old = storage[property];
	    var entity_new = m_util.keysearch("identifier", entity_old["identifier"],
	            search_here);

	    storage[property] = entity_new;
	}

	function load_images(bpy_data, thread, stage, cb_param, cb_finish, cb_set_rate) {

	    var image_assets = [];
	    var fallback_image_assets = []; // in case gz/dds/pvr/min50 were not found

	    var image_users = {};

	    var images = bpy_data["images"];
	    var textures = m_tex.get_img_textures();
	    var dir_path = dirname(thread.filepath);

	    for (var i = 0; i < images.length; i++) {
	        var image = images[i];
	        var uuid = image["uuid"];

	        if (uuid) {
	            var image_path = m_util.normpath_preserve_protocol(dir_path + image["filepath"]);
	            var head_ext = m_assets.split_extension(image_path);
	            var path_ext_low = head_ext[1].toLowerCase();

	            var image_source = image["source"];

	            if (image_source === "FILE") {
	                if (image._comp_method)
	                    var asset_type = m_assets.AT_ARRAYBUFFER;
	                else
	                    var asset_type = m_assets.AT_IMAGE_ELEMENT;

	                if (!m_assets.check_image_extension(path_ext_low)) {
	                    m_print.error("image \"" + image["name"] + "\" has unsupported format or broken path.");
	                    continue;
	                }

	                if (cfg_ldr.min50_available && cfg_def.use_min50)
	                    image_path = set_min50_dds_path(head_ext);

	            } else if (image_source === "MOVIE") {
	                if (!cfg_def.seq_video_fallback) {
	                    var ext = m_sfx.detect_video_container(path_ext_low);

	                    if (ext == "") {
	                        m_print.error("failed to load video file (unsupported format)", image_path);
	                        continue;
	                    }

	                    if (ext != path_ext_low)
	                        image_path = head_ext[0] +".altconv." + ext;
	                    else
	                        image_path = head_ext[0] +"." + head_ext[1];

	                    var asset_type = m_assets.AT_VIDEO_ELEMENT;
	                } else {
	                    image_path = head_ext[0] +".altconv.seq";
	                    var asset_type = m_assets.AT_SEQ_VIDEO_ELEMENT;
	                }
	            } else {
	                m_print.error("Image \""+image["name"]+"\" has unsupported format \""+image_source+"\".");
	                continue;
	            }

	            if (!(uuid in image_users)) 
	                image_users[uuid] = [];

	            for (var j = 0; j < textures.length; j++) {
	                var texture = textures[j];
	                if (!m_tex.get_cache_loaded_status(texture) 
	                        && texture.img_comp_method == image._comp_method
	                        && texture.img_uuid == uuid || thread.is_preloading)
	                    image_users[uuid].push(texture);
	            }

	            if (image._comp_method && cfg_def.assets_gzip_available) {
	                asset_type = m_assets.AT_ARRAYBUFFER_ZIP;
	                image_path = image_path + ".gz";
	            }

	            // only download images which have texture users
	            if (image_users[uuid].length) {
	                image_assets.push({ id:uuid,
	                                    type:asset_type,
	                                    url:image_path,
	                                    is_fetch: thread.is_preloading
	                                });
	            }
	        }
	    }
	    if (image_assets.length) {
	        var image_counter = 0;

	        var asset_cb = function(image_data, id, type, url) {
	            // process only loaded images
	            if (image_data) {
	                var show_path_warning = true;
	                if (!thread.is_preloading) {
	                    var tex_users = image_users[id];
	                    for (var i = 0; i < tex_users.length; i++) {
	                        var tex_user = tex_users[i];
	                        if (type == m_assets.AT_SEQ_VIDEO_ELEMENT) {
	                            tex_user.seq_fps = image_data.fps;
	                            m_tex.update_texture(tex_user, image_data.images, thread.id);
	                        } else {
	                            m_tex.update_texture(tex_user, image_data, thread.id);
	                            if (tex_user.source == "ENVIRONMENT_MAP" && thread.is_primary) {
	                                for (var j = 0; j < bpy_data["scenes"].length; j++)
	                                    m_scenes.update_world_texture(bpy_data["scenes"][j]);
	                            }
	                        }
	                        m_tex.set_cache_loaded_status(tex_user, true);
	                    }
	                    var comp_method = tex_users[0].img_comp_method;
	                } else
	                    var comp_method = type;

	                if (type == m_assets.AT_VIDEO_ELEMENT 
	                        || type == m_assets.AT_SEQ_VIDEO_ELEMENT)
	                    print_video_info(image_data, url, show_path_warning, type);
	                else 
	                    print_image_info(image_data, url, show_path_warning, comp_method);
	            } else {
	                var fb_asset = get_image_fallback(id, url, thread.is_preloading, image_users);
	                if (fb_asset) {
	                    m_print.warn("Trying to load fallback image", fb_asset.url);
	                    fallback_image_assets.push(fb_asset);
	                }
	            }

	            var rate = ++image_counter / (image_assets.length + fallback_image_assets.length);
	            cb_set_rate(thread, stage, rate);
	        };

	        var pack_cb = function() {
	            if (fallback_image_assets.length) {
	                // several fallback iterations are possible: gz->dds/pvr->min50->png
	                m_assets.enqueue(fallback_image_assets, asset_cb, pack_cb);
	                fallback_image_assets.length = 0;
	            } else {
	                m_print.log("%cLOADED ALL IMAGES", "color: #0a0");
	                cb_finish(thread, stage);
	            }
	        };

	        m_assets.enqueue(image_assets, asset_cb, pack_cb);
	    } else
	        cb_finish(thread, stage);
	}

	function get_image_fallback(id, url, is_fetch, image_users) {
	    var old_url = drop_version(url);
	    var ext = m_assets.split_extension(old_url);

	    if (ext[1] == "gz") {
	        // fallback to dds/pvr
	        var new_url = ext[0];
	        var new_type = m_assets.AT_ARRAYBUFFER;
	    } else if (ext[1] == "dds" || ext[1] == "pvr") {
	        // fallback to min50 or original image
	        var new_url = ext[0];
	        var new_type = m_assets.AT_IMAGE_ELEMENT;
	        drop_compression(image_users[id]);
	    } else if (old_url.indexOf(".min50") != -1) {
	        // fallback to original image
	        var new_url = drop_min50(old_url);
	        var new_type = m_assets.AT_IMAGE_ELEMENT;
	    } else {
	        // no more fallbacks
	        return null;
	    }

	    return {
	        id: id,
	        type: new_type,
	        url: new_url,
	        is_fetch: is_fetch
	    };
	}

	function drop_version(path) {
	    return path.split("?v")[0];
	}

	function drop_min50(path) {
	    var split_path = path.split(".min50");
	    var new_path = split_path[0] + split_path[1];
	    return new_path;
	}

	function set_min50_dds_path(head_ext) {
	    if (head_ext[1] == "dds") {
	        var head_ext_wo_dds = m_assets.split_extension(head_ext[0]);
	        return head_ext_wo_dds[0] + ".min50." + head_ext_wo_dds[1] + ".dds";
	    } else
	        return head_ext[0] + ".min50." + head_ext[1];
	}

	function drop_compression(textures) {
	    for (var i = 0; i < textures.length; i++)
	        textures[i].img_comp_method = "";
	}

	function update_scenes_nla(bpy_data, thread, stage, cb_param, cb_finish, cb_set_rate) {
	    var scenes = m_scenes.get_rendered_scenes();
	    for (var i = 0; i < scenes.length; i++) {
	        var scene = scenes[i];
	        if (scene["b4w_use_nla"]) {
	            var nla_cyclic = scene["b4w_nla_cyclic"];
	            if (scene["b4w_use_logic_editor"])
	                nla_cyclic = false;
	            m_nla.update_scene(scene, nla_cyclic, thread.id);
	        }
	    }
	    cb_finish(thread, stage);
	}

	/**
	 * Find textures
	 */
	function find_image_users(uri) {

	    var tex_image_users = [];

	    var textures = m_tex.get_img_textures();
	    for (var i = 0; i < textures.length; i++) {
	        var tex = textures[i];
	        if (tex.uri === uri)
	            tex_image_users.push(tex);
	    }

	    return tex_image_users;
	}

	function load_speakers(bpy_data, thread, stage, cb_param, cb_finish, cb_set_rate) {
	    var dir_path = dirname(thread.filepath);

	    var sound_assets = [];
	    var spks_by_uuid = {};

	    var objects = m_obj.get_all_objects("ALL", thread.id);
	    for (var i = 0; i < objects.length; i++) {
	        var obj = objects[i];

	        if (is_loaded_spk(obj)) {
	            var uuid = obj.sfx.uuid;
	            // BACKGROUND_MUSIC speaker needs a unique resource (unique uuid)
	            if (m_sfx.get_spk_behavior(obj) == "BACKGROUND_MUSIC") {
	                uuid = m_util.gen_uuid();
	                thread.has_background_music = true;
	            } else if (m_sfx.get_spk_behavior(obj) != "NONE" && cfg_def.init_wa_context_hack)
	                thread.init_wa_context = true;

	            if (!(uuid in spks_by_uuid)) {
	                spks_by_uuid[uuid] = [];

	                var sound_path = m_util.normpath_preserve_protocol(
	                        dir_path + obj.sfx.filepath);

	                switch (m_sfx.source_type(obj)) {
	                case m_sfx.AST_ARRAY_BUFFER:
	                    var asset_type = m_assets.AT_AUDIOBUFFER;
	                    break;
	                case m_sfx.AST_HTML_ELEMENT:
	                    var asset_type = m_assets.AT_AUDIO_ELEMENT;
	                    break;
	                }
	                add_sound_path(sound_assets, uuid, asset_type, sound_path,
	                        thread.is_preloading);
	            }
	            spks_by_uuid[uuid].push(obj);
	        }
	    }

	    if (sound_assets.length) {
	        var sound_counter = 0;
	        var asset_cb = function(sound_data, id, type, url) {

	            // process only loaded sounds
	            if (sound_data) {
	                m_print.log("%cLOAD SOUND", "color: #0aa", url);

	                if (url.indexOf(_debug_resources_root) == -1)
	                    m_print.warn("sound", url, "is not from app root.");

	                var spk_objs = spks_by_uuid[id];
	                for (var i = 0; i < spk_objs.length; i++)
	                    m_sfx.update_spkobj(spk_objs[i], sound_data);
	            }

	            var rate = ++sound_counter / sound_assets.length;
	            cb_set_rate(thread, stage, rate);
	        };
	        var pack_cb = function() {
	            m_print.log("%cLOADED ALL SOUNDS", "color: #0aa");
	            cb_finish(thread, stage);
	        };

	        m_assets.enqueue(sound_assets, asset_cb, pack_cb);

	    } else
	        cb_finish(thread, stage);

	}

	function add_sound_path(sound_assets, uuid, asset_type, sound_path, is_fetch) {
	    var head_ext = m_assets.split_extension(sound_path);
	    var path_ext_low = head_ext[1].toLowerCase();
	    var ext = m_sfx.detect_audio_container(path_ext_low);

	    if (ext != "") {
	        if (ext != path_ext_low)
	            sound_path = head_ext[0] +".altconv." + ext;
	        else
	            sound_path = head_ext[0] +"." + head_ext[1];

	        sound_assets.push({ id:uuid,
	                            type:asset_type,
	                            url:sound_path,
	                            is_fetch: is_fetch
	                        });
	    }
	    else
	        m_print.error("failed to load audio file (unsupported format)", sound_path);
	}

	function is_loaded_spk(obj) {
	    return m_obj_util.is_speaker(obj) && m_sfx.source_type(obj) != m_sfx.AST_NONE;
	}

	function speakers_play(scene, data_id, force_init) {
	    var spk_objs = m_obj.get_scene_objs(scene, "SPEAKER", data_id);
	    for (var i = 0; i < spk_objs.length; i++) {
	        var sobj = spk_objs[i];

	        if (!m_obj_util.is_speaker(sobj))
	            continue;

	        // NOTE: autostart or init for mobile devices
	        if (m_sfx.is_autoplay(sobj) || force_init)
	            m_sfx.play_def(sobj);
	    }
	}

	function video_play(scene, data_id) {
	    var textures = scene._render.video_textures;
	    for (var i = 0; i < textures.length; i++) {
	        var vtex = textures[i]._render;
	        if (scene["b4w_use_nla"] && textures[i]["b4w_nla_video"] 
	                || !textures[i]["use_auto_refresh"])
	            continue;

	        if (data_id != vtex.vtex_data_id)
	            continue;

	        m_tex.reset_video(vtex);
	        m_tex.play_video(vtex);
	    }
	}

	function prepare_nla(bpy_data, thread, stage, cb_param, cb_finish, cb_set_rate) {
	    // apply nla animations before playback to prevent freezing on nla start
	    m_nla.prepare();
	    cb_finish(thread, stage);
	}

	function start_nla(bpy_data, thread, stage, cb_param, cb_finish, cb_set_rate) {
	    m_nla.start();
	    m_print.log("%cSTART NLA", "color: #0a0");
	    cb_finish(thread, stage);
	}

	function prepare_bpy_materials(bpy_data) {
	    var uuids = [];
	    bpy_data["materials"] = [];

	    var meshes = bpy_data["meshes"];
	    for (var i = 0; i < meshes.length; i++) {
	        var mesh = meshes[i];

	        if (mesh["materials"].length == 0) {
	            var def_mat = m_mat.create_default();
	            mesh["materials"].push(def_mat);

	            if (uuids.indexOf(def_mat.uuid) == -1) {
	                uuids.push(def_mat.uuid);
	                bpy_data["materials"].push(def_mat);
	            }
	        } else
	            for (var j = 0; j < mesh["materials"].length; j++) {
	                var bpy_mat = mesh["materials"][j];
	                var mat = m_mat.init_material();
	                m_mat.update_material(bpy_mat, mat);
	                mesh["materials"][j] = mat;

	                if (uuids.indexOf(mat.uuid) == -1) {
	                    uuids.push(mat.uuid);
	                    bpy_data["materials"].push(mat);
	                }
	            }
	    }
	}


	function prepare_bpy_actions(actions, data_id) {
	    for (var i = 0; i < actions.length; i++) {
	        var action = actions[i];
	        action._data_id = data_id;
	        m_anim.append_action(action);
	    }
	}

	/**
	 * Prepare LODs
	 *      find objects with LODs, also check proxies
	 *      make copy of lod objects
	 *      remove old lod objects
	 *      add new lod objects to scene/group
	 */
	function prepare_bpy_lods(bpy_data) {

	    var lods_data = {
	        lod_parents: [],
	        lod_levels_data: []
	    };

	    var scenes = bpy_data["scenes"];
	    for (var i = 0; i < scenes.length; i++) {
	        var scene = scenes[i];
	        var scene_objs = scenes[i]["objects"];

	        for (var j = 0; j < scene_objs.length; j++) {
	            var bpy_obj = scene_objs[j];
	            prepare_bpy_obj_lods(scene, scene_objs, bpy_obj, null, lods_data);
	        }
	    }

	    for (var i = 0; i < lods_data.lod_levels_data.length; i++) {
	        var lev_data = lods_data.lod_levels_data[i];
	        
	        for (var j = 0; j < lev_data.old_lods.length; j++) {
	            var old_lod = lev_data.old_lods[j];
	            var new_lod = lev_data.new_lods[j];
	            var lod_level = lev_data.lod_levels[j];
	            var scene_arr = lev_data.scene_arrays[j];
	            var objs_container_arr = lev_data.objs_container_arrays[j];

	            // The object is added to the object array and inserted into the lod_level 
	            // instead of the original object.
	            lod_level["object"] = new_lod;
	            for (var k = 0; k < objs_container_arr.length; k++)
	                m_util.append_unique(objs_container_arr[k], new_lod);

	            // The original LOD objects that will be replaced by LODs should be removed.
	            remove_bpy_object(old_lod, scene_arr);
	        }        
	    }
	}

	function prepare_bpy_obj_lods(scene, container, lod_parent_bpy, dg_parent_bpy, 
	        lods_data) {

	    var lods_num = lod_parent_bpy["lod_levels"].length;

	    for (var i = 0; i < lods_num; i++) {
	        var lod = lod_parent_bpy["lod_levels"][i];
	        var lod_obj = lod["object"];

	        if (!lod_obj)
	            continue;

	        var par_index = lods_data.lod_parents.indexOf(lod_parent_bpy);
	        if (par_index == -1) {
	            lods_data.lod_parents.push(lod_parent_bpy);
	            var levels_data = {
	                old_lods: [],
	                new_lods: [],
	                lod_levels: [],

	                // for objects shared between multiple scenes
	                scene_arrays: [],
	                objs_container_arrays: []
	            };
	            lods_data.lod_levels_data.push(levels_data);
	        } else
	            var levels_data = lods_data.lod_levels_data[par_index];

	        var lod_index = levels_data.old_lods.indexOf(lod_obj);

	        if (par_index != -1 && lod_index != -1) {
	            levels_data.scene_arrays[lod_index].push(scene);
	            levels_data.objs_container_arrays[lod_index].push(container);
	        } else {
	            var lod_obj_new = m_util.clone_object_nr(lod_obj);
	            lod_obj_new["name"] = lod_parent_bpy["name"] + "_LOD_" +
	                    String(i + 1);

	            // all lods have the same cluster data (id&center) as their main lod object
	            lod_obj_new["b4w_cluster_data"] = lod_parent_bpy["b4w_cluster_data"];

	            assign_bpy_obj_id(lod_obj_new);

	            lod_obj_new["lod_levels"] = [];

	            if (dg_parent_bpy)
	                lod_obj_new["dg_parent"] = dg_parent_bpy;

	            levels_data.old_lods.push(lod_obj);
	            levels_data.new_lods.push(lod_obj_new);
	            levels_data.lod_levels.push(lod);
	            levels_data.scene_arrays.push([scene]);
	            levels_data.objs_container_arrays.push([container]);
	        }
	    }

	    var dupli_group = lod_parent_bpy["dupli_group"];
	    if (dupli_group) {
	        var dg_objects = dupli_group["objects"];
	        for (var k = 0; k < dg_objects.length; k++) {
	            var dg_obj = dg_objects[k];

	            prepare_bpy_obj_lods(scene, dg_objects, dg_obj, lod_parent_bpy,
	                    lods_data);
	        }
	    }
	}

	/**
	 * Calculate upper limit for number of bones used in vertex shader
	 * to minimize shader variations
	 */
	function calc_max_bones(objects) {

	    var upper_max_bones = -1;
	    var blending_max_bones = -1;

	    var gl_max_bones = m_anim.get_max_bones();

	    // calc
	    for (var i = 0; i < objects.length; i++) {
	        var obj = objects[i];
	        var render = obj.render;

	        if (!(m_obj_util.is_mesh(obj) && render.is_skinning))
	            continue;

	        var max_bones = render.max_bones;

	        if (max_bones > upper_max_bones)
	            upper_max_bones = max_bones;

	        if (gl_max_bones >= max_bones && max_bones > blending_max_bones)
	            blending_max_bones = max_bones;

	    }

	    // assign
	    for (var i = 0; i < objects.length; i++) {
	        var obj = objects[i];
	        var render = obj.render;

	        if (!(m_obj_util.is_mesh(obj) && render.is_skinning))
	            continue;

	        render.frames_blending = true;

	        if (upper_max_bones < gl_max_bones)
	            render.max_bones = upper_max_bones;
	        else if (render.max_bones <= gl_max_bones)
	            render.max_bones = blending_max_bones;
	        else {
	            m_print.warn("too many bones for \"" + obj.name + "\" / " +
	                render.max_bones + " bones (max " + gl_max_bones +
	                " with blending, " + 2 * gl_max_bones + " without blending)." 
	                + " Blending between frames will be disabled.");
	            render.max_bones = upper_max_bones;
	            render.frames_blending = false;
	        }
	        render.frames_blending = render.frames_blending
	                && !cfg_anim.frames_blending_hack;
	    }
	}

	function prepare_lod_objects(bpy_objects) {

	    for (var i = 0; i < bpy_objects.length; i++) {
	        var bpy_obj = bpy_objects[i];
	        var obj = bpy_obj._object;
	        var main_lod_render = obj.render;

	        if (!m_obj_util.is_mesh(obj) && !m_obj_util.is_empty(obj))
	            continue;

	        var lods_num = bpy_obj["lod_levels"].length;
	        if (!lods_num)
	            continue;

	        var lod_levels = [bpy_obj];
	        var lod_dists = [0];
	        var last_dist = Infinity;
	        for (var j = 0; j < lods_num; j++) {
	            var bpy_lod = bpy_obj["lod_levels"][j]["object"];
	            var min_dist = bpy_obj["lod_levels"][j]["distance"];
	            if (!bpy_lod) {
	                last_dist = min_dist;
	                break;
	            }

	            lod_levels.push(bpy_lod);
	            lod_dists.push(min_dist);
	        }
	        lod_dists.push(last_dist);

	        // assign render lod properties
	        for (var j = 0; j < lod_levels.length; j++) {
	            var bpy_lod = lod_levels[j];
	            var lod = bpy_lod._object;
	            var render = lod.render;

	            render.is_lod = true;

	            if (main_lod_render.type == "DYNAMIC" && j > 0)
	                m_vec3.subtract(main_lod_render.bs_world.center, 
	                        render.bs_world.center, render.main_lod_offset);

	            render.lod_dist_min = lod_dists[j];
	            render.lod_dist_max = lod_dists[j + 1];

	            var prev_level_spread = j == 0 ? 0 : lod_dists[j] - lod_dists[j - 1];
	            var curr_level_spread = lod_dists[j + 1] - lod_dists[j];
	            var next_level_spread = j == lod_levels.length - 1 ? Infinity : 
	                    lod_dists[j + 2] - lod_dists[j + 1];

	            render.lod_lower_border_range = Math.min(prev_level_spread, 
	                    curr_level_spread);
	            render.lod_upper_border_range = Math.min(curr_level_spread, 
	                    next_level_spread);
	        }

	    }
	}

	function prepare_vehicles(objects) {

	    for (var i = 0; i < objects.length; i++) {
	        var obj_i = objects[i];


	        if (!obj_i.is_vehicle)
	            continue;

	        var vh_set_i = obj_i.vehicle_settings;

	        if (vh_set_i.part == "CHASSIS") {

	            obj_i.vehicle = {};

	            obj_i.vehicle.force_max = vh_set_i.force_max;
	            obj_i.vehicle.brake_max = vh_set_i.brake_max;
	            obj_i.vehicle.suspension_compression = vh_set_i.suspension_compression;
	            obj_i.vehicle.suspension_stiffness = vh_set_i.suspension_stiffness;
	            obj_i.vehicle.suspension_damping = vh_set_i.suspension_damping;
	            obj_i.vehicle.wheel_friction = vh_set_i.wheel_friction;
	            obj_i.vehicle.roll_influence = vh_set_i.roll_influence;
	            obj_i.vehicle.max_suspension_travel_cm = vh_set_i.max_suspension_travel_cm;
	            obj_i.vehicle.engine_force = 0;
	            obj_i.vehicle.brake_force = 1;
	            obj_i.vehicle.steering = 0;
	            obj_i.vehicle.speed = 0;

	            // links to wheel objects
	            obj_i.vehicle.props = [];
	            obj_i.vehicle.prop_offsets = [];
	            obj_i.vehicle.steering_wheel = null;

	            // check dupli groups for car objects
	            var dg_parent = m_obj_util.get_dg_parent(obj_i);
	            if (dg_parent)
	                // NOTE: not the smartest way to do it
	                var car_objects = m_obj_util.get_dg_objects(dg_parent, objects);
	            else
	                var car_objects = objects;

	            for (var j = 0; j < car_objects.length; j++) {
	                var obj_j = car_objects[j];

	                if (!obj_j.is_vehicle)
	                    continue;

	                var vh_set_j = obj_j.vehicle_settings;

	                if (m_phy.is_car_wheel(obj_j) && vh_set_i.name == vh_set_j.name) {
	                    var w_index = m_phy.wheel_index(obj_j.vehicle_settings.part);
	                    obj_i.vehicle.props[w_index] = obj_j;

	                    obj_i.vehicle.prop_offsets[w_index] = new Float32Array(8);

	                } else if (m_phy.is_vehicle_steering_wheel(obj_j) && vh_set_i.name == vh_set_j.name) {
	                    obj_i.vehicle.steering_wheel = obj_j;

	                    obj_i.vehicle.steering_max = vh_set_j.steering_max;
	                    obj_i.vehicle.steering_ratio = vh_set_j.steering_ratio;
	                    obj_i.vehicle.inverse_control = vh_set_j.inverse_control;

	                    var wtsr_inv = m_tsr.invert(obj_i.render.world_tsr,
	                            m_tsr.create());
	                    var steering_wheel_tsr = m_tsr.multiply(wtsr_inv,
	                            obj_j.render.world_tsr, wtsr_inv);
	                    obj_i.vehicle.steering_wheel_tsr = steering_wheel_tsr;

	                    var steering_wheel_axis = new Float32Array([1,0,0]);
	                    m_tsr.transform_dir_vec3(steering_wheel_axis, steering_wheel_tsr,
	                            steering_wheel_axis);
	                    obj_i.vehicle.steering_wheel_axis = steering_wheel_axis;
	                } else if (m_phy.is_vehicle_speedometer(obj_j) && vh_set_i.name == vh_set_j.name) {
	                    obj_i.vehicle.speedometer = obj_j;

	                    obj_i.vehicle.speed_ratio = vh_set_j.speed_ratio;
	                    obj_i.vehicle.max_speed_angle = vh_set_j.max_speed_angle;

	                    var wtsr_inv = m_tsr.invert(obj_i.render.world_tsr,
	                            m_tsr.create());
	                    var speedometer_tsr = m_tsr.multiply(wtsr_inv,
	                            obj_j.render.world_tsr, wtsr_inv);
	                    obj_i.vehicle.speedometer_tsr = speedometer_tsr;

	                    var speedometer_axis = new Float32Array([1,0,0]);
	                    m_tsr.transform_dir_vec3(speedometer_axis, speedometer_tsr,
	                            speedometer_axis);
	                    obj_i.vehicle.speedometer_axis = speedometer_axis;
	                } else if (m_phy.is_vehicle_tachometer(obj_j) && vh_set_i.name == vh_set_j.name) {
	                    obj_i.vehicle.tachometer = obj_j;

	                    obj_i.vehicle.delta_tach_angle = vh_set_j.delta_tach_angle;

	                    var wtsr_inv = m_tsr.invert(obj_i.render.world_tsr,
	                            m_tsr.create());
	                    var tachometer_tsr = m_tsr.multiply(wtsr_inv,
	                            obj_j.render.world_tsr, wtsr_inv);
	                    obj_i.vehicle.tachometer_tsr = tachometer_tsr;

	                    var tachometer_axis = new Float32Array([1,0,0]);
	                    m_tsr.transform_dir_vec3(tachometer_axis, tachometer_tsr,
	                            tachometer_axis);
	                    obj_i.vehicle.tachometer_axis = tachometer_axis;
	                }
	            }

	            if (obj_i.vehicle.props.length != 4)
	                m_util.panic("Not enough wheels for chassis " + obj_i.name);

	        } else if (vh_set_i.part == "HULL") {

	            obj_i.vehicle = {};
	            obj_i.vehicle.props = [];
	            obj_i.vehicle.prop_offsets = [];

	            obj_i.vehicle.force_max = vh_set_i.force_max;
	            obj_i.vehicle.brake_max = vh_set_i.brake_max;
	            obj_i.vehicle.floating_factor = vh_set_i.floating_factor;
	            obj_i.vehicle.water_lin_damp = vh_set_i.water_lin_damp;
	            obj_i.vehicle.water_rot_damp = vh_set_i.water_rot_damp;
	            obj_i.vehicle.engine_force = 0;
	            obj_i.vehicle.brake_force = 1;
	            obj_i.vehicle.steering = 0;
	            obj_i.vehicle.speed = 0;

	            // links to bob objects
	            obj_i.vehicle.steering_wheel = null;

	            // check dupli groups for boat objects
	            var dg_parent = m_obj_util.get_dg_parent(obj_i);
	            if (dg_parent)
	                // NOTE: not the smartest way to do it
	                var boat_objects = m_obj_util.get_dg_objects(dg_parent, objects);
	            else
	                var boat_objects = objects;

	            for (var j = 0; j < boat_objects.length; j++) {
	                var obj_j = boat_objects[j];

	                if (!obj_j.is_vehicle)
	                    continue;

	                var vh_set_j = obj_j.vehicle_settings;

	                if (m_phy.is_boat_bob(obj_j) && vh_set_i.name == vh_set_j.name) {
	                    obj_i.vehicle.props.push(obj_j);
	                    obj_i.vehicle.prop_offsets.push(new Float32Array(8));

	                } else if (m_phy.is_vehicle_steering_wheel(obj_j) && vh_set_i.name == vh_set_j.name) {
	                    obj_i.vehicle.steering_wheel = obj_j;

	                    obj_i.vehicle.steering_max = vh_set_j.steering_max;
	                    obj_i.vehicle.steering_ratio = vh_set_j.steering_ratio;
	                    obj_i.vehicle.inverse_control = vh_set_j.inverse_control;

	                    var wtsr_inv = m_tsr.invert(obj_i.render.world_tsr,
	                            m_tsr.create());
	                    var steering_wheel_tsr = m_tsr.multiply(wtsr_inv,
	                            obj_j.render.world_tsr, wtsr_inv);
	                    obj_i.vehicle.steering_wheel_tsr = steering_wheel_tsr;
	                    var steering_wheel_axis = new Float32Array([1,0,0]);
	                    m_tsr.transform_dir_vec3(steering_wheel_axis, steering_wheel_tsr,
	                            steering_wheel_axis);
	                    obj_i.vehicle.steering_wheel_axis = steering_wheel_axis;
	                } else if (m_phy.is_vehicle_speedometer(obj_j) && vh_set_i.name == vh_set_j.name) {
	                    obj_i.vehicle.speedometer = obj_j;

	                    obj_i.vehicle.speed_ratio = vh_set_j.speed_ratio;
	                    obj_i.vehicle.max_speed_angle = vh_set_j.max_speed_angle;

	                    var wtsr_inv = m_tsr.invert(obj_i.render.world_tsr,
	                            m_tsr.create());
	                    var speedometer_tsr = m_tsr.multiply(wtsr_inv,
	                            obj_j.render.world_tsr, wtsr_inv);
	                    obj_i.vehicle.speedometer_tsr = speedometer_tsr;

	                    var speedometer_axis = new Float32Array([1,0,0]);
	                    m_tsr.transform_dir_vec3(speedometer_axis, speedometer_tsr,
	                            speedometer_axis);
	                    obj_i.vehicle.speedometer_axis = speedometer_axis;
	                } else if (m_phy.is_vehicle_tachometer(obj_j) && vh_set_i.name == vh_set_j.name) {
	                    obj_i.vehicle.tachometer = obj_j;

	                    obj_i.vehicle.delta_tach_angle = vh_set_j.delta_tach_angle;

	                    var wtsr_inv = m_tsr.invert(obj_i.render.world_tsr,
	                            m_tsr.create());
	                    var tachometer_tsr = m_tsr.multiply(wtsr_inv,
	                            obj_j.render.world_tsr, wtsr_inv);
	                    obj_i.vehicle.tachometer_tsr = tachometer_tsr;

	                    var tachometer_axis = new Float32Array([1,0,0]);
	                    m_tsr.transform_dir_vec3(tachometer_axis, tachometer_tsr,
	                            tachometer_axis);
	                    obj_i.vehicle.tachometer_axis = tachometer_axis;
	                }
	            }
	        }
	    }
	}

	function prepare_floaters(objects) {
	    for (var i = 0; i < objects.length; i++) {
	        var obj_i = objects[i];

	        if (!obj_i.is_floating)
	            continue;

	        var fl_set_i = obj_i.floating_settings;

	        if (fl_set_i.part == "MAIN_BODY") {
	            obj_i.floater = {};
	            obj_i.floater.floating_factor = fl_set_i.floating_factor;
	            obj_i.floater.water_lin_damp = fl_set_i.water_lin_damp;
	            obj_i.floater.water_rot_damp = fl_set_i.water_rot_damp;

	            // links to bob objects
	            obj_i.floater.bobs = [];

	            // check dupli groups for floater objects
	            var dg_parent = m_obj_util.get_dg_parent(obj_i);
	            if (dg_parent)
	                // NOTE: not the smartest way to do it
	                var bob_objects = m_obj_util.get_dg_objects(dg_parent, objects);
	            else
	                var bob_objects = objects;

	            for (var j = 0; j < bob_objects.length; j++) {
	                var obj_j = bob_objects[j];

	                if (!obj_j.is_floating)
	                    continue;

	                var fl_set_j = obj_j.floating_settings;

	                if (m_phy.is_floater_bob(obj_j) && fl_set_i.name ==
	                        fl_set_j.name) {
	                    obj_i.floater.bobs.push(obj_j);
	                    obj_j.bob_synchronize_pos = obj_j.floating_settings.synchronize_position;
	                }
	            }
	        }
	    }
	}

	/**
	 * Remove objects from given scenes (also from dupli_group)
	 * removing of already removed objects also supported
	 */
	function remove_bpy_object(remobj, bpy_scenes) {

	    for (var i = 0; i < bpy_scenes.length; i++) {
	        var bpy_objs = bpy_scenes[i]["objects"];

	        // from dupli groups
	        for (var j = 0; j < bpy_objs.length; j++) {
	            var bpy_obj = bpy_objs[j];

	            var dupli_group = bpy_obj["dupli_group"];
	            if (dupli_group)
	                remove_obj_from_dupli_group_r(remobj, dupli_group);
	        }

	        // from scene
	        var obj_index = bpy_objs.indexOf(remobj);
	        if (obj_index > -1)
	            bpy_objs.splice(obj_index, 1);
	    }
	}

	function remove_obj_from_dupli_group_r(remobj, dupli_group) {
	    var dg_objects = dupli_group["objects"];
	    var obj_index = dg_objects.indexOf(remobj);
	    if (obj_index > -1)
	        dg_objects.splice(obj_index, 1);

	    for (var i = 0; i < dg_objects.length; i++) {
	        var bpy_obj = dg_objects[i];
	        dupli_group = bpy_obj["dupli_group"];
	        if (dupli_group)
	            remove_obj_from_dupli_group_r(remobj, dupli_group);
	    }
	}

	function wait_physics_workers(bpy_data, thread, stage, cb_param, cb_finish,
	        cb_set_rate) {

	    var loaded = true;

	    for (var i = 0; i < bpy_data["scenes"].length; i++) {
	        var scene = bpy_data["scenes"][i];

	        if (!m_phy.check_worker_loaded(scene)) {
	            loaded = false;
	            break;
	        }
	    }

	    if (loaded) {
	        cb_finish(thread, stage);
	        m_print.log("%cPHYSICS READY", "color: #0a0");
	    }
	}

	function add_physics_objects(bpy_data, thread, stage, cb_param, cb_finish,
	        cb_set_rate) {

	    for (var i = 0; i < bpy_data["scenes"].length; i++) {
	        var scene = bpy_data["scenes"][i];

	        if (thread.is_primary)
	            var enable_physics = m_phy.scene_has_physics(scene);
	        else {
	            var enable_physics = m_phy.scene_has_physics(_primary_scene) ||
	                    m_phy.scene_has_physics(scene);

	            // secondary data objects are on primary scene already
	            scene = _primary_scene;
	        }

	        if (cfg_phy.enabled && enable_physics) {
	            for (var j = 0; j < ADD_PHY_TYPES.length; j++) {
	                var type = ADD_PHY_TYPES[j];

	                var sobjs = m_obj.get_scene_objs(scene, type, thread.id);
	                for (var k = 0; k < sobjs.length; k++) {
	                    var obj = sobjs[k];
	                    // add only currently loaded objects
	                    if (obj.render.data_id == thread.id) {
	                        m_phy.append_object(obj, scene);
	                        // turn off physics for secondary loaded objects
	                        if (thread.load_hidden && m_phy.obj_has_physics(obj))
	                            m_phy.disable_simulation(obj);
	                    }
	                }
	            }
	        }
	    }
	    cb_finish(thread, stage);
	}

	/**
	 * Load shoremap image on corresponding scenes
	 */
	function load_shoremap(bpy_data, thread, stage, cb_param, cb_finish,
	        cb_set_rate) {

	    var img_by_uri = {};
	    var image_assets = [];
	    var bpy_scenes = bpy_data["scenes"];

	    for (var i = 0; i < bpy_data["scenes"].length; i++) {

	        var scene = bpy_scenes[i];

	        if (scene._render.water_params) {

	            var shoremap_image = scene._render.water_params.shoremap_image;

	            if (shoremap_image && shoremap_image["source"] === "FILE") {
	                var uuid = shoremap_image["uuid"];
	                var dir_path = dirname(thread.filepath);
	                var image_path = m_util.normpath_preserve_protocol(dir_path + 
	                        shoremap_image["filepath"]);

	                if (shoremap_image._comp_method)
	                    var asset_type = m_assets.AT_ARRAYBUFFER;
	                else
	                    var asset_type = m_assets.AT_IMAGE_ELEMENT;

	                image_assets.push({id:uuid, type:asset_type, url:image_path});
	                img_by_uri[uuid] = shoremap_image;
	            }
	        }
	    }
	    if (image_assets.length) {
	        var asset_cb = function(image_data, id, type, url) {
	            if (!image_data) { // image not loaded
	                var image = img_by_uri[id];
	                for (var i = 0; i < bpy_scenes.length; i++) {
	                    var scene = bpy_scenes[i];
	                    var shr_image = scene._render.water_params.shoremap_image;
	                    if (shr_image === image) {
	                        scene._render.water_params.shoremap_image = null;
	                        m_print.warn("image", shr_image["filepath"],
	                            " was not found. Disabling water shore effects.");
	                    }
	                }
	                return;
	            }

	            var show_path_warning = true;
	            print_image_info(image_data, url, show_path_warning);
	            var tex_users = find_image_users(id);
	            for (var i = 0; i < tex_users.length; i++) {
	                var tex_user = tex_users[i];
	                m_tex.update_texture(tex_user, image_data, thread.id);
	            }

	            for (var i = 0; i < bpy_scenes.length; i++) {
	                var scene = bpy_scenes[i];
	                if (scene._render.water_params) {
	                    var shr_image = scene._render.water_params.shoremap_image;
	                    if (shr_image === shoremap_image)
	                        update_scene_shore_distance(image_data, shoremap_image, scene);
	                }
	            }
	        };
	        var pack_cb = function() {
	            cb_finish(thread, stage);
	        };
	        m_assets.enqueue(image_assets, asset_cb, pack_cb);
	    } else
	        cb_finish(thread, stage);
	}

	function update_scene_shore_distance(html_image, shoremap, scene) {
	    var tmpcanvas = document.createElement("canvas");
	    var width  = shoremap.size[0];
	    var height = shoremap.size[1];
	    tmpcanvas.width  = width;
	    tmpcanvas.height = height;

	    var ctx = tmpcanvas.getContext("2d");
	    ctx.drawImage(html_image, 0, 0);

	    var image_data = ctx.getImageData(0, 0, width, height);

	    var dist_color = image_data.data;

	    var bit_shift = new Float32Array(4);
	    bit_shift[0] = 1.0 / (255.0 * 255.0 * 255.0);
	    bit_shift[1] = 1.0 / (255.0 * 255.0);
	    bit_shift[2] = 1.0 / (255.0);
	    bit_shift[3] = 1.0;

	    var arr_size = width * height;
	    var shore_distances = new Float32Array(arr_size);
	    // unpack dist from depth color (g,b channels)
	    for (var j = 0; j < arr_size; j++) {
	        shore_distances[j] = bit_shift[1] * dist_color[4 * j + 2]
	                           + bit_shift[2] * dist_color[4 * j + 3];
	    }
	    scene._render.shore_distances = shore_distances;
	}

	// SMAA - Enhanced Subpixel Morphological Antialiasing
	function load_smaa_textures(bpy_data, thread, stage, cb_param, cb_finish,
	        cb_set_rate) {

	    var scene = bpy_data["scenes"][0];

	    var subs_smaa_arr = [];
	    var smaa_passes_names = [m_subs.SMAA_EDGE_DETECTION,
	                             m_subs.SMAA_BLENDING_WEIGHT_CALCULATION,
	                             m_subs.SMAA_NEIGHBORHOOD_BLENDING,
	                             m_subs.SMAA_RESOLVE];

	    for (var i = 0; i < smaa_passes_names.length; i++) {
	        var smaa_sub = m_scenes.get_subs(scene, smaa_passes_names[i]);
	        if (smaa_sub)
	            subs_smaa_arr.push(smaa_sub);
	    }

	    if (!subs_smaa_arr.length) {
	        cb_finish(thread, stage);
	        return;
	    }

	    var smaa_images = [];

	    var asset_type = m_assets.AT_IMAGE_ELEMENT;

	    var search_texture_path = m_cfg.paths.smaa_search_texture_path;
	    smaa_images.push({id:"SEARCH_TEXTURE", type:asset_type,
	                      url:search_texture_path, is_fetch:thread.is_preloading});

	    var area_texture_path = m_cfg.paths.smaa_area_texture_path;
	    smaa_images.push({id:"AREA_TEXTURE", type:asset_type,
	                      url:area_texture_path, is_fetch:thread.is_preloading});

	    for (var i = 0; i < subs_smaa_arr.length; i++) {
	        var subs_smaa = subs_smaa_arr[i];

	        if (subs_smaa.type == m_subs.SMAA_BLENDING_WEIGHT_CALCULATION) {
	            var slinks_internal = subs_smaa.slinks_internal;

	            for (var j = 0; j < slinks_internal.length; j++) {
	                var slink = slinks_internal[j];
	                if (slink.to == "u_search_tex")
	                    var search_texture = slink.texture;
	                else if (slink.to == "u_area_tex")
	                    var area_texture = slink.texture;
	            }
	            break;
	        }
	    }

	    if (smaa_images.length) {
	        var asset_cb = function(image_data, id, type, url) {

	            if (!image_data) // image not loaded
	                return;

	            var show_path_warning = false;
	            print_image_info(image_data, url, show_path_warning);

	            if (id == "SEARCH_TEXTURE")
	                var texture = search_texture;
	            else
	                var texture = area_texture;

	            texture.source = "IMAGE";

	            m_tex.update_texture(texture, image_data, thread.id);
	            m_tex.set_filters(texture, m_tex.TF_LINEAR, m_tex.TF_LINEAR);
	        };
	        var pack_cb = function() {
	            cb_finish(thread, stage);
	        };
	        m_assets.enqueue(smaa_images, asset_cb, pack_cb);
	    } else
	        cb_finish(thread, stage);
	}

	/**
	 * Add objects to scenes and finish loading
	 */
	function prepare_objects_adding(bpy_data, thread, stage, cb_param, cb_finish,
	        cb_set_rate) {

	    for (var i = 0; i < bpy_data["scenes"].length; i++) {
	        var scene = bpy_data["scenes"][i];

	        // secondary data objects are on primary scene already
	        if (!thread.is_primary)
	            scene = _primary_scene;

	        // firstly, process lamps
	        var lamps = m_obj.get_scene_objs(scene, "LAMP", thread.id);
	        for (var j = 0; j < lamps.length; j++) {
	            var lamp = lamps[j];

	            // add only currently loaded objects
	            if (lamp.render.data_id == thread.id)
	                cb_param.added_objects.push({
	                    scene: scene,
	                    obj: lamp
	                });
	        }

	        // all other objects are processed after lamps
	        var objs = m_obj.get_scene_objs(scene, "ALL", thread.id);
	        for (var j = 0; j < objs.length; j++) {
	            var obj = objs[j];

	            if (obj.type == "LAMP")
	                continue;

	            // add only currently loaded objects
	            if (obj.render.data_id == thread.id) {
	                if (thread.load_hidden && m_obj_util.is_mesh(obj))
	                    m_scenes.change_visibility(obj, true);
	                cb_param.added_objects.push({
	                    scene: scene,
	                    obj: obj
	                });
	            }
	        }
	    }
	}

	function add_objects(bpy_data, thread, stage, cb_param, cb_finish,
	        cb_set_rate) {

	    var obj_data = cb_param.added_objects;
	    var obj_counter = cb_param.obj_counter;

	    if (obj_data.length) {
	        var obj = obj_data[obj_counter].obj;
	        var scene = obj_data[obj_counter].scene;
	        var sc_data = m_obj_util.get_scene_data(obj, scene);

	        m_scenes.append_object(scene, obj);
	        if (obj.anchor && !scene._render.anaglyph_use && !scene._render.sidebyside_use)
	            m_anchors.append(obj);
	        var rate = ++cb_param.obj_counter / obj_data.length;

	        if (obj.render.hide_children)
	            m_scenes.change_visibility_rec(obj, true);

	        var cube_refl_subs = sc_data.cube_refl_subs;
	        if (obj.render.cube_reflection_id != -1 && cube_refl_subs){
	            var center = m_vec3.copy(obj.render.bs_world.center, _vec3_tmp);
	            m_scenes.update_cube_reflect_subs(cube_refl_subs, center);
	        }

	        var refl_objs = obj.reflective_objs;
	        if (refl_objs.length && scene._render.reflection_params) {
	            var rp_trans = m_tsr.get_trans_view(obj.render.world_tsr);
	            var rp_quat = m_tsr.get_quat_view(obj.render.world_tsr);
	            var refl_subs = sc_data.plane_refl_subs;
	            for (var i = 0; i < refl_subs.length; i++) {
	                m_scenes.update_plane_reflect_subs(refl_subs[i], rp_trans, rp_quat);
	                m_obj_util.update_refl_objects(refl_objs,
	                                               refl_subs[i].camera.reflection_plane);
	           }
	        }
	    } else
	        var rate = 1;

	    cb_set_rate(thread, stage, rate);
	}

	function end_objects_adding(bpy_data, thread, stage, cb_param, cb_finish,
	        cb_set_rate) {
	    if (thread.is_primary) {
	        var scene_main = m_scenes.get_main();
	        m_scenes.update_world_texture(scene_main);
	        var scenes = m_scenes.get_rendered_scenes();
	        for (var i = 0; i < scenes.length; i++) {
	            var scene = scenes[i];
	            m_scenes.update_world_texture(scene);
	            m_scenes.prepare_rendering(scene, scene_main);
	        }
	        m_scenes.set_active(scene_main);
	    } else
	        m_scenes.update_scene_permanent_uniforms(_primary_scene);

	    var objects = m_obj.get_all_objects("ALL", thread.id);
	    m_obj.update_objects_dynamics(objects);

	    cb_finish(thread, stage);
	}

	function init_cube_sky_dynamic_props(bpy_data, thread, stage, cb_param, cb_finish,
	        cb_set_rate) {

	    if (thread.is_primary) {
	        var scenes = m_scenes.get_rendered_scenes();
	        for (var i = 0; i < scenes.length; i++) {
	            var scene = scenes[i];
	            var worlds = m_obj.get_scene_objs(scene, "WORLD", 0);
	            for (var j = 0; j < worlds.length; j++) {
	                var world = worlds[j];
	                m_scenes.init_cube_sky_dim(scene, world);
	                m_scenes.update_world_texture(scene);
	            }
	        }
	    }

	    cb_finish(thread, stage);
	}

	function init_logic_nodes(bpy_data, thread, stage, cb_param, cb_finish,
	        cb_set_rate) {

	    if (thread.is_primary) {
	        var scenes = m_scenes.get_rendered_scenes();
	        for (var i = 0; i < scenes.length; i++) {
	            var scene = scenes[i];
	            if (scene["b4w_use_logic_editor"])
	                m_lnodes.init_logic(scene, thread.id);
	        }
	    }

	    cb_finish(thread, stage);
	}

	function synchronize_media(bpy_data, thread, stage, cb_param, cb_finish,
	        cb_set_rate) {

	    if (thread.is_primary)
	        for (var i = 0; i < bpy_data["scenes"].length; i++) {
	            video_play(bpy_data["scenes"][i], thread.id);
	            speakers_play(bpy_data["scenes"][i], thread.id, false);
	        }
	    else { 
	        video_play(_primary_scene, thread.id);
	        speakers_play(_primary_scene, thread.id, false); 
	    }

	    cb_finish(thread, stage);
	}

	exports.setup_canvas = function(canvas) {
	    _canvas = canvas;
	};

	function mobile_media_start(bpy_data, thread, stage, cb_param, cb_finish,
	        cb_set_rate) {

	    // NOTE: not all bpy data can be dropped on this stage at the moment
	    drop_bpy_data(bpy_data, thread);
	    if (cfg_def.media_auto_activation && (thread.has_video_textures || 
	            thread.has_background_music || thread.init_wa_context)) {
	        if (!_play_media_btn)
	            create_media_controls(bpy_data, cb_finish, thread, stage);
	    } else
	        cb_finish(thread, stage);
	}

	function create_media_controls(bpy_data, cb_finish, thread, stage) {
	    var canvas_container = _canvas.parentElement;
	    _canvas_container_z_index = canvas_container.style.zIndex;
	    canvas_container.style.zIndex = "999";

	    _play_media_btn = document.createElement("div");
	    _play_media_btn.style.position = "relative";
	    _play_media_btn.style.height = "88px";
	    _play_media_btn.style.width = "88px";

	    var h = Math.round(_canvas.offsetHeight / 2 - 44);
	    var w = Math.round(_canvas.offsetWidth / 2 - 44);

	    _play_media_btn.style.top = h.toString() + "px";
	    _play_media_btn.style.left = w.toString() + "px";
	    _play_media_btn.style.backgroundImage = "url('" + PLAY_MEDIA_IMAGE_MOBILE + "')";
	    _play_media_btn.style.backgroundSize = "88px";

	    _play_media_bkg = document.createElement("div");
	    _play_media_bkg.style.position = "relative";
	    _play_media_bkg.style.height = _canvas.offsetHeight.toString() + "px";
	    _play_media_bkg.style.width = _canvas.offsetWidth.toString() + "px";
	    _play_media_bkg.style.background = "rgba(0, 0, 0, 0.5)";
	    _play_media_bkg.style.zIndex = "999";

	    canvas_container.appendChild(_play_media_bkg);

	    _play_media_bkg.appendChild(_play_media_btn);

	    _init_media = function() {

	        if (thread.has_video_textures) {
	            m_tex.play();
	            m_tex.pause();
	            m_tex.reset();
	        }

	        if (thread.has_background_music) {
	            if (thread.is_primary)
	                for (var i = 0; i < bpy_data["scenes"].length; i++)
	                    speakers_play(bpy_data["scenes"][i], thread.id, true);
	            else
	                speakers_play(_primary_scene, thread.id, true);
	            m_sfx.pause();
	        }

	        if (thread.init_wa_context) {
	            m_sfx.play_empty_sound();
	        }

	        remove_media_controls();
	        cb_finish(thread, stage);
	    };

	    m_input.add_click_listener(_play_media_btn, _init_media);
	}

	function remove_media_controls() {
	    if (_play_media_btn) {
	        var canvas_container = _canvas.parentElement;
	        canvas_container.style.zIndex = _canvas_container_z_index;
	        m_input.remove_click_listener(_play_media_btn, _init_media);
	        _play_media_bkg.removeChild(_play_media_btn);
	        canvas_container.removeChild(_play_media_bkg);
	        _play_media_bkg = null;
	        _play_media_btn = null;
	        _canvas_container_z_index = 0;
	    }
	}

	exports.update_media_controls = function (width, height) {
	    if(_play_media_btn) {
	        _play_media_bkg.style.height = height.toString() + "px";
	        _play_media_bkg.style.width = width.toString() + "px";

	        var h = Math.round(height / 2 - 44);
	        var w = Math.round(width / 2 - 44);

	        _play_media_btn.style.top = h.toString() + "px";
	        _play_media_btn.style.left = w.toString() + "px";
	    }
	};

	/**
	 * path helper function
	 */
	function dirname(path) {
	    var dirname = path.split("/").slice(0, -1).join("/");
	    if (dirname)
	        dirname += "/";
	    return dirname;
	}

	/**
	 * Stage properties.
	 * priority: 
	 *      ASYNC_PRIORITY - stage can be executed asynchronously alongside with other stages
	 *          (relevant for stages which perform http requests)
	 *      SYNC_PRIORITY - such stages are executed in a strict order one-by-one
	 * background_loading:
	 *      - stage can be executed after the rendering starts
	 * inputs:
	 *      - previous stages which are needed to be finished before this stage can start
	 * is_resource:
	 *      - stage will be omitted if "do_not_load_resources" flag is set
	 * relative_size:
	 *      - a value which represents amount of time required to finish this stage
	 * primary_only:
	 *      - stage is executed only in the primary thread, it's omitted during the dynamic loading
	 * cb_before: 
	 *      - a stage callback which is processed first during the stage execution
	 *          call cb_finish as follows: cb_finish(thread, stage) to finish the stage
	 *          (suitable for preparatory actions)
	 * cb_loop:
	 *      - a stage callback which is called multiple times within a loop; 
	 *          call cb_set_rate callback as follows: cb_set_rate(thread, stage, 1) to break the loop, 
	 *          call cb_finish as follows: cb_finish(thread, stage) to finish the stage
	 *          (suitable for cyclical actions which can be breaked into a separate steps;
	 *          not needed for asynchronous resources(speakers, textures, ...))
	 * cb_after: 
	 *      - a stage callback which is processed last during the stage execution
	 *          call cb_finish as follows: cb_finish(thread, stage) to finish the stage
	 *          (suitable for finishing actions)
	 * cb_param:
	 *      - an utility parameter which is available inside all of the stage callbacks
	 *          (can be used to translate some data through the stage callbacks)
	 */
	exports.load = function(path, loaded_cb, stageload_cb, wait_complete_loading,
	        load_hidden) {

	    var stages = {
	        "load_main": {
	            priority: m_loader.ASYNC_PRIORITY,
	            background_loading: false,
	            inputs: [],
	            is_resource: false,
	            relative_size: 500,
	            primary_only: false,
	            cb_before: load_main
	        },
	        "duplicate_objects": {
	            priority: m_loader.SYNC_PRIORITY,
	            background_loading: false,
	            inputs: ["load_main"],
	            is_resource: false,
	            relative_size: 50,
	            primary_only: false,
	            cb_before: duplicate_objects
	        },
	        "load_binaries": {
	            priority: m_loader.ASYNC_PRIORITY,
	            background_loading: false,
	            inputs: ["load_main"],
	            is_resource: false,
	            relative_size: 500,
	            primary_only: false,
	            cb_before: load_binaries
	        },
	        "wait_for_shaders": {
	            priority: m_loader.SYNC_PRIORITY,
	            background_loading: false,
	            inputs: [],
	            is_resource: false,
	            relative_size: 50,
	            primary_only: true,
	            cb_loop: wait_for_shaders
	        },
	        "prepare_bindata": {
	            priority: m_loader.SYNC_PRIORITY,
	            background_loading: false,
	            inputs: ["duplicate_objects", "load_binaries"],
	            is_resource: false,
	            relative_size: 100,
	            primary_only: false,
	            cb_before: prepare_bindata
	        },
	        "prepare_bpy_data": {
	            priority: m_loader.SYNC_PRIORITY,
	            background_loading: false,
	            inputs: ["duplicate_objects", "prepare_bindata"],
	            is_resource: false,
	            relative_size: 100,
	            primary_only: false,
	            cb_before: prepare_bpy_data
	        },
	        "process_objects": {
	            priority: m_loader.SYNC_PRIORITY,
	            background_loading: false,
	            inputs: ["prepare_bpy_data"],
	            is_resource: false,
	            relative_size: 150,
	            primary_only: false,
	            cb_before: process_objects
	        },
	        "process_scenes": {
	            priority: m_loader.SYNC_PRIORITY,
	            background_loading: false,
	            inputs: ["process_objects", "wait_for_shaders"],
	            is_resource: false,
	            relative_size: 300,
	            primary_only: false,
	            cb_before: process_scenes
	        },
	        "load_smaa_textures": {
	            priority: m_loader.ASYNC_PRIORITY,
	            background_loading: false,
	            inputs: ["process_scenes"],
	            is_resource: false,
	            relative_size: 30,
	            primary_only: true,
	            cb_before: load_smaa_textures
	        },
	        "load_shoremap": {
	            priority: m_loader.ASYNC_PRIORITY,
	            background_loading: false,
	            inputs: ["process_scenes"],
	            is_resource: false,
	            relative_size: 30,
	            primary_only: true,
	            cb_before: load_shoremap
	        },
	        "load_images": {
	            priority: m_loader.ASYNC_PRIORITY,
	            background_loading: true,
	            inputs: ["process_scenes"],
	            is_resource: true,
	            relative_size: 500,
	            primary_only: false,
	            cb_before: load_images
	        },
	        "update_scenes_nla": {
	            priority: m_loader.SYNC_PRIORITY,
	            background_loading: false,
	            inputs: ["process_scenes", "load_images"],
	            is_resource: false,
	            relative_size: 50,
	            primary_only: false,
	            cb_before: update_scenes_nla
	        },
	        "wait_physics_workers": {
	            priority: m_loader.SYNC_PRIORITY,
	            background_loading: false,
	            inputs: ["load_shoremap"],
	            is_resource: false,
	            relative_size: 20,
	            primary_only: false,
	            cb_loop: wait_physics_workers
	        },
	        "add_physics_objects": {
	            priority: m_loader.SYNC_PRIORITY,
	            background_loading: false,
	            inputs: ["wait_physics_workers"],
	            is_resource: false,
	            relative_size: 50,
	            primary_only: false,
	            cb_before: add_physics_objects
	        },
	        "add_objects": {
	            priority: m_loader.SYNC_PRIORITY,
	            background_loading: false,
	            inputs: ["add_physics_objects"],
	            is_resource: false,
	            relative_size: 600,
	            primary_only: false,
	            cb_before: prepare_objects_adding,
	            cb_loop: add_objects,
	            cb_after: end_objects_adding,
	            cb_param: {
	                added_objects: [],
	                obj_counter: 0
	            }
	        },
	        "init_cube_sky_dynamic_props": {
	            priority: m_loader.SYNC_PRIORITY,
	            background_loading: false,
	            inputs: ["add_objects", "load_images"],
	            is_resource: false,
	            relative_size: 50,
	            primary_only: false,
	            cb_before: init_cube_sky_dynamic_props
	        },
	        "init_logic_nodes": {
	            priority: m_loader.SYNC_PRIORITY,
	            background_loading: false,
	            inputs: ["update_scenes_nla", "add_objects"],
	            is_resource: false,
	            relative_size: 50,
	            primary_only: false,
	            cb_before: init_logic_nodes
	        },
	        "load_speakers": {
	            priority: m_loader.ASYNC_PRIORITY,
	            background_loading: true,
	            inputs: ["add_objects"],
	            is_resource: true,
	            relative_size: 100,
	            primary_only: false,
	            cb_before: load_speakers
	        },
	        "mobile_media_start": {
	            priority: m_loader.SYNC_PRIORITY,
	            background_loading: false,
	            inputs: ["load_images", "update_scenes_nla", "load_speakers", "init_logic_nodes"],
	            is_resource: true,
	            relative_size: 5,
	            primary_only: false,
	            cb_before: mobile_media_start,
	            cb_loop: mobile_media_start
	        },
	        "synchronize_media": {
	            priority: m_loader.SYNC_PRIORITY,
	            background_loading: true,
	            inputs: ["mobile_media_start"],
	            is_resource: true,
	            relative_size: 50,
	            primary_only: false,
	            cb_before: synchronize_media
	        },
	        "prepare_nla": {
	            priority: m_loader.SYNC_PRIORITY,
	            background_loading: false, // should be processed before loaded_cb
	                                       // to prevent undetermined lag introduced
	                                       // by itself
	            inputs: ["mobile_media_start"],
	            is_resource: false,
	            relative_size: 5,
	            primary_only: true,
	            cb_before: prepare_nla,
	        },
	        "start_nla": {
	            priority: m_loader.SYNC_PRIORITY,
	            background_loading: true,
	            inputs: ["prepare_nla"],
	            is_resource: false,
	            relative_size: 5,
	            primary_only: true,
	            cb_before: start_nla,
	        }
	    };

	    var scheduler = m_loader.get_scheduler();
	    if (!scheduler) {
	        scheduler = m_loader.create_scheduler();
	        _bpy_data_array = {};
	        _all_objects_cache = {};
	        _dupli_obj_id_overrides = {};
	    }

	    _bpy_data_array[scheduler.threads.length] = {};
	    var data_id = m_loader.create_thread(stages, path, loaded_cb, stageload_cb,
	            free_load_data, wait_complete_loading || cfg_sfx.audio_loading_hack,
	            cfg_def.do_not_load_resources, load_hidden, false);
	    return data_id;
	};

	exports.unload = function(data_id) {
	    // not even started loading
	    // NOTE: data_id = 0 always allowed to unload
	    var scheduler = m_loader.get_scheduler();
	    if (!scheduler || !scheduler.threads.length || data_id &&
	            !m_loader.thread_is_finished(scheduler.threads[data_id])) {
	        m_print.error("Unable to unload data!");
	        return;
	    }
	    // unload all data
	    if (data_id == 0) {
	        m_print.log("%cUNLOAD ALL", "color: #00a");

	        m_anchors.cleanup();
	        m_anim.cleanup();
	        m_sfx.cleanup();
	        m_batch.cleanup();
	        m_scenes.cleanup();
	        m_loader.cleanup();
	        // m_ctl.cleanup depends of m_phy.cleanup
	        m_ctl.cleanup();
	        m_phy.cleanup();
	        m_obj.cleanup();
	        m_util.cleanup();
	        m_render.cleanup();
	        m_nodemat.cleanup();
	        m_shaders.cleanup();
	        m_ext.cleanup();
	        m_assets.cleanup();
	        m_tex.cleanup();
	        m_lnodes.cleanup();
	        m_particles.cleanup();
	        m_input.cleanup();
	        m_debug.cleanup();

	        _all_objects_cache = null;
	        _dupli_obj_id_overrides = {};
	        _primary_scene = null;
	        _bpy_data_array = null;
	        _media_data_init = false;
	    } else {
	        m_print.log("%cUNLOAD DATA " + data_id, "color: #00a");

	        // actions cleanup
	        m_anim.remove_actions(data_id);

	        // mark all objects
	        var objs = m_obj.get_all_objects("ALL", m_obj.DATA_ID_ALL);
	        for (var i = 0; i < objs.length; i++) {
	            var obj = objs[i];
	            // keep WebGL data for objects that will stay on the scene
	            if (m_obj_util.get_object_data_id(obj) != data_id)
	                m_obj.obj_switch_cleanup_flags(obj, false, false, false);
	        }

	        // unload 
	        objs = m_obj.get_all_objects("ALL", data_id);
	        for (var i = objs.length - 1; i >= 0; i--) {
	            var obj = objs[i];
	            prepare_object_unloading(obj);
	            m_obj.remove_object(obj);
	        }

	        // revert flags
	        objs = m_obj.get_all_objects("ALL", m_obj.DATA_ID_ALL);
	        for (var i = 0; i < objs.length; i++)
	            m_obj.obj_switch_cleanup_flags(objs[i], true, true, true);
	    }
	    m_nla.cleanup(data_id);
	    remove_media_controls();
	};

	exports.prepare_object_unloading = prepare_object_unloading;
	function prepare_object_unloading(obj) {
	    // anim cleanup
	    if (m_anim.is_animated(obj))
	        m_anim.remove(obj);

	    // particles cleanup
	    m_particles.remove_obj_from_cache(obj);

	    // objects cleanup
	    m_obj.clear_outline_anim(obj);

	    // controls cleanup
	    if (m_ctl.check_sensor_manifold(obj))
	        m_ctl.remove_sensor_manifold(obj);

	    // physics cleanup
	    if (m_phy.obj_has_physics(obj))
	        m_phy.remove_object(obj);

	    // unload objects
	    m_scenes.remove_object_bundles(obj);

	    // unload sounds / speaker cleanup
	    if (m_obj_util.is_speaker(obj))
	        m_sfx.speaker_remove(obj);

	    if (m_anchors.is_anchor(obj))
	        m_anchors.remove(obj);
	}


	exports.set_debug_resources_root = function(debug_resources_root) {

	    _debug_resources_root = debug_resources_root;
	};

	function parent_num(bpy_obj) {
	    var par = get_parent(bpy_obj);
	    if (par)
	        return 1 + parent_num(par);
	    else
	        return 0;

	}

	function get_parent(bpy_obj) {
	    var armobj = m_anim.get_bpy_armobj(bpy_obj);
	    if (armobj && armobj["parent"] == bpy_obj)
	        return null;
	    else
	        return bpy_obj["parent"] || armobj;
	}

	exports.activate_media = function() {
	    if (!_media_data_init && !cfg_def.media_auto_activation) {

	        m_tex.play();
	        m_tex.pause();
	        m_tex.reset();

	        speakers_play(_primary_scene, m_obj.DATA_ID_ALL, true);
	        m_sfx.pause();

	        if (cfg_def.init_wa_context_hack)
	            m_sfx.play_empty_sound();

	        _media_data_init = true;
	    }
	};

	exports.reset = function() {
	    _canvas = null;
	};

	exports.prefetch = function(path, loaded_cb, stageload_cb) {
	    var stages = {
	        "load_main": {
	            priority: m_loader.ASYNC_PRIORITY,
	            background_loading: false,
	            inputs: [],
	            is_resource: false,
	            relative_size: 500,
	            primary_only: false,
	            cb_before: load_main
	        },
	        "load_binaries": {
	            priority: m_loader.ASYNC_PRIORITY,
	            background_loading: false,
	            inputs: ["load_main"],
	            is_resource: false,
	            relative_size: 500,
	            primary_only: false,
	            cb_before: load_binaries
	        },
	        "load_images": {
	            priority: m_loader.ASYNC_PRIORITY,
	            background_loading: false,
	            inputs: ["load_main"],
	            is_resource: false,
	            relative_size: 500,
	            primary_only: false,
	            cb_before: load_images
	        },
	        "preload_sounds": {
	            priority: m_loader.ASYNC_PRIORITY,
	            background_loading: false,
	            inputs: ["load_main"],
	            is_resource: false,
	            relative_size: 500,
	            primary_only: false,
	            cb_before: preload_sounds
	        }
	    };
	    var scheduler = m_loader.get_scheduler();
	    if (!scheduler) {
	        scheduler = m_loader.create_scheduler();
	        _bpy_data_array = {};
	        _all_objects_cache = {};
	        _dupli_obj_id_overrides = {};
	    }

	    _bpy_data_array[scheduler.threads.length] = {};
	    var data_id = m_loader.create_thread(stages, path, loaded_cb, stageload_cb,
	            free_load_data, false, cfg_def.do_not_load_resources, false, true);
	    return data_id;
	};

	exports.unfetch = function() {
	    m_assets.clear_cache();
	};

	}

	var int_data_factory = register("__data", Int_data);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * @name container
	 * @namespace
	 * @exports exports as container
	 */
	function Int_container(ns, exports) {

	var m_anchors = int_anchors_factory(ns);
	var m_cfg     = int_config_factory(ns);
	var m_data    = int_data_factory(ns);
	var m_hud     = int_hud_factory(ns);
	var m_print   = print_factory(ns);
	var m_scenes  = int_scenes_factory(ns);
	var m_subs    = int_subscene_factory(ns);
	var m_time    = int_time_factory(ns);
	var m_trans   = int_transform_factory(ns);
	var m_util    = int_util_factory(ns);

	var cfg_def = m_cfg.defaults;
	var cfg_lim = m_cfg.context_limits;

	var _gl          = null;
	var _canvas      = null;
	var _canvas_hud  = null;
	var _canvas_cont = null;
	var _mouse_event_param = {clientX: 0, clientY: 0};

	// NOTE: for optimization, to request canvas bounds only once a frame
	var _viewport_layout = {
	    width: 0,   // device pixels
	    height: 0,  // device pixels
	    scale: 1,   // divice pixels/css pixels
	    offset_top: 0,  // css pixels
	    offset_left: 0  // css pixels
	};

	/**
	 * Setup WebGL context
	 * @param gl WebGL context
	 */
	exports.setup_context = function(gl) {
	    _gl = gl;
	};

	exports.get_canvas = get_canvas;
	function get_canvas() {
	    return _canvas;
	}

	exports.get_canvas_hud = get_canvas_hud;
	function get_canvas_hud() {
	    return _canvas_hud;
	}

	exports.get_container = get_container;
	function get_container() {
	    return _canvas_cont;
	}

	exports.init = function(canvas, canvas_hud) {
	    if (canvas && canvas.parentNode) {
	        _canvas      = canvas;
	        _canvas_hud  = canvas_hud;
	        _canvas_cont = canvas.parentNode;
	    } else
	        m_util.panic("canvas container is not available");
	};

	exports.insert_to_container = function(elem, stack_order) {

	    stack_order = stack_order || "LAST";

	    switch (stack_order) {
	    case "FIRST":
	        var cont_first_child = _canvas_cont.firstElementChild;

	        _canvas_cont.insertBefore(elem, cont_first_child);

	        break;
	    case "JUST_BEFORE_CANVAS":
	        _canvas_cont.insertBefore(elem, _canvas);

	        break;
	    case "JUST_AFTER_CANVAS":
	        if (_canvas.nextElementSibling)
	            _canvas_cont.insertBefore(elem, _canvas.nextElementSibling);
	        else
	            _canvas_cont.appendChild(elem, _canvas);

	        break;
	    case "LAST":
	        _canvas_cont.appendChild(elem, _canvas);

	        break;
	    default:
	        m_print.error(stack_order + " invalid stack order");

	        break;
	    }
	};

	exports.get_viewport_width = function() {
	    return _viewport_layout.width;
	};

	exports.get_viewport_height = function() {
	    return _viewport_layout.height;
	};

	exports.set_canvas_offsets = set_canvas_offsets;
	function set_canvas_offsets(left, top) {
	    _viewport_layout.offset_left = left;
	    _viewport_layout.offset_top = top;
	}

	exports.update_canvas_offsets = update_canvas_offsets;
	function update_canvas_offsets() {
	    var boundaries = _canvas.getBoundingClientRect();
	    set_canvas_offsets(boundaries.left, boundaries.top);
	}

	exports.setup_viewport_dim = setup_viewport_dim;
	function setup_viewport_dim(width, height, scale) {
	    _viewport_layout.width = width;
	    _viewport_layout.height = height;
	    _viewport_layout.scale = scale;
	    update_canvas_offsets();
	}

	exports.force_offsets_updating = function() {
	    
	};

	exports.client_to_canvas_coords = function(client_x, client_y, dest) {
	    return client_to_element_coords(client_x, client_y, _canvas, dest);
	};

	exports.get_coords_target_space = get_coords_target_space;
	function get_coords_target_space(event, use_target_touches, dest) {

	    if (event.constructor == MouseEvent) {
	        dest[0] = event.offsetX;
	        dest[1] = event.offsetY;
	    } else if (event.constructor == TouchEvent) {
	        if (event.type == "touchend")
	            var touches = event.changedTouches;
	        else
	            var touches = use_target_touches ? event.targetTouches : event.touches;

	        client_to_element_coords(touches[0].clientX, touches[0].clientY, 
	                event.target, dest);
	    } else {
	        dest[0] = -1;
	        dest[1] = -1;
	    }

	    return dest;
	}

	exports.client_to_element_coords = client_to_element_coords;
	function client_to_element_coords(client_x, client_y, element, dest) {
	    if (!cfg_def.ie11_edge_mouseoffset_hack) {
	        // NOTE: hacky things.
	        // Autoconvert client_x/client_y to offsetX/offsetY using custom MouseEvent
	        _mouse_event_param.clientX = client_x;
	        _mouse_event_param.clientY = client_y;

	        // NOTE: needed in Chrome to work properly
	        _mouse_event_param.view = window;
	        var event = new MouseEvent("b4w_convert", _mouse_event_param);
	        element.dispatchEvent(event);

	        dest[0] = event.offsetX;
	        dest[1] = event.offsetY;
	    } else {
	        // doesn't support complex CSS transformations, but still better 
	        // than nothing
	        var rect = element.getBoundingClientRect();
	        dest[0] = client_x - rect.left;
	        dest[1] = client_y - rect.top;
	    }

	    return dest;
	}

	exports.canvas_to_viewport_coords = function(canvas_x, canvas_y, dest, camera) {
	    if (!dest)
	        dest = new Float32Array(2);

	    dest[0] = canvas_x * _viewport_layout.scale;
	    dest[1] = canvas_y * _viewport_layout.scale;

	    if (camera) {
	        var camera_resolution_scale = camera.width / _viewport_layout.width;
	        dest[0] *= camera_resolution_scale;
	        dest[1] *= camera_resolution_scale;
	    }

	    return dest;
	};

	exports.viewport_to_canvas_coords = function(viewport_x, viewport_y, dest, camera) {
	    if (!dest)
	        dest = new Float32Array(2);
	    
	    dest[0] = viewport_x / _viewport_layout.scale;
	    dest[1] = viewport_y / _viewport_layout.scale;

	    if (camera) {
	        var camera_resolution_scale = camera.width / _viewport_layout.width;
	        dest[0] /= camera_resolution_scale;
	        dest[1] /= camera_resolution_scale;
	    }

	    return dest;
	};

	exports.is_child = function(elem) {

	    if (!elem || !elem.parentNode)
	        return false;
	    else if (elem.parentNode == _canvas_cont)
	        return true;
	    else
	        return exports.is_child(elem.parentNode);
	};

	exports.is_hidpi = is_hidpi;
	function is_hidpi() {
	    if (cfg_def.allow_hidpi && window.devicePixelRatio >= 2)
	        return true;
	    return false;
	}

	exports.find_script = function(src) {
	    var scripts = document.getElementsByTagName("script");
	    var norm_src = m_util.normpath_preserve_protocol(src);

	    for (var i = 0; i < scripts.length; i++) {
	        if (scripts[i].src == norm_src)
	            return scripts[i];
	    }

	    return null;
	};

	function resize_css(canvas_webgl, canvas_hud, width, height) {
	    canvas_webgl.style.width = width + "px";
	    canvas_webgl.style.height = height + "px";

	    if (canvas_hud) {
	        canvas_hud.style.width = width + "px";
	        canvas_hud.style.height = height + "px";
	    }
	}

	exports.resize = resize;
	function resize(width, height, update_canvas_css) {

	    var canvas_webgl = get_canvas();
	    var canvas_hud   = get_canvas_hud();
	    if (update_canvas_css)
	        resize_css(canvas_webgl, canvas_hud, width, height);

	    if (canvas_hud) {
	        // no HIDPI/resolution factor for HUD canvas
	        canvas_hud.width  = width;
	        canvas_hud.height = height;
	        m_hud.update_dim();
	    }

	    var cw = Math.floor(width * cfg_def.canvas_resolution_factor);
	    var ch = Math.floor(height * cfg_def.canvas_resolution_factor);

	    canvas_webgl.width  = cw;
	    canvas_webgl.height = ch;

	    var width_limit = Math.min(_gl.drawingBufferWidth,
	            cfg_lim.max_renderbuffer_size, cfg_lim.max_viewport_dims[0]);
	    var height_limit = Math.min(_gl.drawingBufferHeight,
	            cfg_lim.max_renderbuffer_size, cfg_lim.max_viewport_dims[1]);
	    if (cw > width_limit || ch > height_limit) {
	        m_print.warn("Canvas size exceeds platform limits, downscaling");

	        var downscale = Math.min(width_limit / cw, width_limit / ch);

	        cw *= downscale;
	        ch *= downscale;
	    }

	    if (width)
	        var scale = cw / width;
	    else
	        var scale = 1;

	    canvas_webgl.width  = Math.floor(cw);
	    canvas_webgl.height = Math.floor(ch);

	    m_scenes.setup_dim(canvas_webgl.width, canvas_webgl.height, scale);

	    // needed for frustum culling/constraints
	    if (m_scenes.check_active())
	        m_trans.update_transform(m_scenes.get_active()._camera);

	    m_data.update_media_controls(canvas_webgl.width, canvas_webgl.height);

	    // possible unload in controls callbacks
	    if (!m_data.is_primary_loaded())
	        return;

	    // anchors
	    m_anchors.update();

	    // rendering
	    m_scenes.update(m_time.get_timeline(), 0);

	    // anchors
	    m_anchors.update_visibility();
	}

	exports.resize_to_container = function(force) {
	    var container = get_container();
	    var canvas = get_canvas();

	    var w = container.clientWidth;
	    var h = container.clientHeight;

	    if (force || w != canvas.clientWidth || h != canvas.clientHeight) {
	        var old_width = canvas.width;
	        var old_height = canvas.height;
	        var canvas_webgl = get_canvas();
	        var canvas_hud   = get_canvas_hud();
	        resize_css(canvas_webgl, canvas_hud, w, h);

	        // NOTE: in case of HMD splited screen, update canvas CSS width/height,
	        // but keep canvas width/height unchangeable
	        if (m_scenes.check_active()) {
	            var active_scene = m_scenes.get_active();
	            var subs_stereo = m_scenes.get_subs(active_scene, m_subs.STEREO);
	            if (subs_stereo && subs_stereo.enable_hmd_stereo) {
	                // restore canvas.width/canvas.height
	                resize(old_width, old_height, false);
	                return;
	            }
	        }
	        resize(w, h, false);
	    }
	};

	exports.reset = function() {
	    _gl          = null;
	    _canvas      = null;
	    _canvas_hud  = null;
	    _canvas_cont = null;
	};

	}

	var int_container_factory = register("__container", Int_container);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */

	"use strict";

	/**
	 * Camera internal API.
	 * @name camera
	 * @namespace
	 * @exports exports as camera
	 */
	function Int_camera(ns, exports) {

	var m_bounds   = int_boundings_factory(ns);
	var m_cont     = int_container_factory(ns);
	var m_mat4     = mat4_factory(ns);
	var m_math     = int_math_factory(ns);
	var m_obj_util = int_obj_util_factory(ns);
	var m_print    = print_factory(ns);
	var m_quat     = quat_factory(ns);
	var m_scenes   = int_scenes_factory(ns);
	var m_subs     = int_subscene_factory(ns);
	var m_trans    = int_transform_factory(ns);
	var m_tsr      = int_tsr_factory(ns);
	var m_util     = int_util_factory(ns);
	var m_vec3     = vec3_factory(ns);
	var m_vec4     = vec4_factory(ns);

	// constants
	var TYPE_STEREO_LEFT = 70;
	var TYPE_STEREO_RIGHT = 80;
	var TYPE_HMD_LEFT = 90;
	var TYPE_HMD_RIGHT = 100;

	exports.TYPE_NONE = 10;
	exports.TYPE_PERSP = 20;
	exports.TYPE_ORTHO = 30;
	exports.TYPE_PERSP_ASPECT = 40;
	exports.TYPE_ORTHO_ASPECT = 50;
	exports.TYPE_ORTHO_ASYMMETRIC = 60;
	exports.TYPE_STEREO_LEFT = TYPE_STEREO_LEFT;
	exports.TYPE_STEREO_RIGHT = TYPE_STEREO_RIGHT;
	exports.TYPE_HMD_LEFT = TYPE_HMD_LEFT;
	exports.TYPE_HMD_RIGHT = TYPE_HMD_RIGHT;

	// contolled by low-level set_look_at()
	exports.MS_STATIC = 0;

	// controlled by keyboard key directions:
	exports.MS_TARGET_CONTROLS = 2;

	// controlled by keyboard key directions
	exports.MS_EYE_CONTROLS = 3;

	// controlled by keyboard key directions:
	exports.MS_HOVER_CONTROLS = 4;

	// global params for all cameras

	var PIVOT_DEFAULT_DIST = 10;

	// convergence distance
	var STEREO_CONV_DIST = 6.0;
	// left-right eye distance (1/30 convergence)
	var STEREO_EYE_DIST = 0.065;

	var DEF_ORTHO_SCALE = 2.5;
	var DEF_PERSP_FOV   = m_util.deg_to_rad(40);
	var DEF_PERSP_NEAR  = 0.1;
	var DEF_PERSP_FAR   = 1000;

	var MAX_HOVER_INIT_ANGLE = m_util.deg_to_rad(0.5);

	var RIGHT_TOP_POINT = new Float32Array([1, 1, 1, 1]);
	var LEFT_BOTTOM_POINT = new Float32Array([-1, -1, 1, 1]);
	var FAR_POINT = new Float32Array([0, 0, -1, 1]);

	// for internal usage
	var _vec2_tmp = new Float32Array(2);
	var _vec2_tmp2 = new Float32Array(2);
	var _vec2_tmp3 = new Float32Array(2);
	var _vec3_tmp = new Float32Array(3);
	var _vec3_tmp2 = new Float32Array(3);
	var _vec3_tmp3 = new Float32Array(3);
	var _quat4_tmp = new Float32Array(4);
	var _quat4_tmp2 = new Float32Array(4);
	var _vec4_tmp = new Float32Array(4);
	var _vec4_tmp2 = new Float32Array(4);
	var _mat4_tmp = new Float32Array(16);

	var _frustum_corners_tmp = new Float32Array(24);

	var _pline_tmp = new Float32Array(6);

	/**
	 * Create camera from bpy camera object
	 * uses _vec3_tmp2
	 */
	exports.camera_object_to_camera = function(bpy_camobj, camobj) {
	    var render = camobj.render;

	    var camobj_data = bpy_camobj["data"];

	    switch (camobj_data["type"]) {
	    case "PERSP":
	        var cam = create_camera(exports.TYPE_PERSP);
	        cam.fit = camobj_data["sensor_fit"];

	        // NOTE: expect some issues with camera sensor fit
	        var fov = camobj_data["angle"];
	        var near = camobj_data["clip_start"];
	            
	        set_frustum(cam, fov, near, camobj_data["clip_end"]);
	        break;
	    case "ORTHO":
	        var cam = create_camera(exports.TYPE_ORTHO);
	        cam.fit = camobj_data["sensor_fit"];

	        var top_bound = camobj_data["ortho_scale"] / 2;
	        set_frustum(cam, top_bound, camobj_data["clip_start"],
	                camobj_data["clip_end"]);
	        break;
	    }

	    cam.name = camobj.name;
	    var cam_scenes_data = camobj.scenes_data;
	    cam_scenes_data[0].cameras.push(cam);
	    for (var i = 1; i < cam_scenes_data.length; i++) {
	        var new_cam = clone_camera(cam, false);
	        cam_scenes_data[i].cameras.push(new_cam);
	    }

	    render.move_style                = move_style_bpy_to_b4w(camobj_data["b4w_move_style"]);
	    render.dof_distance              = camobj_data["dof_distance"];

	    var dof_obj = camobj_data["dof_object"];
	    render.dof_object = dof_obj ? dof_obj._object : null;

	    render.dof_front_start           = camobj_data["b4w_dof_front_start"];
	    render.dof_front_end             = camobj_data["b4w_dof_front_end"];
	    render.dof_rear_start            = camobj_data["b4w_dof_rear_start"];
	    render.dof_rear_end              = camobj_data["b4w_dof_rear_end"];
	    render.dof_power                 = camobj_data["b4w_dof_power"];
	    render.dof_bokeh                 = camobj_data["b4w_dof_bokeh"];
	    render.dof_bokeh_intensity       = camobj_data["b4w_dof_bokeh_intensity"];
	    render.dof_foreground_blur       = camobj_data["b4w_dof_foreground_blur"];

	    render.velocity_trans = camobj_data["b4w_trans_velocity"];
	    render.velocity_rot   = camobj_data["b4w_rot_velocity"];
	    render.velocity_zoom  = camobj_data["b4w_zoom_velocity"];

	    var hor_rot_limits = hor_rot_limits_bpy_to_b4w(bpy_camobj, camobj);
	    var vert_rot_limits = vert_rot_limits_bpy_to_b4w(bpy_camobj, camobj);
	    var dist_limits = dist_limits_bpy_to_b4w(bpy_camobj, camobj);
	    var hor_trans_limits = hor_trans_limits_bpy_to_b4w(bpy_camobj, camobj);
	    var vert_trans_limits = vert_trans_limits_bpy_to_b4w(bpy_camobj, camobj);
	    var pivot_limits = pivot_limits_bpy_to_b4w(bpy_camobj, camobj);

	    switch (render.move_style) {
	    case exports.MS_STATIC:
	        break;
	    case exports.MS_EYE_CONTROLS:
	        var pos = m_tsr.get_trans_view(camobj.render.world_tsr);
	        setup_eye_model(camobj, pos, null, hor_rot_limits, vert_rot_limits);
	        break;
	    case exports.MS_TARGET_CONTROLS:
	        var pos = m_tsr.get_trans_view(camobj.render.world_tsr);
	        setup_target_model(camobj, pos, camobj_data["b4w_target"], 
	                hor_rot_limits, vert_rot_limits, dist_limits, pivot_limits,
	                camobj_data["b4w_use_panning"]);
	        break;
	    case exports.MS_HOVER_CONTROLS:
	        var pos = m_tsr.get_trans_view(camobj.render.world_tsr);
	        var pivot = init_hover_pivot(camobj, 
	                bpy_camobj["data"]["b4w_hover_zero_level"], _vec3_tmp2);
	        setup_hover_model(camobj, pos, pivot, dist_limits, vert_rot_limits, 
	                hor_trans_limits, vert_trans_limits, 
	                camobj_data["b4w_enable_hover_hor_rotation"]);
	        break;
	    }

	    clamp_limits(camobj);
	    init_ortho_props(camobj);
	};

	function hor_rot_limits_bpy_to_b4w(bpy_camobj, camobj) {
	    var ms = camobj.render.move_style;
	    var data = bpy_camobj["data"];

	    var hor_rot_limits = null;

	    if ((ms == exports.MS_TARGET_CONTROLS || ms == exports.MS_EYE_CONTROLS) 
	            && data["b4w_use_horizontal_clamping"]) {
	        
	        hor_rot_limits = {
	            left: data["b4w_rotation_left_limit"],
	            right: data["b4w_rotation_right_limit"],
	            camera_space: data["b4w_horizontal_clamping_type"] == "LOCAL"
	        };

	        if (ms == exports.MS_EYE_CONTROLS) {
	            // CCW: right->left for EYE camera
	            hor_rot_limits.left *= -1;
	            hor_rot_limits.right *= -1;
	        }

	    }

	    return hor_rot_limits;
	}

	function vert_rot_limits_bpy_to_b4w(bpy_camobj, camobj) {
	    var ms = camobj.render.move_style;
	    var data = bpy_camobj["data"];

	    var vert_rot_limits = null;

	    if ((ms == exports.MS_TARGET_CONTROLS || ms == exports.MS_EYE_CONTROLS) 
	            && data["b4w_use_vertical_clamping"]) {

	        vert_rot_limits = {
	            down: data["b4w_rotation_down_limit"],
	            up: data["b4w_rotation_up_limit"],
	            camera_space: data["b4w_vertical_clamping_type"] == "LOCAL"
	        };

	        if (ms == exports.MS_TARGET_CONTROLS) {
	            // CCW: up->down for TARGET camera
	            vert_rot_limits.down *= -1;
	            vert_rot_limits.up *= -1;
	        }

	    } else if (ms == exports.MS_HOVER_CONTROLS && data["b4w_use_zooming"]) {
	        if (data["b4w_hover_angle_min"] <= data["b4w_hover_angle_max"]) {
	            vert_rot_limits = {
	                down: data["b4w_hover_angle_min"],
	                up: data["b4w_hover_angle_max"]
	            };

	            // CCW: up->down for HOVER camera
	            vert_rot_limits.down *= -1;
	            vert_rot_limits.up *= -1;
	        } else
	            m_print.error("Wrong angle limits for the HOVER camera. Disabling angle limits.");
	    }

	    return vert_rot_limits;
	}

	function dist_limits_bpy_to_b4w(bpy_camobj, camobj) {
	    var ms = camobj.render.move_style;
	    var data = bpy_camobj["data"];

	    var dist_limits = null;

	    if (ms == exports.MS_TARGET_CONTROLS && data["b4w_use_target_distance_limits"] 
	            && (data["b4w_distance_min"] <= data["b4w_distance_max"]))
	        // enable distance clamping only if the distance limits are correct
	        dist_limits = {
	            min: data["b4w_distance_min"],
	            max: data["b4w_distance_max"]
	        };
	    else if (ms === exports.MS_HOVER_CONTROLS && data["b4w_use_zooming"]) {
	        if (data["b4w_distance_min"] <= data["b4w_distance_max"])
	            dist_limits = {
	                min: data["b4w_distance_min"],
	                max: data["b4w_distance_max"]
	            };
	        else
	            m_print.error("Wrong distance limits for the HOVER camera. Disabling distance limits.");
	    }

	    return dist_limits;
	}

	function hor_trans_limits_bpy_to_b4w(bpy_camobj, camobj) {
	    var ms = camobj.render.move_style;
	    var data = bpy_camobj["data"];

	    var hor_trans_limits = null;

	    if (ms == exports.MS_HOVER_CONTROLS && data["b4w_use_horizontal_clamping"]
	            && (data["b4w_horizontal_translation_min"]
	            <= data["b4w_horizontal_translation_max"]))
	        hor_trans_limits = {
	            min: data["b4w_horizontal_translation_min"],
	            max: data["b4w_horizontal_translation_max"]
	        };

	    return hor_trans_limits;
	}

	function vert_trans_limits_bpy_to_b4w(bpy_camobj, camobj) {
	    var ms = camobj.render.move_style;
	    var data = bpy_camobj["data"];

	    var vert_trans_limits = null;

	    if (ms == exports.MS_HOVER_CONTROLS && data["b4w_use_vertical_clamping"]
	            && (data["b4w_vertical_translation_min"]
	            <= data["b4w_vertical_translation_max"])) {
	        
	        vert_trans_limits = {
	            min: data["b4w_vertical_translation_min"],
	            max: data["b4w_vertical_translation_max"]
	        };
	    }
	    return vert_trans_limits;
	}

	function pivot_limits_bpy_to_b4w(bpy_camobj, camobj) {
	    var ms = camobj.render.move_style;
	    var data = bpy_camobj["data"];

	    var pivot_limits = null;

	    if (ms == exports.MS_TARGET_CONTROLS && data["b4w_use_pivot_limits"])
	        pivot_limits = {
	            min_z: data["b4w_pivot_z_min"],
	            max_z: data["b4w_pivot_z_max"]
	        };

	    return pivot_limits;
	}

	exports.setup_eye_model = setup_eye_model;
	function setup_eye_model(camobj, pos, look_at, hor_rot_lim, vert_rot_lim) {
	    m_trans.set_translation(camobj, pos);
	    if (look_at)
	        set_look_at_corrected(camobj, pos, look_at);

	    set_horizontal_rot_limits(camobj, hor_rot_lim);
	    set_vertical_rot_limits(camobj, vert_rot_lim);
	}

	exports.setup_target_model = setup_target_model;
	function setup_target_model(camobj, pos, pivot, hor_rot_lim, vert_rot_lim, 
	        dist_lim, pivot_lim, use_panning) {
	    var render = camobj.render;

	    m_trans.set_translation(camobj, pos);
	    render.pivot.set(pivot);

	    set_look_at_corrected(camobj, pos, pivot);

	    set_horizontal_rot_limits(camobj, hor_rot_lim);
	    set_vertical_rot_limits(camobj, vert_rot_lim);
	    set_distance_limits(camobj, dist_lim);
	    set_pivot_limits(camobj, pivot_lim);
	    render.use_panning = use_panning;
	}

	exports.setup_hover_model = setup_hover_model;
	function setup_hover_model(camobj, pos, pivot, dist_lim, angle_lim, 
	        hor_trans_lim, vert_trans_lim, hor_rotation) {
	    var render = camobj.render;

	    m_trans.set_translation(camobj, pos);
	    render.hover_pivot.set(pivot);
	    set_look_at_corrected(camobj, pos, pivot);

	    hover_set_distance_limits(camobj, dist_lim);
	    hover_set_vertical_limits(camobj, angle_lim);

	    set_hor_trans_limits(camobj, hor_trans_lim);
	    set_vert_trans_limits(camobj, vert_trans_lim);

	    render.enable_hover_hor_rotation = hor_rotation;
	}

	/**
	 * uses _vec2_tmp, _vec3_tmp, _vec4_tmp
	 */
	function init_hover_pivot(camobj, zero_level, dest) {
	    var render = camobj.render;
	    var trans = m_tsr.get_trans_view(render.world_tsr);
	    var quat = m_tsr.get_quat_view(render.world_tsr);
	    
	    var normal_plane_oxy = _vec4_tmp;
	    normal_plane_oxy.set(m_util.AXIS_Z);
	    normal_plane_oxy[3] = 0;

	    var theta = get_camera_angles(camobj, _vec2_tmp)[1];

	    var view_vector = m_util.quat_to_dir(quat, m_util.AXIS_MZ, _vec3_tmp);

	    m_math.set_pline_initial_point(_pline_tmp, trans);
	    m_math.set_pline_directional_vec(_pline_tmp, view_vector);
	    var res = m_util.line_plane_intersect(normal_plane_oxy, 
	            -zero_level, _pline_tmp, dest);

	    // NOTE: It is used to check parallel line and plane
	    if (!res || Math.abs(theta) < MAX_HOVER_INIT_ANGLE) {
	        m_print.warn("Active hover camera view vector and the supporting plane " 
	                + "are parallel to each other. Hover pivot will be set based on the " 
	                + "camera position.");
	        dest[0] = trans[0];
	        dest[1] = trans[1];
	        dest[2] = 0;
	    }

	    return dest;
	}

	exports.init_ortho_props = init_ortho_props;
	function init_ortho_props(camobj) {
	    var render = camobj.render;
	    for (var i = 0; i < camobj.scenes_data.length; i++) {
	        var main_cam = camobj.scenes_data[i].cameras[0];
	        if (main_cam.type == exports.TYPE_ORTHO)    
	            switch (render.move_style) {
	            case exports.MS_TARGET_CONTROLS:
	                var trans = m_tsr.get_trans_view(render.world_tsr);
	                render.init_dist = m_vec3.dist(trans, render.pivot);
	                render.init_fov = main_cam.fov;
	                break;
	            case exports.MS_HOVER_CONTROLS:
	                var trans = m_tsr.get_trans_view(render.world_tsr);
	                render.init_dist = m_vec3.dist(trans, render.hover_pivot);
	                render.init_fov = main_cam.fov;
	                break;
	            }
	    }
	}

	/**
	 * Create and initialize generic camera object.
	 */
	function init_camera(type) {
	    var cam = {
	        type : type,

	        name : "",

	        size_mult : 1,

	        width  : 0,
	        height : 0,

	        framebuffer : null,
	        framebuffer_prev : null,
	        color_attachment : null,
	        depth_attachment : null,

	        // frustum stuff
	        aspect : 0,
	        fov    : 0,
	        fit    : "VERTICAL",

	        near   : 0,
	        far    : 0,

	        left   : 0,
	        right  : 0,
	        top    : 0,
	        bottom : 0,

	        hmd_fov : m_vec4.create(),

	        // some uniforms
	        world_tsr             : new Float32Array(9),
	        view_matrix           : new Float32Array(16),
	        view_refl_matrix      : new Float32Array(16),
	        view_transform_params : {
	            trans: m_vec3.create(),
	            angle: 0
	        },
	        proj_matrix           : new Float32Array(16),
	        view_proj_matrix      : new Float32Array(16),
	        view_proj_inv_matrix  : new Float32Array(16),
	        prev_view_proj_matrix : new Float32Array(16),
	        sky_vp_inv_matrix     : new Float32Array(16),

	        direction                       : new Float32Array(3),
	        view_tsr                        : m_tsr.create_ext(),
	        view_tsr_inv                    : m_tsr.create_ext(),
	        real_view_tsr                   : m_tsr.create_ext(), // for reflections
	        real_view_tsr_inv               : m_tsr.create_ext(),
	        shadow_cast_billboard_view_tsr  : m_tsr.create_ext(),

	        // dof stuff
	        dof_distance : 0,
	        dof_front_start : 0,
	        dof_front_end : 0,
	        dof_rear_start : 0,
	        dof_rear_end : 0,
	        dof_power : 0,
	        dof_bokeh_intensity : 0,
	        dof_object : null,
	        dof_bokeh : false,
	        dof_foreground_blur : false,
	        dof_on : false,
	        lod_eye: new Float32Array(3),

	        frustum_planes : create_frustum_planes(),
	        stereo_conv_dist : 0,
	        stereo_eye_dist : 0,

	        reflection_plane : null,

	        // shadow cascades stuff
	        csm_centers: null,
	        csm_radii: null,
	        csm_center_dists: new Float32Array(4),
	        pcf_blur_radii: new Float32Array(4)
	    };

	    // some default values
	    cam.hmd_fov[0] = cam.hmd_fov[2] = 0;
	    cam.hmd_fov[1] = cam.hmd_fov[3] = 0;
	    return cam;
	}

	exports.clone_camera = clone_camera;
	function clone_camera(cam, reset_attachments) {

	    var cam_new = init_camera(cam.type);

	    cam_new.name = cam.name;

	    cam_new.size_mult = cam.size_mult;

	    cam_new.width  = cam.width;
	    cam_new.height = cam.height;

	    if (!reset_attachments) {
	        cam_new.framebuffer = cam.framebuffer;
	        cam_new.framebuffer_prev = cam.framebuffer_prev;
	        cam_new.color_attachment = cam.color_attachment;
	        cam_new.depth_attachment = cam.depth_attachment;
	    }

	    // frustum stuff
	    cam_new.aspect = cam.aspect;
	    cam_new.fit    = cam.fit;
	    cam_new.fov    = cam.fov;
	    cam_new.near   = cam.near;
	    cam_new.far    = cam.far;
	    cam_new.left   = cam.left;
	    cam_new.right  = cam.right;
	    cam_new.top    = cam.top;
	    cam_new.bottom = cam.bottom;

	    m_vec4.copy(cam.hmd_fov, cam_new.hmd_fov);

	    // some uniforms
	    m_tsr.copy(cam.world_tsr, cam_new.world_tsr);

	    m_mat4.copy(cam.view_matrix, cam_new.view_matrix);
	    m_mat4.copy(cam.view_refl_matrix, cam_new.view_refl_matrix);
	    cam_new.view_transform_params = m_util.clone_object_r(cam.view_transform_params);
	    m_mat4.copy(cam.proj_matrix, cam_new.proj_matrix);
	    m_mat4.copy(cam.view_proj_matrix, cam_new.view_proj_matrix);
	    m_mat4.copy(cam.view_proj_inv_matrix, cam_new.view_proj_inv_matrix);
	    m_mat4.copy(cam.prev_view_proj_matrix, cam_new.prev_view_proj_matrix);
	    m_mat4.copy(cam.sky_vp_inv_matrix, cam_new.sky_vp_inv_matrix);

	    cam_new.direction.set(cam.direction);
	    m_tsr.copy(cam.view_tsr, cam_new.view_tsr);
	    m_tsr.copy(cam.view_tsr_inv, cam_new.view_tsr_inv);
	    m_tsr.copy(cam.real_view_tsr, cam_new.real_view_tsr);
	    m_tsr.copy(cam.real_view_tsr_inv, cam_new.real_view_tsr_inv);
	    m_tsr.copy(cam.shadow_cast_billboard_view_tsr, cam_new.shadow_cast_billboard_view_tsr);

	    // dof stuff
	    cam_new.dof_distance = cam.dof_distance;
	    cam_new.dof_front_start = cam.dof_front_start;
	    cam_new.dof_front_end = cam.dof_front_end;
	    cam_new.dof_rear_start = cam.dof_rear_start;
	    cam_new.dof_rear_end = cam.dof_rear_end;
	    cam_new.dof_power = cam.dof_power;
	    cam_new.dof_bokeh_intensity = cam.dof_bokeh_intensity;
	    cam_new.dof_object = cam.dof_object;
	    cam_new.dof_bokeh = cam.dof_bokeh;
	    cam_new.dof_foreground_blur = cam.dof_foreground_blur;
	    cam_new.dof_on = cam.dof_on;
	    m_vec3.copy(cam.lod_eye, cam_new.lod_eye);

	    copy_frustum_planes(cam.frustum_planes, cam_new.frustum_planes);
	    cam_new.stereo_conv_dist = cam.stereo_conv_dist;
	    cam_new.stereo_eye_dist = cam.stereo_eye_dist;

	    if (cam.reflection_plane)
	        cam_new.reflection_plane = m_vec4.clone(cam.reflection_plane);

	    // shadow cascades stuff
	    clone_camera_csm(cam, cam_new);
	    m_vec4.copy(cam.csm_center_dists, cam_new.csm_center_dists);
	    m_vec4.copy(cam.pcf_blur_radii, cam_new.pcf_blur_radii);

	    return cam_new;
	}


	exports.create_frustum_planes = create_frustum_planes;
	function create_frustum_planes() {
	    var frustum_planes = {
	        left:   new Float32Array([0, 0, 0, 0]),
	        right:  new Float32Array([0, 0, 0, 0]),
	        top:    new Float32Array([0, 0, 0, 0]),
	        bottom: new Float32Array([0, 0, 0, 0]),
	        near:   new Float32Array([0, 0, 0, 0]),
	        far:    new Float32Array([0, 0, 0, 0])
	    };
	    return frustum_planes;
	}

	function copy_frustum_planes(planes, planes_new) {
	    m_vec4.copy(planes.left, planes_new.left);
	    m_vec4.copy(planes.right, planes_new.right);
	    m_vec4.copy(planes.top, planes_new.top);
	    m_vec4.copy(planes.bottom, planes_new.bottom);
	    m_vec4.copy(planes.near, planes_new.near);
	    m_vec4.copy(planes.far, planes_new.far);
	    return planes_new;
	}

	exports.move_style_bpy_to_b4w = move_style_bpy_to_b4w;
	function move_style_bpy_to_b4w(bpy_move_style) {
	    switch (bpy_move_style) {
	    case "STATIC":
	        return exports.MS_STATIC;
	        break;
	    case "TARGET":
	        return exports.MS_TARGET_CONTROLS;
	        break;
	    case "EYE":
	        return exports.MS_EYE_CONTROLS;
	        break;
	    case "HOVER":
	        return exports.MS_HOVER_CONTROLS;
	        break;
	    default:
	        m_util.panic("Unknown move style");
	    }
	}

	exports.create_camera = create_camera;
	function create_camera(type) {

	    var cam = init_camera(type);

	    if (type == exports.TYPE_NONE)
	        return cam;

	    switch (type) {
	    case exports.TYPE_PERSP:
	        set_frustum(cam, DEF_PERSP_FOV,
	                DEF_PERSP_NEAR, DEF_PERSP_FAR);
	        break;
	    case exports.TYPE_ORTHO:
	        set_frustum(cam, DEF_ORTHO_SCALE,
	                DEF_PERSP_NEAR, DEF_PERSP_FAR);
	        break;

	    case exports.TYPE_PERSP_ASPECT:
	        break;
	    case exports.TYPE_ORTHO_ASPECT:
	        break;
	    case exports.TYPE_ORTHO_ASYMMETRIC:
	        break;
	    case exports.TYPE_STEREO_LEFT:
	    case exports.TYPE_STEREO_RIGHT:
	    case exports.TYPE_HMD_LEFT:
	    case exports.TYPE_HMD_RIGHT:
	        m_util.panic("Stereo camera may only be created from perspective one");
	        break;
	    default:
	        m_util.panic("Unknown camera type");
	        break;
	    }

	    return cam;
	}

	exports.check_attachment = function(cam, type) {
	    switch (type) {
	    case "COLOR":
	    case "CUBEMAP":
	        return Boolean(cam.color_attachment);
	    case "DEPTH":
	        return Boolean(cam.depth_attachment);
	    case "SCREEN":
	        return (!Boolean(cam.color_attachment) && !Boolean(cam.depth_attachment));
	    default:
	        m_util.panic("Wrong attachment type: " + type);
	        break;
	    }
	};

	exports.set_attachment = function(cam, type, tex) {
	    switch (type) {
	    case "COLOR":
	    case "CUBEMAP":
	        cam.color_attachment = tex;
	        break;
	    case "DEPTH":
	        cam.depth_attachment = tex;
	        break;
	    case "SCREEN":
	        cam.color_attachment = null;
	        cam.depth_attachment = null;
	        break;
	    default:
	        m_util.panic("Wrong attachment type: " + type);
	        break;
	    }
	};

	exports.get_attachment = function(cam, type) {
	    switch (type) {
	    case "COLOR":
	    case "CUBEMAP":
	        return cam.color_attachment;
	    case "DEPTH":
	        return cam.depth_attachment;
	    case "SCREEN":
	        return null;
	    default:
	        m_util.panic("Wrong attachment type: " + type);
	        break;
	    }
	};


	/**
	 * Prepare camera for 3D stereo rendering
	 * Only standard perspective camera can be made stereo
	 * @param type Stereo camera type (TYPE_STEREO_LEFT, TYPE_STEREO_RIGHT, TYPE_HMD_LEFT, TYPE_HMD_RIGHT)
	 */
	exports.make_stereo = function(cam, type) {

	    if (!(cam.type == exports.TYPE_PERSP &&
	            (type == exports.TYPE_STEREO_LEFT ||
	            type == exports.TYPE_STEREO_RIGHT ||
	            type == exports.TYPE_HMD_LEFT ||
	            type == exports.TYPE_HMD_RIGHT)))
	        m_util.panic("make_stereo(): wrong camera type");

	    cam.type = type;

	    set_stereo_params(cam, STEREO_CONV_DIST, STEREO_EYE_DIST);
	};

	exports.set_stereo_params = set_stereo_params;
	/**
	 * Set params for camera used in 3D stereo rendering.
	 */
	function set_stereo_params(cam, conv_dist, eye_dist) {

	    if (!(cam.type == exports.TYPE_STEREO_LEFT ||
	                cam.type == exports.TYPE_STEREO_RIGHT ||
	                cam.type == exports.TYPE_HMD_LEFT ||
	                cam.type == exports.TYPE_HMD_RIGHT))
	        m_util.panic("set_stereo_params(): wrong camera type");

	    if (cam.type == exports.TYPE_STEREO_LEFT ||
	            cam.type == exports.TYPE_STEREO_RIGHT)
	        cam.stereo_conv_dist = conv_dist;

	    cam.stereo_eye_dist = eye_dist;

	    set_projection(cam, false);

	    // update camera shadows
	    if (m_scenes.check_active()) {
	        var active_scene = m_scenes.get_active();
	        var sh_params = active_scene._render.shadow_params;

	        if (sh_params) {
	            var cam_scene_data = m_obj_util.get_scene_data(m_scenes.get_camera(active_scene),
	                        active_scene);
	            var upd_cameras = cam_scene_data.cameras;
	            for (var i = 0; i < upd_cameras.length; i++)
	                update_camera_shadows(upd_cameras[i], sh_params);
	        }
	    }
	}



	exports.get_camera_angles = get_camera_angles;
	function get_camera_angles(cam, dest) {
	    var quat = m_tsr.get_quat_view(cam.render.world_tsr);
	    return get_camera_angles_from_quat(quat, dest);
	}

	/**
	 * Camera-specific spherical coordinates from a quaternion
	 * uses _vec3_tmp, _vec3_tmp2, _vec3_tmp3
	 */
	exports.get_camera_angles_from_quat = get_camera_angles_from_quat;
	function get_camera_angles_from_quat(quat, dest) {
	    var z_world_cam = m_util.quat_to_dir(quat, m_util.AXIS_Z, _vec3_tmp);
	    var my_world_cam = m_util.quat_to_dir(quat, m_util.AXIS_MY, _vec3_tmp2);

	    // base angles
	    var base_theta = -Math.asin(z_world_cam[2] / m_vec3.length(z_world_cam));
	    if (Math.abs(base_theta) > Math.PI / 4)
	        var phi_dir = m_vec3.scale(my_world_cam, -m_util.sign(base_theta), _vec3_tmp3);
	    else
	        var phi_dir = m_vec3.scale(z_world_cam, -m_util.sign(my_world_cam[2]), _vec3_tmp3);
	    var base_phi = Math.atan(Math.abs(phi_dir[0] / phi_dir[1]));

	    // resulted theta
	    var theta = base_theta;
	    if (my_world_cam[2] > 0)
	        theta = m_util.sign(theta) * Math.PI - theta;

	    // resulted phi
	    var phi = base_phi;
	    if (phi_dir[1] > 0)
	        phi = Math.PI - phi;
	    if (phi_dir[0] < 0)
	        phi = 2 * Math.PI - phi;

	    dest[0] = phi;
	    dest[1] = theta;

	    return dest;
	}

	exports.get_camera_angles_char = function(cam, dest) {
	    get_camera_angles(cam, dest);

	    // phi
	    dest[0] = m_util.angle_wrap_0_2pi(dest[0] + Math.PI);
	    // theta
	    dest[1] *= -1;

	    return dest;
	};

	exports.set_fov = function(cam, fov) {
	    switch (cam.type) {
	    case exports.TYPE_PERSP:
	    case exports.TYPE_PERSP_ASPECT:
	    case exports.TYPE_STEREO_LEFT:
	    case exports.TYPE_STEREO_RIGHT:
	        cam.fov = fov;
	        break;
	    default:
	        break;
	    }
	};

	exports.get_fov = function(cam) {
	    switch (cam.type) {
	    case exports.TYPE_PERSP:
	    case exports.TYPE_PERSP_ASPECT:
	    case exports.TYPE_STEREO_LEFT:
	    case exports.TYPE_STEREO_RIGHT:
	        return cam.fov;
	    default:
	        return 0;
	    }
	};

	exports.get_vfov = get_vfov;
	function get_vfov(cam) {
	    switch (cam.fit) {
	    case "AUTO":
	        if (cam.aspect > 1)
	            if (is_ortho(cam))
	                return cam.fov / cam.aspect;
	            else
	                return 2 * Math.atan(Math.tan(cam.fov/2) / cam.aspect);
	        else
	            return cam.fov;
	    case "HORIZONTAL":
	        if (is_ortho(cam))
	            return cam.fov / cam.aspect;
	        else
	            return 2 * Math.atan(Math.tan(cam.fov/2) / cam.aspect);
	    case "VERTICAL":
	        return cam.fov;
	    }
	}

	function get_hfov(cam) {
	    switch (cam.fit) {
	    case "AUTO":
	        if (cam.aspect > 1)
	            return cam.fov;
	        else
	            if (is_ortho(cam))
	                return cam.fov * cam.aspect;
	            else
	                return 2 * Math.atan(Math.tan(cam.fov/2) * cam.aspect);
	    case "HORIZONTAL":
	        return cam.fov;
	    case "VERTICAL":
	        if (is_ortho(cam))
	            return cam.fov * cam.aspect;
	        else
	            return 2 * Math.atan(Math.tan(cam.fov/2) * cam.aspect);
	    }
	}


	/**
	 * Set frustum for symmetric camera with float aspect ratio
	 * @param cam Camera ID
	 * @param fov Field-of-view or size for ortho cameras
	 * @param near Distance to near plane
	 * @param far Distance to far plane
	 */
	exports.set_frustum = set_frustum;
	function set_frustum(cam, fov, near, far) {

	    switch (cam.type) {
	    case exports.TYPE_PERSP:
	    case exports.TYPE_STEREO_LEFT:
	    case exports.TYPE_STEREO_RIGHT:
	        cam.fov = fov;
	        // NOTE: side effect
	        cam.aspect = 1;
	        break;
	    case exports.TYPE_ORTHO:
	        cam.fov = fov;
	        // NOTE: side effect
	        cam.aspect = 1;
	        break;

	    case exports.TYPE_HMD_LEFT:
	    case exports.TYPE_HMD_RIGHT:
	        break;
	    default:
	        m_util.panic("set_frustum(): Unsupported camera type: " + cam.type);
	        break;
	    }

	    cam.near = near;
	    cam.far = far;
	}

	/**
	 * Set frustum for camera with fixed aspect ratio
	 * @param {number} h_fov_or_right Horizontal size
	 * @param {number} v_fov_or_top Vertical size
	 */
	exports.set_frustum2 = function(cam, h_fov_or_right, v_fov_or_top, near, far) {
	    switch (cam.type) {
	    case exports.TYPE_PERSP:
	    case exports.TYPE_STEREO_LEFT:
	    case exports.TYPE_STEREO_RIGHT:
	    case exports.TYPE_ORTHO:
	        cam.fov = v_fov_or_top;
	        cam.aspect = 1;
	        break;
	    case exports.TYPE_PERSP_ASPECT:
	    case exports.TYPE_ORTHO_ASPECT:
	        cam.fov = v_fov_or_top;
	        // NOTE: not right for perspective cameras!
	        cam.aspect = h_fov_or_right / v_fov_or_top;
	        break;
	    case exports.TYPE_HMD_LEFT:
	    case exports.TYPE_HMD_RIGHT:
	        break;
	    default:
	        m_util.panic("set_frustum2(): Unsupported camera type: " + cam.type);
	        break;
	    }

	    cam.near = near;
	    cam.far = far;
	};

	exports.set_frustum_asymmetric = set_frustum_asymmetric;
	/**
	 * Set asymmetric frustum for ortho or stereo camera
	 */
	function set_frustum_asymmetric(cam, left, right, bottom, top, near, far) {

	    switch (cam.type) {
	    case exports.TYPE_ORTHO_ASYMMETRIC:
	        cam.left = left;
	        cam.right = right;
	        cam.bottom = bottom;
	        cam.top = top;

	        cam.near = near;
	        cam.far = far;

	        break;
	    default:
	        m_util.panic("set_frustum_asymmetric(): " +
	                "Unsupported camera type: " + cam.type);
	        break;
	    }
	}

	exports.get_move_style = get_move_style;
	function get_move_style(camobj) {
	    return camobj.render.move_style;
	}

	exports.set_view = set_view;
	/**
	 * uses _vec3_tmp, _quat4_tmp, _mat4_tmp
	 */
	function set_view(cam, camobj) {
	    // ignore scale for view_matrix
	    var trans = m_tsr.get_trans(camobj.render.world_tsr, _vec3_tmp);
	    var quat = m_tsr.get_quat(camobj.render.world_tsr, _quat4_tmp);
	    var wm = m_mat4.fromRotationTranslation(quat, trans, _mat4_tmp);

	    m_mat4.invert(wm, cam.view_matrix);

	    if (m_scenes.check_active()) {
	        var active_scene = m_scenes.get_active();
	        var subs_stereo = m_scenes.get_subs(active_scene, m_subs.STEREO);
	    }

	    if (cam.type == exports.TYPE_STEREO_LEFT ||
	            subs_stereo && subs_stereo.enable_hmd_stereo &&
	            cam.type == exports.TYPE_HMD_LEFT)
	        cam.view_matrix[12] += cam.stereo_eye_dist/2;
	    else if (cam.type == exports.TYPE_STEREO_RIGHT ||
	            subs_stereo && subs_stereo.enable_hmd_stereo &&
	            cam.type == exports.TYPE_HMD_RIGHT)
	        cam.view_matrix[12] -= cam.stereo_eye_dist/2;

	    if (cam.reflection_plane) {
	        // store original view tsr before reflecting the view matrix
	        m_tsr.from_mat4(cam.view_matrix, cam.real_view_tsr);
	        m_tsr.invert(cam.real_view_tsr, cam.real_view_tsr_inv);
	        update_view_refl_matrix(cam);
	        reflect_view_matrix(cam);
	        set_projection_reflect(cam, true);
	        m_vec3.transformMat4(trans, cam.view_refl_matrix, trans);
	    }

	    // update view tsr and view zup tsr
	    m_tsr.from_mat4(cam.view_matrix, cam.view_tsr);
	    m_tsr.invert(cam.view_tsr, cam.view_tsr_inv);
	    m_tsr.set_sep(trans, 1, quat, cam.world_tsr);

	    set_view_projection_after(cam);
	}

	/**
	 * Update view_refl_matrix during reflection pass
	 */
	function update_view_refl_matrix(cam) {
	    var Nx = cam.reflection_plane[0];
	    var Ny = cam.reflection_plane[1];
	    var Nz = cam.reflection_plane[2];
	    var D  = cam.reflection_plane[3];

	    var refl_mat = cam.view_refl_matrix;

	    refl_mat[0] = 1.0 - 2.0 * Nx * Nx;
	    refl_mat[1] = -2.0 * Nx * Ny;
	    refl_mat[2] = -2.0 * Nx * Nz;
	    refl_mat[3] = 0.0;

	    refl_mat[4] = -2.0 * Nx * Ny;
	    refl_mat[5] = 1.0 - 2.0 * Ny * Ny;
	    refl_mat[6] = -2.0 * Ny * Nz;
	    refl_mat[7] = 0.0;

	    refl_mat[8] = -2.0 * Nx * Nz;
	    refl_mat[9] = -2.0 * Ny * Nz;
	    refl_mat[10] = 1.0 - 2.0 * Nz * Nz;
	    refl_mat[11] = 0.0;

	    refl_mat[12] = -2.0 * Nx * D;
	    refl_mat[13] = -2.0 * Ny * D;
	    refl_mat[14] = -2.0 * Nz * D;
	    refl_mat[15] = 1.0;
	}

	/**
	* Reflect view matrix during reflection pass
	 */
	function reflect_view_matrix(cam) {
	    m_mat4.multiply(cam.view_matrix, cam.view_refl_matrix, cam.view_matrix);
	}

	exports.set_projection_reflect = set_projection_reflect;
	/**
	 * Change projection matrix for reflected camera during reflection pass
	 * uses _vec4_tmp, _vec4_tmp2, _mat4_tmp
	 */
	function set_projection_reflect(cam, ignore_after_actions) {
	    set_projection(cam, true);

	    var plane = _vec4_tmp;
	    var view_inv_transp_matrix = _mat4_tmp;

	    m_mat4.invert(cam.view_matrix, view_inv_transp_matrix);
	    m_mat4.transpose(view_inv_transp_matrix, view_inv_transp_matrix);
	    m_vec4.transformMat4(cam.reflection_plane, view_inv_transp_matrix, plane);

	    // NOTE: negate reflection plane if camera is behind the plane
	    //if (plane[3] > 0)
	    //    m_vec4.negate(plane, plane);

	    var corner_point = _vec4_tmp2;
	    corner_point[0] = (m_util.sign(plane[0]) + cam.proj_matrix[8]) / cam.proj_matrix[0];
	    corner_point[1] = (m_util.sign(plane[1]) + cam.proj_matrix[9]) / cam.proj_matrix[5];
	    corner_point[2] = -1;
	    corner_point[3] = (1.0 + cam.proj_matrix[10] ) / cam.proj_matrix[14];
	    var dot = plane[0] * corner_point[0] + plane[1] * corner_point[1]
	            + plane[2] * corner_point[2] + plane[3] * corner_point[3];

	    m_vec4.scale(plane, 2.0/dot, plane);

	    cam.proj_matrix[2]  = plane[0];
	    cam.proj_matrix[6]  = plane[1];
	    cam.proj_matrix[10] = plane[2] + 1.0;
	    cam.proj_matrix[14] = plane[3];

	    update_proj_transformed_view(cam);

	    if (!ignore_after_actions)
	        set_view_projection_after(cam);
	}

	function set_view_eye_target_up(cam, eye, target, up) {

	    m_mat4.lookAt(eye, target, up, cam.view_matrix);

	    var active_scene = m_scenes.get_active();
	    var subs_stereo = m_scenes.get_subs(active_scene, m_subs.STEREO);

	    if (cam.type == exports.TYPE_STEREO_LEFT ||
	            subs_stereo && subs_stereo.enable_hmd_stereo &&
	            cam.type == exports.TYPE_HMD_LEFT)
	        cam.view_matrix[12] += cam.stereo_eye_dist/2;
	    else if (cam.type == exports.TYPE_STEREO_RIGHT ||
	            subs_stereo && subs_stereo.enable_hmd_stereo &&
	            cam.type == exports.TYPE_HMD_RIGHT)
	        cam.view_matrix[12] -= cam.stereo_eye_dist/2;

	    // update view tsr
	    m_tsr.from_mat4(cam.view_matrix, cam.view_tsr);

	    calc_view_proj_inverse(cam);
	    calc_sky_vp_inverse(cam);

	    m_tsr.set_trans(eye, cam.world_tsr);
	}

	/**
	 * Simplified version to set non-camera object cams
	 * uses _vec3_tmp, _vec3_tmp2
	 * @param cam CAM object
	 * @param {vec3} trans Translation
	 * @param {vec4} quat Rotation quaternion
	 */
	exports.set_view_trans_quat = function(cam, trans, quat) {

	    // eye relative target
	    var target = _vec3_tmp;
	    target[0] = 0;
	    target[1] = 0;
	    target[2] =-1;

	    m_vec3.transformQuat(target, quat, target);

	    // absolute target
	    target[0] += trans[0];
	    target[1] += trans[1];
	    target[2] += trans[2];

	    var up = _vec3_tmp2;
	    up[0] = 0;
	    up[1] = 1;
	    up[2] = 0;
	    m_vec3.transformQuat(up, quat, up);

	    // NOTE: set view directly
	    set_view_eye_target_up(cam, trans, target, up);
	};

	/**
	 * uses _vec3_tmp, _quat4_tmp
	 */
	exports.set_look_at = set_look_at;
	function set_look_at(camobj, trans, look_at) {
	    var dest_vect = m_vec3.subtract(look_at, trans, _vec3_tmp);
	    if (m_vec3.length(dest_vect)) {
	        m_vec3.normalize(dest_vect, dest_vect);
	        var quat = m_util.rotation_to_stable(m_util.AXIS_MZ, dest_vect, _quat4_tmp);

	        m_trans.set_rotation(camobj, quat);
	    }
	    m_trans.set_translation(camobj, trans);
	}

	/**
	 * uses _vec3_tmp
	 * set_look_at which doesn't change previously corrected up vector
	 */
	exports.set_look_at_corrected = set_look_at_corrected;
	function set_look_at_corrected(camobj, trans, look_at) {
	    var render = camobj.render;

	    var ups_down = is_upside_down(camobj);
	    set_look_at(camobj, trans, look_at);

	    if (ups_down) {
	        var inv_axis = m_vec3.copy(render.vertical_axis, _vec3_tmp);
	        m_vec3.negate(inv_axis, inv_axis);
	        correct_up(camobj, inv_axis, true);
	    } else
	        correct_up(camobj, render.vertical_axis, true);
	}

	/**
	 * uses _vec3_tmp
	 */
	exports.update_camera_transform = update_camera_transform;
	function update_camera_transform(obj, cam_scene_data) {
	    var render = obj.render;
	    var cameras = cam_scene_data.cameras;

	    var quat = m_tsr.get_quat(render.world_tsr, _quat4_tmp);
	    var view_vector = m_util.quat_to_dir(quat, m_util.AXIS_MZ, _vec3_tmp);
	    var cam_loc = m_tsr.get_trans(render.world_tsr, _vec3_tmp2);

	    var shadow_cameras = cam_scene_data.shadow_cameras;
	    for (var i = 0; i < shadow_cameras.length; i++) {
	        var cam = shadow_cameras[i];
	        m_vec3.copy(view_vector, cam.direction);
	        m_tsr.get_trans(render.world_tsr, cam.lod_eye);
	    }
	    for (var i = 0; i < cameras.length; i++) {
	        var cam = cameras[i];
	        set_view(cam, obj);
	        m_vec3.copy(view_vector, cam.direction);
	        if (cam.dof_object) {
	            if (cam.dof_on) {
	                var obj_loc = m_trans.get_translation(cam.dof_object, _vec3_tmp3);
	                var dof_dist = m_vec3.dist(cam_loc, obj_loc);
	                cam.dof_distance = dof_dist;
	            }
	        }
	    }
	}


	exports.update_camera = function(obj) {
	    var render = obj.render;

	    clamp_limits(obj);
	    update_ortho_scale(obj);

	    switch (render.move_style) {

	    case exports.MS_TARGET_CONTROLS:
	        var trans = m_tsr.get_trans_view(render.world_tsr);
	        var quat  = m_tsr.get_quat_view(render.world_tsr);
	        m_util.quat_rotate_to_target(trans, quat, render.pivot, m_util.AXIS_MZ);

	        for (var j = 0; j < obj.scenes_data.length; j++) {
	        // use pivot to set convergence plane for anaglyph stereo view
	            var cams = obj.scenes_data[j].cameras;
	            for (var i = 0; i < cams.length; i++) {
	                var cam = cams[i];

	                if (cam.type == exports.TYPE_STEREO_LEFT || 
	                        cam.type == exports.TYPE_STEREO_RIGHT)
	                    set_stereo_params(cam, m_vec3.dist(trans, render.pivot),
	                            cam.stereo_eye_dist);
	            }
	        }

	        correct_up(obj, render.vertical_axis);
	        break;

	    case exports.MS_EYE_CONTROLS:
	        // NOTE: correction was made previously in m_cons.update_constraint() 
	        // for constrained cameras
	        if (!obj.constraint)
	            correct_up(obj, render.vertical_axis);
	        break;      
	    }

	    update_camera_upside_down(obj);
	};

	exports.correct_up = correct_up;
	/**
	 * Rotate camera to fix UP direction.
	 * Uses _vec3_tmp, _vec3_tmp2, _vec3_tmp3
	 */
	function correct_up(camobj, up_axis, strict) {
	    var render = camobj.render;
	    var quat = m_tsr.get_quat_view(render.world_tsr);

	    // local camera Z in world space
	    var z_cam_world = m_util.quat_to_dir(quat, m_util.AXIS_Z, _vec3_tmp);
	    m_vec3.normalize(z_cam_world, z_cam_world);
	    // handle extreme case (camera looks UP or DOWN)
	    if (Math.abs(m_vec3.dot(up_axis, z_cam_world)) > 0.999999)
	        var rotation = m_quat.identity(_quat4_tmp);
	    else {

	        var x_cam_world_new = m_vec3.cross(up_axis, z_cam_world, _vec3_tmp2);

	        m_vec3.normalize(x_cam_world_new, x_cam_world_new);

	        if (render.move_style == exports.MS_TARGET_CONTROLS) {
	            if (render.target_cam_upside_down)
	                m_vec3.negate(x_cam_world_new, x_cam_world_new);
	        } else {
	            // Y coord of local camera Z axis in parent(!) space
	            var my_cam_world = m_util.quat_to_dir(quat, m_util.AXIS_MY, _vec3_tmp3);
	            if (m_vec3.dot(my_cam_world, up_axis) > 0)
	                m_vec3.negate(x_cam_world_new, x_cam_world_new);
	        }

	        var x_cam_world = m_util.quat_to_dir(quat, m_util.AXIS_X, _vec3_tmp3);
	        m_vec3.normalize(x_cam_world, x_cam_world);

	        var cosine = m_util.clamp(m_vec3.dot(x_cam_world, x_cam_world_new), -1, 1);

	        if (cosine <= -0.999999) {
	            var angle = Math.acos(cosine);
	            var rotation = m_quat.setAxisAngle(z_cam_world, angle, _quat4_tmp);
	        } else
	            var rotation = m_quat.rotationTo(x_cam_world, x_cam_world_new, _quat4_tmp);

	        m_quat.normalize(rotation, rotation);
	    }

	    m_quat.multiply(rotation, quat, quat);

	    // strictly align camera with the given UP vector direction
	    if (strict) {
	        var y_cam_world = m_util.quat_to_dir(quat, m_util.AXIS_Y, _vec3_tmp);
	        if (m_vec3.dot(up_axis, y_cam_world) < 0)
	            m_quat.rotateZ(quat, Math.PI, quat);
	    }

	    update_camera_upside_down(camobj);
	}

	exports.update_camera_upside_down = update_camera_upside_down;
	function update_camera_upside_down(camobj) {
	    var render = camobj.render;
	    if (render.move_style == exports.MS_TARGET_CONTROLS)
	        render.target_cam_upside_down = is_upside_down(camobj);
	}

	/**
	 * uses _vec3_tmp
	 */ 
	function is_upside_down(camobj) {
	    var quat = m_tsr.get_quat_view(camobj.render.world_tsr);
	    var y_world_cam = m_util.quat_to_dir(quat, m_util.AXIS_Y, _vec3_tmp);
	    return y_world_cam[2] < 0;
	}

	exports.set_horizontal_rot_limits = set_horizontal_rot_limits;
	function set_horizontal_rot_limits(camobj, limits) {
	    var render = camobj.render;
	    if (limits) {
	        render.horizontal_limits = render.horizontal_limits || {};
	        render.horizontal_limits.left = limits.left;
	        render.horizontal_limits.right = limits.right;
	        render.horizontal_limits.left_local = limits.left;
	        render.horizontal_limits.right_local = limits.right;
	        render.horizontal_limits.camera_space = Boolean(limits.camera_space);
	        prepare_horizontal_limits(camobj);
	    } else
	        render.horizontal_limits = null;
	}

	/**
	 * Prepare limits to respond to CCW style
	 * uses _vec2_tmp
	 */
	function prepare_horizontal_limits(camobj) {
	    var render = camobj.render;
	    var limits = render.horizontal_limits;

	    if (limits && (render.move_style == exports.MS_EYE_CONTROLS 
	            || render.move_style == exports.MS_TARGET_CONTROLS)) {

	        var angles = get_camera_angles(camobj, _vec2_tmp);
	        if (limits.camera_space) {
	            limits.left += angles[0];
	            limits.right += angles[0];
	        } else {
	            limits.left_local -= angles[0];
	            limits.right_local -= angles[0];
	        }

	        limits.left = m_util.angle_wrap_0_2pi(limits.left);
	        limits.right = m_util.angle_wrap_0_2pi(limits.right);

	        limits.left_local = m_util.angle_wrap_0_2pi(limits.left_local);
	        limits.right_local = m_util.angle_wrap_0_2pi(limits.right_local);
	    }
	}

	exports.set_vertical_rot_limits = set_vertical_rot_limits;
	function set_vertical_rot_limits(camobj, limits) {
	    var render = camobj.render;
	    if (limits) {
	        render.vertical_limits = render.vertical_limits || {};
	        render.vertical_limits.down = limits.down;
	        render.vertical_limits.up = limits.up;
	        render.vertical_limits.down_local = limits.down;
	        render.vertical_limits.up_local = limits.up;
	        render.vertical_limits.camera_space = Boolean(limits.camera_space);
	        prepare_vertical_limits(camobj);
	    } else
	        render.vertical_limits = null;
	}

	/**
	 * uses _vec2_tmp
	 */
	exports.hover_set_vertical_limits = hover_set_vertical_limits;
	function hover_set_vertical_limits(camobj, limits) {
	    var render = camobj.render;

	    if (!limits) {
	        var angles = get_camera_angles(camobj, _vec2_tmp);
	        limits = {
	            down: angles[1],
	            up: angles[1]
	        };
	    }

	    render.vertical_limits = render.vertical_limits || {};
	    render.vertical_limits.down = limits.down;
	    render.vertical_limits.up = limits.up;
	    prepare_vertical_limits(camobj);

	    if (render.distance_limits && render.vertical_limits)
	        hover_camera_update_distance(camobj);
	}

	/**
	 * Prepare limits to respond to CCW style
	 * uses _vec2_tmp
	 */
	function prepare_vertical_limits(camobj) {
	    var render = camobj.render;
	    var limits = render.vertical_limits;

	    if (limits) {
	        switch (render.move_style) {
	        case exports.MS_EYE_CONTROLS:
	        case exports.MS_TARGET_CONTROLS:
	            var angles = get_camera_angles(camobj, _vec2_tmp);
	            if (limits.camera_space) {
	                limits.up += angles[1];
	                limits.down += angles[1];
	            } else {
	                limits.up_local -= angles[1];
	                limits.down_local -= angles[1];
	            }

	            limits.up = m_util.angle_wrap_periodic(limits.up, -Math.PI, Math.PI);
	            limits.down = m_util.angle_wrap_periodic(limits.down, -Math.PI, Math.PI);

	            limits.up_local = m_util.angle_wrap_periodic(limits.up_local, -Math.PI, Math.PI);
	            limits.down_local = m_util.angle_wrap_periodic(limits.down_local, -Math.PI, Math.PI);
	            break;
	        case exports.MS_HOVER_CONTROLS:
	            limits.up = m_util.angle_wrap_periodic(limits.up, -Math.PI, Math.PI);
	            limits.down = m_util.angle_wrap_periodic(limits.down, -Math.PI, Math.PI);  
	            limits.up = m_util.clamp(limits.up, -Math.PI / 2, 0);
	            limits.down = m_util.clamp(limits.down, -Math.PI / 2, 0);          
	            break;
	        }
	    }
	}

	exports.hover_set_distance_limits = hover_set_distance_limits;
	function hover_set_distance_limits(camobj, limits) {
	    var render = camobj.render;

	    if (!limits) {
	        var dist = m_trans.obj_point_distance(camobj, render.hover_pivot);
	        limits = {
	            min: dist,
	            max: dist
	        };
	    }

	    render.distance_limits = render.distance_limits || {};
	    render.distance_limits.min = limits.min;
	    render.distance_limits.max = limits.max;

	    if (render.distance_limits && render.vertical_limits)
	        hover_camera_update_distance(camobj);
	}

	exports.set_distance_limits = set_distance_limits;
	function set_distance_limits(camobj, limits) {
	    var render = camobj.render;
	    
	    if (limits) {
	        render.distance_limits = render.distance_limits || {};
	        render.distance_limits.min = limits.min;
	        render.distance_limits.max = limits.max;
	    } else
	        render.distance_limits = null;
	}

	exports.set_pivot_limits = set_pivot_limits;
	function set_pivot_limits(camobj, limits) {
	    var render = camobj.render;

	    if (limits) {
	        render.pivot_limits = render.pivot_limits || {};
	        render.pivot_limits.min_z = limits.min_z;
	        render.pivot_limits.max_z = limits.max_z;
	    } else
	        render.pivot_limits = null;
	}

	exports.set_hor_trans_limits = set_hor_trans_limits;
	function set_hor_trans_limits(camobj, limits) {
	    var render = camobj.render;

	    if (limits) {
	        render.hover_horiz_trans_limits = render.hover_horiz_trans_limits || {};
	        render.hover_horiz_trans_limits.min = limits.min;
	        render.hover_horiz_trans_limits.max = limits.max;
	    } else
	        render.hover_horiz_trans_limits = null;
	}

	exports.set_vert_trans_limits = set_vert_trans_limits;
	function set_vert_trans_limits(camobj, limits) {
	    var render = camobj.render;

	    if (limits) {
	        render.hover_vert_trans_limits = render.hover_vert_trans_limits || {};
	        render.hover_vert_trans_limits.min = limits.min;
	        render.hover_vert_trans_limits.max = limits.max;
	    } else
	        render.hover_vert_trans_limits = null;
	}

	exports.update_ortho_scale = update_ortho_scale;
	function update_ortho_scale(obj) {
	    var render = obj.render;

	    if (!m_obj_util.is_camera(obj))
	        return;

	    var scenes_data = obj.scenes_data;
	    for (var j = 0; j < scenes_data.length; j++) {
	        var cams = scenes_data[j].cameras;
	        if (cams[0].type === exports.TYPE_ORTHO) {
	            switch (render.move_style) {
	            case exports.MS_TARGET_CONTROLS:
	                var trans = m_tsr.get_trans_view(render.world_tsr);
	                var dir_dist = m_vec3.dist(trans, render.pivot);
	                var new_scale = dir_dist / render.init_dist * render.init_fov;
	                break;
	            case exports.MS_HOVER_CONTROLS:
	                var trans = m_tsr.get_trans_view(render.world_tsr);
	                var dir_dist = m_vec3.distance(trans, render.hover_pivot);
	                var new_scale = dir_dist / render.init_dist * render.init_fov;  
	                break;
	            default:
	                var new_scale = cams[0].fov;
	                break;
	            }
	            
	            for (var i = 0; i < cams.length; i++) {
	                var cam = cams[i];
	                cam.fov = new_scale;
	                set_projection(cam, true);
	            }

	            update_camera_transform(obj, scenes_data[j]);
	        }
	    }
	}

	/**
	 * uses _vec2_tmp
	 */
	function clamp_limits(obj) {

	    var render = obj.render;
	    var ms = render.move_style;

	    if (ms === exports.MS_TARGET_CONTROLS || ms === exports.MS_EYE_CONTROLS) {

	        // horizontal rotation clamping
	        if (render.horizontal_limits) {
	            var left = render.horizontal_limits.left;
	            var right = render.horizontal_limits.right;
	            var angles = get_camera_angles(obj, _vec2_tmp);

	            // CCW: left->right for TARGET camera; right->left for EYE camera
	            if (ms == exports.MS_TARGET_CONTROLS)
	                var ret_angle = m_util.calc_returning_angle(angles[0], left, right);
	            else
	                var ret_angle = m_util.calc_returning_angle(angles[0], right, left);

	            if (ret_angle) {
	                
	                if (ms == exports.MS_TARGET_CONTROLS)
	                    rotate_target_angles(obj, ret_angle, 0);
	                else
	                    rotate_eye_angles(obj, ret_angle, 0);
	            }
	        }

	        // vertical rotation clamping
	        if (render.vertical_limits) {
	            var down = render.vertical_limits.down;
	            var up = render.vertical_limits.up;
	            var angles = get_camera_angles(obj, _vec2_tmp);

	            // CCW: up->down for TARGET camera; down->up for EYE camera
	            if (ms == exports.MS_TARGET_CONTROLS)
	                var ret_angle = m_util.calc_returning_angle(angles[1], up, down);
	            else
	                var ret_angle = m_util.calc_returning_angle(angles[1], down, up);

	            if (ret_angle) {
	                if (ms == exports.MS_TARGET_CONTROLS)
	                    rotate_target_angles(obj, 0, ret_angle);
	                else
	                    rotate_eye_angles(obj, 0, ret_angle);
	            }
	        }

	        // distance clamping
	        if (ms === exports.MS_TARGET_CONTROLS && render.distance_limits)
	            target_cam_clamp_distance(obj);
	    }

	    if (ms === exports.MS_TARGET_CONTROLS && render.pivot_limits)
	        target_clamp_pivot_limits(obj);
	    
	    if (ms === exports.MS_HOVER_CONTROLS) { 
	        // horizontal, vertical translation clamping
	        hover_cam_clamp_axis_limits(obj); 
	        hover_cam_clamp_rotation(obj);
	    }
	}

	function get_delta_angles(obj, phi, theta, dest) {
	    var curr_angles = get_camera_angles(obj, _vec2_tmp3);
	    dest[0] = phi - curr_angles[0];
	    dest[1] = theta - curr_angles[1];
	    return dest;
	}

	exports.rotate_target_angles = rotate_target_angles;
	function rotate_target_angles(obj, d_phi, d_theta) {
	    var render = obj.render;
	    camera_rotate_point_pivot(obj, obj.render.pivot, d_phi, d_theta);        

	    // NOTE: need angles after(!) rotation
	    var angles = get_camera_angles(obj, _vec2_tmp2);
	    var dest_theta = m_util.angle_wrap_periodic(angles[1], -Math.PI, Math.PI);
	    render.target_cam_upside_down = Math.abs(dest_theta) > Math.PI / 2;
	}

	/**
	 * uses _vec2_tmp2
	 */
	exports.set_rotation_target_angles = set_rotation_target_angles;
	function set_rotation_target_angles(obj, phi, theta) {
	    var deltas = get_delta_angles(obj, phi, theta, _vec2_tmp2);
	    var d_phi = deltas[0];
	    var d_theta = deltas[1];
	    rotate_target_angles(obj, d_phi, d_theta);
	}

	exports.rotate_eye_angles = rotate_eye_angles;
	function rotate_eye_angles(obj, d_phi, d_theta) {
	    rotate_static_angles(obj, d_phi, d_theta);
	}

	exports.set_rotation_eye_angles = set_rotation_eye_angles;
	function set_rotation_eye_angles(obj, phi, theta) {
	    set_rotation_static_angles(obj, phi, theta);
	}

	exports.rotate_static_angles = rotate_static_angles;
	function rotate_static_angles(obj, d_phi, d_theta) {
	    var render = obj.render;
	    if (d_phi || d_theta) {
	        var rot_quat = m_quat.identity(_quat4_tmp);

	        if (d_phi) {
	            var quat_phi = m_quat.setAxisAngle(render.vertical_axis, d_phi, _quat4_tmp2);
	            m_quat.multiply(rot_quat, quat_phi, rot_quat);
	        }

	        var obj_quat = m_tsr.get_quat_view(render.world_tsr);
	        if (d_theta) {
	            var x_world_obj = m_util.quat_to_dir(obj_quat, m_util.AXIS_X, _vec3_tmp);
	            var quat_theta = m_quat.setAxisAngle(x_world_obj, d_theta, _quat4_tmp2);
	            // NOTE: obj_quat->x_world_obj->quat_theta->obj_quat leads to
	            // error accumulation if quat_theta is not normalized
	            m_quat.normalize(quat_theta, quat_theta);
	            m_quat.multiply(rot_quat, quat_theta, rot_quat);
	        }

	        m_quat.multiply(rot_quat, obj_quat, obj_quat);
	        // NOTE: it prevents the EYE camera bug, when it changes its vertical angle sign
	        m_quat.normalize(obj_quat, obj_quat);
	    }
	}

	exports.set_rotation_static_angles = set_rotation_static_angles;
	function set_rotation_static_angles(obj, phi, theta) {
	    var d_phi = phi;
	    var d_theta = theta;
	    var render = obj.render;
	    var quat = m_tsr.get_quat(render.world_tsr, _quat4_tmp);
	    var curr_angles = get_camera_angles_from_quat(quat, _vec2_tmp);

	    d_phi = phi - curr_angles[0];
	    d_theta = theta - curr_angles[1];
	    rotate_static_angles(obj, d_phi, d_theta);
	}

	exports.rotate_hover_angles = rotate_hover_angles;
	function rotate_hover_angles(obj, d_phi, d_theta) {
	    var render = obj.render;
	    if (!render.enable_hover_hor_rotation)
	        d_phi = 0;

	    camera_rotate_point_pivot(obj, render.hover_pivot, d_phi, d_theta);

	    if (d_theta)
	        hover_camera_update_distance(obj);
	}
	/**
	 * uses _vec2_tmp2
	 */
	exports.set_rotation_hover_angles = set_rotation_hover_angles;
	function set_rotation_hover_angles(obj, phi, theta) {
	    var deltas = get_delta_angles(obj, phi, theta, _vec2_tmp2);
	    var d_phi = deltas[0];
	    var d_theta = deltas[1];
	    rotate_hover_angles(obj, d_phi, d_theta);
	}

	exports.rotate_angles = function(obj, d_phi, d_theta) {
	    var render = obj.render;
	    var ms = render.move_style;

	    if (ms === exports.MS_TARGET_CONTROLS)
	        rotate_target_angles(obj, d_phi, d_theta);
	    else if (ms === exports.MS_EYE_CONTROLS)
	        rotate_eye_angles(obj, d_phi, d_theta);
	    else if (ms === exports.MS_HOVER_CONTROLS)
	        rotate_hover_angles(obj, d_phi, d_theta);
	    else if (ms === exports.MS_STATIC)
	        rotate_static_angles(obj, d_phi, d_theta);
	};

	exports.set_rotation_angles = function(obj, phi, theta) {
	    var render = obj.render;
	    var ms = render.move_style;

	    if (ms === exports.MS_TARGET_CONTROLS)
	        set_rotation_target_angles(obj, phi, theta);
	    else if (ms === exports.MS_EYE_CONTROLS)
	        set_rotation_eye_angles(obj, phi, theta);
	    else if (ms === exports.MS_HOVER_CONTROLS)
	        set_rotation_hover_angles(obj, phi, theta);
	    else if (ms === exports.MS_STATIC)
	        set_rotation_static_angles(obj, phi, theta);
	};

	/**
	 * uses _vec3_tmp, _quat4_tmp, _quat4_tmp2
	 */
	function camera_rotate_point_pivot(obj, pivot, d_phi, d_theta) {
	    var render = obj.render;

	    if (d_phi || d_theta) {
	        var rot_quat = m_quat.identity(_quat4_tmp);

	        if (d_phi) {
	            var quat_phi = m_quat.setAxisAngle(m_util.AXIS_Z, d_phi, _quat4_tmp2);
	            m_quat.multiply(rot_quat, quat_phi, rot_quat);
	        }

	        var cam_quat = m_tsr.get_quat_view(render.world_tsr);
	        if (d_theta) {
	            var x_world_cam = m_util.quat_to_dir(cam_quat, m_util.AXIS_X, _vec3_tmp);
	            var quat_theta = m_quat.setAxisAngle(x_world_cam, d_theta, _quat4_tmp2);
	            // NOTE: cam_quat->x_world_cam->quat_theta->cam_quat leads to
	            // error accumulation if quat_theta is not normalized
	            m_quat.normalize(quat_theta, quat_theta);
	            m_quat.multiply(rot_quat, quat_theta, rot_quat);
	        }
	        var trans = m_tsr.get_trans_view(render.world_tsr);
	        m_util.rotate_point_pivot(trans, pivot, rot_quat, trans);

	        // direct camera to pivot
	        m_quat.multiply(rot_quat, cam_quat, cam_quat);
	        m_quat.normalize(cam_quat, cam_quat);
	    }
	}

	/**
	 * Change distance to pivot according to current elevation angle
	 * uses _vec2_tmp, _vec3_tmp
	 */
	function hover_camera_update_distance(obj) {
	    var render = obj.render;

	    var elevation_angle = get_camera_angles(obj, _vec2_tmp)[1];
	    var dist = hover_cam_calc_distance_for_angle(obj, elevation_angle);

	    // NOTE: don't use trans->pivot vector, because of errors near pivot (distance ~ 0)
	    var trans = m_tsr.get_trans_view(render.world_tsr);
	    var quat  = m_tsr.get_quat_view(render.world_tsr);
	    var view_vector = m_util.quat_to_dir(quat, m_util.AXIS_MZ, _vec3_tmp);
	    m_vec3.normalize(view_vector, view_vector);
	    m_vec3.scale(view_vector, dist, view_vector);
	    m_vec3.subtract(render.hover_pivot, view_vector, trans);
	}

	function hover_cam_calc_distance_for_angle(obj, elevation_angle) {
	    var render = obj.render;

	    var v_lims = render.vertical_limits;
	    var d_lims = render.distance_limits;

	    if (v_lims.down - v_lims.up) {
	        var rot_factor = (v_lims.down - elevation_angle) / (v_lims.down - v_lims.up);
	        rot_factor = Math.max(rot_factor, 0);
	    } else
	        // set minimum distance for equal up and down angles
	        var rot_factor = 0;

	    return rot_factor * (d_lims.max - d_lims.min) + d_lims.min;
	}

	/**
	 * uses _vec3_tmp, _vec3_tmp2
	 */
	function target_cam_clamp_distance(obj) {
	    var render = obj.render;
	    var trans = m_tsr.get_trans_view(render.world_tsr);
	    var dist_vector = m_vec3.subtract(trans, render.pivot, _vec3_tmp);
	    var len = m_vec3.length(dist_vector);

	    if (len > render.distance_limits.max) {
	        var scale = render.distance_limits.max / len;
	        m_vec3.scale(dist_vector, scale, dist_vector);
	        m_vec3.add(render.pivot, dist_vector, trans);
	    } else if (len < render.distance_limits.min) {
	        // add scaled camera view vector (the more the better) to stabilize
	        // minimum distance clamping
	        var quat = m_tsr.get_quat_view(render.world_tsr);
	        var cam_view = m_util.quat_to_dir(quat, m_util.AXIS_MZ, _vec3_tmp2);
	        m_vec3.scale(cam_view, 100 * render.distance_limits.min, cam_view);
	        m_vec3.add(dist_vector, cam_view, dist_vector);

	        // calculate clamped position on the arc of the minimum circle
	        m_vec3.scale(dist_vector,
	                -render.distance_limits.min / m_vec3.length(dist_vector), dist_vector);
	        m_vec3.add(render.pivot, dist_vector, trans);
	    }
	}

	function target_clamp_pivot_limits(obj) {
	    var render = obj.render;

	    var z_old = render.pivot[2];
	    var z_new = m_util.clamp(render.pivot[2], render.pivot_limits.min_z,
	            render.pivot_limits.max_z);

	    if (z_new != z_old) {
	        var correction_vec = m_vec3.set(0, 0, z_new - z_old, _vec3_tmp);
	        m_vec3.add(render.pivot, correction_vec, render.pivot);

	        var trans = m_tsr.get_trans_view(render.world_tsr);
	        m_vec3.add(trans, correction_vec, trans);        
	    }
	}

	function hover_cam_clamp_axis_limits(obj) {
	    var render = obj.render;

	    if (render.hover_horiz_trans_limits) {
	        var horiz_delta = m_util.clamp(render.hover_pivot[0], 
	                render.hover_horiz_trans_limits.min, render.hover_horiz_trans_limits.max)
	                - render.hover_pivot[0];
	        render.hover_pivot[0] += horiz_delta;
	        var trans = m_tsr.get_trans_view(render.world_tsr);
	        trans[0] += horiz_delta;
	    }

	    if (render.hover_vert_trans_limits) {
	        var vert_delta = m_util.clamp(render.hover_pivot[1], 
	                render.hover_vert_trans_limits.min, 
	                render.hover_vert_trans_limits.max) 
	                - render.hover_pivot[1];
	        render.hover_pivot[1] += vert_delta;
	        var trans = m_tsr.get_trans_view(render.world_tsr);
	        trans[1] += vert_delta;
	    }
	}

	/**
	 * uses _vec2_tmp
	 */
	function hover_cam_clamp_rotation(obj) {
	    var render = obj.render;

	    var curr_angle = get_camera_angles(obj, _vec2_tmp)[1];
	    var ret_angle = m_util.calc_returning_angle(curr_angle, 
	            render.vertical_limits.up, render.vertical_limits.down);

	    if (ret_angle)
	        rotate_hover_angles(obj, 0, ret_angle);
	}

	/**
	 * Check if camera has float or fixed aspect ratio
	 */
	exports.is_float_aspect = function(cam) {
	    switch (cam.type) {

	    case exports.TYPE_PERSP:
	    case exports.TYPE_ORTHO:
	    case exports.TYPE_STEREO_LEFT:
	    case exports.TYPE_STEREO_RIGHT:
	        return true;
	    default:
	        return false;
	    }
	};

	/**
	 * Return minimal camera angular diameter, calculated from FOV.
	 */
	exports.get_angular_diameter = function(cam) {

	    switch (cam.type) {
	    case exports.TYPE_PERSP:
	    case exports.TYPE_PERSP_ASPECT:
	    case exports.TYPE_STEREO_LEFT:
	    case exports.TYPE_STEREO_RIGHT:
	        var vfov = get_vfov(cam);
	        var hfov = get_hfov(cam);
	        return Math.min(vfov, hfov);
	    default:
	        m_print.error("get_angular_diameter(): Unsupported camera type: " + cam.type);
	        return 0;
	    }
	};

	/**
	 * @param cam Camera ID
	 * @param {number} aspect Aspect ratio for camera with float aspect
	 */
	exports.set_aspect = set_aspect;
	function set_aspect(cam, aspect) {
	    switch (cam.type) {
	    case exports.TYPE_PERSP_ASPECT:
	    case exports.TYPE_ORTHO_ASPECT:
	        m_print.error("set_aspect(): Unsupported camera type: " + cam.type);
	        break;
	    default:
	        cam.aspect = aspect;
	        break;
	    }
	}

	exports.get_aspect = function(cam) {
	    return cam.aspect;
	};

	exports.set_projection = set_projection;
	/**
	 * @param cam Camera ID
	 * @param {boolean} ignore_after_actions Don't update view projection matrix and 
	 * frustum planes. This is used when calling set_projection inside or right 
	 * before the set_view() method to avoid unnecessary calculations.
	 */
	function set_projection(cam, ignore_after_actions) {

	    switch (cam.type) {
	    case exports.TYPE_PERSP:
	    case exports.TYPE_PERSP_ASPECT:
	        m_mat4.perspective(get_vfov(cam), cam.aspect, cam.near, cam.far,
	                cam.proj_matrix);
	        break;

	    case exports.TYPE_ORTHO:
	    case exports.TYPE_ORTHO_ASPECT:
	        var top = get_vfov(cam);
	        var right = top * cam.aspect;
	        m_mat4.ortho(-right, right, -top, top, cam.near, cam.far,
	                cam.proj_matrix);
	        break;

	    case exports.TYPE_ORTHO_ASYMMETRIC:
	        // it seams that m_mat4.ortho in general needs positive z values
	        m_mat4.ortho(cam.left, cam.right, cam.bottom, cam.top,
	                cam.near, cam.far, cam.proj_matrix);
	        break;

	    case exports.TYPE_STEREO_LEFT:
	    case exports.TYPE_STEREO_RIGHT:
	        set_projection_stereo(cam);
	        break;
	    case exports.TYPE_HMD_LEFT:
	    case exports.TYPE_HMD_RIGHT:
	        set_projection_hmd(cam);
	        break;

	    case exports.TYPE_NONE:
	        return;
	    default:
	        m_util.panic("Wrong camera type: " + cam.type);
	    }

	    update_proj_transformed_view(cam);

	    if (!ignore_after_actions)
	        set_view_projection_after(cam);
	}

	function set_projection_stereo(cam) {
	    // anaglyph
	    var fov_tan = Math.tan(get_vfov(cam) / 2);

	    var top = cam.near * fov_tan;
	    var bottom = -top;

	    // half of convergence plane in horizontal rotation direction
	    var a = cam.aspect * cam.stereo_conv_dist * fov_tan;

	    if (cam.type == exports.TYPE_STEREO_LEFT) {
	        // part of convergence plane left to eye
	        var b = a - cam.stereo_eye_dist/2;
	        // part of convergence plane right to eye
	        var c = a + cam.stereo_eye_dist/2;
	    } else {
	        var b = a + cam.stereo_eye_dist/2;
	        var c = a - cam.stereo_eye_dist/2;
	    }

	    var left = -(cam.near / cam.stereo_conv_dist * b);
	    var right = cam.near / cam.stereo_conv_dist * c;

	    m_mat4.frustum(left, right, bottom, top, cam.near, cam.far,
	            cam.proj_matrix);

	    // NOTE: save for extraction
	    cam.left = left;
	    cam.right = right;
	}

	function set_projection_hmd(cam) {
	    if (!m_scenes.check_active()) {
	        return;
	    }

	    var active_scene = m_scenes.get_active();
	    var subs_stereo = m_scenes.get_subs(active_scene, m_subs.STEREO);
	    if (subs_stereo && subs_stereo.enable_hmd_stereo) {
	        // VR mode

	        var up_fov_tan    = Math.tan(cam.hmd_fov[0]);
	        var right_fov_tan = Math.tan(cam.hmd_fov[1]);
	        var down_fov_tan  = Math.tan(cam.hmd_fov[2]);
	        var left_fov_tan  = Math.tan(cam.hmd_fov[3]);

	        // NOTE: save for extraction
	        cam.top    = cam.near * up_fov_tan;
	        cam.right  = cam.near * right_fov_tan;
	        cam.bottom = - cam.near * down_fov_tan;
	        cam.left   = - cam.near * left_fov_tan;

	        m_mat4.frustum(cam.left, cam.right, cam.bottom, cam.top, cam.near, cam.far,
	                cam.proj_matrix);
	    } else {
	        // non-VR mode

	        // set up cam.top, cam.right, cam.bottom, cam.left, bcz it will be extracted later.
	        cam.top = cam.near * Math.tan(get_vfov(cam) / 2);
	        cam.bottom = -cam.top;
	        cam.right = cam.top * cam.aspect;
	        cam.left = -cam.right;

	        m_mat4.perspective(get_vfov(cam), cam.aspect, cam.near, cam.far,
	                cam.proj_matrix);
	    }
	}

	exports.set_color_pick_proj = function(camera, x, y, w, h) {
	    // less is better
	    var sq = 1 / Math.max(h, w);

	    switch (camera.type) {
	    case exports.TYPE_NONE:
	    case exports.TYPE_PERSP:
	    case exports.TYPE_PERSP_ASPECT:
	        var h2 = h / 2;
	        var w2 = w / 2;
	        y = - (y - h2) / h2 * Math.tan(get_vfov(camera) / 2.0);
	        x = (x - w2) / w2 * Math.tan(get_vfov(camera) / 2.0) * camera.aspect;
	        var top    = camera.near * (y + sq);
	        var right  = camera.near * (x + sq);
	        var bottom = camera.near * (y - sq);
	        var left   = camera.near * (x - sq);
	        m_mat4.frustum(left, right, bottom, top, camera.near, camera.far,
	                camera.proj_matrix);
	        break;
	    case exports.TYPE_ORTHO:
	    case exports.TYPE_ORTHO_ASPECT:
	        y = - y / h;
	        x = x / w;

	        var top = get_vfov(camera);
	        var right = top * camera.aspect;

	        var left   = - right + (x - sq) * (right + right);
	        right = - right + (x + sq) * (right + right);

	        var bottom = top + (y - sq) * (top + top);
	        top = top + (y + sq) * (top + top);

	        m_mat4.ortho(left, right, bottom, top, camera.near, camera.far,
	                camera.proj_matrix);
	        break;
	    case exports.TYPE_ORTHO_ASYMMETRIC:
	        y = - y / h;
	        x = x / w;
	        var top    = camera.top + (y + sq) * (camera.top - camera.bottom);
	        var right  = camera.left + (x + sq) * (camera.right - camera.left);
	        var bottom = camera.top + (y - sq) * (camera.top - camera.bottom);
	        var left   = camera.left + (x - sq) * (camera.right - camera.left);
	        m_mat4.ortho(left, right, bottom, top, camera.near, camera.far,
	                camera.proj_matrix);
	        break;
	    }

	    update_proj_transformed_view(camera);

	    set_view_projection_after(camera);
	};

	function update_proj_transformed_view(cam) {
	    m_mat4.translate(cam.proj_matrix, cam.view_transform_params.trans, 
	            cam.proj_matrix);
	    m_mat4.rotateZ(cam.proj_matrix, cam.view_transform_params.angle, 
	            cam.proj_matrix);
	}

	function set_view_projection_after(cam) {
	    calc_view_proj_inverse(cam);
	    calc_sky_vp_inverse(cam);
	    m_util.extract_frustum_planes(cam.view_proj_matrix, cam.frustum_planes);
	}

	function calc_view_proj_inverse(cam) {
	    m_mat4.copy(cam.view_matrix, cam.view_proj_matrix);
	    m_mat4.multiply(cam.proj_matrix, cam.view_proj_matrix,
	            cam.view_proj_matrix);
	    m_mat4.invert(cam.view_proj_matrix, cam.view_proj_inv_matrix);
	}

	exports.calc_sky_vp_inverse = calc_sky_vp_inverse;
	function calc_sky_vp_inverse(cam) {
	    //mat4.toRotationMat(cam.view_matrix, cam.sky_vp_inv_matrix);
	    m_mat4.copy(cam.view_matrix, cam.sky_vp_inv_matrix);
	    cam.sky_vp_inv_matrix[12] = 0;
	    cam.sky_vp_inv_matrix[13] = 0;
	    cam.sky_vp_inv_matrix[14] = 0;
	    cam.sky_vp_inv_matrix[15] = 1;

	    m_mat4.multiply(cam.proj_matrix, cam.sky_vp_inv_matrix,
	            cam.sky_vp_inv_matrix);
	    m_mat4.invert(cam.sky_vp_inv_matrix, cam.sky_vp_inv_matrix);
	}

	/**
	 * Extract frustum corner coords
	 * uses _mat4_tmp
	 */
	exports.extract_frustum_corners = extract_frustum_corners;
	function extract_frustum_corners(cam, near, far, corners, is_world_space) {
	    if (!corners)
	        corners = new Float32Array(24);

	    if (!near)
	        near = cam.near;
	    if (!far)
	        far = cam.far;

	    var top_near, right_near, left_near, bottom_near;
	    var top_far, right_far, left_far, bottom_far;

	    switch (cam.type) {

	    case exports.TYPE_NONE:
	        m_util.panic("Extraction from NONE camera is not possible");
	        break;

	    case exports.TYPE_PERSP:
	    case exports.TYPE_PERSP_ASPECT:
	        top_near = near * Math.tan(get_vfov(cam) / 2);
	        bottom_near = -top_near;
	        right_near = top_near * cam.aspect;
	        left_near = -right_near;

	        var coeff = far / near;

	        top_far = top_near * coeff;
	        bottom_far = -top_far;
	        right_far = top_far * cam.aspect;
	        left_far = -right_far;

	        break;

	    case exports.TYPE_ORTHO:
	    case exports.TYPE_ORTHO_ASPECT:
	        var top = get_vfov(cam);
	        var right = top * cam.aspect;

	        top_near = top_far = top;
	        right_near = right_far = right;

	        bottom_near = bottom_far = -top;
	        left_near = left_far = -right;

	        break;
	    case exports.TYPE_ORTHO_ASYMMETRIC:
	        top_near = top_far = cam.top;
	        right_near = right_far = cam.right;

	        bottom_near = bottom_far = cam.bottom;
	        left_near = left_far = cam.left;

	        break;

	    case exports.TYPE_STEREO_LEFT:
	    case exports.TYPE_STEREO_RIGHT:
	        var coeff_near = near / cam.near;

	        top_near = near * Math.tan(get_vfov(cam) / 2);
	        bottom_near = -top_near;
	        right_near = cam.right * coeff_near;
	        left_near = cam.left * coeff_near;

	        var coeff_far = far / near;

	        top_far = top_near * coeff_far;
	        bottom_far = -top_far;
	        right_far = right_near * coeff_far;
	        left_far = left_near * coeff_far;

	        break;

	    case exports.TYPE_HMD_LEFT:
	    case exports.TYPE_HMD_RIGHT:
	        var coeff_near = near / cam.near;

	        top_near    = cam.top * coeff_near;
	        bottom_near = cam.bottom * coeff_near;
	        right_near  = cam.right * coeff_near;
	        left_near   = cam.left * coeff_near;

	        var coeff_far = far / near;

	        top_far    = top_near * coeff_far;
	        bottom_far = bottom_near * coeff_far;
	        right_far  = right_near * coeff_far;
	        left_far   = left_near * coeff_far;

	        break;

	    default:
	        m_util.panic("Wrong camera type: " + cam.type);
	    }

	    // near 1,2,3,4 CCW from zero point of view
	    corners[0] = left_near;
	    corners[1] = bottom_near;
	    corners[2] = -near;

	    corners[3] = right_near;
	    corners[4] = bottom_near;
	    corners[5] = -near;

	    corners[6] = right_near;
	    corners[7] = top_near;
	    corners[8] = -near;

	    corners[9] = left_near;
	    corners[10] = top_near;
	    corners[11] = -near;

	    // far 5,6,7,8 CW from zero point of view
	    corners[12] = left_far;
	    corners[13] = bottom_far;
	    corners[14] = -far;

	    corners[15] = left_far;
	    corners[16] = top_far;
	    corners[17] = -far;

	    corners[18] = right_far;
	    corners[19] = top_far;
	    corners[20] = -far;

	    corners[21] = right_far;
	    corners[22] = bottom_far;
	    corners[23] = -far;

	    // to world space
	    if (is_world_space) {
	        var view_inv = _mat4_tmp;
	        m_mat4.invert(cam.view_matrix, view_inv);
	        m_util.positions_multiply_matrix(corners, view_inv, corners, 0);
	    }

	    return corners;
	}

	/**
	 * Assign boundings for camera
	 */
	exports.assign_boundings = function(camobj) {

	    var render = camobj.render;

	    var bb = m_bounds.create_bb();

	    bb.min_x =-1;
	    bb.max_x = 1;
	    bb.min_y =-1;
	    bb.max_y = 1;
	    bb.min_z =-1;
	    bb.max_z = 1;

	    render.bb_local = bb;

	    var bs = m_bounds.bs_from_values(1, m_util.f32([0,0,0]));
	    render.bs_local = bs;

	    render.bcap_local = m_bounds.bcap_from_values(1, bb);
	    render.bcyl_local = m_bounds.bcyl_from_values(1, bb);
	    render.bcon_local = m_bounds.bcon_from_values(1, bb);
	};

	exports.is_static_camera = is_static_camera;
	function is_static_camera(obj) {
	    return m_obj_util.is_camera(obj) && obj.render 
	            && obj.render.move_style == exports.MS_STATIC;
	}

	exports.is_target_camera = is_target_camera;
	function is_target_camera(obj) {
	    return m_obj_util.is_camera(obj) && obj.render 
	            && obj.render.move_style == exports.MS_TARGET_CONTROLS;
	}

	exports.is_eye_camera = function(obj) {
	    return m_obj_util.is_camera(obj) && obj.render 
	            && obj.render.move_style == exports.MS_EYE_CONTROLS;
	};

	exports.is_hover_camera = is_hover_camera;
	function is_hover_camera(obj) {
	    return m_obj_util.is_camera(obj) && obj.render 
	            && obj.render.move_style == exports.MS_HOVER_CONTROLS;
	}

	exports.is_ortho_camera = function(obj) {
	    return m_obj_util.is_camera(obj) && obj.render 
	            && obj.scenes_data[0].cameras[0].type == exports.TYPE_ORTHO;
	};

	exports.update_camera_shadows = update_camera_shadows;
	function update_camera_shadows(cam, shadow_params) {
	    if (shadow_params.enable_csm)
	        update_camera_csm(cam, shadow_params);
	    else
	        cam.pcf_blur_radii[0] = shadow_params.first_cascade_blur_radius;
	}

	function update_camera_csm(cam, shadow_params) {
	    var N = shadow_params.csm_num;

	    if (!cam.csm_centers)
	        init_camera_csm(cam, shadow_params);

	    for (var i = 0; i < N; i++) {
	        var near = (i == 0) ? cam.near : csm_far_plane(shadow_params, cam,
	                i - 1);
	        var far = csm_far_plane(shadow_params, cam, i);

	        var corners = extract_frustum_corners(cam, near, far,
	                _frustum_corners_tmp);

	        var mec = m_bounds.get_frustum_mec(corners);

	        cam.csm_centers[i].set(mec.center);
	        cam.csm_radii[i] = mec.radius;
	        cam.csm_center_dists[i] = m_vec3.length(mec.center);

	        // calculate PCF blur radius
	        var blur_rad_first = shadow_params.first_cascade_blur_radius;
	        var blur_rad_last = shadow_params.last_cascade_blur_radius;

	        cam.pcf_blur_radii[i] = get_cascade_interpolation(blur_rad_first,
	                blur_rad_last, N, i);
	    }
	}

	function init_camera_csm(cam, shadow_params) {
	    var csm_num = shadow_params.csm_num;
	    cam.csm_centers = new Array(csm_num);
	    for (var i = 0; i < csm_num; i++)
	        cam.csm_centers[i] = new Float32Array(3);

	    cam.csm_radii = new Float32Array(csm_num);
	}

	function clone_camera_csm(cam, cam_new) {
	    if (!cam.csm_centers)
	        return;

	    var csm_num = cam.csm_centers.length;
	    cam_new.csm_centers = new Array(csm_num);
	    for (var i = 0; i < csm_num; i++)
	        cam_new.csm_centers[i] = m_vec3.clone(cam.csm_centers[i]);

	    cam_new.csm_radii = new Float32Array(cam.csm_radii);
	}

	exports.csm_far_plane = csm_far_plane;
	function csm_far_plane(shadow_params, cam, csm_index) {
	    var N = shadow_params.csm_num;

	    var border_first = m_util.clamp(shadow_params.csm_first_cascade_border,
	            cam.near, cam.far);
	    var border_last  = m_util.clamp(shadow_params.csm_last_cascade_border,
	            cam.near, cam.far);
	    var far = get_cascade_interpolation(border_first, border_last, N, csm_index);

	    // clamp to camera near/far plane
	    return m_util.clamp(far, cam.near, cam.far);
	}

	/**
	 * Get interpolated value for specific casade
	 */
	function get_cascade_interpolation(val_first, val_last, casc_count, casc_index) {
	    switch (casc_index) {
	    case 0:
	        var val = val_first;
	        break;
	    case casc_count - 1:
	        var val = val_last;
	        break;
	    default:
	        var val = (val_first == 0) ? 0 : val_first
	                * Math.pow(val_last / val_first, casc_index / (casc_count - 1));
	        break;
	    }

	    return val;
	}

	/**
	 * uses _vec4_tmp
	 */
	exports.project_point = function(camobj, point, dest) {
	    var cam = camobj.scenes_data[0].cameras[0];

	    switch (cam.type) {
	    case exports.TYPE_PERSP:
	    case exports.TYPE_PERSP_ASPECT:
	    case exports.TYPE_ORTHO:
	    case exports.TYPE_ORTHO_ASPECT:
	    case exports.TYPE_STEREO_LEFT:
	    case exports.TYPE_STEREO_RIGHT:
	    case exports.TYPE_HMD_LEFT:
	    case exports.TYPE_HMD_RIGHT:
	    case exports.TYPE_NONE:
	        var dir = _vec4_tmp;
	        dir.set(point);
	        dir[3] = 1;

	        var vp = cam.view_proj_matrix;
	        m_vec4.transformMat4(dir, vp, dir);

	        var x = dir[0] / dir[3];
	        // NOTE: flip y coordinate to match space origin (top left corner)
	        // view+proj transformation doesn't do it
	        var y = -dir[1] / dir[3];

	        // transform from [-1, 1] to [0, cam.width] or [0, cam.height] interval
	        dest[0] = (x + 1) / 2 * cam.width;
	        dest[1] = (y + 1) / 2 * cam.height;

	        // convert to CSS canvas cordinates
	        m_cont.viewport_to_canvas_coords(dest[0], dest[1], dest, cam);

	        // NOTE: depth factor (0-1)
	        if (dest.length > 2)
	            dest[2] = (dir[2] / Math.abs(dir[3]) + 1) / 2;

	        return dest;
	    default:
	        m_print.error("Non-compatible camera");
	        return dest;
	    }
	};

	exports.get_first_cam = function(camobj) {
	    return camobj.scenes_data[0].cameras[0];
	};


	/**
	 * Get camera frustum/box edge in view space
	 */
	exports.get_edge = function(cam, edge_type) {
	    switch (cam.type) {
	    case exports.TYPE_PERSP:
	    case exports.TYPE_PERSP_ASPECT:
	    case exports.TYPE_STEREO_LEFT:
	    case exports.TYPE_STEREO_RIGHT:
	        var top_1m = Math.tan(get_vfov(cam) / 2);
	        switch (edge_type) {
	        case "LEFT":
	            return -top_1m * cam.aspect;
	        case "RIGHT":
	            return top_1m * cam.aspect;
	        case "TOP":
	            return top_1m;
	        case "BOTTOM":
	            return -top_1m;
	        }
	        break;
	    case exports.TYPE_ORTHO:
	    case exports.TYPE_ORTHO_ASPECT:
	        switch (edge_type) {
	        case "LEFT":
	            return -get_vfov(cam) * cam.aspect;
	        case "RIGHT":
	            return get_vfov(cam) * cam.aspect;
	        case "TOP":
	            return get_vfov(cam);
	        case "BOTTOM":
	            return -get_vfov(cam);
	        }
	        break;
	    case exports.TYPE_ORTHO_ASYMMETRIC:
	        switch (edge_type) {
	        case "LEFT":
	            return cam.left;
	        case "RIGHT":
	            return cam.right;
	        case "TOP":
	            return cam.top;
	        case "BOTTOM":
	            return cam.bottom;
	        }
	        break;
	    case exports.TYPE_HMD_LEFT:
	    case exports.TYPE_HMD_RIGHT:
	        var active_scene = m_scenes.get_active();
	        var subs_stereo = m_scenes.get_subs(active_scene, m_subs.STEREO);
	        if (subs_stereo && subs_stereo.enable_hmd_stereo) {
	            switch (edge_type) {
	            case "LEFT":
	                return -Math.tan(Math.min(cam.hmd_fov[1], cam.hmd_fov[3]));
	            case "RIGHT":
	                return Math.tan(Math.min(cam.hmd_fov[1], cam.hmd_fov[3]));
	            case "TOP":
	                return Math.tan(Math.min(cam.hmd_fov[0], cam.hmd_fov[2]));
	            case "BOTTOM":
	                return -Math.tan(Math.min(cam.hmd_fov[0], cam.hmd_fov[2]));
	            }
	        } else {
	            var top_1m = Math.tan(get_vfov(cam) / 2);
	            switch (edge_type) {
	            case "LEFT":
	                return -top_1m * cam.aspect;
	            case "RIGHT":
	                return top_1m * cam.aspect;
	            case "TOP":
	                return top_1m;
	            case "BOTTOM":
	                return -top_1m;
	            }
	        }
	        break;
	    default:
	        m_util.panic("Unknown camera type");
	        break;
	    }
	}; 

	exports.is_ortho = is_ortho;
	function is_ortho(cam) {
	    switch (cam.type) {
	    case exports.TYPE_ORTHO:
	    case exports.TYPE_ORTHO_ASPECT:
	    case exports.TYPE_ORTHO_ASYMMETRIC:
	        return true;
	    default:
	        return false;
	    }
	}

	exports.set_trans_pivot = function(camobj, trans, pivot) {
	    var render = camobj.render;

	    m_tsr.set_trans(trans, render.world_tsr);
	    m_vec3.copy(pivot, render.pivot);

	    // TODO: update quaternion based on the UP vector
	    // var quat = m_tsr.get_quat_view(render.world_tsr);
	    // m_util.quat_rotate_to_target(trans, quat, pivot);
	};

	/**
	 * uses _vec3_tmp
	 */
	exports.set_hover_pivot = function(camobj, coords) {
	    var render = camobj.render;

	    var pivot_delta = m_vec3.subtract(coords, render.hover_pivot, _vec3_tmp);
	    var old_trans = m_tsr.get_trans_view(render.world_tsr);
	    var trans = m_vec3.add(pivot_delta, old_trans, pivot_delta);
	    m_trans.set_translation(camobj, trans);

	    m_vec3.copy(coords, render.hover_pivot);
	};

	/**
	 * uses _vec3_tmp
	 */
	exports.set_target_pivot = function(camobj, coords) {
	    var render = camobj.render;

	    var pivot_delta = m_vec3.subtract(coords, render.pivot, _vec3_tmp);
	    var old_trans = m_tsr.get_trans_view(render.world_tsr);
	    var trans = m_vec3.add(pivot_delta, old_trans, pivot_delta);
	    m_trans.set_translation(camobj, trans);

	    m_vec3.copy(coords, render.pivot);
	};

	exports.get_eye = get_eye;
	function get_eye(camobj, dest) {
	    if (!dest)
	        dest = new Float32Array(3);

	    var trans = m_tsr.get_trans_view(camobj.render.world_tsr);
	    m_vec3.copy(trans, dest);
	    return dest;
	}

	/**
	 * NOTE: deprecated, used for compatibility
	 * uses _vec3_tmp, _vec3_tmp2
	 */
	exports.set_move_style = function(camobj, move_style) {
	    camobj.render.move_style = move_style;

	    camobj.render.horizontal_limits = null;
	    camobj.render.vertical_limits = null;
	    camobj.render.distance_limits = null;
	    camobj.render.hover_horiz_trans_limits = null;
	    camobj.render.hover_vert_trans_limits = null;

	    init_ortho_props(camobj);

	    switch (move_style) {
	    case exports.MS_STATIC:
	    case exports.MS_EYE_CONTROLS:
	        break;
	    case exports.MS_HOVER_CONTROLS:
	        var pos = m_tsr.get_trans_view(camobj.render.world_tsr);
	        var pivot = init_hover_pivot(camobj, 0, _vec3_tmp2);
	        setup_hover_model(camobj, pos, pivot, null, null, null, null, 
	                camobj.render.enable_hover_hor_rotation);
	        break;
	    case exports.MS_TARGET_CONTROLS:
	        var cam_eye = get_eye(camobj, _vec3_tmp);
	        var quat = m_tsr.get_quat_view(camobj.render.world_tsr);
	        var view_vector = m_util.quat_to_dir(quat, m_util.AXIS_MZ, _vec3_tmp2);
	        var pivot = m_vec3.scaleAndAdd(cam_eye, view_vector, PIVOT_DEFAULT_DIST, view_vector);
	        m_vec3.copy(pivot, camobj.render.pivot);
	        break;
	    }
	};

	exports.wipe_move_style = function(camobj) {
	    var render = camobj.render;
	    
	    // default STATIC camera with clean settings
	    render.move_style = 0;

	    m_vec3.set(0, 0, 0, render.pivot);
	    m_vec3.set(0, 0, 0, render.hover_pivot);
	    render.target_cam_upside_down = false;
	    render.use_panning = false;

	    render.horizontal_limits = null;
	    render.vertical_limits = null;
	    render.distance_limits = null;
	    render.hover_horiz_trans_limits = null;
	    render.hover_vert_trans_limits = null;
	    render.pivot_limits = null;

	    render.enable_hover_hor_rotation = true;
	};

	exports.set_eye_distance = function(cameras, eye_dist) {
	    for (var i = 0; i < cameras.length; i++) {
	        var cam = cameras[i];
	        if (cam.type == TYPE_STEREO_LEFT ||
	                cam.type == TYPE_STEREO_RIGHT ||
	                cam.type == TYPE_HMD_LEFT ||
	                cam.type == TYPE_HMD_RIGHT)
	            set_stereo_params(cam, cam.stereo_conv_dist, eye_dist);
	    }
	};

	exports.set_hmd_fov = function(camobj, hmd_left_fov, hmd_right_fov) {
	    var active_scene = m_scenes.get_active();
	    var cam_scene_data = m_obj_util.get_scene_data(camobj, active_scene);
	    var cameras = cam_scene_data.cameras;
	    for (var i = 0; i < cameras.length; i++) {
	        var cam = cameras[i];

	        if (cam.type == TYPE_HMD_LEFT ||
	                cam.type == TYPE_HMD_RIGHT) {

	            if (cam.type == TYPE_HMD_LEFT)
	                m_vec4.copy(hmd_left_fov, cam.hmd_fov);

	            if (cam.type == TYPE_HMD_RIGHT)
	                m_vec4.copy(hmd_right_fov, cam.hmd_fov);

	            if (cam.reflection_plane)
	                set_projection_reflect(cam, false);
	            else
	                set_projection(cam, false);
	        }
	    }
	};

	exports.set_hmd_proj_mat = function(camobj, hmd_left_proj_mat, hmd_right_proj_mat) {
	    var active_scene = m_scenes.get_active();
	    var cam_scene_data = m_obj_util.get_scene_data(camobj, active_scene);
	    var cameras = cam_scene_data.cameras;

	    for (var i = 0; i < cameras.length; i++) {
	        var cam = cameras[i];

	        if (cam.type == TYPE_HMD_LEFT || cam.type == TYPE_HMD_RIGHT) {

	            if (cam.type == TYPE_HMD_LEFT && hmd_left_proj_mat)
	                m_mat4.copy(hmd_left_proj_mat, cam.proj_matrix);

	            if (cam.type == TYPE_HMD_RIGHT && hmd_right_proj_mat)
	                m_mat4.copy(hmd_right_proj_mat, cam.proj_matrix);

	            update_proj_transformed_view(cam);
	            set_view_projection_after(cam);
	        }
	    }
	};

	exports.set_proj_mat = function(camobj, proj_mat) {
	    var active_scene = m_scenes.get_active();
	    var cam_scene_data = m_obj_util.get_scene_data(camobj, active_scene);
	    var cameras = cam_scene_data.cameras;

	    var near;
	    var far;
	    var right;
	    var top;
	    var left;
	    var bottom;
	    var new_proj_mat;
	    var aspect;

	    // init near, far, right and so on
	    for (var i = 0; i < cameras.length; i++) {
	        var cam = cameras[i];

	        if (cam.type == exports.TYPE_NONE && cam.near ||
	                cam.type == exports.TYPE_PERSP ||
	                cam.type == exports.TYPE_PERSP_ASPECT) {
	            near = cam.near;
	            far = cam.far;

	            var inv_proj = m_mat4.invert(proj_mat, _mat4_tmp);
	            var right_top_point = m_vec4.transformMat4(RIGHT_TOP_POINT, inv_proj, _vec4_tmp);

	            right = right_top_point[0] * near;
	            top = right_top_point[1] * near;

	            var left_bottom_point = m_vec4.transformMat4(LEFT_BOTTOM_POINT, inv_proj, _vec4_tmp);
	            left = left_bottom_point[0] * near;
	            bottom = left_bottom_point[1] * near;

	            var far_point = m_vec4.transformMat4(FAR_POINT, inv_proj, _vec4_tmp);
	            far = -far_point[2] * far_point[3];

	            new_proj_mat = m_mat4.frustum(left, right, bottom, top, near, far, _mat4_tmp);

	            aspect = (right - left) / (top - bottom);

	            break;
	        }
	    }

	    for (var i = 0; i < cameras.length; i++) {
	        var cam = cameras[i];

	        if (cam.type == exports.TYPE_NONE || cam.type == exports.TYPE_PERSP ||
	                cam.type == exports.TYPE_PERSP_ASPECT) {

	            cam.far = far;
	            cam.near = near;
	            cam.right = right;
	            cam.top = top;
	            cam.left = left;
	            cam.bottom = bottom;
	            cam.aspect = aspect;
	            cam.fov = Math.atan(top / near) - Math.atan(bottom / near);

	            m_mat4.copy(new_proj_mat, cam.proj_matrix);

	            update_proj_transformed_view(cam);
	            set_view_projection_after(cam);
	        }
	    }
	};

	}

	var int_camera_factory = register("__camera", Int_camera);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * API for controlling the camera within the bounds of the current camera model.
	 * Use {@link module:transform|Transform API} for low-level actions.<br>
	 * All functions require a valid camera object reference. Use
	 * {@link module:scenes.get_object_by_name|scenes.get_object_by_name()} or
	 * {@link module:scenes.get_active_camera|scenes.get_active_camera()} to obtain it.
	 * The result of applying various transforms to a camera can be overridden by the 
	 * present camera limits.
	 * <p>
	 * <b>API examples for this module</b>: 
	 * {@link https://www.blend4web.com/doc/en/camera.html#camera-controls-api|English},
	 * {@link https://www.blend4web.com/doc/zh/camera.html#camera-controls-api|中文}, 
	 * {@link https://www.blend4web.com/doc/ru/camera.html#camera-controls-api|Русский}.
	 * </p>
	 * @module camera
	 * @local DistanceLimits
	 * @local VerticalRotationLimits
	 * @local HorizontalRotationLimits
	 * @local HoverAngleLimits
	 * @local VerticalTranslationLimits
	 * @local HorizontalTranslationLimits
	 * @local HoverCameraParams
	 * @local TargetCameraParams
	 * @local EyeCameraParams
	 * @local StaticCameraParams
	 * @local PivotLimits
	 * @local VelocityParams
	 * @local FrustumPlanes
	 */
	function Camera(ns, exports) {

	var m_cam      = int_camera_factory(ns);
	var m_cont     = int_container_factory(ns);
	var m_math     = int_math_factory(ns);
	var m_obj_util = int_obj_util_factory(ns);
	var m_phy      = int_physics_factory(ns);
	var m_print    = print_factory(ns);
	var m_scs      = int_scenes_factory(ns);
	var m_trans    = int_transform_factory(ns);
	var m_tsr      = int_tsr_factory(ns);
	var m_util     = int_util_factory(ns);
	var m_vec3     = vec3_factory(ns);
	var m_vec4     = vec4_factory(ns);
	var m_quat     = quat_factory(ns);

	var _vec2_tmp = new Float32Array(2);
	var _vec3_tmp = new Float32Array(3);
	var _vec3_tmp2 = new Float32Array(3);
	var _vec4_tmp = new Float32Array(4);
	var _quat_tmp = m_quat.create();
	var _limits_tmp = {};
	var _limits_tmp2 = {};

	/**
	 * An object that defines distance limits for the HOVER/TARGET camera.
	 * The "min" value must be less or equal than the "max" value.
	 * @typedef {Object} DistanceLimits
	 * @property {number} min The minimum distance to the pivot.
	 * @property {number} max The maximum distance to the pivot.
	 * @cc_externs min max
	 */

	/**
	 * An object that defines limits for rotations in a vertical plane for the TARGET/EYE camera.
	 * The limits are converted by engine into the range [-Pi, Pi] when set via API.
	 * @see https://www.blend4web.com/doc/en/camera.html#camera-spherical-coordinates
	 * @typedef {Object} VerticalRotationLimits
	 * @property {number} down The elevation angle in radians that restricts a downward rotation.
	 * @property {number} up The elevation angle in radians that restricts an upward rotation.
	 * @property {boolean} [camera_space=false] Define limits relative to the current
	 * camera position/orientation, otherwise - in world space (by default).
	 * @cc_externs down up camera_space
	 */

	/**
	 * An object that defines limits for rotations in a horizontal plane for the TARGET/EYE camera.
	 * The limits are converted by engine into the range [0, 2Pi] when set via API.
	 * @see https://www.blend4web.com/doc/en/camera.html#camera-spherical-coordinates
	 * @typedef {Object} HorizontalRotationLimits
	 * @property {number} left The azimuth angle in radians that restricts a leftward rotation.
	 * @property {number} right The azimuth angle in radians that restricts a rightward rotation.
	 * @property {boolean} [camera_space=false] Define limits relative to the current
	 * camera position/orientation, otherwise - in world space (by default).
	 * @cc_externs left right camera_space
	 */

	/**
	 * An object that defines limits for rotations in a vertical plane for the HOVER camera.
	 * The limits are converted by engine into the range [-Pi, Pi] and then clamped
	 * to be in range [-Pi/2, 0] when set via API.
	 * The "down" value must be greater or equal than the "up" value.
	 * @see https://www.blend4web.com/doc/en/camera.html#camera-spherical-coordinates
	 * @typedef {Object} HoverAngleLimits
	 * @property {number} down The elevation angle in radians that restricts a downward rotation.
	 * @property {number} up The elevation angle in radians that restricts an upward rotation.
	 * @cc_externs down up
	 */

	/**
	 * An object that defines limits for translations along the Z axis for the HOVER camera.
	 * The "min" value must be less or equal than the "max" value.
	 * @see https://www.blend4web.com/doc/en/camera.html#hover-translation-limits
	 * @typedef {Object} VerticalTranslationLimits
	 * @property {number} min The minimum value that restricts camera translation along the Z axis.
	 * @property {number} max The maximum value that restricts camera translation along the Z axis.
	 * @cc_externs min max
	 */

	/**
	 * An object that defines limits for translations along the X axis for the HOVER camera.
	 * The "min" value must be less or equal than the "max" value.
	 * @see https://www.blend4web.com/doc/en/camera.html#hover-translation-limits
	 * @typedef {Object} HorizontalTranslationLimits
	 * @property {number} min The minimum value that restricts camera translation along the X axis.
	 * @property {number} max The maximum value that restricts camera translation along the X axis.
	 * @cc_externs min max
	 */

	/**
	 * An object that defines limits for translations along the Y axis for the 
	 * camera pivot point.
	 * @typedef {Object} PivotLimits
	 * @property {number} min_z The minimum value that restricts pivot translation 
	 * along the Z axis.
	 * @property {number} max_z The maximum value that restricts pivot translation 
	 * along the Z axis.
	 * @cc_externs min_z max_z
	 */

	/**
	 * An object that defines velocity of the camera movement.
	 * @typedef {Object} VelocityParams
	 * @property {number} [trans=Current velocity value] Translation velocity ([0,Infinity]).
	 * @property {number} [rot=Current velocity value] Rotation velocity ([0,Infinity]).
	 * @property {number} [zoom=Current velocity value] Zoom velocity ([0,1]).
	 * @cc_externs trans rot zoom
	 */

	/**
	 * An object that defines the STATIC camera parameters.
	 * @typedef {Object} StaticCameraParams
	 * @property {?Vec3} [pos=null] Position of the camera. Set to null to keep the current 
	 * camera position.
	 * @property {?Vec3} [look_at=null] Point the camera is looking at. Set to null to 
	 * keep the existing camera orientation.
	 * @cc_externs pos look_at
	 */

	/**
	 * An object that defines the EYE camera parameters.
	 * @typedef {Object} EyeCameraParams
	 * @property {?Vec3} [pos=null] Position of the camera. Set to null to keep the 
	 * current camera position.
	 * @property {?Vec3} [look_at=null] Point the camera is looking at. Set to null 
	 * to keep the existing camera orientation.
	 * @property {?HorizontalRotationLimits} [horiz_rot_lim=null] Horizontal rotation 
	 * limits. Set to null to disable the limits.
	 * @property {?VerticalRotationLimits} [vert_rot_lim=null] Vertical rotation limits. 
	 * Set to null to disable the limits.
	 * @cc_externs pos look_at horiz_rot_lim vert_rot_lim
	 */

	/**
	 * An object that defines the TARGET camera parameters.
	 * @typedef {Object} TargetCameraParams
	 * @property {?Vec3} [pos=null] Position of the camera. Set to null to keep the 
	 * current camera position.
	 * @property {Vec3} [pivot=null] Camera pivot point. If set to null, when the 
	 * current view vector of unit length will be used to define the pivot point.
	 * @property {?HorizontalRotationLimits} [horiz_rot_lim=null] Horizontal 
	 * rotation limits. Set to null to disable the limits.
	 * @property {?VerticalRotationLimits} [vert_rot_lim=null] Vertical rotation 
	 * limits. Set to null to disable the limits.
	 * @property {?DistanceLimits} [dist_lim=null] Distance limits. Set to null to 
	 * disable the limits.
	 * @property {?PivotLimits} [pivot_lim=null] Pivot limits. Set to 
	 * null to disable the limits.
	 * @property {boolean} [use_panning=false] Use panning mode.
	 * @cc_externs pos pivot horiz_rot_lim vert_rot_lim dist_lim use_panning
	 */

	/**
	 * An object that defines the HOVER camera parameters.
	 * @typedef {Object} HoverCameraParams
	 * @property {?Vec3} [pos=null] Position of the camera. Set to null to keep the 
	 * current camera position.
	 * @property {Vec3} pivot Camera pivot point.
	 * @property {?DistanceLimits} [dist_lim=null] Distance limits. Set to null to 
	 * define the limits as fixed distance to the pivot which depends on the 
	 * given pivot and camera positions.
	 * @property {?HoverAngleLimits} [hover_angle_lim=null] Hover angle limits. 
	 * Set to null to define the limits as fixed angle which depends on the given 
	 * pivot and camera positions.
	 * @property {?HorizontalTranslationLimits} [horiz_trans_lim=null] Horizontal 
	 * translation limits. Set to null to disable the limits.
	 * @property {?VerticalTranslationLimits} [vert_trans_lim=null] Vertical 
	 * translation limits. Set to null to disable the limits.
	 * @property {boolean} [enable_horiz_rot=false] Enable horizontal rotation.
	 * @cc_externs pos pivot dist_lim hover_angle_lim horiz_trans_lim vert_trans_lim
	 * @cc_externs enable_horiz_rot
	 */

	/**
	 * An object that defines the HOVER camera parameters.
	 * @typedef {Object} HoverCameraParamsRel
	 * @property {?Vec3} [pos=null] Position of the camera. Set to null to keep the 
	 * current camera position.
	 * @property {Vec3} pivot Camera pivot point.
	 * @property {number} [dist_interval=0] A distance variation around the established 
	 * distance to the pivot: distance ± dist_interval/2. The resulted distance 
	 * limits are clamped to be in range [0, +∞].
	 * @property {number} [angle_interval=0] A hover angle variation (in radians)
	 * around the established hover angle: hover angle ± angle_interval/2. The 
	 * resulted hover angle limits are clamped to be in range [-PI/2, 0].
	 * @property {number} [t=0.5] An optional parameter which lies in range [0, 1] 
	 * and defines the disposition of the given angle and distance intervals around 
	 * the established values, for example: 
	 * 0 - the given camera position is the nearest zoomed-in point, 
	 * 1 - the given camera position is the farthest zoomed-out point, 
	 * 0.5 (by default) - the given camera position is in the middle of the given 
	 * intervals and can be zoomed equally in both directions.
	 * @cc_externs pos pivot dist_interval angle_interval t
	 */

	 /**
	 * Camera frustum planes object.
	 * @typedef {Object} FrustumPlanes
	 * @property {Plane} Left frustum plane.
	 * @property {Plane} Right frustum plane.
	 * @property {Plane} Top frustum plane.
	 * @property {Plane} Bottom frustum plane.
	 * @property {Plane} Near frustum plane.
	 * @property {Plane} Far frustum plane.
	 * @cc_externs left right top bottom near far
	 */

	/**
	 * The camera's movement style: STATIC (non-interactive).
	 * @const {CameraMoveStyle} module:camera.MS_STATIC
	 */
	exports.MS_STATIC = m_cam.MS_STATIC;
	/**
	 * The camera's movement style: TARGET.
	 * @const {CameraMoveStyle} module:camera.MS_TARGET_CONTROLS
	 */
	exports.MS_TARGET_CONTROLS = m_cam.MS_TARGET_CONTROLS;
	/**
	 * The camera's movement style: EYE.
	 * @const {CameraMoveStyle} module:camera.MS_EYE_CONTROLS
	 */
	exports.MS_EYE_CONTROLS = m_cam.MS_EYE_CONTROLS;
	/**
	 * The camera's movement style: HOVER.
	 * @const {CameraMoveStyle} module:camera.MS_HOVER_CONTROLS
	 */
	exports.MS_HOVER_CONTROLS = m_cam.MS_HOVER_CONTROLS;

	/**
	 * Setup the STATIC camera.
	 * @method module:camera.static_setup
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {?StaticCameraParams} [params=null] The parameters of the STATIC camera.
	 */
	exports.static_setup = function(camobj, params) {
	    if (!m_obj_util.is_camera(camobj)) {
	        m_print.error("static_setup(): Wrong camera object");
	        return;
	    }

	    m_cam.wipe_move_style(camobj);
	    camobj.render.move_style = m_cam.MS_STATIC;

	    if (params) {
	        var pos = params.pos || m_tsr.get_trans_view(camobj.render.world_tsr);
	        if (params.look_at)
	            m_cam.set_look_at(camobj, pos, params.look_at);
	        else
	            m_trans.set_translation(camobj, pos);
	    }

	    m_trans.update_transform(camobj);
	    m_phy.sync_transform(camobj);

	    // init ortho properties after the camera was updated
	    m_cam.init_ortho_props(camobj);
	};

	/**
	 * Set position and orientation for the STATIC camera.
	 * @method module:camera.static_set_look_at
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {?Vec3} [pos=null] Position of the camera. Pass null to keep the current 
	 * camera position.
	 * @param {?Vec3} [look_at=null] Point the camera is looking at. Pass null to 
	 * keep the existing camera orientation.
	 */
	exports.static_set_look_at = function(camobj, pos, look_at) {
	    if (!m_cam.is_static_camera(camobj)) {
	        m_print.error("static_set_look_at(): Wrong camera object or camera move style");
	        return;
	    }

	    pos = pos || m_tsr.get_trans_view(camobj.render.world_tsr);
	    if (look_at)
	        m_cam.set_look_at(camobj, pos, look_at);
	    else
	        m_trans.set_translation(camobj, pos);

	    m_trans.update_transform(camobj);
	    m_phy.sync_transform(camobj);
	};

	/**
	 * Set the STATIC camera's rotation from quaternion.
	 * @method module:camera.static_set_rotation
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {Quat} quat Quaternion vector.
	 */
	exports.static_set_rotation = function(camobj, quat) {
	    if (!m_cam.is_static_camera(camobj)) {
	        m_print.error("static_set_rotation(): Wrong camera object or camera move style");
	        return;
	    }

	    m_trans.set_rotation(camobj, quat);

	    m_trans.update_transform(camobj);
	    m_phy.sync_transform(camobj);
	};

	/**
	 * Get the STATIC camera's rotation quaternion.
	 * @method module:camera.static_get_rotation
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {?Quat} [dest=new Float32Array(4);] Destination vector.
	 * @returns {?Quat} Destination vector.
	 */
	exports.static_get_rotation = function(camobj, dest) {
	    if (!m_cam.is_static_camera(camobj)) {
	        m_print.error("static_get_rotation(): Wrong camera object or camera move style");
	        return null;
	    }

	    dest = dest || new Float32Array(4);
	    return m_trans.get_rotation(camobj, dest);
	};

	/**
	 * Setup the EYE camera.
	 * @method module:camera.eye_setup
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {?EyeCameraParams} [params=null] The parameters of the EYE camera.
	 */
	exports.eye_setup = function(camobj, params) {

	    if (!m_obj_util.is_camera(camobj)) {
	        m_print.error("eye_setup(): Wrong camera object");
	        return;
	    }
	    if (params && params.horiz_rot_lim)
	        if (typeof params.horiz_rot_lim.left != "number" 
	                || typeof params.horiz_rot_lim.right != "number") {
	            m_print.error("eye_setup(): Wrong horizontal limits object.");
	            return;
	        }
	    if (params && params.vert_rot_lim)
	        if (typeof params.vert_rot_lim.down != "number" 
	                || typeof params.vert_rot_lim.up != "number") {
	            m_print.error("eye_setup(): Wrong vertical limits object.");
	            return;
	        }

	    m_cam.wipe_move_style(camobj);
	    camobj.render.move_style = m_cam.MS_EYE_CONTROLS;

	    if (params) {
	        var pos = params.pos || m_tsr.get_trans_view(camobj.render.world_tsr);
	        m_cam.setup_eye_model(camobj, pos, params.look_at, params.horiz_rot_lim, 
	                params.vert_rot_lim);
	    }

	    m_trans.update_transform(camobj);
	    m_phy.sync_transform(camobj);

	    // init ortho after the camera was updated
	    m_cam.init_ortho_props(camobj);
	};

	/**
	 * Set position and orientation for the EYE camera.
	 * @method module:camera.eye_set_look_at
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {?Vec3} [pos=null] Position of the camera. Pass null to keep the current 
	 * camera position.
	 * @param {?Vec3} [look_at=null] Point the camera is looking at. Pass null to 
	 * keep the existing camera orientation.
	 */
	exports.eye_set_look_at = function(camobj, pos, look_at) {
	    if (!m_cam.is_eye_camera(camobj)) {
	        m_print.error("eye_set_look_at(): Wrong camera object or camera move style");
	        return;
	    }

	    pos = pos || m_tsr.get_trans_view(camobj.render.world_tsr);
	    if (look_at)
	        m_cam.set_look_at_corrected(camobj, pos, look_at);
	    else
	        m_trans.set_translation(camobj, pos);

	    m_cam.correct_up(camobj, camobj.render.vertical_axis, true);

	    m_trans.update_transform(camobj);
	    m_phy.sync_transform(camobj);
	};

	/**
	 * Rotate the EYE camera counterclockwise (CCW) around its origin by the given angles.
	 * Performs delta rotation or sets the camera's absolute rotation depending on 
	 * the "is_abs" parameter.
	 * @see https://www.blend4web.com/doc/en/camera.html#camera-spherical-coordinates
	 * @method module:camera.eye_rotate
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {number} phi Azimuth angle in radians.
	 * @param {number} theta Elevation angle in radians.
	 * @param {boolean} [is_abs=false] Performs delta rotation if FALSE, sets 
	 * camera's absolute rotation if TRUE.
	 * @deprecated [17.06] Use {@link module:camera.rotate_camera} instead
	 */
	exports.eye_rotate = function(camobj, phi, theta, is_abs) {
	    m_print.error_deprecated("eye_rotate", "rotate_camera");
	    if (!m_cam.is_eye_camera(camobj)) {
	        m_print.error("eye_rotate(): Wrong camera object or camera move style");
	        return;
	    }

	    is_abs = is_abs || false;
	    exports.rotate_camera(camobj, phi, theta, is_abs);
	};

	/**
	 * Set vertical rotation limits for the EYE camera.
	 * @see https://www.blend4web.com/doc/en/camera.html#camera-spherical-coordinates
	 * @method module:camera.eye_set_vertical_limits
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {?VerticalRotationLimits} [limits=null] Vertical rotation limits. 
	 * Pass null to disable the limits.
	 */
	exports.eye_set_vertical_limits = function(camobj, limits) {
	    if (!m_cam.is_eye_camera(camobj)) {
	        m_print.error("eye_set_vertical_limits(): Wrong camera object or camera move style");
	        return;
	    }

	    if (limits)
	        if (typeof limits.down != "number" || typeof limits.up != "number") {
	            m_print.error("eye_set_vertical_limits(): Incorrect limits object.");
	            return;
	        }

	    m_cam.set_vertical_rot_limits(camobj, limits);
	    m_trans.update_transform(camobj);
	    m_phy.sync_transform(camobj);
	};

	/**
	 * Get vertical rotation limits of the EYE camera (converted to the [-Pi, Pi] range).
	 * @see https://www.blend4web.com/doc/en/camera.html#camera-spherical-coordinates
	 * @method module:camera.eye_get_vertical_limits
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {?VerticalRotationLimits} [dest=new Object();] The receiving object.
	 * @param {boolean} [local=false] Use camera local space representation.
	 * @returns {?VerticalRotationLimits} Vertical rotation limits or null if disabled.
	 */
	exports.eye_get_vertical_limits = function(camobj, dest, local) {
	    if (!m_cam.is_eye_camera(camobj)) {
	        m_print.error("eye_get_vertical_limits(): Wrong camera object or camera move style");
	        return null;
	    }

	    var render = camobj.render;
	    if (render.vertical_limits) {
	        dest = dest || {};
	        if (local) {
	            dest.down = render.vertical_limits.down_local;
	            dest.up = render.vertical_limits.up_local;
	        } else {
	            dest.down = render.vertical_limits.down;
	            dest.up = render.vertical_limits.up;
	        }
	        dest.camera_space = local || false;
	        return dest;
	    } else
	        return null;
	};

	/**
	 * Set horizontal rotation limits for the EYE camera.
	 * @see https://www.blend4web.com/doc/en/camera.html#camera-spherical-coordinates
	 * @method module:camera.eye_set_horizontal_limits
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {?HorizontalRotationLimits} [limits=null] Horizontal rotation limits. 
	 * Pass null to disable the limits.
	 */
	exports.eye_set_horizontal_limits = function(camobj, limits) {
	    if (!m_cam.is_eye_camera(camobj)) {
	        m_print.error("eye_set_horizontal_limits(): Wrong camera object or camera move style");
	        return;
	    }

	    if (limits)
	        if (typeof limits.left != "number" || typeof limits.right != "number") {
	            m_print.error("eye_set_horizontal_limits(): Incorrect limits object.");
	            return;
	        }

	    m_cam.set_horizontal_rot_limits(camobj, limits);
	    m_trans.update_transform(camobj);
	    m_phy.sync_transform(camobj);
	};

	/**
	 * Get horizontal angle limits of the EYE camera (converted to the [0, 2Pi] range).
	 * @see https://www.blend4web.com/doc/en/camera.html#camera-spherical-coordinates
	 * @method module:camera.eye_get_horizontal_limits
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {?HorizontalRotationLimits} [dest=new Object();] The receiving object.
	 * @param {boolean} [local=false] Use camera local space representation.
	 * @returns {?HorizontalRotationLimits} Horizontal rotation limits or null if disabled.
	 */
	exports.eye_get_horizontal_limits = function(camobj, dest, local) {
	    if (!m_cam.is_eye_camera(camobj)) {
	        m_print.error("eye_get_horizontal_limits(): Wrong camera object or camera move style");
	        return null;
	    }

	    var render = camobj.render;
	    if (render.horizontal_limits) {
	        dest = dest || {};
	        if (local) {
	            dest.left = render.horizontal_limits.left_local;
	            dest.right = render.horizontal_limits.right_local;
	        } else {
	            dest.left = render.horizontal_limits.left;
	            dest.right = render.horizontal_limits.right;
	        }
	        dest.camera_space = local || false;
	        return dest;
	    } else
	        return null;
	};

	/**
	 * Setup the TARGET camera.
	 * @method module:camera.target_setup
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {TargetCameraParams} params The parameters of the TARGET camera.
	 */
	exports.target_setup = function(camobj, params) {

	    if (!m_obj_util.is_camera(camobj)) {
	        m_print.error("target_setup(): Wrong camera object");
	        return;
	    }
	    if (params.horiz_rot_lim)
	        if (typeof params.horiz_rot_lim.left != "number" 
	                || typeof params.horiz_rot_lim.right != "number") {
	            m_print.error("target_setup(): Wrong horizontal limits object");
	            return;
	        }
	    if (params.vert_rot_lim)
	        if (typeof params.vert_rot_lim.down != "number" 
	                || typeof params.vert_rot_lim.up != "number") {
	            m_print.error("target_setup(): Wrong vertical limits object");
	            return;
	        }
	    if (params.dist_lim) {
	        if (typeof params.dist_lim.min != "number" 
	                || typeof params.dist_lim.max != "number" 
	                || params.dist_lim.min > params.dist_lim.max) {
	            m_print.error("target_setup(): Wrong distance limits object");
	            return;
	        }
	        params.dist_lim.min = Math.max(params.dist_lim.min, 0);
	        params.dist_lim.max = Math.max(params.dist_lim.max, 0);
	    }

	    if (params.pivot_lim) {
	        if (typeof params.pivot_lim.min_y != "number" 
	                || typeof params.pivot_lim.max_y != "number" 
	                || params.pivot_lim.min_y > params.pivot_lim.max_y) {
	            m_print.error("target_setup(): Wrong pivot limits object");
	            return;
	        }
	    }

	    m_cam.wipe_move_style(camobj);
	    camobj.render.move_style = m_cam.MS_TARGET_CONTROLS;

	    var pos = params.pos || m_tsr.get_trans_view(camobj.render.world_tsr);
	    var pivot = params.pivot;
	    if (!pivot) {
	        var view_vec = get_view_vector(camobj, _vec3_tmp);
	        pivot = m_vec3.add(pos, view_vec, view_vec);
	    }
	    m_cam.setup_target_model(camobj, pos, pivot, params.horiz_rot_lim, 
	            params.vert_rot_lim, params.dist_lim, params.pivot_lim, 
	            params.use_panning || false);

	    m_trans.update_transform(camobj);
	    m_phy.sync_transform(camobj);

	    // init ortho after the camera was updated
	    m_cam.init_ortho_props(camobj);
	};

	/**
	 * Rotate the TARGET camera counterclockwise (CCW) around its pivot by the given 
	 * angles.
	 * Performs delta rotation or sets the camera's absolute rotation depending on 
	 * the "is_abs" parameter.
	 * @see https://www.blend4web.com/doc/en/camera.html#camera-spherical-coordinates
	 * @method module:camera.target_rotate
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {number} phi Azimuth angle in radians.
	 * @param {number} theta Elevation angle in radians.
	 * @param {boolean} [is_abs=false] Performs delta rotation if FALSE, sets 
	 * camera's absolute rotation if TRUE.
	 * @deprecated [17.06] Use {@link module:camera.rotate_camera} instead
	 */
	exports.target_rotate = function(camobj, phi, theta, is_abs) {
	    m_print.error_deprecated("target_rotate", "rotate_camera");
	    if (!m_cam.is_target_camera(camobj)) {
	        m_print.error("target_rotate(): Wrong camera object or camera move style");
	        return;
	    }

	    is_abs = is_abs || false;
	    
	    exports.rotate_camera(camobj, phi, theta, is_abs);
	};

	/**
	 * Set translation and pivot point for the TARGET camera.
	 * The result of this operation can be corrected by existing limits.
	 * @method module:camera.target_set_trans_pivot
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {?Vec3} [trans=null] Translation vector. Pass null to keep the current 
	 * camera position.
	 * @param {?Vec3} [pivot=null] Pivot vector. Pass null to keep the current pivot 
	 * point.
	 */
	exports.target_set_trans_pivot = function(camobj, trans, pivot) {
	    if (!m_cam.is_target_camera(camobj)) {
	        m_print.error("target_set_trans_pivot(): Wrong camera object or camera move style");
	        return;
	    }

	    trans = trans || m_tsr.get_trans_view(camobj.render.world_tsr);
	    pivot = pivot || camobj.render.pivot;
	    m_cam.set_trans_pivot(camobj, trans, pivot);

	    m_trans.update_transform(camobj);
	    m_phy.sync_transform(camobj);
	};

	/**
	 * Performs parallel translation for the TARGET camera. It works as similar as
	 * the set_translation() method but uses the camera pivot to perform the translation.
	 * @method module:camera.target_set_pivot_translation
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {Vec3} trans New pivot position.
	 */
	exports.target_set_pivot_translation = function(camobj, trans) {
	    if (!m_cam.is_target_camera(camobj)) {
	        m_print.error("target_set_pivot_translation(): Wrong camera object or camera move style");
	        return;
	    }

	    m_cam.set_target_pivot(camobj, trans);

	    m_trans.update_transform(camobj);
	    m_phy.sync_transform(camobj);
	};

	/**
	 * Set distance to the pivot point for the TARGET camera.
	 * The result of this operation can be corrected by existing limits.
	 * @method module:camera.target_set_distance
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {number} distance Distance to the pivot point.
	 */
	exports.target_set_distance = function(camobj, distance) {
	    if (!m_cam.is_target_camera(camobj)) {
	        m_print.error("target_set_distance(): Wrong camera object or camera move style");
	        return;
	    }

	    var dist_curr = m_trans.obj_point_distance(camobj, camobj.render.pivot);
	    var dist_needed = Math.max(0, distance);

	    // +y move backward
	    m_trans.move_local(camobj, 0, 0, dist_needed - dist_curr);

	    m_trans.update_transform(camobj);
	    m_phy.sync_transform(camobj);
	};

	/**
	 * Get distance to the pivot point for the TARGET camera.
	 * @method module:camera.target_get_distance
	 * @param {Object3D} camobj Camera 3D-object.
	 * @returns {number} Distance to the pivot point.
	 */
	exports.target_get_distance = function(camobj) {
	    if (!m_cam.is_target_camera(camobj)) {
	        m_print.error("target_get_distance(): Wrong camera object or camera move style");
	        return 0;
	    }

	    return m_trans.obj_point_distance(camobj, camobj.render.pivot);
	};

	/**
	 * Zoom the TARGET camera to the object.
	 * @method module:camera.target_zoom_object
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {Object3D} obj Object 3D.
	 */
	exports.target_zoom_object = function(camobj, obj) {
	    if (!m_cam.is_target_camera(camobj)) {
	        m_print.error("target_zoom_object(): Wrong camera object or camera move style");
	        return;
	    }

	    var center = m_trans.get_object_center(obj, false, _vec3_tmp);

	    var radius = m_trans.get_object_size(obj);
	    var active_scene = m_scs.get_active();
	    var cam_scene_data = m_obj_util.get_scene_data(camobj, active_scene);
	    var main_camera = cam_scene_data.cameras[0];
	    var ang_radius = m_cam.get_angular_diameter(main_camera) / 2;
	    var dist_need = radius / Math.sin(ang_radius);
	    var dist_current = m_trans.obj_point_distance(camobj, center);

	    m_cam.set_trans_pivot(camobj, m_tsr.get_trans_view(camobj.render.world_tsr), center);
	    // TODO: excess update
	    m_trans.update_transform(camobj);

	    // +y move backward
	    m_trans.move_local(camobj, 0, 0, dist_need - dist_current);

	    m_trans.update_transform(camobj);
	    m_phy.sync_transform(camobj);
	};

	/**
	 * Get the pivot point of the TARGET camera.
	 * @method module:camera.target_get_pivot
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {?Vec3} [dest=new Float32Array(3);] Pivot destination vector.
	 * @returns {?Vec3} Pivot destination vector.
	 */
	exports.target_get_pivot = function(camobj, dest) {
	    if (!m_cam.is_target_camera(camobj)) {
	        m_print.error("target_get_pivot(): Wrong camera object or camera move style");
	        return null;
	    }

	    dest = dest || new Float32Array(3);
	    m_vec3.copy(camobj.render.pivot, dest);
	    return dest;
	};

	/**
	 * Set distance limits for the TARGET camera.
	 * @method module:camera.target_set_distance_limits
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {?DistanceLimits} [limits=null] Distance limits. Pass null to disable 
	 * the limits.
	 */
	exports.target_set_distance_limits = function(camobj, limits) {
	    if (!m_cam.is_target_camera(camobj)) {
	        m_print.error("target_set_distance_limits(): Wrong camera object or camera move style");
	        return;
	    }

	    if (limits) {
	        if (typeof limits.min != "number" || typeof limits.max != "number" 
	                || limits.min > limits.max) {
	            m_print.error("target_set_distance_limits(): Wrong limits object");
	            return;
	        }
	        limits.min = Math.max(limits.min, 0);
	        limits.max = Math.max(limits.max, 0);
	    }

	    m_cam.set_distance_limits(camobj, limits);
	    m_trans.update_transform(camobj);
	    m_phy.sync_transform(camobj);
	};

	/**
	 * Get distance limits of the TARGET camera.
	 * @method module:camera.target_get_distance_limits
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {?DistanceLimits} [dest=new Object();] The receiving object.
	 * @returns {?DistanceLimits} Distance limits or null if disabled.
	 */
	exports.target_get_distance_limits = function(camobj, dest) {
	    if (!m_cam.is_target_camera(camobj)) {
	        m_print.error("target_get_distance_limits(): Wrong camera object or camera move style");
	        return null;
	    }

	    var render = camobj.render;
	    if (render.distance_limits) {
	        dest = dest || {};
	        dest.min = render.distance_limits.min;
	        dest.max = render.distance_limits.max;
	        return dest;
	    } else
	        return null;
	};

	/**
	 * Set vertical rotation limits for the TARGET camera.
	 * @see https://www.blend4web.com/doc/en/camera.html#camera-spherical-coordinates
	 * @method module:camera.target_set_vertical_limits
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {?VerticalRotationLimits} [limits=null] Vertical rotation limits. 
	 * Pass null to disable the limits.
	 */
	exports.target_set_vertical_limits = function(camobj, limits) {
	    if (!m_cam.is_target_camera(camobj)) {
	        m_print.error("target_set_vertical_limits(): Wrong camera object or camera move style");
	        return;
	    }

	    if (limits)
	        if (typeof limits.down != "number" || typeof limits.up != "number") {
	            m_print.error("target_set_vertical_limits(): Wrong limits object");
	            return;
	        }

	    m_cam.set_vertical_rot_limits(camobj, limits);
	    m_trans.update_transform(camobj);
	    m_phy.sync_transform(camobj);
	};

	/**
	 * Get vertical rotation limits of the TARGET camera (converted to the [-Pi, Pi] range).
	 * @see https://www.blend4web.com/doc/en/camera.html#camera-spherical-coordinates
	 * @method module:camera.target_get_vertical_limits
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {?VerticalRotationLimits} [dest=new Object();] The receiving object.
	 * @param {boolean} [local=false] Use camera local space representation.
	 * @returns {?VerticalRotationLimits} Vertical rotation limits or null if disabled.
	 */
	exports.target_get_vertical_limits = function(camobj, dest, local) {
	    if (!m_cam.is_target_camera(camobj)) {
	        m_print.error("target_get_vertical_limits(): Wrong camera object or camera move style");
	        return null;
	    }

	    var render = camobj.render;
	    if (render.vertical_limits) {
	        dest = dest || {};
	        if (local) {
	            dest.down = render.vertical_limits.down_local;
	            dest.up = render.vertical_limits.up_local;
	        } else {
	            dest.down = render.vertical_limits.down;
	            dest.up = render.vertical_limits.up;
	        }
	        dest.camera_space = local || false;
	        return dest;
	    } else
	        return null;
	};

	/**
	 * Set horizontal rotation limits for the TARGET camera.
	 * @see https://www.blend4web.com/doc/en/camera.html#camera-spherical-coordinates
	 * @method module:camera.target_set_horizontal_limits
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {?HorizontalRotationLimits} [limits=null] Horizontal rotation limits.
	 * Pass null to disable the limits.
	 */
	exports.target_set_horizontal_limits = function(camobj, limits) {
	    if (!m_cam.is_target_camera(camobj)) {
	        m_print.error("target_set_horizontal_limits(): Wrong camera object or camera move style");
	        return;
	    }

	    if (limits)
	        if (typeof limits.left != "number" || typeof limits.right != "number") {
	            m_print.error("target_set_horizontal_limits(): Wrong limits object");
	            return;
	        }

	    m_cam.set_horizontal_rot_limits(camobj, limits);
	    m_trans.update_transform(camobj);
	    m_phy.sync_transform(camobj);
	};

	/**
	 * Get horizontal rotation limits of the TARGET camera (converted to the [0, 2Pi] range).
	 * @see https://www.blend4web.com/doc/en/camera.html#camera-spherical-coordinates
	 * @method module:camera.target_get_horizontal_limits
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {?HorizontalRotationLimits} [dest=new Object();] The receiving object.
	 * @param {boolean} [local=false] Use camera local space representation.
	 * @returns {?HorizontalRotationLimits} Horizontal rotation limits or null if disabled.
	 */
	exports.target_get_horizontal_limits = function(camobj, dest, local) {
	    if (!m_cam.is_target_camera(camobj)) {
	        m_print.error("target_get_horizontal_limits(): Wrong camera object or camera move style");
	        return null;
	    }

	    var render = camobj.render;
	    if (render.horizontal_limits) {
	        dest = dest || {};
	        if (local) {
	            dest.left = render.horizontal_limits.left_local;
	            dest.right = render.horizontal_limits.right_local;
	        } else {
	            dest.left = render.horizontal_limits.left;
	            dest.right = render.horizontal_limits.right;
	        }
	        dest.camera_space = local || false;
	        return dest;
	    } else
	        return null;
	};

	/**
	 * Set pivot limits for the TARGET camera.
	 * @method module:camera.target_set_pivot_limits
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {?PivotLimits} [limits=null] Pivot limits. Pass null to 
	 * disable the limits.
	 */
	exports.target_set_pivot_limits = function(camobj, limits) {
	    if (!m_cam.is_target_camera(camobj)) {
	        m_print.error("target_set_pivot_limits(): Wrong camera object or camera move style");
	        return;
	    }

	    if (limits) {
	        if (typeof limits.min_z != "number" || typeof limits.max_z != "number" 
	                || limits.min_z > limits.max_z) {
	            m_print.error("target_set_pivot_limits(): Wrong limits object");
	            return;
	        }
	    }

	    m_cam.set_pivot_limits(camobj, limits);
	    m_trans.update_transform(camobj);
	    m_phy.sync_transform(camobj);
	};

	/**
	 * Get pivot limits of the TARGET camera.
	 * @method module:camera.target_get_pivot_limits
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {?PivotLimits} [dest=new Object();] The receiving object.
	 * @returns {?PivotLimits} pivot limits or null if disabled.
	 */
	exports.target_get_pivot_limits = function(camobj, dest) {
	    if (!m_cam.is_target_camera(camobj)) {
	        m_print.error("target_get_pivot_limits(): Wrong camera object or camera move style");
	        return null;
	    }

	    var render = camobj.render;
	    if (render.pivot_limits) {
	        dest = dest || {};
	        dest.min_z = render.pivot_limits.min_z;
	        dest.max_z = render.pivot_limits.max_z;
	        return dest;
	    } else
	        return null;
	};

	/**
	 * Translate the pivot point of the TARGET camera in screen space.
	 * Translation distance is defined with absolute value of parameters.
	 * +h from left to right
	 * +v from down to up
	 * @method module:camera.target_pan_pivot
	 * @param {Object3D} camobj Camera 3D-object
	 * @param {number} trans_h_delta Absolute delta of the horizontal translation.
	 * @param {number} trans_v_delta Absolute delta of the vertical translation.
	 */
	exports.target_pan_pivot = function(camobj, trans_h_delta, trans_v_delta) {
	    if (!m_cam.is_target_camera(camobj)) {
	        m_print.error("target_pan_pivot(): wrong object");
	        return;
	    }

	    var render = camobj.render;

	    if (render.use_panning) {
	        var trans_vector = _vec3_tmp;
	        trans_vector[0] = trans_h_delta;
	        trans_vector[1] = -trans_v_delta;
	        trans_vector[2] = 0;

	        m_tsr.transform_dir_vec3(trans_vector, render.world_tsr, trans_vector);

	        m_vec3.add(render.pivot, trans_vector, render.pivot);

	        var cam_trans = m_tsr.get_trans_view(render.world_tsr);
	        m_vec3.add(cam_trans, trans_vector, cam_trans);

	        m_trans.update_transform(camobj);
	        m_phy.sync_transform(camobj);
	    }
	};

	/**
	 * Enable/disable panning for the TARGET camera.
	 * @method module:camera.target_switch_panning
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {boolean} enable Enable or disable panning.
	 */
	exports.target_switch_panning = function(camobj, enable) {
	    if (!m_cam.is_target_camera(camobj)) {
	        m_print.error("target_switch_panning(): Wrong camera object or camera move style");
	        return null;
	    }

	    camobj.render.use_panning = enable;
	};

	/**
	 * Setup HOVER camera model with the distance and hover angle limits defined as 
	 * variations around the current values which depend on the given camera/pivot 
	 * positions.
	 * @method module:camera.hover_setup_rel
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {HoverCameraParamsRel} params The parameters of the HOVER camera.
	 */
	exports.hover_setup_rel = function(camobj, params) {
	    exports.hover_setup(camobj, { pos: params.pos, pivot: params.pivot });

	    if (typeof params.dist_interval == "undefined")
	        var dist_interval = 0;
	    else
	        var dist_interval = Math.max(params.dist_interval, 0);

	    if (typeof params.angle_interval == "undefined")
	        var angle_interval = 0;
	    else
	        var angle_interval = Math.max(params.angle_interval, 0);

	    if (typeof params.t == "undefined")
	        var t = 0.5;
	    else
	        var t = m_util.clamp(params.t, 0, 1);        

	    var dist_lim = exports.hover_get_distance_limits(camobj, _limits_tmp);
	    dist_lim.min = Math.max(dist_lim.min - t * dist_interval, 0);
	    dist_lim.max = dist_lim.max + (1 - t) * dist_interval;

	    var ha_lim = exports.hover_get_vertical_limits(camobj, _limits_tmp2);
	    ha_lim.down = m_util.clamp(ha_lim.down + t * angle_interval, -Math.PI/2, 0);
	    ha_lim.up = m_util.clamp(ha_lim.up - (1 - t) * angle_interval, -Math.PI/2, 0);

	    m_cam.hover_set_distance_limits(camobj, dist_lim);
	    m_cam.hover_set_vertical_limits(camobj, ha_lim);

	    m_trans.update_transform(camobj);
	    m_phy.sync_transform(camobj);

	    // init ortho after the camera was updated
	    m_cam.init_ortho_props(camobj);
	};

	/**
	 * Setup HOVER camera model.
	 * @method module:camera.hover_setup
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {HoverCameraParams} params The parameters of the HOVER camera.
	 */
	exports.hover_setup = function(camobj, params) {

	    if (!m_obj_util.is_camera(camobj)) {
	        m_print.error("hover_setup(): Wrong camera object");
	        return;
	    }

	    if (params.dist_lim) {
	        if (typeof params.dist_lim.min != "number" 
	                || typeof params.dist_lim.max != "number"
	                || params.dist_lim.min > params.dist_lim.max) {
	            m_print.error("hover_setup(): Wrong distance limits object");
	            return;
	        }
	        params.dist_lim.min = Math.max(params.dist_lim.min, 0);
	        params.dist_lim.max = Math.max(params.dist_lim.max, 0);
	    }
	    if (params.hover_angle_lim)
	        if (typeof params.hover_angle_lim.down != "number" 
	                || typeof params.hover_angle_lim.up != "number"
	                || params.hover_angle_lim.down < params.hover_angle_lim.up) {
	            m_print.error("hover_setup(): Wrong hover angle limits object");
	            return;
	        }
	    if (params.horiz_trans_lim)
	        if (typeof params.horiz_trans_lim.min != "number" 
	                || typeof params.horiz_trans_lim.max != "number"
	                || params.horiz_trans_lim.min > params.horiz_trans_lim.max) {
	            m_print.error("hover_setup(): Wrong horizontal translation limits object");
	            return;
	        }
	    if (params.vert_trans_lim)
	        if (typeof params.vert_trans_lim.min != "number" 
	                || typeof params.vert_trans_lim.max != "number"
	                || params.vert_trans_lim.min > params.vert_trans_lim.max) {
	            m_print.error("hover_setup(): Wrong vertical translation limits object");
	            return;
	        }

	    m_cam.wipe_move_style(camobj);
	    camobj.render.move_style = m_cam.MS_HOVER_CONTROLS;

	    var pos = params.pos || m_tsr.get_trans_view(camobj.render.world_tsr);
	    m_cam.setup_hover_model(camobj, pos, params.pivot, params.dist_lim, 
	            params.hover_angle_lim, params.horiz_trans_lim, 
	            params.vert_trans_lim, params.enable_horiz_rot || false);

	    m_trans.update_transform(camobj);
	    m_phy.sync_transform(camobj);

	    // init ortho after the camera was updated
	    m_cam.init_ortho_props(camobj);
	};

	/**
	 * Rotate the HOVER camera around its pivot by the given angles.
	 * Performs delta rotation or sets the camera's absolute rotation depending on 
	 * the "is_abs" parameter.
	 * @see https://www.blend4web.com/doc/en/camera.html#camera-spherical-coordinates
	 * @method module:camera.hover_rotate
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {number} phi Azimuth angle in radians
	 * @param {number} theta Elevation angle in radians
	 * @param {boolean} [is_abs=false] Performs delta rotation if FALSE, sets 
	 * camera's absolute rotation if TRUE.
	 * @deprecated [17.06] Use {@link module:camera.rotate_camera} instead
	 */
	exports.hover_rotate = function(camobj, phi, theta, is_abs) {
	    m_print.error_deprecated("hover_rotate", "rotate_camera");
	    if (!m_cam.is_hover_camera(camobj)) {
	        m_print.error("hover_rotate(): Wrong camera object or camera move style");
	        return;
	    }

	    is_abs = is_abs || false;

	    exports.rotate_camera(camobj, phi, theta, is_abs);
	};

	/**
	 * Performs parallel translation for the HOVER camera. It works as similar as
	 * the set_translation() method but uses the camera pivot to perform the translation.
	 * @method module:camera.hover_set_pivot_translation
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {Vec3} trans New pivot position.
	 */
	exports.hover_set_pivot_translation = function(camobj, trans) {
	    if (!m_cam.is_hover_camera(camobj)) {
	        m_print.error("hover_set_pivot_translation(): Wrong camera object or camera move style");
	        return;
	    }

	    m_cam.set_hover_pivot(camobj, trans);

	    m_trans.update_transform(camobj);
	    m_phy.sync_transform(camobj);
	};

	/**
	 * Get pivot position of the HOVER camera.
	 * @method module:camera.hover_get_pivot
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {Vec3} [dest=new Float32Array(3);] Destination vector for the pivot translation.
	 * @returns {?Vec3} Destination vector for the pivot translation.
	 */
	exports.hover_get_pivot = function(camobj, dest) {
	    if (!m_cam.is_hover_camera(camobj)) {
	        m_print.error("hover_get_pivot(): Wrong camera object or camera move style");
	        return null;
	    }

	    dest = dest || new Float32Array(3);
	    m_vec3.copy(camobj.render.hover_pivot, dest);
	    return dest;
	};

	/**
	 * Get distance to the pivot point for the HOVER camera.
	 * @method module:camera.hover_get_distance
	 * @param {Object3D} camobj Camera 3D-object.
	 * @returns {number} Distance to the pivot.
	 */
	exports.hover_get_distance = function(camobj) {
	    if (!m_cam.is_hover_camera(camobj)) {
	        m_print.error("hover_get_distance(): Wrong camera object or camera move style");
	        return 0;
	    }

	    return m_trans.obj_point_distance(camobj, camobj.render.hover_pivot);
	};

	/**
	 * Set vertical rotation (hover angle) limits for the HOVER camera.
	 * @see https://www.blend4web.com/doc/en/camera.html#camera-spherical-coordinates
	 * @method module:camera.hover_set_vertical_limits
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {HoverAngleLimits} limits Hover angle limits
	 */
	exports.hover_set_vertical_limits = function(camobj, limits) {
	    if (!m_cam.is_hover_camera(camobj)) {
	        m_print.error("hover_set_vertical_limits(): Wrong camera object or camera move style");
	        return;
	    }

	    if (typeof limits.down != "number" || typeof limits.up != "number"
	            || limits.down < limits.up) {
	        m_print.error("hover_set_vertical_limits(): Wrong limits object");
	        return;
	    }

	    m_cam.hover_set_vertical_limits(camobj, limits);

	    m_trans.update_transform(camobj);
	    m_phy.sync_transform(camobj);
	};

	/**
	 * Get vertical rotation (hover angle) limits for the HOVER camera (converted to the [-Pi, 0] range).
	 * @see https://www.blend4web.com/doc/en/camera.html#camera-spherical-coordinates
	 * @method module:camera.hover_get_vertical_limits
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {?HoverAngleLimits} [dest=new Object();] The receiving object.
	 * @returns {?HoverAngleLimits} Hover angle limits.
	 */
	exports.hover_get_vertical_limits = function(camobj, dest) {
	    if (!m_cam.is_hover_camera(camobj)) {
	        m_print.error("hover_get_vertical_limits(): Wrong camera object or camera move style");
	        return null;
	    }

	    var render = camobj.render;
	    dest = dest || {};
	    dest.down = render.vertical_limits.down;
	    dest.up = render.vertical_limits.up;

	    return dest;
	};

	/**
	 * Set distance limits for the HOVER camera.
	 * @method module:camera.hover_set_distance_limits
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {DistanceLimits} limits Distance limits.
	 */
	exports.hover_set_distance_limits = function(camobj, limits) {
	    if (!m_cam.is_hover_camera(camobj)) {
	        m_print.error("hover_set_distance_limits(): Wrong camera object or camera move style");
	        return;
	    }

	    if (typeof limits.min != "number" || typeof limits.max != "number"
	            || limits.min > limits.max) {
	        m_print.error("hover_set_distance_limits(): Wrong limits object");
	        return;
	    }
	    limits.min = Math.max(limits.min, 0);
	    limits.max = Math.max(limits.max, 0);

	    m_cam.hover_set_distance_limits(camobj, limits);

	    m_trans.update_transform(camobj);
	    m_phy.sync_transform(camobj);
	};

	/**
	 * Get distance limits of the HOVER camera.
	 * @method module:camera.hover_get_distance_limits
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {?DistanceLimits} [dest=new Object();] The receiving object.
	 * @returns {?DistanceLimits} Distance limits.
	 */
	exports.hover_get_distance_limits = function(camobj, dest) {
	    if (!m_cam.is_hover_camera(camobj)) {
	        m_print.error("hover_get_distance_limits(): Wrong camera object or camera move style");
	        return null;
	    }

	    var render = camobj.render;
	    dest = dest || {};
	    dest.min = render.distance_limits.min;
	    dest.max = render.distance_limits.max;
	    return dest;
	};

	/**
	 * Set vertical (along the Z axis) translation limits for the HOVER camera.
	 * @see https://www.blend4web.com/doc/en/camera.html#hover-translation-limits
	 * @method module:camera.hover_set_vert_trans_limits
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {?VerticalTranslationLimits} limits Vertical translation limits.
	 * Pass null to disable the limits.
	 */
	exports.hover_set_vert_trans_limits = function(camobj, limits) {
	    if (!m_cam.is_hover_camera(camobj)) {
	        m_print.error("hover_set_vert_trans_limits(): Wrong camera object or camera move style");
	        return;
	    }

	    if (limits)
	        if (typeof limits.min != "number" || typeof limits.max != "number"
	                || limits.min > limits.max) {
	            m_print.error("hover_set_vert_trans_limits(): Wrong limits object");
	            return;
	        }

	    m_cam.set_vert_trans_limits(camobj, limits);
	    m_trans.update_transform(camobj);
	    m_phy.sync_transform(camobj);
	};

	/**
	 * Get vertical translation limits of the HOVER camera.
	 * @see https://www.blend4web.com/doc/en/camera.html#hover-translation-limits
	 * @method module:camera.hover_get_vert_trans_limits
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {?VerticalTranslationLimits} [dest=new Object();] The receiving object.
	 * @returns {?VerticalTranslationLimits} Vertical translation limits or null if disabled.
	 */
	exports.hover_get_vert_trans_limits = function(camobj, dest) {
	    if (!m_cam.is_hover_camera(camobj)) {
	        m_print.error("hover_get_vert_trans_limits(): Wrong camera object or camera move style");
	        return null;
	    }

	    var render = camobj.render;
	    if (render.hover_vert_trans_limits) {
	        dest = dest || {};
	        dest.min = render.hover_vert_trans_limits.min;
	        dest.max = render.hover_vert_trans_limits.max;
	        return dest;
	    } else
	        return null;
	};

	/**
	 * Set horizontal (along the X axis) translation limits for the HOVER camera.
	 * @see https://www.blend4web.com/doc/en/camera.html#hover-translation-limits
	 * @method module:camera.hover_set_horiz_trans_limits
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {?HorizontalTranslationLimits} limits Horizontal translation limits.
	 * Pass null to disable the limits.
	 */
	exports.hover_set_horiz_trans_limits = function(camobj, limits) {
	    if (!m_cam.is_hover_camera(camobj)) {
	        m_print.error("hover_set_horiz_trans_limits(): Wrong camera object or camera move style");
	        return;
	    }

	    if (limits)
	        if (typeof limits.min != "number" || typeof limits.max != "number"
	                || limits.min > limits.max) {
	            m_print.error("hover_set_horiz_trans_limits(): Wrong limits object");
	            return;
	        }

	    m_cam.set_hor_trans_limits(camobj, limits);
	    m_trans.update_transform(camobj);
	    m_phy.sync_transform(camobj);
	};

	/**
	 * Get horizontal translation limits of the HOVER camera.
	 * @see https://www.blend4web.com/doc/en/camera.html#hover-translation-limits
	 * @method module:camera.hover_get_horiz_trans_limits
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {?HorizontalTranslationLimits} [dest=new Object();] The receiving object.
	 * @returns {?HorizontalTranslationLimits} Horizontal translation limits or null if disabled.
	 */
	exports.hover_get_horiz_trans_limits = function(camobj, dest) {
	    if (!m_cam.is_hover_camera(camobj)) {
	        m_print.error("hover_get_horiz_trans_limits(): Wrong camera object or camera move style");
	        return null;
	    }

	    var render = camobj.render;
	    if (render.hover_horiz_trans_limits) {
	        dest = dest || {};
	        dest.min = render.hover_horiz_trans_limits.min;
	        dest.max = render.hover_horiz_trans_limits.max;
	        return dest;
	    } else
	        return null;
	};

	/**
	 * Enable/disable horizontal rotation for the HOVER camera.
	 * @method module:camera.hover_switch_horiz_rotation
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {boolean} enable Enable or disable the rotation.
	 */
	exports.hover_switch_horiz_rotation = function(camobj, enable) {
	    if (!m_cam.is_hover_camera(camobj)) {
	        m_print.error("hover_switch_horiz_rotation(): Wrong camera object or camera move style");
	        return null;
	    }

	    camobj.render.enable_hover_hor_rotation = enable;
	};

	/**
	 * Check if the object is a camera and has the MS_STATIC movement style.
	 * @method module:camera.is_static_camera
	 * @param {Object3D} obj Object 3D
	 * @returns {boolean} The result of the checking.
	 */
	exports.is_static_camera = m_cam.is_static_camera;

	/**
	 * Check if the object is a camera and has the MS_TARGET_CONTROLS movement style.
	 * @method module:camera.is_target_camera
	 * @param {Object3D} obj Object 3D
	 * @returns {boolean} The result of the checking.
	 */
	exports.is_target_camera = m_cam.is_target_camera;

	/**
	 * Check if the object is a camera and has the MS_EYE_CONTROLS movement style.
	 * @method module:camera.is_eye_camera
	 * @param {Object3D} obj Object 3D
	 * @returns {boolean} The result of the checking.
	 */
	exports.is_eye_camera = m_cam.is_eye_camera;

	/**
	 * Check if the object is a camera and has the MS_HOVER_CONTROLS movement style.
	 * @method module:camera.is_hover_camera
	 * @param {Object3D} obj Object 3D
	 * @returns {boolean} The result of the checking.
	 */
	exports.is_hover_camera = m_cam.is_hover_camera;

	exports.get_move_style = function(camobj) {
	    if (!m_obj_util.is_camera(camobj)) {
	        m_print.error("get_move_style(): Wrong camera object");
	        return null;
	    }

	    return m_cam.get_move_style(camobj);
	};

	/**
	 * Translates the STATIC/EYE camera. Performs parallel translation for the TARGET/HOVER
	 * camera and its pivot.
	 * @method module:camera.set_translation
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {Vec3} trans New camera position.
	 */
	exports.set_translation = function(camobj, trans) {
	    if (!m_obj_util.is_camera(camobj)) {
	        m_print.error("set_translation(): Wrong camera object");
	        return;
	    }

	    var render = camobj.render;

	    if (m_cam.is_target_camera(camobj)) {
	        var cam_trans = m_tsr.get_trans_view(render.world_tsr);
	        var trans_delta = m_vec3.subtract(trans, cam_trans, _vec3_tmp);
	        m_vec3.add(trans_delta, render.pivot, render.pivot);
	    } else if (m_cam.is_hover_camera(camobj)) {
	        var cam_trans = m_tsr.get_trans_view(render.world_tsr);
	        var trans_delta = m_vec3.subtract(trans, cam_trans, _vec3_tmp);
	        m_vec3.add(trans_delta, render.hover_pivot, render.hover_pivot);
	    }
	    m_trans.set_translation(camobj, trans);

	    m_trans.update_transform(camobj);
	    m_phy.sync_transform(camobj);
	};

	/**
	 * Get the camera's translation vector.
	 * @method module:camera.get_translation
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {Vec3} [dest=new Float32Array(3);] Destination vector.
	 * @returns {?Vec3} Destination vector.
	 */
	exports.get_translation = function(camobj, dest) {
	    if (!m_obj_util.is_camera(camobj)) {
	        m_print.error("get_translation(): Wrong camera object");
	        return null;
	    }

	    dest = dest || new Float32Array(3);
	    return m_trans.get_translation(camobj, dest);
	};

	/**
	 * Rotate the TARGET/EYE/HOVER camera counterclockwise (CCW) by the given
	 * angles depending on the camera's movement style.
	 * Performs the delta rotation or sets the camera's absolute rotation depending
	 * on the "*_is_abs" parameters.
	 * @see https://www.blend4web.com/doc/en/camera.html#camera-spherical-coordinates
	 * @method module:camera.rotate_camera
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {number} phi Azimuth angle in radians
	 * @param {number} theta Elevation angle in radians
	 * @param {boolean} [is_abs=false] Performs delta rotation if FALSE, sets camera's absolute rotation if TRUE.
	 */
	exports.rotate_camera = function(camobj, phi, theta, is_abs) {
	    if (!m_obj_util.is_camera(camobj)) {
	        m_print.error("rotate_camera(): Wrong camera object");
	        return;
	    }

	    is_abs = is_abs || false;

	    
	    if (is_abs)
	        m_cam.set_rotation_angles(camobj, phi, theta);
	    else
	        m_cam.rotate_angles(camobj, phi, theta);

	    m_trans.update_transform(camobj);
	    m_phy.sync_transform(camobj);
	};

	/**
	 * Set velocity parameters for the camera.
	 * @method module:camera.set_velocities
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {VelocityParams} velocity Velocity parameters.
	 */
	exports.set_velocities = function(camobj, velocity) {
	    if (!m_obj_util.is_camera(camobj)) {
	        m_print.error("set_velocities(): Wrong camera object");
	        return;
	    }

	    var render = camobj.render;
	    if (typeof velocity.trans == "number")
	        render.velocity_trans = m_util.clamp(velocity.trans, 0, Infinity);
	    if (typeof velocity.rot == "number")
	        render.velocity_rot = m_util.clamp(velocity.rot, 0, Infinity);
	    if (typeof velocity.zoom == "number")
	        render.velocity_zoom = m_util.clamp(velocity.zoom, 0, 0.99);
	};

	/**
	 * Get velocity parameters of the camera.
	 * @method module:camera.get_velocities
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {VelocityParams} dest The receiving object.
	 * @returns {?VelocityParams} Velocity parameters.
	 */
	exports.get_velocities = function(camobj, dest) {
	    if (!m_obj_util.is_camera(camobj)) {
	        m_print.error("get_velocities(): Wrong camera object");
	        return null;
	    }

	    var render = camobj.render;
	    dest = dest || {};
	    dest.trans = render.velocity_trans;
	    dest.rot = render.velocity_rot;
	    dest.zoom = render.velocity_zoom;
	    return dest;
	};

	/**
	 * Check whether the camera is looking upwards.
	 * @method module:camera.is_look_up
	 * @param {Object3D} camobj Camera 3D-object.
	 * @returns {boolean} The result of the checking.
	 */
	exports.is_look_up = function(camobj) {
	    if (!m_obj_util.is_camera(camobj)) {
	        m_print.error("is_look_up(): Wrong camera object");
	        return false;
	    }

	    var quat = m_tsr.get_quat_view(camobj.render.world_tsr);
	    var dir = m_util.quat_to_dir(quat, m_util.AXIS_MZ, _vec3_tmp);

	    return dir[1] >= 0;
	};

	/**
	 * Get the angles of horizontal (azimuth) and vertical (elevation) rotation
	 * (CCW as seen from the rotation axis) of the TARGET/HOVER camera, or the
	 * analogous orientation angles of the EYE camera.
	 * Intended for the cameras with corrected up vector.
	 * @see https://www.blend4web.com/doc/en/camera.html#camera-spherical-coordinates
	 * @method module:camera.get_camera_angles
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {?Vec2} [dest=new Float32Array(2);] Destination vector for the camera
	 * angles (in radians): [phi, theta], phi: [0, 2Pi], theta: [-Pi, Pi].
	 * @returns {?Vec2} Destination vector for the camera angles (in radians): [phi, theta].
	 */
	exports.get_camera_angles = function(camobj, dest) {
	    if (!m_obj_util.is_camera(camobj)) {
	        m_print.error("get_camera_angles(): Wrong camera object");
	        return null;
	    }

	    dest = dest || new Float32Array(2);
	    m_cam.get_camera_angles(camobj, dest);
	    return dest;
	};

	/**
	 * Get the angles of horizontal (azimuth) and vertical (elevation) rotation
	 * (CCW as seen from the rotation axis) of the TARGET/HOVER camera, or the
	 * analogous orientation angles of the EYE camera.
	 * The angles are converted for the character object.
	 * Intended for the cameras with corrected up vector.
	 * @see https://www.blend4web.com/doc/en/camera.html#camera-spherical-coordinates
	 * @method module:camera.get_camera_angles_char
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {?Vec2} [dest=new Float32Array(2);] Destination vector for the camera
	 * angles (in radians): [phi, theta], phi: [0, 2Pi], theta: [-Pi, Pi].
	 * @returns {?Vec2} Destination vector for the camera angles (in radians): [phi, theta].
	 */
	exports.get_camera_angles_char = function(camobj, dest) {
	    if (!m_obj_util.is_camera(camobj)) {
	        m_print.error("get_camera_angles_char(): Wrong camera object");
	        return null;
	    }

	    dest = dest || new Float32Array(2);
	    m_cam.get_camera_angles_char(camobj, dest);
	    return dest;
	};

	/**
	 * Get the angles of horizontal (azimuth) and vertical (elevation) rotation
	 * (CCW as seen from the rotation axis) of the TARGET/HOVER camera, or the
	 * analogous orientation angles of the EYE camera from the given direction 
	 * representing the view vector of the camera, which up vector is vertically aligned.
	 * @see https://www.blend4web.com/doc/en/camera.html#camera-spherical-coordinates
	 * @method module:camera.get_camera_angles_dir
	 * @param {Vec3} dir Direction representing the view vector of the camera.
	 * @param {?Vec2} [dest=new Float32Array(2);] Destination vector for the camera
	 * angles (in radians): [phi, theta], phi: [0, 2Pi], theta: [-Pi, Pi].
	 * @returns {?Vec2} Destination vector for the camera angles (in radians): [phi, theta].
	 * @example
	 * var m_cam = require("camera");
	 * var m_vec3 = require("vec3");
	 *
	 * var view_vec = m_vec3.fromValues(10, 5, -3);
	 * var angles = new Float32Array(2);
	 * m_cam.get_camera_angles_dir(view_vec, angles);
	 * var phi = angles[0], theta = angles[1];
	 */
	exports.get_camera_angles_dir = function(dir, dest) {
	    dest = dest || new Float32Array(2);

	    var dir_norm = m_vec3.normalize(dir, _vec3_tmp);
	    var quat = m_util.rotation_to_stable(m_util.AXIS_MZ, dir_norm, _quat_tmp);
	    m_util.correct_cam_quat_up(quat, true);
	    m_cam.get_camera_angles_from_quat(quat, dest);
	    return dest;
	};

	/**
	 * Set the distance to the convergence plane of the stereoscopic camera.
	 * @method module:camera.set_stereo_distance
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {number} conv_dist Distance from the convergence plane.
	 */
	exports.set_stereo_distance = function(camobj, conv_dist) {
	    if (!m_obj_util.is_camera(camobj)) {
	        m_print.error("set_stereo_distance(): Wrong camera object");
	        return;
	    }

	    var active_scene = m_scs.get_active();
	    var cam_scene_data = m_obj_util.get_scene_data(camobj, active_scene);
	    var cameras = cam_scene_data.cameras;
	    for (var i = 0; i < cameras.length; i++) {
	        var cam = cameras[i];
	        if (cam.type == m_cam.TYPE_STEREO_LEFT ||
	                cam.type == m_cam.TYPE_STEREO_RIGHT ||
	                cam.type == m_cam.TYPE_HMD_LEFT ||
	                cam.type == m_cam.TYPE_HMD_RIGHT)
	            m_cam.set_stereo_params(cam, conv_dist, cam.stereo_eye_dist);
	    }
	};
	/**
	 * Get the distance from the convergence plane of the stereoscopic camera.
	 * @method module:camera.get_stereo_distance
	 * @param {Object3D} camobj Camera 3D-object.
	 * @returns {number} Distance from convergence plane.
	 */
	exports.get_stereo_distance = function(camobj) {
	    if (!m_obj_util.is_camera(camobj)) {
	        m_print.error("get_stereo_distance(): Wrong camera object");
	        return 0;
	    }

	    var active_scene = m_scs.get_active();
	    var cam_scene_data = m_obj_util.get_scene_data(camobj, active_scene);
	    var cameras = cam_scene_data.cameras;
	    for (var i = 0; i < cameras.length; i++) {
	        var cam = cameras[i];
	        if (cam.type == m_cam.TYPE_STEREO_LEFT ||
	                cam.type == m_cam.TYPE_STEREO_RIGHT)
	            return cam.stereo_conv_dist;
	    }

	    return 0;
	};

	/**
	 * Set the distance between eyes of the stereoscopic camera.
	 * @method module:camera.set_eye_distance
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {number} eye_dist Distance between eyes.
	 */
	exports.set_eye_distance = function(camobj, eye_dist) {
	    if (!m_obj_util.is_camera(camobj)) {
	        m_print.error("set_eye_distance(): Wrong camera object");
	        return;
	    }
	    var active_scene = m_scs.get_active();
	    var cam_scene_data = m_obj_util.get_scene_data(camobj, active_scene);
	    var cameras = cam_scene_data.cameras;
	    m_cam.set_eye_distance(cameras, eye_dist);
	};

	/**
	 * Get the distance between eyes of the stereoscopic camera.
	 * @method module:camera.get_eye_distance
	 * @param {Object3D} camobj Camera 3D-object.
	 * @returns {number} Distance between eyes.
	 */
	exports.get_eye_distance = function(camobj) {
	    if (!m_obj_util.is_camera(camobj)) {
	        m_print.error("get_eye_distance(): Wrong camera object");
	        return 0;
	    }

	    var active_scene = m_scs.get_active();
	    var cam_scene_data = m_obj_util.get_scene_data(camobj, active_scene);
	    var cameras = cam_scene_data.cameras;
	    for (var i = 0; i < cameras.length; i++) {
	        var cam = cameras[i];
	        if (cam.type == m_cam.TYPE_STEREO_LEFT ||
	                cam.type == m_cam.TYPE_STEREO_RIGHT ||
	                cam.type == m_cam.TYPE_HMD_LEFT ||
	                cam.type == m_cam.TYPE_HMD_RIGHT)
	            return cam.stereo_eye_dist;
	    }

	    return 0;
	};

	/**
	 * Set vertical axis of the camera.
	 * @method module:camera.set_vertical_axis
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {Vec3} axis Vertical axis.
	 */
	exports.set_vertical_axis = function(camobj, axis) {
	    if (!m_obj_util.is_camera(camobj)) {
	        m_print.error("set_vertical_axis(): Wrong camera object");
	        return;
	    }

	    var render = camobj.render;
	    m_vec3.copy(axis, render.vertical_axis);

	    m_trans.update_transform(camobj);
	    m_phy.sync_transform(camobj);
	};

	/**
	 * Get vertical axis of the camera.
	 * @method module:camera.get_vertical_axis
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {?Vec3} [dest=m_vec3.create();] Destination vector.
	 * @returns {?Vec3} Destination vector.
	 */
	exports.get_vertical_axis = function(camobj, dest) {
	    if (!m_obj_util.is_camera(camobj)) {
	        m_print.error("get_vertical_axis(): Wrong camera object");
	        return;
	    }

	    if (!dest)
	        dest = m_vec3.create();

	    var render = camobj.render;
	    m_vec3.copy(render.vertical_axis, dest);

	    return dest;
	};

	/**
	 * Translate the view plane of the camera.
	 * Modify the projection matrix of the camera so it appears to be moving in up-down
	 * and left-right directions. This method can be used to imitate character
	 * walking/running/driving.
	 * @method module:camera.translate_view
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {number} x X coord (positive - left to right).
	 * @param {number} y Y coord (positive - down to up).
	 * @param {number} angle Rotation angle in radians (clockwise).
	 */
	exports.translate_view = function(camobj, x, y, angle) {
	    if (!m_obj_util.is_camera(camobj)) {
	        m_print.error("translate_view(): Wrong camera object");
	        return;
	    }

	    var active_scene = m_scs.get_active();
	    var cam_scene_data = m_obj_util.get_scene_data(camobj, active_scene);
	    var cameras = cam_scene_data.cameras;
	    for (var i = 0; i < cameras.length; i++) {
	        var cam = cameras[i];

	        m_vec3.set(-x, -y, 0, cam.view_transform_params.trans);
	        // cam.view_transform_params.angle = angle;

	        if (cam.reflection_plane)
	            m_cam.set_projection_reflect(cam, false);
	        else
	            m_cam.set_projection(cam, false);
	    }
	};

	/**
	 * Get camera view vector in world space.
	 * @method module:camera.get_view_vector
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {?Vec3} [dest=new Float32Array(3);] Destination vector.
	 * @returns {?Vec3} Destination vector.
	 */
	exports.get_view_vector = get_view_vector;
	function get_view_vector(camobj, dest) {
	    if (!m_obj_util.is_camera(camobj)) {
	        m_print.error("get_view_vector(): Wrong camera object");
	        return null;
	    }

	    dest = dest || new Float32Array(3);
	    var quat = m_tsr.get_quat_view(camobj.render.world_tsr);
	    m_util.quat_to_dir(quat, m_util.AXIS_MZ, dest);

	    return dest;
	}

	/**
	 * Get the vertical angle of the camera's field of view.
	 * @method module:camera.get_fov
	 * @param {Object3D} camobj Camera 3D-object.
	 * @returns {number} Camera field of view (in radians).
	 */
	exports.get_fov = function(camobj) {
	    if (!m_obj_util.is_camera(camobj)) {
	        m_print.error("get_fov(): Wrong camera object");
	        return 0;
	    }
	    var active_scene = m_scs.get_active();
	    var cam_scene_data = m_obj_util.get_scene_data(camobj, active_scene);
	    var cameras = cam_scene_data.cameras;
	    return m_cam.get_fov(cameras[0]);
	};

	/**
	 * Set the vertical angle of the camera's field of view.
	 * @method module:camera.set_fov
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {number} fov New camera field of view (in radians).
	 */
	exports.set_fov = function(camobj, fov) {
	    if (!m_obj_util.is_camera(camobj)) {
	        m_print.error("set_fov(): Wrong camera object");
	        return;
	    }

	    var active_scene = m_scs.get_active();
	    var cam_scene_data = m_obj_util.get_scene_data(camobj, active_scene);
	    var cameras = cam_scene_data.cameras;
	    for (var i = 0; i < cameras.length; i++) {
	        var cam = cameras[i];

	        m_cam.set_fov(cam, fov);

	        if (cam.reflection_plane)
	            m_cam.set_projection_reflect(cam, false);
	        else
	            m_cam.set_projection(cam, false);
	    }
	};

	/**
	 * Set the angles of the camera's field of view (for head-mounted display only).
	 * @method module:camera.set_hmd_fov
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {Vec4} hmd_left_fov New left camera field of view.
	 * @param {Vec4} hmd_right_fov New right camera field of view.
	 * @deprecated Do not use it anymore
	 */
	exports.set_hmd_fov = function(camobj, hmd_left_fov, hmd_right_fov) {
	    m_print.error_once("set_hmd_fov() deprecated");
	};

	/**
	 * Correct the UP vector of the camera.
	 * @method module:camera.correct_up
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {Vec3} [z_axis=util.AXIS_Z] Axis vector.
	 * @param {boolean} [strict=false] Align camera exactly with the direction of 
	 * the given axis vector (never with the opposite direction).
	 */
	exports.correct_up = function(camobj, z_axis, strict) {
	    if (!m_obj_util.is_camera(camobj)) {
	        m_print.error("correct_up(): Wrong camera object");
	        return;
	    }

	    z_axis = z_axis || camobj.render.vertical_axis;
	    m_cam.correct_up(camobj, z_axis, strict || false);

	    m_trans.update_transform(camobj);
	    m_phy.sync_transform(camobj);
	};

	/**
	 * Set the orthogonal scale of the camera.
	 * @method module:camera.set_ortho_scale
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {number} ortho_scale Orthogonal scale.
	 */
	exports.set_ortho_scale = function(camobj, ortho_scale) {
	    if (!m_obj_util.is_camera(camobj) || !m_cam.is_ortho_camera(camobj)) {
	        m_print.error("set_ortho_scale(): Wrong camera object");
	        return;
	    }

	    var render = camobj.render;

	    if (m_cam.is_target_camera(camobj)) {
	        var trans = m_tsr.get_trans_view(render.world_tsr);
	        var dir_dist = m_vec3.dist(trans, render.pivot);
	        render.init_fov = ortho_scale / 2 * render.init_dist / dir_dist;
	    } else if (m_cam.is_hover_camera(camobj)) {
	        var trans = m_tsr.get_trans_view(render.world_tsr);
	        var dir_dist = m_vec3.distance(trans, render.hover_pivot);
	        render.init_fov = ortho_scale / 2 * render.init_dist / dir_dist;
	    } else {
	        var active_scene = m_scs.get_active();
	        var cam_scene_data = m_obj_util.get_scene_data(camobj, active_scene);
	        // hover camera without distance limits, EYE or STATIC camera
	        cam_scene_data.cameras[0].fov = ortho_scale / 2;
	    }

	    m_cam.update_ortho_scale(camobj);
	};

	/**
	 * Get the orthogonal scale of the camera.
	 * @method module:camera.get_ortho_scale
	 * @param {Object3D} camobj Camera 3D-object.
	 * @returns {number} Orthogonal scale.
	 */
	exports.get_ortho_scale = function(camobj) {
	    if (!m_obj_util.is_camera(camobj) || !m_cam.is_ortho_camera(camobj)) {
	        m_print.error("get_ortho_scale(): Wrong camera object");
	        return 0;
	    }
	    var active_scene = m_scs.get_active();
	    var cam_scene_data = m_obj_util.get_scene_data(camobj, active_scene);
	    return cam_scene_data.cameras[0].fov * 2;
	};

	/**
	 * Check whether the camera is an ORTHO camera.
	 * @method module:camera.is_ortho_camera
	 * @param {Object3D} camobj Camera 3D-object.
	 * @returns {boolean} The result of the checking.
	 */
	exports.is_ortho_camera = function(camobj) {
	    if (!m_obj_util.is_camera(camobj)) {
	        m_print.error("is_ortho_camera(): Wrong camera object");
	        return false;
	    }

	    return m_cam.is_ortho_camera(camobj);
	};

	/**
	 * Calculate the direction of the camera ray based on the Canvas coordinates.
	 * The origin of the Canvas space is located in the top left corner of the Canvas.
	 * @method module:camera.calc_ray
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {number} canvas_x X Canvas coordinate.
	 * @param {number} canvas_y Y Canvas coordinate.
	 * @param {?ParametricLine} [dest=new Float32Array(6);] Destination parametric line.
	 * @returns {?ParametricLine} Destination parametric line.
	 */
	exports.calc_ray = function(camobj, canvas_x, canvas_y, dest) {
	    if (!m_obj_util.is_camera(camobj)) {
	        m_print.error("calc_ray(): Wrong camera object");
	        return null;
	    }
	    var active_scene = m_scs.get_active();
	    var cam_scene_data = m_obj_util.get_scene_data(camobj, active_scene);
	    var cam = cam_scene_data.cameras[0];
	    // NOTE: It's for compatibility.
	    if (dest && dest.length == 3)
	        m_print.error_once("dest parameter in the function \"calc_ray\" " +
	                "should be type of parametric line.");
	    else
	        dest = dest || new Float32Array(6);

	    switch (cam.type) {
	    case m_cam.TYPE_PERSP:
	    case m_cam.TYPE_PERSP_ASPECT:
	    case m_cam.TYPE_STEREO_LEFT:
	    case m_cam.TYPE_STEREO_RIGHT:
	        var top_1m = Math.tan(m_cam.get_vfov(cam) / 2);
	        var right_1m = top_1m * cam.aspect;

	        var dir = _vec3_tmp;

	        var viewport_xy = m_cont.canvas_to_viewport_coords(canvas_x, canvas_y,
	            _vec2_tmp, cam);

	        // in the camera's local space
	        dir[0] = (2.0 * viewport_xy[0] / cam.width - 1.0) * right_1m;
	        dir[1] = (1.0 - 2.0 * viewport_xy[1] / cam.height) * top_1m;
	        dir[2] = -1;

	        m_tsr.transform_dir_vec3(dir, camobj.render.world_tsr, dir);

	        m_vec3.normalize(dir, dir);

	        if (dest.length == 3)
	            m_vec3.copy(dir, dest);
	        else {
	            var cam_eye = m_trans.get_translation(camobj, _vec3_tmp2);
	            m_math.set_pline_initial_point(dest, cam_eye);
	            m_math.set_pline_directional_vec(dest, dir);
	        }

	        return dest;
	    case m_cam.TYPE_ORTHO:

	        var dir = _vec3_tmp;
	        var viewport_xy = m_cont.canvas_to_viewport_coords(canvas_x, canvas_y,
	                _vec2_tmp, cam);

	        dir[0] = (2.0 * viewport_xy[0] / cam.width - 1.0) * cam.top * cam.aspect;
	        dir[1] = (1.0 - 2.0 * viewport_xy[1] / cam.height) * cam.top;
	        dir[2] = 0;

	        m_tsr.transform_vec3(dir, camobj.render.world_tsr, dir);
	        m_vec3.copy(dir, dest);

	        var quat = m_tsr.get_quat_view(camobj.render.world_tsr, _vec4_tmp);
	        m_vec3.transformQuat(m_util.AXIS_MZ, quat, dir);

	        m_math.set_pline_directional_vec(dest, dir);
	        return dest;
	    default:
	        m_print.error("calc_ray(): Non-compatible camera");
	        return dest;
	    }
	};

	/**
	 * Project the 3D point to the Canvas.
	 * Returned coordinates are measured in CSS pixels.
	 * @method module:camera.project_point
	 * @param {Object3D} camobj Camera 3D-object.
	 * @param {Vec3} point Point in world space.
	 * @param {Vec2|Vec3} [dest=new Float32Array(2);] Destination canvas coordinates
	 * (vec2 - X/Y, vec3 - X/Y/DEPTH).
	 * @returns {Vec2|Vec3} Destination canvas coordinates.
	 */
	exports.project_point = function(camobj, point, dest) {
	    if (!m_obj_util.is_camera(camobj)) {
	        m_print.error("project_point(): Wrong camera object");
	        return null;
	    }

	    dest = dest || new Float32Array(2);
	    return m_cam.project_point(camobj, point, dest);
	};

	/**
	 * Check whether the camera has distance limits.
	 * @method module:camera.has_distance_limits
	 * @param {Object3D} camobj Camera 3D-object.
	 * @returns {boolean} The result of the checking.
	 */
	exports.has_distance_limits = function(camobj) {
	    return (m_cam.is_target_camera(camobj) || m_cam.is_hover_camera(camobj)) 
	        && camobj.render.distance_limits !== null;
	};

	/**
	 * Check whether the camera has any vertical rotation limits.
	 * @method module:camera.has_vertical_rot_limits
	 * @param {Object3D} camobj Camera 3D-object.
	 * @returns {boolean} The result of the checking.
	 */
	exports.has_vertical_rot_limits = function(camobj) {
	    return (m_cam.is_eye_camera(camobj) || m_cam.is_target_camera(camobj) 
	            || m_cam.is_hover_camera(camobj)) && camobj.render.vertical_limits !== null;
	};

	/**
	 * Check whether the camera has any horizontal rotation limits.
	 * @method module:camera.has_horizontal_rot_limits
	 * @param {Object3D} camobj Camera 3D-object.
	 * @returns {boolean} The result of the checking.
	 */
	exports.has_horizontal_rot_limits = function(camobj) {
	    return (m_cam.is_target_camera(camobj) || m_cam.is_eye_camera(camobj)) 
	            && camobj.render.horizontal_limits !== null;
	};

	/**
	 * Check whether the camera has any vertical translation limits.
	 * @method module:camera.has_vertical_trans_limits
	 * @param {Object3D} camobj Camera 3D-object.
	 * @returns {boolean} The result of the checking.
	 */
	exports.has_vertical_trans_limits = function(camobj) {
	    return m_cam.is_hover_camera(camobj) && camobj.render.hover_vert_trans_limits !== null;
	};

	/**
	 * Check whether the camera has any horizontal translation limits.
	 * @method module:camera.has_horizontal_trans_limits
	 * @param {Object3D} camobj Camera 3D-object.
	 * @returns {boolean} The result of the checking.
	 */
	exports.has_horizontal_trans_limits = function(camobj) {
	    return m_cam.is_hover_camera(camobj) && camobj.render.hover_horiz_trans_limits !== null;
	};

	/**
	 * Get camera frustum planes.
	 * @method module:camera.get_frustum_planes
	 * @param {Object3D} camobj Camera object.
	 * @param {FrustumPlanes} planes Frustum planes object.
	 * @returns {?FrustumPlanes} Frustum planes object.
	 */
	exports.get_frustum_planes = function(camobj, planes) {
	    if (!m_obj_util.is_camera(camobj)) {
	        m_print.error("get_frustum_planes(): Wrong camera object");
	        return null;
	    }
	    var active_scene = m_scs.get_active();
	    var cam_scene_data = m_obj_util.get_scene_data(camobj, active_scene);
	    var fr_planes = cam_scene_data.cameras[0].frustum_planes;
	    m_vec4.copy(fr_planes.left, planes.left);
	    m_vec4.copy(fr_planes.right, planes.right);
	    m_vec4.copy(fr_planes.top, planes.top);
	    m_vec4.copy(fr_planes.bottom, planes.bottom);
	    m_vec4.copy(fr_planes.near, planes.near);
	    m_vec4.copy(fr_planes.far, planes.far);

	    return planes;
	};

	/**
	 * Set camera projection matrix.
	 * @method module:camera.set_projection
	 * @param {Object3D} camobj Camera object.
	 * @param {Float32Array} matrix Projection matrix.
	 */
	exports.set_projection = function(camobj, matrix) {
	    if (!m_obj_util.is_camera(camobj))
	        m_print.error("set_projection(): Wrong camera object");
	    else
	        m_cam.set_proj_mat(camobj, matrix);
	};

	}

	var camera_factory = register("camera", Camera);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * API for the engine's global configuration.
	 *
	 * <p>Use the {@link module:config.set|set()}/{@link module:config.get|get()} 
	 * method to change/get the value of a property. Use the 
	 * {@link module:config.reset|reset()} method to reset all properties to their 
	 * default state. Any change in configuration must occur before engine 
	 * initialization. Keep in mind that some of the properties are affected by the 
	 * quality profile and the user's hardware/browser. In the former case use the 
	 * {@link module:config.P_CUSTOM|P_CUSTOM} profile in order to change such 
	 * properties.</p>
	 *
	 * <p>Normally, the users should not alter these parameters.</p>
	 *
	 * <h3>Configuration Parameters Available</h3>
	 * <dl>
	 * <dt>allow_cors
	 * <dd>Boolean, allow cross-origin resource sharing.
	 * <dt>allow_hidpi
	 * <dd>Boolean, allow HIDPI mode on supported devices (use the 
	 * {@link module:config.P_CUSTOM|P_CUSTOM} profile in order to change this parameter).
	 * <dt>alpha
	 * <dd>Boolean, enable WebGL canvas transparency.
	 * <dt>alpha_sort
	 * <dd>Boolean, enable z-sorting for transparent materials.
	 * <dt>alpha_sort_threshold
	 * <dd>Number, camera distance threshold for transparency z-sorting.
	 * <dt>anaglyph_use
	 * <dd><span style="color: red;"> Deprecated, use "stereo" instead.</span> 
	 * Boolean, enable anaglyph stereo rendering.
	 * <dt>animation_framerate
	 * <dd>Number, animation framerate.
	 * <dt>anisotropic_filtering
	 * <dd>Boolean, enable anisotropic filtering.
	 * <dt>antialiasing
	 * <dd>Boolean, enable postprocess-based anti-aliasing (use the 
	 * {@link module:config.P_CUSTOM|P_CUSTOM} profile in order to change this parameter).
	 * <dt>assets_dds_available
	 * <dd>Boolean, allow the engine to use compressed DDS textures.
	 * <dt>assets_gzip_available
	 * <dd>Boolean, enable loading gzipped versions of json/bin/dds/pvr files. It's worth 
	 * doing it if gzip compression is not set up on a server. A gzipped file must be 
	 * placed near the original one and its name must be the same as the name of the 
	 * original file + the ".gz" extension. For example: 
	 * <pre>
	 *  my_folder/
	 *      my_project.json
	 *      my_project.json.gz
	 *      my_project.bin
	 *      my_project.bin.gz
	 * </pre>
	 * <dt>assets_min50_available
	 * <dd>Boolean, allow the engine to use halved textures. The halved
	 * textures should be present near the source textures in order to be picked up.
	 * <dt>assets_path
	 * <dd>String, path to the assets directory (for 
	 * {@link module:config.get_assets_path|get_assets_path()} and 
	 * {@link module:config.get_std_assets_path|get_std_assets_path()}).
	 * <dt>assets_pvr_available
	 * <dd>Boolean, allow the engine to use compressed PVRTC textures.
	 * These textures should be present near the source textures in order to be picked up.
	 * <dt>audio
	 * <dd>Boolean, enable Web Audio.
	 * <dt>background_color
	 * <dd>Array, RGBA values to use as a background color for the WebGL
	 * canvas.
	 * <dt>bloom
	 * <dd>Boolean, enable bloom.
	 * <dt>built_in_module_name
	 * <dd>String, name of the module which stores exported data (HTML export only).
	 * <dt>canvas_resolution_factor
	 * <dd>Number, set the resolution factor for the canvas. Requires the following call
	 * to apply changes:
	 * {@link module:container.resize_to_container|container.resize_to_container(true)}.
	 * <dt>compositing
	 * <dd>Boolean, enable compositing.
	 * <dt>console_verbose
	 * <dd>Boolean, print more debug info in the browser console.
	 * <dt>debug_view
	 * <dd>Boolean, enable debug view mode.
	 * <dt>dof
	 * <dd>Boolean, enable the Depth of Field effect.
	 * <dt>do_not_load_resources
	 * <dd>Boolean, disable loading of assets (textures and sounds).
	 * <dt>enable_outlining
	 * <dd>Boolean, enable object outlining.
	 * <dt>enable_selectable
	 * <dd>Boolean, enable object selection.
	 * <dt>enable_texture_cache
	 * <dd>Boolean, cache all textures to prevent redundant resource requests and 
	 * speed up scene dynamic loading. Enabled by default. Note: this option affects 
	 * the dynamic loading functionality only, if it's your case and you have some 
	 * issues with GPU memory overloading consider disabling this option.
	 * <dt>glow_materials
	 * <dd>Boolean, enable glow materials.
	 * <dt>gl_debug
	 * <dd>Boolean, enable gl errors check. Very slow.
	 * <dt>god_rays
	 * <dd>Boolean, enable god rays.
	 * <dt>is_mobile_device
	 * <dd>Boolean, check mobile device. Read-only.
	 * <dt>lod_leap_smooth_threshold
	 * <dd>Number, the maximum amount of the camera movement (in meters) that 
	 * still can trigger a smooth transition during the LOD switching. Low values can
	 * be useful to prevent noticeable smooth transitions while teleporting. High 
	 * values can be useful to keep smooth transitions for fast moving cameras 
	 * (e.g. flight simulators).
	 * <dt>lod_smooth_transitions
	 * <dd>Boolean, enable smooth transitions between LOD levels.
	 * <dt>max_fps
	 * <dd>Number, maximum FPS limit.
	 * <dt>max_fps_physics
	 * <dd>Number, maximum physics FPS limit.
	 * <dt>media_auto_activation
	 * <dd>Boolean, activate media data context on mobile devices using a popup dialog.
	 * <dt>motion_blur
	 * <dd>Boolean, enable motion_blur.
	 * <dt>outlining_overview_mode
	 * <dd>Boolean, make all objects selectable, enable object outlining and
	 * outlining on selection.
	 * <dt>physics_calc_fps
	 * <dd>Boolean, return physics FPS in the {@link module:main~FPSCallback|FPSCallback}.
	 * <dt>physics_enabled
	 * <dd>Boolean, use the uranium.js physics engine.
	 * <dt>physics_uranium_path
	 * <dd>String, path to the directory of uranium.js file. If not specified, search in the
	 * directory with the engine's sources.
	 * <dt>physics_use_wasm
	 * <dd>Boolean, use WebAssembly for physics or not(default).
	 * <dt>physics_use_workers
	 * <dd>Boolean, simulate physics in workers (default) or not.
	 * <dt>precision
	 * <dd>String, preferred GLSL floating point precision (use the 
	 * {@link module:config.P_CUSTOM|P_CUSTOM} profile in order to change this parameter).
	 * <dt>prevent_caching
	 * <dd>Boolean, prevent assets caching by appending timestamp suffix to their
	 * URLs (default) or not.
	 * <dt>quality
	 * <dd>Number, preferred rendering quality profile (one of 
	 * {@link module:config.P_LOW|P_LOW}, {@link module:config.P_HIGH|P_HIGH},
	 * {@link module:config.P_ULTRA|P_ULTRA}, {@link module:config.P_CUSTOM|P_CUSTOM} enums).
	 * <dt>reflections
	 * <dd>Boolean, enable reflections.
	 * <dt>reflection_quality
	 * <dd>String, quality of reflections. It can be "LOW", "MEDIUM" or "HIGH".
	 * <dt>refractions
	 * <dd>Boolean, enable refractions.
	 * <dt>sfx_mix_mode
	 * <dd>Boolean, enable the mixer mode in the SFX subsystem.
	 * <dt>shaders_path
	 * <dd>String, path to the shaders directory (developer version only).
	 * <dt>shadows
	 * <dd>Boolean, enable shadows.
	 * <dt>shadow_blur_samples
	 * <dd>String, number of shadow border blur samples. It can be "16x", "8x" or "4x".
	 * <dt>show_hud_debug_info
	 * <dd>Boolean, show HUD with debug information.
	 * <dt>smaa
	 * <dd><span style="color: red;">Deprecated.</span> Boolean, enable SMAA 
	 * anti-aliasing (use the {@link module:config.P_CUSTOM|P_CUSTOM} 
	 * profile in order to change this parameter).
	 * <dt>smaa_area_texture_path
	 * <dd><span style="color: red;">Deprecated.</span> String, path to the SMAA 
	 * "area" texture. If not specified, search in the directory with the engine's 
	 * sources.
	 * <dt>smaa_search_texture_path
	 * <dd><span style="color: red;">Deprecated.</span> String, path to the SMAA 
	 * "search" texture. If not specified, search in the directory with the engine's 
	 * sources.
	 * <dt>srgb_type
	 * <dd>String, the quality of the "Linear <-> sRGB" color conversions. Can be 
	 * one of the following: "SRGB_SIMPLE" - a bit faster, but less accurate, which 
	 * is especially noticeable for the dark tones; "SRGB_PROPER" - a bit slower, 
	 * but more precise.
	 * <dt>ssao
	 * <dd>Boolean, enable SSAO.
	 * <dt>stereo
	 * <dd>String, stereoscopic mode: "ANAGLYPH", "SIDEBYSIDE", "HMD" or "NONE".
	 * <dt>use_min50
	 * <dd>Boolean, enable min50 textures.
	 * </dl>
	 * @module config
	 * @local QualityProfile
	 * @cc_externs allow_cors allow_hidpi alpha alpha_sort
	 * @cc_externs alpha_sort_threshold anaglyph_use animation_framerate
	 * @cc_externs antialiasing assets_path assets_dds_available assets_min50_available 
	 * @cc_externs background_color built_in_module_name canvas_resolution_factor
	 * @cc_externs console_verbose compositing do_not_load_resources enable_selectable
	 * @cc_externs enable_outlining enable_texture_cache media_auto_activation outlining_overview_mode
	 * @cc_externs physics_enabled physics_uranium_path physics_calc_fps physics_use_workers
	 * @cc_externs precision prevent_caching quality physics_uranium_bin
	 * @cc_externs sfx_mix_mode shaders_path show_hud_debug_info
	 * @cc_externs smaa smaa_search_texture_path smaa_area_texture_path
	 * @cc_externs debug_view url_params stereo gl_debug max_fps max_fps_physics
	 * @cc_externs use_min50 anisotropic_filtering shadows reflections refractions
	 * @cc_externs ssao dof god_rays bloom motion_blur is_mobile_device shadow_blur_samples
	 * @cc_externs reflection_quality assets_pvr_available audio lod_leap_smooth_threshold
	 * @cc_externs lod_smooth_transitions glow_materials srgb_type physics_use_wasm assets_gzip_available
	 */
	function Config(ns, exports) {

	var m_cfg    = int_config_factory(ns);
	var m_compat = int_compat_factory(ns);
	var m_debug  = int_debug_factory(ns);
	var m_data   = int_data_factory(ns);
	var m_print  = print_factory(ns);


	/**
	 * Quality profile enum. One of {@link module:config.P_LOW|P_LOW}, {@link module:config.P_HIGH|P_HIGH}, {@link module:config.P_ULTRA|P_ULTRA}, {@link module:config.P_CUSTOM|P_CUSTOM}.
	 * @typedef {number} QualityProfile
	 */

	/**
	 * Low quality profile: maximize engine performance, minimize memory consumption.
	 * @const {QualityProfile} module:config.P_LOW
	 */
	exports.P_LOW = m_cfg.P_LOW;

	/**
	 * High quality profile: use all requested features.
	 * @const {QualityProfile} module:config.P_HIGH
	 */
	exports.P_HIGH = m_cfg.P_HIGH;

	/**
	 * Ultra quality profile: use all requested features and maximize quality.
	 * @const {QualityProfile} module:config.P_ULTRA
	 */
	exports.P_ULTRA = m_cfg.P_ULTRA;

	/**
	 * Custom quality profile: use engine defaults, allow customization.
	 * @const {QualityProfile} module:config.P_CUSTOM
	 */
	exports.P_CUSTOM = m_cfg.P_CUSTOM;

	/**
	 * Auto quality profile: cannot be used directly, only for quality
	 * auto configurators.
	 * @const {QualityProfile} module:config.P_AUTO
	 */
	exports.P_AUTO = m_cfg.P_AUTO;

	/**
	 * Set the value of the config property of the engine.
	 * @method module:config.set
	 * @param {string} prop Property name
	 * @param {*} value New property value
	 */
	exports.set = m_cfg.set;

	/**
	 * Get the value of the config property of the engine.
	 * @method module:config.get
	 * @param {string} prop Property name
	 * @returns {*} Value of property
	 */
	exports.get = m_cfg.get;

	/**
	 * Reset all the engine's config properties to defaults.
	 * @method module:config.reset
	 */
	exports.reset = m_cfg.reset;

	/**
	 * Reset context limit properties to minimum.
	 * @method module:config.reset_limits
	 */
	exports.reset_limits = m_cfg.reset_limits;
	/**
	 * Get the path to the standard assets directory inside the SDK.
	 * @method module:config.get_std_assets_path
	 * @returns {string} Path to assets
	 */
	exports.get_std_assets_path = m_cfg.get_assets_path;
	/**
	 * Get the path to the project's assets directory.
	 * @see https://www.blend4web.com/doc/en/developers.html#loading-application-assets
	 * @method module:config.get_assets_path
	 * @param {string} name Name of the project
	 * @returns {string} Path to assets
	 */
	exports.get_assets_path = m_cfg.get_assets_path;

	/**
	 * Set the engine's quality profile.
	 * @method module:config.apply_quality
	 * @param {QualityProfile} quality Quality profile
	 */
	exports.apply_quality = function(quality) {
	    if (m_data.is_primary_loaded()) {
	        m_print.error("Cannot change quality profile after a scene is loaded.");
	        return;
	    }

	    m_cfg.set("quality", quality);
	    var gl = m_debug.get_gl();
	    // initialized
	    if (gl) {
	        m_cfg.apply_quality();
	        m_compat.set_hardware_defaults(m_debug.get_gl(), false);
	    }
	};

	}

	var config_factory = register("config", Config);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Object constraints API. Please note that these constraints are not the same
	 * as those assigned in Blender.
	 * @module constraints
	 * @local StiffViewportPositioning
	 */
	function Constraints(ns, exports) {

	var m_cam      = int_camera_factory(ns);
	var m_cons     = int_constraints_factory(ns);
	var m_obj_util = int_obj_util_factory(ns);
	var m_phy      = int_physics_factory(ns);
	var m_print    = print_factory(ns);
	var m_trans    = int_transform_factory(ns);
	var m_util     = int_util_factory(ns);
	var m_vec3     = vec3_factory(ns);

	/**
	 * An object that defines positioning for the stiff viewport constraint.
	 * @typedef {Object} StiffViewportPositioning
	 * @property {number} [left] Offset from the left edge of the camera's viewport
	 * @property {number} [right] Offset from the right edge of the camera's viewport
	 * @property {number} [top] Offset from the top edge of the camera's viewport
	 * @property {number} [bottom] Offset from the bottom edge of the camera's viewport
	 * @property {number} [distance] Distance from the camera
	 * @property {Quat} [rotation] Rotation offset
	 * @property {string} [hor_units="widths"] Left/Right offset units: "heights" or "widths"
	 * @property {string} [vert_units="heights"] Top/Bottom offset units: "heights" or "widths"
	 * @cc_externs left right top bottom distance rotation hor_units vert_units
	 */

	/**
	 * Attach the object to the other object or to the armature bone using a
	 * stiff constraint. The child object will move, rotate and scale
	 * together with its parent. Examples: a sword is parented to the
	 * character's hand; the character is sitting in a vehicle.
	 *
	 * @method module:constraints.append_stiff
	 * @param {Object3D} obj Constrained object
	 * @param {(Object3D|Array)} target Target object or [Armature object, Bone Name]
	 * @param {Vec3} [offset] Offset, in the parent's local space.
	 * @param {Quat} [rotation_offset=null] Rotation offset, in the
	 * parent's local space.
	 * @param {number} [scale_offset=1] Scale offset, in the parent's local space.
	 *
	 * @example var m_scene = require("scenes");
	 * var m_const = require("constraints");
	 *
	 * var my_offset_vector = new Float32Array([2.0, 2.0, 2.0]);
	 *
	 * var my_cube = m_scene.get_object_by_name("cube");
	 * var my_sphere = m_scene.get_object_by_name("Icosphere");
	 *
	 * m_const.append_stiff(my_sphere, my_cube, my_offset_vector);
	 */
	exports.append_stiff = function(obj, target, offset, rotation_offset,
	        scale_offset) {

	    if (!m_obj_util.is_dynamic(obj)) {
	        m_print.error("Wrong object: \"" + obj.name + "\" is not dynamic.");
	        return;
	    }
	    if (!m_cons.check_self_applying(obj, target)) {
	        m_print.error("Can not apply constraint. Object and target must be different.");
	        return;
	    }
	    if (!m_cons.check_compatibility(obj, target)) {
	        m_print.error("Constraint recursion is forbidden.");
	        return;
	    }
	    offset = offset || new Float32Array(3);
	    scale_offset = scale_offset || 1;
	    rotation_offset =
	            rotation_offset ? rotation_offset : [0, 0, 0, 1];

	    if (target instanceof Array && target.length == 2)
	        m_cons.append_stiff_bone(obj, target[0], target[1], offset,
	                rotation_offset, scale_offset);
	    else
	        m_cons.append_stiff_obj(obj, target, offset, rotation_offset,
	                scale_offset);

	    m_trans.update_transform(obj);
	    m_phy.sync_transform(obj);
	};

	/**
	 * Attach the object to the other object using a
	 * semi-stiff constraint. The child object will move and rotate together with
	 * its parent, but it will be still possible to rotate it independently
	 * in the parent's local space. Example: a tank turret.
	 *
	 * @method module:constraints.append_semi_stiff
	 * @param {Object3D} obj Constrained object
	 * @param {Object3D} target Target object
	 * @param {Vec3} [offset] Offset, in the parent's local space
	 * @param {Quat} [rotation_offset] Initial rotation offset, in the
	 * parent's local space
	 * @param {number} [clamp_left] Left object rotation limit, in radians
	 * @param {number} [clamp_right] Right object rotation limit, in radians
	 * @param {number} [clamp_up] Upward object rotation limit, in radians
	 * @param {number} [clamp_down] Downward object rotation limit, in radians
	 *
	 * @example var m_scene = require("scenes");
	 * var m_const = require("constraints");
	 *
	 * var my_offset_vector = new Float32Array([2.0, 2.0, 2.0]);
	 *
	 * var my_cube = m_scene.get_object_by_name("cube");
	 * var my_sphere = m_scene.get_object_by_name("Icosphere");
	 *
	 * m_const.append_semi_stiff(my_sphere, my_cube, my_offset_vector);
	 */
	exports.append_semi_stiff = function(obj, target, offset, rotation_offset,
	                                            clamp_left, clamp_right,
	                                            clamp_up, clamp_down) {
	    if (!m_obj_util.is_dynamic(obj)) {
	        m_print.error("Wrong object: \"" + obj.name + "\" is not dynamic.");
	        return;
	    }
	    if (!m_cons.check_self_applying(obj, target)) {
	        m_print.error("Can not apply constraint. Object and target must be different.");
	        return;
	    }
	    if (!m_cons.check_compatibility(obj, target)) {
	        m_print.error("Constraint recursion is forbidden.");
	        return;
	    }
	    clamp_left  = m_util.isdef(clamp_left) ? clamp_left : Math.PI / 2;
	    clamp_right = m_util.isdef(clamp_right) ? clamp_right : -Math.PI / 2;
	    clamp_up    = m_util.isdef(clamp_up) ? clamp_up :  Math.PI / 2;
	    clamp_down  = m_util.isdef(clamp_down) ? clamp_down : -Math.PI / 2;
	    offset = offset || new Float32Array(3);
	    rotation_offset =
	            rotation_offset ? new Float32Array(rotation_offset) : null;

	    m_cons.append_semi_stiff_obj(obj, target, offset, rotation_offset,
	                                        clamp_left, clamp_right,
	                                        clamp_up, clamp_down);

	    m_trans.update_transform(obj);
	    m_phy.sync_transform(obj);
	};

	/**
	 * Attach the EYE camera to the object using a
	 * semi-stiff constraint. Also apply rotation limits to the camera.
	 * The camera will move and rotate together with
	 * its parent, but it will be still possible to rotate it independently
	 * in the parent's local space. The camera's UP vector will be preserved.
	 * Example: first-person vehicle view.
	 *
	 * @see https://www.blend4web.com/doc/en/camera.html#api
	 * @method module:constraints.append_semi_stiff_cam
	 * @param {Object3D} obj Constrained object
	 * @param {Object3D} target Target object
	 * @param {Vec3} [offset] Offset, in the parent's local space
	 * @param {Quat} [rotation_offset] Initial rotation offset, in the
	 * parent's local space
	 * @param {number} [clamp_left] Left camera rotation limit, in radians
	 * @param {number} [clamp_right] Right camera rotation limit, in radians
	 * @param {number} [clamp_up] Upward camera rotation limit, in radians
	 * @param {number} [clamp_down] Downward camera rotation limit, in radians
	 * @deprecated [17.06] Use {@link module:constraints.append_semi_stiff} instead
	 */
	exports.append_semi_stiff_cam = function(obj, target, offset, rotation_offset,
	                                            clamp_left, clamp_right,
	                                            clamp_up, clamp_down) {
	    m_print.error_deprecated("append_semi_stiff_cam", "append_semi_stiff");
	    if (!m_cam.is_eye_camera(obj)) {
	        m_print.error("append_semi_stiff_cam(): wrong object type, only EYE" +
	            " camera objects can be parented.");
	        return;
	    }
	    exports.append_semi_stiff(obj, target, offset, rotation_offset,
	                                            clamp_left, clamp_right,
	                                            clamp_up, clamp_down);
	};

	/**
	 * Attach the EYE camera to the object using a
	 * semi-soft constraint. The camera will smoothly follow the object's rear.
	 * Example: third-person character or vehicle views.
	 *
	 * @method module:constraints.append_semi_soft_cam
	 * @param {Object3D} obj Constrained object
	 * @param {Object3D} target Target object
	 * @param {Vec3} [offset] Offset, in the parent's local space
	 * @param {number} [softness=0.25] Camera smoothness ratio
	 * @deprecated [17.06] Use {@link module:constraints.append_semi_soft} instead
	 */
	exports.append_semi_soft_cam = function(obj, target, offset, softness) {

	    m_print.error_deprecated("append_semi_soft_cam", "append_semi_soft");
	    if (!m_cam.is_eye_camera(obj)) {
	        m_print.error("append_semi_soft_cam(): wrong object type, only EYE" +
	            " camera objects can be parented.");
	        return;
	    }
	    exports.append_semi_soft(obj, target, offset, softness);
	};

	/**
	 * Attach one object to another one using a
	 * semi-soft constraint. The object will smoothly follow the object's rear.
	 * Example: third-person character or vehicle views.
	 *
	 * @method module:constraints.append_semi_soft
	 * @param {Object3D} obj Constrained object
	 * @param {Object3D} target Target object
	 * @param {Vec3} [offset] Offset, in the parent's local space
	 * @param {number} [softness=0.25] Object smoothness ratio
	 *
	 * @example var m_scene = require("scenes");
	 * var m_const = require("constraints");
	 *
	 * var my_offset_vector = new Float32Array([2.0, 2.0, 2.0]);
	 * 
	 * var my_cube = m_scene.get_object_by_name("cube");
	 * var my_sphere = m_scene.get_object_by_name("Icosphere");
	 *
	 * m_const.append_semi_soft(my_sphere, my_cube, my_offset_vector, 0.5);
	 */
	exports.append_semi_soft = function(obj, target, offset, softness) {

	    if (!m_obj_util.is_dynamic(obj)) {
	        m_print.error("Wrong object: \"" + obj.name + "\" is not dynamic.");
	        return;
	    }
	    if (!m_cons.check_self_applying(obj, target)) {
	        m_print.error("Can not apply constraint. Object and target must be different.");
	        return;
	    }
	    if (!m_cons.check_compatibility(obj, target)) {
	        m_print.error("Constraint recursion is forbidden.");
	        return;
	    }
	    if (!m_util.isdef(softness) || softness < 0)
	        softness = 0.25;
	    offset = offset || new Float32Array(3);

	    m_cons.append_semi_soft_obj(obj, target, offset, softness);

	    m_trans.update_transform(obj);
	    m_phy.sync_transform(obj);
	};

	/**
	 * Attach the object to the other object using a
	 * stiff translation constraint. The child object will move together with
	 * its parent, but will not rotate. It will be still possible to rotate it
	 * independently from the parent.
	 * <p>
	 * Example: attaching the camera to the physics character in order to
	 * implement the first-person character view.
	 * </p>
	 * </p>
	 * Another example: the character
	 * jumps in water and splashes' particle emitter is attached to the
	 * first-person camera using this constraint - the bubbles will follow the
	 * character but will not be rotated with the camera.
	 * </p>
	 * @method module:constraints.append_stiff_trans
	 * @param {Object3D} obj Constrained object
	 * @param {Object3D} target Target object
	 * @param {Vec3} [offset] Offset, in the parent's local space
	 *
	 * @example var m_scene = require("scenes");
	 * var m_const = require("constraints");
	 *
	 * var my_offset_vector = new Float32Array([-2.0, 2.0, 2.0]);
	 *
	 * var my_cube = m_scene.get_object_by_name("cube");
	 * var my_sphere_4 = m_scene.get_object_by_name("Icosphere");
	 *
	 * m_const.append_stiff_trans(my_sphere, my_cube, my_offset_vector);
	 */
	exports.append_stiff_trans = function(obj, target, offset) {

	    if (!m_obj_util.is_dynamic(obj)) {
	        m_print.error("Wrong object: \"" + obj.name + "\" is not dynamic.");
	        return;
	    }
	    if (!m_cons.check_self_applying(obj, target)) {
	        m_print.error("Can not apply constraint. Object and target must be different.");
	        return;
	    }
	    if (!m_cons.check_compatibility(obj, target)) {
	        m_print.error("Constraint recursion is forbidden.");
	        return;
	    }
	    offset = offset || new Float32Array(3);
	    m_cons.append_stiff_trans_obj(obj, target, offset);

	    m_trans.update_transform(obj);
	    m_phy.sync_transform(obj);
	};

	/**
	 * Attach the object to the other object using a copy location constraint.
	 * The child object will move together with its parent, but will not rotate.
	 * Note that the offset is the object's location in the world space.
	 * <p>
	 * This method works similarly to the <b>Copy Location</b> constraint in Blender.
	 * </p>
	 * @method module:constraints.append_copy_loc
	 * @param {Object3D} obj Constrained object
	 * @param {Object3D} target Target object
	 * @param {string} [axes='XYZ'] Copy the target's location
	 * @param {boolean} [use_offset=false] Add original location into copied location
	 * @param {number} [influence=1] Amount of influence constraint will have on the final solution
	 *
	 * @example var m_scene = require("scenes");
	 * var m_const = require("constraints");
	 *
	 * var my_cube = m_scene.get_object_by_name("cube");
	 * var my_sphere = m_scene.get_object_by_name("Icosphere");
	 *
	 * m_const.append_copy_loc(my_sphere, my_cube, 'XYZ', false, 0.5);
	 */
	exports.append_copy_loc = function(obj, target, axes, use_offset, influence) {

	    if (!m_obj_util.is_dynamic(obj)) {
	        m_print.error("Wrong object: \"" + obj.name + "\" is not dynamic.");
	        return;
	    }
	    if (!m_cons.check_self_applying(obj, target)) {
	        m_print.error("Can not apply constraint. Object and target must be different.");
	        return;
	    }
	    if (!m_cons.check_compatibility(obj, target)) {
	        m_print.error("Constraint recursion is forbidden.");
	        return;
	    }
	    use_offset = use_offset || false;
	    axes = axes || "XYZ";
	    influence = influence || 1;
	    var offset = m_trans.get_translation(obj, new Float32Array(3));
	    var used_axes = new Float32Array(3);
	    used_axes[0] = axes.indexOf("-X") != -1 ? -1 : axes.indexOf("X") != -1 ? 1 : 0;
	    used_axes[1] = axes.indexOf("-Y") != -1 ? -1 : axes.indexOf("Y") != -1 ? 1 : 0;
	    used_axes[2] = axes.indexOf("-Z") != -1 ? -1 : axes.indexOf("Z") != -1 ? 1 : 0;
	    m_cons.append_copy_loc_obj(obj, target, offset, used_axes, use_offset, influence);

	    m_trans.update_transform(obj);
	    m_phy.sync_transform(obj);
	};

	/**
	 * Attach the object to the other object using a copy transforms constraint.
	 * The child object will move and rotate together with its parent.
	 * <p>
	 * This method works similarly to the <b>Copy Transforms</b> constraint in Blender.
	 * </p>
	 * @method module:constraints.append_copy_trans
	 * @param {Object3D} obj Constrained object
	 * @param {Object3D} target Target object
	 * @param {number} [influence=1] Amount of influence constraint will have on the final solution
	 *
	 * @example var m_scene = require("scenes");
	 * var m_const = require("constraints");
	 *
	 * var my_cube = m_scene.get_object_by_name("cube");
	 * var my_sphere = m_scene.get_object_by_name("Icosphere");
	 *
	 * m_const.append_copy_trans(my_sphere, my_cube, 0.5);
	 */
	exports.append_copy_trans = function(obj, target, influence) {

	    if (!m_obj_util.is_dynamic(obj)) {
	        m_print.error("Wrong object: \"" + obj.name + "\" is not dynamic.");
	        return;
	    }
	    if (!m_cons.check_self_applying(obj, target)) {
	        m_print.error("Can not apply constraint. Object and target must be different.");
	        return;
	    }
	    if (!m_cons.check_compatibility(obj, target)) {
	        m_print.error("Constraint recursion is forbidden.");
	        return;
	    }
	    influence = influence || 1;

	    m_cons.append_copy_trans_obj(obj, target, influence);

	    m_trans.update_transform(obj);
	    m_phy.sync_transform(obj);
	};

	/**
	 * Attach the object to the other object using a copy rotation constraint.
	 * The child object will rotate together with its parent, but will not move.
	 * Note that the offset is the object's rotation in the world space.
	 * <p> 
	 * This method works similarly to the <b>Copy Rotation</b> constraint in Blender.
	 * </p>
	 * @method module:constraints.append_copy_rot
	 * @param {Object3D} obj Constrained object
	 * @param {Object3D} target Target object
	 * @param {string} [axes='XYZ'] Copy the target's location
	 * @param {boolean} [use_offset=false] Add original location into copied location
	 * @param {number} [influence=1] Amount of influence constraint will have on the final solution
	 *
	 * @example var m_scene = require("scenes");
	 * var m_const = require("constraints");
	 *
	 * var my_cube = m_scene.get_object_by_name("cube");
	 * var my_sphere = m_scene.get_object_by_name("Icosphere");
	 *
	 * m_const.append_copy_rot(my_sphere, my_cube, 'XYZ', 0.5);
	 */
	exports.append_copy_rot = function(obj, target, axes, use_offset, influence) {

	    if (!m_obj_util.is_dynamic(obj)) {
	        m_print.error("Wrong object: \"" + obj.name + "\" is not dynamic.");
	        return;
	    }
	    if (!m_cons.check_self_applying(obj, target)) {
	        m_print.error("Can not apply constraint. Object and target must be different.");
	        return;
	    }
	    if (!m_cons.check_compatibility(obj, target)) {
	        m_print.error("Constraint recursion is forbidden.");
	        return;
	    }
	    use_offset = use_offset || false;
	    axes = axes || "XYZ";
	    influence = influence || 1;
	    var used_axes = new Float32Array(3);
	    used_axes[0] = axes.indexOf("-X") != -1 ? -1 : axes.indexOf("X") != -1 ? 1 : 0;
	    used_axes[1] = axes.indexOf("-Y") != -1 ? -1 : axes.indexOf("Y") != -1 ? 1 : 0;
	    used_axes[2] = axes.indexOf("-Z") != -1 ? -1 : axes.indexOf("Z") != -1 ? 1 : 0;
	    m_cons.append_copy_rot_obj(obj, target, used_axes, use_offset, influence);

	    m_trans.update_transform(obj);
	    m_phy.sync_transform(obj);
	};

	/**
	 * Attach the object to the other object using a
	 * stiff translation/rotation constraint. The child object will move and rotate
	 * together with its parent, but will not scale. It will be still possible to
	 * scale it independently from the parent.
	 *
	 * Example: smoke emitter attached to the tractor pipe; exhaustion effects
	 * are achieved by scaling the emitter.
	 *
	 * @method module:constraints.append_stiff_trans_rot
	 * @param {Object3D} obj Constrained object
	 * @param {Object3D} target Target object
	 * @param {Vec3} [offset] Offset, in the parent's local space
	 * @param {Quat} [rotation_offset] Rotation offset, in
	 * the parent's local space
	 *
	 * @example var m_scene = require("scenes");
	 * var m_const = require("constraints");
	 *
	 * var my_sphere = m_scene.get_object_by_name("Icosphere");
	 * var my_cube = m_scene.get_object_by_name("cube");
	 *
	 * var my_offset_vector = new Float32Array([-2.0, 2.0, 2.0]);
	 * m_const.append_stiff_trans_rot(my_sphere, my_cube, my_offset_vector);
	 */
	exports.append_stiff_trans_rot = function(obj, target, offset, rotation_offset) {

	    if (!m_obj_util.is_dynamic(obj)) {
	        m_print.error("Wrong object: \"" + obj.name + "\" is not dynamic.");
	        return;
	    }
	    if (!m_cons.check_self_applying(obj, target)) {
	        m_print.error("Can not apply constraint. Object and target must be different.");
	        return;
	    }
	    if (!m_cons.check_compatibility(obj, target)) {
	        m_print.error("Constraint recursion is forbidden.");
	        return;
	    }
	    offset = offset || new Float32Array(3);
	    rotation_offset =
	            rotation_offset ? new Float32Array(rotation_offset) : [0, 0, 0, 1];
	    m_cons.append_stiff_trans_rot_obj(obj, target, offset, rotation_offset, 1.0);

	    m_trans.update_transform(obj);
	    m_phy.sync_transform(obj);
	};

	/**
	 * Make the object "looking" at the target object.
	 *
	 * Example: a spot light which is tracking the character; both objects can be
	 * moved via API or animated.
	 * <p>
	 * This method works in a similar way to the <b>Track To</b> constraint in Blender.
	 * </p>
	 * @method module:constraints.append_track
	 * @param {Object3D} obj Constrained object
	 * @param {(Object3D)} target Target object
	 * @param {string} [track_axis='Y'] Axis that points to the target object
	 * @param {string} [up_axis='Z'] Axis that points upward
	 * @param {boolean} [use_target_z=false] Target's Z axis, not World Z axis, will constraint the Up direction
	 * @param {number} [influence=1] Amount of influence constraint will have on the final solution
	 *
	 * @example var m_scene = require("scenes");
	 * var m_const = require("constraints");
	 *
	 * var my_cube = m_scene.get_object_by_name("cube");  
	 * var my_camera = m_scene.get_object_by_name("Camera");
	 *
	 * m_const.append_track(my_camera, my_cube, "-X", "Z");
	 */
	exports.append_track = function(obj, target, track_axis, up_axis, use_target_z, influence) {

	    if (!m_obj_util.is_dynamic(obj)) {
	        m_print.error("Wrong object: \"" + obj.name + "\" is not dynamic.");
	        return;
	    }
	    if (!m_cons.check_self_applying(obj, target)) {
	        m_print.error("Can not apply constraint. Object and target must be different.");
	        return;
	    }
	    if (!m_cons.check_compatibility(obj, target)) {
	        m_print.error("Constraint recursion is forbidden.");
	        return;
	    }
	    var track_axis_vec = m_util.AXIS_Y;
	    if (track_axis == "-Y")
	        track_axis_vec = m_util.AXIS_MY;
	    else if (track_axis == "Y")
	        track_axis_vec = m_util.AXIS_Y;
	    else if (track_axis == "-X")
	        track_axis_vec = m_util.AXIS_MX;
	    else if (track_axis == "X")
	        track_axis_vec = m_util.AXIS_X;
	    else if (track_axis == "-Z")
	        track_axis_vec = m_util.AXIS_MZ;
	    else if (track_axis == "Z")
	        track_axis_vec = m_util.AXIS_Z;

	    var up_axis_vec = m_util.AXIS_Z;
	    if (up_axis == "X")
	        up_axis_vec = m_util.AXIS_X;
	    else if (up_axis == "Y")
	        up_axis_vec = m_util.AXIS_Y;

	    if (Math.abs(m_vec3.dot(track_axis_vec, up_axis_vec)) == 1) {
	        m_print.error("Can not use parallel vectors for track and up axes.");
	        return;
	    }

	    influence = influence || 1;
	    use_target_z = use_target_z || false;
	    m_cons.append_track_obj(obj, target, track_axis_vec, up_axis_vec,
	                    use_target_z, influence);

	    m_trans.update_transform(obj);
	    m_phy.sync_transform(obj);
	};

	/**
	 * Attach the object to the other object using a follow constraint. The child
	 * object will track and follow its parent position.
	 * <p>
	 * This method works similarly to the <b>Limit Distance</b> constraint in Blender, but, unlike it, does not set a precise distance.
	 * </p>
	 * Example: a follow-style camera view for the character.
	 *
	 * @method module:constraints.append_follow
	 * @param {Object3D} obj Constrained object
	 * @param {Object3D} target Target object
	 * @param {number} dist_min Minimum distance
	 * @param {number} dist_max Maximum distance
	 *
	 * @example var m_scene = require("scenes");
	 * var m_const = require("constraints");
	 *
	 * var my_cube = m_scene.get_object_by_name("cube");
	 * var my_camera = m_scene.get_object_by_name("Camera");
	 *
	 * m_const.append_follow(my_camera, my_cube, 2.0, 4.0);
	 */
	exports.append_follow = function(obj, target, dist_min, dist_max) {

	    if (!m_obj_util.is_dynamic(obj)) {
	        m_print.error("Wrong object: \"" + obj.name + "\" is not dynamic.");
	        return;
	    }
	    if (!m_cons.check_self_applying(obj, target)) {
	        m_print.error("Can not apply constraint. Object and target must be different.");
	        return;
	    }
	    if (!m_cons.check_compatibility(obj, target)) {
	        m_print.error("Constraint recursion is forbidden.");
	        return;
	    }
	    m_cons.append_follow_obj(obj, target, dist_min, dist_max);

	    m_trans.update_transform(obj);
	    m_phy.sync_transform(obj);
	};

	/**
	 * Attach the object to the camera using a stiff viewport constraint, so
	 * the child object will preserve its orientation in the camera viewport.
	 * This constraint is used to create onscreen 2D/3D user interfaces.
	 * @method module:constraints.append_stiff_viewport
	 * @param {Object3D} obj Constrained object
	 * @param {Object3D} camobj Camera object
	 * @param {StiffViewportPositioning} [positioning] Positioning
	 *
	 * @example var m_scene = require("scenes");
	 * var m_const = require("constraints");
	 *
	 * var sphere_1 = m_scene.get_object_by_name("Icosphere");
	 * var my_camera = m_scene.get_object_by_name("Camera");
	 *
	 * m_const.append_stiff_viewport(sphere_1, my_camera, { 
	 *      left: 150,
	 *      top: 100,
	 *      distance: 1
	 *  });
	 */
	exports.append_stiff_viewport = function(obj, camobj, positioning) {
	    if (!m_obj_util.is_dynamic(obj)) {
	        m_print.error("Wrong object: \"" + obj.name + "\" is not dynamic.");
	        return;
	    }
	    if (!m_cons.check_self_applying(obj, camobj)) {
	        m_print.error("Can not apply constraint. Object and target must be different.");
	        return;
	    }
	    if (!m_cons.check_compatibility(obj, camobj)) {
	        m_print.error("Constraint recursion is forbidden.");
	        return;
	    }
	    positioning = positioning || {};
	    m_cons.append_stiff_viewport(obj, camobj, positioning);

	    m_trans.update_transform(obj);
	    m_phy.sync_transform(obj);
	};

	/**
	 * Remove the object's constraint (if any).
	 * @method module:constraints.remove
	 * @param {Object3D} obj Constrained object
	 * @param {boolean} [restore_transform=false] Restore default transform
	 *
	 * @example var m_scene = require("scenes");
	 * var m_const = require("constraints");
	 *
	 * var my_sphere = m_scene.get_object_by_name("Icosphere");
	 *
	 * m_const.remove(my_sphere);
	 */
	exports.remove = function(obj, restore_transform) {
	    restore_transform = restore_transform || false;
	    if (obj.constraint)
	        m_cons.remove(obj, restore_transform);
	    if (restore_transform)
	        m_trans.update_transform(obj);
	};

	}

	var constraints_factory = register("constraints", Constraints);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Provides access to the 3D canvas element and its container.
	 * @module container
	 */
	function Container(ns, exports) {

	var m_cont   = int_container_factory(ns);
	var m_print  = print_factory(ns);

	/**
	 * Returns the 3D canvas element.
	 * @method module:container.get_canvas
	 * @returns {HTMLElement} Canvas element
	 */
	exports.get_canvas = m_cont.get_canvas;

	/**
	 * Returns the HUD element.
	 * @method module:container.get_canvas_hud
	 * @returns {HTMLElement} Canvas hud element
	 */
	exports.get_canvas_hud = m_cont.get_canvas_hud;

	/**
	 * Returns the HTML element which contains the 3D canvas.
	 * @method module:container.get_container
	 * @returns {HTMLElement} Canvas container element
	 */
	exports.get_container = m_cont.get_container;

	/**
	 * Inserts the DOM element to the container.
	 * @method module:container.insert_to_container
	 * @param {HTMLElement} elem Inserted DOM element.
	 * @param {string} stack_order Inserted DOM element stack order (one of "FIRST",
	 * "JUST_BEFORE_CANVAS", "JUST_AFTER_CANVAS", "LAST").
	 */
	exports.insert_to_container = function(elem, stack_order) {

	    if (arguments.length != 2) {
	        m_print.error("insert_to_container(): two arguments required");
	        return;
	    }

	    if (!elem || !stack_order)
	        return;

	    m_cont.insert_to_container(elem, stack_order);
	};

	/**
	 * Set left/top offsets (relative to browser window) for the canvas.
	 * Can be useful in case of scrolling/DOM-manipulations, when the canvas 
	 * position has been changed.
	 * @method module:container.set_canvas_offsets
	 * @param {number} left Left offset for the container
	 * @param {number} top Top offset for the container
	 * @deprecated Not needed anymore.
	 */
	exports.set_canvas_offsets = function(left, top) {
	    m_print.error_once("container.set_canvas_offsets() deprecated. " +
	            "Not needed anymore. Use the container.client_to_canvas_coords method.");
	    return m_cont.set_canvas_offsets(left, top);
	};

	/**
	 * Update canvas left/top offsets (relative to browser window).
	 * Can be useful in case of scrolling/DOM-manipulations, when the canvas 
	 * position has been changed.
	 * @method module:container.update_canvas_offsets
	 * @deprecated Not needed anymore.
	 */
	exports.update_canvas_offsets = function() {
	    m_print.error_once("container.update_canvas_offsets() deprecated. " +
	            "Not needed anymore. Use the container.client_to_canvas_coords method.");

	    m_cont.update_canvas_offsets();
	};

	/**
	 * Convert client(e.clientX/e.clientY) CSS coordinates to CSS coordinates 
	 * relative to the Canvas.
	 * @method module:container.client_to_canvas_coords
	 * @param {number} x X client coordinate.
	 * @param {number} y Y client coordinate.
	 * @param {Vec2} [dest=Float32Array(2)] Destination vector.
	 * @returns {Vec2} CSS coordinates relative to the Canvas.
	 */
	exports.client_to_canvas_coords = function(x, y, dest) {
	    if (!dest)
	        dest = new Float32Array(2);

	    return m_cont.client_to_canvas_coords(x, y, dest);
	};

	/**
	 * Convert client(e.clientX/e.clientY) CSS coordinates to CSS coordinates
	 * relative to the HTML element.
	 * @method module:container.client_to_element_coords
	 * @param {number} x X client coordinate.
	 * @param {number} y Y client coordinate.
	 * @param {HTMLElement} element HTML element.
	 * @param {Vec2} [dest=Float32Array(2)] Destination vector.
	 * @returns {Vec2} CSS coordinates relative to the Canvas.
	 */
	exports.client_to_element_coords = function(x, y, element, dest) {
	    if (!dest)
	        dest = new Float32Array(2);

	    return m_cont.client_to_element_coords(x, y, element, dest);
	};

	/**
	 * Get CSS coordinates from the given MouseEvent or TouchEvent transformed into 
	 * the space of its target element.
	 * @param {MouseEvent|TouchEvent} event An event to get values from.
	 * @param {boolean} [use_target_touches=false] For TouchEvent use only those 
	 * touches that were started on the event target element (the targetTouches 
	 * property).
	 * @param {Vec2} [dest=Float32Array(2)] Destination vector.
	 * @returns {Vec2} CSS coordinates relative to the Canvas.
	 * @example
	 * var m_cont = require("container");
	 * var m_input = require("input");
	 * var _vec2_tmp = new Float32Array(2);
	 *
	 * var canvas = m_cont.get_canvas();
	 * m_input.add_click_listener(canvas, function(event) {
	 *     var coords = m_cont.get_coords_target_space(event, false, _vec2_tmp);
	 * });
	 */
	exports.get_coords_target_space = function(event, use_target_touches, dest) {
	    if (!dest)
	        dest = new Float32Array(2);

	    return m_cont.get_coords_target_space(event, use_target_touches, dest);
	};

	/**
	 * Update canvas offsets on the next request.
	 * @method module:container.force_offsets_updating
	 * @deprecated Not needed anymore.
	 */
	exports.force_offsets_updating = function() {
	    m_print.error_once("container.force_offsets_updating() deprecated. " +
	            "Not needed anymore. Use the container.client_to_canvas_coords method.");

	    m_cont.force_offsets_updating();
	};

	/**
	 * Resize the rendering canvas.
	 * @method module:container.resize
	 * @param {number} width New canvas width
	 * @param {number} height New canvas height
	 * @param {boolean} [update_canvas_css=true] Change canvas CSS width/height
	 */
	exports.resize = function(width, height, update_canvas_css) {
	    m_cont.resize(width, height, update_canvas_css);
	};

	/**
	 * Fit canvas elements to match the size of container element.
	 * @method module:container.resize_to_container
	 * @param {boolean} [force=false] Resize canvas element even in case of
	 * matching of canvas and container size.
	 */
	exports.resize_to_container = function(force) {
	    force = force || false;
	    m_cont.resize_to_container(force);
	};

	}

	var container_factory = register("container", Container);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Implements the event-driven model of Blend4Web.
	 *
	 * <dl>
	 * <dt>Sensor</dt>
	 *
	 * <dd>Sensor is a programming entity intended for detecting events occurred in
	 * the scene. Some sensors may carry a payload. For example the
	 * ray-tracing sensor (Ray Sensor)
	 * provides the relative length of the intersection ray.</dd>
	 *
	 * <dt>Sensor Manifold (or simply manifold)</dt>
	 *
	 * <dd>Sensors should be present in one or multiple collections - so called
	 * sensor manifolds. A manifold is a logic container associated with a scene
	 * object. It generates a response (pulse) to a defined set of sensor events by
	 * executing a callback function.</dd>
	 * </dl>
	 *
	 * <p>In order to use the input-output sensors, register the corresponding event
	 * listeners by using register_* methods.</p>
	 *
	 * @see https://www.blend4web.com/doc/en/developers.html#event-model
	 *
	 * @module controls
	 * @local ManifoldCallback
	 * @local ManifoldLogicFunction
	 * @local CollisionPayload
	 * @local RayPayload
	 * @local SensorCallback
	 */
	function Controls(ns, exports) {

	var m_ctl   = int_controls_factory(ns);
	var m_phy   = int_physics_factory(ns);
	var m_print = print_factory(ns);

	/**
	 * Manifold's callback. It is executed when the manifold generates a pulse.
	 * @callback ManifoldCallback
	 * @param {?Object3D} obj Object 3D, or null to denote the global object
	 * @param {string} id Manifold ID
	 * @param {number} pulse Additional callback condition for CT_TRIGGER or
	 * CT_CONTINUOUS manifolds: +1 or -1
	 * @param {*} [param] Callback parameter. The user-defined parameter which is
	 * passed to create_sensor_manifold(). Can be used, for example, as a storage
	 * object to communicate between different manifolds.
	 */
	/**
	 * Manifold's logic function. Specifies a logic expression which consists of
	 * sensor values. This logic expression will be evaluated every frame. As a
	 * result, the manifold changes its internal state and fires the callback.
	 * @callback ManifoldLogicFunction
	 * @param {Array} s Numeric array with sensor values.
	 * @returns {number} Result of evaluation of the logic expression
	 */
	/**
	 * Collision sensor payload.
	 * @callback CollisionPayload
	 * @param {?Object3D} coll_obj The target collision object, i.e the object
	 * the source object collides with (null for no collision or when this object
	 * is represented by collision material).
	 * @param {?Vec3} coll_pos Position of collision point.
	 * @param {?Vec3} coll_norm Normal of collision point.
	 * @param {?number} coll_dist Distance between collision points of colliding
	 * objects.
	 * @cc_externs coll_obj coll_pos coll_norm coll_dist
	 */
	/**
	 * Ray sensor payload.
	 * @callback RayPayload
	 * @param {number} hit_fract Fraction of ray length where hit has occurred (0-1)
	 * or -1 if there is no hit anymore.
	 * @param {?Object3D} obj_hit The hit object.
	 * @param {number} hit_time Time the hit happened.
	 * @param {Vec3} hit_pos Hit position in world space.
	 * @param {Vec3} hit_norm Hit normal in world space.
	 * @cc_externs hit_fract obj_hit hit_time hit_pos hit_norm
	 */
	/**
	 * Special callback for callback-sensor. It's executed every frame and
	 * its return value is copied into the sensor value. Should return a numeric value.
	 * @callback SensorCallback
	 */

	/**
	 * Manifold control type: positive.
	 * Such manifold executes the callback each frame when the result of
	 * evaluation of its logic function is positive.
	 * @const module:controls.CT_POSITIVE
	 */
	exports.CT_POSITIVE = m_ctl.CT_POSITIVE;

	/**
	 * Manifold control type: continuous.
	 * Such manifold executes the callback with a positive pulse (+1) each frame
	 * when the result of evaluation of its logic function is non-zero.
	 * It executes a callback with a negative pulse (-1) once the logic function
	 * evaluates to zero.
	 * @const module:controls.CT_CONTINUOUS
	 */
	exports.CT_CONTINUOUS = m_ctl.CT_CONTINUOUS;

	/**
	 * Manifold control type: trigger.
	 * Such manifold executes the callback with a single positive pulse (+1) once the result of
	 * evaluation of its logic function is non-zero.
	 * It executes a callback with a single negative pulse (-1) once the logic function
	 * evaluates to zero.
	 * @const module:controls.CT_TRIGGER
	 */
	exports.CT_TRIGGER = m_ctl.CT_TRIGGER;

	/**
	 * Manifold control type: shot.
	 * Such manifold executes the callback once the result of evaluation of its
	 * logic function becomes a non-zero value.
	 * @const module:controls.CT_SHOT
	 */
	exports.CT_SHOT = m_ctl.CT_SHOT;

	/**
	 * Manifold control type: level.
	 * Such manifold executes the callback each time the result of
	 * evaluation of its logic function is changed.
	 * @const module:controls.CT_LEVEL
	 */
	exports.CT_LEVEL = m_ctl.CT_LEVEL;

	/**
	 * Manifold control type: change.
	 * Such manifold executes the callback each time the value
	 * of any sensor is changed. The logic function is ignored.
	 * @const module:controls.CT_CHANGE
	 */
	exports.CT_CHANGE = m_ctl.CT_CHANGE;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_BACKSPACE
	 */
	exports.KEY_BACKSPACE   = 8;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_TAB
	 */
	exports.KEY_TAB         = 9;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_ENTER
	 */
	exports.KEY_ENTER       = 13;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_SHIFT
	 */
	exports.KEY_SHIFT       = 16;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_CTRL
	 */
	exports.KEY_CTRL        = 17;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_ALT
	 */
	exports.KEY_ALT         = 18;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_PAUSE
	 */
	exports.KEY_PAUSE       = 19;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_CAPSLOCK
	 */
	exports.KEY_CAPSLOCK    = 20;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_ESC
	 */
	exports.KEY_ESC         = 27;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_SPACE
	 */
	exports.KEY_SPACE       = 32;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_LEFT
	 */
	exports.KEY_LEFT        = 37;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_UP
	 */
	exports.KEY_UP          = 38;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_RIGHT
	 */
	exports.KEY_RIGHT       = 39;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_DOWN
	 */
	exports.KEY_DOWN        = 40;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_1
	 */
	exports.KEY_1 = 49;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_2
	 */
	exports.KEY_2 = 50;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_3
	 */
	exports.KEY_3 = 51;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_4
	 */
	exports.KEY_4 = 52;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_5
	 */
	exports.KEY_5 = 53;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_6
	 */
	exports.KEY_6 = 54;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_7
	 */
	exports.KEY_7 = 55;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_8
	 */
	exports.KEY_8 = 56;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_9
	 */
	exports.KEY_9 = 57;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_A
	 */
	exports.KEY_A = 65;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_B
	 */
	exports.KEY_B = 66;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_C
	 */
	exports.KEY_C = 67;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_D
	 */
	exports.KEY_D = 68;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_E
	 */
	exports.KEY_E = 69;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_F
	 */
	exports.KEY_F = 70;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_G
	 */
	exports.KEY_G = 71;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_H
	 */
	exports.KEY_H = 72;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_I
	 */
	exports.KEY_I = 73;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_J
	 */
	exports.KEY_J = 74;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_K
	 */
	exports.KEY_K = 75;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_L
	 */
	exports.KEY_L = 76;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_M
	 */
	exports.KEY_M = 77;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_N
	 */
	exports.KEY_N = 78;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_O
	 */
	exports.KEY_O = 79;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_P
	 */
	exports.KEY_P = 80;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_Q
	 */
	exports.KEY_Q = 81;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_R
	 */
	exports.KEY_R = 82;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_S
	 */
	exports.KEY_S = 83;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_T
	 */
	exports.KEY_T = 84;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_U
	 */
	exports.KEY_U = 85;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_V
	 */
	exports.KEY_V = 86;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_W
	 */
	exports.KEY_W = 87;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_X
	 */
	exports.KEY_X = 88;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_Y
	 */
	exports.KEY_Y = 89;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_Z
	 */
	exports.KEY_Z = 90;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_NUM0
	 */
	exports.KEY_NUM0 = 96;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_NUM1
	 */
	exports.KEY_NUM1 = 97;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_NUM2
	 */
	exports.KEY_NUM2 = 98;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_NUM3
	 */
	exports.KEY_NUM3 = 99;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_NUM4
	 */
	exports.KEY_NUM4 = 100;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_NUM5
	 */
	exports.KEY_NUM5 = 101;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_NUM6
	 */
	exports.KEY_NUM6 = 102;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_NUM7
	 */
	exports.KEY_NUM7 = 103;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_NUM8
	 */
	exports.KEY_NUM8 = 104;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_NUM9
	 */
	exports.KEY_NUM9 = 105;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_NUM9
	 */
	exports.KEY_MULT = 106;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_NUM9
	 */
	exports.KEY_ADD = 107;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_NUM9
	 */
	exports.KEY_SUB = 109;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * Can only be used when NUM LOCK is turned on.
	 * @const module:controls.KEY_DEC_POINT
	 */
	exports.KEY_DEC_POINT = 110;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_NUM9
	 */
	exports.KEY_DIV = 111;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_SEMI_COLON
	 */
	exports.KEY_SEMI_COLON    = 186;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_EQUAL_SIGN
	 */
	exports.KEY_EQUAL_SIGN    = 187;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_COMMA
	 */
	exports.KEY_COMMA         = 188;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_DASH
	 */
	exports.KEY_DASH          = 189;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_PERIOD
	 */
	exports.KEY_PERIOD        = 190;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_FORWARD_SLASH
	 */
	exports.KEY_FORWARD_SLASH = 191;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_GRAVE_ACCENT
	 */
	exports.KEY_GRAVE_ACCENT  = 192;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_LEFT_SQ_BRACKET
	 */
	exports.KEY_LEFT_SQ_BRACKET  = 219;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_BACK_SLASH
	 */
	exports.KEY_BACK_SLASH       = 220;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_RIGHT_SQ_BRACKET
	 */
	exports.KEY_RIGHT_SQ_BRACKET = 221;

	/**
	 * Keyboard sensor parameter. Corresponds to keyCode property of KeyboardEvent.
	 * @const module:controls.KEY_SINGLE_QUOTE
	 */
	exports.KEY_SINGLE_QUOTE     = 222;

	/**
	 * Payload value of a touch movement sensor. Returned by get_sensor_payload()
	 * for single-finger pan gestures.
	 * @const module:controls.PL_SINGLE_TOUCH_MOVE
	 */
	exports.PL_SINGLE_TOUCH_MOVE    = m_ctl.PL_SINGLE_TOUCH_MOVE;

	/**
	 * Payload value of a touch movement sensor. Returned by get_sensor_payload()
	 * for multi-finger zoom gestures.
	 * @const module:controls.PL_MULTITOUCH_MOVE_ZOOM
	 */
	exports.PL_MULTITOUCH_MOVE_ZOOM = m_ctl.PL_MULTITOUCH_MOVE_ZOOM;

	/**
	 * Payload value of a touch movement sensor. Returned by get_sensor_payload()
	 * for multi-finger pan gestures.
	 * @const module:controls.PL_MULTITOUCH_MOVE_PAN
	 */
	exports.PL_MULTITOUCH_MOVE_PAN  = m_ctl.PL_MULTITOUCH_MOVE_PAN;

	/**
	 * Payload value of a touch movement sensor. Returned by get_sensor_payload()
	 * for multi-finger rotate gestures.
	 * @const module:controls.PL_MULTITOUCH_MOVE_ROTATE
	 */
	exports.PL_MULTITOUCH_MOVE_ROTATE  = m_ctl.PL_MULTITOUCH_MOVE_ROTATE;

	/**
	 * Default logic AND function for sensor manifold
	 * @const module:controls.default_AND_logic_fun
	 */
	exports.default_AND_logic_fun = m_ctl.default_AND_logic_fun;

	/**
	 * Default logic OR function for sensor manifold
	 * @const module:controls.default_OR_logic_fun
	 */
	exports.default_OR_logic_fun = m_ctl.default_OR_logic_fun;

	/**
	 * Create a gamepad button sensor.
	 * @method module:controls.create_gamepad_btn_sensor
	 * @param {number} ind Button number
	 * @param {number} [number] Connected gamepad number
	 * @returns {Sensor} Sensor object
	 */
	exports.create_gamepad_btn_sensor = m_ctl.create_gamepad_btn_sensor;
	/**
	 * Create a gamepad an axis sensor.
	 * @method module:controls.create_gamepad_axis_sensor
	 * @param {number} axis Axis number
	 * @param {number} [number] Connected gamepad number
	 * @returns {Sensor} Sensor object
	 */
	exports.create_gamepad_axis_sensor = m_ctl.create_gamepad_axis_sensor;

	/**
	 * Create a gamepad position sensor.
	 * @method module:controls.create_gamepad_position_sensor
	 * @param {number} [number] Connected gamepad number
	 * @returns {Sensor} Sensor object
	 */
	exports.create_gamepad_position_sensor = m_ctl.create_gamepad_position_sensor;
	/**
	 * Create a gamepad orientation sensor.
	 * @method module:controls.create_gamepad_orientation_sensor
	 * @param {number} [number] Connected gamepad number
	 * @returns {Sensor} Sensor object
	 */
	exports.create_gamepad_orientation_sensor = m_ctl.create_gamepad_orientation_sensor;

	/**
	 * Create a custom sensor.
	 * A custom sensor can be controlled manually by using the get_custom_sensor()
	 * and set_custom_sensor() methods.
	 * @method module:controls.create_custom_sensor
	 * @param {number} value Initial custom sensor value
	 * @returns {Sensor} Sensor object
	 */
	exports.create_custom_sensor = m_ctl.create_custom_sensor;

	/**
	 * Create a keyboard sensor.
	 * This sensor carries the following payload values:
	 * 0 --- button wasn't pressed at the last frame, and it wasn't pressed at the current frame,
	 * 1 --- button wasn't pressed at the last frame, but it was pressed at the current frame,
	 * 2 --- button was pressed at the last frame, and it was pressed at the current frame,
	 * 3 --- button was pressed at the last frame, and it wasn't pressed at the current frame.
	 * @method module:controls.create_keyboard_sensor
	 * @param {number} key Sensor key KEY_*
	 * @param {HTMLElement} [element=Canvas container element] HTML element
	 * @returns {Sensor} Sensor object
	 */
	exports.create_keyboard_sensor = m_ctl.create_keyboard_sensor;

	/**
	 * Create a collision sensor.
	 * Detects collisions between the object and the entities (objects or physics
	 * materials) with the specified collision ID. If the collision ID is not
	 * specified, the sensor will detect collisions with any entities.
	 * This sensor carries the following {@link CollisionPayload|payload}.
	 * @method module:controls.create_collision_sensor
	 * @param {Object3D} obj_src Collision object.
	 * @param {?string} [collision_id="ANY"] Collision ID, "ANY" for any collision ID
	 * @param {boolean} [calc_pos_norm=false] Should the sensor return the
	 * collision position/normal/distance or not.
	 * @returns {Sensor} Sensor object
	 */
	exports.create_collision_sensor = function(obj_src, collision_id, calc_pos_norm) {
	    collision_id = collision_id || "ANY";
	    calc_pos_norm = calc_pos_norm || false;

	    return m_ctl.create_collision_sensor(obj_src, collision_id, calc_pos_norm);
	};

	/**
	 * Create a collision impulse sensor.
	 * It is intended to obtain the value of the impulse (that is, mass multiplied
	 * by velocity) applied to the object at the collision point.
	 * @method module:controls.create_collision_impulse_sensor
	 * @param {Object3D} obj Collision object.
	 * @returns {Sensor} Sensor object
	 */
	exports.create_collision_impulse_sensor = m_ctl.create_collision_impulse_sensor;

	/**
	 * Create a ray sensor.
	 * The sensor casts a ray between the from and to positions.
	 * These positions are specified relatively to the object's origin
	 * (ign_src_rot = true), in the world space (obj_src = null) or in the local
	 * space (ign_src_rot = false).
	 * Checks intersection of this ray with the specified collision ID. If the
	 * collision ID is not specified, the sensor will detect collisions with any
	 * entities.
	 * This sensor carries the following {@link RayPayload|payload}.
	 * @method module:controls.create_ray_sensor
	 * @param {?Object3D} obj_src Source object, pass a non-null value to perform 
	 * ray casting in object space, e.g. from/to vectors specified in object space.
	 * @param {Vec3} from From vector.
	 * @param {Vec3} to To vector.
	 * @param {?string} [collision_id="ANY"] Collision ID, "ANY" for any collision ID
	 * @param {boolean} [is_binary_value=false] Calculate the value of the sensor as
	 * a binary (hit/non-hit) instead of hit fraction.
	 * @param {boolean} [calc_pos_norm=false] Calculate hit position/normal
	 * (accessed from payload object).
	 * @param {boolean} [ign_src_rot=false] Ignore any rotation of the source object
	 * during ray casting.
	 * @returns {Sensor} Sensor object.
	 */
	exports.create_ray_sensor = function(obj_src, from, to, collision_id,
	        is_binary_value, calc_pos_norm, ign_src_rot) {

	    if (obj_src && !m_phy.obj_has_physics(obj_src)) {
	        m_print.error_once("No physics for object " + obj_src.name);
	        return;
	    }

	    collision_id = collision_id || "ANY";
	    is_binary_value = is_binary_value || false;
	    calc_pos_norm = calc_pos_norm || false;
	    ign_src_rot = ign_src_rot || false;

	    return m_ctl.create_ray_sensor(obj_src, from, to, collision_id, is_binary_value,
	            calc_pos_norm, ign_src_rot);
	};

	/**
	 * Create a mouse click sensor.
	 * The sensor's payload is an object
	 * with useful properties like coordinates, and index of button
	 * @method module:controls.create_mouse_click_sensor
	 * @param {HTMLElement} [element=Canvas container element] HTML element
	 * @returns {Sensor} Sensor object
	 * @cc_externs coords which
	 */
	exports.create_mouse_click_sensor = m_ctl.create_mouse_click_sensor;

	/**
	 * Create a mouse wheel sensor.
	 * The sensor's value is 1 for a single wheel notch scrolled away from the user.
	 * @method module:controls.create_mouse_wheel_sensor
	 * @param {HTMLElement} [element=Canvas container element] HTML element
	 * @returns {Sensor} Sensor object
	 */
	exports.create_mouse_wheel_sensor = m_ctl.create_mouse_wheel_sensor;

	/**
	 * Create a mouse movement sensor.
	 * The sensor's value is a number of pixels, the sensor's payload is an object
	 * with useful properties like coordinates
	 * @method module:controls.create_mouse_move_sensor
	 * @param {string} [axis="XY"] Coordinate(s) to track: "X", "Y", "XY"
	 * @param {HTMLElement} [element] HTML element. The canvas container will be use by default.
	 * @returns {Sensor} Sensor object
	 * @cc_externs coords
	 */
	exports.create_mouse_move_sensor = m_ctl.create_mouse_move_sensor;
	/**
	 * Create a mouse move pointerlock sensor.
	 * The sensor's value is a number of pixels, the sensor's payload is an object
	 * with useful properties like coordinates
	 * @method module:controls.create_plock_mouse_sensor
	 * @param {HTMLElement} [element=Canvas container element] HTML element
	 * @returns {Sensor} Sensor object
	 * @cc_externs coords
	 */
	exports.create_plock_mouse_sensor = m_ctl.create_plock_mouse_sensor;
	/**
	 * Create a mouse pointerlock sensor.
	 * The sensor's value is a pointerlock state
	 * @method module:controls.create_plock_sensor
	 * @param {HTMLElement} [element=Canvas container element] HTML element
	 * @returns {Sensor} Sensor object
	 */
	exports.create_plock_sensor = m_ctl.create_plock_sensor;
	/**
	 * Create a touch movement sensor.
	 * The sensor's value is a number of pixels, the sensor's payload is an object
	 * with useful properties like coordinates
	 * @method module:controls.create_touch_move_sensor
	 * @param {string} [axis="XY"] Coordinate(s) to track: "X", "Y" or "XY"
	 * @param {HTMLElement} [element] HTML element. The canvas container will be use by default.
	 * @returns {Sensor} Sensor object
	 * @cc_externs coords gesture
	 */
	exports.create_touch_move_sensor = m_ctl.create_touch_move_sensor;

	/**
	 * Create a touch zoom sensor.
	 * The sensor's value is the distance difference in pixels.
	 * @method module:controls.create_touch_zoom_sensor
	 * @param {HTMLElement} [element=Canvas container element] HTML element
	 * @returns {Sensor} Sensor object
	 */
	exports.create_touch_zoom_sensor = m_ctl.create_touch_zoom_sensor;

	/**
	 * Create a touch rotate sensor.
	 * The sensor's value is the angle (in radians) from -PI to PI.
	 * @method module:controls.create_touch_rotate_sensor
	 * @param {HTMLElement} [element=Canvas container element] HTML element
	 * @returns {Sensor} Sensor object
	 */
	exports.create_touch_rotate_sensor = m_ctl.create_touch_rotate_sensor;

	/**
	 * Create a touch click sensor.
	 * The sensor's value is 1 for a touched touchscreen. The sensor's payload is an object
	 * with useful properties like coordinates
	 * @method module:controls.create_touch_click_sensor
	 * @param {HTMLElement} [element=Canvas container element] HTML element
	 * @returns {Sensor} Sensor object
	 * @cc_externs coords
	 */
	exports.create_touch_click_sensor = m_ctl.create_touch_click_sensor;

	/**
	 * Create a motion sensor.
	 * The sensor's value is 1 if the object is in motion.
	 * @method module:controls.create_motion_sensor
	 * @param {Object3D} obj Object 3D
	 * @param {number} [threshold=0.1] Translation velocity threshold,
	 * units (meters) per second
	 * @param {number} [rotation_threshold=0.1] Rotation velocity threshold,
	 * radians per second
	 * @returns {Sensor} Sensor object
	 */
	exports.create_motion_sensor = m_ctl.create_motion_sensor;

	/**
	 * Create a velocity sensor.
	 * The sensor's value is 1 if abs() of the object's vertical velocity exceeds
	 * the threshold.
	 * @method module:controls.create_vertical_velocity_sensor
	 * @param {Object3D} obj Object 3D
	 * @param {number} [threshold=1.0] Vertical velocity threshold,
	 * units (meters) per second
	 * @returns {Sensor} Sensor object
	 */
	exports.create_vertical_velocity_sensor = m_ctl.create_vertical_velocity_sensor;

	/**
	 * Create a gyroscope angle sensor.
	 * The sensor's payload stores the Euler angles of orientation (in radians)
	 * of a mobile device.
	 * @method module:controls.create_gyro_angles_sensor
	 * @returns {Sensor} Sensor object
	 */
	exports.create_gyro_angles_sensor = m_ctl.create_gyro_angles_sensor;

	/**
	 * Create a gyroscope quaternion sensor.
	 * The sensor's payload stores the quaternion of orientation
	 * of a mobile device.
	 * @method module:controls.create_gyro_quat_sensor
	 * @returns {Sensor} Sensor object
	 */
	exports.create_gyro_quat_sensor = m_ctl.create_gyro_quat_sensor;

	/**
	 * Create a gyroscope delta sensor.
	 * The sensor's payload stores the differences (in radians) between Euler angles
	 * of the current orientation and the previous orientation of a mobile device.
	 * @method module:controls.create_gyro_delta_sensor
	 * @returns {Sensor} Sensor object
	 */
	exports.create_gyro_delta_sensor = m_ctl.create_gyro_delta_sensor;

	/**
	 * Create a HMD quaternion sensor.
	 * The sensor's payload stores the quaternion of orientation of a HMD.
	 * @method module:controls.create_hmd_quat_sensor
	 * @returns {Sensor} Sensor object
	 */
	exports.create_hmd_quat_sensor = m_ctl.create_hmd_quat_sensor;

	/**
	 * Create a HMD position sensor.
	 * The sensor's payload stores the vector of HMD position.
	 * @method module:controls.create_hmd_position_sensor
	 * @returns {Sensor} Sensor object
	 */
	exports.create_hmd_position_sensor = m_ctl.create_hmd_position_sensor;

	/**
	 * Create a timer sensor.
	 * The sensor's value becomes 1 for the frame which comes next after the
	 * period of time has elapsed. After that, its value becomes 0 again.
	 * The timer's precision depends on FPS, so it is not effective for measuring
	 * short intervals.
	 * @method module:controls.create_timer_sensor
	 * @param {number} period Timer period, in seconds
	 * @param {boolean} [do_repeat=false] Re-start the timer upon expiration
	 * @returns {Sensor} Sensor object
	 */
	exports.create_timer_sensor = function(period, do_repeat) {
	    return m_ctl.create_timer_sensor(period, do_repeat || false);
	};

	/**
	 * Reset the timer sensor and set a new period value.
	 * @method module:controls.reset_timer_sensor
	 * @param {Object3D} obj Object 3D
	 * @param {string} manifold_id Object's manifold ID
	 * @param {number} num Sensor's number in the manifold
	 * @param {number} period A new period value for the sensor
	 */
	exports.reset_timer_sensor = m_ctl.reset_timer_sensor;

	/**
	 * Create an elapsed sensor.
	 * The sensor's value is the time elapsed from the previous frame.
	 * @method module:controls.create_elapsed_sensor
	 * @returns {Sensor} Sensor object
	 */
	exports.create_elapsed_sensor = m_ctl.create_elapsed_sensor;

	/**
	 * Create a timeline sensor.
	 * The sensor's value is the value of the global engine timeline.
	 * @method module:controls.create_timeline_sensor
	 * @returns {Sensor} Sensor object
	 */
	exports.create_timeline_sensor = m_ctl.create_timeline_sensor;

	/**
	 * Create a selection sensor for the object.
	 * The sensor's value becomes 1 when the object is selected by the user.
	 * @param {Object3D} obj Object 3D
	 * @param {boolean} [enable_toggle_switch=false] If true, reset the sensor
	 * (set it to 0) only when another object is selected. If false, reset the
	 * sensor when the mouse button/touch is released.
	 * @method module:controls.create_selection_sensor
	 * @returns {Sensor} Sensor object
	 */
	exports.create_selection_sensor = function(obj, enable_toggle_switch) {
	    return m_ctl.create_selection_sensor(obj, enable_toggle_switch || false);
	};

	/**
	 * Create a callback sensor.
	 * The given callback is executed every frame and its return value is copied into the sensor value.
	 * @param {SensorCallback} callback A callback which modifies sensor value.
	 * @param {number} [value=0] Initial sensor value.
	 * @method module:controls.create_callback_sensor
	 * @returns {Sensor} Sensor object
	 */
	exports.create_callback_sensor = function(callback, value) {
	    return m_ctl.create_callback_sensor(callback, value || 0);
	};

	/**
	 * Set the value of the custom sensor.
	 * @method module:controls.set_custom_sensor
	 * @param {Sensor} sensor Sensor object
	 * @param {number} value New sensor value
	 */
	exports.set_custom_sensor = function(sensor, value) {
	    m_ctl.sensor_set_value(sensor, value);
	};

	/**
	 * Get the value of the custom sensor.
	 * @method module:controls.get_custom_sensor
	 * @param {Sensor} sensor Sensor object
	 * @returns {number} Sensor value
	 */
	exports.get_custom_sensor = function(sensor) {
	    return sensor.value;
	};

	/**
	 * Return the value of the sensor from the object's manifold. The sensor is
	 * identified by its index in the manifold's array of sensors.
	 * @method module:controls.get_sensor_value
	 * @param {?Object3D} obj Object 3D, or null to denote the global object
	 * @param {string} manifold_id Object's manifold ID
	 * @param {number} num Sensor index in manifold's array
	 * @returns {number} Sensor value
	 */
	exports.get_sensor_value = m_ctl.get_sensor_value;

	/**
	 * Return the payload data of the sensor from the object's manifold. The sensor
	 * is identified by its index in the manifold's array of sensors.
	 * @method module:controls.get_sensor_payload
	 * @param {?Object3D} obj Object 3D, or null to denote the global object
	 * @param {string} manifold_id Object's manifold ID
	 * @param {number} num Sensor index in manifold's array
	 * @returns {*} Sensor payload
	 */
	exports.get_sensor_payload = m_ctl.get_sensor_payload;

	/**
	 * Create a sensor manifold.
	 * @method module:controls.create_sensor_manifold
	 * @param {?Object3D} obj Object 3D to attach the manifold to, or null to denote
	 * the global object.
	 * @param {string} id New manifold ID.
	 * @param {number} type Manifold control type (CT_SHOT, CT_TRIGGER etc).
	 * @param {Sensor[]} sensors Array of sensors.
	 * @param {?ManifoldLogicFunction} logic_fun Manifold's logic function, if null
	 * use default_AND_logic_fun function.
	 * @param {ManifoldCallback} callback Manifold's callback.
	 * @param {*} [callback_param] Parameter to pass to the manifold's callback
	 * (e.g. some state).
	 */
	exports.create_sensor_manifold = function(obj, id, type, sensors,
	                                          logic_fun, callback, callback_param) {

	    callback_param = callback_param === undefined? null: callback_param;
	    logic_fun = logic_fun || m_ctl.default_AND_logic_fun;

	    m_ctl.create_sensor_manifold(obj, id, type, sensors, logic_fun, callback,
	                                 callback_param);
	};

	/**
	 * Convenience function: creates a manifold coupled with a single keyboard
	 * sensor. Can be used to quickly create a single-key functionality.
	 * @method module:controls.create_kb_sensor_manifold
	 * @param {?Object3D} obj Object 3D to attach the manifold to, or null to denote
	 * the global object
	 * @param {string} id New manifold ID
	 * @param {number} type Manifold control type (CT_SHOT, CT_TRIGGER etc)
	 * @param {number} key Sensor key KEY_*
	 * @param {ManifoldCallback} callback Manifold's callback
	 * @param {*} [callback_param] Parameter to pass to the manifold's callback
	 * (e.g. some state)
	 */
	exports.create_kb_sensor_manifold = function(obj, id, type, key,
	        callback, callback_param) {
	    var kb_sensor = m_ctl.create_keyboard_sensor(key);

	    callback_param = callback_param === undefined? null: callback_param;
	    var logic_fun = m_ctl.default_AND_logic_fun;

	    m_ctl.create_sensor_manifold(obj, id, type, [kb_sensor], logic_fun,
	                                 callback, callback_param);
	};

	/**
	 * Check whether the object has any manifolds attached.
	 * @method module:controls.check_sensor_manifolds
	 * @param {?Object3D} obj Object 3D, or null to denote the global object
	 * @returns {boolean} Result of the check
	 */
	exports.check_sensor_manifolds = function(obj) {
	    return m_ctl.check_sensor_manifold(obj, null);
	};

	/**
	 * Check whether the object has the manifold attached.
	 * @method module:controls.check_sensor_manifold
	 * @param {?Object3D} obj Object 3D, or null to denote the global object
	 * @param {string} id Manifold ID
	 * @returns {boolean} Result of the check
	 */
	exports.check_sensor_manifold = m_ctl.check_sensor_manifold;

	/**
	 * Remove the sensor manifold registered for the object.
	 * @method module:controls.remove_sensor_manifold
	 * @param {?Object3D} obj Object 3D to delete the manifold from, or null to denote
	 * the global object
	 * @param {string} [id=null] ID of the sensor manifold, or null to delete all
	 * manifolds
	 */
	exports.remove_sensor_manifold = m_ctl.remove_sensor_manifold;

	/**
	 * Reset controls for all the objects.
	 * Calling this method is discouraged, use remove_sensor_manifold() instead.
	 * @method module:controls.reset
	 */
	exports.reset = m_ctl.reset;

	/**
	 * Set smooth factor for mouse pointerlock sensor.
	 * @method module:controls.set_plock_smooth_factor
	 * @param {number} value Set 
	 */
	exports.set_plock_smooth_factor = m_ctl.set_plock_smooth_factor;

	}

	var controls_factory = register("controls", Controls);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Data API. Used to load/unload exported JSON data files.
	 * @module data
	 * @local StageloadCallback
	 * @local LoadedCallback
	 */
	function Data(ns, exports) {

	/**
	 * Data loaded callback.
	 * Executed when the data loading process has been completed.
	 * @callback LoadedCallback
	 * @param {number} data_id Data ID
	 * @param {boolean} success Load success
	 */

	/**
	 * Loading stage callback.
	 * Used to implement loading progress indicators (preloaders).
	 * @callback StageloadCallback
	 * @param {number} percentage Loading progress (0-100).
	 * @param {number} load_time Loading time in ms.
	 * @param {number} data_id Data ID
	 */

	var m_data   = int_data_factory(ns);
	var m_loader = int_loader_factory(ns);

	/**
	 * Load data from the json file exported from Blender.
	 * @method module:data.load
	 * @param {string} path Path to JSON file
	 * @param {LoadedCallback} [loaded_cb=null] Callback to be executed right after load
	 * @param {StageloadCallback} [stageload_cb=null] Callback to report about the loading progress
	 * @param {boolean} [wait_complete_loading=false] Wait until all resources are loaded
	 * @param {boolean} [load_hidden=false] Hide loaded and disable physics objects
	 * @returns {number} ID of loaded data.
	 */
	exports.load = m_data.load;

	/**
	 * Unload the previously loaded data.
	 * @method module:data.unload
	 * @param {number} [data_id=0] ID of unloaded data. Unload all data if data_id is zero.
	 */
	exports.unload = function(data_id) {
	    data_id = data_id | 0;
	    m_data.unload(data_id);
	};


	/**
	 * Set the root which contains the resources, for debug purposes. 
	 * Enables the checking of loading paths, so if the resources are not loaded from 
	 * the app root, there will be a warning in m_print.
	 * @method module:data.set_debug_resources_root
	 * @param {string} debug_resources_root App root directory.
	 */
	exports.set_debug_resources_root = m_data.set_debug_resources_root;

	/**
	 * Check if the engine primary data (main scene) is loaded (detect the last loading stage).
	 * @method module:data.is_primary_loaded
	 * @returns {boolean} Check result
	 */
	exports.is_primary_loaded = m_data.is_primary_loaded;

	/**
	 * Check if the engine has finished all of the scheduled loading actions.
	 * @method module:data.is_idle
	 * @returns {boolean} Check result
	 */
	exports.is_idle = m_loader.is_finished;

	exports.load_and_add_new = m_data.load;

	exports.cleanup = exports.unload;
	/**
	 * Activate media data context.
	 * Activation of audio/video contexts is required for mobile platforms which
	 * disable media playback without explicit user interaction. This method
	 * should be executed inside some input event listener.
	 * @method module:data.activate_media
	 */
	exports.activate_media = m_data.activate_media;
	/**
	 * Preload scene's resources and put them into cache.
	 * @param {string} path Path to JSON file
	 * @param {LoadedCallback} [loaded_cb=null] Callback to be executed right after load
	 * @param {StageloadCallback} [stageload_cb=null] Callback to report about the loading progress
	 * @method module:data.prefetch
	 */
	exports.prefetch = m_data.prefetch;
	/**
	 * Clear loading cache.
	 * @method module:data.unfetch
	 */
	exports.unfetch = m_data.unfetch;

	}

	var data_factory = register("data", Data);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Engine debugging API.
	 * @module debug
	 * @local DebugViewMode
	 * @local StageloadCallback
	 * @local LoadedCallback
	 * @local CodeTestCallback
	 * @local EqualsFunction
	 * @local OKFunction
	 */
	function Debug(ns, exports) {

	var m_batch    = int_batch_factory(ns);
	var m_cfg      = int_config_factory(ns);
	var m_compat   = int_compat_factory(ns);
	var m_ctl      = int_controls_factory(ns);
	var m_cont     = int_container_factory(ns);
	var m_data     = int_data_factory(ns);
	var m_debug    = int_debug_factory(ns);
	var m_ext      = int_extensions_factory(ns);
	var m_geom     = int_geometry_factory(ns);
	var m_load     = int_loader_factory(ns);
	var m_obj      = int_objects_factory(ns);
	var m_obj_util = int_obj_util_factory(ns);
	var m_phy      = int_physics_factory(ns);
	var m_print    = print_factory(ns);
	var m_render   = int_renderer_factory(ns);
	var m_scenes   = int_scenes_factory(ns);
	var m_scgraph  = int_scenegraph_factory(ns);
	var m_sfx      = int_sfx_factory(ns);
	var m_shaders  = int_shaders_factory(ns);
	var m_subs     = int_subscene_factory(ns);
	var m_textures = int_textures_factory(ns);
	var m_trans    = int_transform_factory(ns);
	var m_tsr      = int_tsr_factory(ns);
	var m_util     = int_util_factory(ns);
	var m_vec3     = vec3_factory(ns);

	var _tsr_tmp = m_tsr.create();
	var _vec2_tmp = new Float32Array(2);
	var _vec3_tmp = m_vec3.create();
	var _vec3_tmp2 = m_vec3.create();

	var _normal_line = null;

	var cfg_def = m_cfg.defaults;

	var PERF_NUM_CALLS = 5;
	var EPS = 0.000001;

	var _called_funcs = [];
	var _last_warn_message = "";
	var _last_err_message = "";
	var _warn_got = false;
	var _err_got = false;
	var _test_result = true;

	var _pixel = new Uint8Array(4);

	/**
	 * Debug view mode.
	 * @typedef {number} DebugViewMode
	 */

	 /**
	 * Data loaded callback.
	 * @callback LoadedCallback
	 */

	/**
	 * Loading stage callback.
	 * @callback StageloadCallback
	 * @param {number} percentage Loading progress (0-100).
	 */

	/**
	 * Code test callback.
	 * @callback CodeTestCallback
	 * @param {EqualsFunction} equals Comparison function.
	 * @param {OKFunction} ok Code test function.
	 */

	/**
	 * Return the comparison result of the given parameters.
	 * @callback EqualsFunction
	 * @param {*} result Real function result.
	 * @param {*} exp_result Expected result.
	 */

	 /**
	 * Check code crash.
	 * @callback OKFunction
	 * @param {*} result Real function result.
	 */


	/**
	 * Debug view mode: turn off debug view.
	 * @const {DebugViewMode} module:debug.DV_NONE
	 */
	exports.DV_NONE = m_debug.DV_NONE;

	/**
	 * Debug view mode: turn on the black-and-white wireframe view.
	 * @const {DebugViewMode} module:debug.DV_OPAQUE_WIREFRAME
	 */
	exports.DV_OPAQUE_WIREFRAME = m_debug.DV_OPAQUE_WIREFRAME;

	/**
	 * Debug view mode: turn on the transparent (superimposed on the source color) wireframe view.
	 * @const {DebugViewMode} module:debug.DV_TRANSPARENT_WIREFRAME
	 */
	exports.DV_TRANSPARENT_WIREFRAME = m_debug.DV_TRANSPARENT_WIREFRAME;

	/**
	 * Debug view mode: turn on the wireframe view with the front/back faces coloration.
	 * @const {DebugViewMode} module:debug.DV_FRONT_BACK_VIEW
	 */
	exports.DV_FRONT_BACK_VIEW = m_debug.DV_FRONT_BACK_VIEW;

	/**
	 * Debug view mode: turn on the debug spheres view.
	 * @const {DebugViewMode} module:debug.DV_BOUNDINGS
	 */
	exports.DV_BOUNDINGS = m_debug.DV_BOUNDINGS;

	/**
	 * Debug view mode: turn on the clusters view.
	 * @const {DebugViewMode} module:debug.DV_CLUSTERS_VIEW
	 */
	exports.DV_CLUSTERS_VIEW = m_debug.DV_CLUSTERS_VIEW;

	/**
	 * Debug view mode: turn on the batches view.
	 * @const {DebugViewMode} module:debug.DV_BATCHES_VIEW
	 */
	exports.DV_BATCHES_VIEW = m_debug.DV_BATCHES_VIEW;

	/**
	 * Debug view mode: turn on the render time view.
	 * @const {DebugViewMode} module:debug.DV_RENDER_TIME
	 */
	exports.DV_RENDER_TIME = m_debug.DV_RENDER_TIME;

	/**
	 * Print info about the physics worker.
	 * @method module:debug.physics_stats
	 */
	exports.physics_stats = function() {
	    m_phy.debug_workers();
	};

	/**
	 * Print object info by physics ID.
	 * @method module:debug.physics_id
	 * @param {number} id Physics ID
	 */
	exports.physics_id = function(id) {
	    m_print.log("O", m_phy.find_obj_by_body_id(id));

	    var act_phy_scene = m_phy.get_active_scene();

	    if (!act_phy_scene) {
	        m_print.error("No active physics scene.");
	        return;
	    }

	    var bundles = act_phy_scene._physics.bundles;

	    for (var i = 0; i < bundles.length; i++) {
	        var bundle = bundles[i];
	        var phy = bundle.physics;

	        if (phy.body_id == id)
	            m_print.log("B", bundle);
	    }
	};

	/**
	 * Print names and info for objects inside the view frustum.
	 * @method module:debug.visible_objects
	 */
	exports.visible_objects = function() {
	    var scene = m_scenes.get_active();

	    var objs = m_obj.get_scene_objs(scene, "MESH", m_obj.DATA_ID_ALL);

	    var main_subscenes = m_scenes.subs_array(scene, [m_subs.MAIN_OPAQUE,
	                                                     m_subs.MAIN_BLEND,
	                                                     m_subs.MAIN_GLOW]);

	    for (var i = 0; i < main_subscenes.length; i++) {
	        var subs_main = main_subscenes[i];
	        var draw_data = subs_main.draw_data;

	        if (!draw_data.length)
	            continue;

	        print_objs(subs_main, draw_data, objs, "DYNAMIC");
	        print_objs(subs_main, draw_data, objs, "STATIC");
	    }
	};

	function print_objs(subs, draw_data, objs, type) {

	    m_print.group(m_subs.subs_label(subs), type);

	    for (var j = 0; j < objs.length; j++) {
	        var obj = objs[j];
	        var render = obj.render;

	        if (render.type != type)
	            continue;

	        var is_visible = false;

	        for (var k = 0; k < draw_data.length; k++) {
	            var bundles = draw_data[k].bundles;
	            for (var m = 0; m < bundles.length; m++) {
	                var bundle = bundles[m];
	                if (bundle.do_render && bundle.obj_render == render) {
	                    if (type == "STATIC")
	                        m_print.log_raw(obj.origin_name, obj);
	                    else
	                        m_print.log_raw(obj.name, obj);
	                    is_visible = true;
	                    break;
	                }
	            }
	            if (is_visible)
	                break;
	        }
	    }

	    m_print.groupEnd();
	}

	/**
	 * Print debug info for the object with the given name
	 * @method module:debug.object_info
	 * @param {string} name Object name
	 */
	exports.object_info = function(name) {
	    var scene = m_scenes.get_active();

	    var objs = m_obj.get_scene_objs(scene, "MESH", m_obj.DATA_ID_ALL);

	    for (var i = 0; i < objs.length; i++) {
	        var obj = objs[i];

	        if (obj.name != name)
	            continue;

	        m_print.log("Object", obj);

	        var subscenes = m_scenes.get_all_subscenes(scene);

	        for (var j = 0; j < subscenes.length; j++) {
	            var subs = subscenes[j];
	            var print_bundles = [];

	            var draw_data = subs.draw_data;

	            for (var k = 0; k < draw_data.length; k++) {
	                var bundles = draw_data[k].bundles;
	                for (var m = 0; m < bundles.length; m++) {
	                    if (bundles[m].obj_render == obj.render)
	                        print_bundles.push(bundles[m]);
	                }
	            }

	            m_print.log("Subscene " + subs.type, print_bundles);
	        }
	    }
	};

	/**
	 * Print debug info for the object with the given name
	 * @method module:debug.objects_stat
	 */
	exports.objects_stat = function() {
	    var scene = m_scenes.get_active();

	    m_print.log("Armatures: " + m_obj.get_scene_objs(scene, "ARMATURE",
	            m_obj.DATA_ID_ALL).length);
	    m_print.log("Cameras: " + m_obj.get_scene_objs(scene, "CAMERA",
	            m_obj.DATA_ID_ALL).length);
	    m_print.log("Curves: " + m_obj.get_scene_objs(scene, "CURVE",
	            m_obj.DATA_ID_ALL).length);
	    m_print.log("Empties: " + m_obj.get_scene_objs(scene, "EMPTY",
	            m_obj.DATA_ID_ALL).length);
	    m_print.log("Lamps: " + m_obj.get_scene_objs(scene, "LAMP",
	            m_obj.DATA_ID_ALL).length);
	    m_print.log("Meshes: " + m_obj.get_scene_objs(scene, "MESH",
	            m_obj.DATA_ID_ALL).length);
	    m_print.log("Speakers: " + m_obj.get_scene_objs(scene, "SPEAKER",
	            m_obj.DATA_ID_ALL).length);
	};

	/**
	 * Return the number of vertices in the active scene.
	 * @method module:debug.num_vertices
	 * @returns {number} The number of vertices.
	 */
	exports.num_vertices = function() {

	    var num = 0;

	    var scene = m_scenes.get_active();

	    var main_subscenes = m_scenes.subs_array(scene, [m_subs.MAIN_OPAQUE,
	                                                     m_subs.MAIN_BLEND,
	                                                     m_subs.MAIN_GLOW]);

	    for (var i = 0; i < main_subscenes.length; i++) {

	        var subs = main_subscenes[i];

	        var draw_data = subs.draw_data;

	        for (var j = 0; j < draw_data.length; j++) {
	            var bundles = draw_data[j].bundles;
	            for (var k = 0; k < bundles.length; k++) {

	                var batch = bundles[k].batch;
	                // NOTE: some objects (particles) do not have any submesh
	                if (batch)
	                    num += batch.num_vertices;
	            }
	        }
	    }

	    return num;
	};

	/**
	 * Return the number of all triangles in the active scene.
	 * @method module:debug.num_triangles
	 * @returns {number} The number of all triangles.
	 */
	exports.num_triangles = function() {

	    var num = 0;

	    var scene = m_scenes.get_active();

	    var main_subscenes = m_scenes.subs_array(scene, [m_subs.MAIN_OPAQUE,
	                                                     m_subs.MAIN_BLEND,
	                                                     m_subs.MAIN_GLOW]);

	    for (var i = 0; i < main_subscenes.length; i++) {

	        var subs = main_subscenes[i];

	        var draw_data = subs.draw_data;

	        for (var j = 0; j < draw_data.length; j++) {
	            var bundles = draw_data[j].bundles;
	            for (var k = 0; k < bundles.length; k++) {

	                var batch = bundles[k].batch;
	                // NOTE: some objects (particles) do not have any submesh
	                if (batch)
	                    num += batch.num_triangles;
	            }
	        }
	    }

	    return num;
	};

	/**
	 * Return the number of batches in the main scenes.
	 * @method module:debug.num_draw_calls
	 * @returns {number} The number of batches.
	 */
	exports.num_draw_calls = function() {

	    var scene = m_scenes.get_active();

	    var main_subscenes = m_scenes.subs_array(scene, [m_subs.MAIN_OPAQUE,
	                                                     m_subs.MAIN_BLEND,
	                                                     m_subs.MAIN_GLOW,
	                                                     m_subs.MAIN_PLANE_REFLECT,
	                                                     m_subs.MAIN_PLANE_REFLECT_BLEND]);

	    var number = 0;
	    for (var i = 0; i < main_subscenes.length; i++) {
	        var subs = main_subscenes[i];
	        var draw_data = subs.draw_data;
	        for (var j = 0; j < draw_data.length; j++)
	            number += draw_data[j].bundles.length;
	    }

	    var cube_reflect_subs = m_scenes.subs_array(scene,
	                            [m_subs.MAIN_CUBE_REFLECT, m_subs.MAIN_CUBE_REFLECT_BLEND]);
	    for (var i = 0; i < cube_reflect_subs.length; i++) {
	        var subs = cube_reflect_subs[i];
	        var draw_data = subs.draw_data;
	        for (var j = 0; j < draw_data.length; j++)
	            number += 6 * draw_data[j].bundles.length;
	    }

	    return number;
	};

	/**
	 * Return the number of compiled shaders.
	 * @method module:debug.num_shaders
	 * @returns {number} The number of compiled shaders.
	 */
	exports.num_shaders = function() {
	    var compiled_shaders = m_shaders.get_compiled_shaders();
	    return m_util.get_dict_length(compiled_shaders);
	};

	/**
	 * Return geometry info in the main scenes.
	 * @method module:debug.geometry_stats
	 * @returns {Object} Geometry info.
	 */
	exports.geometry_stats = function() {

	    var scene = m_scenes.get_active();
	    var subscenes = m_scenes.get_all_subscenes(scene);
	    var unique_batches = {};

	    for (var i = 0; i < subscenes.length; i++) {

	        var subs = subscenes[i];

	        if (subs.type == m_subs.SINK || subs.type == m_subs.DEBUG_VIEW)
	            continue;

	        var draw_data = subs.draw_data;
	        for (var j = 0; j < draw_data.length; j++) {
	            var bundles = draw_data[j].bundles;
	            for (var k = 0; k < bundles.length; k++) {
	                var batch = bundles[k].batch;
	                var render = bundles[k].obj_render;
	                // NOTE: some objects (particles) do not have any submesh
	                if (batch)
	                    if (subs.type != m_subs.COLOR_PICKING && subs.type != m_subs.OUTLINE_MASK
	                            || render.origin_selectable || render.origin_outlining)
	                        unique_batches[batch.id] = batch;
	            }
	        }
	    }

	    var vbo_memory = 0;
	    var ibo_memory = 0;

	    for (var id in unique_batches) {
	        var bufs_data = unique_batches[id].bufs_data;

	        if (bufs_data.debug_ibo_bytes)
	            ibo_memory += bufs_data.debug_ibo_bytes / (1024 * 1024);

	        vbo_memory += bufs_data.debug_vbo_bytes / (1024 * 1024);
	    }

	    return {"vbo_memory": vbo_memory, "ibo_memory": ibo_memory};
	};

	/**
	 * Return the number of unique textures in the main scenes.
	 * @method module:debug.num_textures
	 * @returns {Object} Textures info.
	 */
	exports.num_textures = function() {

	    var tex_list = [];

	    var memory = 0;

	    var scene = m_scenes.get_active();

	    var main_subscenes = m_scenes.subs_array(scene, [m_subs.MAIN_OPAQUE,
	                                                     m_subs.MAIN_BLEND,
	                                                     m_subs.MAIN_GLOW]);

	    for (var i = 0; i < main_subscenes.length; i++) {

	        var subs = main_subscenes[i];

	        var draw_data = subs.draw_data;
	        for (var j = 0; j < draw_data.length; j++) {
	            var bundles = draw_data[j].bundles;
	            for (var k = 0; k < bundles.length; k++) {

	                var batch = bundles[k].batch;
	                // NOTE: some objects (particles) do not have any submesh
	                if (batch) {
	                    var batch_texs = batch.textures;

	                    for (var m = 0; m < batch_texs.length; m++) {

	                        var batch_tex = batch_texs[m];

	                        if (batch_tex.source === "IMAGE" ||
	                                batch_tex.source === "ENVIRONMENT_MAP") {

	                            var tex = batch_tex.w_texture;

	                            if (tex_list.indexOf(tex) === -1) {
	                                tex_list.push(tex);
	                                var mem = batch_tex.width * batch_tex.height *
	                                    4 / (1024 * 1024) / batch_tex.compress_ratio;

	                                // mipmaps
	                                mem *=  1.3333;

	                                memory += mem;
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }

	    return {"number": tex_list.length, "memory": memory};
	};

	/**
	 * Return the number and the total size of unique output framebuffers.
	 * @method module:debug.num_render_targets
	 * @returns {Object} Render targets info.
	 */
	exports.num_render_targets = function() {

	    var list = [];

	    var memory = 0;

	    var scene = m_scenes.get_active();

	    var subscenes = m_scenes.get_all_subscenes(scene);

	    for (var i = 0; i < subscenes.length; i++) {

	        var subs = subscenes[i];

	        if (subs.type == m_subs.SINK)
	            continue;

	        var cam = subs.camera;
	        var subs_textures = [cam.color_attachment, cam.depth_attachment];
	        subs_textures.push.apply(subs_textures, subs.textures_internal);

	        for (var j = 0; j < subs_textures.length; j++) {
	            var tex = subs_textures[j];
	            if (m_textures.is_texture(tex) && list.indexOf(tex) == -1) {
	                list.push(tex);
	                memory += cam.width * cam.height * m_textures.get_texture_texel_size(tex);
	            }
	        }
	    }

	    return {"number": list.length, "memory": (memory / 1024 / 1024)};
	};

	/**
	 * Draw a frustum for the active camera.
	 * @method module:debug.make_camera_frustum_shot
	 */
	exports.make_camera_frustum_shot = function() {

	    var active_scene = m_scenes.get_active();
	    var subs_main = m_scenes.get_subs(active_scene, m_subs.MAIN_OPAQUE);
	    if (!subs_main)
	        return;

	    m_scenes.make_frustum_shot(subs_main.camera, subs_main, [1,1,0]);
	};

	/**
	 * Draw a light frustum, used for rendering the shadow maps.
	 * @method module:debug.make_light_frustum_shot
	 */
	exports.make_light_frustum_shot = function() {

	    var active_scene = m_scenes.get_active();
	    var subs_main = m_scenes.get_subs(active_scene, m_subs.MAIN_OPAQUE);
	    var subscenes_shadow = m_scenes.subs_array(active_scene, [m_subs.SHADOW_CAST]);
	    if (!subs_main)
	        return;

	    for (var i = 0; i < subscenes_shadow.length; i++) {
	        var subs_shadow = subscenes_shadow[i];

	        var color;
	        switch (i) {
	        case 0:
	            color = [1, 0, 0];
	            break;
	        case 1:
	            color = [0, 1, 0];
	            break;
	        case 2:
	            color = [0, 0, 1];
	            break;
	        default:
	            color = [1, 0, 1];
	        }

	        m_scenes.make_frustum_shot(subs_shadow.camera, subs_main, color);
	    }
	};


	/**
	 * Print info about the active scene graph in DOT format.
	 * @method module:debug.scenegraph_to_dot
	 */
	exports.scenegraph_to_dot = function() {
	    var scenes = m_scenes.get_all_scenes();

	    for (var i = 0; i < scenes.length; i++) {
	        var scene = scenes[i];
	        var graph = m_scenes.get_graph(scene);
	        m_print.log("\n" + m_scgraph.debug_convert_to_dot(graph));
	    }
	};

	exports.loading_graph_to_dot = function(data_id) {
	    data_id = data_id | 0;
	    m_print.log("\n" + m_load.graph_to_dot(data_id));
	};

	/**
	 * Print info about the controls module.
	 * @method module:debug.controls_info
	 */
	exports.controls_info = m_ctl.debug;

	/**
	 * Get the distance between two objects.
	 * @method module:debug.object_distance
	 * @param {Object3D} obj The first object.
	 * @param {Object3D} obj2 The second object.
	 * @returns {number} Distance.
	 * @deprecated use {@link module:transform.distance|transform.distance} instead.
	 */
	exports.object_distance = function(obj, obj2) {
	    var trans = m_tsr.get_trans_view(obj.render.world_tsr);
	    var trans2 = m_tsr.get_trans_view(obj2.render.world_tsr);
	    var dist = m_vec3.dist(trans, trans2);
	    return dist;
	};

	/**
	 * Store a simple telemetry message.
	 * @method module:debug.msg
	 */
	exports.msg = m_debug.msg;

	/**
	 * Store a flashback telemetry message.
	 * @method module:debug.fbmsg
	 */
	exports.fbmsg = m_debug.fbmsg;

	/**
	 * Print the list of flashback messages.
	 * @method module:debug.print_telemetry
	 */
	exports.print_telemetry = m_debug.print_telemetry;

	/**
	 * Plot the list of flashback messages as a gnuplot datafile.
	 * @method module:debug.plot_telemetry
	 */
	exports.plot_telemetry = m_debug.plot_telemetry;

	/**
	 * Store the callback function result as a flashback message.
	 * @method module:debug.fbres
	 * @param {Function} fun fun
	 * @param {number} timeout timeout
	 */
	exports.fbres = function(fun, timeout) {
	    if (!timeout)
	        timeout = 16;

	    var cb = function() {
	        m_debug.fbmsg("FBRES", fun());
	        setTimeout(cb, timeout);
	    };

	    cb();
	};

	/**
	 * Check the engine constants, abort if not constant.
	 * @method module:debug.assert_constants
	 */
	exports.assert_constants = function() {
	    var VEC3_IDENT = new Float32Array(3);
	    var QUAT4_IDENT = new Float32Array([0,0,0,1]);

	    var AXIS_X = new Float32Array([1, 0, 0]);
	    var AXIS_Y = new Float32Array([0, 1, 0]);
	    var AXIS_Z = new Float32Array([0, 0, 1]);
	    var AXIS_MX = new Float32Array([-1, 0, 0]);
	    var AXIS_MY = new Float32Array([ 0,-1, 0]);
	    var AXIS_MZ = new Float32Array([ 0, 0,-1]);

	    if (!m_util.cmp_arr(VEC3_IDENT, m_util.VEC3_IDENT))
	        throw "Wrong VEC3_IDENT";
	    if (!m_util.cmp_arr(QUAT4_IDENT, m_util.QUAT4_IDENT))
	        throw "Wrong QUAT4_IDENT";

	    if (!m_util.cmp_arr(AXIS_X, m_util.AXIS_X))
	        throw "Wrong AXIS_X";
	    if (!m_util.cmp_arr(AXIS_Y, m_util.AXIS_Y))
	        throw "Wrong AXIS_Y";
	    if (!m_util.cmp_arr(AXIS_Z, m_util.AXIS_Z))
	        throw "Wrong AXIS_Z";
	    if (!m_util.cmp_arr(AXIS_MX, m_util.AXIS_MX))
	        throw "Wrong AXIS_MX";
	    if (!m_util.cmp_arr(AXIS_MY, m_util.AXIS_MY))
	        throw "Wrong AXIS_MY";
	    if (!m_util.cmp_arr(AXIS_MZ, m_util.AXIS_MZ))
	        throw "Wrong AXIS_MZ";
	};

	/**
	 * Mute the BACKGROUND_MUSIC speakers.
	 * @method module:debug.mute_music
	 */
	exports.mute_music = function() {
	    var spks = m_sfx.get_speaker_objects();

	    for (var i = 0; i < spks.length; i++) {
	        var spk = spks[i];

	        if (m_sfx.get_spk_behavior(spk) == "BACKGROUND_MUSIC")
	            m_sfx.mute(spk, true);
	    }
	};

	/**
	 * Check the object for a finite value.
	 * @method module:debug.check_finite
	 * @param {*} o Value
	 */
	exports.check_finite = m_debug.check_finite;

	/**
	 * Set debugging parameters.
	 * @method module:debug.set_debug_params
	 * @param {DebugParams} params Debug parameters
	 * @cc_externs debug_view_mode wireframe_edge_color debug_colors_seed
	 */
	exports.set_debug_params = function(params) {
	    var active_scene = m_scenes.get_active();
	    var subs_debug_views = m_scenes.subs_array(active_scene, [m_subs.DEBUG_VIEW]);

	    if (!subs_debug_views.length) {
	        m_print.error("Debugging is not available on the scene.");
	        return;
	    }

	    for (var i = 0; i < subs_debug_views.length; i++) {
	        var subs_debug_view = subs_debug_views[i];
	        if (typeof params.debug_view_mode == "number") {
	            switch (params.debug_view_mode) {
	            case m_debug.DV_NONE:
	            case m_debug.DV_OPAQUE_WIREFRAME:
	            case m_debug.DV_TRANSPARENT_WIREFRAME:
	            case m_debug.DV_FRONT_BACK_VIEW:
	            case m_debug.DV_BOUNDINGS:
	            case m_debug.DV_CLUSTERS_VIEW:
	            case m_debug.DV_BATCHES_VIEW:
	            case m_debug.DV_RENDER_TIME:
	                m_scenes.set_debug_view_mode(subs_debug_view, params.debug_view_mode);
	                break;
	            default:
	                m_print.error("set_debug_params(): Wrong debug view mode");
	                break;
	            }
	        }
	        if (typeof params.debug_colors_seed == "number")
	            m_scenes.set_debug_colors_seed(subs_debug_view, params.debug_colors_seed);
	        if (typeof params.render_time_threshold == "number")
	            m_scenes.set_render_time_threshold(subs_debug_view, params.render_time_threshold);
	        if (typeof params.wireframe_edge_color == "object")
	            m_scenes.set_wireframe_edge_color(subs_debug_view,
	                    m_util.f32(params.wireframe_edge_color));
	    }
	};

	exports.get_error_quantity = function() {
	    return m_print.get_error_count();
	};

	exports.get_warning_quantity = function() {
	    return m_print.get_warning_count();
	};

	exports.clear_errors_warnings = function() {
	    return m_print.clear_errors_warnings();
	};

	/**
	 * Print shaders' statistics.
	 * @method module:debug.analyze_shaders
	 * @param {string} [opt_shader_id_part=""] Shader ID (filename) part.
	 */
	exports.analyze_shaders = function(opt_shader_id_part) {

	    var compiled_shaders = m_shaders.get_compiled_shaders();

	    var count = 0;
	    for (var shader_id in compiled_shaders) {
	        if (opt_shader_id_part && shader_id.indexOf(opt_shader_id_part) === -1)
	            continue;
	        count++;
	    }
	    var msg = "of " + count + " analyzing...";

	    var rslts = {};

	    for (var shader_id in compiled_shaders) {

	        if (opt_shader_id_part && shader_id.indexOf(opt_shader_id_part) === -1)
	            continue;

	        var cshader = compiled_shaders[shader_id];
	        var stat = get_shaders_stat(cshader.vshader, cshader.fshader);
	        if (!stat)
	            continue;

	        var shaders_info = cshader.shaders_info;
	        var title = shaders_info.vert + " + " + shaders_info.frag;

	        // NOTE: cshader.shaders_info
	        stat.cshader = cshader;
	        stat.shaders_info = shaders_info;

	        var stats = rslts[title] = rslts[title] || [];

	        stats.push(stat);
	        m_print.log_raw(msg);
	    }

	    for (var title in rslts) {

	        m_print.group("%c" + title, "color: #800");
	        var stats = rslts[title];
	        print_shader_stats(stats);
	        m_print.groupEnd();
	    }
	};

	/**
	 * Return stage callback without loading data.
	 * @method module:debug.fake_load
	 * @param {StageloadCallback} stageload_cb Callback to report about the loading progress
	 * @param {number} [interval=5000] Loading interval
	 * @param {number} [start=0] Start percentage
	 * @param {number} [end=5000] End percentage
	 * @param {LoadedCallback} [loaded_cb=null] Callback to be executed right after load
	 */
	exports.fake_load = m_debug.fake_load;

	function get_shaders_stat(vshader, fshader) {

	    var ext_ds = m_ext.get_debug_shaders();
	    if (!ext_ds) {
	        m_print.warn("WEBGL_debug_shaders extension not found");
	        return;
	    }

	    var vsrc_trans = ext_ds.getTranslatedShaderSource(vshader);
	    var fsrc_trans = ext_ds.getTranslatedShaderSource(fshader);

	    if (m_compat.detect_mobile()) {
	        vsrc_trans = vsrc_trans.replace("#version", "#version 300 //");
	        fsrc_trans = fsrc_trans.replace("#version", "#version 300 //");
	        var vout = post_sync("/analyze_shader/vert_gles", vsrc_trans);
	        var fout = post_sync("/analyze_shader/frag_gles", fsrc_trans);
	    } else {
	        // HACK: lower GLSL version for cgc tool
	        vsrc_trans = vsrc_trans.replace("#version", "#version 400 //");
	        fsrc_trans = fsrc_trans.replace("#version", "#version 400 //");
	        var vout = post_sync("/analyze_shader/vert", vsrc_trans);
	        var fout = post_sync("/analyze_shader/frag", fsrc_trans);
	    }

	    var vstats = parse_shader_assembly(vout);
	    var fstats = parse_shader_assembly(fout);

	    return {
	        vsrc: m_debug.get_gl().getShaderSource(vshader),
	        vsrc_trans: vsrc_trans,
	        vout: vout,
	        vstats: vstats,
	        fsrc: m_debug.get_gl().getShaderSource(fshader),
	        fsrc_trans: fsrc_trans,
	        fout: fout,
	        fstats: fstats
	    };
	}

	function parse_shader_assembly(data) {
	    var stats = {};

	    if (!data)
	        return stats;

	    var lines = data.split("\n");

	    for (var i = 0; i < lines.length; i++) {
	        var line = lines[i];

	        if (line.search(new RegExp(/^[A-Z.]+ ?/)) == -1) {
	            continue;
	        }

	        var op = line.split(" ")[0];

	        if (!(op in stats))
	            stats[op] = 0;

	        stats[op]++;
	    }

	    var all_ops = 0;
	    var tex_ops = 0;
	    var attribs = 0;

	    for (var op in stats) {
	        switch (op) {
	        case "KIL":
	        case "TEX":
	        case "TXB":
	        case "TXP":
	        case "KIL.F":
	        case "TEX.F":
	        case "TXB.F":
	        case "TXD.F":
	        case "TXL.F":
	        case "TXQ.F":
	        case "TXP.F":
	            tex_ops += stats[op];
	            all_ops += stats[op];
	            break;
	        // data type qualifiers
	        case "ATTRIB":
	            attribs += stats[op];
	            break;
	        case "ADDRESS":
	        case "PARAM":
	        case "TEMP":
	        case "ALIAS":
	        case "OUTPUT":
	            break;
	        // end program line
	        case "END":
	            break;
	        default:
	            all_ops += stats[op];
	            break;
	        }
	    }

	    stats["ALL_OPS"] = all_ops;
	    stats["TEX_OPS"] = tex_ops;
	    stats["ATTRIBS"] = attribs;

	    return stats;
	}

	function post_sync(path, data) {
	    var req = new XMLHttpRequest();
	    req.open("POST", path, false);
	    req.send(data);

	    if (req.status == 200)
	        return req.responseText;
	    else {
	        m_print.error(req.responseText);
	        throw("Error POST XHR: " + req.status);
	    }
	}

	function print_shader_stats(stats) {
	    // sort in descending order by fragment shader operations
	    stats.sort(function(a, b) {
	        return b.fstats["ALL_OPS"] - a.fstats["ALL_OPS"];
	    });

	    for (var j = 0; j < stats.length; j++) {
	        var stat = stats[j];

	        var fstats = stat.fstats;
	        var vstats = stat.vstats;

	        var mat_names = find_material_names_by_comp_shader(stat.cshader);
	        mat_names = mat_names.length ? "\t\t(" + mat_names.join(", ") + ")" : "\t\t(NA)";

	        // NOTE some not changing params are commented out
	        m_print.groupCollapsed(
	            "VERT ->",
	            "OPS", vstats["ALL_OPS"],
	            "ATT", vstats["ATTRIBS"],
	            "TEX", vstats["TEX_OPS"],

	            "\t\tFRAG ->",
	            "OPS", fstats["ALL_OPS"],
	            "TEX", fstats["TEX_OPS"],
	            mat_names
	        );

	        m_print.groupCollapsed("directives");
	        // NOTE: perhaps they should be stored in sorted order
	        var dirs = stat.shaders_info.directives.slice().sort();
	        for (var i = 0; i < dirs.length; i++) {
	            var dir = dirs[i];
	            m_print.log_raw(dir[0], dir[1]);
	        }
	        m_print.groupEnd();

	        m_print.groupCollapsed("node elements");
	        var nelem = stat.shaders_info.node_elements;
	        for (var i = 0; i < nelem.length; i++)
	            m_print.log_raw(nelem[i]);
	        m_print.groupEnd();

	        m_print.groupCollapsed("vert source");
	        m_print.log_raw(stat.vsrc);
	        m_print.groupEnd();

	        m_print.groupCollapsed("vert translated source");
	        m_print.log_raw(stat.vsrc_trans);
	        m_print.groupEnd();

	        // ignore them as they used for collective stats
	        var ignored_stats = ["ALL_OPS", "TEX_OPS", "ATTRIBS"];

	        m_print.groupCollapsed("vert ops stats");
	        for (var op in vstats)
	            if (ignored_stats.indexOf(op) == -1)
	                m_print.log_raw(op, vstats[op]);
	        m_print.groupEnd();

	        m_print.groupCollapsed("vert assembly");
	        m_print.log_raw(stat.vout);
	        m_print.groupEnd();

	        m_print.groupCollapsed("frag source");
	        m_print.log_raw(stat.fsrc);
	        m_print.groupEnd();

	        m_print.groupCollapsed("frag translated source");
	        m_print.log_raw(stat.fsrc_trans);
	        m_print.groupEnd();

	        m_print.groupCollapsed("frag ops stats");
	        for (var op in fstats)
	            if (ignored_stats.indexOf(op) == -1)
	                m_print.log_raw(op, fstats[op]);
	        m_print.groupEnd();

	        m_print.groupCollapsed("frag assembly");
	        m_print.log_raw(stat.fout);
	        m_print.groupEnd();

	        m_print.groupEnd();
	    }
	}

	function find_material_names_by_comp_shader(cshader) {

	    var names = [];

	    var scenes = m_scenes.get_all_scenes();

	    for (var i = 0; i < scenes.length; i++) {
	        var scene = scenes[i];
	        var objects = m_obj.get_scene_objs(scene, "MESH", m_obj.DATA_ID_ALL);

	        for (var j = 0; j < objects.length; j++) {
	            var obj = objects[j];
	            var scene_data = m_obj_util.get_scene_data(obj, scene);

	            if (!scene_data || !scene_data.batches.length)
	                continue;

	            var batches = scene_data.batches;

	            for (var k = 0; k < batches.length; k++) {
	                var batch = batches[k];

	                if (batch.shader == cshader)
	                    for (var l = 0; l < batch.material_names.length; l++) {
	                        var name = batch.material_names[l];
	                        if (names.indexOf(name) == -1)
	                            names.push(name);
	                    }
	            }
	        }
	    }

	    return names;
	}

	/**
	 * Perform simple performance test.
	 * @method module:debug.test_performance
	 * @param {TestPerformanceCallback} callback Callback
	 */
	exports.test_performance = function(callback) {
	    // waiting for shaders
	    if (!m_shaders.check_shaders_loaded()) {
	        window.setTimeout(function() {
	            exports.test_performance(callback);
	        }, 100);
	        return;
	    }

	    var ext = m_ext.get_disjoint_timer_query();
	    if (!ext) {
	        callback(0, 0);
	        return;
	    }

	    var gl_debug_save = cfg_def.gl_debug;
	    // enable it to force timer queries update for
	    // paused engine / unloaded scenes
	    cfg_def.gl_debug = true;

	    var graph = m_scgraph.create_performance_graph();
	    m_scenes.generate_auxiliary_batches(null, graph);

	    var subs = m_scgraph.find_subs(graph, m_subs.PERFORMANCE);
	    var cam = subs.camera;

	    for (var i = 0; i < PERF_NUM_CALLS; i++)
	        m_render.draw(subs);

	    cfg_def.gl_debug = gl_debug_save;

	    window.setTimeout(function() {
	        m_debug.process_timer_queries(subs);
	        // in ms
	        var time = subs.debug_render_time;
	        // in GB/s (100 texture lookups)
	        var bandwidth = (cam.width * cam.height * 4 * 10) /
	                (time / 1000) / Math.pow(10, 9);
	        callback(time, bandwidth);
	    }, 100);
	};

	exports.calc_vbo_garbage_byte_size = m_debug.calc_vbo_garbage_byte_size;

	exports.show_vbo_garbage_info = m_debug.show_vbo_garbage_info;

	exports.print_batches_stat = m_debug.print_batches_stat;

	function call(func, name) {
	    var decor_func = function() {
	        _called_funcs.push(decor_func);
	        return func.apply(func, arguments);

	    };
	    return decor_func;
	}

	exports.start_debug = function(module_name) {
	    _called_funcs = [];
	    _test_result = true;
	    var module = require(module_name);
	    for (var name in module)
	        if (typeof module[name] === "function")
	            module[name] = call(module[name], name);
	};

	exports.check_debug_result = function() {
	    return _test_result;
	};

	/**
	 * Test code.
	 * @method module:debug.test
	 * @param {string} test_name Test name
	 * @param {CodeTestCallback} callback Callback
	 */
	exports.test = function(test_name, callback) {

	    var print_err_func = m_print.error;
	    var print_err_once_func = m_print.error_once;
	    var print_warn_func = m_print.warn;

	    m_print.error = m_print.error_once = function error() {
	        var args = m_print.compose_args_prefix(arguments, "B4W ERROR");
	        _last_err_message = args.join(" ");
	        _err_got = true;
	    };

	    m_print.warn = function warn() {
	        var args = m_print.compose_args_prefix(arguments, "B4W WARN");
	        _last_warn_message = args.join(" ");
	        _warn_got = true;
	    };

	    _warn_got = false;
	    _err_got = false;

	    try {
	        callback();
	        var success = true;
	    } catch(e) {
	        _test_result = false;
	        console.error("Test \"" + test_name + "\" failed with exception: \"" + e + "\"");
	        var success = false;
	        _warn_got = false;
	        _err_got = false;
	    }

	    m_print.error = print_err_func;
	    m_print.error_once = print_err_once_func;
	    m_print.warn = print_warn_func;

	    return success;
	};

	/**
	 * Compare color picked at the center of the screen with reference RGBA vector.
	 * @param {RGBA} ref_color Reference RGBA vector to compare with.
	 */
	exports.pix = function(ref_color) {
	    var canvas_w = m_cont.get_viewport_width();
	    var canvas_h = m_cont.get_viewport_height();

	    var canvas_x = canvas_w / 2;
	    var canvas_y = canvas_h / 2;

	    m_cont.resize(canvas_w, canvas_h, false);

	    var scene = m_scenes.get_active();
	    var graph = scene._render.graph;
	    var subs = m_scgraph.find_on_screen(graph);
	    if (!subs)
	        m_util.panic("Couldn't find onscreen subscene");

	    var cam = subs.camera;
	    var viewport_xy = m_cont.canvas_to_viewport_coords(canvas_x, canvas_y,
	            _vec2_tmp, subs.camera);

	    viewport_xy[1] = cam.height - viewport_xy[1];
	    var color = m_render.read_pixels(cam.framebuffer, viewport_xy[0],
	            viewport_xy[1], 1, 1, _pixel);

	    eqv(ref_color, color, 1);
	};

	exports.eqs = function(result, exp_result, expected_err, expected_warn) {
	    if (JSON.stringify(result) != JSON.stringify(exp_result))
	        throw "debug.eqs: wrong result";

	    check_err_warn_messages(expected_err, expected_warn, "eqs");
	};

	exports.eqv = eqv;
	function eqv(result, exp_result, eps, expected_err, expected_warn) {
	    if (typeof exp_result != typeof result)
	        throw "debug.eqv: wrong expected data type";
	    if (result.length != exp_result.length)
	        throw "debug.eqv: wrong expected vector length";
	    eps = eps ? eps : EPS;
	    for (var i = 0; i < result.length; i++) {
	        // NaN values are not allowed
	        if (typeof exp_result[i] != "number" || isNaN(exp_result[i]))
	            throw "debug.eqv: wrong expected data type";
	        if (typeof result[i] != "number" || isNaN(result[i]))
	            throw "debug.eqv: wrong result data type";
	        if (exp_result[i] > result[i] + eps || exp_result[i] < result[i] - eps)
	            throw "debug.eqv: wrong result";
	    }

	    check_err_warn_messages(expected_err, expected_warn, "eqv");
	}

	exports.eqf = function(result, exp_result, eps, expected_err, expected_warn) {
	    // NaN values are not allowed
	    if (typeof exp_result != "number" || isNaN(exp_result))
	        throw "debug.eqf: wrong expected data type";
	    if (typeof result != "number" || isNaN(result))
	        throw "debug.eqf: wrong result data type";
	    eps = eps ? eps : EPS;
	    if (exp_result > result + eps || exp_result < result - eps)
	        throw "debug.eqf: wrong result";

	    check_err_warn_messages(expected_err, expected_warn, "eqf");
	};

	exports.eq = function(result, exp_result, expected_err, expected_warn) {
	    if (result !== exp_result)
	        throw "debug.eq: wrong result";

	    check_err_warn_messages(expected_err, expected_warn, "eq");
	};

	exports.ok = function(exp, expected_err, expected_warn) {

	    if (!Boolean(exp))
	        throw "debug.ok: wrong result";

	    check_err_warn_messages(expected_err, expected_warn, "ok");
	};

	function check_err_warn_messages(expected_err, expected_warn, func_name) {
	    expected_err = expected_err || "";
	    expected_warn = expected_warn || "";

	    if (_err_got) {
	        if (expected_err == "")
	            throw "debug." + func_name + ": no error is expected, but got \"" 
	                    + _last_err_message + "\"";
	        else if (_last_err_message != expected_err)
	            throw "debug." + func_name + ": error \"" + expected_err 
	                    + "\" is expected, but got \"" + _last_err_message + "\"";
	    } else {
	        if (expected_err != "")
	            throw "debug." + func_name + ": error \"" + expected_err 
	                + "\" is expected, but got nothing";
	    }
	    if (_warn_got) {
	        if (expected_warn == "")
	            throw "debug." + func_name + ": no warning is expected, but got \"" 
	                    + _last_warn_message + "\"";
	        else if (_last_warn_message != expected_warn)
	            throw "debug." + func_name + ": warning \"" + expected_warn 
	                    + "\" is expected, but got \"" + _last_warn_message + "\"";
	    } else {
	        if (expected_warn != "")
	            throw "debug." + func_name + ": warning \"" + expected_warn 
	                + "\" is expected, but got nothing";
	    }

	    _warn_got = false;
	    _err_got = false;
	}

	exports.stat = function(module_name) {
	    var missing_functions = [];

	    var module = require(module_name);
	    for (var name in module)
	        if (_called_funcs.indexOf(module[name]) == -1 &&
	                typeof module[name] === "function")
	            missing_functions.push(name);

	    if (missing_functions.length) {
	        m_print.groupCollapsed(missing_functions.length + " function(s) not tested.");
	        for (var i = 0; i < missing_functions.length; i++)
	            m_print.log_raw(missing_functions[i]);
	        m_print.groupEnd();
	    } else
	        m_print.group("All functions were tested.");
	};

	/**
	 * Show normals of the dynamic object.
	 * @method module:debug.show_normals
	 * @param {Object3D} obj Object 3D
	 * @param {string} mat_name Material name
	 * @param {number} length Length of normals
	 * @param {number} width Width of normals
	 */
	exports.show_normals = function(obj, mat_name, length, width) {
	    hide_normals();

	    var batch = m_batch.find_batch_material(obj, mat_name, "MAIN");
	    if (!m_geom.has_dyn_geom(obj) || !batch) {
	        m_print.error("Normals are not avaliable for the dynamic object:", obj.name);
	        return false;
	    }

	    var bufs_data = batch.bufs_data;
	    if (!(bufs_data && bufs_data.pointers &&
	            bufs_data.pointers["a_position"] &&
	            bufs_data.pointers["a_tbn"])) {
	        m_print.error("Normals are not avaliable for the object:", obj.name);
	        return false;
	    }

	    var positions = m_geom.extract_array_float(bufs_data, "a_position");
	    var norms = m_geom.extract_array_float(bufs_data, "a_normal");

	    var obj_tsr = m_trans.get_tsr(obj, _tsr_tmp);

	    _normal_line = m_obj.create_line("normal_line");

	    var normals = new Float32Array(2 * positions.length);
	    for (var i = 0; i < positions.length; i += 3) {
	        var ver_pos = _vec3_tmp;
	        ver_pos[0] = positions[i + 0];
	        ver_pos[1] = positions[i + 1];
	        ver_pos[2] = positions[i + 2];
	        var begin_norm = m_tsr.transform_vec3(ver_pos, obj_tsr, _vec3_tmp2);
	        normals[2 * i + 0] = begin_norm[0];
	        normals[2 * i + 1] = begin_norm[1];
	        normals[2 * i + 2] = begin_norm[2];

	        var dir = m_vec3.scale(norms.subarray(i, i + 3), length, _vec3_tmp2);
	        var end_norm_l = m_vec3.add(ver_pos, dir, _vec3_tmp2);
	        var end_norm = m_tsr.transform_vec3(end_norm_l, obj_tsr, _vec3_tmp2);
	        normals[2 * i + 3] = end_norm[0];
	        normals[2 * i + 4] = end_norm[1];
	        normals[2 * i + 5] = end_norm[2];
	    }

	    var normal_line_batch = m_batch.get_first_batch(_normal_line);

	    m_geom.draw_line(normal_line_batch, normals, true);
	    m_render.assign_attribute_setters(normal_line_batch);
	    normal_line_batch.diffuse_color.set([1.0, 1.0, 1.0, 1.0]);
	    normal_line_batch.line_width = width;
	};

	/**
	 * Hide normals of a dynamic object.
	 * @method module:debug.hide_normals
	 */
	exports.hide_normals = hide_normals;
	function hide_normals() {
	    if (!_normal_line)
	        return;

	    // NOTE: it is a copy/paste m_scenes.remove_object
	    m_obj.obj_switch_cleanup_flags(_normal_line, false, false, false);
	    m_data.prepare_object_unloading(_normal_line);
	    m_obj.obj_switch_cleanup_flags(_normal_line, true, true, true);
	    m_obj.remove_object(_normal_line);

	    _normal_line = null;
	}

	}

	var debug_factory = register("debug", Debug);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Low-level input device API.
	 * For more generic cases use {@link module:controls|sensor-based API}.
	 * @module input
	 * @local DeviceType
	 * @local DeviceVectorParameterSync
	 * @local DeviceValueParameterSync
	 * @local DeviceParameterAsync
	 * @local DeviceHMDType
	 * @local DeviceConfig
	 * @local MouseLocationCallback
	 * @local MouseDownWhichCallback
	 * @local MouseUpWhichCallback
	 * @local MouseWheelCallback
	 * @local KeyboardDownCallback
	 * @local KeyboardUpCallback
	 * @local TouchStartCallback
	 * @local TouchMoveCallback
	 * @local TouchEndCallback
	 * @local GyroscopeQuatCallback
	 * @local GyroscopeAnglesCallback
	 */

	function Input(ns, exports) {

	var m_input   = int_input_factory(ns);
	var m_cam     = int_camera_factory(ns);
	var m_cfg     = int_config_factory(ns);
	var m_cont    = int_container_factory(ns);
	var m_obj_util= int_obj_util_factory(ns);
	var m_print   = print_factory(ns);
	var m_scs     = int_scenes_factory(ns);
	var m_vec4    = vec4_factory(ns);

	var _vec4_tmp = m_vec4.create();
	var _vec4_tmp2 = m_vec4.create();

	var _splited_screen = false;

	var cfg_dbg = m_cfg.debug_subs;
	var cfg_def = m_cfg.defaults;

	/**
	 * Type of the names of the synchronous vector parameter of a device.
	 * @typedef {Float32Array} DeviceVectorParameterSync
	 */

	/**
	* Type of the names of the synchronous value parameter of a device.
	* @typedef {number} DeviceValueParameterSync
	*/

	/**
	 * Type of the names of the asynchronous parameter of a device.
	 * @typedef {number} DeviceParameterAsync
	 */

	/**
	 * HMD type enum. Value of {@link module:input.HMD_WEBVR_TYPE|input.HMD_WEBVR_TYPE}.
	 * @typedef {number} DeviceHMDType
	 */

	/**
	 * Type of the names of the device config.
	 * @typedef {number} DeviceConfig
	 */

	/**
	 * Gamepad D-pad up button ID.
	 * @const {number} module:input.GMPD_BUTTON_12
	 */
	exports.GMPD_BUTTON_12 = m_input.GMPD_BUTTON_12;
	/**
	 * Gamepad D-pad down button ID.
	 * @const {number} module:input.GMPD_BUTTON_13
	 */
	exports.GMPD_BUTTON_13 = m_input.GMPD_BUTTON_13;
	/**
	 * Gamepad D-pad right button ID.
	 * @const {number} module:input.GMPD_BUTTON_15
	 */
	exports.GMPD_BUTTON_15 = m_input.GMPD_BUTTON_15;
	/**
	 * Gamepad D-pad left button ID.
	 * @const {number} module:input.GMPD_BUTTON_14
	 */
	exports.GMPD_BUTTON_14 = m_input.GMPD_BUTTON_14;
	/**
	 * Gamepad face panel up button ID.
	 * @const {number} module:input.GMPD_BUTTON_3
	 */
	exports.GMPD_BUTTON_3 = m_input.GMPD_BUTTON_3;
	/**
	 * Gamepad face panel down button ID.
	 * @const {number} module:input.GMPD_BUTTON_0
	 */
	exports.GMPD_BUTTON_0 = m_input.GMPD_BUTTON_0;
	/**
	 * Gamepad face panel right button ID.
	 * @const {number} module:input.GMPD_BUTTON_1
	 */
	exports.GMPD_BUTTON_1 = m_input.GMPD_BUTTON_1;
	/**
	 * Gamepad face panel left button ID.
	 * @const {number} module:input.GMPD_BUTTON_2
	 */
	exports.GMPD_BUTTON_2 = m_input.GMPD_BUTTON_2;
	/**
	 * Gamepad right top shoulder button ID.
	 * @const {number} module:input.GMPD_BUTTON_5
	 */
	exports.GMPD_BUTTON_5 = m_input.GMPD_BUTTON_5;
	/**
	 * Gamepad right bottom shoulder button ID.
	 * @const {number} module:input.GMPD_BUTTON_7
	 */
	exports.GMPD_BUTTON_7 = m_input.GMPD_BUTTON_7;
	/**
	 * Gamepad left top shoulder button ID.
	 * @const {number} module:input.GMPD_BUTTON_4
	 */
	exports.GMPD_BUTTON_4 = m_input.GMPD_BUTTON_4;
	/**
	 * Gamepad left bottom shoulder button ID.
	 * @const {number} module:input.GMPD_BUTTON_6
	 */
	exports.GMPD_BUTTON_6 = m_input.GMPD_BUTTON_6;
	/**
	 * Gamepad select/back button ID.
	 * @const {number} module:input.GMPD_BUTTON_8
	 */
	exports.GMPD_BUTTON_8 = m_input.GMPD_BUTTON_8;
	/**
	 * Gamepad start/forward button ID.
	 * @const {number} module:input.GMPD_BUTTON_9
	 */
	exports.GMPD_BUTTON_9 = m_input.GMPD_BUTTON_9;
	/**
	 * Gamepad left analog button ID.
	 * @const {number} module:input.GMPD_BUTTON_10
	 */
	exports.GMPD_BUTTON_10 = m_input.GMPD_BUTTON_10;
	/**
	 * Gamepad right analog button ID.
	 * @const {number} module:input.GMPD_BUTTON_11
	 */
	exports.GMPD_BUTTON_11 = m_input.GMPD_BUTTON_11;
	/**
	 * Gamepad main button ID.
	 * @const {number} module:input.GMPD_BUTTON_16
	 */
	exports.GMPD_BUTTON_16 = m_input.GMPD_BUTTON_16;
	/**
	 * Gamepad button.
	 * @const {number} module:input.GMPD_BUTTON_17
	 */
	exports.GMPD_BUTTON_17 = m_input.GMPD_BUTTON_17;
	/**
	 * Gamepad button.
	 * @const {number} module:input.GMPD_BUTTON_18
	 */
	exports.GMPD_BUTTON_18 = m_input.GMPD_BUTTON_18;
	/**
	 * Gamepad button.
	 * @const {number} module:input.GMPD_BUTTON_19
	 */
	exports.GMPD_BUTTON_19 = m_input.GMPD_BUTTON_19;
	/**
	 * Gamepad button.
	 * @const {number} module:input.GMPD_BUTTON_20
	 */
	exports.GMPD_BUTTON_20 = m_input.GMPD_BUTTON_20;
	/**
	 * Gamepad button.
	 * @const {number} module:input.GMPD_BUTTON_21
	 */
	exports.GMPD_BUTTON_21 = m_input.GMPD_BUTTON_21;
	/**
	 * Gamepad button.
	 * @const {number} module:input.GMPD_BUTTON_22
	 */
	exports.GMPD_BUTTON_22 = m_input.GMPD_BUTTON_22;
	/**
	 * Gamepad button.
	 * @const {number} module:input.GMPD_BUTTON_23
	 */
	exports.GMPD_BUTTON_23 = m_input.GMPD_BUTTON_23;
	/**
	 * Gamepad button.
	 * @const {number} module:input.GMPD_BUTTON_24
	 */
	exports.GMPD_BUTTON_24 = m_input.GMPD_BUTTON_24;
	/**
	 * Gamepad button.
	 * @const {number} module:input.GMPD_BUTTON_25
	 */
	exports.GMPD_BUTTON_25 = m_input.GMPD_BUTTON_25;
	/**
	 * Gamepad track pad ID.
	 * @const {number} module:input.GMPD_TRACKPAD_BUTTON
	 */
	exports.GMPD_TRACKPAD_BUTTON = m_input.GMPD_TRACKPAD_BUTTON;
	/**
	 * Gamepad trigger ID.
	 * @const {number} module:input.GMPD_TRIGGER_BUTTON
	 */
	exports.GMPD_TRIGGER_BUTTON = m_input.GMPD_TRIGGER_BUTTON;
	/**
	 * Gamepad grips ID.
	 * @const {number} module:input.GMPD_GRIPS_BUTTON
	 */
	exports.GMPD_GRIPS_BUTTON = m_input.GMPD_GRIPS_BUTTON;
	/**
	 * Gamepad grips ID.
	 * @const {number} module:input.GMPD_MENU_BUTTON
	 */
	exports.GMPD_MENU_BUTTON = m_input.GMPD_MENU_BUTTON;
	/**
	 * Gamepad axis.
	 * @const {number} module:input.GMPD_AXIS_0
	 */
	exports.GMPD_AXIS_0 = m_input.GMPD_AXIS_0;
	/**
	 * Gamepad axis.
	 * @const {number} module:input.GMPD_AXIS_1
	 */
	exports.GMPD_AXIS_1 = m_input.GMPD_AXIS_1;
	/**
	 * Gamepad axis.
	 * @const {number} module:input.GMPD_AXIS_2
	 */
	exports.GMPD_AXIS_2 = m_input.GMPD_AXIS_2;
	/**
	 * Gamepad axis.
	 * @const {number} module:input.GMPD_AXIS_3
	 */
	exports.GMPD_AXIS_3 = m_input.GMPD_AXIS_3;
	/**
	 * Gamepad axis.
	 * @const {number} module:input.GMPD_AXIS_4
	 */
	exports.GMPD_AXIS_4 = m_input.GMPD_AXIS_4;
	/**
	 * Gamepad axis.
	 * @const {number} module:input.GMPD_AXIS_5
	 */
	exports.GMPD_AXIS_5 = m_input.GMPD_AXIS_5;
	/**
	 * Gamepad axis.
	 * @const {number} module:input.GMPD_AXIS_6
	 */
	exports.GMPD_AXIS_6 = m_input.GMPD_AXIS_6;
	/**
	 * Gamepad axis.
	 * @const {number} module:input.GMPD_AXIS_7
	 */
	exports.GMPD_AXIS_7 = m_input.GMPD_AXIS_7;
	/**
	 * Gamepad axis.
	 * @const {number} module:input.GMPD_AXIS_8
	 */
	exports.GMPD_AXIS_8 = m_input.GMPD_AXIS_8;
	/**
	 * Gamepad axis.
	 * @const {number} module:input.GMPD_AXIS_9
	 */
	exports.GMPD_AXIS_9 = m_input.GMPD_AXIS_9;
	/**
	 * Gamepad axis.
	 * @const {number} module:input.GMPD_AXIS_10
	 */
	exports.GMPD_AXIS_10 = m_input.GMPD_AXIS_10;
	/**
	 * Gamepad axis.
	 * @const {number} module:input.GMPD_AXIS_11
	 */
	exports.GMPD_AXIS_11 = m_input.GMPD_AXIS_11;

	/**
	 * Parameter of HMD orientation quaternion.
	 * @const {DeviceVectorParameterSync} module:input.HMD_ORIENTATION_QUAT
	 */
	exports.HMD_ORIENTATION_QUAT = m_input.HMD_ORIENTATION_QUAT;

	/**
	 * Parameter of HMD position.
	 * @const {DeviceVectorParameterSync} module:input.HMD_POSITION
	 */
	exports.HMD_POSITION = m_input.HMD_POSITION;

	/**
	 * Parameter of HMD type.
	 * @const {DeviceValueParameterSync} module:input.HMD_WEBVR_TYPE
	 */
	exports.HMD_WEBVR_TYPE = m_input.HMD_WEBVR_TYPE;

	/**
	 * WebVR (old) desktop HMD
	 * @const {DeviceHMDType} module:input.HMD_WEBVR_DESKTOP
	 */
	exports.HMD_WEBVR_DESKTOP = m_input.HMD_WEBVR_DESKTOP;

	/**
	 * WebVR (old) mobile HMD
	 * @const {DeviceHMDType} module:input.HMD_WEBVR_MOBILE
	 */
	exports.HMD_WEBVR_MOBILE = m_input.HMD_WEBVR_MOBILE;

	/**
	 * Non-WebVR HMD
	 * @const {DeviceHMDType} module:input.HMD_NON_WEBVR
	 */
	exports.HMD_NON_WEBVR = m_input.HMD_NON_WEBVR;

	/**
	 * WebVR API 1.0
	 * @const {DeviceHMDType} module:input.HMD_WEBVR1
	 */
	exports.HMD_WEBVR1 = m_input.HMD_WEBVR1;

	/**
	 * WebVR API 1.1
	 * @const {DeviceHMDType} module:input.HMD_WEBVR1_1
	 */
	exports.HMD_WEBVR1_1 = m_input.HMD_WEBVR1_1;

	/**
	 * Parameter of HMD eye distance.
	 * @const {DeviceConfig} module:input.HMD_EYE_DISTANCE
	 */
	var HMD_EYE_DISTANCE = m_input.HMD_EYE_DISTANCE;
	exports.HMD_EYE_DISTANCE = HMD_EYE_DISTANCE;

	/**
	 * Parameter of HMD distortion coefficients.
	 * @const {DeviceConfig} module:input.HMD_DISTORTION
	 */
	exports.HMD_DISTORTION = m_input.HMD_DISTORTION;

	/**
	 * Parameter of HMD baseline distance.
	 * @const {DeviceConfig} module:input.HMD_BASELINE_DIST
	 */
	exports.HMD_BASELINE_DIST = m_input.HMD_BASELINE_DIST;

	/**
	 * Parameter of HMD screen to lens distance.
	 * @const {DeviceConfig} module:input.HMD_SCREEN_LENS_DIST
	 */
	exports.HMD_SCREEN_LENS_DIST = m_input.HMD_SCREEN_LENS_DIST;

	/**
	 * Parameter of mobile screen width.
	 * @const {DeviceConfig} module:input.HMD_SCREEN_WIDTH
	 */
	exports.HMD_SCREEN_WIDTH = m_input.HMD_SCREEN_WIDTH;

	/**
	 * Parameter of mobile screen height.
	 * @const {DeviceConfig} module:input.HMD_SCREEN_HEIGHT
	 */
	exports.HMD_SCREEN_HEIGHT = m_input.HMD_SCREEN_HEIGHT;

	/**
	 * Parameter of mobile bevel size.
	 * @const {DeviceConfig} module:input.HMD_BEVEL_SIZE
	 */
	exports.HMD_BEVEL_SIZE = m_input.HMD_BEVEL_SIZE;

	/**
	 * Parameter of the mouse pointer coordinates.
	 * @const {DeviceVectorParameterSync | DeviceParameterAsync} module:input.MOUSE_LOCATION
	 */
	exports.MOUSE_LOCATION = m_input.MOUSE_LOCATION;

	/**
	 * Parameter of the mouse downed key.
	 * @const {DeviceParameterAsync} module:input.MOUSE_DOWN_WHICH
	 */
	exports.MOUSE_DOWN_WHICH = m_input.MOUSE_DOWN_WHICH;

	/**
	 * Parameter of the mouse upped key.
	 * @const {DeviceParameterAsync} module:input.MOUSE_UP_WHICH
	 */
	exports.MOUSE_UP_WHICH = m_input.MOUSE_UP_WHICH;

	/**
	 * Parameter of the vertical scroll amount.
	 * @const {DeviceParameterAsync} module:input.MOUSE_WHEEL
	 */
	exports.MOUSE_WHEEL = m_input.MOUSE_WHEEL;

	/**
	 * Parameter of the keyboard upped key.
	 * @const {DeviceParameterAsync} module:input.KEYBOARD_UP
	 */
	exports.KEYBOARD_UP = m_input.KEYBOARD_UP;

	/**
	 * Parameter of the keyboard downed key.
	 * @const {DeviceParameterAsync} module:input.KEYBOARD_DOWN
	 */
	exports.KEYBOARD_DOWN = m_input.KEYBOARD_DOWN;

	/**
	 * Parameter of started touch point list on the touch surface.
	 * @const {DeviceParameterAsync} module:input.TOUCH_START
	 */
	exports.TOUCH_START = m_input.TOUCH_START;

	/**
	 * Parameter of moving touch list on the touch surface.
	 * @const {DeviceParameterAsync} module:input.TOUCH_MOVE
	 */
	exports.TOUCH_MOVE = m_input.TOUCH_MOVE;

	/**
	 * Parameter of ended touch point list on the touch surface.
	 * @const {DeviceParameterAsync} module:input.TOUCH_END
	 */
	exports.TOUCH_END = m_input.TOUCH_END;

	/**
	 * Parameter of gyroscope orientation quaternion.
	 * @const {DeviceParameterAsync} module:input.GYRO_ORIENTATION_QUAT
	 */
	exports.GYRO_ORIENTATION_QUAT = m_input.GYRO_ORIENTATION_QUAT;

	/**
	 * Parameter of gyroscope orientation angles.
	 * @const {DeviceParameterAsync} module:input.GYRO_ORIENTATION_ANGLES
	 */
	exports.GYRO_ORIENTATION_ANGLES = m_input.GYRO_ORIENTATION_ANGLES;

	var SYNC_VECTOR_PARAMS = {};
	SYNC_VECTOR_PARAMS[m_input.DEVICE_HMD] = [m_input.HMD_ORIENTATION_QUAT,
	        m_input.HMD_POSITION];
	SYNC_VECTOR_PARAMS[m_input.DEVICE_MOUSE] = [m_input.MOUSE_LOCATION];

	var SYNC_VALUE_PARAMS = {};
	SYNC_VALUE_PARAMS[m_input.DEVICE_HMD] = [m_input.HMD_WEBVR_TYPE];

	var ASYNC_PARAMS = {};
	ASYNC_PARAMS[m_input.DEVICE_MOUSE] = [m_input.MOUSE_LOCATION,
	        m_input.MOUSE_DOWN_WHICH, m_input.MOUSE_UP_WHICH, m_input.MOUSE_WHEEL];
	ASYNC_PARAMS[m_input.DEVICE_KEYBOARD] = [m_input.KEYBOARD_UP,
	        m_input.KEYBOARD_DOWN];
	ASYNC_PARAMS[m_input.DEVICE_TOUCH] = [m_input.TOUCH_START, m_input.TOUCH_MOVE,
	        m_input.TOUCH_END];
	ASYNC_PARAMS[m_input.DEVICE_GYRO] = [m_input.GYRO_ORIENTATION_QUAT,
	        m_input.GYRO_ORIENTATION_ANGLES];

	var CONF = {};
	CONF[m_input.DEVICE_HMD] = [m_input.HMD_DISTORTION,
	        m_input.HMD_EYE_DISTANCE, m_input.HMD_BASELINE_DIST,
	        m_input.HMD_SCREEN_LENS_DIST, m_input.HMD_SCREEN_WIDTH,
	        m_input.HMD_SCREEN_HEIGHT, m_input.HMD_BEVEL_SIZE];

	/**
	 * The callback for the mouse location corresponding to the
	 * {@link module:input.MOUSE_LOCATION|MOUSE_LOCATION} param.
	 * @callback MouseLocationCallback
	 * @param {Float32Array} location List: the horizontal mouse coordinate, the
	 * vertical mouse coordinate.
	 * @example
	 * var m_input = require("input");
	 * 
	 * var mouse_location_cb = function(location) {
	 *     console.log("The horizontal location: " + location[0]);
	 *     console.log("The vertical location: " + location[1]);
	 * };
	 * var device = m_input.get_device_by_type_element(m_input.DEVICE_MOUSE);
	 * m_input.attach_param_cb(device, m_input.MOUSE_LOCATION, mouse_location_cb);
	 */

	/**
	 * The callback for the pressed mouse button corresponding to the
	 * {@link module:input.MOUSE_DOWN_WHICH|MOUSE_DOWN_WHICH} param.
	 * @callback MouseDownWhichCallback
	 * @param {number} which Number indicates button that was pressed on the mouse
	 * (1 -- left button, 2 -- middle button, 3 -- right button).
	 * @example
	 * var m_input = require("input");
	 * 
	 * var mouse_down_which_cb = function(which) {
	 *     console.log("Pressed button: " + which);
	 * };
	 * var device = m_input.get_device_by_type_element(m_input.DEVICE_MOUSE);
	 * m_input.attach_param_cb(device, m_input.MOUSE_DOWN_WHICH, mouse_down_which_cb);
	 */

	/**
	 * The callback for the released mouse button corresponding to the
	 * {@link module:input.MOUSE_UP_WHICH|MOUSE_UP_WHICH} param.
	 * @callback MouseUpWhichCallback
	 * @param {number} which Number indicates button that was released on the mouse
	 * (1 -- left button, 2 -- middle button, 3 -- right button).
	 * @example
	 * var m_input = require("input");
	 * 
	 * var mouse_up_which_cb = function(which) {
	 *     console.log("Released button: " + which);
	 * };
	 * var device = m_input.get_device_by_type_element(m_input.DEVICE_MOUSE);
	 * m_input.attach_param_cb(device, m_input.MOUSE_UP_WHICH, mouse_up_which_cb);
	 */

	/**
	 * The callback for the mouse scroll corresponding to the
	 * {@link module:input.MOUSE_WHEEL|MOUSE_WHEEL} param.
	 * @callback MouseWheelCallback
	 * @param {number} delta The vertical mouse scroll amount.
	 * @example
	 * var m_input = require("input");
	 * 
	 * var mouse_wheel_cb = function(delta) {
	 *     console.log("Scroll amount: " + delta);
	 * };
	 * var device = m_input.get_device_by_type_element(m_input.DEVICE_MOUSE);
	 * m_input.attach_param_cb(device, m_input.MOUSE_WHEEL, mouse_wheel_cb);
	 */

	/**
	 * The callback for the pressed keyboard button corresponding to the
	 * {@link module:input.KEYBOARD_DOWN|KEYBOARD_DOWN} param.
	 * @callback KeyboardDownCallback
	 * @param {number} key_code Number indicates button that was pressed on the
	 * keyboard (use constants KEY_* from module {@link module:controls|controls}).
	 * @example
	 * var m_input = require("input");
	 * 
	 * var keyboard_down_cb = function(key_code) {
	 *     console.log("Pressed keyboard button: " + key_code);
	 * };
	 * var device = m_input.get_device_by_type_element(m_input.DEVICE_KEYBOARD);
	 * m_input.attach_param_cb(device, m_input.KEYBOARD_DOWN, keyboard_down_cb);
	 */

	/**
	 * The callback for the released keyboard button corresponding to the
	 * {@link module:input.KEYBOARD_UP|KEYBOARD_UP} param.
	 * @callback KeyboardUpCallback
	 * @param {number} key_code Number indicates button that was released on the
	 * keyboard (use constants KEY_* from module {@link module:controls|controls}).
	 * @example
	 * var m_input = require("input");
	 * 
	 * var keyboard_up_cb = function(key_code) {
	 *     console.log("Released keyboard button: " + key_code);
	 * };
	 * var device = m_input.get_device_by_type_element(m_input.DEVICE_KEYBOARD);
	 * m_input.attach_param_cb(device, m_input.KEYBOARD_UP, keyboard_up_cb);
	 */

	/**
	 * The callback for the start of touch surface contacting corresponding to the
	 * {@link module:input.TOUCH_START|TOUCH_START} param.
	 * @callback TouchStartCallback
	 * @param {Array} touches List of touch objects corresponding to the
	 * contacting with the touch surface points.
	 * @example
	 * var m_input = require("input");
	 * 
	 * var touch_start_cb = function(touches) {
	 *     for (var i = 0; i < touches.length; ++i)
	 *          console.log("Touch contact " + touches[i].identifier + " has position" +
	 *                  + " x: " + touches[i].clientX + " y: " + touches[i].clientY);
	 * };
	 * var device = m_input.get_device_by_type_element(m_input.DEVICE_TOUCH);
	 * m_input.attach_param_cb(device, m_input.TOUCH_START, touch_start_cb);
	 */

	/**
	 * The callback for the contact moving on the touch surface corresponding to the
	 * {@link module:input.TOUCH_MOVE|TOUCH_MOVE} param.
	 * @callback TouchMoveCallback
	 * @param {Array} touches List of touch objects corresponding to the
	 * contacting with the touch surface points.
	 * @example
	 * var m_input = require("input");
	 * 
	 * var touch_move_cb = function(touches) {
	 *     for (var i = 0; i < touches.length; ++i)
	 *          console.log("Touch contact " + touches[i].identifier + " has position" +
	 *                  + " x: " + touches[i].clientX + " y: " + touches[i].clientY);
	 * };
	 * var device = m_input.get_device_by_type_element(m_input.DEVICE_TOUCH);
	 * m_input.attach_param_cb(device, m_input.TOUCH_MOVE, touch_move_cb);
	 */

	/**
	 * The callback for the end of touch surface contacting corresponding to the
	 * {@link module:input.TOUCH_END|TOUCH_END} param.
	 * @callback TouchEndCallback
	 * @param {Array} touches List of touch objects corresponding to the
	 * contacting with the touch surface points.
	 * @example
	 * var m_input = require("input");
	 * 
	 * var touch_end_cb = function(touches) {
	 *     for (var i = 0; i < touches.length; ++i)
	 *          console.log("Touch contact " + touches[i].identifier + " has position" +
	 *                  + " x: " + touches[i].clientX + " y: " + touches[i].clientY);
	 * };
	 * var device = m_input.get_device_by_type_element(m_input.DEVICE_TOUCH);
	 * m_input.attach_param_cb(device, m_input.TOUCH_END, touch_end_cb);
	 */

	/**
	 * The callback for the quaternion of the gyroscope orientation corresponding 
	 * to the {@link module:input.GYRO_ORIENTATION_QUAT|GYRO_ORIENTATION_QUAT} param.
	 * @callback GyroscopeQuatCallback
	 * @param {Quat} quat Quaternion vector corresponding to the gyroscope orientation.
	 * @example
	 * var m_input = require("input");
	 * 
	 * var gyroscope_quat_cb = function(quat) {
	 *     console.log("Gyroscope orientation quaternion is " + quat);
	 * };
	 * var device = m_input.get_device_by_type_element(m_input.DEVICE_GYRO);
	 * m_input.attach_param_cb(device, m_input.GYRO_ORIENTATION_QUAT, gyroscope_quat_cb);
	 */

	/**
	 * The callback for the Euler angles of the gyroscope orientation corresponding
	 * to the {@link module:input.GYRO_ORIENTATION_ANGLES|GYRO_ORIENTATION_ANGLES} param.
	 * @callback GyroscopeAnglesCallback
	 * @param {Euler} angles Euler angles (in radians) corresponding to the gyroscope 
	 * orientation.
	 * @example
	 * var m_input = require("input");
	 * 
	 * var gyroscope_angles_cb = function(angles) {
	 *     console.log("Gyroscope orientation Euler angles are " + angles);
	 * };
	 * var device = m_input.get_device_by_type_element(m_input.DEVICE_GYRO);
	 * m_input.attach_param_cb(device, m_input.GYRO_ORIENTATION_ANGLES, gyroscope_angles_cb);
	 */

	/**
	 * Device type enum.
	 * @typedef {number} DeviceType
	 */

	/**
	 * Gyroscope device type.
	 * @const {DeviceType} module:input.DEVICE_GYRO
	 */
	exports.DEVICE_GYRO = m_input.DEVICE_GYRO;

	/**
	 * Head mounted device type.
	 * @const {DeviceType} module:input.DEVICE_HMD
	 */
	exports.DEVICE_HMD = m_input.DEVICE_HMD;

	/**
	 * Mouse device type.
	 * @const {DeviceType} module:input.DEVICE_MOUSE
	 */
	exports.DEVICE_MOUSE = m_input.DEVICE_MOUSE;

	/**
	 * Keyboard device type.
	 * @const {DeviceType} module:input.DEVICE_KEYBOARD
	 */
	exports.DEVICE_KEYBOARD = m_input.DEVICE_KEYBOARD;

	/**
	 * Touch device type.
	 * @const {DeviceType} module:input.DEVICE_TOUCH
	 */
	exports.DEVICE_TOUCH = m_input.DEVICE_TOUCH;

	/**
	 * Check if the device can be used.
	 * @method module:input.can_use_device
	 * @param {DeviceType} type Device type.
	 * @returns {boolean} Result of the check
	 */
	exports.can_use_device = m_input.can_use_device;

	/**
	 * Get device object by associated device type and DOM element.
	 * If device is not available, then return null.
	 * @method module:input.get_device_by_type_element
	 * @param {DeviceType} type Device type.
	 * @param {?HTMLElement} element HTML element to add event listeners to.
	 * @returns {?Object} Device object.
	 */
	exports.get_device_by_type_element = m_input.get_device_by_type_element;

	/**
	 * Switch triggering of the browser default actions for registered events.
	 * @param {Object} device Device object. Use
	 * {@link module:input.get_device_by_type_element|input.get_device_by_type_element} to obtain it.
	 * @param {boolean} prevent_default Prevent default flag.
	 * @method module:input.switch_prevent_default
	 */
	exports.switch_prevent_default = function(device, prevent_default) {
	    if (device)
	        m_input.switch_prevent_default(device, prevent_default);
	};

	/**
	 * Register device. Right now it should be used for DEVICE_HMD.
	 * @method module:input.register_device
	 * @deprecated Not needed anymore.
	 */
	exports.register_device = function() {
	    m_print.error_once("input.register_device() deprecated");
	};

	/**
	 * Reset device. The device parameters values return to zero.
	 * Right now it should be used for DEVICE_HMD.
	 * @param {Object} device Device object. Use
	 * {@link module:input.get_device_by_type_element|input.get_device_by_type_element} to obtain it.
	 * @method module:input.reset_device
	 */
	exports.reset_device = function(device) {
	    if (!device || device.type != m_input.DEVICE_HMD) {
	        m_print.error("reset_device is undefined for device.");
	        return;
	    }

	    m_input.reset_device(device);
	};

	/**
	 * Get parameter vector.
	 * @param {Object} device Device object. Use
	 * {@link module:input.get_device_by_type_element|input.get_device_by_type_element} to obtain it.
	 * @param {DeviceVectorParameterSync} param Name of the device vector parameter.
	 * @param {Float32Array} dest Destination vector.
	 * @returns {?Float32Array} Destination vector.
	 * @method module:input.get_vector_param
	 */
	exports.get_vector_param = function(device, param, dest) {
	    if (device && device.type in SYNC_VECTOR_PARAMS &&
	            SYNC_VECTOR_PARAMS[device.type].indexOf(param) >= 0)
	        return m_input.get_vector_param(device, param, dest);
	    else
	        m_print.error("device hasn't param: ", param);
	    return null;
	};

	/**
	 * Get parameter value.
	 * @param {Object} device Device object. Use
	 * {@link module:input.get_device_by_type_element|input.get_device_by_type_element} to obtain it.
	 * @param {DeviceValueParameterSync} param Name of the device value parameter.
	 * @returns {number|boolean|null} Parameter value.
	 * @method module:input.get_value_param
	 */
	exports.get_value_param = function(device, param) {
	    if (device && device.type in SYNC_VALUE_PARAMS &&
	            SYNC_VALUE_PARAMS[device.type].indexOf(param) >= 0)
	        return m_input.get_value_param(device, param);
	    else
	        m_print.error("device hasn't param: ", param);

	    return null;
	};

	/**
	 * Attach callback to the device parameter. It is called when parameter is changed.
	 * @param {Object} device Device object. Use
	 * {@link module:input.get_device_by_type_element|input.get_device_by_type_element} to obtain it.
	 * @param {DeviceParameterAsync} param Name of the device parameter.
	 * @param {MouseLocationCallback|MouseDownWhichCallback|MouseUpWhichCallback|
	 * MouseWheelCallback|KeyboardDownCallback|KeyboardUpCallback|
	 * TouchStartCallback|TouchMoveCallback|TouchEndCallback|
	 * GyroscopeQuatCallback|GyroscopeAnglesCallback} [cb = null] Callback.
	 * @method module:input.attach_param_cb
	 */
	exports.attach_param_cb = function(device, param, cb) {
	    cb = cb || null;
	    if (device && device.type in ASYNC_PARAMS &&
	            ASYNC_PARAMS[device.type].indexOf(param) >= 0)
	        return m_input.attach_param_cb(device, param, cb);
	    else
	        m_print.error("device hasn't param: ", param);
	};

	/**
	 * Detach callback from the device parameter.
	 * @param {Object} device Device object. Use
	 * {@link module:input.get_device_by_type_element|input.get_device_by_type_element} to obtain it.
	 * @param {DeviceParameterAsync} param Name of the device parameter.
	 * @param {MouseLocationCallback|MouseDownWhichCallback|MouseUpWhichCallback|
	 * MouseWheelCallback|KeyboardDownCallback|KeyboardUpCallback|
	 * TouchStartCallback|TouchMoveCallback|TouchEndCallback|
	 * GyroscopeQuatCallback|GyroscopeAnglesCallback} [cb = null] Callback.
	 * @method module:input.detach_param_cb
	 */
	exports.detach_param_cb = function(device, param, cb) {
	    cb = cb || null;
	    if (device && device.type in ASYNC_PARAMS &&
	            ASYNC_PARAMS[device.type].indexOf(param) >= 0)
	        return m_input.detach_param_cb(device, param, cb);
	    else
	        m_print.error("device hasn't param: ", param);
	};

	exports.set_config = function(device, config, value) {
	    if (device && device.type in CONF &&
	            CONF[device.type].indexOf(config) >= 0)
	        return m_input.set_config(device, config, value);
	    else
	        m_print.error("device hasn't config: ", config);
	};

	/**
	 * Request fullscreen mode.
	 * @method module:input.request_fullscreen_hmd
	 * @deprecated Use {@link module:screen.request_fullscreen_hmd} instead
	 */
	exports.request_fullscreen_hmd = function() {
	    m_print.error_deprecated("request_fullscreen_hmd", "screen.request_fullscreen_hmd");

	    if (m_scs.check_active()) {
	         var cam_obj = m_scs.get_camera(m_scs.get_active());
	         if (!cam_obj)
	             return;
	    } else
	        return;

	    enable_split_screen(cam_obj);

	    var hmd_device = m_input.get_device_by_type_element(m_input.DEVICE_HMD);
	    if (hmd_device) {
	        var webvr_display = hmd_device.webvr_display;
	        // TODO: add "&& !webvr_display.isPresenting" to "if" (optimization).
	        // Right now webvr_display.isPresenting is allways "true" after
	        // first requestPresent.
	        if (webvr_display && !webvr_display.isPresenting) {
	            var capabilities = webvr_display.capabilities;
	            if (!capabilities.canPresent)
	                m_print.error("HMD fullscreen request failed.");
	            else {
	                var canvas = m_cont.get_canvas();
	                webvr_display.requestPresent([{source: canvas}]).then(function () {
	                    // TODO: check code below
	                    // There was strange behavior Samsung Internet on GearVR

	                    if (!cfg_def.is_mobile_device) {
	                        var left_eye = webvr_display.getEyeParameters("left");
	                        var right_eye = webvr_display.getEyeParameters("right");

	                        m_cont.resize(
	                                Math.max(left_eye.renderWidth, right_eye.renderWidth) * 2,
	                                Math.max(left_eye.renderHeight, right_eye.renderHeight), false);
	                    }
	                }, function () {
	                    m_print.error("HMD fullscreen request failed.");
	                });
	            }
	        }
	    }
	};

	/**
	 * Enable "split screen" mode.
	 * @method module:input.enable_split_screen
	 * @param {Object3D} camobj Camera 3D-object.
	 * @returns {boolean} "Split screen" mode is enabled.
	 * @deprecated Use {@link module:screen.request_split_screen} instead
	 */
	exports.enable_split_screen = enable_split_screen;
	function enable_split_screen(camobj) {
	    m_print.error_deprecated("enable_split_screen", "screen.request_split_screen");

	    var hmd_device = m_input.get_device_by_type_element(m_input.DEVICE_HMD);
	    if (!hmd_device)
	        return false;

	    if (_splited_screen)
	        return true;

	    var hmd_left_fov = m_input.get_vector_param(hmd_device, m_input.HMD_FOV_LEFT, _vec4_tmp);
	    var hmd_right_fov = m_input.get_vector_param(hmd_device, m_input.HMD_FOV_RIGHT, _vec4_tmp2);
	    m_cam.set_hmd_fov(camobj, hmd_left_fov, hmd_right_fov);

	    var eye_distance = m_input.get_value_param(hmd_device, HMD_EYE_DISTANCE);
	    if (eye_distance) {
	        var active_scene = m_scs.get_active();
	        var cam_scene_data = m_obj_util.get_scene_data(camobj, active_scene);
	        var cameras = cam_scene_data.cameras;
	        m_cam.set_eye_distance(cameras, eye_distance);
	    }

	    var hmd_params = {};
	    hmd_params.base_line_factor = 0.5;
	    hmd_params.inter_lens_factor = 0.5;
	    hmd_params.enable_hmd_stereo = true;
	    var hmd_type = m_input.get_value_param(hmd_device, m_input.HMD_WEBVR_TYPE);
	    if (hmd_type & (m_input.HMD_NON_WEBVR | m_input.HMD_WEBVR_MOBILE |
	            m_input.HMD_WEBVR_DESKTOP)) {
	        hmd_params.distortion_coefs = [
	            hmd_device.distortion_coefs[0],
	            hmd_device.distortion_coefs[1]
	        ];
	        hmd_params.chromatic_aberration_coefs = [
	            hmd_device.chromatic_aberration_coefs[0],
	            hmd_device.chromatic_aberration_coefs[1],
	            hmd_device.chromatic_aberration_coefs[2],
	            hmd_device.chromatic_aberration_coefs[3]
	        ];
	        if (!hmd_device.webvr_hmd_device)
	            if (hmd_device.base_line_dist && hmd_device.height_dist && hmd_device.bevel_size)
	                hmd_params.base_line_factor = (hmd_device.base_line_dist - hmd_device.bevel_size) /
	                        hmd_device.height_dist;
	            else if (!hmd_device.bevel_size)
	                hmd_params.base_line_factor = hmd_device.base_line_dist / hmd_device.height_dist;
	        if (hmd_device.inter_lens_dist && hmd_device.width_dist && !hmd_device.webvr_hmd_device)
	            hmd_params.inter_lens_factor = hmd_device.inter_lens_dist /
	                    hmd_device.width_dist;
	        // NOTE: prevent crash in case of difference of slink's dimensions.
	        // For example: "debug" slink ~ 0.5 X 1.0,
	        //              "origin" slink ~ distortion_scale * 0.5 X distortion_scale * 1.0
	        if (!cfg_dbg.enabled) {
	            var distortion_scale = (1 + hmd_device.distortion_coefs[0] + hmd_device.distortion_coefs[1]);
	            m_scs.multiply_size_mult(distortion_scale, distortion_scale);
	        }
	    }
	    m_scs.set_hmd_params(hmd_params);

	    m_cont.resize_to_container(true);

	    m_input.reset_device(hmd_device);

	    _splited_screen = true;
	    return true;
	}

	/**
	 * Disable "split screen" mode.
	 * @method module:input.disable_split_screen
	 * @returns {boolean} "Split screen" mode is disabled.
	 * @deprecated Use {@link module:screen.exit_split_screen} instead
	 */
	exports.disable_split_screen = function() {
	    m_print.error_deprecated("disable_split_screen", "screen.exit_split_screen");

	    var hmd_device = m_input.get_device_by_type_element(m_input.DEVICE_HMD);
	    if (!_splited_screen || !hmd_device || !hmd_device.registered)
	        return false;

	    // set up non-vr mode
	    var hmd_params = {};
	    hmd_params.enable_hmd_stereo = false;
	    m_scs.set_hmd_params(hmd_params);

	    var distortion_scale = 1 / (1 + hmd_device.distortion_coefs[0] + hmd_device.distortion_coefs[1]);
	    m_scs.multiply_size_mult(distortion_scale, distortion_scale);
	    // resize screen to canvas resolution (non-vr mode)
	    m_cont.resize_to_container(true);
	    return true;
	};
	/**
	 * Set gamepad button key value.
	 * @method module:input.set_gamepad_key
	 * @param {number} gamepad_id Connected gamepad number.
	 * @param {number} btn Button or axis identifier.
	 * @param {number} key Button key value.
	 */
	exports.set_gamepad_key = function(gamepad_id, btn, key) {
	    switch(gamepad_id) {
	    case 0:
	        var type = m_input.DEVICE_GAMEPAD0;
	        break;
	    case 1:
	        var type = m_input.DEVICE_GAMEPAD1;
	        break;
	    case 2:
	        var type = m_input.DEVICE_GAMEPAD2;
	        break;
	    case 3:
	        var type = m_input.DEVICE_GAMEPAD3;
	        break;
	    default:
	        var type = m_input.DEVICE_GAMEPAD0;
	    }
	    var device = m_input.get_device_by_type_element(type);
	    m_input.set_config(device, btn, key);
	};
	/**
	 * Get pressed button key value.
	 * @method module:input.get_pressed_gmpd_btn
	 * @param {number} gamepad_id Gamepad identifier (Connected device number 0-3).
	 * @returns {number} Pressed button key value.
	 */
	exports.get_pressed_gmpd_btn = m_input.get_pressed_gmpd_btn;
	/**
	 * Get moved axis key value.
	 * @method module:input.get_moved_gmpd_axis
	 * @param {number} gamepad_id Gamepad identifier (Connected device number 0-3).
	 * @returns {number} Moved axis key value.
	 */
	exports.get_moved_gmpd_axis = m_input.get_moved_gmpd_axis;
	/**
	 * Get gamepad position.
	 * @method module:input.get_gamepad_position
	 * @param {number} gamepad_id Gamepad identifier (Connected device number 0-3).
	 * @param {Vec3} dest Destination vector.
	 * @returns {Vec3} Gamepad position.
	 */
	exports.get_gamepad_position = m_input.get_gamepad_position;
	/**
	 * Get gamepad orientation.
	 * @method module:input.get_gamepad_orientation
	 * @param {number} gamepad_id Gamepad identifier (Connected device number 0-3).
	 * @param {Quat} dest Destination vector.
	 * @returns {Quat} Gamepad orientation.
	 */
	exports.get_gamepad_orientation = m_input.get_gamepad_orientation;
	/**
	 * Check available gamepads indices.
	 * @method module:input.check_enable_gamepad_indices
	 * @returns {Array} Numeric array with indices
	 * @cc_externs getGamepads webkitGetGamepads
	 */
	exports.check_enable_gamepad_indices = check_enable_gamepad_indices;
	function check_enable_gamepad_indices() {
	    var gamepads = navigator.getGamepads ? navigator.getGamepads() :
	            (navigator.webkitGetGamepads ? navigator.webkitGetGamepads : []);
	    var indices = [];
	    for (var i = 0; i < gamepads.length; i++)
	        if (gamepads[i])
	            indices.push(i);
	    return indices;
	}

	/**
	 * Get gamepad id of VR controller.
	 * @method module:input.get_vr_controller_id
	 * @param {number} controller_id VR controller id.
	 * @return {number} Gamepad id.
	 * @example
	 * var m_input = require("input");
	 *
	 * // get the id of the first VR controller (among all gamepads)
	 * var vr_id = m_input.get_vr_controller_id(0);
	 */
	exports.get_vr_controller_id = function(controller_id) {
	    var gamepads = navigator.getGamepads ? navigator.getGamepads() :
	            (navigator.webkitGetGamepads ? navigator.webkitGetGamepads : []);

	    // CHECK: there could be more than 4 gamepads in Firefox Nightly
	    for (var i = 0, j = 0; i < 4; i++) {
	        var gamepad = gamepads[i];
	        // use gamepad.id == "", bcz there is a bug in Firefox Nightly
	        if (gamepad && (gamepad.id == "" ||
	                gamepad.id == "OpenVR Gamepad" ||
	                gamepad.id == "Oculus Touch (Left)" ||
	                gamepad.id == "Oculus Touch (Right)"
	                )) {
	            if (j == controller_id)
	                return j;
	            j++;
	        }
	    }

	    return controller_id;
	};

	/**
	 * Register the listener on the click event. Callback is called on right
	 * after click on element (without 300ms delay).
	 * @method module:input.add_click_listener
	 * @param {HTMLElement} element DOM element.
	 * @param {Callback} callback Callback.
	 */
	exports.add_click_listener = function(element, callback) {
	    if (!element || !callback)
	        return;

	    m_input.add_click_listener(element, callback);
	};

	/**
	 * Unregister the listener registered with
	 * {@link module:input.add_click_listener | input.add_click_listener}.
	 * @method module:input.remove_click_listener
	 * @param {HTMLElement} element DOM element.
	 * @param {Callback} callback Callback.
	 */
	exports.remove_click_listener = function(element, callback) {
	    if (!element || !callback)
	        return;

	    m_input.remove_click_listener(element, callback);
	};

	}

	var input_factory = register("input", Input);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Inner main Blend4Web module.
	 * @module main
	 */
	function Int_main(ns, exports) {

	var m_cont = int_container_factory(ns);

	var _canvas_data_url_params = {
	    callback: null,
	    format: "image/png",
	    quality: 1.0,
	    blob_url: "",
	    last_auto_revoke: false,
	    curr_auto_revoke: false
	};

	function to_blob(callback, type, quality) {
	    var canvas = m_cont.get_canvas();

	    if (canvas.toBlob)
	        canvas.toBlob(callback, type, quality);
	    else {
	        var binStr = atob(canvas.toDataURL(type, quality).split(',')[1]);
	        var data = new Uint8Array(binStr.length);

	        for (var i = 0; i < binStr.length; i++)
	            data[i] = binStr.charCodeAt(i);

	        callback(new Blob([data], {type: type || 'image/png'}));
	    }
	}

	exports.canvas_data_url = function(callback, format, quality, auto_revoke) {
	    _canvas_data_url_params.curr_auto_revoke = typeof auto_revoke === "undefined" ?
	            auto_revoke: true;

	    _canvas_data_url_params.last_auto_revoke = _canvas_data_url_params.curr_auto_revoke;
	    _canvas_data_url_params.callback = callback;
	    _canvas_data_url_params.format = format || _canvas_data_url_params.format;
	    _canvas_data_url_params.quality = quality || _canvas_data_url_params.quality;
	};

	exports.frame = function(timeline, delta) {

	    // make screenshot
	    var cb = _canvas_data_url_params.callback;
	    if (cb) {
	        if (_canvas_data_url_params.last_auto_revoke &&
	                _canvas_data_url_params.blob_url)
	            URL.revokeObjectURL(_canvas_data_url_params.blob_url);

	        to_blob(function(blob) {
	            if (navigator.msSaveOrOpenBlob) {
	                cb(blob);
	            } else {
	                _canvas_data_url_params.blob_url = URL.createObjectURL(blob);
	                cb(_canvas_data_url_params.blob_url);
	            }
	        }, _canvas_data_url_params.format, _canvas_data_url_params.quality);

	        _canvas_data_url_params.callback = null;
	        _canvas_data_url_params.format = "image/png";
	        _canvas_data_url_params.quality = 1.0;
	    }
	};

	}

	var int_main_factory = register("__main", Int_main);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Main Blend4Web module.
	 * Implements methods to initialize and change the global params of the engine.
	 * @module main
	 * @local LoopCallback
	 * @local RenderCallback
	 * @local FPSCallback
	 */
	function Main(ns, exports) {

	/**
	 * Loop callback.
	 * @callback LoopCallback
	 * @param {number} timeline Timeline
	 * @param {number} delta Delta
	 */

	/**
	 * Rendering callback.
	 * @callback RenderCallback
	 * @param {number} delta Delta
	 * @param {number} timeline Timeline
	 */

	/**
	 * FPS callback
	 * @callback FPSCallback
	 * @param {number} fps_avg Averaged rendering FPS.
	 * @param {number} phy_fps_avg Averaged physics FPS.
	 */

	var m_anchors   = int_anchors_factory(ns);
	var m_anim      = int_animation_factory(ns);
	var m_assets    = int_assets_factory(ns);
	var m_cfg       = int_config_factory(ns);
	var m_compat    = int_compat_factory(ns);
	var m_cont      = int_container_factory(ns);
	var m_ctl       = int_controls_factory(ns);
	var m_data      = int_data_factory(ns);
	var m_debug     = int_debug_factory(ns);
	var m_ext       = int_extensions_factory(ns);
	var m_geom      = int_geometry_factory(ns);
	var m_input     = int_input_factory(ns);
	var m_hud       = int_hud_factory(ns);
	var m_nla       = int_nla_factory(ns);
	var m_main      = int_main_factory(ns);
	var m_lnodes    = int_logic_nodes_factory(ns);
	var m_obj       = int_objects_factory(ns);
	var m_phy       = int_physics_factory(ns);
	var m_print     = print_factory(ns);
	var m_render    = int_renderer_factory(ns);
	var m_scenes    = int_scenes_factory(ns);
	var m_sfx       = int_sfx_factory(ns);
	var m_shaders   = int_shaders_factory(ns);
	var m_textures  = int_textures_factory(ns);
	var m_time      = int_time_factory(ns);
	var m_trans     = int_transform_factory(ns);
	var m_util      = int_util_factory(ns);
	var m_version   = int_version_factory(ns);
	var m_particles = int_particles_factory(ns);

	var cfg_ctx = m_cfg.context;
	var cfg_def = m_cfg.defaults;

	var _last_abs_time = 0;
	var _pause_time = 0;
	var _resume_time = 0;
	var _loop_cb = [];

	var _fps_callback = function() {};
	var _fps_counter = function() {};

	var _render_callback = function() {};

	var WEBGL_CTX_IDS = ["webgl", "experimental-webgl"];
	var WEBGL2_CTX_IDS = ["webgl2", "experimental-webgl2"];

	var _gl = null;

	/**
	 * NOTE: According to the spec, this function takes only one param
	 */
	var _requestAnimFrame = (function() {
	  return window.requestAnimationFrame ||
	         window.webkitRequestAnimationFrame ||
	         window.mozRequestAnimationFrame ||
	         window.oRequestAnimationFrame ||
	         window.msRequestAnimationFrame ||
	         function(callback) {return window.setTimeout(callback,
	             1000/cfg_def.max_fps);};
	})();

	// public enums

	/**
	 * Create the WebGL context and initialize the engine.
	 * @method module:main.init
	 * @param {HTMLCanvasElement} elem_canvas_webgl Canvas element for WebGL
	 * @param {HTMLCanvasElement} [elem_canvas_hud] Canvas element for HUD
	 * @returns {WebGLRenderingContext|Null} WebGL context or null
	 */
	exports.init = function(elem_canvas_webgl, elem_canvas_hud) {
	    // NOTE: for debug purposes
	    // works in chrome with --enable-memory-info --js-flags="--expose-gc"
	    //window.setInterval(function() {window.gc();}, 1000);

	    m_print.set_verbose(cfg_def.console_verbose);

	    var ver_str = m_version.version_str() + " " + m_version.type() +
	            " (" + m_version.date_str() + ")";
	    m_print.log("%cINIT ENGINE", "color: #00a", ver_str);
	    m_print.log("%cUSER AGENT:", "color: #00a", navigator.userAgent);

	    // check gl context and performance.now()
	    if (!window["WebGLRenderingContext"])
	        return null;

	    setup_clock();

	    if (elem_canvas_hud) {
	        m_hud.init(elem_canvas_hud);
	    } else {
	        // disable features which depend on HUD
	        m_cfg.defaults.show_hud_debug_info = false;
	        m_cfg.sfx.mix_mode = false;
	    }

	    m_compat.apply_context_alpha_hack();

	    // allow WebGL 2 only in Chrome and Firefox
	    if (!(m_compat.check_user_agent("Chrome") ||
	                m_compat.check_user_agent("Firefox")))
	        cfg_def.webgl2 = false;

	    var gl = get_context(elem_canvas_webgl, cfg_def.webgl2);

	    // fallback to WebGL 1
	    if (!gl && cfg_def.webgl2) {
	        cfg_def.webgl2 = false;
	        gl = get_context(elem_canvas_webgl, false);
	    }

	    if (!gl)
	        return null;

	    m_print.log("%cINIT WEBGL " + (cfg_def.webgl2 ? "2" : "1"), "color: #00a");

	    _gl = gl;

	    init_context(elem_canvas_webgl, elem_canvas_hud, gl);
	    m_cfg.apply_quality();
	    m_compat.set_hardware_defaults(gl, true);

	    m_cfg.set_paths();

	    m_shaders.load_shaders();

	    if (cfg_def.ie11_edge_touchscreen_hack)
	        elem_canvas_webgl.style["touch-action"] = "none";

	    m_print.log("%cSET PRECISION:", "color: #00a", cfg_def.precision);

	    return gl;
	};

	function setup_clock() {
	    if (!window.performance) {
	        m_print.log("Apply performance workaround");
	        window.performance = {};
	    }

	    var curr_time = Date.now();

	    if (!window.performance.now) {
	        m_print.log("Apply performance.now() workaround");

	        //cfg_def.no_phy_interp_hack = true;

	        window.performance.now = function() {
	            return Date.now() - curr_time;
	        };
	    }

	    m_time.set_timeline(0);
	}

	function get_context(canvas, init_webgl2) {

	    var ctx = null;
	    
	    var ctx_ids = init_webgl2 ? WEBGL2_CTX_IDS : WEBGL_CTX_IDS;

	    for (var i = 0; i < ctx_ids.length; i++) {
	        var name = ctx_ids[i];

	        try {
	            ctx = canvas.getContext(name, cfg_ctx);
	        } catch(e) {
	            // nothing
	        }

	        if (ctx)
	            break;
	    }

	    if (ctx)
	        m_compat.detect_tegra_invalid_enum_issue(ctx);

	    return ctx;
	}

	function init_context(canvas, canvas_hud, gl) {
	    canvas.addEventListener("webglcontextlost",
	            function(event) {
	                event.preventDefault();

	                m_print.error("WebGL context lost");

	                // at least prevent freeze
	                pause();

	            }, false);

	    m_ext.setup_context(gl);

	    var rinfo = m_ext.get_renderer_info();
	    if (rinfo)
	        m_print.log("%cRENDERER INFO:", "color: #00a",
	            gl.getParameter(rinfo.UNMASKED_VENDOR_WEBGL) + ", " +
	            gl.getParameter(rinfo.UNMASKED_RENDERER_WEBGL));

	    m_render.setup_context(gl);
	    m_geom.setup_context(gl);
	    m_textures.setup_context(gl);
	    m_shaders.setup_context(gl);
	    m_cont.setup_context(gl);
	    m_debug.setup_context(gl);
	    m_data.setup_canvas(canvas);
	    m_cont.init(canvas, canvas_hud);

	    m_scenes.setup_dim(canvas.width, canvas.height, 1);

	    m_sfx.init();

	    m_input.init();

	    _fps_counter = init_fps_counter();

	    loop();
	}

	/**
	 * Set the callback for the FPS counter
	 * @method module:main.set_fps_callback
	 * @param {FPSCallback} fps_cb FPS callback
	 */
	exports.set_fps_callback = function(fps_cb) {
	    _fps_callback = fps_cb;
	};
	/**
	 * Remove the callback for the FPS counter
	 * @method module:main.clear_fps_callback
	 */
	exports.clear_fps_callback = function() {
	    _fps_callback = function() {};
	};


	/**
	 * Set the rendering callback which is executed for every frame just before the
	 * rendering. Only one callback is allowed.
	 * @method module:main.set_render_callback
	 * @param {RenderCallback} callback Render callback
	 */
	exports.set_render_callback = function(callback) {
	    set_render_callback(callback);
	};
	function set_render_callback(callback) {
	    _render_callback = callback;
	}

	/**
	 * Remove the rendering callback.
	 * @method module:main.clear_render_callback
	 */
	exports.clear_render_callback = function() {
	    clear_render_callback();
	};
	function clear_render_callback() {
	    _render_callback = function() {};
	}

	exports.pause = pause;
	/**
	 * Pause the engine
	 * @method module:main.pause
	 */
	function pause() {
	    if (is_paused())
	        return;

	    _pause_time = performance.now() / 1000;
	    m_sfx.pause();
	    m_phy.pause();
	    m_textures.pause();
	    m_anchors.pause();
	}

	/**
	 * Resume the engine (after pausing)
	 * @method module:main.resume
	 */
	exports.resume = function() {
	    if (!is_paused())
	        return;

	    _resume_time = performance.now() / 1000;
	    m_sfx.resume();
	    m_phy.resume();
	    m_textures.play(true);
	    m_anchors.resume();
	};

	/**
	 * Check if the engine is paused
	 * @method module:main.is_paused
	 * @returns {boolean} Paused flag
	 */
	exports.is_paused = is_paused;
	function is_paused() {
	    return (_resume_time < _pause_time);
	}

	function loop() {
	    var vr_display = cfg_def.stereo === "HMD" && m_input.get_webvr_display();
	    if (vr_display)
	        vr_display.requestAnimationFrame(loop);
	    else
	        _requestAnimFrame(loop);

	    // float sec
	    var abstime = performance.now() / 1000;

	    if (!_last_abs_time)
	        _last_abs_time = abstime;

	    var delta = abstime - _last_abs_time;

	    // do not render short frames
	    if (delta < 1/cfg_def.max_fps)
	        return;

	    var timeline = m_time.get_timeline();

	    for (var i = 0; i < _loop_cb.length; i++)
	        _loop_cb[i](timeline, delta);

	    if (!is_paused()) {
	        // correct delta if resume occured since last frame
	        if (_resume_time > _last_abs_time)
	            delta -= (_resume_time - Math.max(_pause_time, _last_abs_time));

	        m_time.set_delta(delta);

	        timeline += delta;
	        m_time.set_timeline(timeline);

	        m_debug.update();

	        m_assets.update();
	        m_data.update();
	        frame(timeline, delta);

	        _fps_counter(delta);
	    }

	    _last_abs_time = abstime;

	    if (vr_display && vr_display.isPresenting)
	        vr_display.submitFrame();
	}

	function frame(timeline, delta) {
	    // possible unload between frames
	    if (!m_data.is_primary_loaded())
	        return;

	    m_hud.reset();

	    m_trans.update(delta);

	    m_lnodes.update(timeline, delta);

	    m_nla.update(timeline, delta);

	    // sound
	    m_sfx.update(timeline, delta);

	    // animation
	    if (delta)
	        m_anim.update(delta);

	    // possible unload in animation callbacks
	    if (!m_data.is_primary_loaded())
	        return;

	    m_phy.update(timeline, delta);

	    // possible unload in physics callbacks
	    if (!m_data.is_primary_loaded())
	        return;

	    //inputs should be updated before controls
	    m_input.update(timeline);
	    // controls
	    m_ctl.update(timeline, delta);

	    // possible unload in controls callbacks
	    if (!m_data.is_primary_loaded())
	        return;

	    // anchors
	    m_anchors.update(false);

	    // objects
	    m_obj.update(timeline, delta);

	    // particles
	    m_particles.update();

	    // user callback
	    _render_callback(delta, timeline);

	    // possible unload in render callback
	    if (!m_data.is_primary_loaded())
	        return;

	    // rendering
	    m_scenes.update(timeline, delta);

	    // anchors
	    m_anchors.update_visibility();

	    m_main.frame();
	}

	function init_fps_counter() {
	    var fps_avg = 60;       // decent default value

	    var fps_frame_counter = 0;
	    var interval = cfg_def.fps_measurement_interval;
	    var interval_cb = cfg_def.fps_callback_interval;

	    var fps_counter = function(delta) {
	        // NOTE: fixes issues when delta=0
	        if (delta < 1/cfg_def.max_fps)
	            return;

	        fps_avg = m_util.smooth(1/delta, fps_avg, delta, interval);

	        // stays zero for disabled physics/FPS calculation
	        var phy_fps_avg = m_phy.get_fps();

	        fps_frame_counter = (fps_frame_counter + 1) % interval_cb;
	        if (fps_frame_counter == 0) {
	            _fps_callback(Math.round(fps_avg), phy_fps_avg);
	        }
	    };

	    return fps_counter;
	}

	/**
	 * Reset the engine.
	 * Unloads the scene and releases the engine's resources.
	 * @method module:main.reset
	 */
	exports.reset = function() {
	    m_data.unload(0);

	    m_data.reset();
	    m_ext.reset();
	    m_render.reset();
	    m_geom.reset();
	    m_textures.reset_mod();
	    m_shaders.reset();
	    m_debug.reset();
	    m_cont.reset();
	    m_data.reset();
	    m_cont.reset();
	    m_time.reset();
	    m_sfx.reset();

	    _last_abs_time = 0;

	    _pause_time = 0;
	    _resume_time = 0;

	    _fps_callback = function() {};
	    _fps_counter = function() {};

	    _render_callback = function() {};

	    _loop_cb.length = 0;

	    _gl = null;
	};

	/**
	 * Register one-time callback to return DataURL of rendered canvas element.
	 * @param {BlobURLCallback} callback BlobURL callback.
	 * @param {string} [format="image/png"] The image format ("image/png", "image/jpeg",
	 * "image/webp" and so on).
	 * @param {number} [quality=1.0] Number between 0 and 1 for types: "image/jpeg",
	 * "image/webp".
	 * @param {boolean} [auto_revoke=true] Automatically revoke blob object.
	 * If auto_revoke is false then application must revoke blob URL via the following call {@link https://developer.mozilla.org/en-US/docs/Web/API/URL/revokeObjectURL| URL.revokeObjectURL(blobURL)}.
	 */
	exports.canvas_data_url = function(callback, format, quality, auto_revoke) {
	    m_main.canvas_data_url(callback, format, quality, auto_revoke);
	};

	/**
	 * Check using device.
	 * @method module:main.detect_mobile
	 * @returns {boolean} Checking result.
	 */
	exports.detect_mobile = function() {
	    return m_compat.detect_mobile();
	};
	/**
	 * Append a callback to be executed every frame
	 * (even if the rendering is paused). Its purpose is to perform actions 
	 * non-related to the actual rendering, e.g html/css manipulation.
	 * This method allows registration of multiple callbacks.
	 * @method module:main.append_loop_cb
	 * @param {LoopCallback} callback Callback
	 */
	exports.append_loop_cb = function(callback) {
	    for (var i = 0; i < _loop_cb.length; i++)
	        if (_loop_cb[i] == callback)
	            return;
	    _loop_cb.push(callback);
	};
	/**
	 * Remove loop callback.
	 * @method module:main.remove_loop_cb
	 * @param {LoopCallback} callback Callback
	 */
	exports.remove_loop_cb = function(callback) {
	    for (var i = 0; i < _loop_cb.length; i++)
	        if (_loop_cb[i] == callback) {
	            _loop_cb.splice(i, 1);
	            break;
	        }
	};

	/**
	 * Return renderer info.
	 * @method module:main.get_renderer_info
	 * @returns {RendererInfo|Null} Renderer info.
	 */
	exports.get_renderer_info = function() {
	    var rinfo = m_ext.get_renderer_info();

	    if (!rinfo)
	        return null;

	    var vendor = _gl.getParameter(rinfo.UNMASKED_VENDOR_WEBGL);
	    var renderer = _gl.getParameter(rinfo.UNMASKED_RENDERER_WEBGL);

	    return {"vendor": vendor, "renderer": renderer};
	};

	}

	var main_factory = register("main", Main);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Physics module. Provides API to uranium.js physics engine. 
	 * @see https://www.blend4web.com/doc/en/physics.html
	 * @module physics
	 * @local CollisionCallback
	 * @local CollisionImpulseCallback
	 * @local RayTestCallback
	 * @local RayTestCallbackPosNorm
	 * @local CharacterMoveType
	 * @local NavmeshDistanceCallback
	 * @local NavmeshPathOptions
	 */
	function Physics(ns, exports) {

	/**
	 * Navmesh distance callback. Used to determine start and end polygon of navmesh
	 * @callback NavmeshDistanceCallback
	 * @param {Vec3} position Position to which we must calculate a distance
	 * @param {Vec3} centroid Center of current polygon
	 * @param {Uint32Array} vertex_ids Indices of polygon vertices
	 * @param {Array} vertices Vertex array
	 * @param {number} current_max_distance Current maximum distance
	 */

	var m_phy   = int_physics_factory(ns);
	var m_print = print_factory(ns);
	var m_util  = int_util_factory(ns);
	var m_nmesh = int_navmesh_factory(ns);

	/**
	 * Collision result callback.
	 * @callback CollisionCallback
	 * @param {boolean} result Collision result flag.
	 * @param {?Object3D} coll_obj The target collision object, i.e the object
	 * the source object collides with (null for no collision or when this object 
	 * is represented by collision material).
	 * @param {?Vec3} coll_pos Position of collision point.
	 * @param {?Vec3} coll_norm Normal of collision point.
	 * @param {?number} coll_dist Distance between collision points of colliding
	 * objects.
	 * @cc_externs coll_obj coll_pos coll_norm coll_dist
	 */

	/**
	 * Collision impulse result callback.
	 * @callback CollisionImpulseCallback
	 * @param {number} impulse Impulse applied on collision point.
	 */

	/**
	 * Ray test callback.
	 * @callback RayTestCallback
	 * @param {number} id Ray Test ID
	 * @param {number} hit_fract Fraction of ray length where hit has occurred (0-1)
	 * or -1 if there is no hit anymore
	 * @param {?Object3D} obj_hit Hit Object 3D
	 * @param {number} hit_time Time the hit happened.
	 * @cc_externs hit_fract obj_hit hit_time
	 */

	/**
	 * Ray test callback with additional position/normal.
	 * @callback RayTestCallbackPosNorm
	 * @param {number} id Ray Test ID
	 * @param {number} hit_fract Fraction of ray length where hit has occurred (0-1)
	 * or -1 if there is no hit anymore
	 * @param {?Object3D} obj_hit Hit Object 3D
	 * @param {number} hit_time Time the hit happened.
	 * @param {Vec3} hit_pos Hit position in world space
	 * @param {Vec3} hit_norm Hit normal in world space
	 * @cc_externs hit_fract obj_hit hit_time hit_pos hit_norm
	 */

	/**
	 * Configurable options of navmesh path.
	 * @typedef {Object} NavmeshPathOptions
	 * @property {number} [island=0] ID; see {@link module:physics.navmesh_get_island|physics.navmesh_get_island}
	 * @property {number} [allowed_distance=Number.MAX_VALUE] Distance limit from
	 * start/target position to navmesh
	 * @property {boolean} [do_not_pull_string=false] Returns centroids path instead of pulled string
	 * @property {boolean} [return_normals=false] Return path normals in PathInformation.
	 * @property {NavmeshDistanceCallback} [distance_to_closest] Callback for distance
	 * calculation to determine closest node
	 * @property {NavmeshDistanceCallback} [distance_to_farthest] Callback for distance
	 * calculation to determine farthest node
	 * @cc_externs island allowed_distance do_not_pull_string return_normals
	 * @cc_externs distance_to_closest distance_to_farthest
	 */

	/**
	 * Navmesh path information.
	 * @typedef {Object} PathInformation
	 * @property {Float32Array} positions Positions of path points - plane array of 
	 * Vec3-type positions
	 * @property {?Float32Array} normals Normals of path points - plane array of 
	 * Vec3-type normals
	 * @cc_externs positions normals
	 */

	/**
	 * Character's type of movement enum. One of CM_*.
	 * @typedef {number} CharacterMoveType
	 */

	/**
	 * The character's type of movement is "walk".
	 * @const {CharacterMoveType} module:physics.CM_WALK
	 */
	exports.CM_WALK = 0;
	/**
	 * The character's type of movement is "run".
	 * @const {CharacterMoveType} module:physics.CM_RUN
	 */
	exports.CM_RUN = 1;
	/**
	 * The character's type of movement is "climb".
	 * @const {CharacterMoveType} module:physics.CM_CLIMB
	 */
	exports.CM_CLIMB = 2;
	/**
	 * The character's type of movement is "fly".
	 * @const {CharacterMoveType} module:physics.CM_FLY
	 */
	exports.CM_FLY = 3;

	/**
	 * Enable physics simulation.
	 * @method module:physics.enable_simulation
	 * @param {Object3D} obj Object 3D
	 */
	exports.enable_simulation = function(obj) {
	    if (!m_phy.obj_has_physics(obj)) {
	        m_print.error_once("No physics for object " + obj.name);
	        return;
	    }
	    m_phy.enable_simulation(obj);
	};
	/**
	 * Disable physics simulation.
	 * @method module:physics.disable_simulation
	 * @param {Object3D} obj Object 3D
	 */
	exports.disable_simulation = function(obj) {
	    if (!m_phy.obj_has_physics(obj)) {
	        m_print.error_once("No physics for object " + obj.name);
	        return;
	    }
	    m_phy.disable_simulation(obj);
	};
	/**
	 * Check if the object has any physics
	 * @method module:physics.has_physics
	 * @param {Object3D} obj Object 3D
	 * @returns {boolean} Check result
	 */
	exports.has_physics = function(obj) {
	    return m_phy.obj_has_physics(obj);
	};
	/**
	 * Check if the object has any simulated physics
	 * @method module:physics.has_simulated_physics
	 * @param {Object3D} obj Object 3D
	 * @returns {boolean} Check result
	 */
	exports.has_simulated_physics = function(obj) {
	    return m_phy.has_simulated_physics(obj);
	};
	/**
	 * Check if the object has dynamic simulated physics
	 * @method module:physics.has_dynamic_physics
	 * @param {Object3D} obj Object 3D
	 * @returns {boolean} Check result
	 */
	exports.has_dynamic_physics = function(obj) {
	    return m_phy.has_dynamic_physics(obj);
	};
	/**
	 * Set the object's gravity.
	 * @method module:physics.set_gravity
	 * @param {Object3D} obj Object 3D
	 * @param {number} gravity Object gravity value along the Z axis.
	 * @deprecated [17.10] Use {@link module:physics.set_object_gravity} instead
	 */
	exports.set_gravity = function(obj, gravity) {
	    m_print.error_deprecated("set_gravity", "set_object_gravity");
	    if (!m_phy.obj_has_physics(obj)) {
	        m_print.error_once("No physics for object " + obj.name);
	        return;
	    }
	    // handling old behavior when positive gravity aligned with negative Z.
	    m_phy.set_gravity(obj, 0, 0, -gravity);
	};
	/**
	 * Set the object's gravity.
	 * @method module:physics.set_object_gravity
	 * @param {Object3D} obj Object 3D
	 * @param {Vec3} gravity Gravity vector.
	 * @example var m_phy = require("physics");
	 * var m_scenes = require("scenes");
	 *
	 * var my_cube = m_scenes.get_object_by_name("Cube");
	 * var gravity_vec = new Float32Array([0, 0, 1]);
	 * m_phy.set_object_gravity(my_cube, gravity_vec);
	 */
	exports.set_object_gravity = function(obj, gravity) {
	    if (!m_phy.obj_has_physics(obj)) {
	        m_print.error_once("No physics for object " + obj.name);
	        return;
	    }
	    m_phy.set_gravity(obj, gravity[0], gravity[1], gravity[2]);
	};
	/**
	 * Set the object's transform (for static/kinematic objects)
	 * @method module:physics.set_transform
	 * @param {Object3D} obj Object 3D
	 * @param {Vec3} trans Translation vector
	 * @param {Quat} quat Rotation quaternion
	 */
	exports.set_transform = function(obj, trans, quat) {
	    if (!m_phy.obj_has_physics(obj)) {
	        m_print.error_once("No physics for object " + obj.name);
	        return;
	    }
	    m_phy.set_transform(obj, trans, quat);
	};

	/**
	 * Sync the object's transform (for static/kinematic objects)
	 * @method module:physics.sync_transform
	 * @param {Object3D} obj Object 3D
	 */
	exports.sync_transform = function(obj) {
	    if (!m_phy.obj_has_physics(obj)) {
	        m_print.error_once("No physics for object " + obj.name);
	        return;
	    }
	    m_phy.sync_transform(obj);
	};

	/**
	 * Apply velocity to the object (in the local space)
	 * @method module:physics.apply_velocity
	 * @param {Object3D} obj Object 3D
	 * @param {number} vx_local Vx local space velocity
	 * @param {number} vy_local Vy local space velocity
	 * @param {number} vz_local Vz local space velocity 
	 */
	exports.apply_velocity = function(obj, vx_local, vy_local, vz_local) {
	    if (!m_phy.obj_has_physics(obj)) {
	        m_print.error_once("No physics for object " + obj.name);
	        return;
	    }
	    m_phy.apply_velocity(obj, vx_local, vy_local, vz_local);
	};
	/**
	 * Apply velocity to the object (in the world space)
	 * @method module:physics.apply_velocity_world
	 * @param {Object3D} obj Object 3D
	 * @param {number} vx Vx world space velocity
	 * @param {number} vy Vy world space velocity
	 * @param {number} vz Vz world space velocity
	 */
	exports.apply_velocity_world = function(obj, vx, vy, vz) {
	    if (!m_phy.obj_has_physics(obj)) {
	        m_print.error_once("No physics for object " + obj.name);
	        return;
	    }
	    m_phy.apply_velocity_world(obj, vx, vy, vz);
	};
	/**
	 * Apply a constant force to the object (in the local space).
	 * Pass zero values to remove applied force.
	 * @method module:physics.apply_force
	 * @param {Object3D} obj Object 3D
	 * @param {number} fx_local Fx force in the local space
	 * @param {number} fy_local Fy force in the local space
	 * @param {number} fz_local Fz force in the local space 
	 */
	exports.apply_force = function(obj, fx_local, fy_local, fz_local) {
	    if (!m_phy.obj_has_physics(obj)) {
	        m_print.error_once("No physics for object " + obj.name);
	        return;
	    }
	    m_phy.apply_force(obj, fx_local, fy_local, fz_local, false);
	};

	/**
	 * Apply a constant force to the object (in the world space).
	 * Pass zero values to remove applied force.
	 * @method module:physics.apply_force_world
	 * @param {Object3D} obj Object 3D
	 * @param {number} fx_world Fx force in the world space
	 * @param {number} fy_world Fy force in the world space
	 * @param {number} fz_world Fz force in the world space 
	 */
	exports.apply_force_world = function(obj, fx_world, fy_world, fz_world) {
	    if (!m_phy.obj_has_physics(obj)) {
	        m_print.error_once("No physics for object " + obj.name);
	        return;
	    }
	    m_phy.apply_force(obj, fx_world, fy_world, fz_world, true);
	};

	/**
	 * Apply constant torque to the object (in the local space).
	 * Pass zero values to remove applied torque.
	 * @method module:physics.apply_torque
	 * @param {Object3D} obj Object 3D
	 * @param {number} tx_local Tx torque
	 * @param {number} ty_local Ty torque
	 * @param {number} tz_local Tz torque
	 */
	exports.apply_torque = function(obj, tx_local, ty_local, tz_local) {
	    if (!m_phy.obj_has_physics(obj)) {
	        m_print.error_once("No physics for object " + obj.name);
	        return;
	    }
	    m_phy.apply_torque(obj, tx_local, ty_local, tz_local);
	};

	/**
	 * Set object's angular velocity.
	 * @method module:physics.set_angular_velocity
	 * @param {Object3D} obj Object 3D
	 * @param {number} av_x X projection of angular velocity in the local space
	 * @param {number} av_y Y projection of angular velocity in the local space
	 * @param {number} av_z Z projection of angular velocity in the local space
	 * @example var m_physics = require("physics");
	 *
	 * var obj = m_scenes.get_object_by_name("Cube");
	 * m_physics.set_angular_velocity(obj, 0.0, 0.0, 0.5);
	 */
	exports.set_angular_velocity = function(obj, av_x, av_y, av_z) {
	    if (!m_phy.obj_has_physics(obj)) {
	        m_print.error_once("No physics for object " + obj.name);
	        return;
	    }
	    m_phy.set_angular_velocity(obj, av_x, av_y, av_z);
	};
	/**
	 * Apply throttle to vehicle.
	 * @method module:physics.vehicle_throttle
	 * @param {Object3D} obj Object 3D
	 * @param {number} engine_force Engine force (-1..1)
	 */
	exports.vehicle_throttle = function(obj, engine_force) {
	    if (!m_phy.obj_has_physics(obj)) {
	        m_print.error_once("No physics for object " + obj.name);
	        return;
	    }

	    if (!m_phy.is_vehicle_chassis(obj) && !m_phy.is_vehicle_hull(obj))
	        m_print.error("Wrong object");

	    m_phy.vehicle_throttle(obj, m_util.clamp(engine_force, -1, 1));
	};
	/**
	 * Increment vehicle throttle.
	 * @method module:physics.vehicle_throttle_inc
	 * @param {Object3D} obj Object 3D
	 * @param {number} engine_force_inc Engine force increment (0..1)
	 * @param {number} dir Throttling direction -1,0,1
	 */
	exports.vehicle_throttle_inc = function(obj, engine_force_inc, dir) {
	    if (!m_phy.obj_has_physics(obj)) {
	        m_print.error_once("No physics for object " + obj.name);
	        return;
	    }

	    if (!m_phy.is_vehicle_chassis(obj) && !m_phy.is_vehicle_hull(obj))
	        m_print.error("Wrong object");

	    engine_force_inc = m_util.clamp(engine_force_inc, 0, 1);

	    var vehicle = obj.vehicle;

	    var force = vehicle.engine_force;

	    if (dir == -1 || dir == 1) {
	        force += dir * engine_force_inc;
	        force = Math.max(-1, Math.min(force, 1));
	    } else if (dir == 0 && force >= 0) {
	        force -= engine_force_inc;
	        force = Math.max(0, force);
	    } else if (dir == 0 && force < 0) {
	        force += engine_force_inc;
	        force = Math.min(0, force);
	    } else
	        m_print.error("Wrong steering direction");

	    m_phy.vehicle_throttle(obj, m_util.clamp(force, -1, 1));
	};
	/**
	 * Change vehicle steering.
	 * @method module:physics.vehicle_steer
	 * @param {Object3D} obj Object 3D
	 * @param {number} steering_value Steering value (-1..1)
	 */
	exports.vehicle_steer = function(obj, steering_value) {
	    if (!m_phy.obj_has_physics(obj)) {
	        m_print.error_once("No physics for object " + obj.name);
	        return;
	    }

	    if (!m_phy.is_vehicle_chassis(obj) && !m_phy.is_vehicle_hull(obj))
	        m_print.error("Wrong object");

	    m_phy.vehicle_steer(obj, m_util.clamp(steering_value, -1, 1));
	};
	/**
	 * Increment vehicle steering.
	 * @method module:physics.vehicle_steer_inc
	 * @param {Object3D} obj Object 3D
	 * @param {number} steering_value_inc Steering value increment (0..1)
	 * @param {number} dir Steering direction -1,0,1
	 */
	exports.vehicle_steer_inc = function(obj, steering_value_inc, dir) {
	    if (!m_phy.obj_has_physics(obj)) {
	        m_print.error_once("No physics for object " + obj.name);
	        return;
	    }

	    if (!m_phy.is_vehicle_chassis(obj) && !m_phy.is_vehicle_hull(obj))
	        m_print.error("Wrong object");

	    steering_value_inc = m_util.clamp(steering_value_inc, 0, 1);

	    var vehicle = obj.vehicle;

	    var steering = vehicle.steering;

	    if (dir == -1 || dir == 1) {
	        steering += dir * steering_value_inc;
	        steering = Math.max(-1, Math.min(steering, 1));
	    } else if (dir == 0 && steering >= 0) {
	        steering -= steering_value_inc;
	        steering = Math.max(0, steering);
	    } else if (dir == 0 && steering < 0) {
	        steering += steering_value_inc;
	        steering = Math.min(0, steering);
	    } else
	        m_print.error("Wrong steering direction");

	    m_phy.vehicle_steer(obj, m_util.clamp(steering, -1, 1));
	};
	/**
	 * Stop the vehicle by applying the brake force.
	 * @method module:physics.vehicle_brake
	 * @param {Object3D} obj Object 3D
	 * @param {number} brake_force Brake force (0..1)
	 */
	exports.vehicle_brake = function(obj, brake_force) {
	    if (!m_phy.obj_has_physics(obj)) {
	        m_print.error_once("No physics for object " + obj.name);
	        return;
	    }

	    if (!m_phy.is_vehicle_chassis(obj) && !m_phy.is_vehicle_hull(obj))
	        m_print.error("Wrong object");

	    m_phy.vehicle_brake(obj, m_util.clamp(brake_force, 0, 1));
	};
	/**
	 * Increment the brake force
	 * @method module:physics.vehicle_brake_inc
	 * @param {Object3D} obj Object 3D
	 * @param {number} brake_force_inc Brake force increment (-1..1)
	 */
	exports.vehicle_brake_inc = function(obj, brake_force_inc) {
	    if (!m_phy.obj_has_physics(obj)) {
	        m_print.error_once("No physics for object " + obj.name);
	        return;
	    }

	    if (!m_phy.is_vehicle_chassis(obj) && !m_phy.is_vehicle_hull(obj))
	        m_print.error("Wrong object");

	    brake_force_inc = m_util.clamp(brake_force_inc, -1, 1);

	    var vehicle = obj.vehicle;

	    var brake_force = vehicle.brake_force;

	    brake_force += brake_force * brake_force_inc;
	    m_phy.vehicle_brake(obj, m_util.clamp(brake_force, 0, 1));
	};
	/**
	 * Check if the given object is a vehicle chassis.
	 * @method module:physics.is_vehicle_chassis
	 * @param {Object3D} obj Object 3D
	 * @returns {boolean} Checking result.
	 */
	exports.is_vehicle_chassis = function(obj) {
	    return m_phy.is_vehicle_chassis(obj);
	};
	/**
	 * Check if the given object is a vehicle hull.
	 * @method module:physics.is_vehicle_hull
	 * @param {Object3D} obj Object 3D
	 * @returns {boolean} Checking result.
	 */
	exports.is_vehicle_hull = function(obj) {
	    return m_phy.is_vehicle_hull(obj);
	};
	/**
	 * Get the vehicle name.
	 * @method module:physics.get_vehicle_name
	 * @param {Object3D} obj Object 3D
	 * @returns {?string} Vehicle name.
	 */
	exports.get_vehicle_name = function(obj) {
	    if (!m_phy.obj_has_physics(obj)) {
	        m_print.error_once("No physics for object " + obj.name);
	        return null;
	    }
	    if (m_phy.is_vehicle_chassis(obj) || m_phy.is_vehicle_hull(obj))
	        return obj.vehicle_settings.name;
	    else {
	        m_print.error("Wrong object");
	        return null;
	    }
	};
	/**
	 * Get the vehicle's throttle value.
	 * @method module:physics.get_vehicle_throttle
	 * @param {Object3D} obj Object 3D
	 * @returns {?number} Throttle value.
	 */
	exports.get_vehicle_throttle = function(obj) {
	    if (!m_phy.obj_has_physics(obj)) {
	        m_print.error_once("No physics for object " + obj.name);
	        return null;
	    }
	    if (m_phy.is_vehicle_chassis(obj) || m_phy.is_vehicle_hull(obj))
	        return obj.vehicle.engine_force;
	    else {
	        m_print.error("Wrong object");
	        return null;
	    }
	};
	/**
	 * Get the vehicle's steering value.
	 * @method module:physics.get_vehicle_steering
	 * @param {Object3D} obj Object 3D
	 * @returns {number} Steering value
	 */
	exports.get_vehicle_steering = function(obj) {
	    if (!m_phy.obj_has_physics(obj)) {
	        m_print.error_once("No physics for object " + obj.name);
	        return 0;
	    }
	    if (m_phy.is_vehicle_chassis(obj) || m_phy.is_vehicle_hull(obj))
	        return obj.vehicle.steering;
	    else
	        m_print.error("Wrong object");

	    return 0;
	};
	/**
	 * Get the vehicle's brake force.
	 * @method module:physics.get_vehicle_brake
	 * @param {Object3D} obj Object 3D
	 * @returns {number} Brake value
	 */
	exports.get_vehicle_brake = function(obj) {
	    if (!m_phy.obj_has_physics(obj)) {
	        m_print.error_once("No physics for object " + obj.name);
	        return 0;
	    }
	    if (m_phy.is_vehicle_chassis(obj) || m_phy.is_vehicle_hull(obj))
	        return obj.vehicle.brake_force;
	    else
	        m_print.error("Wrong object");

	    return 0;
	};
	/**
	 * Get the vehicle speed in km/h.
	 * @method module:physics.get_vehicle_speed
	 * @param {Object3D} obj Object 3D
	 * @returns {number} Vehicle speed
	 */
	exports.get_vehicle_speed = function(obj) {
	    if (!m_phy.obj_has_physics(obj)) {
	        m_print.error_once("No physics for object " + obj.name);
	        return 0;
	    }
	    if (m_phy.is_vehicle_chassis(obj) || m_phy.is_vehicle_hull(obj))
	        return m_phy.get_vehicle_speed(obj);
	    else
	        m_print.error("Wrong object");

	    return 0;
	};
	/**
	 * Check if the given object is a character.
	 * @method module:physics.is_character
	 * @param {Object3D} obj Object 3D
	 * @returns {boolean} Check result
	 */
	exports.is_character = function(obj) {
	    return m_phy.has_character_physics(obj);
	};
	/**
	 * Move the character in the corresponding direction.
	 * @method module:physics.set_character_move_dir
	 * @param {Object3D} obj Object 3D
	 * @param {number} forw Apply forward speed
	 * @param {number} side Apply side speed
	 */
	exports.set_character_move_dir = function(obj, forw, side) {
	    if (!m_phy.obj_has_physics(obj)) {
	        m_print.error_once("No physics for object " + obj.name);
	        return;
	    }
	    m_phy.set_character_move_dir(obj, forw, side);
	};
	/**
	 * Set the character moving type.
	 * @method module:physics.set_character_move_type
	 * @param {Object3D} obj Object 3D
	 * @param {CharacterMoveType} type Character moving type (one of CM_*).
	 */
	exports.set_character_move_type = function(obj, type) {
	    if (!m_phy.obj_has_physics(obj)) {
	        m_print.error_once("No physics for object " + obj.name);
	        return;
	    }
	    m_phy.set_character_move_type(obj, type);
	};

	/**
	 * Set the character's walk speed.
	 * @method module:physics.set_character_walk_velocity
	 * @param {Object3D} obj Object 3D
	 * @param {number} velocity Walking velocity
	 */
	exports.set_character_walk_velocity = function(obj, velocity) {
	    if (!m_phy.obj_has_physics(obj)) {
	        m_print.error_once("No physics for object " + obj.name);
	        return;
	    }
	    m_phy.set_character_walk_velocity(obj, velocity);
	};
	/**
	 * Set the character's run speed.
	 * @method module:physics.set_character_run_velocity
	 * @param {Object3D} obj Object 3D
	 * @param {number} velocity Running velocity
	 */
	exports.set_character_run_velocity = function(obj, velocity) {
	    if (!m_phy.obj_has_physics(obj)) {
	        m_print.error_once("No physics for object " + obj.name);
	        return;
	    }
	    m_phy.set_character_run_velocity(obj, velocity);
	};
	/**
	 * Set the character's fly speed.
	 * @method module:physics.set_character_fly_velocity
	 * @param {Object3D} obj Object 3D
	 * @param {number} velocity Flying velocity
	 */
	exports.set_character_fly_velocity = function(obj, velocity) {
	    if (!m_phy.obj_has_physics(obj)) {
	        m_print.error_once("No physics for object " + obj.name);
	        return;
	    }
	    m_phy.set_character_fly_velocity(obj, velocity);
	};
	/**
	 * Make the character jump
	 * @method module:physics.character_jump
	 * @param {Object3D} obj Object 3D
	 */
	exports.character_jump = function(obj) {
	    if (!m_phy.obj_has_physics(obj)) {
	        m_print.error_once("No physics for object " + obj.name);
	        return;
	    }
	    m_phy.character_jump(obj);
	};
	/**
	 * Increment the character rotation
	 * @method module:physics.character_rotation_inc
	 * @param {Object3D} obj Object 3D
	 * @param {number} h_angle Angle (in radians) in horizontal plane
	 * @param {number} v_angle Angle (in radians) in vertical plane
	 */
	exports.character_rotation_inc = function(obj, h_angle, v_angle) {
	    if (!m_phy.obj_has_physics(obj)) {
	        m_print.error_once("No physics for object " + obj.name);
	        return;
	    }
	    m_phy.character_rotation_inc(obj, h_angle, v_angle);
	};
	/**
	 * Set the character rotation in horizontal and vertical planes
	 * @method module:physics.set_character_rotation
	 * @param {Object3D} obj Object 3D
	 * @param {number} angle_h Angle (in radians) in horizontal plane
	 * @param {number} angle_v Angle (in radians) in vertical plane
	 */
	exports.set_character_rotation = function(obj, angle_h, angle_v) {
	    if (!m_phy.obj_has_physics(obj)) {
	        m_print.error_once("No physics for object " + obj.name);
	        return;
	    }
	    m_phy.set_character_rotation(obj, angle_h, angle_v);
	};
	/**
	 * Set the character vertical rotation
	 * @method module:physics.set_character_rotation_v
	 * @param {Object3D} obj Object 3D
	 * @param {number} angle Angle (in radians) in vertical plane
	 */
	exports.set_character_rotation_v = function(obj, angle) {
	    if (!m_phy.obj_has_physics(obj)) {
	        m_print.error_once("No physics for object " + obj.name);
	        return;
	    }
	    m_phy.set_character_rotation_v(obj, angle);
	};
	/**
	 * Set the character horizontal rotation
	 * @method module:physics.set_character_rotation_h
	 * @param {Object3D} obj Object 3D
	 * @param {number} angle Angle (in radians) in horizontal plane
	 */
	exports.set_character_rotation_h = function(obj, angle) {
	    if (!m_phy.obj_has_physics(obj)) {
	        m_print.error_once("No physics for object " + obj.name);
	        return;
	    }
	    m_phy.set_character_rotation_h(obj, angle);
	};
	/**
	 * Set the vertical angle of the moving direction for a character. Applies only 
	 * in FLYING and SWIMMING mode. Used to control the moving direction from the 
	 * camera vertical angle.
	 * @method module:physics.set_character_vert_move_dir_angle
	 * @param {Object3D} obj Character object.
	 * @param {number} angle Angle (in radians) in vertical plane
	 * @example
	 * var m_cam = require("camera");
	 * var m_phys = require("physics");
	 * var m_scenes = require("scenes");
	 * 
	 * var _vec2_tmp = new Float32Array(2);
	 *
	 * var char = m_scenes.get_first_character();
	 * var camera = m_scenes.get_active_camera();
	 * var angles = m_cam.get_camera_angles_char(camera, _vec2_tmp);
	 *
	 * m_phys.set_character_vert_move_dir_angle(char, angles[1]);
	 */
	exports.set_character_vert_move_dir_angle = function(obj, angle) {
	    if (!m_phy.obj_has_physics(obj)) {
	        m_print.error_once("No physics for object " + obj.name);
	        return;
	    }
	    m_phy.set_character_vert_move_dir_angle(obj, angle);
	};
	/**
	 * Append a new async collision test to the given object.
	 * @method module:physics.append_collision_test
	 * @param {Object3D} obj_src Object 3D
	 * @param {?string} collision_id Collision ID, pass "ANY" or null for any collision ID.
	 * @param {CollisionCallback} callback Collision callback
	 * @param {boolean} [calc_pos_norm=false] Pass collision point/normal/distance in callback
	 */
	exports.append_collision_test = function(obj_src, collision_id, callback,
	        calc_pos_norm) {
	    if (!m_phy.obj_has_physics(obj_src)) {
	        m_print.error_once("No physics for object " + obj_src.name);
	        return;
	    }

	    collision_id = collision_id || "ANY";

	    calc_pos_norm = calc_pos_norm || false;
	    m_phy.append_collision_test(obj_src, collision_id, callback, calc_pos_norm);
	};
	/**
	 * Remove the collision test from the given object.
	 * @method module:physics.remove_collision_test
	 * @param {Object3D} obj Object 3D.
	 * @param {?string} collision_id Collision ID, pass "ANY" or null for any collision ID.
	 * @param {CollisionCallback} callback Collision callback.
	 */
	exports.remove_collision_test = function(obj, collision_id, callback) {
	    if (!m_phy.obj_has_physics(obj)) {
	        m_print.error_once("No physics for object " + obj.name);
	        return;
	    }

	    collision_id = collision_id || "ANY";

	    m_phy.remove_collision_test(obj, collision_id, callback);
	};
	/**
	 * Apply a new async collision impulse test to the given object.
	 * @method module:physics.apply_collision_impulse_test
	 * @param {Object3D} obj Object 3D
	 * @param {CollisionImpulseCallback} callback Collision impulse test callback.
	 */
	exports.apply_collision_impulse_test = function(obj, callback) {
	    if (!m_phy.obj_has_physics(obj)) {
	        m_print.error_once("No physics for object " + obj.name);
	        return;
	    }
	    m_phy.apply_collision_impulse_test(obj, callback);
	};
	/**
	 * Remove the collision impulse test from the given object.
	 * @method module:physics.clear_collision_impulse_test
	 * @param {Object3D} obj Object 3D
	 */
	exports.clear_collision_impulse_test = function(obj) {
	    if (!m_phy.obj_has_physics(obj)) {
	        m_print.error_once("No physics for object " + obj.name);
	        return;
	    }
	    m_phy.clear_collision_impulse_test(obj);
	};
	/**
	 * Append a new async ray test.
	 * @method module:physics.append_ray_test
	 * @param {?Object3D} obj_src Source object, pass a non-null value to perform ray casting
	 * in object space, e.g. from/to vectors specified in object space.
	 * @param {Vec3} from From vector
	 * @param {Vec3} to To vector
	 * @param {?string} collision_id Collision ID, pass "ANY" or null for any collision ID.
	 * @param {RayTestCallback} callback Ray Test callback
	 * @param {boolean} [autoremove=false] Automatically remove test after ray casting.
	 * @returns {number} Ray Test ID
	 */
	exports.append_ray_test = function(obj_src, from, to, collision_id, callback, 
	        autoremove) {

	    obj_src = obj_src || null;

	    if (obj_src != null && !m_phy.obj_has_physics(obj_src)) {
	        m_print.error_once("No physics for object " + obj_src.name);
	        return 0;
	    }

	    collision_id = collision_id || "ANY";
	    autoremove = autoremove || false;

	    var calc_all_hits = false;
	    var calc_pos_norm = false;
	    var ign_src_rot = false;

	    return m_phy.append_ray_test(obj_src, from, to, collision_id, callback, 
	            autoremove, calc_all_hits, calc_pos_norm, ign_src_rot);
	};

	/**
	 * Append a new async ray test (extended version).
	 * @method module:physics.append_ray_test_ext
	 * @param {?Object3D} obj_src Source object, pass a non-null value to perform ray casting
	 * in object space, e.g. from/to vectors specified in object space
	 * @param {Vec3} from From vector
	 * @param {Vec3} to To vector
	 * @param {?string} collision_id Collision ID, pass "ANY" or null for any collision ID.
	 * @param {RayTestCallback|RayTestCallbackPosNorm} callback Ray Test callback
	 * @param {boolean} [autoremove=false] Automatically remove test after ray casting.
	 * @param {boolean} [calc_all_hits=false] Test for all possible objects along the ray or
	 * just for closest object
	 * @param {boolean} [calc_pos_norm=false] Calculate and return hit point's position/normal in
	 * callback
	 * @param {boolean} [ign_src_rot=false] Ignore rotation of source object
	 * @returns {number} Ray Test ID
	 */
	exports.append_ray_test_ext = function(obj_src, from, to, collision_id, callback, 
	        autoremove, calc_all_hits, calc_pos_norm, ign_src_rot) {

	    obj_src = obj_src || null;

	    if (obj_src != null && !m_phy.obj_has_physics(obj_src)) {
	        m_print.error_once("No physics for object " + obj_src.name);
	        return 0;
	    }

	    collision_id = collision_id || "ANY";
	    autoremove = autoremove || false;
	    calc_all_hits = calc_all_hits || false;
	    calc_pos_norm = calc_pos_norm || false;
	    ign_src_rot = ign_src_rot || false;

	    return m_phy.append_ray_test(obj_src, from, to, collision_id, callback,
	            autoremove, calc_all_hits, calc_pos_norm, ign_src_rot);
	};
	/**
	 * Remove ray test.
	 * @method module:physics.remove_ray_test
	 * @param {number} id Ray Test ID
	 */
	exports.remove_ray_test = function(id) {
	    if (!m_phy.is_ray_test(id)) {
	        m_print.error("Wrong ray test ID");
	        return;
	    }

	    m_phy.remove_ray_test(id);
	};

	/**
	 * Change from/to vectors for the given ray test.
	 * @method module:physics.change_ray_test_from_to
	 * @param {number} id Ray Test ID
	 * @param {Vec3} from New from vector
	 * @param {Vec3} to New to vector
	 */
	exports.change_ray_test_from_to = function(id, from, to) {
	    if (!m_phy.is_ray_test(id)) {
	        m_print.error("Wrong ray test ID");
	        return;
	    }

	    m_phy.change_ray_test_from_to(id, from, to);
	};


	/**
	 * Apply physics constraint.
	 * @method module:physics.apply_constraint
	 * @param {string} pivot_type Pivot type
	 * @param {Object3D} obj_a Object 3D A
	 * @param {Vec3} trans_a Translation of pivot frame relative to A
	 * @param {Quat} quat_a Rotation of pivot frame relative to A
	 * @param {Object3D} obj_b Object 3D B
	 * @param {Vec3} trans_b Translation of pivot frame relative to B
	 * @param {Quat} quat_b Rotation of pivot frame relative to B
	 * @param {ConstraintLimits} limits Object containing constraint limits
	 * @param {Float32Array} [stiffness=null] 6-dimensional vector with constraint stiffness
	 * @param {Float32Array} [damping=null] 6-dimensional vector with constraint damping
	 */
	exports.apply_constraint = function(pivot_type, obj_a, trans_a, quat_a,
	        obj_b, trans_b, quat_b, limits, stiffness, damping) {

	    if (!m_phy.obj_has_physics(obj_a) || !m_phy.obj_has_physics(obj_b)) {
	        m_print.error("Wrong objects");
	        return;
	    }

	    m_phy.apply_constraint(pivot_type, obj_a, trans_a, quat_a,
	        obj_b, trans_b, quat_b, limits, stiffness, damping);
	};
	/**
	 * Remove physics constraint.
	 * constraint identified by object A from apply_constraint function
	 * @method module:physics.remove_constraint
	 * @param {Object3D} obj_a Object A.
	 */
	exports.clear_constraint = function(obj_a) {
	    if (!m_phy.obj_has_physics(obj_a) || !m_phy.has_constraint(obj_a)) {
	        m_print.error("Wrong object");
	        return;
	    }

	    m_phy.clear_constraint(obj_a);
	};
	/**
	 * Pull object A to constraint pivot with object B.
	 * @method module:physics.pull_to_constraint_pivot
	 * @param {Object3D} obj_a Object 3D A
	 * @param {Vec3} trans_a Translation of pivot frame relative to A
	 * @param {Quat} quat_a Rotation of pivot frame relative to A
	 * @param {Object3D} obj_b Object 3D B
	 * @param {Vec3} trans_b Translation of pivot frame relative to B
	 * @param {Quat} quat_b Rotation of pivot frame relative to B
	 */
	exports.pull_to_constraint_pivot = function(obj_a, trans_a, quat_a,
	        obj_b, trans_b, quat_b) {

	    if (!m_phy.obj_has_physics(obj_a) || !m_phy.obj_has_physics(obj_b)) {
	        m_print.error("Wrong objects");
	        return;
	    }
	    m_phy.pull_to_constraint_pivot(obj_a, trans_a, quat_a,
	        obj_b, trans_b, quat_b);
	};

	function distance_to_closest_default(position, centroid, vertex_ids, vertices,
	        current_max_distance) {
	    return m_util.dist_to_triange(position, vertices[vertex_ids[0]],
	            vertices[vertex_ids[1]], vertices[vertex_ids[2]]);
	}

	// NOTE: don't remove this function.
	// function distance_to_closest_default(position, centroid, vertex_ids, vertices,
	//         current_max_distance) {
	//     m_vec3.subtract(position, centroid, _vec3_tmp);
	//     return m_vec3.dot(_vec3_tmp, _vec3_tmp);
	// }

	function distance_to_farthest_default(position, centroid, vertex_ids, vertices,
	        current_max_distance) {
	    var distance = Math.abs(position[2] - centroid[2]);
	    if (distance < current_max_distance &&
	            m_nmesh.is_vector_in_poly(position, vertex_ids, vertices))
	        return distance;
	    else
	        return Number.MAX_VALUE;
	}

	/**
	 * Get the id of a closest navmesh island(group)
	 * @method module:physics.navmesh_get_island
	 * @param {Object3D} navmesh_obj Navigation mesh object
	 * @param {Vec3} position Path start position
	 * @param {?NavmeshDistanceCallback} distance_to_closest Callback for distance
	 * calculation to determine the closest node. If null then the default function will 
	 * be used. It calculates the distance from a point to a triangle in the 3D space.
	 * @returns {number} island ID
	 * @example 
	 * var m_phys = require("physics");
	 * var m_scenes = require("scenes");
	 *
	 * var start_point = new Float32Array([5, 2, -7]);
	 * var end_point = new Float32Array([-2, 0, 3]);
	 * var navmesh_obj = m_scenes.get_object_by_name("navmesh");
	 *
	 * var island_id = m_phys.navmesh_get_island(navmesh_obj, start_point);
	 * var path = m_phys.navmesh_find_path(navmesh_obj, start_point, end_point, { island: island_id });
	 */
	exports.navmesh_get_island = navmesh_get_island;
	function navmesh_get_island(navmesh_obj, position,
	        distance_to_closest) {
	    if (!distance_to_closest)
	        distance_to_closest = distance_to_closest_default;

	    if (!m_phy.obj_has_physics(navmesh_obj)) {
	        m_print.error_once("No physics for object " + navmesh_obj.name);
	        return;
	    }

	    var navmesh = navmesh_obj.physics.navmesh;

	    if (!navmesh) {
	        m_print.error(navmesh_obj.name + " is not a navigation mesh object");
	        return null;
	    }
	    return m_nmesh.navmesh_get_island(navmesh, position, distance_to_closest);
	}

	/**
	 * Find path between start_pos and dest_pos, return flat array containing
	 * positions of path.
	 * @method module:physics.navmesh_find_path
	 * @param {Object3D} navmesh_obj Navigation mesh object
	 * @param {Vec3} start_pos Start position
	 * @param {Vec3} dest_pos Target position
	 * @param {NavmeshPathOptions} [options={}] Configurable options of navmesh path
	 * @returns {?PathInformation} Path information or null if path does not exist
	 * @example 
	 * var m_phys = require("physics");
	 * var m_scenes = require("scenes");
	 *
	 * var start_point = new Float32Array([5, 2, -7]);
	 * var end_point = new Float32Array([-2, 0, 3]);
	 * var navmesh_obj = m_scenes.get_object_by_name("navmesh");
	 *
	 * var island_id = m_phys.navmesh_get_island(navmesh_obj, start_point);
	 * var path = m_phys.navmesh_find_path(navmesh_obj, start_point, end_point, { island: island_id });
	 */
	exports.navmesh_find_path = function (navmesh_obj, start_pos, dest_pos, options) {
	    if (!m_phy.obj_has_physics(navmesh_obj)) {
	        m_print.error_once("No physics for object " + navmesh_obj.name);
	        return;
	    }
	    var navmesh = navmesh_obj.physics.navmesh;
	    if (!navmesh) {
	        m_print.error(navmesh_obj.name + " is not a navigation mesh object");
	        return null;
	    }
	    options = options || {};
	    var nav_options = {};

	    nav_options.do_not_pull_string = Boolean(options.do_not_pull_string);

	    nav_options.distance_to_closest = options.distance_to_closest ||
	            distance_to_closest_default;

	    nav_options.distance_to_farthest = options.distance_to_farthest ||
	            distance_to_farthest_default;

	    nav_options.island = options.island || 0;

	    nav_options.allowed_distance = options.allowed_distance || Number.MAX_VALUE;

	    nav_options.return_normals = options.return_normals || false;

	    return m_nmesh.navmesh_find_path(navmesh, start_pos, dest_pos, nav_options);
	};
	}

	var physics_factory = register("physics", Physics);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Screen API
	 * The API is used to manage content on the screen: fullscreen, HMD, HUD.
	 * @module screen
	 */
	function Screen(ns, exports) {

	var m_cam   = int_camera_factory(ns);
	var m_cont  = int_container_factory(ns);
	var m_cfg   = int_config_factory(ns);
	var m_hud   = int_hud_factory(ns);
	var m_input = int_input_factory(ns);
	var m_main  = int_main_factory(ns);
	var m_obj_util = int_obj_util_factory(ns);
	var m_print = print_factory(ns);
	var m_scs   = int_scenes_factory(ns);
	var m_vec4  = vec4_factory(ns);

	var _vec4_tmp = m_vec4.create();
	var _vec4_tmp2 = m_vec4.create();

	var _splited_screen = false;

	var _exit_cb = function() {};
	var _vr_present_change_cb = function() {};

	var cfg_dbg = m_cfg.debug_subs;

	// TODO: fix API doc of draw_mixer_strip function. Add information about id,
	// is_active, slot, params, active_param, mute, solo params.

	/**
	 * Draw the mixer strip.
	 * Used by mixer addon.
	 * @method module:screen.draw_mixer_strip
	 */
	exports.draw_mixer_strip = m_hud.draw_mixer_strip;

	/**
	 * Plot the array.
	 * @method module:screen.plot_array
	 * @param {string} header Plot header
	 * @param {number} slot Slot number
	 * @param {Float32Array} arr Array
	 * @param {number} arg_min Minimum plot argument value
	 * @param {number} arg_max Maximum plot argument value
	 * @param {number} val_min Minimum plot value
	 * @param {number} val_max Maximum plot value
	 */
	exports.plot_array = m_hud.plot_array;

	exports.request_fullscreen = request_fullscreen;
	/**
	 * Request fullscreen mode, i.e. presenting element entire to a screen.
	 * It is better to use
	 * {@link module:screen.request_fullscreen_hmd|request_fullscreen_hmd} for
	 * presenting VR content on head-mounted display.
	 * Security issues: execute by user event.
	 * @method module:screen.request_fullscreen
	 * @param {HTMLElement} [elem=Canvas container element] HTML element.
	 * @param {FullscreenEnabledCallback} [enabled_cb] Enabled callback.
	 * @param {FullscreenDisabledCallback} [disabled_cb] Disabled callback.
	 */
	function request_fullscreen(elem, enabled_cb, disabled_cb) {
	    elem = elem || m_cont.get_container();
	    enabled_cb = enabled_cb || function() {};
	    disabled_cb = disabled_cb || function() {};

	    function on_fullscreen_change() {
	        if (document.fullscreenElement === elem ||
	                document.webkitFullscreenElement === elem ||
	                document.mozFullScreenElement === elem ||
	                document.webkitIsFullScreen ||
	                document.msFullscreenElement === elem) {
	            //m_print.log("Fullscreen enabled");
	            enabled_cb();
	        } else {
	            document.removeEventListener("fullscreenchange",
	                    on_fullscreen_change, false);
	            document.removeEventListener("webkitfullscreenchange",
	                    on_fullscreen_change, false);
	            document.removeEventListener("mozfullscreenchange",
	                    on_fullscreen_change, false);
	            document.removeEventListener("MSFullscreenChange",
	                    on_fullscreen_change, false);
	            //m_print.log("Fullscreen disabled");
	            disabled_cb();
	        }
	    }

	    document.addEventListener("fullscreenchange", on_fullscreen_change, false);
	    document.addEventListener("webkitfullscreenchange", on_fullscreen_change, false);
	    document.addEventListener("mozfullscreenchange", on_fullscreen_change, false);
	    document.addEventListener("MSFullscreenChange", on_fullscreen_change, false);

	    elem.requestFullScreen = elem.requestFullScreen ||
	            elem.webkitRequestFullScreen || elem.mozRequestFullScreen
	            || elem.msRequestFullscreen;
	    if (elem.requestFullScreen)
	        elem.requestFullScreen();
	    else
	        m_print.error("B4W App: request fullscreen method is not supported");
	}

	exports.exit_fullscreen = exit_fullscreen;
	/**
	 * Exit fullscreen mode.
	 * @method module:screen.exit_fullscreen
	 */
	function exit_fullscreen() {

	    var exit_fs = document.exitFullscreen || document.webkitExitFullscreen ||
	            document.mozCancelFullScreen || document.msExitFullscreen;

	    if (typeof exit_fs != "function")
	        m_print.error("B4W App: exit fullscreen method is not supported");

	    exit_fs.apply(document);
	}

	/**
	 * Check whether fullscreen mode is available.
	 * @method module:screen.check_fullscreen
	 * @returns {boolean} Result of the check.
	 */
	exports.check_fullscreen = m_input.check_fullscreen;

	/**
	 * Request HMD fullscreen mode. Use the function for represent VR content
	 * on a head-mounted display.
	 * The function requires using of a browser supporting WebVR API
	 * or a mobile browser supporting Fullscreen API.
	 * Security issues: execute by user event.
	 * @method module:screen.request_fullscreen_hmd
	 * @param {HTMLElement} [element=Canvas container element] HTML element.
	 * @param {GenericCallback} [enabled_cb] The callback will be called right
	 * after switching HMD fullscreen mode on.
	 * @param {GenericCallback} [disabled_cb] The callback will be called right
	 * after switching HMD fullscreen mode off.
	 * @example
	 * var m_input = require("input");
	 * var m_screen = require("screen");
	 * m_input.add_click_listener(document.body, function() {
	 *     m_screen.request_fullscreen_hmd();
	 * });
	 */
	exports.request_fullscreen_hmd = function(element, enabled_cb, disabled_cb) {
	    if (!m_cfg.get("stereo") == "HMD" &&
	            !(m_cfg.get("stereo") == "NONE" && m_cfg.get("is_mobile_device")))
	        return;

	    var hmd_device = m_input.get_device_by_type_element(m_input.DEVICE_HMD);
	    if (hmd_device &&
	            m_input.get_value_param(hmd_device, m_input.HMD_WEBVR_TYPE) & m_input.HMD_WEBVR1) {
	        var webvr_display = hmd_device.webvr_display;
	        if (webvr_display && !webvr_display.isPresenting) {

	            enabled_cb = enabled_cb || function() {};
	            disabled_cb = disabled_cb || function() {};

	            _vr_present_change_cb = function() {
	                if (webvr_display.isPresenting)
	                    enabled_cb();
	                else {
	                    window.removeEventListener('vrdisplaypresentchange', _vr_present_change_cb);
	                    disabled_cb();
	                }
	            };
	            window.addEventListener('vrdisplaypresentchange', _vr_present_change_cb, false);

	            var capabilities = webvr_display.capabilities;
	            if (!capabilities.canPresent)
	                m_print.error("HMD fullscreen request failed.");
	            else {
	                var canvas = m_cont.get_canvas();
	                webvr_display.requestPresent([{source: canvas}]).then(function () {
	                    // TODO: add some logic
	                }, function () {
	                    m_print.error("HMD fullscreen request failed.");
	                });
	            }
	        }
	    } else
	        request_fullscreen(element, enabled_cb, disabled_cb);

	};

	/**
	 * Exit HMD fullscreen mode.
	 * @method module:screen.exit_fullscreen_hmd
	 */
	exports.exit_fullscreen_hmd = function() {
	    if (!m_cfg.get("stereo") == "HMD" &&
	            !(m_cfg.get("stereo") == "NONE" && m_cfg.get("is_mobile_device")))
	        return;

	    var hmd_device = m_input.get_device_by_type_element(m_input.DEVICE_HMD);
	    if (hmd_device &&
	            m_input.get_value_param(hmd_device, m_input.HMD_WEBVR_TYPE) & m_input.HMD_WEBVR1) {
	        var webvr_display = hmd_device.webvr_display;
	        if (webvr_display && webvr_display.isPresenting) {
	            webvr_display.exitPresent();
	            m_cont.resize_to_container(true);
	        }
	    } else
	        exit_fullscreen();
	};

	/**
	 * Check whether HMD fullscreen mode is available.
	 * @method module:screen.check_fullscreen_hmd
	 * @returns {boolean} The result of the checking.
	 */
	exports.check_fullscreen_hmd = function() {
	    var hmd_device = m_input.get_device_by_type_element(m_input.DEVICE_HMD);
	    var is_webvr_1 = m_input.get_value_param(hmd_device, m_input.HMD_WEBVR_TYPE) & m_input.HMD_WEBVR1;
	    if (hmd_device &&
	            (is_webvr_1 && hmd_device.webvr_display || !is_webvr_1 && m_input.check_fullscreen()))
	        return true;
	    return false;
	};

	exports.request_split_screen = request_split_screen;
	/**
	 * Request "split screen" mode, which represent rendering two eyes suitable
	 * for head-mounted displays.
	 * The function requires setting the "stereo" config to "HMD"
	 * {see @link module:config}, using a browser supporting WebVR API
	 * or a mobile browser.
	 * @method module:screen.request_split_screen
	 * @param {GenericCallback} [enter_cb] The callback will be called right
	 * after turning split screen mode on.
	 * @param {GenericCallback} [exit_cb] The callback will be called right
	 * after turning split screen mode off.
	 * @example
	 * var m_app = require("app");
	 * var m_screen = require("screen");
	 * exports.init = function() {
	 *     m_app.init({
	 *         // . . .
	 *         stereo: "HMD"
	 *    });
	 * }
	 *
	 * m_screen.request_split_screen();
	 */
	function request_split_screen(enter_cb, exit_cb) {
	    var hmd_device = m_input.get_device_by_type_element(m_input.DEVICE_HMD);
	    if (!hmd_device)
	        return false;

	    if (_splited_screen)
	        return true;

	    // _exit_cb will be called in the exit_split_screen function.
	    _exit_cb = exit_cb;

	    if (m_scs.check_active()) {
	         var camobj = m_scs.get_camera(m_scs.get_active());
	         if (!camobj)
	             return;
	    } else
	        return;

	    if (hmd_device.registered) {
	        enable_split_screen(camobj);

	        if (enter_cb)
	            enter_cb();
	    } else {
	        m_input.request_register_device(hmd_device);
	        hmd_device.registered_cb = function() {
	            enable_split_screen(camobj);

	            if (enter_cb)
	                enter_cb();
	        };
	    }
	}

	function enable_split_screen(camobj) {
	    var hmd_device = m_input.get_device_by_type_element(m_input.DEVICE_HMD);
	    if (!hmd_device)
	        return false;

	    if (_splited_screen)
	        return true;

	    var hmd_type = m_input.get_value_param(hmd_device, m_input.HMD_WEBVR_TYPE);
	    if (hmd_type & m_input.HMD_WEBVR1_1) {
	        var webvr_display = hmd_device.webvr_display;
	        // TODO: check code below
	        // There was strange behavior Samsung Internet on GearVR
	        var left_eye = webvr_display.getEyeParameters("left");
	        var right_eye = webvr_display.getEyeParameters("right");

	        m_cont.resize(
	                Math.max(left_eye.renderWidth, right_eye.renderWidth) * 2,
	                Math.max(left_eye.renderHeight, right_eye.renderHeight), false);

	        // TODO: uncomment until fieldOfView is not in WebVR 1.*
	        // var hmd_left_proj_mat = m_input.get_vector_param(hmd_device,
	        //         m_input.HMD_PROJ_LEFT, _mat4_tmp);
	        // var hmd_right_proj_mat = m_input.get_vector_param(hmd_device,
	        //         m_input.HMD_PROJ_RIGHT, _mat4_tmp2);
	        // m_cam.set_hmd_proj_mat(camobj, hmd_left_proj_mat, hmd_right_proj_mat);
	    } else {
	        // non-WebVR, pre-WebVR 1.1
	        // TODO: remove magic numbers
	        var canvas = m_cont.get_canvas();
	        var actual_width = Math.max(2 * canvas.height, canvas.width);
	        var actual_height = actual_width / 2;
	        m_cont.resize(actual_width, actual_height, false);
	    }

	    // TODO: remove HMD FOV
	    // HMD FOV deprecated. Use projection matrixes instead.
	    var hmd_left_fov = m_input.get_vector_param(hmd_device,
	            m_input.HMD_FOV_LEFT, _vec4_tmp);
	    var hmd_right_fov = m_input.get_vector_param(hmd_device,
	            m_input.HMD_FOV_RIGHT, _vec4_tmp2);
	    m_cam.set_hmd_fov(camobj, hmd_left_fov, hmd_right_fov,
	            !Boolean(hmd_type & m_input.HMD_WEBVR1_1));

	    var hmd_params = {};
	    hmd_params.base_line_factor = 0.5;
	    hmd_params.inter_lens_factor = 0.5;
	    hmd_params.enable_hmd_stereo = true;
	    if (hmd_type & (m_input.HMD_NON_WEBVR | m_input.HMD_WEBVR_MOBILE |
	            m_input.HMD_WEBVR_DESKTOP)) {
	        hmd_params.distortion_coefs = [
	            hmd_device.distortion_coefs[0],
	            hmd_device.distortion_coefs[1]
	        ];
	        hmd_params.chromatic_aberration_coefs = [
	            hmd_device.chromatic_aberration_coefs[0],
	            hmd_device.chromatic_aberration_coefs[1],
	            hmd_device.chromatic_aberration_coefs[2],
	            hmd_device.chromatic_aberration_coefs[3]
	        ];
	        if (!hmd_device.webvr_hmd_device)
	            if (hmd_device.base_line_dist && hmd_device.height_dist && hmd_device.bevel_size)
	                hmd_params.base_line_factor = (hmd_device.base_line_dist - hmd_device.bevel_size) /
	                        hmd_device.height_dist;
	            else if (!hmd_device.bevel_size)
	                hmd_params.base_line_factor = hmd_device.base_line_dist / hmd_device.height_dist;
	        if (hmd_device.inter_lens_dist && hmd_device.width_dist && !hmd_device.webvr_hmd_device)
	            hmd_params.inter_lens_factor = hmd_device.inter_lens_dist /
	                    hmd_device.width_dist;
	    }

	    // NOTE: prevent crash in case of difference of slink's dimensions.
	    // For example: "debug" slink ~ 0.5 X 1.0,
	    //              "origin" slink ~ distortion_scale * 0.5 X distortion_scale * 1.0
	    if (!cfg_dbg.enabled)
	        m_scs.multiply_size_mult(0.5, 1.0);
	    m_scs.set_hmd_params(hmd_params);

	    var eye_distance = m_input.get_value_param(hmd_device, m_input.HMD_EYE_DISTANCE);
	    if (eye_distance) {
	        var active_scene = m_scs.get_active();
	        var cam_scene_data = m_obj_util.get_scene_data(camobj, active_scene);
	        var cameras = cam_scene_data.cameras;
	        m_cam.set_eye_distance(cameras, eye_distance);
	    }

	    m_scs.render_both_eyes();

	    // m_input.reset_device(hmd_device);

	    _splited_screen = true;
	    return true;
	}

	/**
	 * Exit "split screen" mode.
	 * @method module:screen.exit_split_screen
	 * @returns {boolean} "Split screen" mode is disabled.
	 */
	exports.exit_split_screen = function() {
	    var hmd_device = m_input.get_device_by_type_element(m_input.DEVICE_HMD);
	    if (!_splited_screen || !hmd_device || !hmd_device.registered)
	        return false;

	    // set up non-vr mode
	    var hmd_params = {};
	    hmd_params.enable_hmd_stereo = false;
	    m_scs.set_hmd_params(hmd_params);

	    _splited_screen = false;

	    if (_exit_cb)
	        _exit_cb();

	    m_scs.render_one_eye();

	    if (!cfg_dbg.enabled)
	        m_scs.multiply_size_mult(2.0, 1.0);

	    // resize screen to canvas resolution (non-vr mode)
	    m_cont.resize_to_container(true);
	    return true;
	};

	/**
	 * Take a screenshot and download as screenshot.png image.
	 * @method module:screen.shot
	 * @param {string} [format="image/png"] The MIME image format ("image/png",
	 * "image/jpeg", "image/webp" and so on)
	 * @param {number} [quality=1.0] Number between 0 and 1 for types: "image/jpeg",
	 * "image/webp"
	 * @example
	 * var m_screen = require("screen");
	 * m_screen.shot();
	 */
	exports.shot = function(format, quality) {
	    format = format || "image/png";
	    quality = quality || 1.0;

	    var cb = function(url) {
	        var file_name = "screenshot." + format.split("/")[1];
	        if (navigator.msSaveOrOpenBlob) {
	            navigator.msSaveOrOpenBlob(url, file_name);
	        } else {
	            var a = window.document.createElement("a");
	            document.body.appendChild(a);
	            a.style.display = "none";
	            a.href = url;
	            a.download = "screenshot." + format.split("/")[1];
	            a.click();

	            document.body.removeChild(a);
	        }
	    };

	    m_main.canvas_data_url(cb, format, quality, true);
	};

	}

	var screen_factory = register("screen", Screen);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Scene API.
	 * Most of the routines presented here require an active scene to be set,
	 * use get_active() set_active() to do that.
	 * @module scenes
	 * @local ColorCorrectionParams
	 * @local SceneMetaTags
	 * @local HMDParams
	 * @local BloomParams
	 * @local DOFParams
	 * @local SSAOParams
	 * @local SkyParams
	 * @local WindParams
	 */
	function Scenes(ns, exports) {

	var m_batch    = int_batch_factory(ns);
	var m_cam      = int_camera_factory(ns);
	var m_cont     = int_container_factory(ns);
	var m_data     = int_data_factory(ns);
	var m_graph    = int_graph_factory(ns);
	var m_obj      = int_objects_factory(ns);
	var m_obj_util = int_obj_util_factory(ns);
	var m_print    = print_factory(ns);
	var m_scenes   = int_scenes_factory(ns);
	var m_scgraph  = int_scenegraph_factory(ns);
	var m_subs     = int_subscene_factory(ns);
	var m_util     = int_util_factory(ns);

	/**
	 * Color correction params.
	 * @typedef {Object} ColorCorrectionParams
	 * @property {number} [brightness] Brightness
	 * @property {number} [contrast] Contrast
	 * @property {number} [exposure] Exposure
	 * @property {number} [saturation] Saturation
	 * @cc_externs brightness contrast exposure saturation
	 */

	/**
	 * Scene meta tags.
	 * @typedef {Object} SceneMetaTags
	 * @property {string} title The title meta tag.
	 * @property {string} description The description meta tag.
	 * @cc_externs title description
	 */

	/**
	 * Head-mounted display params.
	 * @typedef {Object} HMDParams
	 * @property {boolean} enable_hmd_stereo Enable hmd stereo
	 * @property {Array} distortion_coefs Distortion coefficient list
	 * @property {Array} chromatic_aberration_coefs Chromatic aberration coefficient list
	 * @property {number} base_line_factor Tray to lens-center distance divided by screen height
	 * @property {number} inter_lens_factor Inter-lens distance divided by screen width
	 */

	/**
	 * Bloom params.
	 * @typedef {Object} BloomParams
	 * @property {number} key Strength of bloom effect
	 * @property {number} edge_lum Luminance threshold above which bloom is visible.
	 * @property {number} blur The amount of blur applied to bloom effect.
	 * @property {number} average_luminance The average luminance of the frame. Has influence only when
	 * the adaptive bloom is disabled.
	 * @cc_externs key edge_lum blur adaptive average_luminance
	 */

	/**
	 * Depth of Field parameters. Readonly properties like the "dof_bokeh" and the 
	 * "dof_object" can be only set beforehand in Blender.
	 * @typedef {Object} DOFParams
	 * @property {boolean} dof_on Use DOF.
	 * @property {number} dof_distance The distance to the focal point. Readonly if 
	 * the "dof_object" property is set, which has a higher priority.
	 * @property {number} dof_front_start The distance in front of the focal point 
	 * where the DOF effect starts. Disabled (has zero value and readonly status) if 
	 * the "dof_bokeh" property is False.
	 * @property {number} dof_front_end The distance in front of the focal point 
	 * where the DOF effect reaches its maximum power.
	 * @property {number} dof_rear_start The distance beyond the focal point where 
	 * the DOF effect starts. Disabled (has zero value and readonly status) if the 
	 * "dof_bokeh" property is False.
	 * @property {number} dof_rear_end The distance beyond the focal point where 
	 * the DOF effect reaches its maximum power.
	 * @property {number} dof_power The DOF intensity.
	 * @property {boolean} dof_bokeh Use bokeh DOF (readonly).
	 * @property {number} dof_bokeh_intensity The brightness of the bokeh DOF effect.
	 * @property {Object3D} dof_object The object which center defines the focal 
	 * point. Controls the "dof_distance" property if set (readonly).
	 * @cc_externs dof_on dof_distance dof_front_start dof_front_end dof_rear_start
	 * @cc_externs dof_rear_end dof_power dof_bokeh dof_bokeh_intensity dof_object
	 */

	/**
	 * SSAO Parameters
	 * @typedef {Object} SSAOParams
	 * @property {number} [quality] The number of samples used for calculating SSAO. 
	 * Must be 8, 16, 24 or 32.
	 * @property {number} [radius_increase] The spherical sampling radius multiply factor
	 * when transferring from the internal sampling ring to the external one.
	 * @property {boolean} [use_hemisphere] Use hemisphere to calculate SSAO.
	 * @property {boolean} [use_blur_depth] Apply edge-preserving blur to SSAO.
	 * @property {number} [blur_discard_value] Influence of depth difference between samples on blur weight.
	 * @property {number} [influence] How much AO affects the final rendering.
	 * @property {number} [dist_factor] How much AO decreases with distance.
	 * @property {boolean} [ssao_white] Turn SSAO white, basically disabling it.
	 * @property {boolean} [ssao_only] Only SSAO and not the regular render will be visible.
	 * @cc_externs quality radius_increase use_hemisphere
	 * @cc_externs use_blur_depth blur_discard_value
	 * @cc_externs influence dist_factor ssao_white ssao_only
	 */

	/**
	 * Procedural Sky Parameters
	 * @typedef {Object} SkyParams
	 * @property {boolean} [procedural_skydome] Procedural sky is used (readonly).
	 * @property {boolean} [use_as_environment_lighting] Procedural sky is used for 
	 * calculating environment lighting (readonly).
	 * @property {number} [rayleigh_brightness] Brightness of Rayleigh scattering. 
	 * Available only if "procedural_skydome" is True.
	 * @property {number} [mie_brightness] Brightness of Mie scattering. Available 
	 * only if "procedural_skydome" is True.
	 * @property {number} [spot_brightness] Brightness of the sun spot. Available 
	 * only if "procedural_skydome" is True.
	 * @property {number} [scatter_strength] The strength of the light scattering. 
	 * Available only if "procedural_skydome" is True.
	 * @property {number} [rayleigh_strength] The strength of the Rayleigh 
	 * scattering. Available only if "procedural_skydome" is True.
	 * @property {number} [mie_strength] The strength of the Mie scattering. 
	 * Available only if "procedural_skydome" is True.
	 * @property {number} [rayleigh_collection_power] Rayleigh collection power. 
	 * Available only if "procedural_skydome" is True.
	 * @property {number} [mie_collection_power] Mie collection power. Available 
	 * only if "procedural_skydome" is True.
	 * @property {number} [mie_distribution] Mie distribution. Available only if 
	 * "procedural_skydome" is True.
	 * @property {RGB} [color] The base color of the procedural sky. Available only 
	 * if "procedural_skydome" is True.
	 * @cc_externs procedural_skydome use_as_environment_lighting
	 * @cc_externs rayleigh_brightness mie_brightness spot_brightness
	 * @cc_externs scatter_strength rayleigh_strength mie_strength
	 * @cc_externs rayleigh_collection_power mie_collection_power
	 * @cc_externs mie_distribution color
	 */

	/**
	 * Wind Parameters
	 * @typedef {Object} WindParams
	 * @property {number} [wind_dir] The direction of the wind.
	 * @property {number} [wind_strength] The strength of the wind.
	 * @cc_externs wind_dir wind_strength
	 */

	/**
	 * All possible data IDs.
	 * @const module:scenes.DATA_ID_ALL
	 */
	exports.DATA_ID_ALL   = m_obj.DATA_ID_ALL;

	/**
	 * Set the active scene
	 * @method module:scenes.set_active
	 * @param {string} scene_name Name of the scene
	 * @example var m_scenes = require("scenes");
	 *
	 * m_scenes.set_active("Scene");
	 */
	exports.set_active = function(scene_name) {
	    // NOTE: keysearch is dangerous
	    var scenes = m_scenes.get_all_scenes();
	    m_scenes.set_active(m_util.keysearch("name", scene_name, scenes));
	};

	/**
	 * Get the current active scene
	 * @method module:scenes.get_active
	 * @returns {string} Active scene name
	 * @example var m_scenes = require("scenes");
	 *
	 * var current_scene = m_scenes.get_active();
	 */
	exports.get_active = function() {
	    if (!m_scenes.check_active())
	        return "";
	    else
	        return m_scenes.get_active()["name"];
	};
	/**
	 * Get all scene names.
	 * @method module:scenes.get_scenes
	 * @returns {string[]} Array of scene names.
	 * @example var m_scenes = require("scenes");
	 *
	 * var scene_list = m_scenes.get_scenes();
	 */
	exports.get_scenes = function() {
	    var scenes = m_scenes.get_all_scenes();
	    var scene_names = [];
	    for (var i = 0; i < scenes.length; i++)
	        scene_names.push(scenes[i]["name"]);

	    return scene_names;
	};
	/**
	 * Return the active camera object from the active scene.
	 * @method module:scenes.get_active_camera
	 * @returns {Object3D} Camera object.
	 * @example var m_scenes = require("scenes");
	 *
	 * var camera = m_scenes.get_active_camera();
	 */
	exports.get_active_camera = function() {
	    if (!m_scenes.check_active()) {
	        m_print.error("No active scene");
	        return false;
	    } else
	        return m_scenes.get_camera(m_scenes.get_active());
	};

	/**
	 * Get object by name.
	 * @method module:scenes.get_object_by_name
	 * @param {string} name Object name
	 * @param {number} [data_id=0] ID of loaded data
	 * @returns {Object3D} Object 3D
	 * @example var m_scenes = require("scenes");
	 *
	 * var cube = m_scenes.get_object_by_name("Cube");
	 */
	exports.get_object_by_name = function(name, data_id) {
	    var obj = m_obj.get_object(m_obj.GET_OBJECT_BY_NAME, name, data_id | 0, true);
	    if (obj)
	        return obj;
	    else
	        m_print.error("get object " + name + ": not found");
	};

	/**
	 * Get the duplicated object by empty name and dupli name.
	 * @method module:scenes.get_object_by_dupli_name
	 * @param {string} empty_name Name of the EMPTY object used to duplicate the object
	 * @param {string} dupli_name Name of the duplicated object
	 * @param {number} [data_id=0] ID of loaded data
	 * @returns {Object3D} Object 3D
	 */
	exports.get_object_by_dupli_name = function(empty_name, dupli_name,
	        data_id) {
	    var obj = m_obj.get_object(m_obj.GET_OBJECT_BY_DUPLI_NAME, empty_name,
	            dupli_name, data_id | 0);

	    if (obj)
	        return obj;
	    else
	        m_print.error("get object " + dupli_name + ": not found");
	};

	/**
	 * Get the duplicated object by empty name and dupli name list.
	 * @method module:scenes.get_object_by_dupli_name_list
	 * @param {string[]} name_list List of the EMPTY and DUPLI object names:
	 * [empty_name,empty_name,...,dupli_name]. Can be retrieved with the get_object_name_hierarchy() method.
	 * @param {number} [data_id=0] ID of loaded data.
	 * @returns {Object3D} Object 3D.
	 */
	exports.get_object_by_dupli_name_list = function(name_list, data_id) {
	    var obj = m_obj.get_object(m_obj.GET_OBJECT_BY_DUPLI_NAME_LIST,
	            name_list, data_id | 0);
	    if (obj)
	        return obj;
	    else
	        m_print.error("get object " + name_list + ": not found");
	};

	/**
	 * Get world by name.
	 * @method module:scenes.get_world_by_name
	 * @param {string} name World name
	 * @param {number} [data_id=0] ID of loaded data
	 * @returns {Object3D} Object 3D
	 * @example m_scenes = require("scenes");
	 *
	 * var world_obj = m_scenes.get_world_by_name("World");
	 */
	exports.get_world_by_name = function(name, data_id) {
	    var wrd = m_obj.get_world_by_name(name, data_id | 0);
	    if (wrd)
	        return wrd;
	    else
	        m_print.error("get object " + name + ": not found");
	};

	/**
	 * Returns object data_id property.
	 * @method module:scenes.get_object_data_id
	 * @param {Object3D} obj Object 3D
	 * @returns {number} data_id Data ID property
	 * @example var m_scenes = require("scenes");
	 *
	 * var cube = m_scenes.get_object_by_name("Cube");
	 *
	 * var data_id = m_scenes.get_object_data_id(cube);
	 */
	exports.get_object_data_id = function(obj) {
	    return m_obj_util.get_object_data_id(obj);
	};

	/**
	 * For given mouse coords, render the color scene and return an object.
	 * @method module:scenes.pick_object
	 * @param {number} x X Canvas coordinate.
	 * @param {number} y Y Canvas coordinate.
	 * @returns {Object3D?} The object under the given coordinates or null.
	 * @example 
	 * var m_cont = require("container");
	 * var m_scenes = require("scenes");
	 *
	 * var canvas_cont = m_cont.get_container();
	 * canvas_cont.addEventListener("mousedown", down_cb);
	 * var down_cb = function(event) {
	 *     var obj = m_scenes.pick_object(event.offsetX, event.offsetY);
	 * }
	 */
	exports.pick_object = function(x, y) {
	    var main_scene = m_scenes.get_main();
	    if (!main_scene) {
	        m_print.error("No active scene");
	        return null;
	    }

	    var subs_stereo = m_scenes.get_subs(main_scene, m_subs.STEREO);
	    if (subs_stereo)
	        if (subs_stereo.enable_hmd_stereo) {
	            m_print.error_once("pick_object() is not available in the stereo rendering mode." +
	                    " Use scenes.pick_center instead.");
	            return pick_center();
	        }

	    return m_obj.pick_object(x, y);
	};

	/**
	 * Render the color scene and return an object in the viewport center.
	 * @method module:scenes.pick_center
	 * @returns {Object3D?} The object in the viewport center.
	 */
	exports.pick_center = pick_center;
	function pick_center() {
	    var canvas = m_cont.get_canvas();
	    var h = canvas.clientHeight;
	    var w = canvas.clientWidth;
	    return m_obj.pick_object(w / 2, h / 2);
	}

	/**
	 * Check if the outlining is enabled or not for the object.
	 * @method module:scenes.outlining_is_enabled
	 * @param {Object3D} obj Object 3D
	 * @returns {boolean} Checking result.
	 * @example var m_scenes = require("scenes");
	 *
	 * var cube = m_scenes.get_object_by_name("Cube");
	 *
	 * var outlining_is_enabled = m_scenes.outlining_is_enabled(cube);
	 */
	exports.outlining_is_enabled = function(obj) {
	    return obj && obj.render && obj.render.outlining;
	};

	/**
	 * Set outline intensity for the object.
	 * @method module:scenes.set_outline_intensity
	 * @param {Object3D} obj Object 3D
	 * @param {number} value Intensity value
	 * @example var m_scenes = require("scenes");
	 *
	 * var cube = m_scenes.get_object_by_name("Cube");
	 *
	 * m_scenes.set_outline_intensity(cube, 0.4);
	 */
	exports.set_outline_intensity = function(obj, value) {
	    if (obj && obj.render && obj.render.outlining)
	        m_obj.set_outline_intensity(obj, value);
	    else
	        m_print.error("set_outline_intensity(): wrong object");
	};

	/**
	 * Get outline intensity for the object.
	 * @method module:scenes.get_outline_intensity
	 * @param {Object3D} obj Object 3D
	 * @returns {number} Intensity value
	 * @example var m_scenes = require("scenes");
	 *
	 * var cube = m_scenes.get_object_by_name("Cube");
	 *
	 * var outline_intensity = m_scenes.get_outline_intensity(cube);
	 */
	exports.get_outline_intensity = function(obj) {
	    if (obj && obj.render && obj.render.outlining)
	        return obj.render.outline_intensity;
	    else
	        m_print.error("get_outline_intensity(): wrong object");

	    return 0;
	};

	/**
	 * Apply outlining animation to the object
	 * @method module:scenes.apply_outline_anim
	 * @param {Object3D} obj Object 3D
	 * @param {number} tau Outlining duration
	 * @param {number} T Period of outlining
	 * @param {number} N Number of relapses (0 - infinity)
	 * @example var m_scenes = require("scenes");
	 *
	 * var cube = m_scenes.get_object_by_name("Cube");
	 *
	 * m_scenes.apply_outline_anim(cube, 10, 5, 0);
	 */
	exports.apply_outline_anim = function(obj, tau, T, N) {
	    if (obj && obj.render && obj.render.outlining)
	        m_obj.apply_outline_anim(obj, tau, T, N);
	    else
	        m_print.error("apply_outline_anim(): wrong object");
	};

	/**
	 * Apply outlining animation to the object and use the object's default settings
	 * @method module:scenes.apply_outline_anim_def
	 * @param {Object3D} obj Object 3D
	 * @example var m_scenes = require("scenes");
	 *
	 * var cube = m_scenes.get_object_by_name("Cube");
	 *
	 * m_scenes.apply_outline_anim_def(cube);
	 */
	exports.apply_outline_anim_def = function(obj) {
	    if (obj && obj.render && obj.render.outlining) {
	        var oa_set = obj.render.outline_anim_settings_default;
	        m_obj.apply_outline_anim(obj, oa_set.outline_duration,
	                oa_set.outline_period, oa_set.outline_relapses);
	    } else
	        m_print.error("apply_outline_anim_def(): wrong object");
	};

	/**
	 * Stop outlining animation for the object.
	 * @method module:scenes.clear_outline_anim
	 * @param {Object3D} obj Object 3D
	 * @example var m_scenes = require("scenes");
	 *
	 * var cube = m_scenes.get_object_by_name("Cube");
	 *
	 * m_scenes.clear_outline_anim(cube);
	 */
	exports.clear_outline_anim = function(obj) {
	    if (obj && obj.render && obj.render.outlining)
	        m_obj.clear_outline_anim(obj);
	    else
	        m_print.error("clear_outline_anim(): wrong object");
	};

	/**
	 * Set the color of outline outline effect for active scene.
	 * @method module:scenes.set_outline_color
	 * @param {RGB} color RGB color vector
	 * @example var m_scenes = require("scenes");
	 *
	 * m_scenes.set_outline_color([0.8, 0.2, 0.8]);
	 */
	exports.set_outline_color = m_scenes.set_outline_color;

	/**
	 * Get the color of outline outline effect for active scene.
	 * @method module:scenes.get_outline_color
	 * @param {?RGB} dest Destination RGB color vector
	 * @returns {RGB} Destination RGB color vector
	 * @example var m_scenes = require("scenes");
	 *
	 * var outline_color = new Float32Array(3);
	 *
	 * m_scenes.get_outline_color(outline_color);
	 */
	exports.get_outline_color = function(dest) {
	    var scene = m_scenes.get_active();
	    var subs = m_scenes.get_subs(scene, m_subs.OUTLINE);
	    if (subs) {
	        dest = dest || new Float32Array(3);
	        dest.set(subs.outline_color);
	        return dest;
	    }
	};

	/**
	 * Set head-mounted display params.
	 * @method module:scenes.set_hmd_params
	 * @param {HMDParams} hmd_params Head-mounted display params.
	 * @cc_externs enable_hmd_stereo distortion_coefs chromatic_aberration_coefs
	 * @cc_externs base_line_factor inter_lens_factor
	 */
	exports.set_hmd_params = function(hmd_params) {
	    if (!m_scenes.check_active()) {
	        m_print.error("No active scene");
	        return;
	    }

	    if (!hmd_params)
	        return;

	    if (hmd_params.distortion_coefs && !(hmd_params.distortion_coefs instanceof Array))
	        hmd_params.distortion_coefs = null;

	    if (hmd_params.chromatic_aberration_coefs && !(hmd_params.chromatic_aberration_coefs instanceof Array))
	        hmd_params.chromatic_aberration_coefs = null;

	    if (typeof hmd_params.base_line_factor != "number")
	        hmd_params.base_line_factor = null;

	    if (typeof hmd_params.inter_lens_factor != "number")
	        hmd_params.inter_lens_factor = null;

	    if (typeof hmd_params.enable_hmd_stereo != "boolean")
	        hmd_params.enable_hmd_stereo = null;

	    m_scenes.set_hmd_params(hmd_params);
	};

	/**
	 * Get shadow params.
	 * @method module:scenes.get_shadow_params
	 * @returns {ShadowParams} Shadow params
	 * @cc_externs enable_csm csm_num csm_first_cascade_border first_cascade_blur_radius
	 * @cc_externs csm_last_cascade_border last_cascade_blur_radius csm_resolution
	 * @cc_externs self_shadow_normal_offset self_shadow_polygon_offset
	 * @cc_externs pcf_blur_radius fade_last_cascade blend_between_cascades
	 * @cc_externs csm_borders blur_radii
	 * @example var m_scenes = require("scenes");
	 *
	 * var shadow_params = m_scenes.get_shadow_params();
	 */
	exports.get_shadow_params = function() {
	    if (!m_scenes.check_active()) {
	        m_print.error("No active scene");
	        return false;
	    }

	    var active_scene = m_scenes.get_active();
	    var shadow_cast  = m_scenes.get_subs(active_scene, m_subs.SHADOW_CAST);

	    if (!shadow_cast)
	        return null;

	    var shs = active_scene._render.shadow_params;
	    var subs_main = m_scenes.get_subs(active_scene, m_subs.MAIN_OPAQUE);
	    var subs_shadow_receive = m_scenes.get_subs(active_scene, m_subs.SHADOW_RECEIVE);

	    var shadow_params = {};
	    shadow_params.csm_resolution = shs.csm_resolution;

	    shadow_params.self_shadow_polygon_offset = shadow_cast.self_shadow_polygon_offset;
	    if (subs_shadow_receive)
	        shadow_params.self_shadow_normal_offset = subs_shadow_receive.self_shadow_normal_offset;

	    shadow_params.enable_csm = shs.enable_csm;
	    shadow_params.csm_num = shs.csm_num;
	    shadow_params.csm_first_cascade_border = shs.csm_first_cascade_border;
	    shadow_params.first_cascade_blur_radius = shs.first_cascade_blur_radius;
	    shadow_params.csm_last_cascade_border = shs.csm_last_cascade_border;
	    shadow_params.last_cascade_blur_radius = shs.last_cascade_blur_radius;

	    shadow_params.fade_last_cascade = shs.fade_last_cascade;
	    shadow_params.blend_between_cascades = shs.blend_between_cascades;

	    if (shs.enable_csm) {
	        shadow_params.csm_borders = m_scenes.get_csm_borders(active_scene,
	                subs_main.camera);
	        shadow_params.blur_radii = new Float32Array(shs.csm_num);
	        shadow_params.blur_radii.set(subs_main.camera.pcf_blur_radii.subarray(0,
	                shs.csm_num));
	    } else {
	        shadow_params.csm_borders = null;
	        shadow_params.blur_radii = null;
	    }


	    return shadow_params;
	};

	/**
	 * Set shadow params
	 * @method module:scenes.set_shadow_params
	 * @param {ShadowParams} shadow_params Shadow params
	 * @example var m_scenes = require("scenes");
	 *
	 * m_scenes.set_shadow_params({ blend_between_cascades: true,
	 *                              blur_radii: null,
	 *                              csm_borders: null,
	 *                              csm_first_cascade_border: 10,
	 *                              csm_last_cascade_border: 100,
	 *                              csm_num: 1,
	 *                              csm_resolution: 2048,
	 *                              enable_csm: true,
	 *                              fade_last_cascade: true,
	 *                              first_cascade_blur_radius: 3,
	 *                              last_cascade_blur_radius: 1.5,
	 *                              self_shadow_normal_offset: 0.01,
	 *                              self_shadow_polygon_offset: 1 });
	 */
	exports.set_shadow_params = function(shadow_params) {
	    if (!m_scenes.check_active()) {
	        m_print.error("No active scene");
	        return;
	    }

	    var active_scene = m_scenes.get_active();

	    if (typeof shadow_params.self_shadow_polygon_offset == "number")
	        m_graph.traverse(active_scene._render.graph, function(node, attr) {
	            if (attr.type == m_subs.SHADOW_CAST)
	                attr.self_shadow_polygon_offset = shadow_params.self_shadow_polygon_offset;
	        });

	    var subs_shadow_receives = m_scenes.subs_array(active_scene, [m_subs.SHADOW_RECEIVE]);
	    for (var i = 0; i < subs_shadow_receives.length; i++) {
	        var subs_shadow_receive = subs_shadow_receives[i];
	        if (typeof shadow_params.self_shadow_normal_offset == "number")
	            subs_shadow_receive.self_shadow_normal_offset = shadow_params.self_shadow_normal_offset;
	        if (typeof shadow_params.pcf_blur_radius == "number")
	            subs_shadow_receive.pcf_blur_radius = shadow_params.pcf_blur_radius;
	    }

	    var subs_main_blends = m_scenes.subs_array(active_scene, [m_subs.MAIN_BLEND]);
	    for (var i = 0; i < subs_main_blends.length; i++) {
	        var subs_main_blend = subs_main_blends[i];
	        if (typeof shadow_params.self_shadow_normal_offset == "number")
	            subs_main_blend.self_shadow_normal_offset = shadow_params.self_shadow_normal_offset;
	        if (typeof shadow_params.pcf_blur_radius == "number")
	            subs_main_blend.pcf_blur_radius = shadow_params.pcf_blur_radius;

	        subs_main_blend.need_perm_uniforms_update = true;
	    }

	    var shs = active_scene._render.shadow_params;
	    if (typeof shadow_params.csm_first_cascade_border == "number")
	        shs.csm_first_cascade_border = shadow_params.csm_first_cascade_border;
	    if (typeof shadow_params.first_cascade_blur_radius == "number")
	        shs.first_cascade_blur_radius = shadow_params.first_cascade_blur_radius;
	    if (typeof shadow_params.csm_last_cascade_border == "number")
	        shs.csm_last_cascade_border = shadow_params.csm_last_cascade_border;
	    if (typeof shadow_params.last_cascade_blur_radius == "number")
	        shs.last_cascade_blur_radius = shadow_params.last_cascade_blur_radius;

	    // update directives; only depth subs supported
	    if (subs_shadow_receive) {
	        var draw_data = subs_shadow_receive.draw_data;
	        for (var i = 0; i < draw_data.length; i++) {
	            var bundles = draw_data[i].bundles;
	            for (var j = 0; j < bundles.length; j++) {

	                var bundle = bundles[j];

	                if (!bundle.obj_render.shadow_receive)
	                    continue;

	                var batch = bundle.batch;
	                m_batch.assign_shadow_receive_dirs(batch, shs);

	                m_batch.update_shader(batch);
	                m_subs.append_draw_data(subs_shadow_receive, bundle);
	            }
	        }
	        subs_shadow_receive.need_perm_uniforms_update = true;
	    }

	    var cam_scene_data = m_obj_util.get_scene_data(active_scene._camera, active_scene);
	    var upd_cameras = cam_scene_data.cameras;
	    for (var i = 0; i < upd_cameras.length; i++)
	        m_cam.update_camera_shadows(upd_cameras[i], shs);

	    m_scenes.schedule_shadow_update(active_scene);
	};

	/**
	 * Get horizon and zenith colors of the environment.
	 * @method module:scenes.get_environment_colors
	 * @returns {Array} Environment colors
	 * @example var m_scenes = require("scenes");
	 *
	 * var environment_colors = m_scenes.get_environment_colors();
	 */
	exports.get_environment_colors = function() {
	    if (!m_scenes.check_active()) {
	        m_print.error("No active scene");
	        return [];
	    }
	    var active_scene = m_scenes.get_active();
	    return m_scenes.get_environment_colors(active_scene);
	};

	/**
	 * Set horizon and/or zenith color(s) of the environment.
	 * @method module:scenes.set_environment_colors
	 * @param {number} [opt_environment_energy] Environment Energy
	 * @param {RGB} [opt_horizon_color] Horizon color
	 * @param {RGB} [opt_zenith_color] Zenith color
	 * @example var m_rgb = require("rgb");
	 * var m_scenes = require("scenes");
	 *
	 * var horizon_color = m_rgb.from_values(0.5, 0.1, 0.1);
	 * var zenith_color = m_rgb.from_values(0.1, 0.1, 0.8);
	 *
	 * m_scenes.set_environment_colors(0.8, horizon_color, zenith_color);
	 */
	exports.set_environment_colors = function(opt_environment_energy,
	        opt_horizon_color, opt_zenith_color) {
	    if (!m_scenes.check_active()) {
	        m_print.error("No active scene");
	        return;
	    }
	    var active_scene = m_scenes.get_active();
	    var subs = m_scenes.get_subs(active_scene, m_subs.MAIN_OPAQUE);

	    var energy = opt_environment_energy || opt_environment_energy == 0 ?
	                            parseFloat(opt_environment_energy):
	                            subs.environment_energy;
	    var horizon_color = opt_horizon_color || opt_horizon_color == 0 ?
	                            opt_horizon_color:
	                            subs.horizon_color;
	    var zenith_color = opt_zenith_color || opt_zenith_color == 0 ?
	                            opt_zenith_color:
	                            subs.zenith_color;

	    m_scenes.set_environment_colors(active_scene, energy,
	                horizon_color, zenith_color);
	};

	/**
	 * Get fog color and density.
	 * @method module:scenes.get_fog_color_density
	 * @param {Vec4} dest Destination vector [C,C,C,D]
	 * @returns {Vec4} Destination vector
	 * @example var m_scenes = require("scenes");
	 *
	 * var fog_density = new Float32Array(4);
	 * m_scenes.get_fog_color_density(fog_density);
	 */
	exports.get_fog_color_density = function(dest) {
	    if (!m_scenes.check_active()) {
	        m_print.error("No active scene");
	        return false;
	    }
	    var active_scene = m_scenes.get_active();
	    return m_scenes.get_fog_color_density(active_scene, dest);
	};

	/**
	 * Set fog color and density
	 * @method module:scenes.set_fog_color_density
	 * @param {Vec4} val Color-density vector [C,C,C,D]
	 * @example var m_scenes = require("scenes");
	 *
	 * m_scenes.set_fog_color_density([0.5, 0.5, 0.7, 0.05]);
	 */
	exports.set_fog_color_density = function(val) {
	    if (!m_scenes.check_active()) {
	        m_print.error("No active scene");
	        return;
	    }
	    var active_scene = m_scenes.get_active();
	    m_scenes.set_fog_color_density(active_scene, val);
	};

	/**
	 * Get fog params
	 * @method module:scenes.get_fog_params
	 * @returns {FogParams} Fog params
	 * @cc_externs fog_intensity fog_intensity fog intensity
	 * @cc_externs fog_depth fog_depth fog_depth
	 * @cc_externs fog_start fog_start fog start
	 * @cc_externs fog_height fog_height fog height
	 * @example var m_scenes = require("scenes");
	 *
	 * var fog_params = m_scenes.get_fog_params();
	 */
	exports.get_fog_params = function() {
	    if (!m_scenes.check_active()) {
	        m_print.error("No active scene");
	        return false;
	    }
	    var active_scene = m_scenes.get_active();

	    var fog_params = {};
	    fog_params.fog_intensity = m_scenes.get_fog_intensity(active_scene);
	    fog_params.fog_depth     = m_scenes.get_fog_depth(active_scene);
	    fog_params.fog_start     = m_scenes.get_fog_start(active_scene);
	    fog_params.fog_height    = m_scenes.get_fog_height(active_scene);

	    return fog_params;
	};

	/**
	 * Set fog params
	 * @method module:scenes.set_fog_params
	 * @param {FogParams} fog_params Fog params
	 * @example var m_scenes = require("scenes");
	 *
	 * m_scenes.set_fog_params({ fog_intensity: 1,
	 *                           fog_depth: 25,
	 *                           fog_start: 5,
	 *                           fog_height: 0 });
	 */
	exports.set_fog_params = function(fog_params) {
	    if (!m_scenes.check_active()) {
	        m_print.error("No active scene");
	        return;
	    }
	    var active_scene = m_scenes.get_active();

	    if (typeof fog_params.fog_intensity == "number")
	        m_scenes.set_fog_intensity(active_scene, fog_params.fog_intensity);
	    if (typeof fog_params.fog_depth == "number")
	        m_scenes.set_fog_depth(active_scene, fog_params.fog_depth);
	    if (typeof fog_params.fog_start == "number")
	        m_scenes.set_fog_start(active_scene, fog_params.fog_start);
	    if (typeof fog_params.fog_height == "number")
	        m_scenes.set_fog_height(active_scene, fog_params.fog_height);
	};

	/**
	 * Get SSAO params
	 * @method module:scenes.get_ssao_params
	 * @returns {SSAOParams} SSAO params
	 * @example var m_scenes = require("scenes");
	 *
	 * var ssao_params = m_scenes.get_ssao_params();
	 */
	exports.get_ssao_params = function() {
	    if (!m_scenes.check_active()) {
	        m_print.error("No active scene");
	        return false;
	    }
	    var active_scene = m_scenes.get_active();
	    return m_scenes.get_ssao_params(active_scene);
	};

	/**
	 * Set SSAO params
	 * @method module:scenes.set_ssao_params
	 * @param {SSAOParams} ssao_params SSAO params
	 * @example var m_scenes = require("scenes");
	 *
	 * m_scenes.set_ssao_params({ quality: 16,
	 *                            radius_increase: 3,
	 *                            use_hemisphere: true,
	 *                            use_blur_depth: false,
	 *                            blur_discard_value: 1,
	 *                            influence: 0.7,
	 *                            dist_factor: 0,
	 *                            ssao_white: false,
	 *                            ssao_only: false });
	 */
	exports.set_ssao_params = function(ssao_params) {
	    if (!m_scenes.check_active()) {
	        m_print.error("No active scene");
	        return;
	    }
	    var scene = m_scenes.get_active();

	    var subscenes = m_scenes.subs_array(scene, [m_subs.SSAO]);
	    var subscenes_blur = m_scenes.subs_array(scene, [m_subs.SSAO_BLUR]);

	    if (!subscenes.length) {
	        m_print.error("SSAO is not enabled on the scene");
	        return 0;
	    }

	    for (var i = 0; i < subscenes.length; i++)
	        set_params_ssao_subs(subscenes[i], subscenes_blur[i], ssao_params);
	};

	function set_params_ssao_subs(subs, subs_blur, ssao_params) {
	    var scene = m_scenes.get_active();
	    
	    var bundle = subs.draw_data[0].bundles[0];
	    var batch = bundle.batch;

	    var bundle_blur = subs_blur.draw_data[0].bundles[0];
	    var batch_blur = bundle_blur.batch;

	    if ("quality" in ssao_params) {
	        var quality = ssao_params.quality;
	        if (quality === 8 || quality === 16 || quality === 24 || quality === 32) {
	            subs.ssao_samples = quality;
	            m_batch.set_batch_directive(batch, "SSAO_QUALITY", "SSAO_QUALITY_" 
	                    + quality);
	            m_batch.update_shader(batch);
	            m_subs.append_draw_data(subs, bundle);
	        } else
	            m_print.error("set_ssao_params(): Wrong \"quality\" value.");
	    }

	    if ("use_hemisphere" in ssao_params) {
	        subs.ssao_hemisphere = ssao_params.use_hemisphere;
	        m_batch.set_batch_directive(batch, "SSAO_HEMISPHERE", 
	                ssao_params.use_hemisphere | 0);
	        m_batch.update_shader(batch);
	        m_subs.append_draw_data(subs, bundle);
	    }

	    if ("use_blur_depth" in ssao_params) {
	        subs_blur.ssao_blur_depth = ssao_params.use_blur_depth;
	        m_batch.set_batch_directive(batch_blur, "SSAO_BLUR_DEPTH", 
	                ssao_params.use_blur_depth | 0);
	        m_batch.update_shader(batch_blur);
	        m_subs.append_draw_data(subs_blur, bundle_blur);
	        m_scgraph.connect_render_targets_batch(scene._render.graph, subs_blur, batch_blur, false);
	    }

	    if ("ssao_white" in ssao_params) {
	        subs.ssao_white = ssao_params.ssao_white;
	        m_batch.set_batch_directive(batch, "SSAO_WHITE", 
	                ssao_params.ssao_white | 0);
	        m_batch.update_shader(batch);
	        m_subs.append_draw_data(subs, bundle);
	    }

	    if ("blur_discard_value" in ssao_params)
	        subs_blur.ssao_blur_discard_value = ssao_params.blur_discard_value;

	    if ("radius_increase" in ssao_params)
	        subs.ssao_radius_increase = ssao_params.radius_increase;

	    if ("influence" in ssao_params)
	        subs.ssao_influence = ssao_params.influence;

	    if ("dist_factor" in ssao_params)
	        subs.ssao_dist_factor = ssao_params.dist_factor;

	    if (typeof ssao_params.ssao_only == "boolean") {
	        // FIX: in case of stereo mode there are 2 MAIN_OPAQUE
	        var subs_main = m_scenes.get_subs(scene, m_subs.MAIN_OPAQUE);
	        subs_main.ssao_only = ssao_params.ssao_only;
	        var draw_data = subs_main.draw_data;
	        var append_bundles = [];
	        for (var i = 0; i < draw_data.length; i++) {
	            var bundles = draw_data[i].bundles;
	            for (var j = 0; j < bundles.length; j++) {
	                var batch_main = bundles[j].batch;
	                m_batch.set_batch_directive(batch_main, "SSAO_ONLY",
	                        ssao_params.ssao_only | 0);
	                m_batch.update_shader(batch_main);
	                append_bundles.push(bundles[j]);
	            }
	        }
	        for (var i = 0; i < append_bundles.length; i++)
	            m_subs.append_draw_data(subs_main, append_bundles[i]);
	    }

	    subs.need_perm_uniforms_update = true;
	    subs_blur.need_perm_uniforms_update = true;
	}

	/**
	 * Get color correction params
	 * @method module:scenes.get_color_correction_params
	 * @returns {ColorCorrectionParams} Color correction params
	 * @example var m_scenes = require("scenes");
	 *
	 * var color_parameters = m_scenes.get_color_correction_params();
	 */
	exports.get_color_correction_params = function() {
	    if (!m_scenes.check_active()) {
	        m_print.error("No active scene");
	        return null;
	    }

	    var active_scene = m_scenes.get_active();
	    var subs = m_scenes.get_subs(active_scene, m_subs.COMPOSITING);
	    if (!subs)
	        return null;

	    var compos_params = {};

	    compos_params.brightness = subs.brightness;
	    compos_params.contrast = subs.contrast;
	    compos_params.exposure = subs.exposure;
	    compos_params.saturation = subs.saturation;

	    return compos_params;
	};

	/**
	 * Set color correction params.
	 * @method module:scenes.set_color_correction_params
	 * @param {ColorCorrectionParams} color_corr_params Color correction params.
	 * @example var m_scenes = require("scenes");
	 * 
	 * m_scenes.set_color_correction_params({ brightness: 0.2,
	 *                                        contrast: 0.4,
	 *                                        exposure: 0.9,
	 *                                        saturation: 0.5 });
	 */
	exports.set_color_correction_params = function(color_corr_params) {
	    if (!m_scenes.check_active()) {
	        m_print.error("No active scene");
	        return;
	    }

	    var active_scene = m_scenes.get_active();
	    var subs = m_scenes.get_subs(active_scene, m_subs.COMPOSITING);
	    if (!subs)
	        return;

	    if ("brightness" in color_corr_params)
	        subs.brightness = color_corr_params.brightness;

	    if ("contrast" in color_corr_params)
	        subs.contrast = color_corr_params.contrast;

	    if ("exposure" in color_corr_params)
	        subs.exposure = color_corr_params.exposure;

	    if ("saturation" in color_corr_params)
	        subs.saturation = color_corr_params.saturation;

	    subs.need_perm_uniforms_update = true;
	};

	/**
	 * Get sky params
	 * @method module:scenes.get_sky_params
	 * @returns {SkyParams} Sky params
	 * @example var m_scenes = require("scenes");
	 *
	 * var sky_params = m_scenes.get_sky_params();
	 */
	exports.get_sky_params = function() {
	    if (!m_scenes.check_active()) {
	        m_print.error("No active scene");
	        return false;
	    }
	    var active_scene = m_scenes.get_active();
	    return m_scenes.get_sky_params(active_scene);
	};

	/**
	 * Set sky params
	 * @method module:scenes.set_sky_params
	 * @param {SkyParams} sky_params Sky params
	 * @example var m_scenes = require("scenes");
	 *
	 * m_scenes.set_sky_params({ rayleigh_brightness: 3.3,
	 *                           mie_brightness: 0.1,
	 *                           spot_brightness: 20,
	 *                           scatter_strength: 0.2,
	 *                           rayleigh_strength: 0.2,
	 *                           mie_strength: 0.006,
	 *                           rayleigh_collection_power: 0.35,
	 *                           mie_collection_power: 0.5,
	 *                           mie_distribution: 0.4,
	 *                           color: [0.3, 0.9, 0.3] });
	 */
	exports.set_sky_params = function(sky_params) {
	    
	    if (!m_scenes.check_active()) {
	        m_print.error("No active scene");
	        return;
	    }
	    var scene = m_scenes.get_active();

	    var subs = m_scenes.get_subs(scene, m_subs.SKY);
	    if (subs) {
	        // procedural_skydome and use_as_environment_lighting are readonly

	        if ("color" in sky_params)
	            subs.sky_color.set(sky_params.color);

	        if ("rayleigh_brightness" in sky_params)
	            subs.rayleigh_brightness = sky_params.rayleigh_brightness;

	        if ("mie_brightness" in sky_params)
	            subs.mie_brightness = sky_params.mie_brightness;

	        if ("spot_brightness" in sky_params)
	            subs.spot_brightness = sky_params.spot_brightness;

	        if ("scatter_strength" in sky_params)
	            subs.scatter_strength = sky_params.scatter_strength;

	        if ("rayleigh_strength" in sky_params)
	            subs.rayleigh_strength = sky_params.rayleigh_strength;

	        if ("mie_strength" in sky_params)
	            subs.mie_strength = sky_params.mie_strength;

	        if ("rayleigh_collection_power" in sky_params)
	            subs.rayleigh_collection_power = sky_params.rayleigh_collection_power;

	        if ("mie_collection_power" in sky_params)
	            subs.mie_collection_power = sky_params.mie_collection_power;

	        if ("mie_distribution" in sky_params)
	            subs.mie_distribution = sky_params.mie_distribution;

	        subs.need_perm_uniforms_update = true;
	        subs.need_fog_update = true;
	        m_scenes.update_sky(scene, subs);
	    }
	};

	/**
	 * Get depth-of-field (DOF) params.
	 * @method module:scenes.get_dof_params
	 * @returns {DOFParams} The object containing DOF parameters.
	 * @example var m_scenes = require("scenes");
	 *
	 * var dof_params = m_scenes.get_dof_params();
	 */
	exports.get_dof_params = function() {
	    if (!m_scenes.check_active()) {
	        m_print.error("No active scene");
	        return false;
	    }
	    var active_scene = m_scenes.get_active();
	    var subs = m_scenes.get_subs(active_scene, m_subs.DOF);
	    if (subs)
	        return m_scenes.get_dof_params(active_scene);
	    else
	        return null;
	};

	/**
	 * Set depth-of-field (DOF) params
	 * @method module:scenes.set_dof_params
	 * @param {DOFParams} dof_params The object containing DOF parameters.
	 * @example
	 * var m_scenes = require("scenes");
	 *
	 * // adjusting the front/rear distances
	 * m_scenes.set_dof_params({ dof_front_start: 0, 
	 *         dof_front_end: 2, 
	 *         dof_rear_start: 0, 
	 *         dof_rear_end: 5 });
	 *
	 * // disabling the DOF effect
	 * m_scenes.set_dof_params({ dof_on: false });
	 */
	exports.set_dof_params = function(dof_params) {
	    if (!m_scenes.check_active()) {
	        m_print.error("No active scene");
	        return;
	    }
	    var active_scene = m_scenes.get_active();
	    m_scenes.set_dof_params(active_scene, dof_params);
	};

	/**
	 * Get god rays parameters
	 * @method module:scenes.get_god_rays_params
	 * @returns {GodRaysParams} god rays parameters
	 * @example var m_scenes = require("scenes");
	 *
	 * var god_ray_params = m_scenes.get_god_rays_params();
	 */
	exports.get_god_rays_params = function() {
	    if (!m_scenes.check_active()) {
	        m_print.error("No active scene");
	        return false;
	    }
	    var active_scene = m_scenes.get_active();
	    var subs = m_scenes.get_subs(active_scene, m_subs.GOD_RAYS);
	    if (subs)
	        return m_scenes.get_god_rays_params(active_scene);
	    else
	        return null;
	};

	/**
	 * Set god rays parameters
	 * @method module:scenes.set_god_rays_params
	 * @param {GodRaysParams} god_rays_params God rays parameters
	 * @cc_externs god_rays_max_ray_length god_rays_intensity god_rays_steps
	 * @example var m_scenes = require("scenes");
	 *
	 * m_scenes.set_god_rays_params({ god_rays_max_ray_length: 1,
	 *                                god_rays_intensity: 0.7,
	 *                                god_rays_steps: 10 });
	 */
	exports.set_god_rays_params = function(god_rays_params) {
	    if (!m_scenes.check_active()) {
	        m_print.error("No active scene");
	        return;
	    }
	    var active_scene = m_scenes.get_active();
	    m_scenes.set_god_rays_params(active_scene, god_rays_params);
	};

	/**
	 * Get bloom parameters
	 * @method module:scenes.get_bloom_params
	 * @returns {BloomParams} bloom parameters
	 * @example var m_scenes = require("scenes");
	 *
	 * var bloom_parameters = m_scenes.get_bloom_params();
	 */
	exports.get_bloom_params = function() {
	    if (!m_scenes.check_active()) {
	        m_print.error("No active scene");
	        return false;
	    }
	    var active_scene = m_scenes.get_active();
	    var subs = m_scenes.get_subs(active_scene, m_subs.BLOOM);
	    if (subs)
	        return m_scenes.get_bloom_params(active_scene);
	    else
	        return null;
	};

	/**
	 * Set bloom parameters
	 * @method module:scenes.set_bloom_params
	 * @param {BloomParams} bloom_params Bloom parameters
	 * @example var m_scenes = require("scenes");
	 *
	 * m_scenes.set_bloom_params({ key: 1, edge_lum: 0.5, blur: 4 });
	 */
	exports.set_bloom_params = function(bloom_params) {
	    if (!m_scenes.check_active()) {
	        m_print.error("No active scene");
	        return;
	    }
	    var active_scene = m_scenes.get_active();
	    m_scenes.set_bloom_params(active_scene, bloom_params);
	};

	/**
	 * Get glow material parameters
	 * @method module:scenes.get_glow_material_params
	 * @returns {GlowMaterialParams} glow material parameters
	 * @example var m_scenes = require("scenes");
	 *
	 * var glow_params = m_scenes.get_glow_material_params();
	 */
	exports.get_glow_material_params = function() {
	    if (!m_scenes.check_active()) {
	        m_print.error("No active scene");
	        return false;
	    }

	    var active_scene = m_scenes.get_active();
	    var subs = m_scenes.get_subs(active_scene, m_subs.GLOW_COMBINE);
	    if (subs)
	        return m_scenes.get_glow_material_params(active_scene);
	    else
	        return null;
	};

	/**
	 * Set glow material parameters
	 * @method module:scenes.set_glow_material_params
	 * @param {GlowMaterialParams} glow_material_params Glow material parameters
	 * @cc_externs small_glow_mask_coeff large_glow_mask_coeff small_glow_mask_width large_glow_mask_width
	 */
	exports.set_glow_material_params = function(glow_material_params) {
	    if (!m_scenes.check_active()) {
	        m_print.error("No active scene");
	        return;
	    }

	    var active_scene = m_scenes.get_active();
	    m_scenes.set_glow_material_params(active_scene, glow_material_params);
	};

	/**
	 * Get wind parameters
	 * @method module:scenes.get_wind_params
	 * @returns {WindParams} Wind params
	 * @example var m_scenes = require("scenes");
	 *
	 * var wind_parameters = m_scenes.get_wind_params();
	 */
	exports.get_wind_params = function() {
	    if (!m_scenes.check_active()) {
	        m_print.error("No active scene");
	        return false;
	    }
	    var active_scene = m_scenes.get_active();
	    return m_scenes.get_wind_params(active_scene);
	};

	/**
	 * Set wind parameters
	 * @method module:scenes.set_wind_params
	 * @param {WindParams} wind_params Wind parameters
	 * @example var m_scenes = require("scenes");
	 *
	 * m_scenes.set_wind_params({ wind_dir: 90,
	 *                            wind_strength: 3 });
	 */
	exports.set_wind_params = function(wind_params) {
	    if (!m_scenes.check_active()) {
	        m_print.error("No active scene");
	        return;
	    }
	    var active_scene = m_scenes.get_active();
	    m_obj.set_wind_params(active_scene, wind_params);
	};

	/**
	 * Get water surface level.
	 * @method module:scenes.get_water_surface_level
	 * @param {number} pos_x World x position
	 * @param {number} pos_y World y position
	 * @returns {number} Surface level
	 * @example var m_scenes = require("scenes");
	 *
	 * var water_level = m_scenes.get_water_surface_level(10.3, 15.6);
	 */
	exports.get_water_surface_level = function(pos_x, pos_y) {
	    if (!m_scenes.check_active()) {
	        m_print.error("No active scene");
	        return 0;
	    }
	    var active_scene = m_scenes.get_active();
	    if (!active_scene._render.water_params) {
	        m_print.error("No water parameters on the active scene");
	        return 0;
	    }
	    return m_scenes.get_water_surface_level(active_scene, pos_x, pos_y);
	};

	/**
	 * Set water params
	 * @method module:scenes.set_water_params
	 * @param {WaterParams} water_params Water parameters
	 * @cc_externs waves_height waves_length water_fog_density water_fog_color
	 * @cc_externs dst_noise_scale0 dst_noise_scale1 dst_noise_freq0 dst_noise_freq1
	 * @cc_externs dir_min_shore_fac dir_freq dir_noise_scale dir_noise_freq
	 * @cc_externs dir_min_noise_fac dst_min_fac waves_hor_fac water_dynamic
	 */
	exports.set_water_params = function(water_params) {
	    if (!m_scenes.check_active()) {
	        m_print.error("No active scene");
	        return;
	    }
	    var active_scene = m_scenes.get_active();
	    m_scenes.set_water_params(active_scene, water_params);
	};

	/**
	 * Get water material parameters.
	 * @method module:scenes.get_water_mat_params
	 * @param {WaterParams} water_params Water parameters
	 */
	exports.get_water_mat_params = function(water_params) {
	    if (!m_scenes.check_active()) {
	        m_print.error("No active scene");
	        return;
	    }
	    var active_scene = m_scenes.get_active();
	    m_scenes.get_water_mat_params(active_scene, water_params);
	};

	/**
	 * Update scene materials parameters.
	 * @method module:scenes.update_scene_materials_params
	 * @example var m_scenes = require("scenes");
	 *
	 * m_scenes.update_scene_materials_params();
	 */
	exports.update_scene_materials_params = function() {
	    if (!m_scenes.check_active()) {
	        m_print.error("No active scene");
	        return;
	    }
	    var active_scene = m_scenes.get_active();
	    m_scenes.update_scene_permanent_uniforms(active_scene);
	};
	/**
	 * Hide object and his children if it's necessary.
	 * Supported only for dynamic meshes/empties and lamps.
	 * @method module:scenes.hide_object
	 * @param {Object3D} obj Object 3D
	 * @param {boolean} [ignore_children=false] Don't hide child objects.
	 * @example var m_scenes = require("scenes");
	 * var cube = m_scenes.get_object_by_name("Cube");
	 *
	 * m_scenes.hide_object(cube); 
	 */
	exports.hide_object = function(obj, ignore_children) {
	    ignore_children = ignore_children || false;
	    if (!is_hideable(obj))
	        m_print.error("show/hide is only supported for dynamic objects.");
	    else
	        if (ignore_children)
	            m_scenes.change_visibility(obj, true);
	        else
	            m_scenes.change_visibility_rec(obj, true);
	};
	/**
	 * Show object and his children if it's necessary.
	 * Supported only for dynamic meshes/empties and lamps.
	 * @method module:scenes.show_object
	 * @param {Object3D} obj Object 3D
	 * @param {boolean} [ignore_children=false] Don't show child objects.
	 * @example var m_scenes = require("scenes");
	 *
	 * var cube = m_scenes.get_object_by_name("Cube");
	 *
	 * m_scenes.show_object(cube);
	 */
	exports.show_object = function(obj, ignore_children) {
	    ignore_children = ignore_children || false;
	    if (!is_hideable(obj))
	        m_print.error("show/hide is only supported for dynamic objects.");
	    else
	        if (ignore_children)
	            m_scenes.change_visibility(obj, false);
	        else
	            m_scenes.change_visibility_rec(obj, false);
	};
	/**
	 * Check if object is hidden.
	 * Supported only for dynamic meshes/empties and lamps.
	 * @method module:scenes.is_hidden
	 * @param {Object3D} obj Object 3D
	 * @returns {boolean} Check result
	 * @example var m_scenes = require("scenes");
	 *
	 * var cube = m_scenes.get_object_by_name("Cube");
	 *
	 * var object_is_hidden = m_scenes.is_hidden(cube);
	 */
	exports.is_hidden = function(obj) {
	    if (is_hideable(obj)) {
	        return m_scenes.is_hidden(obj);
	    } else {
	        m_print.error("show/hide is only supported for dynamic meshes/empties and lamps");
	        return false;
	    }
	};

	function is_hideable(obj) {
	    return m_obj_util.is_dynamic_mesh(obj) || m_obj_util.is_empty(obj)
	            || m_obj_util.is_line(obj) || m_obj_util.is_lamp(obj)
	}

	/**
	 * Check if object is visible.
	 * @method module:scenes.is_visible
	 * @param {Object3D} obj Object 3D
	 * @returns {boolean} Check result
	 * @example var m_scenes = require("scenes");
	 *
	 * var cube = m_scenes.get_object_by_name("Cube");
	 *
	 * var object_is_visible = m_scenes.is_visible(cube);
	 */
	exports.is_visible = function(obj) {
	    return obj.render.is_visible;
	};

	/**
	 * Check if object with given name is present on scene.
	 * @method module:scenes.check_object_by_name
	 * @param {string} name Object name
	 * @param {number} [data_id=0] ID of loaded data
	 * @returns {boolean} Check result
	 */
	exports.check_object_by_name = function(name, data_id) {
	    var obj = m_obj.get_object(m_obj.GET_OBJECT_BY_NAME, name,
	            data_id | 0, true);
	    if (obj)
	        return true;
	    else
	        return false;
	};

	/**
	 * Check if duplicated object is present on scene by empty name and dupli name.
	 * @method module:scenes.check_object_by_dupli_name
	 * @param {string} empty_name Name of the EMPTY object used to duplicate the object
	 * @param {string} dupli_name Name of the duplicated object
	 * @param {number} [data_id=0] ID of loaded data
	 * @returns {boolean} Check result
	 */
	exports.check_object_by_dupli_name = function(empty_name, dupli_name,
	        data_id) {
	    var obj = m_obj.get_object(m_obj.GET_OBJECT_BY_DUPLI_NAME, empty_name,
	            dupli_name, data_id | 0);
	    if (obj)
	        return true;
	    else
	        return false;
	};

	/**
	 * Check if duplicated object is present on scene by empty name and dupli name list.
	 * @method module:scenes.check_object_by_dupli_name_list
	 * @param {string[]} name_list List of the EMPTY and DUPLI object names: [empty_name,empty_name,...,dupli_name]
	 * @param {number} [data_id=0] ID of loaded data
	 * @returns {boolean} Check result
	 */
	exports.check_object_by_dupli_name_list = function(name_list, data_id) {
	    var obj = m_obj.get_object(m_obj.GET_OBJECT_BY_DUPLI_NAME_LIST,
	            name_list, data_id | 0);
	    if (obj)
	        return true;
	    else
	        return false;
	};

	/**
	 * Get all objects from the active scene.
	 * @method module:scenes.get_all_objects
	 * @param {string} [type="ALL"] Object type.
	 * @param {number} [data_id=DATA_ID_ALL] Objects data id
	 * @returns {Object3D[]} Array with objects.
	 * @example var m_scenes = require("scenes");
	 *
	 * // get objects of all types
	 * var scene_object_list = m_scenes.get_all_objects();
	 *
	 * // get all MESH objects
	 * var scene_object_list = m_scenes.get_all_objects("MESH");
	 *
	 * // get all SPEAKER objects from the first dynamically loaded scene
	 * var scene_object_list = m_scenes.get_all_objects("SPEAKER", 1);
	 */
	exports.get_all_objects = function(type, data_id) {
	    var scene = m_scenes.get_active();

	    if (!type)
	        type = "ALL";

	    if (!data_id && data_id !== 0)
	        data_id = m_obj.DATA_ID_ALL;

	    return m_obj.get_scene_objs_derived(scene, type, data_id);
	};

	/**
	 * Get the object's name.
	 * @method module:scenes.get_object_name
	 * @param {Object3D} obj Object 3D
	 * @returns {string} Object name
	 * @example var m_scenes = require("scenes");
	 *
	 * var cube = m_scenes.get_object_by_name("Cube");
	 * 
	 * var object_name = m_scenes.get_object_name(cube);
	 */
	exports.get_object_name = function(obj) {
	    if (!obj) {
	        m_print.error("Wrong object name");
	        return "";
	    }
	    return obj.origin_name;
	};

	/**
	 * Get the object names hierarchy (considering dupli group parenting).
	 * @method module:scenes.get_object_name_hierarchy
	 * @param {Object3D} obj Object 3D
	 * @returns {?Array} Object names hierarchy array (from the highest parent to the object itself).
	 * @example var m_scenes = require("scenes");
	 *
	 * var cube = m_scenes.get_object_by_name("Cube");
	 *
	 * var name_hierarchy = m_scenes.get_object_name_hierarchy(cube);
	 */
	exports.get_object_name_hierarchy = function(obj) {
	    if (!obj) {
	        m_print.error("Wrong object name");
	        return null;
	    }

	    var names = [];
	    var curr_obj = obj;
	    while (curr_obj) {
	        names.push(curr_obj.origin_name);
	        curr_obj = m_obj_util.get_dg_parent(curr_obj);
	    }
	    return names.reverse();
	};

	/**
	 * Get the object's type.
	 * @method module:scenes.get_object_type
	 * @param {Object3D} obj Object 3D
	 * @returns {string} Object type
	 * @example var m_scenes = require("scenes");
	 *
	 * var cube = m_scenes.get_object_by_name("Cube");
	 *
	 * var object_type = m_scenes.get_object_type(cube);
	 */
	exports.get_object_type = function(obj) {
	    if (!(obj && obj.type)) {
	        m_print.error("Wrong object");
	        return "UNDEFINED";
	    }

	    return obj.type;
	};

	/**
	 * Return the object's children.
	 * @method module:scenes.get_object_children
	 * @param {Object3D} obj Object 3D
	 * @returns {Object3D[]} Array of children objects.
	 * @example var m_scenes = require("scenes");
	 *
	 * var cube = m_scenes.get_object_by_name("Cube");
	 *
	 * var object_children = m_scenes.get_object_children(cube);
	 */
	exports.get_object_children = function(obj) {
	    return obj.cons_descends.slice(0);
	};

	/**
	 * Find the first character on the active scene.
	 * @method module:scenes.get_first_character
	 * @returns {Object3D} Character object.
	 * @example var m_scenes = require("scenes");
	 *
	 * var character = m_scenes.get_first_character();
	 */
	exports.get_first_character = function() {
	    return m_obj.get_first_character(m_scenes.get_active());
	};

	/**
	 * Return the distance to the shore line.
	 * @method module:scenes.get_shore_dist
	 * @param {Vec3} trans Current translation.
	 * @param {number} [v_dist_mult=1] Vertical distance multiplier.
	 * @returns {number} Distance.
	 */
	exports.get_shore_dist = function(trans, v_dist_mult) {
	    if (!v_dist_mult && v_dist_mult !== 0)
	        v_dist_mult = 1;

	    if (!m_scenes.check_active()) {
	        m_print.error("No active scene");
	        return 0;
	    }

	    var active_scene = m_scenes.get_active();

	    return m_scenes.get_shore_dist(active_scene, trans, v_dist_mult);
	};

	/**
	 * Return the camera water depth or null if there is no water.
	 * @method module:scenes.get_cam_water_depth
	 * @returns {number} Depth
	 * @example var m_scenes = require("scenes");
	 *
	 * var water_depth = m_scenes.get_cam_water_depth();
	 */
	exports.get_cam_water_depth = function() {
	    return m_scenes.get_cam_water_depth();
	};

	/**
	 * Return render type of mesh object or null.
	 * @method module:scenes.get_type_mesh_object
	 * @param {Object3D} obj Object 3D.
	 * @returns {string} Render type: "DYNAMIC" or "STATIC" or ""(for non meshes).
	 * @example var m_scenes = require("scenes");
	 *
	 * var cube = m_scenes.get_object_by_name("Cube");
	 * var type = m_scenes.get_type_mesh_object(cube);
	 */
	exports.get_type_mesh_object = function(obj) {
	    if (m_obj_util.is_mesh(obj))
	        return obj.render.type;
	    return "";
	};

	/**
	 * Get the Blender-assigned meta tags from the active scene.
	 * @method module:scenes.get_meta_tags
	 * @returns {SceneMetaTags} Scene meta tags
	 * @example var m_scenes = require("scenes");
	 *
	 * var meta_tags = m_scenes.get_meta_tags();
	 */
	exports.get_meta_tags = function() {
	    if (!m_scenes.check_active()) {
	        m_print.error("No active scene");
	        return false;
	    }

	    var active_scene = m_scenes.get_active();

	    return m_scenes.get_meta_tags(active_scene);
	};

	/**
	 * Get the Blender-assigned custom property from the active scene.
	 * @method module:scenes.get_custom_prop
	 * @returns {*} Scene custom property
	 */
	exports.get_custom_prop = function() {
	    if (!m_scenes.check_active()) {
	        m_print.error("No active scene");
	        return false;
	    }

	    var active_scene = m_scenes.get_active();

	    return m_scenes.get_custom_prop(active_scene);
	};
	/**
	 * Append copied object to the scene.
	 * @method module:scenes.append_object
	 * @param {Object3D} obj Object 3D
	 * @param {string} [scene_name] Name of the scene
	 * @example var m_scs = require("scenes");
	 * var m_obj = require("objects");
	 *
	 * var src_obj = m_scs.get_object_by_name("Plane");
	 * var deep_copy = m_obj.copy(src_obj, "deep_copy", true); 
	 *
	 * m_scs.append_object(deep_copy);
	 */
	exports.append_object = function(obj, scene_name) {

	    if (scene_name) {
	        var scenes = m_scenes.get_all_scenes();
	        var scene = m_util.keysearch("name", scene_name, scenes);
	    } else
	        var scene = m_scenes.get_active();

	    m_scenes.append_object(scene, obj, true);
	};
	/**
	 * Remove dynamic object from all scenes.
	 * @method module:scenes.remove_object
	 * @param {Object3D} obj Object 3D
	 * @example var m_scenes = require("scenes");
	 *
	 * var cube = m_scenes.get_object_by_name("Cube");
	 * m_scenes.remove_object(cube);
	 */
	exports.remove_object = function(obj) {
	    if (!m_obj_util.is_dynamic_mesh(obj) && !m_obj_util.is_empty(obj) &&
	            !m_obj_util.is_line(obj)) {
	        m_print.error("Can't remove object \"" + obj.name + "\". It must be " +
	                "dynamic and type of MESH or EMPTY.");
	        return;
	    }

	    // cleanup only vbo/ibo/vao buffers for deep copied objects
	    m_obj.obj_switch_cleanup_flags(obj, obj.render.is_copied_deep, false, false);
	    m_data.prepare_object_unloading(obj);
	    m_obj.obj_switch_cleanup_flags(obj, true, true, true);
	    m_obj.remove_object(obj);
	};
	/**
	 * Get timeline marker frame by name.
	 * @method module:scenes.marker_frame
	 * @param {string} name Timeline marker name
	 * @returns {number} Timeline marker frame
	 */
	exports.marker_frame = function(name) {
	    var active_scene = m_scenes.get_active();
	    if (active_scene["timeline_markers"]
	            && name in active_scene["timeline_markers"])
	        return m_scenes.marker_frame(active_scene, name);
	    else {
	        m_print.error("\"" + name + "\" marker not found.");
	        return 0;
	    }
	};
	/**
	 * Get motion blur params.
	 * @method module:scenes.get_mb_params
	 * @returns {MotionBlurParams} Motion blur params
	 * @example var m_scenes = require("scenes");
	 *
	 * var motion_blur_params = m_scenes.get_mb_params();
	 */
	exports.get_mb_params = function() {
	    var scene = m_scenes.get_active();
	    var mb_subs = m_scenes.get_subs(scene, m_subs.MOTION_BLUR);
	    if (mb_subs) {
	        var mb_params = {mb_factor : mb_subs.mb_factor,
	                mb_decay_threshold : mb_subs.mb_decay_threshold};
	        return mb_params;
	    } else
	        return null;
	};
	/**
	 * Set motion blur params.
	 * @method module:scenes.set_mb_params
	 * @param {MotionBlurParams} mb_params Motion blur params
	 * @cc_externs mb_factor mb_decay_threshold
	 * @example var m_scenes = require("scenes");
	 *
	 * m_scenes.set_mb_params({ mb_factor: 0.1,
	 *                          mb_decay_threshold: 0.01 });
	 */
	exports.set_mb_params = function(mb_params) {
	    var scene = m_scenes.get_active();
	    var mb_subscenes = m_scenes.subs_array(scene, [m_subs.MOTION_BLUR]);

	    if (!mb_subscenes.length) {
	        m_print.error("The motion blur subscene doesn't exist.");
	        return;
	    }

	    for (var i = 0; i < mb_subscenes.length; i++) {
	        var mb_subs = mb_subscenes[i];
	        if (typeof mb_params.mb_decay_threshold == "number")
	            mb_subs.mb_decay_threshold = mb_params.mb_decay_threshold;
	        if (typeof mb_params.mb_factor == "number")
	            mb_subs.mb_factor = mb_params.mb_factor;
	    }
	};

	/**
	 * Check if objects can be selected.
	 * @method module:scenes.can_select_objects
	 * @returns {boolean} True if objects can be selected.
	 * @example var m_scenes = require("scenes");
	 *
	 * var objects_selectable = m_scenes.can_select_objects();
	 */
	exports.can_select_objects = function() {
	    var scene = m_scenes.get_active();
	    return Boolean(m_scenes.get_subs(scene, m_subs.COLOR_PICKING));
	};

	}

	var scenes_factory = register("scenes", Scenes);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Object transformations API.
	 * With some exceptions specified below, make sure that the objects are dynamic.
	 * @module transform
	 */
	function Transform(ns, exports) {

	var m_bounds   = int_boundings_factory(ns);
	var m_obj_util = int_obj_util_factory(ns);
	var m_phy      = int_physics_factory(ns);
	var m_print    = print_factory(ns);
	var m_quat     = quat_factory(ns);
	var m_trans    = int_transform_factory(ns);
	var m_tsr      = int_tsr_factory(ns);
	var m_util     = int_util_factory(ns);

	var _tsr_tmp = m_tsr.create();
	var _vec3_tmp = new Float32Array(3);
	var _quat4_tmp = new Float32Array(4);

	/**
	 * Set the object translation.
	 * @method module:transform.set_translation
	 * @param {Object3D} obj Object 3D
	 * @param {number} x X coord
	 * @param {number} y Y coord
	 * @param {number} z Z coord
	 */
	exports.set_translation = function(obj, x, y, z) {
	    if (m_obj_util.is_dynamic(obj)) {
	        _vec3_tmp[0] = x;
	        _vec3_tmp[1] = y;
	        _vec3_tmp[2] = z;

	        m_trans.set_translation(obj, _vec3_tmp);
	        m_trans.update_transform(obj);
	        m_phy.sync_transform(obj);
	    } else
	        m_print.error("Wrong object: \"" + obj.name + "\" is not dynamic.");
	};
	/**
	 * Set the object translation (in the coordinate space of its parent).
	 * @method module:transform.set_translation_rel
	 * @param {Object3D} obj Object 3D
	 * @param {number} x X coord
	 * @param {number} y Y coord
	 * @param {number} z Z coord
	 */
	exports.set_translation_rel = function(obj, x, y, z) {
	    if (m_obj_util.is_dynamic(obj)) {
	        _vec3_tmp[0] = x;
	        _vec3_tmp[1] = y;
	        _vec3_tmp[2] = z;

	        m_trans.set_translation_rel(obj, _vec3_tmp);
	        m_trans.update_transform(obj);
	        m_phy.sync_transform(obj);
	    } else
	        m_print.error("Wrong object: \"" + obj.name + "\" is not dynamic.");
	};

	/**
	 * Set the object translation (vector form).
	 * @method module:transform.set_translation_v
	 * @param {Object3D} obj Object 3D
	 * @param {Vec3} trans Translation vector
	 */
	exports.set_translation_v = function(obj, trans) {
	    if (m_obj_util.is_dynamic(obj)) {
	        m_trans.set_translation(obj, trans);
	        m_trans.update_transform(obj);
	        m_phy.sync_transform(obj);
	    } else
	        m_print.error("Wrong object: \"" + obj.name + "\" is not dynamic.");
	};

	/**
	 * Set the object translation in vector form
	 * (in the coordinate space of its parent).
	 * @method module:transform.set_translation_rel_v
	 * @param {Object3D} obj Object 3D
	 * @param {Vec3} trans Translation vector
	 */
	exports.set_translation_rel_v = function(obj, trans) {
	    if (m_obj_util.is_dynamic(obj)) {
	        m_trans.set_translation_rel(obj, trans);
	        m_trans.update_transform(obj);
	        m_phy.sync_transform(obj);
	    } else
	        m_print.error("Wrong object: \"" + obj.name + "\" is not dynamic.");
	};

	/**
	 * Set the object translation relatively to another object.
	 * @method module:transform.set_translation_obj_rel
	 * @param {Object3D} obj Transformed object
	 * @param {number} x X coord
	 * @param {number} y Y coord
	 * @param {number} z Z coord
	 * @param {Object3D} obj_ref Reference object
	 */
	exports.set_translation_obj_rel = function(obj, x, y, z, obj_ref) {
	    if (m_obj_util.is_dynamic(obj)) {
	        _vec3_tmp[0] = x;
	        _vec3_tmp[1] = y;
	        _vec3_tmp[2] = z;

	        var trans = m_tsr.get_trans_view(obj_ref.render.world_tsr);
	        var quat = m_tsr.get_quat_view(obj_ref.render.world_tsr);

	        m_util.transform_vec3(_vec3_tmp, 1, quat, trans, _vec3_tmp);

	        m_trans.set_translation(obj, _vec3_tmp);
	        m_trans.update_transform(obj);
	        m_phy.sync_transform(obj);
	    } else
	        m_print.error("Wrong object: \"" + obj.name + "\" is not dynamic.");
	};

	/**
	 * Get the object's translation vector.
	 * @method module:transform.get_translation
	 * @param {Object3D} obj Object 3D
	 * @param {Vec3} [dest] Destination vector
	 * @returns {Vec3} Destination vector
	 * @example 
	 * var m_scenes = require("scenes");
	 * var m_trans = require("transform");
	 * var m_vec3 = require("vec3");
	 * // precache 3D vector
	 * var _vec3_tmp = m_vec3.create();
	 * // ...
	 * var cube = m_scenes.get_object_by_name("Cube");
	 * var translation = m_trans.get_translation(cube, _vec3_tmp);
	 */
	exports.get_translation = function(obj, dest) {
	    if (!dest)
	        dest = new Float32Array(3);

	    m_trans.get_translation(obj, dest);
	    return dest;
	};

	/**
	 * Get the object's translation vector (in the coordinate space of its parent).
	 * @method module:transform.get_translation_rel
	 * @param {Object3D} obj Object 3D
	 * @param {Vec3} [dest] Destination vector
	 * @returns {Vec3} Destination vector
	 */
	exports.get_translation_rel = function(obj, dest) {
	    if (!dest)
	        dest = new Float32Array(3);

	    m_trans.get_translation_rel(obj, dest);
	    return dest;
	};

	/**
	 * Set the object's rotation quaternion.
	 * @method module:transform.set_rotation
	 * @param {Object3D} obj Object 3D
	 * @param {number} x X part of quaternion
	 * @param {number} y Y part of quaternion
	 * @param {number} z Z part of quaternion
	 * @param {number} w W part of quaternion
	 */
	exports.set_rotation = function(obj, x, y, z, w) {
	    if (m_obj_util.is_dynamic(obj)) {
	        _quat4_tmp[0] = x;
	        _quat4_tmp[1] = y;
	        _quat4_tmp[2] = z;
	        _quat4_tmp[3] = w;

	        m_trans.set_rotation(obj, _quat4_tmp);
	        m_trans.update_transform(obj);
	        m_phy.sync_transform(obj);
	    } else
	        m_print.error("Wrong object: \"" + obj.name + "\" is not dynamic.");
	};

	/**
	 * Set the object's rotation quaternion (in the coordinate space of its parent).
	 * @method module:transform.set_rotation_rel
	 * @param {Object3D} obj Object 3D
	 * @param {number} x X part of quaternion
	 * @param {number} y Y part of quaternion
	 * @param {number} z Z part of quaternion
	 * @param {number} w W part of quaternion
	 */
	exports.set_rotation_rel = function(obj, x, y, z, w) {
	    if (m_obj_util.is_dynamic(obj)) {
	        _quat4_tmp[0] = x;
	        _quat4_tmp[1] = y;
	        _quat4_tmp[2] = z;
	        _quat4_tmp[3] = w;

	        m_trans.set_rotation_rel(obj, _quat4_tmp);
	        m_trans.update_transform(obj);
	        m_phy.sync_transform(obj);
	    } else
	        m_print.error("Wrong object: \"" + obj.name + "\" is not dynamic.");
	};

	/**
	 * Set the object's rotation in vector form.
	 * @method module:transform.set_rotation_v
	 * @param {Object3D} obj Object 3D
	 * @param {Quat} quat Quaternion vector
	 */
	exports.set_rotation_v = function(obj, quat) {
	    if (m_obj_util.is_dynamic(obj)) {
	        m_trans.set_rotation(obj, quat);
	        m_trans.update_transform(obj);
	        m_phy.sync_transform(obj);
	    } else
	        m_print.error("Wrong object: \"" + obj.name + "\" is not dynamic.");
	};
	/**
	 * Set the object's rotation in vector form
	 * (in the coordinate space of its parent).
	 * @method module:transform.set_rotation_rel_v
	 * @param {Object3D} obj Object 3D
	 * @param {Quat} quat Quaternion vector
	 */
	exports.set_rotation_rel_v = function(obj, quat) {
	    if (m_obj_util.is_dynamic(obj)) {
	        m_trans.set_rotation_rel(obj, quat);
	        m_trans.update_transform(obj);
	        m_phy.sync_transform(obj);
	    } else
	        m_print.error("Wrong object: \"" + obj.name + "\" is not dynamic.");
	};
	/**
	 * Get the object's rotation in vector form
	 * (in the coordinate space of its parent).
	 * @method module:transform.set_rotation_rel_v
	 * @param {Object3D} obj Object 3D
	 * @param {Quat} quat Quaternion vector
	 * @returns {Quat} Destination vector
	 * @example 
	 * var m_scenes = require("scenes");
	 * var m_trans = require("transform");
	 * var m_quat  = require("quat");
	 * // precache quaternion
	 * var _quat_tmp = m_quat.create();
	 * // ...
	 * var cube = m_scenes.get_object_by_name("Cube");
	 * var rot_quat = m_trans.get_rotation_rel_v(cube, _quat_tmp);
	 */
	exports.get_rotation_rel_v = function(obj, quat) {
	    if (m_obj_util.is_dynamic(obj)) {
	        m_trans.get_rotation_rel(obj, quat);
	        return quat;
	    } else
	        m_print.error("Wrong object: \"" + obj.name + "\" is not dynamic.");
	};

	/**
	 * Get the object's rotation quaternion.
	 * @method module:transform.get_rotation
	 * @param {Object3D} obj Object 3D
	 * @param {Quat} [opt_dest] Destination vector
	 * @returns {Quat} Destination vector
	 * @example 
	 * var m_scenes = require("scenes");
	 * var m_trans = require("transform");
	 * var m_quat  = require("quat");
	 * // precache quaternion
	 * var _quat_tmp = m_quat.create();
	 * // ...
	 * var cube = m_scenes.get_object_by_name("Cube");
	 * var rot_quat = m_trans.get_rotation(cube, _quat_tmp);
	 */
	exports.get_rotation = function(obj, opt_dest) {
	    if (!opt_dest)
	        opt_dest = new Float32Array(4);

	    m_trans.get_rotation(obj, opt_dest);
	    return opt_dest;
	};

	/**
	 * Get the object's rotation quaternion
	 * (in the coordinate space of its parent).
	 * @method module:transform.get_rotation_rel
	 * @param {Object3D} obj Object 3D
	 * @param {Quat} [opt_dest] Destination vector
	 * @returns {Quat} Destination vector
	 */
	exports.get_rotation_rel = function(obj, opt_dest) {
	    if (!opt_dest)
	        opt_dest = new Float32Array(4);

	    m_trans.get_rotation_rel(obj, opt_dest);
	    return opt_dest;
	};

	/**
	 * Set euler rotation in the ZYX intrinsic system.
	 * Using euler angles is discouraged, use quaternion instead.
	 * @method module:transform.set_rotation_euler
	 * @param {Object3D} obj Object 3D
	 * @param {number} x Angle X in radians
	 * @param {number} y Angle Y in radians
	 * @param {number} z Angle Z in radians
	 */
	exports.set_rotation_euler = function(obj, x, y, z) {
	    if (m_obj_util.is_dynamic(obj)) {
	        _vec3_tmp[0] = x;
	        _vec3_tmp[1] = y;
	        _vec3_tmp[2] = z;

	        m_trans.set_rotation_euler(obj, _vec3_tmp);
	        m_trans.update_transform(obj);
	        m_phy.sync_transform(obj);
	    } else
	        m_print.error("Wrong object: \"" + obj.name + "\" is not dynamic.");
	};

	/**
	 * Get Euler rotation of object in the ZYX intrinsic system.
	 * Using euler angles is discouraged, use quaternion instead.
	 * @method module:transform.get_rotation_euler
	 * @param {Object3D} obj Object 3D
	 * @param {Euler} [dest = new Float32Array(3)] Destination vector
	 * @returns {Euler} Vector with Euler angles
	 */
	exports.get_rotation_euler = function(obj, dest) {
	    if (!dest)
	        dest = new Float32Array(3);

	    m_trans.get_rotation_euler(obj, dest);
	    return dest;
	};

	/**
	 * Get Euler rotation of object in the ZYX intrinsic system
	 * (in the coordinate space of its parent).
	 * Using euler angles is discouraged, use quaternion instead.
	 * @method module:transform.get_rotation_euler
	 * @param {Object3D} obj Object 3D
	 * @param {Euler} [dest = new Float32Array(3)] Destination vector
	 * @returns {Euler} Vector with Euler angles
	 */
	exports.get_rotation_euler_rel = function(obj, dest) {
	    if (!dest)
	        dest = new Float32Array(3);

	    m_trans.get_rotation_euler_rel(obj, dest);
	    return dest;
	};

	/**
	 * Set euler rotation in the ZYX intrinsic system
	 * (in the coordinate space of its parent).
	 * Using euler angles is discouraged, use quaternion instead.
	 * @method module:transform.set_rotation_euler_rel
	 * @param {Object3D} obj Object 3D
	 * @param {number} x Angle X in radians
	 * @param {number} y Angle Y in radians
	 * @param {number} z Angle Z in radians
	 */
	exports.set_rotation_euler_rel = function(obj, x, y, z) {
	    if (m_obj_util.is_dynamic(obj)) {
	        _vec3_tmp[0] = x;
	        _vec3_tmp[1] = y;
	        _vec3_tmp[2] = z;

	        m_trans.set_rotation_euler_rel(obj, _vec3_tmp);
	        m_trans.update_transform(obj);
	        m_phy.sync_transform(obj);
	    } else
	        m_print.error("Wrong object: \"" + obj.name + "\" is not dynamic.");
	};

	/**
	 * Set euler rotation in vector form.
	 * Using euler angles is discouraged, use quaternion instead.
	 * @method module:transform.set_rotation_euler_v
	 * @param {Object3D} obj Object 3D
	 * @param {Euler} euler Vector with euler angles
	 */
	exports.set_rotation_euler_v = function(obj, euler) {
	    if (m_obj_util.is_dynamic(obj)) {
	        m_trans.set_rotation_euler(obj, euler);
	        m_trans.update_transform(obj);
	        m_phy.sync_transform(obj);
	    } else
	        m_print.error("Wrong object: \"" + obj.name + "\" is not dynamic.");
	};

	/**
	 * Set euler rotation in vector form relatively to its parent
	 * (in the coordinate space of its parent).
	 * Using euler angles is discouraged, use quaternion instead.
	 * @method module:transform.set_rotation_euler_rel_v
	 * @param {Object3D} obj Object 3D
	 * @param {Euler} euler Vector with euler angles
	 */
	exports.set_rotation_euler_rel_v = function(obj, euler) {
	    if (m_obj_util.is_dynamic(obj)) {
	        m_trans.set_rotation_euler_rel(obj, euler);
	        m_trans.update_transform(obj);
	        m_phy.sync_transform(obj);
	    } else
	        m_print.error("Wrong object: \"" + obj.name + "\" is not dynamic.");
	};

	/**
	 * Set the object scale.
	 * @method module:transform.set_scale
	 * @param {Object3D} obj Object 3D
	 * @param {number} scale Object scale
	 */
	exports.set_scale = function(obj, scale) {
	    if (m_obj_util.is_dynamic(obj)) {
	        m_trans.set_scale(obj, scale);
	        m_trans.update_transform(obj);
	    } else
	        m_print.error("Wrong object: \"" + obj.name + "\" is not dynamic.");
	};

	/**
	 * Set the object's scale
	 * (in the coordinate space of its parent).
	 * @method module:transform.set_scale_rel
	 * @param {Object3D} obj Object 3D
	 * @param {number} scale Object scale
	 */
	exports.set_scale_rel = function(obj, scale) {
	    if (m_obj_util.is_dynamic(obj)) {
	        m_trans.set_scale_rel(obj, scale);
	        m_trans.update_transform(obj);
	    } else
	        m_print.error("Wrong object: \"" + obj.name + "\" is not dynamic.");
	};

	/**
	 * Get the object scale.
	 * @method module:transform.get_scale
	 * @param {Object3D} obj Object 3D
	 * @returns {number} scale
	 */
	exports.get_scale = function(obj) {
	    return m_trans.get_scale(obj);
	};

	/**
	 * Get the object scale
	 * (in the coordinate space of its parent).
	 * @method module:transform.get_scale_rel
	 * @param {Object3D} obj Object 3D
	 * @returns {number} scale
	 */
	exports.get_scale_rel = function(obj) {
	    return m_trans.get_scale_rel(obj);
	};

	/**
	 * Reset EMPTY's transform to allow child objects behave in the absolute (world) space.
	 * @method module:transform.empty_reset_transform
	 * @param {Object3D} obj Object 3D
	 */
	exports.empty_reset_transform = function(obj) {
	    if (obj.type != "EMPTY") {
	        m_print.error("Wrong object: " + obj.name);
	        return;
	    }

	    for (var i = 0; i < obj.cons_descends.length; i++)
	        if (!m_obj_util.is_dynamic(obj.cons_descends[i])) {
	            m_print.error("Wrong object: \"" + obj.cons_descends[i].name 
	                    + "\" is not dynamic.");
	            return;
	        }

	    m_trans.set_translation(obj, [0, 0, 0]);
	    m_trans.set_rotation(obj, [0, 0, 0, 1]);
	    m_trans.set_scale(obj, 1);
	    m_trans.update_transform(obj);
	    m_phy.sync_transform(obj);
	};

	/**
	 * Get object size (maximum radius, calculated from bounding box).
	 * @method module:transform.get_object_size
	 * @param {Object3D} obj Object 3D
	 * @returns {number} Object size
	 */
	exports.get_object_size = function(obj) {

	    if (!m_obj_util.is_mesh(obj)) {
	        m_print.error("Wrong object: " + obj.name);
	        return 0;
	    }

	    return m_trans.get_object_size(obj);
	};
	/**
	 * Get the object center in the world space.
	 * Works for dynamic and static objects.
	 * @method module:transform.get_object_center
	 * @param {Object3D} obj Object 3D
	 * @param {boolean} calc_bs_center Use the object's bounding sphere to
	 * calculate center, otherwise use the bounding box.
	 * @param {Vec3} [dest] Destination vector
	 * @returns {Vec3} Destination vector
	 */
	exports.get_object_center = function(obj, calc_bs_center, dest) {

	    if (!m_obj_util.is_mesh(obj)) {
	        m_print.error("Wrong object: " + obj.name);
	        return null;
	    }

	    if (!dest)
	        dest = new Float32Array(3);

	    return m_trans.get_object_center(obj, calc_bs_center, dest);
	};

	/**
	 * Perform incremental object translation in the local space.
	 * @method module:transform.move_local
	 * @param {Object3D} obj Object 3D
	 * @param {number} dx Translation offset along X axis
	 * @param {number} dy Translation offset along Y axis
	 * @param {number} dz Translation offset along Z axis
	 */
	exports.move_local = function(obj, dx, dy, dz) {
	    if (m_obj_util.is_dynamic(obj)) {
	        m_trans.move_local(obj, dx, dy, dz);
	        m_trans.update_transform(obj);
	        m_phy.sync_transform(obj);
	    } else
	        m_print.error("Wrong object: \"" + obj.name + "\" is not dynamic.");
	};

	/**
	 * Perform incremental rotation around X axis in the local space.
	 * @method module:transform.rotate_x_local
	 * @param {Object3D} obj Object 3D
	 * @param {number} angle Angle in radians
	 */
	exports.rotate_x_local = function(obj, angle) {
	    if (m_obj_util.is_dynamic(obj)) {
	        var quat = m_quat.setAxisAngle(m_util.AXIS_X, angle, _quat4_tmp);
	        m_trans.rotate_local(obj, quat);
	        m_trans.update_transform(obj);
	        m_phy.sync_transform(obj);
	    } else
	        m_print.error("Wrong object: \"" + obj.name + "\" is not dynamic.");
	};

	/**
	 * Perform incremental rotation around Y axis in the local space.
	 * @method module:transform.rotate_y_local
	 * @param {Object3D} obj Object 3D
	 * @param {number} angle Angle in radians
	 */
	exports.rotate_y_local = function(obj, angle) {
	    if (m_obj_util.is_dynamic(obj)) {
	        var quat = m_quat.setAxisAngle(m_util.AXIS_MY, angle, _quat4_tmp);
	        m_trans.rotate_local(obj, quat);
	        m_trans.update_transform(obj);
	        m_phy.sync_transform(obj);
	    } else
	        m_print.error("Wrong object: \"" + obj.name + "\" is not dynamic.");
	};

	/**
	 * Perform incremental rotation around Z axis in the local space.
	 * @method module:transform.rotate_z_local
	 * @param {Object3D} obj Object 3D
	 * @param {number} angle Angle in radians
	 */
	exports.rotate_z_local = function(obj, angle) {
	    if (m_obj_util.is_dynamic(obj)) {
	        var quat = m_quat.setAxisAngle(m_util.AXIS_Z, angle, _quat4_tmp);
	        m_trans.rotate_local(obj, quat);
	        m_trans.update_transform(obj);
	        m_phy.sync_transform(obj);
	    } else
	        m_print.error("Wrong object: \"" + obj.name + "\" is not dynamic.");
	};

	/**
	 * Get object bounding box.
	 * @method module:transform.get_object_bounding_box
	 * @param {Object3D} obj Object 3D
	 * @returns {BoundingBox} Bounding box
	 * @cc_externs max_x min_x max_y min_y max_z min_z
	 */
	exports.get_object_bounding_box = function(obj) {
	    return m_bounds.clone_bb(obj.render.bb_world);
	};

	/**
	 * Set the object's TSR vector.
	 * @method module:transform.set_tsr
	 * @param {Object3D} obj Object 3D
	 * @param {TSR} tsr vector
	 */
	exports.set_tsr = function(obj, tsr) {
	    if (m_obj_util.is_dynamic(obj)) {
	        m_trans.set_tsr(obj, tsr);
	        m_trans.update_transform(obj);
	        m_phy.sync_transform(obj);
	    } else
	        m_print.error("Wrong object: \"" + obj.name + "\" is not dynamic.");
	};

	/**
	 * Set the object's TSR vector
	 * (in the coordinate space of its parent).
	 * @method module:transform.set_tsr_rel
	 * @param {Object3D} obj Object 3D
	 * @param {TSR} tsr vector
	 */
	exports.set_tsr_rel = function(obj, tsr) {
	    if (m_obj_util.is_dynamic(obj)) {
	        m_trans.set_tsr_rel(obj, tsr);
	        m_trans.update_transform(obj);
	        m_phy.sync_transform(obj);
	    } else
	        m_print.error("Wrong object: \"" + obj.name + "\" is not dynamic.");
	};

	/**
	 * Return an object's transformation in TSR form.
	 * @method module:transform.get_tsr
	 * @param {Object3D} obj Object 3D
	 * @param {TSR} [dest] Destination vector.
	 * @returns {TSR} Destination vector.
	 */
	exports.get_tsr = function(obj, dest) {
	    if (!dest)
	        dest = new Float32Array(8);

	    m_trans.get_tsr(obj, dest);

	    return dest;
	};

	/**
	 * Return the object transformation in TSR form.
	 * (in the coordinate space of its parent).
	 * @method module:transform.get_tsr_rel
	 * @param {Object3D} obj Object 3D
	 * @param {TSR} [dest] Destination vector.
	 * @returns {TSR} Destination vector.
	 */
	exports.get_tsr_rel = function(obj, dest) {
	    if (!dest)
	        dest = new Float32Array(8);

	    m_trans.get_tsr_rel(obj, dest);

	    return dest;
	};

	/**
	 * Get distance between the two objects.
	 * @method module:transform.distance
	 * @param {Object3D} obj1 The first object.
	 * @param {Object3D} obj2 The second object.
	 * @returns {number} Distance
	 */
	exports.distance = function(obj1, obj2) {
	    return m_trans.distance(obj1, obj2);
	};

	/**
	 * Set the object's transformation matrix.
	 * It's better to use TSR form.
	 * @method module:transform.set_matrix
	 * @param {Object3D} obj Object 3D
	 * @param {Mat4} mat Matrix
	 */
	exports.set_matrix = function(obj, mat) {
	    if (m_obj_util.is_dynamic(obj)) {
	        m_tsr.from_mat4(mat, _tsr_tmp);
	        m_trans.set_tsr(obj, _tsr_tmp);
	        m_trans.update_transform(obj);
	        m_phy.sync_transform(obj);
	    } else
	        m_print.error("Wrong object: \"" + obj.name + "\" is not dynamic.");
	};

	/**
	 * Set the object's transformation matrix
	 * (in the coordinate space of its parent).
	 * It's better to use TSR form.
	 * @method module:transform.set_matrix_rel
	 * @param {Object3D} obj Object 3D
	 * @param {Mat4} mat Matrix
	 */
	exports.set_matrix_rel = function(obj, mat) {
	    if (m_obj_util.is_dynamic(obj)) {
	        m_tsr.from_mat4(mat, _tsr_tmp);
	        m_trans.set_tsr_rel(obj, _tsr_tmp);
	        m_trans.update_transform(obj);
	        m_phy.sync_transform(obj);
	    } else
	        m_print.error("Wrong object: \"" + obj.name + "\" is not dynamic.");
	};

	/**
	 * Return the object's transformation matrix.
	 * It's better to use TSR form.
	 * @method module:transform.get_matrix
	 * @param {Object3D} obj Object 3D
	 * @param {Mat4} [dest] Destination matrix.
	 * @returns {Mat4} Destination matrix.
	 */
	exports.get_matrix = function(obj, dest) {
	    if (!dest)
	        dest = new Float32Array(16);

	    m_trans.get_tsr(obj, _tsr_tmp);
	    m_tsr.to_mat4(_tsr_tmp, dest);

	    return dest;
	};

	/**
	 * Return the object's transformation matrix
	 * (in the coordinate space of its parent).
	 * It's better to use TSR form.
	 * @method module:transform.get_matrix_rel
	 * @param {Object3D} obj Object 3D
	 * @param {Mat4} [dest] Destination matrix.
	 * @returns {Mat4} Destination matrix.
	 */
	exports.get_matrix_rel = function(obj, dest) {
	    if (!dest)
	        dest = new Float32Array(16);

	    m_trans.get_tsr_rel(obj, _tsr_tmp);
	    m_tsr.to_mat4(_tsr_tmp, dest);

	    return dest;
	};

	}

	var transform_factory = register("transform", Transform);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Contains various utility methods for math, searching etc.
	 * @module util
	 */
	function Util(ns, exports) {

	var m_compat   = int_compat_factory(ns);
	var m_print    = print_factory(ns);
	var m_quat     = quat_factory(ns);
	var m_tbn      = int_tbn_factory(ns);
	var m_util     = int_util_factory(ns);
	var m_vec3     = vec3_factory(ns);

	/**
	 * X-axis vector.
	 * @const {Vec3} module:util.AXIS_X
	 */
	exports.AXIS_X  = new Float32Array([1, 0, 0]);
	/**
	 * Y-axis vector.
	 * @const {Vec3} module:util.AXIS_Y
	 */
	exports.AXIS_Y  = new Float32Array([0, 1, 0]);
	/**
	 * Z-axis vector.
	 * @const {Vec3} module:util.AXIS_Z
	 */
	exports.AXIS_Z  = new Float32Array([0, 0, 1]);
	/**
	 * Negative x-axis vector.
	 * @const {Vec3} module:util.AXIS_MX
	 */
	exports.AXIS_MX = new Float32Array([-1, 0, 0]);
	/**
	 * Negative y-axis vector.
	 * @const {Vec3} module:util.AXIS_MY
	 */
	exports.AXIS_MY = new Float32Array([ 0,-1, 0]);
	/**
	 * Negative z-axis vector.
	 * @const {Vec3} module:util.AXIS_MZ
	 */
	exports.AXIS_MZ = new Float32Array([ 0, 0,-1]);

	/**
	 * Rotation sequence enum.
	 * @typedef {number} RotationSequence
	 */

	/**
	 * Rotation sequence: XYX.
	 * @const {RotationSequence} module:util.XYX
	 */
	exports.XYX = m_util.XYX;
	/**
	 * Rotation sequence: YZY.
	 * @const {RotationSequence} module:util.YZY
	 */
	exports.YZY = m_util.YZY;
	/**
	 * Rotation sequence: ZXZ.
	 * @const {RotationSequence} module:util.ZXZ
	 */
	exports.ZXZ = m_util.ZXZ;
	/**
	 * Rotation sequence: XZX.
	 * @const {RotationSequence} module:util.XZX
	 */
	exports.XZX = m_util.XZX;
	/**
	 * Rotation sequence: YXY.
	 * @const {RotationSequence} module:util.YXY
	 */
	exports.YXY = m_util.YXY;
	/**
	 * Rotation sequence: ZYZ.
	 * @const {RotationSequence} module:util.ZYZ
	 */
	exports.ZYZ = m_util.ZYZ;
	/**
	 * Rotation sequence: XYZ.
	 * @const {RotationSequence} module:util.XYZ
	 */
	exports.XYZ = m_util.XYZ;
	/**
	 * Rotation sequence: YZX.
	 * @const {RotationSequence} module:util.YZX
	 */
	exports.YZX = m_util.YZX;
	/**
	 * Rotation sequence: ZXY.
	 * @const {RotationSequence} module:util.ZXY
	 */
	exports.ZXY = m_util.ZXY;
	/**
	 * Rotation sequence: XZY.
	 * @const {RotationSequence} module:util.XZY
	 */
	exports.XZY = m_util.XZY;
	/**
	 * Rotation sequence: YXZ.
	 * @const {RotationSequence} module:util.YXZ
	 */
	exports.YXZ = m_util.YXZ;
	/**
	 * Rotation sequence: ZYX.
	 * @const {RotationSequence} module:util.ZYX
	 */
	exports.ZYX = m_util.ZYX;

	/**
	 * Create a new Float32Array.
	 * @param {number|Array|TypedArray} param Constructor param
	 * @returns {Float32Array} New Float32Array.
	 */
	exports.f32 = function(param) {
	    param = param || 0;
	    return m_util.f32(param);
	};

	/**
	 * Abort the program if assertion is false.
	 * @method module:util.assert
	 * @param {boolean} Boolean expression result
	 */
	exports.assert = m_util.assert;

	/**
	 * Search for object in array.
	 * @method module:util.keyfind
	 * @param {string} key Key
	 * @param {*} value Value
	 * @param {Object[]} array Array of objects.
	 * @returns {Object[]} Array of found objects.
	 */
	exports.keyfind = m_util.keyfind;

	/**
	 * Search for object in array.
	 * @method module:util.keysearch
	 * @param {string} key Key.
	 * @param {*} value Value.
	 * @param {Array} array Array of objects.
	 * @returns {?Object} First found object or null.
	 */
	exports.keysearch = m_util.keysearch;

	/**
	 * Extract rotation from the 4x4 matrix to quaternion vector.
	 * @method module:util.matrix_to_quat
	 * @param {Mat4} matrix 4x4 matrix
	 * @returns {Quat} Quaternion
	 */
	exports.matrix_to_quat = function(matrix) {
	    return m_util.matrix_to_quat(matrix);
	};

	/**
	 * Convert euler angles in the ZYX intrinsic system to quaternion.
	 * @method module:util.euler_to_quat
	 * @param {Euler} euler Euler angles. The angles order: an angle of the rotation around the x axis,
	 * an angle of the rotation around the y axis, an angle of the rotation around the z axis.
	 * @param {Quat} [quat] Destination quaternion vector.
	 * @returns {Quat} Quaternion vector.
	 */
	exports.euler_to_quat = function(euler, quat) {
	    if (!quat)
	        quat = new Float32Array(4);

	    return m_util.euler_to_quat(euler, quat);
	};

	/**
	 * Convert Euler angles in the ordered intrinsic system to quaternion.
	 * @method module:util.ordered_angles_to_quat
	 * @param {Euler} angles Ordered Euler angles. Euler angles have the same order as
	 * the intrinsic rotation sequence.
	 * @param {RotationSequence} order Intrinsic rotation sequence.
	 * @param {Quat} [quat] Destination quaternion vector.
	 * @returns {Quat} Quaternion vector.
	 */
	exports.ordered_angles_to_quat = function(angles, order, quat) {
	    if (!quat)
	        quat = m_quat.create();

	    return m_util.ordered_angles_to_quat(angles, order, quat);
	};

	/**
	 * Convert quaternion to Euler angles in the ordered intrinsic system.
	 * @method module:util.quat_to_ordered_angles
	 * @param {Quat} quat Quaternion vector.
	 * @param {RotationSequence} order Intrinsic rotation sequence.
	 * @param {Euler} [angles] Destination Euler angles vector. Euler angles have 
	 * the same order as the intrinsic rotation sequence.
	 * @returns {Euler} Euler angles vector.
	 */
	exports.quat_to_ordered_angles = function(quat, order, angles) {
	    if (!angles)
	        angles = m_vec3.create();

	    return m_util.quat_to_ordered_angles(quat, order, angles);
	};

	/**
	 * Convert quaternion rotation to euler rotation.
	 * @method module:util.quat_to_euler
	 * @param {Quat} quat Quaternion vector
	 * @param {Euler} [euler] Destination euler vector
	 * @returns {Euler} Euler vector
	 */
	exports.quat_to_euler = function(quat, euler) {
	    if (!euler)
	        euler = new Float32Array(3);

	    return m_util.quat_to_euler(quat, euler);
	};

	/**
	 * Get sign of the number.
	 * @method module:util.sign
	 * @param {number} value Input value
	 * @returns {number} -1,0,1 for negative, zero or positive number accordingly
	 */
	exports.sign = m_util.sign;

	/**
	 * Clamp the number.
	 * @method module:util.clamp
	 * @param {number} value Input value
	 * @param {number} min Lower bound
	 * @param {number} max Upper bound
	 * @returns {number} Clamped value
	 */
	exports.clamp = m_util.clamp;

	/**
	 * Convert quaternion rotation to a directional vector.
	 * @method module:util.quat_to_dir
	 * @param {Quat} quat Rotation quaternion
	 * @param {Vec3} ident Identity vector
	 * @param {Vec3} [dest] Destination vector
	 * @returns {Vec3} Destination vector.
	 */
	exports.quat_to_dir = m_util.quat_to_dir;

	/**
	 * Project camera quaternion rotation on a horizontal plane.
	 * @method module:util.ground_project_cam_quat
	 * @param {Quat} quat Source quaternion.
	 * @param {Quat} [dest] Destination quaternion.
	 * @returns {Quat} Destination quaternion.
	 */
	exports.ground_project_cam_quat = function(quat, dest) {
	    return m_util.quat_project(quat, m_util.AXIS_MZ, m_util.AXIS_Z, m_util.AXIS_Y, dest);
	};

	/**
	 * Transform a camera quaternion to a mesh quaternion.
	 * @method module:util.cam_quat_to_mesh_quat
	 * @param {Quat} cam_quat Camera quaternion.
	 * @param {Quat} [dest] Destination quaternion.
	 * @returns {Quat} Destination quaternion.
	 */
	exports.cam_quat_to_mesh_quat = function(cam_quat, dest) {
	    return m_util.cam_quat_to_mesh_quat(cam_quat, dest);
	};

	/**
	 * Perform quaternion projection.
	 * @method module:util.quat_project
	 * @param {Quat} quat Quaternion to project.
	 * @param {Vec3} quat_ident_dir Direction corresponding to the identity quaternion.
	 * @param {Vec3} plane Plane direction (normal).
	 * @param {Vec3} plane_ident_dir Direction corresponding to the
	 * identity quaternion in a plane.
	 * @param {Quat} [dest=quat.create()] Destination quaternion.
	 * @returns {Quat} Destination quaternion.
	 */
	exports.quat_project = function(quat, quat_ident_dir,
	        plane, plane_ident_dir, dest) {

	    if (m_vec3.dot(plane, plane_ident_dir) != 0) {
	        m_print.error("Wrong in-plane direction");
	        return null;
	    }

	    return m_util.quat_project(quat, quat_ident_dir,
	            plane, plane_ident_dir, dest);
	};

	exports.hash_code = m_util.hash_code;

	/**
	 * Perform exponential smoothing.
	 * @method module:util.smooth
	 * @param {number} curr Current value.
	 * @param {number} last Last smoothed value.
	 * @param {number} delta Time delta.
	 * @param {number} period Mean lifetime for averaging.
	 * @returns {number} Smoothed value
	 */
	exports.smooth = m_util.smooth;

	/**
	 * Perform exponential smoothing (vector form).
	 * @method module:util.smooth_v
	 * @param {Float32Array} curr Current value.
	 * @param {Float32Array} last Last smoothed value.
	 * @param {Float32Array} delta Time delta.
	 * @param {Float32Array} period Mean lifetime for averaging.
	 * @param {Float32Array} [dest] Smoothed value
	 * @returns {Float32Array} Smoothed value
	 */
	exports.smooth_v = m_util.smooth_v;

	/**
	 * Check if object is a vector.
	 * @method module:util.is_vector
	 * @param {Object} o Object
	 * @param {number} [dimension=0] Dimension, allow any if not specified
	 * @returns {boolean} Check result
	 */
	exports.is_vector = m_util.is_vector;

	/**
	 * Correct the camera quaternion rotation.
	 * @method module:util.correct_cam_quat_up
	 * @param {Quat} quat Quaternion to correct
	 * @param {boolean} up_only Disable upside-down camera view
	 */
	exports.correct_cam_quat_up = m_util.correct_cam_quat_up;

	exports.quat_to_angle_axis = m_util.quat_to_angle_axis;

	exports.random_from_array = m_util.random_from_array;

	exports.horizontal_direction = m_util.horizontal_direction;

	/**
	 * Convert radian angle into range [0, 2PI)
	 * @method module:util.angle_wrap_0_2pi
	 * @param {number} angle Angle in radians
	 * @returns {number} Converted angle
	 */
	exports.angle_wrap_0_2pi = m_util.angle_wrap_0_2pi;

	/**
	 * Convert radian angle into custom range [from, to)
	 * @method module:util.angle_wrap_periodic
	 * @param {number} angle Angle in radians
	 * @param {number} from Value from in radians
	 * @param {number} to Value to in radians
	 * @returns {number} Converted angle
	 */
	exports.angle_wrap_periodic = m_util.angle_wrap_periodic;

	/**
	 * Smooth step function.
	 * @method module:util.smooth_step
	 * @param {number} t Input value.
	 * @param {number} min Min clamping value.
	 * @param {number} max Max clamping value.
	 * @returns {number} Result value.
	 */
	exports.smooth_step = m_util.smooth_step;

	/**
	 * Linear interpolation function.
	 * @method module:util.lerp
	 * @param {number} t Input value.
	 * @param {number} from Start interpolation value.
	 * @param {number} to End interpolation value.
	 * @returns {number} Result value.
	 */
	exports.lerp = m_util.lerp;

	/**
	 * Convert degrees to radians.
	 * @method module:util.deg_to_rad
	 * @param {number} degrees Angle in degrees.
	 * @returns {number} Angle in radians.
	 */
	exports.deg_to_rad = m_util.deg_to_rad;

	/**
	 * Convert radians to degrees.
	 * @method module:util.rad_to_deg
	 * @param {number} radians Angle in radians.
	 * @returns {number} Angle in degrees.
	 */
	exports.rad_to_deg = m_util.rad_to_deg;
	/**
	 * Convert directional vector to quaternion.
	 * @method module:util.dir_to_quat
	 * @param {Vec3} dir Directional vector.
	 * @param {Vec3} ident Identity vector
	 * @param {Quat} [dest] Destination quaternion
	 * @returns {Quat} Destination quaternion
	 */
	exports.dir_to_quat = m_util.dir_to_quat;

	/**
	 * Check if Internet Explorer 11 is using.
	 * @method module:util.is_ie11
	 * @returns {boolean} Check result.
	 */
	exports.is_ie11 = m_compat.is_ie11;

	/**
	 * Generate flat array of TBN quaternions
	 * @method module:util.gen_tbn_quats
	 * @param {Float32Array} normals Flat array of normals.
	 * @param {Float32Array} [tangents] Flat array of tangents.
	 * @returns {Float32Array} Flat array of quaternions.
	 */
	exports.gen_tbn_quats = m_tbn.get;

	/**
	 * Returns the integer part of the given number.
	 * @method module:util.trunc
	 * @param {number} value Original value.
	 * @returns {number} Truncated value.
	 */
	exports.trunc = m_util.trunc;

	}

	var util_factory = register("util", Util);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Application add-on.
	 * Provides generic routines for the engine's initialization, UI and I/O.
	 * @module app
	 * @local AppInitCallback
	 * @local AnimFinishCallback
	 * @local QueueObject
	 */

	function App(ns, exports) {

	var m_cam    = camera_factory(ns);
	var m_cfg    = config_factory(ns);
	var m_cons   = constraints_factory(ns);
	var m_cont   = container_factory(ns);
	var m_ctl    = controls_factory(ns);
	var m_data   = data_factory(ns);
	var m_dbg    = debug_factory(ns);
	var m_input  = input_factory(ns);
	var m_main   = main_factory(ns);
	var m_phy    = physics_factory(ns);
	var m_print  = print_factory(ns);
	var m_screen = screen_factory(ns);
	var m_scs    = scenes_factory(ns);
	var m_trans  = transform_factory(ns);
	var m_util   = util_factory(ns);
	var m_vec3   = vec3_factory(ns);

	// Constants used for the target camera
	var TARGET_KEY_ZOOM_POW1     = 1.0;
	var TARGET_KEY_ZOOM_POW2     = 0.15;
	var TARGET_TOUCH_ZOOM_FACTOR = 0.03;

	// Constants used for the eye camera
	var EYE_KEY_TRANS_FACTOR   = 5.0;
	var EYE_ROTATION_DECREMENT = 0.5;

	// Constants used for both target and eye camera
	var TARGET_EYE_MOUSE_ROT_MULT_PX = 0.003;
	var TARGET_EYE_MOUSE_PAN_MULT_PX = 0.00075;
	var TARGET_EYE_TOUCH_ROT_MULT_PX = 0.003;
	var TARGET_EYE_TOUCH_PAN_MULT_PX = 0.00075;
	var TARGET_EYE_KEY_ROT_FACTOR    = 0.75;

	// Constants used for the hover camera
	var HOVER_MOUSE_PAN_MULT_PX        = 0.003;
	var HOVER_MOUSE_ROT_MULT_PX        = 0.00075;
	var HOVER_TOUCH_PAN_MULT_PX        = 0.003;
	var HOVER_TOUCH_ROT_MULT_PX        = 0.003;
	var HOVER_KEY_TRANS_FACTOR         = 0.5;
	var HOVER_KEY_ZOOM_FACTOR          = 30.0;
	var HOVER_MOUSE_TOUCH_TRANS_FACTOR = 0.2;
	var HOVER_MOUSE_ZOOM_FACTOR        = 2.0;
	var HOVER_TOUCH_ZOOM_FACTOR        = 2.0;
	var HOVER_ZOOM_FACTOR_MIN          = 2.0;
	var HOVER_SPEED_MIN                = 1.0;


	var _smooth_factor = 1;
	// Constants used for camera smoothing
	var CAM_SMOOTH_ZOOM_MOUSE      = 0.1;
	var CAM_SMOOTH_ZOOM_TOUCH      = 0.15;
	var CAM_SMOOTH_ROT_TRANS_MOUSE = 0.08;
	var CAM_SMOOTH_ROT_TRANS_TOUCH = 0.12;

	// Constants used for camera physics
	var CHAR_HEAD_POSITION          = 0.5;
	var CAM_COLL_DELTA              = 0.25;

	// NOTE: EPSILON_DELTA << EPSILON_DISTANCE to prevent camera freezing near pivot
	var EPSILON_DISTANCE = 0.001;
	var EPSILON_DELTA    = 0.00001;

	var FRAME_WAITING_PER = 10;

	var AXIS_THRESHOLD = 0.1;

	var TRANS_GMPD_KOEF = 0.002;
	var ZOOM_GMPD_KOEF = 0.05;

	var LOW_BANDWIDTH_LIMIT = 1.5;

	// Cached HTML elements
	var _fps_logger_elem = null;

	// Global flags used for re-initializing of application camera controls
	// (which should be done after switching camera type)
	var _disable_default_pivot   = false;
	var _disable_letter_controls = false;
	var _disable_zoom            = false;
	var _element                 = null;
	var _allow_element_exit      = false;
	var _disable_gamepad_controls = false;

	// Cached arrays
	var _vec2_tmp  = new Float32Array(2);
	var _vec2_tmp2 = new Float32Array(2);
	var _vec3_tmp  = new Float32Array(3);
	var _vec3_tmp2 = new Float32Array(3);
	var _quat4_tmp = new Float32Array(4);
	var _velocity_tmp = {};

	var _limits_tmp = {};

	/**
	 * Application initialization callback.
	 * @callback AppInitCallback
	 * @param {HTMLElement} canvas Initialized canvas element.
	 * @param {boolean} success Success flag.
	 */

	/**
	 * Initialize the engine.
	 * The "options" object may be extended by adding properties from the engine's
	 * configuration (see {@link module:config|config} module).
	 * In that case they will be applied before engine initialization.
	 * @param {Object}   [options={}] Initialization options.
	 * @param {string}   [options.canvas_container_id=null] Canvas container ID.
	 * @param {AppInitCallback} [options.callback=function(){}] Initialization callback.
	 * @param {string[]}  [options.error_purge_elements=null] Array of IDs of HTML 
	 * elements to be removed in case of initialization error.
	 * @param {boolean}  [options.show_hud_debug_info=false] Show HUD with
	 * developer info.
	 * @param {boolean}  [options.show_fps=false] Show FPS counter.
	 * @param {string}   [options.fps_elem_id=null] Custom fps counter id.
	 * @param {string}   [options.fps_wrapper_id=null] Show FPS wrapper with
	 * current id.
	 * @param {boolean}  [options.report_init_failure=true] Show elements with info
	 * about init failure
	 * @param {boolean}  [options.pause_invisible=true] Pause engine simulation if
	 * page is not visible (in other tab or minimized).
	 * @param {boolean}  [options.key_pause_enabled=true] Enable key pause
	 * @param {boolean}  [options.autoresize=false] Automatically resize canvas to
	 * match the size of container element.
	 * @param {number}  [options.force_container_ratio=0] Automatically resize
	 * canvas container height, based on its width and passed ratio value.
	 * @param {boolean} [options.min_capabilities=false] Set min capability mode
	 * @param {boolean} [options.debug_loading=false] Print loading info into the console
	 * @cc_externs canvas_container_id callback show_hud_debug_info
	 * @cc_externs sfx_mix_mode show_fps fps_elem_id error_purge_elements
	 * @cc_externs report_init_failure pause_invisible key_pause_enabled
	 * @cc_externs alpha alpha_sort_threshold assets_dds_available assets_pvr_available
	 * @cc_externs assets_min50_available quality fps_wrapper_id
	 * @cc_externs console_verbose physics_enabled autoresize track_container_position
	 * @cc_externs force_container_ratio from to elem prop cb duration opt_prefix
	 * @cc_externs opt_suffix min_capabilities srgb_type debug_loading
	 */

	exports.init = function(options) {
	    options = options || {};

	    var autoresize = false;
	    var canvas_container_id = null;
	    var callback = function() {};
	    var error_purge_elements = null;
	    var fps_elem_id = null;
	    var force_container_ratio = 0;
	    var fps_wrapper_id = null;
	    var key_pause_enabled = true;
	    var min_capabilities = false;
	    var pause_invisible = true;
	    var report_init_failure = true;
	    var sfx_mix_mode = false;
	    var show_fps = false;
	    var show_hud_debug_info = false;
	    var track_container_position = false;
	    var quality = m_cfg.get("quality");

	    for (var opt in options) {
	        switch (opt) {
	        case "canvas_container_id":
	            canvas_container_id = options.canvas_container_id;
	            break;
	        case "callback":
	            callback = options.callback;
	            break;
	        case "autoresize":
	            autoresize = options.autoresize;
	            break;
	        case "show_hud_debug_info":
	            show_hud_debug_info = options.show_hud_debug_info;
	            break;
	        case "sfx_mix_mode":
	            sfx_mix_mode = options.sfx_mix_mode;
	            break;
	        case "show_fps":
	            show_fps = options.show_fps;
	            break;
	        case "track_container_position":
	            track_container_position = options.track_container_position;
	            m_print.error_once("track_container_position deprecated. " +
	                    "Not needed anymore. Use the container.get_coords_target_space method.");
	            break;
	        case "fps_wrapper_id":
	            fps_wrapper_id = options.fps_wrapper_id;
	            break;
	        case "fps_elem_id":
	            fps_elem_id = options.fps_elem_id;
	            break;
	        case "error_purge_elements":
	            error_purge_elements = options.error_purge_elements;
	            break;
	        case "report_init_failure":
	            report_init_failure = options.report_init_failure;
	            break;
	        case "pause_invisible":
	            pause_invisible = options.pause_invisible;
	            break;
	        case "key_pause_enabled":
	            key_pause_enabled = options.key_pause_enabled;
	            break;
	        case "force_container_ratio":
	            force_container_ratio = options.force_container_ratio;
	            break;
	        case "min_capabilities":
	            min_capabilities = options.min_capabilities;
	            break;
	        case "quality":
	            quality = options.quality;
	            break;
	        default:
	            m_cfg.set(opt, options[opt]);
	            break;
	        }
	    }

	    if (quality != m_cfg.P_AUTO)
	        m_cfg.set("quality", quality);

	    var on_key_pause = function(e) {
	        if (e.keyCode == m_ctl.KEY_P) {
	            if (m_main.is_paused())
	                m_main.resume();
	            else
	                m_main.pause();
	        }
	    };

	    if (key_pause_enabled)
	        document.addEventListener("keydown", on_key_pause, false);

	    m_cfg.set("show_hud_debug_info", show_hud_debug_info);
	    m_cfg.set("sfx_mix_mode", sfx_mix_mode);

	    var init_hud_canvas = show_hud_debug_info || sfx_mix_mode || null;

	    var onload_cb = function() {
	        var init_ok = setup_canvas(canvas_container_id, init_hud_canvas,
	                report_init_failure, error_purge_elements);

	        var canvas_elem = m_cont.get_canvas();

	        if (!init_ok) {
	            callback(canvas_elem, false);

	            return;
	        }

	        var canvas_container_elem = m_cont.get_container();

	        m_cont.resize_to_container();

	        if (show_fps) {
	            create_fps_logger_elem(fps_elem_id, fps_wrapper_id);
	            m_main.set_fps_callback(fps_callback);
	        }

	        if (pause_invisible) {
	            handle_page_visibility();
	            handle_position_visibility();
	        }

	        if (force_container_ratio) {
	            m_main.append_loop_cb(function() {
	                canvas_container_elem.style.height =
	                    canvas_container_elem.clientWidth / force_container_ratio + "px";
	            });
	        }

	        if (autoresize)
	            m_main.append_loop_cb(function() {
	                m_cont.resize_to_container();
	            });

	        if (track_container_position) {
	            m_main.append_loop_cb(function() {
	                m_cont.force_offsets_updating();
	            });
	        }

	        if (min_capabilities)
	            m_cfg.reset_limits();

	        if (quality == m_cfg.P_AUTO) {
	            m_dbg.test_performance(function(time, bw) {
	                if (time == 0) {
	                    m_print.log("QUALITY TEST RESULT: UNSUPPORTED, using HIGH");
	                    m_cfg.apply_quality(m_cfg.P_HIGH);
	                } else if (bw < LOW_BANDWIDTH_LIMIT) {
	                    m_print.log("QUALITY TEST RESULT: LOW (" + bw.toFixed(1) + " GB/s)");
	                    m_cfg.apply_quality(m_cfg.P_LOW);
	                } else {
	                    m_print.log("QUALITY TEST RESULT: HIGH (" + bw.toFixed(1) + " GB/s)");
	                    m_cfg.apply_quality(m_cfg.P_HIGH);
	                }

	                callback(canvas_elem, true);
	            });
	        } else
	            callback(canvas_elem, true);
	    };

	    var onunload_cb = function() {
	        m_data.cleanup();
	    };

	    if (document.readyState == "complete")
	        window.setTimeout(onload_cb, 0);
	    else
	        window.addEventListener("load", onload_cb, false);

	    window.addEventListener("unload", onunload_cb, false);
	};

	function handle_page_visibility() {

	    var was_paused = m_main.is_paused();

	    var visibility_change = function() {
	        if (document.hidden) {
	            was_paused = m_main.is_paused();
	            m_main.pause();
	        } else if (!was_paused)
	            m_main.resume();
	    };
	    document.addEventListener("visibilitychange", visibility_change, false);
	}

	function handle_position_visibility() {
	    var frame_counter = 0;
	    var container = m_cont.get_container();
	    var was_paused = m_main.is_paused();
	    var check_paused = true;

	    var visibility_change = function() {
	        if (frame_counter % FRAME_WAITING_PER == 0) {
	            var coords = container.getBoundingClientRect();
	            if (coords.top > window.innerHeight
	                    || coords.bottom < 0) {
	                if (check_paused)
	                    was_paused = m_main.is_paused();
	                m_main.pause();
	                check_paused = false;
	            } else if (!was_paused && !check_paused) {
	                m_main.resume();
	                check_paused = true;
	            }
	        }
	        frame_counter++;
	    };
	    m_main.append_loop_cb(visibility_change);
	}

	function setup_canvas(canvas_container_id, init_hud_canvas,
	        report_init_failure, purge_elements) {

	    var canvas_elem = document.createElement("canvas");
	    var append_to = document.getElementById(canvas_container_id);

	    if (!append_to) {

	        m_print.error("Warning: canvas container \"" + canvas_container_id +
	            "\" not found, appending to body");
	        append_to = document.body;
	    }

	    canvas_elem.style.position = "absolute";
	    canvas_elem.style.left = 0;
	    canvas_elem.style.top = 0;
	    canvas_elem.style.width = append_to.offsetWidth + "px";
	    canvas_elem.style.height = append_to.offsetHeight + "px";
	    canvas_elem.width = append_to.offsetWidth * window.devicePixelRatio;
	    canvas_elem.height = append_to.offsetHeight * window.devicePixelRatio;

	    if (init_hud_canvas) {
	        var canvas_elem_hud = document.createElement("canvas");
	        // NOTE: pointer-events only for Chrome, Firefox, Safari
	        canvas_elem_hud.style.position = "absolute";
	        canvas_elem.style.left = 0;
	        canvas_elem.style.top = 0;
	        canvas_elem_hud.style.pointerEvents = "none";
	    } else
	        var canvas_elem_hud = null;

	    append_to.appendChild(canvas_elem);

	    if (!m_main.init(canvas_elem, canvas_elem_hud)) {
	        if (report_init_failure)
	            report_app_error("Browser could not initialize WebGL", "For more info visit",
	                    "https://www.blend4web.com/doc/en/problems_and_solutions.html#problems-upon-startup", purge_elements);
	        return false;
	    }

	    if (canvas_elem_hud)
	        m_cont.insert_to_container(canvas_elem_hud, "LAST");

	    return true;
	}

	function create_fps_logger_elem(fps_elem_id, fps_wrapper_id) {
	    if (fps_elem_id) {
	        if (fps_wrapper_id)
	            document.getElementById(fps_wrapper_id).style.display = "block";

	        _fps_logger_elem = document.getElementById(fps_elem_id);
	    } else {
	        _fps_logger_elem = document.createElement("div");
	        _fps_logger_elem.innerHTML = 0;
	        _fps_logger_elem.style.cssText =
	            "position:absolute;" +
	            "font-family: Arial, sans-serif;" +
	            "top: 20px;" +
	            "right: 20px;" +
	            "text-shadow: 0px 0px 6px #000;" +
	            "font-size: 40px;" +
	            "line-height: 50px;" +
	            "font-weight: bold;" +
	            "color: #fff;";

	        m_cont.insert_to_container(_fps_logger_elem, "JUST_AFTER_CANVAS");
	    }
	}

	function fps_callback(fps, phy_fps) {
	    var fps_str = String(fps);

	    if (phy_fps)
	        fps_str += "/" + String(phy_fps);

	    _fps_logger_elem.innerHTML = fps_str;
	}

	function elem_cloned(elem_id) {

	    var target = document.getElementById(elem_id);

	    // clone to prevent adding event listeners more than once
	    var new_element = target.cloneNode(true);
	    target.parentNode.replaceChild(new_element, target);

	    return new_element;
	}

	exports.set_onclick = function(elem_id, callback) {
	    var elem = elem_cloned(elem_id);
	    elem.addEventListener("mouseup", function(e) {
	        callback(elem.value);
	    }, false);
	};

	exports.set_onchange = function(elem_id, callback) {
	    var elem = elem_cloned(elem_id);
	    elem.addEventListener("change", function(e) {
	        var checked = elem.checked;
	        var rslt = checked != undefined ? checked : elem.value;
	        callback(rslt);
	    }, false);
	};

	exports.set_onkeypress = function(elem_id, callback) {
	    var elem = elem_cloned(elem_id);
	    elem.addEventListener("keypress", function(e) {
	        callback(e.keyCode, elem.value);
	    }, false);
	};

	function trans_hover_cam_horiz_local(camobj, dir, fact) {
	    var dist = Math.max(m_cam.hover_get_distance(camobj), HOVER_SPEED_MIN);

	    var obj_quat = m_trans.get_rotation(camobj, _quat4_tmp);
	    var abs_dir = m_util.quat_to_dir(obj_quat, dir, _vec3_tmp);
	    abs_dir[2] = 0;
	    m_vec3.normalize(abs_dir, abs_dir);
	    m_vec3.scale(abs_dir, dist * fact, abs_dir);

	    var obj_trans = m_trans.get_translation(camobj, _vec3_tmp2);
	    m_vec3.add(obj_trans, abs_dir, obj_trans);
	    m_cam.set_translation(camobj, obj_trans);
	}

	function zoom_hover_cam(camobj, fact) {
	    var limits = m_cam.hover_get_vertical_limits(camobj, _limits_tmp);
	    if (limits.up != limits.down) {
	        var y_angle = m_cam.get_camera_angles(camobj, _vec2_tmp2)[1];
	        var angle_factor = (limits.down - y_angle) / (limits.down - limits.up);
	        var dist_limits = m_cam.hover_get_distance_limits(camobj, _limits_tmp);
	        angle_factor = Math.max(angle_factor, HOVER_ZOOM_FACTOR_MIN / dist_limits.max);
	        m_cam.rotate_camera(camobj, 0, angle_factor * fact);
	    }
	}

	function trans_eye_cam_local(camobj, fact_x, fact_y, fact_z) {
	    fact_x *= EYE_KEY_TRANS_FACTOR;
	    fact_y *= EYE_KEY_TRANS_FACTOR;
	    fact_z *= EYE_KEY_TRANS_FACTOR;
	    m_trans.move_local(camobj, fact_x, fact_y, fact_z);
	}

	function calc_fact_from(fact_to) {
	    return fact_to / (1 - fact_to);
	}

	function trans_targ_cam_local(camobj, fact_view, elapsed) {
	    var dist = m_cam.target_get_distance(camobj);
	    var abs_fact_view = Math.abs(fact_view);
	    var fact = Math.pow(abs_fact_view * elapsed, TARGET_KEY_ZOOM_POW1
	            - Math.pow(abs_fact_view * elapsed, TARGET_KEY_ZOOM_POW2));

	    if (fact_view < 0)
	        if (dist > EPSILON_DISTANCE)
	            fact_view = - dist * fact;
	        else
	            fact_view = 0;
	    else
	        fact_view = dist * calc_fact_from(fact);

	    m_trans.move_local(camobj, 0, 0, fact_view);
	}

	function get_dest_mouse_touch(obj, value, fact, dist, dest_value) {
	    var t_mult = dist * fact;

	    for (var i = value; i > 0; --i) {
	        dist += t_mult;
	        dest_value += t_mult;
	        t_mult = dist * fact;
	    }
	    return dest_value;
	}

	function get_dest_zoom(obj, value, velocity_zoom, dest_value, dev_fact,
	        use_pivot) {

	    if (use_pivot) {
	        // camera zooming
	        var cam_pivot = m_cam.target_get_pivot(obj, _vec3_tmp);
	        var cam_eye = m_cam.get_translation(obj);
	        var dist = m_vec3.dist(cam_pivot, cam_eye) + dest_value;

	        if (value > 0)
	            dest_value = get_dest_mouse_touch(obj, value,
	                    -velocity_zoom, dist, dest_value);
	        else
	            dest_value = get_dest_mouse_touch(obj, -value,
	                    calc_fact_from(velocity_zoom), dist, dest_value);
	    } else
	        // use_hover == True
	        dest_value -= value * dev_fact * velocity_zoom;
	    return dest_value;
	}

	/**
	 * Assign keyboard and mouse controls to the active camera.
	 * (arrow keys, ADSW, wheel and others)
	 * @method module:app.enable_camera_controls
	 * @param {boolean} [disable_default_pivot=false] Do not use the possible
	 * camera-defined pivot point
	 * @param {boolean} [disable_letter_controls=false] Disable keyboard letter controls
	 * (only arrow keys will be used to control the camera).
	 * @param {boolean} [disable_zoom=false] Disable zoom
	 * @param {HTMLElement} [element] HTML element to add event listeners to. 
	 * The canvas container will be use by default.
	 * @param {boolean} [allow_element_exit=false] Continue receiving mouse events
	 * even when the mouse is leaving the HTML element
	 * @param {boolean} [disable_gamepad_controls=false] Disable gamepad controls
	 * @example 
	 * var m_app = require("app");
	 * m_app.enable_camera_controls();
	 */

	exports.enable_camera_controls = enable_camera_controls;

	function enable_camera_controls(disable_default_pivot, disable_letter_controls,
	                                disable_zoom, element, allow_element_exit,
	                                disable_gamepad_controls) {
	    _disable_default_pivot = disable_default_pivot;
	    _disable_letter_controls = disable_letter_controls;
	    _disable_zoom = disable_zoom;
	    _element = element;
	    _allow_element_exit = allow_element_exit;
	    _disable_gamepad_controls = disable_gamepad_controls;

	    var obj = m_scs.get_active_camera();
	    enable_cam_controls_resetting(obj);

	    var use_pivot = false;
	    var character = null;
	    var use_hover = false;

	    switch (m_cam.get_move_style(obj)) {
	    case m_cam.MS_TARGET_CONTROLS:
	        use_pivot = !disable_default_pivot;
	        break;
	    case m_cam.MS_EYE_CONTROLS:
	        character = m_scs.get_first_character();
	        break;
	    case m_cam.MS_STATIC:
	        return;
	    case m_cam.MS_HOVER_CONTROLS:
	        use_hover = true;
	        break;
	    }

	    var velocity = m_cam.get_velocities(obj, _velocity_tmp);

	    var elapsed = m_ctl.create_elapsed_sensor();

	    if (m_phy.has_simulated_physics(obj)) {

	        var collision = m_ctl.create_collision_sensor(obj, null, true);

	        var collision_cb = function(obj, id, pulse) {
	            var coll_dist = m_ctl.get_sensor_payload(obj, id, 0).coll_dist;
	            if (coll_dist < 0) {
	                var coll_norm = m_ctl.get_sensor_payload(obj, id, 0).coll_norm;
	                var recover_offset = _vec3_tmp;
	                m_vec3.scale(coll_norm, -CAM_COLL_DELTA * coll_dist, recover_offset);
	                var trans = m_trans.get_translation(obj, _vec3_tmp2);
	                m_vec3.add(trans, recover_offset, trans);
	                m_trans.set_translation_v(obj, trans);
	            }
	        };
	        m_ctl.create_sensor_manifold(obj, "CAMERA_COLLISION", m_ctl.CT_POSITIVE,
	                [collision], null, collision_cb);
	    }

	    if (character) {
	        // apply camera transform to character
	        var trans = m_trans.get_translation(obj);
	        var quat  = m_trans.get_rotation(obj);
	        var char_quat = m_util.cam_quat_to_mesh_quat(quat);

	        trans[2] -= CHAR_HEAD_POSITION;
	        m_phy.set_transform(character, trans, char_quat);
	        m_cons.append_stiff_trans(obj, character, [0, 0, 0.5]);

	        var char_dir = new Float32Array(2);

	        var is_fly = true;
	        m_phy.set_character_move_type(character, m_phy.CM_FLY);

	        var move_type_cb = function() {
	            is_fly = !is_fly;
	            m_phy.set_character_move_type(character,
	                is_fly ? m_phy.CM_FLY : m_phy.CM_WALK);
	        };

	        m_ctl.create_kb_sensor_manifold(obj, "TOGGLE_CHAR_MOVE_TYPE",
	                m_ctl.CT_SHOT, m_ctl.KEY_C, move_type_cb);
	    }

	    var key_cb = function(obj, id, pulse) {
	        if (pulse == 1) {

	            var elapsed = m_ctl.get_sensor_value(obj, id, 0);

	            m_cam.get_velocities(obj, velocity);
	            switch (id) {
	            case "FORWARD":
	                if (character)
	                    char_dir[0] = 1;
	                else if (use_hover) {
	                    var hover_angle = m_cam.get_camera_angles(obj, _vec2_tmp2)[1];
	                    var axis = (Math.abs(hover_angle) >= Math.PI / 4) ? m_util.AXIS_Y : m_util.AXIS_MZ;
	                    trans_hover_cam_horiz_local(obj, axis,
	                            velocity.trans * HOVER_KEY_TRANS_FACTOR * elapsed);
	                } else if (use_pivot)
	                    trans_targ_cam_local(obj, -velocity.zoom, elapsed);
	                else
	                    trans_eye_cam_local(obj, 0, 0, -velocity.trans * elapsed);
	                break;
	            case "BACKWARD":
	                if (character)
	                    char_dir[0] = -1;
	                else if (use_hover) {
	                    var hover_angle = m_cam.get_camera_angles(obj, _vec2_tmp2)[1];
	                    var axis = (Math.abs(hover_angle) >= Math.PI / 4) ? m_util.AXIS_MY : m_util.AXIS_Z;
	                    trans_hover_cam_horiz_local(obj, axis,
	                            velocity.trans * HOVER_KEY_TRANS_FACTOR * elapsed);
	                } else if (use_pivot)
	                    trans_targ_cam_local(obj, velocity.zoom, elapsed);
	                else
	                    trans_eye_cam_local(obj, 0, 0, velocity.trans * elapsed);
	                break;
	            case "UP":
	                if (use_hover)
	                    zoom_hover_cam(obj, - velocity.zoom * HOVER_KEY_ZOOM_FACTOR 
	                            * elapsed);
	                else if (!character)
	                    trans_eye_cam_local(obj, 0, velocity.trans * elapsed, 0);
	                break;
	            case "DOWN":
	                if (use_hover)
	                    zoom_hover_cam(obj, velocity.zoom * HOVER_KEY_ZOOM_FACTOR 
	                            * elapsed);
	                else if (!character)
	                    trans_eye_cam_local(obj, 0, -velocity.trans * elapsed, 0);
	                break;
	            case "LEFT":
	                if (character)
	                    char_dir[1] = 1;
	                else if (use_hover)
	                    trans_hover_cam_horiz_local(obj, m_util.AXIS_MX,
	                            velocity.trans * HOVER_KEY_TRANS_FACTOR * elapsed);
	                else
	                    trans_eye_cam_local(obj, -velocity.trans * elapsed, 0, 0);
	                break;
	            case "RIGHT":
	                if (character)
	                    char_dir[1] = -1;
	                else if (use_hover)
	                    trans_hover_cam_horiz_local(obj, m_util.AXIS_X,
	                            velocity.trans * HOVER_KEY_TRANS_FACTOR * elapsed);
	                else
	                    trans_eye_cam_local(obj, velocity.trans * elapsed, 0, 0);
	                break;
	            case "ROT_LEFT":
	                if (use_pivot)
	                    m_cam.rotate_camera(obj, -velocity.rot
	                            * TARGET_EYE_KEY_ROT_FACTOR * elapsed, 0);
	                else
	                    m_cam.rotate_camera(obj, velocity.rot * TARGET_EYE_KEY_ROT_FACTOR
	                            * elapsed, 0);
	                break;
	            case "ROT_RIGHT":
	                if (use_pivot)
	                    m_cam.rotate_camera(obj, velocity.rot
	                            * TARGET_EYE_KEY_ROT_FACTOR * elapsed, 0);
	                else
	                    m_cam.rotate_camera(obj, -velocity.rot * TARGET_EYE_KEY_ROT_FACTOR
	                            * elapsed, 0);
	                break;
	            case "ROT_UP":
	                if (use_pivot)
	                    m_cam.rotate_camera(obj, 0, -velocity.rot
	                            * TARGET_EYE_KEY_ROT_FACTOR * elapsed);
	                else
	                    m_cam.rotate_camera(obj, 0, velocity.rot
	                            * TARGET_EYE_KEY_ROT_FACTOR * elapsed);
	                break;
	            case "ROT_DOWN":
	                if (use_pivot)
	                    m_cam.rotate_camera(obj, 0, velocity.rot
	                            * TARGET_EYE_KEY_ROT_FACTOR * elapsed);
	                else
	                    m_cam.rotate_camera(obj, 0, -velocity.rot
	                            * TARGET_EYE_KEY_ROT_FACTOR * elapsed);
	                break;
	            default:
	                break;
	            }

	        } else {
	            switch (id) {
	            case "FORWARD":
	            case "BACKWARD":
	                if (character)
	                    char_dir[0] = 0;
	                break;
	            case "LEFT":
	            case "RIGHT":
	                if (character)
	                    char_dir[1] = 0;
	                break;
	            }
	        }

	        if (character) {
	            m_phy.set_character_move_dir(character, char_dir[0], char_dir[1]);
	            var angles = m_cam.get_camera_angles_char(obj, _vec2_tmp);
	            m_phy.set_character_rotation_h(character, angles[0]);
	            m_phy.set_character_vert_move_dir_angle(character, angles[1]);
	        }
	    };

	    var key_w, key_s, key_a, key_d, key_r, key_f, gmpd_btn_6, gmpd_btn_7;
	    var lh_axis, lv_axis, rh_axis, rv_axis;

	    if (!disable_gamepad_controls) {
	        var gmpd_indices = m_input.check_enable_gamepad_indices();
	        if (gmpd_indices.length)
	            var gamepad_id = gmpd_indices[gmpd_indices.length - 1];
	        else
	            var gamepad_id = 0;

	        gmpd_btn_6 = m_ctl.create_gamepad_btn_sensor(m_input.GMPD_BUTTON_6,
	                gamepad_id);
	        gmpd_btn_7 = m_ctl.create_gamepad_btn_sensor(m_input.GMPD_BUTTON_7,
	                gamepad_id);
	        lh_axis = m_ctl.create_gamepad_axis_sensor(m_input.GMPD_AXIS_0, gmpd_indices);
	        lv_axis = m_ctl.create_gamepad_axis_sensor(m_input.GMPD_AXIS_1, gmpd_indices);

	        rh_axis = m_ctl.create_gamepad_axis_sensor(m_input.GMPD_AXIS_2, gmpd_indices);
	        rv_axis = m_ctl.create_gamepad_axis_sensor(m_input.GMPD_AXIS_3, gmpd_indices);
	    } else
	        gmpd_btn_6 = gmpd_btn_7 = lh_axis = lv_axis = rh_axis = rv_axis =
	                m_ctl.create_custom_sensor(0);

	    if (!disable_letter_controls) {
	        key_w = m_ctl.create_keyboard_sensor(m_ctl.KEY_W);
	        key_s = m_ctl.create_keyboard_sensor(m_ctl.KEY_S);
	        key_a = m_ctl.create_keyboard_sensor(m_ctl.KEY_A);
	        key_d = m_ctl.create_keyboard_sensor(m_ctl.KEY_D);
	        key_r = m_ctl.create_keyboard_sensor(m_ctl.KEY_R);
	        key_f = m_ctl.create_keyboard_sensor(m_ctl.KEY_F);
	    } else
	        key_w = key_s = key_a = key_d = key_r = key_f = m_ctl.create_custom_sensor(0);

	    var key_up = m_ctl.create_keyboard_sensor(m_ctl.KEY_UP);
	    var key_down = m_ctl.create_keyboard_sensor(m_ctl.KEY_DOWN);
	    var key_left = m_ctl.create_keyboard_sensor(m_ctl.KEY_LEFT);
	    var key_right = m_ctl.create_keyboard_sensor(m_ctl.KEY_RIGHT);

	    // var key_single_logic = null;
	    // var key_double_logic = function(s) {
	    //     return s[0] && (s[1] || s[2]);
	    // }
	     var key_triple_logic = function(s) {
	        return s[0] && (s[1] || s[2] || s[3]);
	    };
	    var key_double_pos_logic = function(s) {
	        return s[0] && (s[1] || s[2] > AXIS_THRESHOLD);
	    };
	    var key_double_neg_logic = function(s) {
	        return s[0] && (s[1] || s[2] < -AXIS_THRESHOLD);
	    };
	    var key_triple_pos_logic = function(s) {
	        return s[0] && (s[1] || s[2] || s[3] > AXIS_THRESHOLD);
	    };
	    var key_triple_neg_logic = function(s) {
	        return s[0] && (s[1] || s[2] || s[3] < -AXIS_THRESHOLD);
	    };

	    if (!use_hover) {
	        m_ctl.create_sensor_manifold(obj, "FORWARD", m_ctl.CT_CONTINUOUS,
	                [elapsed, key_w, lv_axis], key_double_neg_logic, key_cb);
	        m_ctl.create_sensor_manifold(obj, "BACKWARD", m_ctl.CT_CONTINUOUS,
	                [elapsed, key_s, lv_axis], key_double_pos_logic, key_cb);
	    }

	    if (use_pivot) {
	        m_ctl.create_sensor_manifold(obj, "ROT_UP", m_ctl.CT_CONTINUOUS,
	                [elapsed, key_up, key_r, rv_axis], key_triple_neg_logic, key_cb);
	        m_ctl.create_sensor_manifold(obj, "ROT_DOWN", m_ctl.CT_CONTINUOUS,
	                [elapsed, key_down, key_f, rv_axis], key_triple_pos_logic, key_cb);
	        m_ctl.create_sensor_manifold(obj, "ROT_LEFT", m_ctl.CT_CONTINUOUS,
	                [elapsed, key_left, key_a, rh_axis], key_triple_neg_logic, key_cb);
	        m_ctl.create_sensor_manifold(obj, "ROT_RIGHT", m_ctl.CT_CONTINUOUS,
	                [elapsed, key_right, key_d, rh_axis], key_triple_pos_logic, key_cb);
	    } else if (use_hover) {
	        m_ctl.create_sensor_manifold(obj, "LEFT", m_ctl.CT_CONTINUOUS,
	                [elapsed, key_left, key_a, lh_axis], key_triple_neg_logic, key_cb);
	        m_ctl.create_sensor_manifold(obj, "RIGHT", m_ctl.CT_CONTINUOUS,
	                [elapsed, key_right, key_d, lh_axis], key_triple_pos_logic, key_cb);
	        m_ctl.create_sensor_manifold(obj, "FORWARD", m_ctl.CT_CONTINUOUS,
	                [elapsed, key_up, key_w, lv_axis], key_triple_neg_logic, key_cb);
	        m_ctl.create_sensor_manifold(obj, "BACKWARD", m_ctl.CT_CONTINUOUS,
	                [elapsed, key_down, key_s, lv_axis], key_triple_pos_logic, key_cb);
	        m_ctl.create_sensor_manifold(obj, "UP", m_ctl.CT_CONTINUOUS,
	                [elapsed, key_f, rv_axis], key_double_pos_logic, key_cb);
	        m_ctl.create_sensor_manifold(obj, "DOWN", m_ctl.CT_CONTINUOUS,
	                [elapsed, key_r, rv_axis], key_double_neg_logic, key_cb);
	    } else {
	        m_ctl.create_sensor_manifold(obj, "UP", m_ctl.CT_CONTINUOUS,
	                [elapsed, key_r, gmpd_btn_6], key_triple_logic, key_cb);
	        m_ctl.create_sensor_manifold(obj, "DOWN", m_ctl.CT_CONTINUOUS,
	                [elapsed, key_f, gmpd_btn_7], key_triple_logic, key_cb);
	        m_ctl.create_sensor_manifold(obj, "LEFT", m_ctl.CT_CONTINUOUS,
	                [elapsed, key_a, lh_axis], key_double_neg_logic, key_cb);
	        m_ctl.create_sensor_manifold(obj, "RIGHT", m_ctl.CT_CONTINUOUS,
	                [elapsed, key_d, lh_axis], key_double_pos_logic, key_cb);
	        m_ctl.create_sensor_manifold(obj, "ROT_UP", m_ctl.CT_CONTINUOUS,
	                [elapsed, key_up, rv_axis], key_double_neg_logic, key_cb);
	        m_ctl.create_sensor_manifold(obj, "ROT_DOWN", m_ctl.CT_CONTINUOUS,
	                [elapsed, key_down, rv_axis], key_double_pos_logic, key_cb);
	        m_ctl.create_sensor_manifold(obj, "ROT_LEFT", m_ctl.CT_CONTINUOUS,
	                [elapsed, key_left, rh_axis], key_double_neg_logic, key_cb);
	        m_ctl.create_sensor_manifold(obj, "ROT_RIGHT", m_ctl.CT_CONTINUOUS,
	                [elapsed, key_right, rh_axis], key_double_pos_logic, key_cb);
	    }

	    if (!disable_zoom) {
	        // mouse wheel: camera zooming and translation speed adjusting
	        var dest_zoom_mouse = 0;
	        var mouse_wheel = m_ctl.create_mouse_wheel_sensor(element);

	        // camera zooming with touch
	        var dest_zoom_touch = 0;
	        var touch_zoom = m_ctl.create_touch_zoom_sensor(element);

	        var mouse_wheel_cb = function(obj, id, pulse) {
	            if (pulse == 1) {
	                var value = m_ctl.get_sensor_value(obj, id, 0);
	                m_cam.get_velocities(obj, velocity);
	                if (use_pivot || use_hover) {
	                    dest_zoom_mouse = get_dest_zoom(obj, value, velocity.zoom,
	                            dest_zoom_mouse, HOVER_MOUSE_ZOOM_FACTOR, use_pivot);
	                } else {
	                    // translation speed adjusting
	                    var factor = value * velocity.zoom;
	                    velocity.trans *= (1 + factor);
	                    m_cam.set_velocities(obj, velocity);
	                }
	            }
	        };

	        m_ctl.create_sensor_manifold(obj, "MOUSE_WHEEL", m_ctl.CT_LEVEL,
	                [mouse_wheel], null, mouse_wheel_cb);

	        var touch_zoom_cb = function(obj, id, pulse, param) {
	            if (pulse == 1) {
	                var value = m_ctl.get_sensor_value(obj, id, 0);
	                m_cam.get_velocities(obj, velocity);

	                if (m_ctl.get_sensor_payload(obj, id, 0)
	                        === m_ctl.PL_MULTITOUCH_MOVE_ZOOM) {
	                    dest_zoom_touch = get_dest_zoom(obj, value, velocity.zoom
	                            * TARGET_TOUCH_ZOOM_FACTOR, dest_zoom_touch,
	                            HOVER_TOUCH_ZOOM_FACTOR, use_pivot);
	                }
	            }
	        };

	        m_ctl.create_sensor_manifold(obj, "TOUCH_ZOOM", m_ctl.CT_LEVEL,
	                [touch_zoom], null, touch_zoom_cb);

	        // camera zoom smoothing
	        var zoom_interp_cb = function(obj, id, pulse) {

	            if (use_pivot || use_hover) {
	                if (Math.abs(dest_zoom_mouse) > EPSILON_DELTA
	                        || Math.abs(dest_zoom_touch) > EPSILON_DELTA) {
	                    var value = m_ctl.get_sensor_value(obj, id, 0);
	                    var zoom_mouse = m_util.smooth(dest_zoom_mouse, 0, value,
	                            smooth_coeff_zoom_mouse());
	                    dest_zoom_mouse -= zoom_mouse;

	                    var zoom_touch = m_util.smooth(dest_zoom_touch, 0, value,
	                            smooth_coeff_zoom_touch());
	                    dest_zoom_touch -= zoom_touch;

	                    if (use_hover) {
	                        zoom_hover_cam(obj, - (zoom_mouse + zoom_touch));
	                    } else {
	                        var res_dist = m_cam.target_get_distance(obj)
	                            + zoom_mouse + zoom_touch;
	                        // NOTE: prevent zoom overshooting.
	                        res_dist = Math.max(res_dist, EPSILON_DISTANCE);
	                        m_cam.target_set_distance(obj, res_dist);
	                    }
	                } else {
	                    dest_zoom_mouse = 0;
	                    dest_zoom_touch = 0;
	                }
	            }
	        };

	        m_ctl.create_sensor_manifold(obj, "ZOOM_INTERPOL", m_ctl.CT_POSITIVE,
	                [elapsed], null, zoom_interp_cb);
	    }

	    // camera rotation and translation with mouse
	    var dest_x_mouse = 0;
	    var dest_y_mouse = 0;

	    // camera panning with mouse
	    var dest_pan_x_mouse = 0;
	    var dest_pan_y_mouse = 0;

	    var mouse_cb = function(obj, id, pulse, param) {
	        if (pulse == 1) {
	            var value = m_ctl.get_sensor_value(obj, id, 1);

	            m_cam.get_velocities(obj, velocity);
	            if (!use_hover) {
	                var left_mult  = TARGET_EYE_MOUSE_ROT_MULT_PX * velocity.rot;
	                var right_mult = TARGET_EYE_MOUSE_PAN_MULT_PX * velocity.trans;
	            } else {
	                var left_mult  = HOVER_MOUSE_PAN_MULT_PX * velocity.trans;
	                var right_mult = HOVER_MOUSE_ROT_MULT_PX * velocity.rot;
	            }

	            if (m_ctl.get_sensor_payload(obj, id, 0).which === 1) {
	                dest_x_mouse += (param == "X") ? -value * left_mult : 0;
	                dest_y_mouse += (param == "Y") ? -value * left_mult : 0;
	            } else if (m_ctl.get_sensor_payload(obj, id, 0).which === 2
	                    || m_ctl.get_sensor_payload(obj, id, 0).which === 3) {
	                dest_pan_x_mouse += (param == "X") ? -value * right_mult : 0;
	                dest_pan_y_mouse += (param == "Y") ? -value * right_mult : 0;
	            }
	        }
	    };

	    // camera panning with gamepad
	    var dest_pan_x_gmpd = 0;
	    var dest_pan_y_gmpd = 0;
	    if (!disable_gamepad_controls) {
	        var gmpd_panning_x_pos_cb = function(obj, id, pulse) {
	            m_cam.get_velocities(obj, velocity);
	            dest_pan_x_gmpd += velocity.trans * TRANS_GMPD_KOEF;
	        };
	        var gmpd_panning_y_pos_cb = function(obj, id, pulse) {
	            m_cam.get_velocities(obj, velocity);
	            dest_pan_y_gmpd += velocity.zoom * ZOOM_GMPD_KOEF;
	        };
	        var gmpd_panning_x_neg_cb = function(obj, id, pulse) {
	            m_cam.get_velocities(obj, velocity);
	            dest_pan_x_gmpd -= velocity.trans * TRANS_GMPD_KOEF;
	        };
	        var gmpd_panning_y_neg_cb = function(obj, id, pulse) {
	            m_cam.get_velocities(obj, velocity);
	            dest_pan_y_gmpd -= velocity.zoom * ZOOM_GMPD_KOEF;
	        };

	        if (use_pivot) {
	            m_ctl.create_sensor_manifold(obj, "GMPD_PAN_Y_POS", m_ctl.CT_CONTINUOUS,
	                    [gmpd_btn_6], null, gmpd_panning_y_pos_cb);
	            m_ctl.create_sensor_manifold(obj, "GMPD_PAN_Y_NEG", m_ctl.CT_CONTINUOUS,
	                    [gmpd_btn_7], null, gmpd_panning_y_neg_cb);
	            m_ctl.create_sensor_manifold(obj, "GMPD_PAN_X_POS", m_ctl.CT_CONTINUOUS,
	                    [lh_axis], function(s) {return s[0] < -AXIS_THRESHOLD}, gmpd_panning_x_neg_cb);
	            m_ctl.create_sensor_manifold(obj, "GMPD_PAN_X_NEG", m_ctl.CT_CONTINUOUS,
	                    [lh_axis], function(s) {return s[0] > AXIS_THRESHOLD}, gmpd_panning_x_pos_cb);
	        } else if (use_hover) {
	            m_ctl.create_sensor_manifold(obj, "GMPD_PAN_X_POS", m_ctl.CT_CONTINUOUS,
	                    [rh_axis], function(s) {return s[0] < -AXIS_THRESHOLD}, gmpd_panning_x_neg_cb);
	            m_ctl.create_sensor_manifold(obj, "GMPD_PAN_X_NEG", m_ctl.CT_CONTINUOUS,
	                    [rh_axis], function(s) {return s[0] > AXIS_THRESHOLD}, gmpd_panning_x_pos_cb);
	        }
	    }

	    if (allow_element_exit) {
	        var mouse_move_x = m_ctl.create_mouse_move_sensor("X", window);
	        var mouse_move_y = m_ctl.create_mouse_move_sensor("Y", window);
	        var mouse_down_c = m_ctl.create_mouse_click_sensor(element);
	        var mouse_down_w = m_ctl.create_mouse_click_sensor(window);

	        var element_exit_state = false;
	        var element_exit_logic = function(s) {
	            if (s[2])
	                element_exit_state = true;
	            else if (!s[0])
	                element_exit_state = false;
	            return element_exit_state && s[0];
	        };
	        m_ctl.create_sensor_manifold(obj, "MOUSE_X", m_ctl.CT_POSITIVE,
	                [mouse_down_w, mouse_move_x, mouse_down_c], element_exit_logic, mouse_cb, "X");
	        m_ctl.create_sensor_manifold(obj, "MOUSE_Y", m_ctl.CT_POSITIVE,
	                [mouse_down_w, mouse_move_y, mouse_down_c], element_exit_logic, mouse_cb, "Y");

	        var device = m_input.get_device_by_type_element(m_input.DEVICE_MOUSE, window);
	        m_input.switch_prevent_default(device, false);
	    } else {
	        var mouse_move_x = m_ctl.create_mouse_move_sensor("X", element);
	        var mouse_move_y = m_ctl.create_mouse_move_sensor("Y", element);
	        var mouse_down = m_ctl.create_mouse_click_sensor(element);
	        m_ctl.create_sensor_manifold(obj, "MOUSE_X", m_ctl.CT_POSITIVE,
	                [mouse_down, mouse_move_x], null, mouse_cb, "X");
	        m_ctl.create_sensor_manifold(obj, "MOUSE_Y", m_ctl.CT_POSITIVE,
	                [mouse_down, mouse_move_y], null, mouse_cb, "Y");
	    }

	    // camera rotation and translation with touch
	    var dest_x_touch = 0;
	    var dest_y_touch = 0;

	    // camera panning with touch
	    var dest_pan_x_touch = 0;
	    var dest_pan_y_touch = 0;

	    var touch_move_x = m_ctl.create_touch_move_sensor("X", element);
	    var touch_move_y = m_ctl.create_touch_move_sensor("Y", element);

	    var touch_cb = function(obj, id, pulse, param) {
	        if (pulse == 1) {
	            m_cam.get_velocities(obj, velocity);
	            if (use_hover)
	                var r_mult = HOVER_TOUCH_PAN_MULT_PX * velocity.trans;
	            else
	                var r_mult = TARGET_EYE_TOUCH_ROT_MULT_PX * velocity.rot;
	            var value = m_ctl.get_sensor_value(obj, id, 0);
	            if (m_ctl.get_sensor_payload(obj, id, 0).gesture
	                    === m_ctl.PL_SINGLE_TOUCH_MOVE) {
	                dest_x_touch += (param == "X") ? -value * r_mult : 0;
	                dest_y_touch += (param == "Y") ? -value * r_mult : 0;
	            } else if (m_ctl.get_sensor_payload(obj, id, 0).gesture
	                    ===  m_ctl.PL_MULTITOUCH_MOVE_PAN) {
	                if (!use_hover) {
	                    var pan_mult = TARGET_EYE_TOUCH_PAN_MULT_PX * velocity.trans;
	                } else {
	                    var pan_mult = HOVER_TOUCH_ROT_MULT_PX * velocity.rot;
	                }
	                dest_pan_x_touch += (param == "X") ? -value * pan_mult : 0;
	                dest_pan_y_touch += (param == "Y") ? -value * pan_mult : 0;
	            }
	        }
	    };

	    m_ctl.create_sensor_manifold(obj, "TOUCH_X", m_ctl.CT_POSITIVE,
	            [touch_move_x], null, touch_cb, "X");
	    m_ctl.create_sensor_manifold(obj, "TOUCH_Y", m_ctl.CT_POSITIVE,
	            [touch_move_y], null, touch_cb, "Y");

	    // camera rotation and translation smoothing
	    var rot_trans_interp_cb = function(obj, id, pulse) {
	        if (    Math.abs(dest_x_mouse) > EPSILON_DELTA ||
	                Math.abs(dest_y_mouse) > EPSILON_DELTA ||
	                Math.abs(dest_x_touch) > EPSILON_DELTA ||
	                Math.abs(dest_y_touch) > EPSILON_DELTA ||
	                Math.abs(dest_pan_x_mouse) > EPSILON_DELTA ||
	                Math.abs(dest_pan_y_mouse) > EPSILON_DELTA ||
	                Math.abs(dest_pan_x_touch) > EPSILON_DELTA ||
	                Math.abs(dest_pan_y_touch) > EPSILON_DELTA ||
	                Math.abs(dest_pan_x_gmpd) > EPSILON_DELTA ||
	                Math.abs(dest_pan_y_gmpd) > EPSILON_DELTA) {

	            var value = m_ctl.get_sensor_value(obj, id, 0);

	            var x_mouse = m_util.smooth(dest_x_mouse, 0, value,
	                    smooth_coeff_rot_trans_mouse());
	            var y_mouse = m_util.smooth(dest_y_mouse, 0, value,
	                    smooth_coeff_rot_trans_mouse());

	            dest_x_mouse -= x_mouse;
	            dest_y_mouse -= y_mouse;

	            var x_touch = m_util.smooth(dest_x_touch, 0, value,
	                    smooth_coeff_rot_trans_touch());
	            var y_touch = m_util.smooth(dest_y_touch, 0, value,
	                    smooth_coeff_rot_trans_touch());

	            dest_x_touch -= x_touch;
	            dest_y_touch -= y_touch;

	            var trans_x_mouse = m_util.smooth(dest_pan_x_mouse, 0,
	                    value, smooth_coeff_rot_trans_mouse());
	            var trans_y_mouse = m_util.smooth(dest_pan_y_mouse, 0,
	                    value, smooth_coeff_rot_trans_mouse());

	            dest_pan_x_mouse -= trans_x_mouse;
	            dest_pan_y_mouse -= trans_y_mouse;

	            var trans_x_touch = m_util.smooth(dest_pan_x_touch, 0,
	                    value, smooth_coeff_rot_trans_touch());
	            var trans_y_touch = m_util.smooth(dest_pan_y_touch, 0,
	                    value, smooth_coeff_rot_trans_touch());

	            dest_pan_x_touch -= trans_x_touch;
	            dest_pan_y_touch -= trans_y_touch;

	            var trans_x_gmpd = m_util.smooth(dest_pan_x_gmpd, 0,
	                    value, smooth_coeff_rot_trans_mouse());
	            var trans_y_gmpd = m_util.smooth(dest_pan_y_gmpd, 0,
	                    value, smooth_coeff_rot_trans_mouse());

	            dest_pan_x_gmpd -= trans_x_gmpd;
	            dest_pan_y_gmpd -= trans_y_gmpd;

	            if (use_pivot) {
	                m_cam.rotate_camera(obj, x_mouse + x_touch,
	                        y_mouse + y_touch);

	                var dist = m_cam.target_get_distance(obj);
	                m_cam.target_pan_pivot(obj,
	                        dist * (trans_x_mouse + trans_x_touch + trans_x_gmpd),
	                        dist * (trans_y_mouse + trans_y_touch + trans_y_gmpd));
	            } else if (use_hover) {
	                if (x_mouse + x_touch) {
	                    trans_hover_cam_horiz_local(obj, m_util.AXIS_X,
	                            (x_mouse + x_touch)
	                            * HOVER_MOUSE_TOUCH_TRANS_FACTOR);
	                }

	                if (y_mouse + y_touch) {
	                    var hover_angle = m_cam.get_camera_angles(obj, _vec2_tmp2)[1];
	                    var axis = (Math.abs(hover_angle) > Math.PI / 4) ? m_util.AXIS_MY : m_util.AXIS_Z;
	                    trans_hover_cam_horiz_local(obj, axis, (y_mouse + y_touch)
	                            * HOVER_MOUSE_TOUCH_TRANS_FACTOR);
	                }

	                m_cam.rotate_camera(obj, trans_x_mouse + trans_x_touch + trans_x_gmpd, 0);
	            } else {
	                m_cam.rotate_camera(obj, (x_mouse + x_touch) * EYE_ROTATION_DECREMENT,
	                        (y_mouse + y_touch) * EYE_ROTATION_DECREMENT);

	                if (character) {
	                    var angles = m_cam.get_camera_angles_char(obj, _vec2_tmp);
	                    m_phy.set_character_rotation_h(character, angles[0]);
	                    m_phy.set_character_vert_move_dir_angle(character, angles[1]);
	                }
	            }
	        }
	    };

	    m_ctl.create_sensor_manifold(obj, "ROT_TRANS_INTERPOL", m_ctl.CT_POSITIVE,
	            [elapsed], null, rot_trans_interp_cb);

	    m_ctl.create_kb_sensor_manifold(obj, "DEC_STEREO_DIST", m_ctl.CT_SHOT,
	            m_ctl.KEY_LEFT_SQ_BRACKET, function(obj, id, pulse) {
	                var dist = m_cam.get_stereo_distance(obj);
	                m_cam.set_stereo_distance(obj, 0.9 * dist);
	            });

	    m_ctl.create_kb_sensor_manifold(obj, "INC_STEREO_DIST", m_ctl.CT_SHOT,
	            m_ctl.KEY_RIGHT_SQ_BRACKET, function(obj, id, pulse) {
	                var dist = m_cam.get_stereo_distance(obj);
	                m_cam.set_stereo_distance(obj, 1.1 * dist);
	            });
	}

	/**
	 * Register sensors for resetting the camera controls if the camera move style
	 * was changed.
	 */
	function enable_cam_controls_resetting(cam) {
	    var prev_ms = m_cam.get_move_style(cam);
	    var move_style_cb = function() {
	        var curr_ms = m_cam.get_move_style(cam);
	        var is_changed = curr_ms != prev_ms;
	        prev_ms = curr_ms;
	        return is_changed;
	    };
	    var cb_sensor = m_ctl.create_callback_sensor(move_style_cb);

	    function reset_controls_cb(cam, id, pulse) {
	        disable_camera_controls();
	        enable_camera_controls(_disable_default_pivot, _disable_letter_controls,
	                _disable_zoom, _element, _allow_element_exit,
	                _disable_gamepad_controls);
	    }
	    m_ctl.create_sensor_manifold(cam, "CHANGE_MOVE_STYLE", m_ctl.CT_POSITIVE,
	            [cb_sensor], null, reset_controls_cb);
	}

	/**
	 * Disable controls for the active camera.
	 * @method module:app.disable_camera_controls
	 * @example 
	 * var m_app = require("app");
	 * m_app.disable_camera_controls();
	 */
	exports.disable_camera_controls = disable_camera_controls;
	function disable_camera_controls() {
	    var cam = m_scs.get_active_camera();

	    if (m_ctl.check_sensor_manifold(cam, "TOGGLE_CHAR_MOVE_TYPE")
	            && m_scs.get_first_character())
	        m_cons.remove(cam);

	    var cam_std_manifolds = ["FORWARD", "BACKWARD", "ROT_UP", "ROT_DOWN",
	            "ROT_LEFT", "ROT_RIGHT", "UP", "DOWN", "LEFT", "RIGHT",
	            "MOUSE_WHEEL", "TOUCH_ZOOM", "ZOOM_INTERPOL", "MOUSE_X", "MOUSE_Y",
	            "TOUCH_X", "TOUCH_Y", "ROT_TRANS_INTERPOL", "CHANGE_MOVE_STYLE", 
	            "TOGGLE_CHAR_MOVE_TYPE"];

	    for (var i = 0; i < cam_std_manifolds.length; i++)
	        m_ctl.remove_sensor_manifold(cam, cam_std_manifolds[i]);
	}

	/**
	 * Assign some controls to the non-camera object.
	 * @param {Object3D} obj Object 3D
	 * @param {HTMLElement} [element=Canvas container element] HTML element
	 */
	exports.enable_object_controls = function(obj, element) {
	    var trans_speed = 1;

	    var is_vehicle = m_phy.is_vehicle_chassis(obj) ||
	            m_phy.is_vehicle_hull(obj);

	    var key_cb = function(obj, id, pulse) {
	        if (pulse == 1) {
	            var elapsed = m_ctl.get_sensor_value(obj, id, 0);

	            switch (id) {
	            case "FORWARD":
	                if (is_vehicle)
	                    m_phy.vehicle_throttle(obj, 1);
	                else
	                    m_trans.move_local(obj, 0, -trans_speed * elapsed, 0);
	                break;
	            case "BACKWARD":
	                if (is_vehicle)
	                    m_phy.vehicle_throttle(obj, -1);
	                else
	                    m_trans.move_local(obj, 0, trans_speed * elapsed, 0);
	                break;
	            case "LEFT":
	                if (is_vehicle)
	                    m_phy.vehicle_steer(obj, -1);
	                else
	                    m_trans.move_local(obj, trans_speed * elapsed, 0, 0);
	                break;
	            case "RIGHT":
	                if (is_vehicle)
	                    m_phy.vehicle_steer(obj, 1);
	                else
	                    m_trans.move_local(obj, -trans_speed * elapsed, 0, 0);
	                break;
	            default:
	                break;
	            }
	        } else {
	            switch (id) {
	            case "FORWARD":
	            case "BACKWARD":
	                if (is_vehicle)
	                    m_phy.vehicle_throttle(obj, 0);
	                break;
	            case "LEFT":
	            case "RIGHT":
	                if (is_vehicle)
	                    m_phy.vehicle_steer(obj, 0);
	                break;
	            default:
	                break;
	            }
	        }
	    };

	    var elapsed = m_ctl.create_elapsed_sensor();

	    var key_w = m_ctl.create_keyboard_sensor(m_ctl.KEY_W);
	    var key_s = m_ctl.create_keyboard_sensor(m_ctl.KEY_S);
	    var key_a = m_ctl.create_keyboard_sensor(m_ctl.KEY_A);
	    var key_d = m_ctl.create_keyboard_sensor(m_ctl.KEY_D);

	    var key_up = m_ctl.create_keyboard_sensor(m_ctl.KEY_UP);
	    var key_down = m_ctl.create_keyboard_sensor(m_ctl.KEY_DOWN);
	    var key_left = m_ctl.create_keyboard_sensor(m_ctl.KEY_LEFT);
	    var key_right = m_ctl.create_keyboard_sensor(m_ctl.KEY_RIGHT);

	    var key_logic = function(s) {
	        return s[0] && (s[1] || s[2]);
	    };

	    m_ctl.create_sensor_manifold(obj, "FORWARD", m_ctl.CT_CONTINUOUS,
	            [elapsed, key_w, key_up], key_logic, key_cb);
	    m_ctl.create_sensor_manifold(obj, "BACKWARD", m_ctl.CT_CONTINUOUS,
	            [elapsed, key_s, key_down], key_logic, key_cb);
	    m_ctl.create_sensor_manifold(obj, "LEFT", m_ctl.CT_CONTINUOUS,
	            [elapsed, key_a, key_left], key_logic, key_cb);
	    m_ctl.create_sensor_manifold(obj, "RIGHT", m_ctl.CT_CONTINUOUS,
	            [elapsed, key_d, key_right], key_logic, key_cb);
	};

	/**
	 * Remove controls from the non-camera object.
	 * @param {Object3D} obj Object.
	 */
	exports.disable_object_controls = function(obj) {
	    var obj_std_manifolds = ["FORWARD", "BACKWARD", "LEFT", "RIGHT"];

	    for (var i = 0; i < obj_std_manifolds.length; i++)
	        m_ctl.remove_sensor_manifold(obj, obj_std_manifolds[i]);
	};

	/**
	 * Enable debug controls:
	 * <ul>
	 * <li>K - make camera debug shot
	 * <li>L - make light debug shot
	 * <li>M - flashback messages
	 * </ul>
	 */
	exports.enable_debug_controls = function() {
	    m_ctl.create_kb_sensor_manifold(null, "CAMERA_SHOT", m_ctl.CT_SHOT,
	            m_ctl.KEY_K, function() {m_dbg.make_camera_frustum_shot();});

	    m_ctl.create_kb_sensor_manifold(null, "LIGHT_SHOT", m_ctl.CT_SHOT,
	            m_ctl.KEY_L, function() {m_dbg.make_light_frustum_shot();});

	    m_ctl.create_kb_sensor_manifold(null, "TELEMETRY", m_ctl.CT_SHOT,
	            m_ctl.KEY_T, function() {m_dbg.plot_telemetry();});
	};

	/**
	 * Request fullscreen mode.
	 * Security issues: execute by user event.
	 * @method module:app.request_fullscreen
	 * @param {HTMLElement} elem Element
	 * @param {FullscreenEnabledCallback} enabled_cb Enabled callback
	 * @param {FullscreenDisabledCallback} disabled_cb Disabled callback
	 * @deprecated Use {@link module:screen.request_fullscreen} instead
	 */
	exports.request_fullscreen = function(elem, enabled_cb, disabled_cb) {
	    m_print.error_deprecated("request_fullscreen", "screen.request_fullscreen");
	    m_screen.request_fullscreen(elem, enabled_cb, disabled_cb);
	};

	/**
	 * Exit fullscreen mode.
	 * @method module:app.exit_fullscreen
	 * @deprecated Use {@link module:screen.exit_fullscreen} instead
	 */
	exports.exit_fullscreen = function() {
	    m_print.error_deprecated("exit_fullscreen", "screen.exit_fullscreen");
	    m_screen.exit_fullscreen();
	};

	/**
	 * Check whether fullscreen mode is available.
	 * @method module:app.check_fullscreen
	 * @returns {boolean} Result of the check.
	 * @deprecated Use {@link module:screen.check_fullscreen} instead
	 */
	exports.check_fullscreen = function() {
	    m_print.error_deprecated("check_fullscreen", "screen.check_fullscreen");
	    return m_screen.check_fullscreen();
	};

	exports.report_app_error = report_app_error;
	/**
	 * Report an application error.
	 * Creates standard HTML elements with error info and inserts them into the page body.
	 * @method module:app.report_app_error
	 * @param {string} text_message Message to place on upper element.
	 * @param {string} link_message Message to place on bottom element.
	 * @param {string} link Link to place on bottom element.
	 * @param {string[]} purge_elements Array of element IDs to destroy just before the error
	 * elements are inserted.
	 */
	function report_app_error(text_message, link_message, link, purge_elements) {

	    var elem = document.createElement("div");
	    var top_elem = document.createElement("div");
	    var bottom_elem = document.createElement("div");

	    if (purge_elements) {
	        for (var i = 0; i < purge_elements.length; i++) {
	            var purge_elem = document.getElementById(purge_elements[i]);

	            if (purge_elem)
	                purge_elem.parentNode.removeChild(purge_elem);
	        }
	    }

	    elem.style.cssText = "z-index:10;width:100%;height:auto;position:absolute;top:50%;margin-top:150px;text-align:center;";
	    top_elem.style.cssText = "color:#fff;font-size:24px;";
	    bottom_elem.style.cssText = "color:#fff;font-size:20px;";

	    top_elem.innerHTML = text_message;
	    bottom_elem.innerHTML = link_message + '   ' + '<a style="color:#fff;font-size:20px;width:100%;" href="' + link + '">'+link.replace("https://www.", "")+'</a>';

	    elem.appendChild(top_elem);
	    elem.appendChild(bottom_elem);

	    document.body.appendChild(elem);
	}

	/**
	 * Retrieve parameters of the page's URL.
	 * @param {boolean} [allow_param_array=false] Create arrays of parameters if they share the same name.
	 * @returns {Object|Null} URL parameters in a key-value format.
	 */
	exports.get_url_params = function(allow_param_array) {
	    allow_param_array = !!allow_param_array;

	    var url = decodeURIComponent(location.href.toString());

	    if (url.indexOf("?") == -1)
	        return null;

	    var params = url.split("?")[1].split("&");
	    var out = {};

	    for (var i = 0; i < params.length; i++) {
	        var param = params[i].split("=");
	        var prop_name = param[0];

	        if (param.length > 1) {
	            var prop_val = param[1];

	            if (allow_param_array) {
	                if (prop_name in out)
	                    out[prop_name].push(prop_val);
	                else
	                    out[prop_name] = [prop_val];
	            } else
	                out[prop_name] = prop_val;
	        } else {
	            if (allow_param_array) {
	                if (!(prop_name in out))
	                    out[prop_name] = [];
	            } else
	                out[prop_name] = '';
	        }
	    }

	    return out;
	};
	/**
	 * Animate css-property value.
	 * @method module:app.css_animate
	 * @param {HTMLElement} elem HTML-element.
	 * @param {string} prop Animated css-property.
	 * @param {number} from Value from.
	 * @param {number} to Value to.
	 * @param {number} timeout Time for animation.
	 * @param {string} [opt_prefix] Prefix of css-property (" scale(", "%" and etc).
	 * @param {string} [opt_suffix] Suffix of css-property (" px", "%" and etc).
	 * @param {GenericCallback} [opt_callback] Finish callback function.
	 */
	exports.css_animate = function(elem, prop, from, to, timeout, opt_prefix, opt_suffix, opt_callback) {
	    if (!elem || !prop || !isFinite(from) || !isFinite(to) || !isFinite(timeout))
	        return;

	    opt_prefix   = opt_prefix || "";
	    opt_suffix   = opt_suffix || "";
	    opt_callback = opt_callback || function() {};

	    var elem_style  = elem.style;
	    var vendor_prop = prop.charAt(0).toUpperCase() + prop.slice(1);

	    if (elem_style[prop] != undefined) {

	    } else if (elem_style["webkit" + vendor_prop] != undefined) {
	        prop = "webkit" + vendor_prop;
	    } else if (elem_style["ms" + vendor_prop] != undefined) {
	        prop = "ms" + vendor_prop;
	    } else if (elem_style["moz" + vendor_prop] != undefined) {
	        prop = "moz" + vendor_prop;
	    } else
	        return;

	    function css_anim_cb(val) {
	        if (!elem)
	            return;

	        elem_style[prop] = opt_prefix + val + opt_suffix;

	        if (from > to && val <= to || from < to && val >= to) {
	            elem_style[prop] = opt_prefix + to + opt_suffix;
	            opt_callback();
	        }
	    }

	    animate(elem, from, to, timeout, css_anim_cb);
	};

	/**
	 * Animate html tag attribute.
	 * @method module:app.attr_animate
	 * @param {HTMLElement} elem HTML-element.
	 * @param {string} attr_name Animated attribute name.
	 * @param {number} from Value from.
	 * @param {number} to Value to.
	 * @param {number} timeout Time for animation.
	 * @param {GenericCallback} [opt_callback] Finish callback function.
	 */
	exports.attr_animate = function(elem, attr_name, from, to, timeout, opt_callback) {
	    if (!elem || !attr_name || !isFinite(from) || !isFinite(to) || !isFinite(timeout))
	        return;

	    opt_callback = opt_callback || function() {};

	    function attr_anim_cb(val) {
	        if (!elem)
	            return;

	        if (val >= 0)
	            elem.setAttribute(attr_name, val);

	        if (from > to && val <= to || from < to && val >= to) {
	            elem.setAttribute(attr_name, to);
	            opt_callback();
	        }
	    }

	    animate(elem, from, to, timeout, attr_anim_cb);
	};

	// Animate value from "from" to "to" for "timeout" mseconds.
	function animate(elem, from, to, timeout, anim_cb) {
	    var start = performance.now();

	    function cb() {
	        var elapsed_total = performance.now() - start;
	        var value = from + elapsed_total * (to - from) / timeout;

	        anim_cb(value);

	        if (elapsed_total >= timeout || !elem.parentNode)
	            m_main.remove_loop_cb(cb);
	    }

	    m_main.append_loop_cb(cb);
	}

	/**
	 * Animation finish callback.
	 * @callback AnimFinishCallback
	 */

	/**
	 * Queue object params.
	 * @typedef {Object} QueueObject
	 * @property {string} type Animation type.
	 * @property {HTMLElement} elem Animated html element.
	 * @property {string} prop Animated property.
	 * @property {number} from Initial property value.
	 * @property {number} to Target property value.
	 * @property {number} duration Animation duration in ms.
	 * @property {string} [opt_prefix=''] Prefix for the css property.
	 * @property {string} [opt_suffix=''] Prefix for the css property.
	 * @property {AnimFinishCallback} [cb=function(){}] Animation finish callback.
	 */

	/**
	 * Animate queue of the html elements.
	 * @method module:app.queue_animate
	 * @param {QueueObject[]} queue Array of the queue objects.
	 */
	exports.queue_animate = function(queue) {
	    if (!queue.length)
	        return;

	    var queue_obj = queue.shift();

	    var elem     = queue_obj.elem;
	    var prop     = queue_obj.prop;
	    var from     = queue_obj.from;
	    var to       = queue_obj.to;
	    var duration = queue_obj.duration;

	    var prefix = queue_obj.opt_prefix;
	    var suffix = queue_obj.opt_suffix;

	    var cb = function() {
	        if (queue_obj.cb)
	            queue_obj.cb();

	        exports.queue_animate(queue);
	    };

	    if (queue_obj.type == "css")
	        exports.css_animate(elem, prop, from, to, duration, prefix, suffix, cb);
	    else if (queue_obj.type == "attr")
	        exports.attr_animate(elem, prop, from, to, duration, cb);
	};

	function smooth_coeff_zoom_mouse() {
	    return CAM_SMOOTH_ZOOM_MOUSE * _smooth_factor;
	}

	function smooth_coeff_zoom_touch() {
	    return CAM_SMOOTH_ZOOM_TOUCH * _smooth_factor;
	}

	function smooth_coeff_rot_trans_mouse() {
	    return CAM_SMOOTH_ROT_TRANS_MOUSE * _smooth_factor;
	}

	function smooth_coeff_rot_trans_touch() {
	    return CAM_SMOOTH_ROT_TRANS_TOUCH * _smooth_factor;
	}

	/**
	 * Set smooth factor for camera rotation and zoom.
	 * @method module:app.set_camera_smooth_factor
	 * @param {number} value New smooth factor
	 */
	exports.set_camera_smooth_factor = function(value) {
	    _smooth_factor = value;
	};

	/**
	 * Get smooth factor for camera rotation and zoom.
	 * @method module:app.get_camera_smooth_factor
	 * @returns {number} Smooth factor
	 */
	exports.get_camera_smooth_factor = function() {
	    return _smooth_factor;
	};

	}

	var app_factory = register("app", App);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Time API.
	 * @module time
	 */
	function Time(ns, exports) {

	var m_time = int_time_factory(ns);

	/**
	 * Set a new timeout.
	 * this method has the same behavior as window.setTimeout(), except it uses
	 * engine's timeline.
	 * @method module:time.set_timeout
	 * @param {timeout_callback} callback Timeout callback
	 * @param {number} time Timeout
	 * @returns {number} Timeout ID
	 */
	exports.set_timeout = m_time.set_timeout;

	/**
	 * Clear the timeout.
	 * @method module:time.clear_timeout
	 * @param {number} id Timeout ID
	 */
	exports.clear_timeout = m_time.clear_timeout;

	/**
	 * Get the engine's timeline (number of seconds after engine's initialization).
	 * @method module:time.get_timeline
	 * @returns {number} Timeline
	 */
	exports.get_timeline = m_time.get_timeline;

	/**
	 * Animate value.
	 * @method module:time.animate
	 * @param {number} from Value to animate from 
	 * @param {number} to Value to animate to
	 * @param {number} timeout Period of time to animate the value
	 * @param {anim_callback} anim_cb Animation callback
	 * @returns {number} Animator ID
	 */
	exports.animate = m_time.animate;

	/**
	 * Clear the animation.
	 * @method module:time.clear_animation
	 * @param {number} id Animator ID
	 */
	exports.clear_animation = m_time.clear_animation;

	}

	var time_factory = register("time", Time);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/** 
	 * {@link TSR} (translation, scale, rotation} utility routines.
	 * @module tsr
	 * @see https://www.blend4web.com/doc/en/objects.html#moving-via-tsr-vectors
	 */
	function TSR(ns, exports) {

	var m_mat4  = mat4_factory(ns);
	var m_tsr   = int_tsr_factory(ns);

	/**
	 * Create a new identity TSR vector.
	 * @method module:tsr.create
	 * @returns {TSR} New TSR vector
	 */
	exports.create = m_tsr.create;

	/**
	 * Create a new TSR vector from given values.
	 * @method module:tsr.from_values
	 * @param {number} x X translation.
	 * @param {number} y Y translation.
	 * @param {number} z Z translation.
	 * @param {number} s Scale.
	 * @param {number} qx X quaternion rotation.
	 * @param {number} qy Y quaternion rotation.
	 * @param {number} qz Z quaternion rotation.
	 * @param {number} qw W quaternion rotation.
	 * @returns {TSR} New TSR vector
	 */
	exports.from_values = m_tsr.from_values;

	/**
	 * Copy one TSR vector to another.
	 * @method module:tsr.copy
	 * @param {TSR} tsr Source TSR vector
	 * @param {TSR} tsr2 Destination TSR vector
	 */
	exports.copy = m_tsr.copy;

	/**
	 * Set TSR to identity.
	 * @method module:tsr.identity
	 * @param {TSR} tsr TSR vector
	 */
	exports.identity = m_tsr.identity;

	/**
	 * Set TSR from separate trans, scale and quat.
	 * @method module:tsr.set_sep
	 * @param {Vec3} trans Translation vector
	 * @param {number} scale Scale
	 * @param {Quat} quat Rotation quaternion
	 * @param {TSR} [dest] Destination TSR vector
	 * @returns {TSR} dest Destination TSR vector
	 */
	exports.set_sep = m_tsr.set_sep;
	exports.set_trans = m_tsr.set_trans;
	/**
	 * Set TSR scale.
	 * @method module:tsr.set_scale
	 * @param {number} scale Scale
	 * @param {TSR} dest Destination TSR vector
	 */
	exports.set_scale = m_tsr.set_scale;
	/**
	 * Set TSR translation and scale from vec4.
	 * @method module:tsr.set_transcale
	 * @param {Vec4} transcale Translation+Scale vector
	 * @param {TSR} dest Destination TSR vector
	 */
	exports.set_transcale = m_tsr.set_transcale ;
	/**
	 * Set TSR quaternion.
	 * @method module:tsr.set_quat
	 * @param {Quat} quat Rotation quaternion
	 * @param {TSR} dest Destination TSR vector
	 */
	exports.set_quat = m_tsr.set_quat;

	/**
	 * Get ArrayBufferView from translation part of TSR.
	 * @method module:tsr.get_trans_view
	 * @param {TSR} tsr TSR vector
	 * @returns {Vec3} Translation part of TSR
	 */
	exports.get_trans_view = m_tsr.get_trans_view;
	/**
	 * Get TSR scale.
	 * @method module:tsr.get_scale
	 * @returns {number} Scale
	 */
	exports.get_scale = m_tsr.get_scale;
	/**
	 * Get ArrayBufferView from quaternion part of TSR.
	 * @method module:tsr.get_quat_view
	 * @returns {Quat} Quaternion part of TSR
	 */
	exports.get_quat_view = m_tsr.get_quat_view;

	/**
	 * Calculates the inverse of TSR.
	 * @method module:tsr.invert
	 * @param {TSR} tsr TSR vector
	 * @param {TSR} dest Destination TSR vector
	 * @returns {TSR} Destination TSR vector
	 */
	exports.invert = m_tsr.invert;


	/**
	 * Create mat4 from TSR.
	 * Not optimized.
	 * @method module:tsr.to_mat4
	 * @param {TSR} tsr TSR vector.
	 * @param {?Mat4} [dest=mat4.create()] Destination matrix.
	 * @returns {Mat4} Destination matrix.
	 */
	exports.to_mat4 = function(tsr, dest) {
	    if (!dest)
	        dest = m_mat4.create();

	    m_tsr.to_mat4(tsr, dest);
	    return dest;
	};

	/**
	 * Set TSR from mat4.
	 * Not optimized.
	 * @method module:tsr.from_mat4
	 * @param {Mat4} mat Matrix.
	 * @param {TSR} dest Destination TSR vector.
	 * @returns {TSR} Destination TSR vector.
	 */
	exports.from_mat4 = m_tsr.from_mat4;

	/**
	 * Multiply two TSRs.
	 * @method module:tsr.multiply
	 * @param {TSR} tsr First TSR vector
	 * @param {TSR} tsr2 Second TSR vector
	 * @param {TSR} dest Destination TSR vector
	 * @returns {TSR} Destination TSR vector
	 */
	exports.multiply = m_tsr.multiply;

	/**
	 * Transform vec3 by TSR.
	 * @method module:tsr.transform_vec3
	 * @param {Vec3} trans Vector to transform
	 * @param {TSR} tsr TSR vector
	 * @param {Vec3} dest Destination vector
	 */
	exports.transform_vec3 = m_tsr.transform_vec3;

	/**
	 * Transform vec3 by inverse TSR.
	 * @method module:tsr.transform_vec3_inv
	 * @param {Vec3} trans Vector to transform
	 * @param {TSR} tsr TSR vector
	 * @param {Vec3} dest Destination vector
	 */
	exports.transform_vec3_inv = m_tsr.transform_vec3_inv;

	/**
	 * Transform vec3 vectors by TSR.
	 * optional destination offset in values (not vectors, not bytes)
	 * @method module:tsr.transform_vectors
	 * @param {Float32Array} vectors Array of vectors to transform
	 * @param {TSR} tsr TSR vector
	 * @param {Float32Array} new_vectors Destination array of vectors
	 * @param {number} [dest_offset=0] Offset in new_vectors array
	 * @returns {Float32Array} Destination array of vectors
	 */
	exports.transform_vectors = m_tsr.transform_vectors;
	/**
	 * Transform directional vec3 vectors by TSR.
	 * optional destination offset in values (not vectors, not bytes)
	 * @method module:tsr.transform_dir_vectors
	 * @param {Float32Array} vectors Array of vectors to transform
	 * @param {TSR} tsr TSR vector
	 * @param {Float32Array} new_vectors Destination array of vectors
	 * @param {number} [dest_offset=0] Offset in new_vectors array
	 * @returns {Float32Array} Destination array of vectors
	 */
	exports.transform_dir_vectors = m_tsr.transform_dir_vectors;
	/**
	 * Transform directional vec3 by TSR.
	 * @method module:tsr.transform_dir_vec3
	 * @param {Vec3} trans Vector to transform
	 * @param {TSR} tsr TSR vector
	 * @param {Vec3} dest Destination vector
	 */
	exports.transform_dir_vec3 = m_tsr.transform_dir_vec3;

	/**
	 * Transform 4 comp tangent vectors by matrix.
	 * optional destination offset in values (not vectors, not bytes)
	 * @method module:tsr.transform_tangents
	 * @param {Float32Array} vectors Array of vectors to transform
	 * @param {TSR} tsr TSR vector
	 * @param {Float32Array} new_vectors Destination array of vectors
	 * @param {number} [dest_offset=0] Offset in new_vectors array
	 * @returns {Float32Array} Destination array of vectors
	 */
	exports.transform_tangents = m_tsr.transform_tangents;

	/**
	 * Perform TSR translation by given vec3.
	 * @method module:tsr.translate
	 * @param {TSR} tsr TSR vector
	 * @param {Vec3} trans Translation vector
	 * @param {TSR} dest Destination TSR vector
	 * @returns {TSR} Destination TSR vector
	 */
	exports.translate = m_tsr.translate;

	/**
	 * Perform interpolation between two TSR vectors.
	 * @method module:tsr.interpolate
	 * @param {TSR} tsr First TSR vector
	 * @param {TSR} tsr2 Second TSR vector
	 * @param {number} factor Interpolation factor
	 * @param {TSR} dest Destination TSR vector
	 * @returns {TSR} Destination TSR vector
	 */
	exports.interpolate = function(tsr, tsr2, factor, dest) {
	    if (!dest)
	        dest = m_tsr.create();

	    m_tsr.interpolate(tsr, tsr2, factor, dest);

	    return dest;
	};

	}

	var tsr_factory = register("tsr", TSR);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Camera animation add-on.
	 * Implements procedural animation for the camera.
	 * @module camera_anim
	 * @local TrackToTargetZoomCallback
	 * @local TrackToTargetCallback
	 * @local AutoRotateDisabledCallback
	 * @local MoveCameraToPointCallback
	 * @local RotateCameraCallback
	 */

	function Camera_anim(ns, exports) {

	var m_cam   = camera_factory(ns);
	var m_ctl   = controls_factory(ns);
	var m_print = print_factory(ns);
	var m_scs   = scenes_factory(ns);
	var m_time  = time_factory(ns);
	var m_trans = transform_factory(ns);
	var m_tsr   = tsr_factory(ns);
	var m_util  = util_factory(ns);
	var m_vec3  = vec3_factory(ns);

	var ROTATION_OFFSET = 0.2;
	var ROTATION_LIMITS_EPS = 1E-6;
	var DEFAULT_CAM_LIN_SPEED = 1;
	var DEFAULT_CAM_ANGLE_SPEED = 0.01;
	var DEFAULT_CAM_ROTATE_TIME = 1000;

	// cache vars
	var _vec2_tmp           = new Float32Array(2);
	var _vec2_tmp2          = new Float32Array(2);
	var _vec3_tmp           = new Float32Array(3);
	var _vec3_tmp2          = new Float32Array(3);
	var _vec3_tmp3          = new Float32Array(3);
	var _tsr_tmp            = m_tsr.create();
	var _tsr_tmp2           = m_tsr.create();
	var _tsr_tmp3           = m_tsr.create();

	var _limits_tmp = {};

	var _is_camera_moving = false;
	var _is_camera_rotating = false;

	var _is_camera_stop_moving = false;
	var _is_camera_stop_rotating = false;

	/**
	 * Callback to be executed when the camera finishes its track animation.
	 * See track_to_target() method.
	 * @callback TrackToTargetCallback
	 */

	/**
	 * Callback to be executed when the camera finishes its zoom-in animation.
	 * See track_to_target() method.
	 * @callback TrackToTargetZoomCallback
	 */


	/**
	 * Smoothly rotate the EYE camera to make it pointing at the specified
	 * target (an object or some position). Then smoothly zoom on this target,
	 * pause and zoom back.
	 * @param {Object3D} cam_obj Camera object 3D
	 * @param {(Object3D|Vec3)} target Target object or target position
	 * @param {?number} [rot_speed=1] Rotation speed, radians per second
	 * @param {?number} [zoom_mult=2] Zoom level value
	 * @param {?number} [zoom_time=1] Time it takes to zoom on the target, seconds
	 * @param {?number} [zoom_delay=1] Delay before the camera zooms back, seconds
	 * @param {?TrackToTargetCallback} [track_cb] Track finishing callback
	 * @param {?TrackToTargetZoomCallback} [zoom_in_cb] Zoom-in callback
	 */
	exports.track_to_target = function(cam_obj, target, rot_speed, zoom_mult, 
	        zoom_time, zoom_delay, track_cb, zoom_in_cb) {

	    if (!m_cam.is_eye_camera(cam_obj)) {
	        m_print.error("track_to_target(): Wrong camera object or camera move style");
	        return;
	    }

	    if (m_util.is_vector(target))
	        var obj_pos = target;
	    else {
	        var obj_pos = _vec3_tmp;
	        m_trans.get_object_center(target, false, obj_pos);
	    }

	    rot_speed  = rot_speed  || 1;
	    zoom_mult  = zoom_mult  || 2;
	    zoom_time  = zoom_time  || 1;
	    zoom_delay  = zoom_delay || 1;

	    var cam_pos = m_trans.get_translation(cam_obj, _vec3_tmp2);
	    var dir_to_target = m_vec3.subtract(obj_pos, cam_pos, _vec3_tmp3);

	    var start_angles = m_cam.get_camera_angles(cam_obj, _vec2_tmp);
	    var finish_angles = m_cam.get_camera_angles_dir(dir_to_target, _vec2_tmp2);

	    var phi_angle = finish_angles[0] - start_angles[0];
	    var theta_angle = finish_angles[1] - start_angles[1];

	    // calculate arc angle on a unit sphere using the spherical law of cosines
	    var arc_angle = Math.acos(Math.cos(phi_angle) * Math.cos(theta_angle));
	    var rot_time = Math.abs(arc_angle / rot_speed);

	    var zoom_dist = m_vec3.length(dir_to_target) * (1 - 1 / zoom_mult);


	    var smooth_function = function(x) {
	        var f = 6 * x * (1 - x);
	        return f;
	    };

	    var _start_time = m_time.get_timeline();
	    var _stage = 0;
	    var track_to_target_cb = function(obj, id, pulse) {
	        // NOTE: if move_style was changed during the tracking
	        if (!m_cam.is_eye_camera(obj)) {
	            disable_cb();
	            return;
	        }

	        if (pulse == 1) {
	            var curr_time = m_ctl.get_sensor_value(obj, id, 0) - _start_time;
	            var elapsed = m_ctl.get_sensor_value(obj, id, 1);

	            if (curr_time < rot_time) {
	                var smooth_coeff = smooth_function(curr_time / rot_time);
	                var phi_delta = smooth_coeff * phi_angle * elapsed / rot_time;
	                var theta_delta = smooth_coeff * theta_angle * elapsed / rot_time;
	                m_cam.rotate_camera(cam_obj, phi_delta, theta_delta);
	            } else if (curr_time < rot_time + zoom_time) {

	                if (_stage == 0) {
	                    m_cam.rotate_camera(cam_obj, finish_angles[0], finish_angles[1], true);
	                    _stage++;
	                }

	                var smooth_coeff = smooth_function(curr_time - rot_time / zoom_time);
	                var delta_dist = smooth_coeff * zoom_dist * elapsed / zoom_time;
	                m_trans.move_local(obj, 0, 0, -delta_dist);
	            } else if (curr_time < rot_time + zoom_time + zoom_delay) {
	                if (_stage <= 1) {
	                    m_cam.rotate_camera(cam_obj, finish_angles[0], finish_angles[1], true);
	                    m_cam.eye_set_look_at(cam_obj, cam_pos);
	                    m_trans.move_local(obj, 0, 0, -zoom_dist);
	                    if (zoom_in_cb)
	                        zoom_in_cb();
	                    
	                    _stage++;
	                }
	            } else if (curr_time < rot_time + zoom_time + zoom_delay + zoom_time) {
	                if (_stage <= 2) {
	                    m_cam.rotate_camera(cam_obj, finish_angles[0], finish_angles[1], true);
	                    m_cam.eye_set_look_at(cam_obj, cam_pos);
	                    m_trans.move_local(obj, 0, 0, -zoom_dist);
	                    _stage++;
	                }
	                var smooth_coeff = smooth_function(curr_time - rot_time - zoom_time - zoom_delay / zoom_time);
	                var delta_dist = smooth_coeff * zoom_dist * elapsed / zoom_time;
	                m_trans.move_local(obj, 0, 0, delta_dist);
	            } else {
	                m_cam.rotate_camera(cam_obj, finish_angles[0], finish_angles[1], true);
	                m_cam.eye_set_look_at(cam_obj, cam_pos);
	                disable_cb();
	            }
	        }
	    };

	    var disable_cb = function() {
	        m_ctl.remove_sensor_manifold(cam_obj, "TRACK_TO_TARGET");
	        if (track_cb)
	            track_cb();
	    };

	    var timeline = m_ctl.create_timeline_sensor();
	    var elapsed = m_ctl.create_elapsed_sensor();
	    m_ctl.create_sensor_manifold(cam_obj, "TRACK_TO_TARGET", m_ctl.CT_CONTINUOUS,
	            [timeline, elapsed], null, track_to_target_cb);
	};

	function init_limited_rotation_ratio(obj, limits, auto_rotate_ratio) {
	    var phi = m_cam.get_camera_angles(obj, _vec2_tmp)[0];

	    var delts = get_delta_to_limits(obj, phi, limits.left, limits.right, _vec2_tmp2);

	    return auto_rotate_ratio * Math.min(1, delts[0] / ROTATION_OFFSET,
	            delts[1] / ROTATION_OFFSET);
	}

	function get_delta_to_limits(obj, angle, limit_left, limit_right, dest) {
	    // accurate delta calculation
	    var diff_left = m_util.angle_wrap_0_2pi(angle - limit_left);
	    var delta_to_left = Math.min(diff_left, 2 * Math.PI - diff_left);
	    var diff_right = m_util.angle_wrap_0_2pi(limit_right - angle);
	    var delta_to_right = Math.min(diff_right, 2 * Math.PI - diff_right);

	    // some precision errors could be near the limits
	    if (Math.abs(delta_to_left) < ROTATION_LIMITS_EPS 
	            || 2 * Math.PI - Math.abs(delta_to_left) < ROTATION_LIMITS_EPS)
	        delta_to_left = 0;
	    if (Math.abs(delta_to_right) < ROTATION_LIMITS_EPS 
	            || 2 * Math.PI - Math.abs(delta_to_right) < ROTATION_LIMITS_EPS)
	        delta_to_right = 0;

	    if (m_cam.is_eye_camera(obj)) {
	        dest[0] = delta_to_right; // to min angle
	        dest[1] = delta_to_left; // to max angle
	    } else {
	        dest[0] = delta_to_left; // to min angle
	        dest[1] = delta_to_right; // to max angle
	    }

	    return dest;
	}

	/**
	 * Callback to be executed when auto-rotating is disabled.
	 * It is fired when either the user manually rotates the camera,
	 * or the auto_rotate() method is executed again.
	 * @callback AutoRotateDisabledCallback
	 */

	/**
	 * Switch auto-rotation of the TARGET or HOVER camera around its pivot, or
	 * auto-rotating of the EYE camera around itself.
	 * When it is called for the first time, auto-rotation is enabled
	 * while the next call will disable auto-rotation.
	 * @param {number} auto_rotate_ratio Rotation speed multiplier
	 * @param {AutoRotateDisabledCallback} [callback] Callback to be executed when auto-rotation is disabled
	 * @param {boolean} [disable_on_mouse_wheel] Disable camera auto-rotation after mouse scrolling.
	 */
	exports.auto_rotate = function(auto_rotate_ratio, callback, disable_on_mouse_wheel) {

	    callback = callback || function(){};

	    var obj = m_scs.get_active_camera();

	    if (m_cam.is_static_camera(obj)) {
	        m_print.error("auto_rotate(): Wrong camera move style");
	        return;
	    }

	    var angle_limits = {};
	    var rot_offset = 0;
	    var cur_rotate_ratio = 0;

	    function update_limited_rotation_params(curr_limits) {
	        angle_limits = angle_limits || {};
	        angle_limits.left = curr_limits.left;
	        angle_limits.right = curr_limits.right;
	        rot_offset = Math.min(ROTATION_OFFSET,
	                (m_util.angle_wrap_0_2pi(angle_limits.right - angle_limits.left)) / 2);
	        cur_rotate_ratio = init_limited_rotation_ratio(obj,
	                angle_limits, auto_rotate_ratio);
	    }

	    function elapsed_cb(obj, id, pulse) {
	        if (pulse == 1) {
	            var move_style = m_cam.get_move_style(obj);
	            // NOTE: if move_style was changed to STATIC during the autorotation

	            if (move_style == m_cam.MS_STATIC)
	                disable_cb();
	            else if ((move_style == m_cam.MS_TARGET_CONTROLS 
	                    || move_style == m_cam.MS_EYE_CONTROLS) 
	                    && m_cam.has_horizontal_rot_limits(obj)) {

	                var curr_limits = (move_style == m_cam.MS_EYE_CONTROLS) 
	                        ? m_cam.eye_get_horizontal_limits(obj, _limits_tmp)
	                        : m_cam.target_get_horizontal_limits(obj, _limits_tmp);

	                if (angle_limits === null || curr_limits.left != angle_limits.left
	                        || curr_limits.right != angle_limits.right)
	                    update_limited_rotation_params(curr_limits);
	                limited_auto_rotate(obj, id);
	            } else {
	                angle_limits = null;
	                unlimited_auto_rotate(obj, id);
	            }
	        }
	    }

	    function limited_auto_rotate(obj, id) {
	        var value = m_ctl.get_sensor_value(obj, id, 0);

	        var phi = m_cam.get_camera_angles(obj, _vec2_tmp)[0];
	        var delts = get_delta_to_limits(obj, phi, angle_limits.left, angle_limits.right,
	                _vec2_tmp2);

	        if (delts[1] > rot_offset 
	                && delts[0] > rot_offset)
	            cur_rotate_ratio = m_util.sign(cur_rotate_ratio) * auto_rotate_ratio;

	        else if (delts[1] < rot_offset)
	            cur_rotate_ratio = cur_rotate_ratio - 
	                    Math.pow(auto_rotate_ratio, 2) / (2 * ROTATION_OFFSET) * value;

	        else if (delts[0] < rot_offset)
	            cur_rotate_ratio = cur_rotate_ratio +
	                    Math.pow(auto_rotate_ratio, 2) / (2 * ROTATION_OFFSET) * value;

	        m_cam.rotate_camera(obj, value * cur_rotate_ratio, 0);
	    }

	    function unlimited_auto_rotate(obj, id) {
	        var value = m_ctl.get_sensor_value(obj, id, 0);
	        m_cam.rotate_camera(obj, value * auto_rotate_ratio, 0);
	    }

	    function disable_cb() {
	        m_ctl.remove_sensor_manifold(obj, "AUTO_ROTATE");
	        m_ctl.remove_sensor_manifold(obj, "DISABLE_AUTO_ROTATE");

	        callback();
	    }

	    if (!m_ctl.check_sensor_manifold(obj, "AUTO_ROTATE")) {
	        var mouse_move_x = m_ctl.create_mouse_move_sensor("X");
	        var mouse_move_y = m_ctl.create_mouse_move_sensor("Y");
	        var mouse_down   = m_ctl.create_mouse_click_sensor();
	        var touch_move   = m_ctl.create_touch_move_sensor();
	        var touch_zoom   = m_ctl.create_touch_zoom_sensor();
	        var elapsed      = m_ctl.create_elapsed_sensor();

	        if (disable_on_mouse_wheel)
	            var wheel_zoom = m_ctl.create_mouse_wheel_sensor();
	        else
	            var wheel_zoom = m_ctl.create_custom_sensor(0);

	        var logic_func = function(s) {return (s[0] && s[2]) || (s[1] && s[2]) || s[3] || s[4] || s[5]};

	        m_ctl.create_sensor_manifold(obj, "DISABLE_AUTO_ROTATE", m_ctl.CT_LEVEL,
	                                    [mouse_move_x, mouse_move_y, mouse_down,
	                                    touch_move, touch_zoom, wheel_zoom], logic_func,
	                                    disable_cb);

	        m_ctl.create_sensor_manifold(obj, "AUTO_ROTATE", m_ctl.CT_CONTINUOUS,
	                                    [elapsed], function(s) {return s[0]},
	                                    elapsed_cb);
	    } else
	        disable_cb();
	};

	/**
	 * Check if the camera is auto-rotating.
	 * @method module:camera_anim.is_auto_rotate
	 * @returns {boolean} Result of the check: true - when the camera is
	 * auto-rotating, false - otherwise.
	 */
	exports.is_auto_rotate = function() {
	    var obj = m_scs.get_active_camera();

	    return m_ctl.check_sensor_manifold(obj, "AUTO_ROTATE");
	};

	/**
	 * Check if auto-rotation is possible for the camera.
	 * For example, the STATIC camera cannot be rotated.
	 * @method module:camera_anim.check_auto_rotate
	 * @returns {boolean} Result of the check: true - when auto-rotation is
	 * possible, false - otherwise.
	 */
	exports.check_auto_rotate = function() {
	    var obj = m_scs.get_active_camera();
	    var cam_type = m_cam.get_move_style(obj);

	    if (cam_type == m_cam.MS_STATIC)
	        return false;

	    return true;
	};

	/**
	 * Callback to be executed when camera is finishes its moving animation.
	 * See move_camera_to_point() method
	 * @callback MoveCameraToPointCallback
	 */

	/**
	 * Smoothly move the camera to the target point. Intended for STATIC cameras only.
	 * @param {(Object3D|tsr)} cam_obj Camera object 3D
	 * @param {(Object3D|tsr)} point_obj Target point object 3D
	 * @param {number} cam_lin_speed Camera linear speed, meters per second
	 * @param {number} cam_angle_speed Camera angular speed, radians per second
	 * @param {MoveCameraToPointCallback} [cb] Finishing callback
	 */
	exports.move_camera_to_point = function(cam_obj, point_obj, cam_lin_speed, cam_angle_speed, cb) {
	    if (m_cam.get_move_style(cam_obj) != m_cam.MS_STATIC) {
	        m_print.error("move_camera_to_point(): wrong camera type");

	        return;
	    }

	    if (_is_camera_moving)
	        return;

	    if (!cam_obj) {
	        m_print.error("move_camera_to_point(): you must specify the camera object");

	        return;
	    }

	    if (!point_obj) {
	        m_print.error("move_camera_to_point(): you must specify the point object");

	        return;
	    }

	    cam_lin_speed   = cam_lin_speed || DEFAULT_CAM_LIN_SPEED;
	    cam_angle_speed = cam_angle_speed || DEFAULT_CAM_ANGLE_SPEED;

	    if (m_util.is_vector(cam_obj))
	        var cam_tsr = cam_obj;
	    else
	        var cam_tsr = m_trans.get_tsr(cam_obj, _tsr_tmp);

	    if (m_util.is_vector(point_obj))
	        var point_tsr = point_obj;
	    else
	        var point_tsr = m_trans.get_tsr(point_obj, _tsr_tmp2);

	    var distance  = m_vec3.distance(m_tsr.get_trans_view(cam_tsr),
	                                    m_tsr.get_trans_view(point_tsr));
	    var move_time = distance / cam_lin_speed;

	    var current_cam_dir = m_util.quat_to_dir(m_tsr.get_quat_view(cam_tsr),
	                                             m_util.AXIS_MZ, _vec3_tmp);
	    var target_cam_dir  = m_util.quat_to_dir(m_tsr.get_quat_view(point_tsr),
	                                             m_util.AXIS_MZ, _vec3_tmp2);

	    var vec_dot     = Math.min(Math.abs(m_vec3.dot(current_cam_dir,
	                                                   target_cam_dir)), 1);
	    var angle       = Math.acos(vec_dot);
	    var rotate_time = angle / cam_angle_speed;

	    var time = Math.max(move_time, rotate_time) * 1000;

	    _is_camera_moving = true;

	    var cur_animator = m_time.animate(0, 1, time, function(e) {
	        var new_tsr = m_tsr.interpolate(cam_tsr, point_tsr,
	                                        m_util.smooth_step(e), _tsr_tmp3);

	        if (_is_camera_stop_moving) {
	            m_time.clear_animation(cur_animator);
	            _is_camera_stop_moving = false;
	            _is_camera_moving = false;

	            return;
	        }

	        m_trans.set_tsr(cam_obj, new_tsr);

	        if (e == 1) {
	            _is_camera_moving = false;

	            if (cb)
	                cb();
	        }
	    });
	};

	/**
	 * Callback to be executed when camera is finishes its rotate animation.
	 * See rotate_camera() method
	 * @callback RotateCameraCallback
	 */

	/**
	 * Smoothly rotate the camera. Intended for non-STATIC cameras.
	 * @param {Object3D} cam_obj Camera object 3D
	 * @param {number} angle_phi Horizontal rotation angle (in radians)
	 * @param {number} angle_theta Vertical rotation angle (in radians)
	 * @param {number} [time=1000] Rotation time in ms
	 * @param {RotateCameraCallback} [cb] Finishing callback
	 */
	exports.rotate_camera = function(cam_obj, angle_phi, angle_theta, time, cb) {
	    if (m_cam.get_move_style(cam_obj) == m_cam.MS_STATIC) {
	        m_print.error("rotate_camera(): not supported for STATIC cameras");
	        return;
	    }

	    if (_is_camera_rotating)
	        return;

	    if (!cam_obj) {
	        m_print.error("rotate_camera(): you must specify the camera object");

	        return;
	    }

	    if (!angle_phi && !angle_theta) {
	        m_print.error("rotate_camera(): you must specify the rotation angle");

	        return;
	    }

	    time = time || DEFAULT_CAM_ROTATE_TIME;

	    _is_camera_rotating = true;

	    function fin_cb() {
	        if (_is_camera_rotating) {
	            _is_camera_rotating = false;

	            if (cb)
	                cb();
	        }
	    }

	    var delta_phi   = 0;
	    var cur_animator_phi = m_time.animate(0, angle_phi, time, function(e) {
	        if (_is_camera_stop_rotating || e >= angle_phi) {
	            _is_camera_stop_rotating = false;
	            m_time.clear_animation(cur_animator_phi);
	            fin_cb();
	            return;
	        }

	        m_cam.rotate_camera(cam_obj, delta_phi - e, 0);
	        delta_phi = e;
	    });

	    var delta_theta = 0;
	    var cur_animator_theta = m_time.animate(0, angle_theta, time, function(e) {
	        if (_is_camera_stop_rotating || e >= angle_theta) {
	            _is_camera_stop_rotating = false;
	            m_time.clear_animation(cur_animator_theta);
	            fin_cb();
	            return;
	        }

	        m_cam.rotate_camera(cam_obj, 0, delta_theta - e);
	        delta_theta = e;
	    });
	};

	/**
	 * Stop camera moving.
	 * @method module:camera_anim.stop_cam_moving
	 */
	exports.stop_cam_moving = function() {
	    _is_camera_stop_moving = true;
	};

	/**
	 * Stop camera rotating.
	 * @method module:camera_anim.stop_cam_rotating
	 */
	exports.stop_cam_rotating = function() {
	    _is_camera_stop_rotating = true;
	};

	/**
	 * Check if the camera is being moved by the 
	 * {@link module:camera_anim.move_camera_to_point|move_camera_to_point} function.
	 * @method module:camera_anim.is_moving
	 * @returns {boolean} Result of the check: true - when the camera is
	 * moving, false - otherwise.
	 */
	exports.is_moving = function() {
	    return _is_camera_moving;
	};

	/**
	 * Check if the camera is being rotated by the 
	 * {@link module:camera_anim.rotate_camera|rotate_camera} function.
	 * @method module:camera_anim.is_rotating
	 * @returns {boolean} Result of the check: true - when the camera is
	 * rotating, false - otherwise.
	 */
	exports.is_rotating = function() {
	    return _is_camera_rotating;
	};

	}

	var camera_anim_factory = register("camera_anim", Camera_anim);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Head Mounted Devices add-on.
	 * Provides support for HMD/VR devices using {@link https://w3c.github.io/webvr/|WebVR API}.
	 * <p>For more info about stereo rendering check out the {@link https://www.blend4web.com/doc/en/stereo_rendering.html|user manual}.
	 * @module hmd
	 */

	function HMD(ns, exports) {

	var m_cam    = camera_factory(ns);
	var m_ctl    = controls_factory(ns);
	var m_input  = input_factory(ns);
	var m_quat   = quat_factory(ns);
	var m_scenes = scenes_factory(ns);
	var m_screen = screen_factory(ns);
	var m_trans  = transform_factory(ns);
	var m_util   = util_factory(ns);
	var m_vec3   = vec3_factory(ns);

	var _last_cam_quat = m_quat.create();
	var _yaw_cam_angle = 0;
	var _was_target_camera = false;
	var _was_hover_camera = false;
	var _was_static_camera = false;

	var _vec3_tmp  = m_vec3.create();
	var _vec3_tmp2 = m_vec3.create();
	var _vec3_tmp3 = m_vec3.create();
	var _quat_tmp  = m_quat.create();
	var _quat_tmp2 = m_quat.create();
	var _quat_tmp3 = m_quat.create();
	var _quat_tmp4 = m_quat.create();

	var _offset_quat = m_quat.create();
	var _offset_pos = m_vec3.create();
	var _empty_params = {pivot: m_vec3.create()};

	/**
	 * HMD behavior enum.
	 * @see {@link module:hmd.HMD_NONE_MOUSE_ALL_AXES},
	 * {@link module:hmd.HMD_ALL_AXES_MOUSE_NONE},
	 * {@link module:hmd.HMD_ROLL_PITCH_MOUSE_YAW},
	 * {@link module:hmd.HMD_ALL_AXES_MOUSE_YAW}
	 * @typedef {number} HMDBehavior
	 */

	/**
	 * HMD behavior: HMD does not affect camera orientation,
	 * mouse controls camera rotation.
	 * @const {HMDBehavior} module:hmd.HMD_NONE_MOUSE_ALL_AXES
	 */
	var HMD_NONE_MOUSE_ALL_AXES = 0;
	exports.HMD_NONE_MOUSE_ALL_AXES = HMD_NONE_MOUSE_ALL_AXES;

	/**
	 * HMD behavior: HMD controls camera rotation,
	 * mouse does not affect camera orientation.
	 * @const {HMDBehavior} module:hmd.HMD_ALL_AXES_MOUSE_NONE
	 */
	var HMD_ALL_AXES_MOUSE_NONE = 1;
	exports.HMD_ALL_AXES_MOUSE_NONE = HMD_ALL_AXES_MOUSE_NONE;

	/**
	 * HMD behavior: HMD controls roll and pitch rotation,
	 * mouse controls yaw rotation.
	 * @const {HMDBehavior} module:hmd.HMD_ROLL_PITCH_MOUSE_YAW
	 */
	var HMD_ROLL_PITCH_MOUSE_YAW = 2;
	exports.HMD_ROLL_PITCH_MOUSE_YAW = HMD_ROLL_PITCH_MOUSE_YAW;

	/**
	 * HMD behavior: HMD affects camera rotation,
	 * mouse affect yaw rotation.
	 * @const {HMDBehavior} module:hmd.HMD_ALL_AXES_MOUSE_YAW
	 */
	var HMD_ALL_AXES_MOUSE_YAW = 3;
	exports.HMD_ALL_AXES_MOUSE_YAW = HMD_ALL_AXES_MOUSE_YAW;

	/**
	 * Enable HMD.
	 * @method module:hmd.enable_hmd
	 * @param {HMDBehavior} control_type Camera rotation type.
	 */
	exports.enable_hmd = function(control_type) {
	    var sensor = null;
	    var device = m_input.get_device_by_type_element(m_input.DEVICE_HMD);
	    if (device) {
	        if (m_input.get_value_param(device, m_input.HMD_WEBVR_TYPE) &
	                (m_input.HMD_WEBVR_MOBILE | m_input.HMD_WEBVR_DESKTOP | m_input.HMD_WEBVR1))
	            // use state of the WebVR device
	            sensor = m_ctl.create_hmd_quat_sensor();
	        else
	            // use gyroscope state
	            sensor = m_ctl.create_gyro_quat_sensor();
	        process_hmd(control_type, sensor);
	    }
	};

	/**
	 * Check if the browser supports WebVR API or it is a mobile version of the browser.
	 * @method module:hmd.check_browser_support
	 * @return {boolean} Checking result.
	 */
	exports.check_browser_support = function() {
	    return Boolean(m_input.can_use_device(m_input.DEVICE_HMD));
	};

	/**
	 * Enable VR controllers.
	 * @method module:hmd.enable_controllers
	 * @param {Object3D} [gamepad_1] Object presenting controller.
	 * @param {Object3D} [gamepad_2] Object presenting controller.
	 * @example
	 * var m_hmd = require("hmd");
	 * var m_scenes = require("scenes");
	 *
	 * var gamepad_1 = m_scenes.get_object_by_name("my_gamepad_1");
	 * var gamepad_2 = m_scenes.get_object_by_name("my_gamepad_2");
	 * m_hmd.enable_controllers(gamepad_1, gamepad_2);
	 */
	exports.enable_controllers = function(gamepad_1, gamepad_2) {
	    // TODO: add default models for gamepad_1, gamepad_2
	    disable_controllers();

	    if (!gamepad_1 && !gamepad_2)
	        return;

	    var gamepad_id = m_input.get_vr_controller_id(0);
	    var gm_pos_sensor = m_ctl.create_gamepad_position_sensor(gamepad_id);
	    var gm_ori_sensor = m_ctl.create_gamepad_orientation_sensor(gamepad_id);

	    var gamepad_id2 = m_input.get_vr_controller_id(1);
	    var gm_pos_sensor2 = m_ctl.create_gamepad_position_sensor(gamepad_id2);
	    var gm_ori_sensor2 = m_ctl.create_gamepad_orientation_sensor(gamepad_id2);

	    function position_cb(obj, id, pulse) {
	        if (gamepad_1) {
	            var gmpos1 = m_ctl.get_sensor_payload(obj, id, 0);
	            var gmori1 = m_ctl.get_sensor_payload(obj, id, 2);

	            m_vec3.add(_offset_pos, gmpos1, gmpos1);
	            m_trans.set_translation_v(gamepad_1, gmpos1);
	            m_trans.set_rotation_v(gamepad_1, gmori1);
	        }

	        if (gamepad_2) {
	            var gmpos2 = m_ctl.get_sensor_payload(obj, id, 1);
	            var gmori2 = m_ctl.get_sensor_payload(obj, id, 3);

	            m_vec3.add(_offset_pos, gmpos2, gmpos2);
	            m_trans.set_translation_v(gamepad_2, gmpos2);
	            m_trans.set_rotation_v(gamepad_2, gmori2);
	        }
	    }
	    m_ctl.create_sensor_manifold(null, "VR_CONTROLLERS", m_ctl.CT_CONTINUOUS,
	            [gm_pos_sensor, gm_pos_sensor2, gm_ori_sensor, gm_ori_sensor2],
	            null, position_cb);
	};

	/**
	 * Disable VR controllers.
	 * @method module:hmd.disable_controllers
	 * @example
	 * var m_hmd = require("hmd");
	 *
	 * m_hmd.disable_controllers();
	 */
	exports.disable_controllers = disable_controllers;
	function disable_controllers() {
	    m_ctl.remove_sensor_manifold(null, "VR_CONTROLLERS");
	}

	function process_hmd(control_type, sensor) {
	    if (!sensor)
	        return;

	    var cam_obj = m_scenes.get_active_camera();
	    if (!cam_obj)
	        return;

	    m_screen.request_split_screen(function() {
	        if (!m_cam.is_eye_camera(cam_obj)) {
	            _was_target_camera = m_cam.is_target_camera(cam_obj);
	            _was_hover_camera = m_cam.is_hover_camera(cam_obj);
	            _was_static_camera = m_cam.is_static_camera(cam_obj);

	            m_cam.eye_setup(cam_obj);
	        }

	        var elapsed = m_ctl.create_elapsed_sensor();
	        var pos_sensor = m_ctl.create_hmd_position_sensor();

	        _last_cam_quat = m_trans.get_rotation(cam_obj, _last_cam_quat);
	        m_ctl.create_sensor_manifold(null, "HMD_ROTATE_CAMERA", m_ctl.CT_CONTINUOUS,
	                [elapsed, sensor, pos_sensor], null, move_cam_cb);
	    });

	    function move_cam_cb(obj, id, pulse) {
	        if (pulse > 0) {
	            var cam_obj = m_scenes.get_active_camera();
	            if (!cam_obj)
	                return;

	            // NOTE: It is executed every frame.
	            // uses _vec3_tmp, _vec3_tmp2, _vec3_tmp3, _quat_tmp, _quat_tmp2
	            if (m_cam.is_eye_camera(cam_obj)) {
	                var hmd_quat = m_ctl.get_sensor_payload(obj, id, 1);
	                var hmd_pos = m_ctl.get_sensor_payload(obj, id, 2);

	                var position = m_vec3.add(hmd_pos, _offset_pos, _vec3_tmp);
	                m_trans.set_translation_v(cam_obj, position);

	                if (hmd_quat) {
	                    if (control_type == HMD_ALL_AXES_MOUSE_NONE) {
	                        hmd_quat = m_quat.multiply(_offset_quat, hmd_quat, _quat_tmp4);
	                        var up_axis = m_vec3.transformQuat(m_util.AXIS_MY, hmd_quat, _vec3_tmp);
	                        m_cam.set_vertical_axis(cam_obj, up_axis);
	                        m_trans.set_rotation_v(cam_obj, hmd_quat);
	                    } else if (control_type == HMD_ROLL_PITCH_MOUSE_YAW ||
	                            control_type == HMD_ALL_AXES_MOUSE_YAW) {
	                        var cam_quat = m_trans.get_rotation(cam_obj,
	                                _quat_tmp2);
	                        var inv_cam_quat = m_quat.invert(cam_quat,
	                                _quat_tmp2);
	                        var diff_cam_quat = m_quat.multiply(_last_cam_quat,
	                                inv_cam_quat, _quat_tmp2);

	                        var cur_vertical_axis = m_cam.get_vertical_axis(cam_obj,
	                                _vec3_tmp);
	                        if (Math.abs(cur_vertical_axis[2]) < Math.PI / 4)
	                            var first_horiz_vec = m_vec3.cross(cur_vertical_axis,
	                                    m_util.AXIS_MY, _vec3_tmp2);
	                        else if (Math.abs(cur_vertical_axis[1]) < Math.PI / 4)
	                            var first_horiz_vec = m_vec3.cross(cur_vertical_axis,
	                                    m_util.AXIS_Z, _vec3_tmp2);

	                        m_vec3.normalize(first_horiz_vec, first_horiz_vec);

	                        var rotated_first_horiz_vec = m_vec3.transformQuat(
	                                first_horiz_vec, diff_cam_quat, _vec3_tmp3);

	                        var vertical_coef = m_vec3.dot(cur_vertical_axis,
	                                rotated_first_horiz_vec);
	                        var second_horiz_vec = m_vec3.scaleAndAdd(rotated_first_horiz_vec,
	                                cur_vertical_axis, -vertical_coef, _vec3_tmp3);
	                        m_vec3.normalize(second_horiz_vec, second_horiz_vec);

	                        var sign_horiz_vec = m_vec3.cross(cur_vertical_axis,
	                                first_horiz_vec, _vec3_tmp);
	                        var abs_yaw_angle = Math.acos(m_util.clamp(
	                                m_vec3.dot(first_horiz_vec, second_horiz_vec),
	                                0, 1));
	                        var sign_yaw_angle = m_util.sign(m_vec3.dot(
	                                second_horiz_vec, sign_horiz_vec));
	                        var diff_yaw_cam_angle = abs_yaw_angle * sign_yaw_angle;

	                        _yaw_cam_angle += diff_yaw_cam_angle;
	                        var yaw_cam_quat = m_quat.setAxisAngle(m_util.AXIS_Z,
	                                -_yaw_cam_angle, _quat_tmp2);

	                        if (control_type == HMD_ALL_AXES_MOUSE_YAW) {
	                            var new_cam_quat = m_quat.multiply(yaw_cam_quat,
	                                    hmd_quat, _quat_tmp);
	                        } else {
	                            var yaw_hmd_quat = m_util.quat_project(hmd_quat, m_util.AXIS_MZ,
	                                    m_util.AXIS_Z, m_util.AXIS_Y, _quat_tmp3);
	                            var yaw_hmd_inv_quat = m_quat.invert(yaw_hmd_quat, _quat_tmp3);
	                            var vertical_hmd_quat = m_quat.multiply(
	                                    yaw_hmd_inv_quat, hmd_quat, _quat_tmp3);

	                            var new_cam_quat = m_quat.multiply(yaw_cam_quat,
	                                    vertical_hmd_quat, _quat_tmp);
	                        }
	                        var up_axis = m_vec3.transformQuat(m_util.AXIS_MY,
	                                new_cam_quat, _vec3_tmp);
	                        m_cam.set_vertical_axis(cam_obj, up_axis);

	                        m_trans.set_rotation_v(cam_obj, new_cam_quat);
	                        m_quat.copy(new_cam_quat, _last_cam_quat);
	                    }
	                }
	            }
	        }
	    }
	}

	/**
	 * Disable HMD.
	 * @method module:hmd.disable_hmd
	 */
	exports.disable_hmd = function() {
	    if (!m_ctl.check_sensor_manifold(null, "HMD_ROTATE_CAMERA"))
	        return;

	    m_ctl.remove_sensor_manifold(null, "HMD_ROTATE_CAMERA");

	    m_screen.exit_split_screen();

	    var cam_obj = m_scenes.get_active_camera();
	    // TODO: add restoring camera's params
	    if (_was_target_camera)
	        m_cam.target_setup(cam_obj, _empty_params);
	    else if (_was_hover_camera)
	        m_cam.hover_setup(cam_obj, _empty_params);
	    else if (_was_static_camera)
	        m_cam.static_setup(cam_obj, _empty_params);

	    // correct up camera (non-vr mode)
	    m_cam.set_vertical_axis(cam_obj, m_util.AXIS_Z);
	    // TODO: update_transform
	    var cam_quat = m_trans.get_rotation(cam_obj, _quat_tmp);
	    m_trans.set_rotation_v(cam_obj, cam_quat);
	};
	/**
	 * Set hmd initial rotation quat.
	 * @method module:hmd.set_rotate_quat
	 * @param {Quat} quat Initial rotation quaternion.
	 * @example
	 * var m_hmd = require("hmd");
	 *
	 * m_hmd.set_rotate_quat([0,0,0,1]);
	 */
	exports.set_rotate_quat = function(quat) {
	    m_quat.copy(quat, _offset_quat);
	};
	/**
	 * Get hmd initial rotation quat.
	 * @method module:hmd.get_rotate_quat
	 * @param {Quat} dest Initial rotation quaternion.
	 * @return {Quat} dest.
	 * @example
	 * var m_hmd = require("hmd");
	 * var m_quat = require("quat");
	 * var _quat_tmp = m_quat.create();
	 *
	 * var quat = m_hmd.get_rotate_quat(_quat_tmp);
	 */
	exports.get_rotate_quat = function(dest) {
	    m_quat.copy(_offset_quat, dest);
	    return dest;
	};
	/**
	 * Set hmd initial position.
	 * @method module:hmd.set_position
	 * @param {Vec3} position Initial position.
	 * @example
	 * var m_hmd = require("hmd");
	 *
	 * m_hmd.set_position([0,0,0]);
	 */
	exports.set_position = function(position) {
	    m_quat.copy(position, _offset_pos);
	};
	/**
	 * Get hmd initial position.
	 * @method module:hmd.get_position
	 * @param {Vec3} dest Initial position.
	 * @return {Vec3} dest.
	 * @example
	 * var m_hmd = require("hmd");
	 * var m_vec3 = require("vec3");
	 * var _vec3_tmp = m_vec3.create();
	 *
	 * var pos = m_hmd.get_position(_vec3_tmp);
	 */
	exports.get_position = function(dest) {
	    m_quat.copy(_offset_pos, dest);
	    return dest;
	};

	}

	var hmd_factory = register("hmd", HMD);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Add-on for first person applications.
	 * It makes creating FPS applications, binding controls and
	 * controlling character movement easier.
	 * @module fps
	 * @local ChangeStateCallback
	 * @local PlockCallback
	 * @local CharMotionCallback
	 */

	function FPS(ns, exports) {

	/**
	 * Function which is called when the given ID state is changed.
	 * @callback ChangeStateCallback
	 * @param {number} old_state_id Previous state ID.
	 * @param {number} new_state_id New state ID.
	 */

	/**
	 * Function which is called when pointerlock state was changed.
	 * @callback PlockCallback
	 * @param {HTMLElement} elem HTML element, which required pointerlock
	 */

	/**
	 * Function which is called when character changes his movement direction.
	 * @callback CharMotionCallback
	 * @param {number} forw_back Forward/backward direction (can be -1, 1 or 0).
	 * @param {number} right_left Right/left direction (can be -1, 1 or 0).
	 */

	/**
	 * Callback for characters/camera rotation
	 * @callback CharRotationCallback
	 * @param {Object3D} character Character
	 * @param {number} x rotation around X-axis in radians
	 * @param {number} y rotation around Y-axis in radians
	 */

	var m_cam    = camera_factory(ns);
	var m_ctl    = controls_factory(ns);
	var m_phy    = physics_factory(ns);
	var m_scs    = scenes_factory(ns);
	var m_util   = util_factory(ns);
	var m_main   = main_factory(ns);
	var m_cont   = container_factory(ns);
	var m_input  = input_factory(ns);
	var m_screen = screen_factory(ns);
	var m_trans  = transform_factory(ns);
	var m_const  = constraints_factory(ns);
	var m_vec3   = vec3_factory(ns);
	var m_hmd    = hmd_factory(ns);
	var m_print  = print_factory(ns);

	var AT_PRESSED = 1;
	var AT_RELEASED = 2;
	var AT_CONTINUOUS = 3;

	var CS_STAY = 0;
	var CS_WALK = 1;
	var CS_RUN = 2;
	var CS_FLY = 3;
	var CS_CLIMB = 4;

	var MOBILE_FORWARD_BTN_ID = "B4W_DEFAULT_BTN_1";
	var MOBILE_BACKWARD_BTN_ID = "B4W_DEFAULT_BTN_2";

	var FORWARD_SVG = 'url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+PHN2ZyBpZD0ic3ZnMzQwMCIgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMTQuMTExbW0iIHdpZHRoPSIxNC4xMTFtbSIgdmVyc2lvbj0iMS4xIiB4bWxuczpjYz0iaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iIHZpZXdCb3g9IjAgMCA0OS45OTk5OTggNDkuOTk5OTk5Ij4gPG1ldGFkYXRhIGlkPSJtZXRhZGF0YTM0MDUiPjxyZGY6UkRGPjxjYzpXb3JrIHJkZjphYm91dD0iIj48ZGM6Zm9ybWF0PmltYWdlL3N2Zyt4bWw8L2RjOmZvcm1hdD48ZGM6dHlwZSByZGY6cmVzb3VyY2U9Imh0dHA6Ly9wdXJsLm9yZy9kYy9kY21pdHlwZS9TdGlsbEltYWdlIi8+PGRjOnRpdGxlLz48L2NjOldvcms+PC9yZGY6UkRGPiA8L21ldGFkYXRhPiA8ZyBpZD0ibGF5ZXIxIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwIC0xMDAyLjQpIj48cmVjdCBpZD0icmVjdDI0MTI2IiBvcGFjaXR5PSIwLjU0MyIgZmlsbC1vcGFjaXR5PSIuODM2MTEiIGhlaWdodD0iNTAiIHdpZHRoPSI1MCIgeT0iMTAwMi40IiB4PSIwIiBmaWxsPSIjZmZmIi8+PHBhdGggaWQ9InBhdGgyNDEyOCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgZD0ibTM5LjE0MiAxMDMzLjUtMTQuMTQyLTE0LjE0Mi0xNC4xNDIgMTQuMTQyIiBzdHJva2U9IiM2ZTZlNmUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLXdpZHRoPSIyIiBmaWxsPSJub25lIi8+IDwvZz48L3N2Zz4=);';

	var DRAG_TOUCH_DELTA_MULT = 4;
	var DRAG_MOUSE_DELTA_MULT = 2;
	var CAM_SMOOTH_CHARACTER_COEFF = 0.2;
	var AXIS_THRESHOLD = 0.05;
	var ROT_STEP = 2.5;
	var MIN_VERT_ANG = (-Math.PI + 0.1) / 2;
	var MAX_VERT_ANG = (Math.PI - 0.1) / 2;
	var MULT_SCALE = 200000;
	var GMPD_BTNS_OFFSET = 300;
	var GMPD_AXIS_OFFSET = 326;

	var _move_delta = new Float32Array(2);
	var _smooth_factor = 1;
	var _fps_camera_mult = 0.0004;
	var _manifold_counter = 0;
	var _character_sm = null;
	var _plock_sensor = null;
	var _plock_cb = {
	    enable_cb  : null,
	    disable_cb : null
	};
	var _rotation_cb = function() {};
	var _curr_gamepad_id = 0;
	var _state_counter = 4;
	var _is_freezed = false;

	var _vec2_tmp = new Float32Array(2);
	var _vec3_tmp = new Float32Array(3);
	var _vec3_tmp2 = new Float32Array(3);

	function default_rotation_cb(character, rot_x, rot_y) {
	    var camera = m_scs.get_active_camera();
	    m_cam.rotate_camera(camera, rot_x, rot_y);
	    var angles = m_cam.get_camera_angles_char(camera, _vec2_tmp);
	    m_phy.set_character_rotation_h(character, angles[0]);
	    m_phy.set_character_vert_move_dir_angle(character, angles[1]);
	}

	function smooth_cb(obj, id, pulse, rot_callback) {
	    if (Math.abs(_move_delta[0]) > 0.01 || Math.abs(_move_delta[1]) > 0.01) {
	        var elapsed = m_ctl.get_sensor_value(obj, id, 0);
	        var rot_x = m_util.smooth(_move_delta[0], 0, elapsed, smooth_coeff());
	        var rot_y = m_util.smooth(_move_delta[1], 0, elapsed, smooth_coeff());

	        _move_delta[0] -= rot_x;
	        _move_delta[1] -= rot_y;

	        rot_callback(obj, -rot_x * _fps_camera_mult, -rot_y * _fps_camera_mult);
	    }
	}

	function set_smooth_factor(value) {
	    _smooth_factor = value;
	}

	function smooth_coeff() {
	    return CAM_SMOOTH_CHARACTER_COEFF * _smooth_factor;
	}

	function create_mobile_controls(character, parent_elem) {
	    var forward_btn = document.createElement("div");

	    forward_btn.style.cssText =
	        "position: absolute;" +
	        "left: 10px;" +
	        "bottom: 70px;" +
	        "width: 53px;" +
	        "height: 53px;" +
	        "background-image: " + FORWARD_SVG;
	    forward_btn.setAttribute("id", MOBILE_FORWARD_BTN_ID);


	    var backwards_btn = document.createElement("div");
	    backwards_btn.style.cssText =
	        "position: absolute;" +
	        "left: 10px;" +
	        "bottom: 10px;" +
	        "width: 53px;" +
	        "height: 53px;" +
	        "background-image: " + FORWARD_SVG +
	        "transform: rotate(180deg);" +
	        "transform-origin: center;";
	    backwards_btn.setAttribute("id", MOBILE_BACKWARD_BTN_ID);

	    parent_elem.appendChild(forward_btn);
	    parent_elem.appendChild(backwards_btn);
	}

	function check_pointerlock(elem) {
	    var request_plock = elem.requestPointerLock ||
	            elem.webkitRequestPointerLock || elem.mozRequestPointerLock;
	    return typeof request_plock === "function";
	}

	function rotate_cam_by_axis(obj, camobj, id, elapsed) {
	    var h_axis = m_ctl.get_sensor_value(obj, id, 1);
	    var v_axis = m_ctl.get_sensor_value(obj, id, 2);
	    var rot_step_value = elapsed * ROT_STEP;
	    var vert_axis_val = Math.abs(v_axis) < AXIS_THRESHOLD ? 0 : v_axis;
	    var vert_ang = - vert_axis_val * rot_step_value;
	    var hor_axis_val = Math.abs(h_axis) < AXIS_THRESHOLD ? 0 : h_axis;
	    var hor_ang = - hor_axis_val * rot_step_value;
	    vert_ang = m_util.clamp(vert_ang, MIN_VERT_ANG, MAX_VERT_ANG);
	    m_cam.rotate_camera(camobj, hor_ang, vert_ang);
	    var cam_angls = m_cam.get_camera_angles(camobj, _vec2_tmp);
	    m_phy.set_character_rotation_h(obj, cam_angls[0] + Math.PI);
	}

	function disable_rotation(elem, character) {
	    if (m_ctl.check_sensor_manifolds(character, "FPS_PLOCK"))
	        m_ctl.remove_sensor_manifold(character, "FPS_PLOCK");

	    if (m_ctl.check_sensor_manifolds(null, "FPS_ACTIVATE_PLOCK"))
	        m_ctl.remove_sensor_manifold(null, "FPS_ACTIVATE_PLOCK");

	    if (m_ctl.check_sensor_manifolds(character, "FPS_CAM_ROT"))
	        m_ctl.remove_sensor_manifold(character, "FPS_CAM_ROT");

	    if (m_ctl.check_sensor_manifolds(null, "FPS_DRAG_PRESS"))
	        m_ctl.remove_sensor_manifold(null, "FPS_DRAG_PRESS");

	    if (m_ctl.check_sensor_manifolds(null, "FPS_DRAG_MOVE"))
	        m_ctl.remove_sensor_manifold(null, "FPS_DRAG_MOVE");

	    if (m_ctl.check_sensor_manifolds(character, "FPS_SMOOTH_DRAG"))
	        m_ctl.remove_sensor_manifold(character, "FPS_SMOOTH_DRAG");
	}

	function enable_rotation(elem, character) {
	    if (check_pointerlock(elem) && !m_main.detect_mobile()) {
	        var plock_mouse_sen = m_ctl.create_plock_mouse_sensor(elem);
	        var plock_sen = _plock_sensor ? _plock_sensor : m_ctl.create_plock_sensor(elem);
	        _plock_sensor = plock_sen;

	        var fps_plock_logic_func = function(s) {
	            return s[0] && s[1];
	        };

	        var fps_plock_sensors_cb = function(obj, id, pulse) {
	            if (pulse > 0) {
	                var payload = m_ctl.get_sensor_payload(obj, id, 0);
	                _rotation_cb(obj, -payload.coords[0] * _fps_camera_mult,
	                        -payload.coords[1] * _fps_camera_mult);
	            }
	        };
	        m_ctl.create_sensor_manifold(character, "FPS_PLOCK", 
	                m_ctl.CT_CONTINUOUS, [plock_mouse_sen, plock_sen],
	                fps_plock_logic_func, fps_plock_sensors_cb);

	        var fps_act_logic_func = function(s) {
	            return s[0];
	        };

	        var fps_act_sensor_cb = function(obj, id, pulse) {
	            if (pulse > 0) {
	                if (_plock_cb.enable_cb)
	                    _plock_cb.enable_cb(elem);
	            } else
	                if (_plock_cb.disable_cb)
	                    _plock_cb.disable_cb(elem);
	        };
	        m_ctl.create_sensor_manifold(null, "FPS_ACTIVATE_PLOCK", 
	                m_ctl.CT_TRIGGER, [plock_sen],
	                fps_act_logic_func, fps_act_sensor_cb);
	    } else {

	        if (m_main.detect_mobile()) {
	            var move_sen = m_ctl.create_touch_move_sensor("XY", elem);
	            var click_sen = m_ctl.create_touch_click_sensor(elem);
	            var drag_mult = DRAG_TOUCH_DELTA_MULT;
	        } else {
	            var move_sen = m_ctl.create_mouse_move_sensor("XY", elem);
	            var click_sen = m_ctl.create_mouse_click_sensor(elem);
	            var drag_mult = DRAG_MOUSE_DELTA_MULT;

	            var camera = m_scs.get_active_camera();
	            var cam_rot_sensor_cb = function(obj, id, pulse) {
	                if (pulse > 0) {
	                    var elapsed = m_ctl.get_sensor_value(obj, id, 0);
	                    rotate_cam_by_axis(obj, camera, id, elapsed);
	                }
	            };
	            var logic_func = function(s) {
	                return Math.abs(s[1]) > AXIS_THRESHOLD || Math.abs(s[2]) > AXIS_THRESHOLD;
	            };
	            var e_s = m_ctl.create_elapsed_sensor();
	            var h_axis = m_ctl.create_gamepad_axis_sensor(m_input.GMPD_AXIS_2);
	            var v_axis = m_ctl.create_gamepad_axis_sensor(m_input.GMPD_AXIS_3);
	            m_ctl.create_sensor_manifold(character, "FPS_CAM_ROT", m_ctl.CT_CONTINUOUS,
	                    [e_s, h_axis, v_axis], logic_func, cam_rot_sensor_cb);
	        }

	        var move_x = 0;
	        var move_y = 0;

	        var press_logic_func = function(s) {
	            return s[0];
	        };
	        var press_sensor_cb = function(obj, id, pulse) {
	            if (pulse == 1) {
	                var payload = m_ctl.get_sensor_payload(obj, id, 0);
	                var coords = payload.coords;
	                move_x = coords[0];
	                move_y = coords[1];
	            }
	        };
	        m_ctl.create_sensor_manifold(null, "FPS_DRAG_PRESS", 
	                m_ctl.CT_SHOT, [click_sen],
	                press_logic_func, press_sensor_cb);

	        var move_logic_func = function(s) {
	            return s[0] && s[1];
	        };
	        var move_sensor_cb = function(obj, id, pulse) {
	            if (pulse == 1) {
	                var payload = m_ctl.get_sensor_payload(obj, id, 0);
	                var coords = payload.coords;
	                _move_delta[0] += (coords[0] - move_x) * drag_mult;
	                _move_delta[1] += (coords[1] - move_y) * drag_mult;

	                move_x = coords[0];
	                move_y = coords[1];
	            }
	        };
	        m_ctl.create_sensor_manifold(null, "FPS_DRAG_MOVE", 
	                m_ctl.CT_CONTINUOUS, [move_sen, click_sen],
	                move_logic_func, move_sensor_cb);

	        var elapsed = m_ctl.create_elapsed_sensor();

	        m_ctl.create_sensor_manifold(character, "FPS_SMOOTH_DRAG", m_ctl.CT_CONTINUOUS,
	            [elapsed], null, smooth_cb, _rotation_cb);
	    }
	}

	function set_characters_camera(character, lock_camera) {
	    var cam_obj = m_scs.get_active_camera();
	    if (lock_camera) {
	        var cam_trans = m_trans.get_translation(cam_obj, _vec3_tmp);
	        var char_trans = m_trans.get_translation(character, _vec3_tmp2);
	        m_vec3.subtract(cam_trans, char_trans, cam_trans);
	        m_const.append_stiff_trans(cam_obj, character, cam_trans);
	    }
	    var angles = m_cam.get_camera_angles_char(cam_obj, _vec2_tmp);
	    m_phy.set_character_rotation_h(character, angles[0]);
	    m_phy.set_character_vert_move_dir_angle(character, angles[1]);
	}

	var _enable_vr_cb = null;
	var _disable_vr_cb = null;

	// TODO: remove next function
	exports.append_switch_vr_cbs = function(enable_cb, disable_cb) {
	    _enable_vr_cb = enable_cb;
	    _disable_vr_cb = _disable_vr_cb;
	};

	function register_hmd(elem, character) {
	    m_input.add_click_listener(elem, function() {
	        m_screen.request_fullscreen_hmd(elem,
	            function() {
	                disable_rotation(elem, character);

	                // camera rotation is enabled with HMD
	                m_hmd.enable_hmd(m_hmd.HMD_ALL_AXES_MOUSE_NONE);

	                create_character_vr_rotate_sensor(character);
	                if (_enable_vr_cb)
	                    _enable_vr_cb();
	            },
	            function() {
	                remove_character_vr_rotate_sensor(character);
	                m_hmd.disable_hmd();

	                enable_rotation(elem, character);
	                if (_disable_vr_cb)
	                    _disable_vr_cb();
	            }
	        );
	    });
	}

	function create_character_vr_rotate_sensor(character) {

	    var e_s = m_ctl.create_elapsed_sensor();
	    var camobj = m_scs.get_active_camera();

	    var sensor_cb = function(obj, id, pulse) {
	        var hor_angle = m_cam.get_camera_angles_char(camobj, _vec2_tmp)[0];
	        m_phy.set_character_rotation_h(obj, hor_angle /*+ Math.PI*/);
	    };
	    m_ctl.create_sensor_manifold(character, "FPS_CHARECTER_VR_ROT", m_ctl.CT_CONTINUOUS,
	                [e_s], null, sensor_cb);
	}

	function remove_character_vr_rotate_sensor(character) {
	    m_ctl.remove_sensor_manifold(character, "FPS_CHARECTER_VR_ROT");
	}

	function check_vr_support() {
	    var support = m_hmd.check_browser_support() && !m_main.detect_mobile();
	    var device = m_input.get_device_by_type_element(m_input.DEVICE_HMD);
	    if (device)
	        support = support && m_input.get_value_param(device, m_input.HMD_WEBVR_TYPE) &
	                        m_input.HMD_WEBVR1;
	    return support;
	}

	function enable_camera_rotation(elem, character) {
	    if (check_vr_support()) {
	        register_hmd(elem, character);
	    }

	    enable_rotation(elem, character);
	}

	function enable_movements(elem, character, motion_cb, settings) {
	    if (m_main.detect_mobile()) {
	        var parent_elem = elem.parentElement ? elem.parentElement : elem;
	        create_mobile_controls(character, parent_elem);
	    }
	    var sm = init_character_states(character);
	    var move_state = {
	        left: 0,
	        right: 0,
	        forw: 0,
	        back: 0
	    };
	    var movestyle = -1;

	    var move_dir_cd = settings.move_dir_cd;

	    var check_character_look = function() {
	        if (_is_freezed) {
	            move_state.left = 0;
	            move_state.right = 0;
	            move_state.forw = 0;
	            move_state.back = 0;
	            return false;
	        }
	        return true;
	    };

	    var set_char_state = function(for_back, right_left) {
	        var curr_state = get_state_machine_state(sm).id;
	        if (!for_back && !right_left && curr_state != CS_CLIMB)
	            state_machine_switch_state(sm, CS_STAY);
	        else if (curr_state == CS_STAY) {
	            if (movestyle > 0)
	                state_machine_switch_state(sm, CS_RUN);
	            else
	                state_machine_switch_state(sm, CS_WALK);
	        }
	    };

	    var move_forward_cb = function(value) {
	        if (!check_character_look())
	            return;
	        var for_back_pr = move_state.forw + move_state.back;
	        move_state.forw = value;
	        var for_back = move_state.forw + move_state.back;
	        var right_left = move_state.left + move_state.right;
	        m_phy.set_character_move_dir(character, for_back, right_left);
	        if (motion_cb)
	            motion_cb(for_back, right_left);
	        set_char_state(for_back, right_left);
	        if (move_dir_cd && for_back_pr != for_back)
	            move_dir_cd(for_back, right_left, 0);
	    };
	    var move_backward_cb = function(value) {
	        if (!check_character_look())
	            return;
	        value = value > 0.0 ? 1.0 : value;
	        value = value < 0.0 ? -1.0 : value;
	        var for_back_pr = move_state.forw + move_state.back;
	        move_state.back = -value;
	        var for_back = move_state.forw + move_state.back;
	        var right_left = move_state.left + move_state.right;
	        m_phy.set_character_move_dir(character, for_back, right_left);
	        if (motion_cb)
	            motion_cb(for_back, right_left);
	        set_char_state(for_back, right_left);
	        if (move_dir_cd && for_back_pr != for_back)
	            move_dir_cd(for_back, right_left, 0);
	    };
	    var move_right_cb = function(value) {
	        if (!check_character_look())
	            return;
	        var curr_state = get_state_machine_state(sm).id;
	        if (curr_state == CS_CLIMB)
	            value = 0;
	        value = value > 0.0 ? 1.0 : value;
	        value = value < 0.0 ? -1.0 : value;
	        var right_left_pr = move_state.left + move_state.right;
	        move_state.right = -value;
	        var for_back = move_state.forw + move_state.back;
	        var right_left = move_state.left + move_state.right;
	        m_phy.set_character_move_dir(character, for_back, right_left);
	        if (motion_cb)
	            motion_cb(for_back, right_left);
	        set_char_state(for_back, right_left);
	        if (move_dir_cd && right_left_pr != right_left)
	            move_dir_cd(for_back, right_left, 0);
	    };
	    var move_left_cb = function(value) {
	        if (!check_character_look())
	            return;
	        var curr_state = get_state_machine_state(sm).id;
	        if (curr_state == CS_CLIMB)
	            value = 0;
	        var right_left_pr = move_state.left + move_state.right;
	        move_state.left = value;
	        var for_back = move_state.forw + move_state.back;
	        var right_left = move_state.left + move_state.right;
	        m_phy.set_character_move_dir(character, for_back, right_left);
	        if (motion_cb)
	            motion_cb(for_back, right_left);
	        set_char_state(for_back, right_left);
	        if (move_dir_cd && right_left_pr != right_left)
	            move_dir_cd(for_back, right_left, 0);
	    };

	    var jump_cb = function(value) {
	        if (!check_character_look())
	            return;
	        if (value > 0.0) {
	            m_phy.character_jump(character);
	            if (move_dir_cd)
	                move_dir_cd(move_state.forw + move_state.back,
	                        move_state.left + move_state.right, 1);
	        }
	    };
	    var change_movestyle = function(value) {
	        movestyle = value;
	        if (Math.abs(move_state.forw + move_state.back) +
	                Math.abs(move_state.left + move_state.right)) {
	            if (value > 0.0)
	                state_machine_switch_state(sm, CS_RUN);
	            else
	                state_machine_switch_state(sm, CS_WALK);
	            if (move_dir_cd)
	                move_dir_cd(move_state.forw + move_state.back,
	                        move_state.left + move_state.right, 0);
	        } else
	            state_machine_switch_state(sm, CS_STAY);
	    };

	    var change_flystyle = function(value) {
	        if (value > 0.0) {
	            var state = get_state_machine_state(_character_sm).id;
	            if (state == CS_WALK || state == CS_STAY)
	                state_machine_switch_state(sm, CS_FLY);
	            else
	                state_machine_switch_state(sm, CS_WALK);
	        }
	    };
	    var forward_sens_arr = settings.forward_sens_arr;
	    var backward_sens_arr = settings.backward_sens_arr;
	    var right_sens_arr = settings.right_sens_arr;
	    var left_sens_arr = settings.left_sens_arr;
	    var jump_sens_arr = settings.jump_sens_arr;
	    var run_sens_arr = settings.run_sens_arr;
	    var fly_sens_arr = settings.fly_sens_arr;

	    bind_action(AT_PRESSED, forward_sens_arr, move_forward_cb);
	    bind_action(AT_PRESSED, backward_sens_arr, move_backward_cb);
	    bind_action(AT_PRESSED, right_sens_arr, move_right_cb);
	    bind_action(AT_PRESSED, left_sens_arr, move_left_cb);
	    bind_action(AT_PRESSED, jump_sens_arr, jump_cb);

	    bind_action(AT_CONTINUOUS, [m_input.GMPD_AXIS_0], move_right_cb);
	    bind_action(AT_CONTINUOUS, [m_input.GMPD_AXIS_1], move_backward_cb);

	    bind_action(AT_PRESSED, run_sens_arr, change_movestyle);
	    bind_action(AT_PRESSED, fly_sens_arr, change_flystyle);
	}

	function get_state_machine() {
	    if (!_character_sm)
	        _character_sm = {
	            nodes: [],
	            current_node: null,
	            lock: false,
	            last_state: null
	        };
	    return _character_sm;
	}

	function state_machine_add_state(state_machine, id, allowed_ids, call_switch,
	        call_before_switch, call_after_switch) {
	    state_machine.nodes.push({
	        id: id,
	        allowed_ids: allowed_ids,
	        call_switch: call_switch,
	        call_before_switch: call_before_switch,
	        call_after_switch: call_after_switch
	    });
	}

	function check_state_machine_validation(state_machine) {
	    var names = [];
	    for (var i = 0; i < state_machine.nodes; i++) {
	        var id = state_machine.nodes[i].id;
	        if (names.indexOf(id) >= 0)
	            return false;
	        else
	            names.push(id);
	    }
	    for (var i = 0; i < state_machine.nodes; i++) {
	        var node = state_machine.nodes[i];
	        for (var j = 0; j < node.allowed_ids.length; j++) {
	            if (names.indexOf(node.allowed_ids[j]) < 0)
	                return false;
	        }
	    }
	    return true;
	}

	function get_state_machine_node(state_machine, node_id) {
	    var node = null;
	    for (var i = 0; i < state_machine.nodes.length; i++) {
	        if (state_machine.nodes[i].id == node_id) {
	            node = state_machine.nodes[i];
	            break;
	        }
	    }
	    return node;
	}

	function set_state_machine_start_node(state_machine, node_id) {
	    var node = get_state_machine_node(state_machine, node_id);
	    state_machine.current_node = node;
	    return node;
	}

	function get_state_machine_state(state_machine) {
	    return state_machine.current_node;
	}

	function set_state_machine_node_after_cb(state_machine, state_id, callback) {
	    var node = get_state_machine_node(state_machine, state_id);
	    node.call_after_switch = callback;
	}

	function state_machine_switch_state(state_machine, new_state_id) {

	    state_machine.last_state = new_state_id;
	    if (state_machine.lock) {
	        return false;
	    }
	    var cur_state = get_state_machine_state(state_machine);
	    var old_state_id = cur_state.id;
	    if (cur_state.allowed_ids.indexOf(new_state_id) >= 0) {
	        var before = true;
	        if (cur_state.call_before_switch) {
	            before = cur_state.call_before_switch(old_state_id, new_state_id);
	        }
	        if (before) {
	            set_state_machine_start_node(state_machine, new_state_id);
	            if (cur_state.call_switch)
	                cur_state.call_switch(old_state_id, new_state_id);
	            if (cur_state.call_after_switch)
	                cur_state.call_after_switch(old_state_id, new_state_id);
	            return true
	        }
	    }
	    return false
	}

	function init_character_states(character) {

	    var sm = get_state_machine();

	    var change_state_cb = function(old_state_id, new_state_id) {
	        switch(new_state_id) {
	        case CS_STAY:
	        case CS_WALK:
	            m_phy.set_character_move_type(character, m_phy.CM_WALK);
	            break;
	        case CS_RUN:
	            m_phy.set_character_move_type(character, m_phy.CM_RUN);
	            break;
	        case CS_FLY:
	            m_phy.set_character_move_type(character, m_phy.CM_FLY);
	            break;
	        case CS_CLIMB:
	            m_phy.set_character_move_type(character, m_phy.CM_CLIMB);
	            break;
	        }
	    };
	    state_machine_add_state(sm, CS_STAY, [CS_WALK, CS_FLY, CS_RUN, CS_CLIMB], change_state_cb, 
	            null, null);
	    state_machine_add_state(sm, CS_WALK, [CS_RUN, CS_FLY, CS_CLIMB, CS_STAY], change_state_cb, 
	            null, null);
	    state_machine_add_state(sm, CS_RUN, [CS_WALK, CS_FLY, CS_CLIMB, CS_STAY], change_state_cb, 
	            null, null);
	    state_machine_add_state(sm, CS_FLY, [CS_WALK], change_state_cb, 
	            null, null);
	    state_machine_add_state(sm, CS_CLIMB, [CS_WALK, CS_RUN, CS_STAY], change_state_cb, 
	            null, null);

	    check_state_machine_validation(sm);
	    set_state_machine_start_node(sm, CS_STAY);

	    return _character_sm;
	}

	function remove_devices_controls() {
	    for (var i = 0; i < _manifold_counter; i++)
	        m_ctl.remove_sensor_manifold(null, "FPS_USER_CONTROL_ACTION_"
	                + i.toString());
	}

	function remove_plock_controls(character, elem) {
	    if (check_pointerlock(elem) && !m_main.detect_mobile()) {
	        if (_plock_cb.disable_cb)
	            _plock_cb.disable_cb(elem);
	        m_ctl.remove_sensor_manifold(character, "FPS_PLOCK");
	        m_ctl.remove_sensor_manifold(null, "FPS_ACTIVATE_PLOCK");
	    }
	}

	function remove_drag_controls(character, elem) {
	    if (!check_pointerlock(elem) || m_main.detect_mobile()) {
	        m_ctl.remove_sensor_manifold(character, "FPS_CAM_ROT");
	        m_ctl.remove_sensor_manifold(character, "FPS_DRAG_PRESS");
	        m_ctl.remove_sensor_manifold(character, "FPS_DRAG_MOVE");
	        m_ctl.remove_sensor_manifold(character, "FPS_SMOOTH_DRAG");
	    }
	}

	function remove_hmd_controls(character) {
	    if (check_vr_support())
	        m_ctl.remove_sensor_manifold(character, "FPS_CHARECTER_VR_ROT");
	}

	function remove_mobile_controls(character, elem) {
	    if (m_main.detect_mobile()) {
	        var forward_btn = document.getElementById(MOBILE_FORWARD_BTN_ID);
	        var backward_btn = document.getElementById(MOBILE_BACKWARD_BTN_ID);
	        if (forward_btn)
	            elem.removeChild(forward_btn);
	        if (backward_btn)
	            elem.removeChild(backward_btn);
	    }
	}
	function set_curr_gamepad_id(new_id) {
	    _curr_gamepad_id = new_id;
	}
	/**
	 * Character state defining that character is staying.
	 * @const {CharacterState} module:fps.CS_STAY
	 */
	exports.CS_STAY = CS_STAY;
	/**
	 * Character state defining that character is in walk-mode.
	 * @const {CharacterState} module:fps.CS_WALK
	 */
	exports.CS_WALK = CS_WALK;
	/**
	 * Character state defining that character is in run-mode.
	 * @const {CharacterState} module:fps.CS_RUN
	 */
	exports.CS_RUN = CS_RUN;
	/**
	 * Character state defining that character is in fly-mode.
	 * @const {CharacterState} module:fps.CS_FLY
	 */
	exports.CS_FLY = CS_FLY;
	/**
	 * Character state defining that character is in climb-mode.
	 * @const {CharacterState} module:fps.CS_CLIMB
	 */
	exports.CS_CLIMB = CS_CLIMB;

	/**
	 * An input type detecting a discrete user action, e.g. button press.
	 * @const module:fps.AT_PRESSED
	 */
	exports.AT_PRESSED = AT_PRESSED;
	/**
	 * An input type detecting a discrete user action, e.g. button release.
	 * @const module:fps.AT_RELEASED
	 */
	exports.AT_RELEASED = AT_RELEASED;
	/**
	 * An input type detecting a continuous user action,
	 * e.g. a held down button, mouse movement, gamepad stick tilt etc.
	 * @const module:fps.AT_CONTINUOUS
	 */
	exports.AT_CONTINUOUS = AT_CONTINUOUS;

	/**
	 * Bind action callback to user controls. This allows to set and define an additional
	 * action to an event and set the conditions to when and how the event happens.
	 * @method module:fps.bind_action
	 * @param {number} action_type Type of action
	 * @param {Array} action_controls Array of sensor types
	 * @param {Function} action_cb Function which applies logic
	 * @example var m_ctl = require("controls");
	 * var m_fps = require("fps");
	 * var m_input = require("input");
	 *
	 * var action_cb = function(value) {
	 *     console.log(value);
	 * };
	 *
	 * // bind custom callback to be executed after pressing the W key or one of the gamepad 
	 * // buttons or after clicking/touching the html element with the "forward_button_id" id
	 * m_fps.bind_action(m_fps.AT_PRESSED, [m_ctl.KEY_W, m_input.GMPD_BUTTON_12,
	 *          "forward_button_id"], action_cb);
	 */
	exports.bind_action = bind_action;
	function bind_action(action_type, action_controls, action_cb) {

	    if (!action_controls.length)
	        return;

	    var sensors = [];
	    for (var j = 0; j < action_controls.length; j++) {
	        if (typeof action_controls[j] == "number") {
	            if (action_controls[j] < GMPD_BTNS_OFFSET)
	                sensors.push(m_ctl.create_keyboard_sensor(action_controls[j]));
	            else if (action_controls[j] < GMPD_AXIS_OFFSET) {
	                sensors.push(m_ctl.create_gamepad_btn_sensor(action_controls[j],
	                        _curr_gamepad_id));
	            } else
	                sensors.push(m_ctl.create_gamepad_axis_sensor(action_controls[j]));
	        } else if (typeof action_controls[j] == "string") {
	            var control_element = document.getElementById(action_controls[j]);
	            if (control_element) {
	                sensors.push(m_ctl.create_touch_click_sensor(control_element));
	            } else
	                m_print.error("Couldn't find element with " +
	                        action_controls[j] + " ID.");
	        }

	    }

	    var logic_func = function(s) {
	        return false;
	    };
	    var type = m_ctl.CT_SHOT;
	    var manifold_cb = function(obj, id, pulse, sens_num) {};

	    switch(action_type) {
	    case AT_PRESSED:
	        type = m_ctl.CT_TRIGGER;
	        logic_func = function(s) {
	            for (var i = 0; i < s.length; i++)
	                if (s[i])
	                    return true;
	                return false;
	        };
	        manifold_cb = function(obj, id, pulse, sens_num) {
	            if (pulse > 0)
	                action_cb(1.0);
	            else
	                action_cb(0.0);
	        };
	        break;
	    case AT_RELEASED:
	        type = m_ctl.CT_TRIGGER;
	        logic_func = function(s) {
	            for (var i = 0; i < s.length; i++)
	                if (s[i])
	                    return true;
	                return false;
	        };
	        manifold_cb = function(obj, id, pulse, sens_num) {
	            if (pulse < 0)
	                action_cb(1.0);
	            else
	                action_cb(0.0);
	        };
	        break;
	    case AT_CONTINUOUS:
	        type = m_ctl.CT_CONTINUOUS;
	        logic_func = function(s) {
	            for (var i = 0; i < s.length; i++)
	                if (Math.abs(s[i]) > AXIS_THRESHOLD)
	                    return true;
	                return false;
	        };
	        manifold_cb = function(obj, id, pulse, sens_num) {
	            if (pulse > 0) {
	                for (var i = 0; i < sens_num; i++) {
	                    var value = m_ctl.get_sensor_value(obj, id, i);
	                    if (Math.abs(value) > AXIS_THRESHOLD) {
	                        action_cb(value);
	                        return;
	                    }
	                }
	            } else
	                action_cb(0.0);
	        };
	        break;
	    }

	    var action_id = "FPS_USER_CONTROL_ACTION_" + _manifold_counter.toString();
	    var sensors_number = sensors.length;
	    m_ctl.create_sensor_manifold(null, action_id, type,
	            sensors, logic_func, manifold_cb, sensors_number);
	    _manifold_counter++;
	}
	/**
	 * Enable FPS controls. This sets keyboard, gamepad and mouse controls.
	 * VR is also plug-and-play ready.
	 * @method module:fps.enable_fps_controls
	 * @param {Object}   [options={}] Initialization options.
	 * @param {Object3D}   [options.character=The result of the {@link module:scenes.get_first_character|get_first_character()} method call] Character.
	 * @param {HTMLElement} [options.element=The result of the {@link module:container.get_canvas|get_canvas()} method call] HTML element to add event listeners to.
	 * @param {CharMotionCallback}  [options.motion_cb=null] Motion callback function
	 * @param {number}  [options.gamepad_id=0] Connected gamepad ID.
	 * @param {number[]}  [options.forward_sens=[{@link module:controls.KEY_W|KEY_W}, {@link module:input.GMPD_BUTTON_12|GMPD_BUTTON_12}]] Array of sensor types used for forward motion.
	 * @param {number[]}  [options.backward_sens=[{@link module:controls.KEY_S|KEY_S}, {@link module:input.GMPD_BUTTON_13|GMPD_BUTTON_13}]] Array of sensor types used for backward motion.
	 * @param {number[]}  [options.right_sens=[{@link module:controls.KEY_D|KEY_D}, {@link module:input.GMPD_BUTTON_15|GMPD_BUTTON_15}]] Array of sensor types used for right motion.
	 * @param {number[]}  [options.left_sens=[{@link module:controls.KEY_A|KEY_A}, {@link module:input.GMPD_BUTTON_14|GMPD_BUTTON_14}]] Array of sensor types used for left motion.
	 * @param {number[]}  [options.jump_sens=[{@link module:controls.KEY_SPACE|KEY_SPACE}, {@link module:input.GMPD_BUTTON_1|GMPD_BUTTON_1}]] Array of sensor types used for jumping.
	 * @param {number[]}  [options.fly_sens=[{@link module:controls.KEY_SHIFT|KEY_SHIFT}, {@link module:input.GMPD_BUTTON_7|GMPD_BUTTON_7}]] Array of sensor types used for flying.
	 * @param {CharRotationCallback}  [options.rotation_cb] Callback for camera rotation. If not specified, the default one will be used.
	 * @param {boolean} [options.lock_camera=false] Parent camera to the character
	 * @cc_externs character element gamepad_id
	 * @cc_externs forward_sens backward_sens right_sens left_sens
	 * @cc_externs report_init_failure pause_invisible key_pause_enabled
	 * @cc_externs jump_sens fly_sens rotation_cb lock_camera
	 * @cc_externs move_dir_cd motion_cb
	 * @example var m_fps = require("fps");
	 *
	 * var character = m_scene.get_first_character();
	 *
	 * var move_cb = function(forw_back, right_left) {
	 *     console.log(forw_back, right_left);  
	 * }
	 *
	 * m_fps.enable_fps_controls(character, null, move_cb);
	 */
	exports.enable_fps_controls = function(options) {
	    options = options || {lock_camera : true};
	    var character = options.character || m_scs.get_first_character();
	    if (!character)
	        return;
	    var elem = options.element || m_cont.get_canvas();
	    var motion_cb = options.motion_cb || null;
	    set_curr_gamepad_id(options.gamepad_id || 0);

	    var forward_sens_arr = options.forward_sens || [m_ctl.KEY_W, m_input.GMPD_BUTTON_12];
	    var backward_sens_arr = options.backward_sens || [m_ctl.KEY_S, m_input.GMPD_BUTTON_13];
	    var right_sens_arr = options.right_sens || [m_ctl.KEY_D, m_input.GMPD_BUTTON_15];
	    var left_sens_arr = options.left_sens || [m_ctl.KEY_A, m_input.GMPD_BUTTON_14];
	    var jump_sens_arr = options.jump_sens || [m_ctl.KEY_SPACE, m_input.GMPD_BUTTON_1];
	    var run_sens_arr = options.run_sens || [m_ctl.KEY_SHIFT, m_input.GMPD_BUTTON_7];
	    var fly_sens_arr = options.fly_sens || [];

	    if (m_main.detect_mobile()) {
	        forward_sens_arr.push(MOBILE_FORWARD_BTN_ID);
	        backward_sens_arr.push(MOBILE_BACKWARD_BTN_ID);
	    }

	    var move_dir_cd = options.move_dir_cd || null;

	    var configs = {
	        forward_sens_arr : forward_sens_arr,
	        backward_sens_arr : backward_sens_arr,
	        right_sens_arr : right_sens_arr,
	        left_sens_arr : left_sens_arr,
	        jump_sens_arr : jump_sens_arr,
	        run_sens_arr : run_sens_arr,
	        fly_sens_arr : fly_sens_arr,
	        move_dir_cd: move_dir_cd
	    };
	    _rotation_cb = options.rotation_cb || default_rotation_cb;
	    var lock_camera = typeof options.lock_camera != "undefined" ? options.lock_camera : true;
	    set_characters_camera(character, lock_camera);
	    enable_camera_rotation(elem, character);
	    enable_movements(elem, character, motion_cb, configs);
	};
	/**
	 * Disable FPS controls.
	 * @method module:fps.disable_fps_controls
	 * @param {Object3D} [character=The result of the {@link module:scenes.get_first_character|get_first_character()} method call] Character
	 * @param {HTMLElement} [elem=Canvas container element] HTML element to add event listeners to
	 * @example var m_fps = require("fps");
	 *
	 * m_fps.disable_fps_controls();
	 */
	exports.disable_fps_controls = function(character, elem) {
	    character = character || m_scs.get_first_character();
	    elem = elem || m_cont.get_container();

	    if (!character)
	        return;

	    remove_devices_controls();
	    remove_plock_controls(character, elem);
	    remove_drag_controls(character, elem);
	    remove_hmd_controls(character);
	    remove_mobile_controls(character, elem);
	};
	/**
	 * Set character state changing callback function.
	 * @method module:fps.set_state_change_cb
	 * @param {number} state_id State ID
	 * @param {ChangeStateCallback} callback Callback function
	 * @example var m_fps = require("fps");
	 *
	 * var state_changing_cb = function(old_state_id, new_state_id) {
	 *     console.log(old_state_id, new_state_id);  
	 * }
	 *
	 * m_fps.set_state_change_cb(m_fps.CS_WALK, state_changing_cb);
	 */
	exports.set_state_change_cb = function(state_id, callback) {
	    var sm = _character_sm;
	    set_state_machine_node_after_cb(sm, state_id, callback);
	};
	/**
	 * Set character's camera smooth behavior
	 * @method module:fps.set_cam_smooth_factor
	 * @param {number} value Smooth factor
	 * @example var m_fps = require("fps");
	 *
	 * m_fps.set_cam_smooth_factor(0.2);
	 */
	exports.set_cam_smooth_factor = function(value) {
	    m_ctl.set_plock_smooth_factor(value);
	    set_smooth_factor(value);
	};
	/**
	 * Set character's camera smooth behavior
	 * @method module:fps.get_cam_smooth_factor
	 * @example var m_fps = require("fps");
	 *
	 * var smooth_factor = m_fps.get_cam_smooth_factor();
	 */
	exports.get_cam_smooth_factor = function() {
	    return _smooth_factor;
	};
	/**
	 * Set character's camera mouse sensitivity
	 * @method module:fps.set_cam_sensitivity
	 * @param {number} value Sensitivity
	 * @example var m_fps = require("fps");
	 *
	 * m_fps.set_cam_sensitivity(80);
	 */
	exports.set_cam_sensitivity = set_cam_sensitivity;
	function set_cam_sensitivity(value) {
	    _fps_camera_mult = value / MULT_SCALE;
	}
	/**
	 * Get character's camera mouse sensitivity
	 * @method module:fps.get_cam_sensitivity
	 * @example var m_fps = require("fps");
	 *
	 * var sens = m_fps.get_cam_sensitivity();
	 */
	exports.get_cam_sensitivity = get_cam_sensitivity;
	function get_cam_sensitivity() {
	    return _fps_camera_mult * MULT_SCALE;
	}
	/**
	 * Set pointerlock callback function, which is called when pointerlock is enabled
	 * @method module:fps.set_plock_enable_cb
	 * @param {PlockCallback} callback Callback function
	 * @example var m_fps = require("fps");
	 * var cb = function(element) {
	 *     console.log("pointerlock is enabled");  
	 * }
	 *
	 * m_fps.set_plock_enable_cb(cb);
	 */
	exports.set_plock_enable_cb = function(callback) {
	    _plock_cb.enable_cb = callback;
	};
	/**
	 * Set pointerlock callback function, which is called when pointerlock is disabled
	 * @method module:fps.set_plock_disable_cb
	 * @param {PlockCallback} callback Callback function
	 * @example var m_fps = require("fps");
	 *
	 * var cb = function(element) {
	 *     console.log("pointerlock is disabled");  
	 * }
	 *
	 * m_fps.set_plock_disable_cb(cb);
	 */
	exports.set_plock_disable_cb = function(callback) {
	    _plock_cb.disable_cb = callback;
	};
	/**
	 * Get character's current state.
	 * @method module:fps.get_character_state
	 * @returns {CharacterState} Character's current state
	 * @example var m_fps = require("fps");
	 *
	 * var curr_state = m_fps.get_character_state();
	 *
	 * if (curr_state == m_fps.CS_RUN) 
	 *     console.log("Character is running");
	 */
	exports.get_character_state = function() {
	    return get_state_machine_state(_character_sm).id;
	};
	/**
	 * Add new character's state.
	 * @method module:fps.add_new_state
	 * @returns {CharacterState} Character's new state
	 * @example var m_fps = require("fps");
	 *
	 * var new_state = m_fps.add_new_state();
	 */
	exports.add_new_state = function() {
	    return _state_counter++;
	};
	/**
	 * Add new character's state to its state machine.
	 * @method module:fps.add_state
	 * @param {CharacterState} new_state Character's new state
	 * @param {CharacterState[]} enabled_transitions Enabled transitions to another states
	 * @param {ChangeStateCallback} change_state_cb Callback function
	 * @example var m_fps = require("fps");
	 *
	 * var new_state = m_fps.add_new_state();
	 * var state_changing_cb = function(old_state_id, new_state_id) {
	 *     console.log(old_state_id, new_state_id);  
	 * }
	 * m_fps.add_state(new_state, [m_fps.CS_WALK, m_fps.CS_RUN], state_changing_cb);
	 */
	exports.add_state = function(new_state, enabled_transitions, change_state_cb) {
	    var sm = get_state_machine();
	    state_machine_add_state(sm, new_state, enabled_transitions, change_state_cb, 
	            null, null);
	    if (!check_state_machine_validation(sm))
	        m_print.error("Incorrect state machine.");
	};
	/**
	 * Switch character's state.
	 * @method module:fps.switch_state
	 * @param {CharacterState} state Character's state
	 * @example var m_fps = require("fps");
	 *
	 * m_fps.switch_state(m_fps.CS_WALK);
	 */
	exports.switch_state = function(state) {
	    var sm = get_state_machine();
	    state_machine_switch_state(sm, state);
	};
	/**
	 * Lock character's state changing.
	 * @method module:fps.lock_character
	 * @example var m_fps = require("fps");
	 *
	 * m_fps.lock_character();
	 */
	exports.lock_character = function() {
	    var sm = get_state_machine();
	    sm.lock = true;
	};
	/**
	 * Unlock character's state changing.
	 * @method module:fps.unlock_character
	 * @example var m_fps = require("fps");
	 *
	 * m_fps.unlock_character();
	 */
	exports.unlock_character = function() {
	    var sm = get_state_machine();
	    sm.lock = false;
	};
	/**
	 * Check if character's state changing is locked.
	 * @method module:fps.is_character_locked
	 * @example var m_fps = require("fps");
	 *
	 * if (m_fps.is_character_locked())
	 *     console.log("character is locked");
	 */
	exports.is_character_locked = function() {
	    var sm = get_state_machine();
	    return sm.lock;
	};
	/**
	 * Set character rotation callback.
	 * @method module:fps.set_rotation_cb
	 * @param {CharRotationCallback} rotation_cb Character's rotation callback
	 * @example var m_fps = require("fps");
	 *
	 * m_fps.set_rotation_cb(function(char, rot_x, rot_y) {});
	 */
	exports.set_rotation_cb = function(rotation_cb) {
	    if (!rotation_cb)
	        _rotation_cb = default_rotation_cb;
	    else
	        _rotation_cb = rotation_cb;
	};
	/**
	 * Freeze character's movements.
	 * @method module:fps.freeze_movements
	 * @example var m_fps = require("fps");
	 *
	 * m_fps.freeze_movements();
	 */
	exports.freeze_movements = function() {
	    _is_freezed = true;
	};
	/**
	 * Unfreeze character's movements.
	 * @method module:fps.unfreeze_movements
	 * @example var m_fps = require("fps");
	 *
	 * m_fps.unfreeze_movements();
	 */
	exports.unfreeze_movements = function() {
	    _is_freezed = false;
	};

	}

	var fps_factory = register("fps", FPS);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Local storage add-on.
	 * @see http://www.w3.org/TR/webstorage/
	 * @name storage
	 * @namespace
	 * @exports exports as storage
	 */
	function Storage(ns, exports) {

	var m_print = print_factory(ns);

	var _prefix = "b4w";
	var _storage = null;

	/**
	 * Initialize the application storage.
	 * @method module:storage.init
	 * @param {string} prefix Storage prefix
	 */
	exports.init = init;
	function init(prefix) {
	    if (prefix)
	        if (prefix !== "b4w")
	            _prefix = prefix;
	        else
	            m_print.error("b4w prefix denied");
	    else
	        m_print.warn("Prefix should be a string. " +
	                "Last declared storage prefix will be used.");
	}

	function init_storage() {
	    try {
	        _storage = window.localStorage;
	        try {
	            _storage["tmp"] = null;
	            delete _storage["tmp"];
	        } catch (e) {
	            m_print.warn("localStorage quota is limited. Disabling localStorage");
	            _storage = null;
	        }
	    } catch (e) {
	        m_print.warn("Applying chrome localStorage bug workaround");
	        _storage = null;
	    }

	    if (!_storage) {
	        m_print.warn("localStorage is not available, initializing temporary storage");
	        _storage = {};
	    }
	}

	/**
	 * Save the value in the local storage.
	 * @param {string} key Key
	 * @param {string} value Value
	 * @param {?string} prefix Storage prefix.
	 */
	exports.set = function(key, value, prefix) {
	    var b4w_st = get_b4w_storage(prefix);
	    b4w_st[key] = String(value);
	    set_b4w_storage(b4w_st, prefix);
	};

	function get_b4w_storage(prefix) {
	    if (_storage[prefix? prefix: _prefix])
	        return JSON.parse(_storage[prefix? prefix: _prefix]);
	    else
	        return {};
	}

	function set_b4w_storage(b4w_storage, prefix) {
	    _storage[prefix? prefix: _prefix] = JSON.stringify(b4w_storage);
	}

	/**
	 * Perform local storage cleanup.
	 * @param {?string} prefix Storage prefix.
	 */
	exports.cleanup = function(prefix) {
	    delete _storage[prefix? prefix: _prefix];
	};

	/**
	 * Get the value from the local storage.
	 * @param {string} key Key
	 * @param {?string} prefix Storage prefix.
	 * @returns {string} Value
	 */
	exports.get = function(key, prefix) {
	    var b4w_st = get_b4w_storage(prefix);
	    if (b4w_st[key])
	        return b4w_st[key];
	    else
	        return "";
	};

	/**
	 * Print the local storage.
	 * @param {?string} prefix Storage prefix.
	 */
	exports.debug = function(prefix) {
	    m_print.log(get_b4w_storage(prefix? prefix: _prefix));
	};

	// NOTE: initialize with default prefix for compatibility reasons
	init_storage();

	}

	var storage_factory = register("storage", Storage);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Gamepads configurator add-on.
	 * @module gp_conf
	 */

	function GP_config(ns, exports) {

	var m_cont      = container_factory(ns);
	var m_ctrl      = controls_factory(ns);
	var m_input     = input_factory(ns);
	var m_storage   = storage_factory(ns);

	var SVG_BASE64 = "url('data:image/svg+xml;base64,";
	var BLUE_COLOR = "#5276cf";
	var BLUE_COLOR_REGEXP = new RegExp(BLUE_COLOR, "g");
	var RED_COLOR = "#ff0000";
	var GREEN_COLOR = "#00ff00";
	var GREY_COLOR = "#e6e6e6";

	var SELECT_BTN_CAPTION = "Click on the buttons & arrows to setup your controller";
	var PRESS_BTN_CAPTION = "Now press the button on the device";
	var MOVE_AXIS_CAPTION = "Now move the axis on the device";
	var MAIN_DEVICE_CAPTION = "Select a device";

	var AXIS_STEP = 20;

	var GMPD_DFLT_STNGS = {};
	GMPD_DFLT_STNGS[m_input.GMPD_BUTTON_12] = m_input.GMPD_BUTTON_12;
	GMPD_DFLT_STNGS[m_input.GMPD_BUTTON_13] = m_input.GMPD_BUTTON_13;
	GMPD_DFLT_STNGS[m_input.GMPD_BUTTON_15] = m_input.GMPD_BUTTON_15;
	GMPD_DFLT_STNGS[m_input.GMPD_BUTTON_14] = m_input.GMPD_BUTTON_14;
	GMPD_DFLT_STNGS[m_input.GMPD_BUTTON_3] = m_input.GMPD_BUTTON_3;
	GMPD_DFLT_STNGS[m_input.GMPD_BUTTON_0] = m_input.GMPD_BUTTON_0;
	GMPD_DFLT_STNGS[m_input.GMPD_BUTTON_1] = m_input.GMPD_BUTTON_1;
	GMPD_DFLT_STNGS[m_input.GMPD_BUTTON_2] = m_input.GMPD_BUTTON_2;
	GMPD_DFLT_STNGS[m_input.GMPD_BUTTON_5] = m_input.GMPD_BUTTON_5;
	GMPD_DFLT_STNGS[m_input.GMPD_BUTTON_7] = m_input.GMPD_BUTTON_7;
	GMPD_DFLT_STNGS[m_input.GMPD_BUTTON_4] = m_input.GMPD_BUTTON_4;
	GMPD_DFLT_STNGS[m_input.GMPD_BUTTON_6] = m_input.GMPD_BUTTON_6;
	GMPD_DFLT_STNGS[m_input.GMPD_BUTTON_8] = m_input.GMPD_BUTTON_8;
	GMPD_DFLT_STNGS[m_input.GMPD_BUTTON_9] = m_input.GMPD_BUTTON_9;
	GMPD_DFLT_STNGS[m_input.GMPD_BUTTON_10] = m_input.GMPD_BUTTON_10;
	GMPD_DFLT_STNGS[m_input.GMPD_BUTTON_11] = m_input.GMPD_BUTTON_11;
	GMPD_DFLT_STNGS[m_input.GMPD_BUTTON_16] = m_input.GMPD_BUTTON_16;


	var VIEWER_MODE = 0;
	var BTN_EDIT_MODE = 1;
	var AXIS_EDIT_MODE = 2;

	// pad
	var gamepad_svg = '<svg id="svg26627" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns="http://www.w3.org/2000/svg" height="128.51mm" viewBox="0 0 636.63517 455.33329" width="179.67mm" version="1.1" xmlns:cc="http://creativecommons.org/ns#" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:dc="http://purl.org/dc/elements/1.1/"><defs id="defs26629"><linearGradient id="linearGradient4691"><stop id="stop4693" offset="0"/><stop id="stop4695" stop-opacity="0" offset="1"/></linearGradient><linearGradient id="linearGradient4358"><stop id="stop4360" stop-color="#2e2e2e" offset="0"/><stop id="stop4362" stop-color="#2e2e2e" stop-opacity="0" offset="1"/></linearGradient><linearGradient id="linearGradient4364" x1="1141.5" xlink:href="#linearGradient4358" gradientUnits="userSpaceOnUse" y1="255.95" gradientTransform="matrix(-1 0 0 1 1531.4 560.1)" x2="1165.2" y2="309.88"/><linearGradient id="linearGradient4368" x1="1141.5" xlink:href="#linearGradient4358" gradientUnits="userSpaceOnUse" y1="255.95" gradientTransform="translate(-896.37 560.1)" x2="1165.2" y2="309.88"/><linearGradient id="linearGradient4430" x1="959.32" gradientUnits="userSpaceOnUse" y1="653.07" gradientTransform="matrix(-1 0 0 1 1531.4 70.097)" x2="1467.6" y2="653.07"><stop id="stop4426" stop-color="#4f4f4f" offset="0"/><stop id="stop4428" stop-color="#4f4f4f" stop-opacity="0" offset="1"/></linearGradient><linearGradient id="linearGradient4701" x1="529.91" xlink:href="#linearGradient4691" gradientUnits="userSpaceOnUse" y1="111.1" gradientTransform="translate(-52.276 546.89)" x2="481.49" y2="85.746"/><linearGradient id="linearGradient4713" x1="529.91" xlink:href="#linearGradient4691" gradientUnits="userSpaceOnUse" y1="111.1" gradientTransform="matrix(-1 0 0 1 689.01 546.89)" x2="481.49" y2="85.746"/><linearGradient id="linearGradient4725" x1="367.39" xlink:href="#linearGradient4691" gradientUnits="userSpaceOnUse" y1="125.6" gradientTransform="matrix(-1.3272 0 0 .68317 806.95 579.14)" x2="367.39" y2="116.11"/></defs><metadata id="metadata26632"><rdf:RDF><cc:Work rdf:about="">    <dc:format>image/svg+xml</dc:format>    <dc:type rdf:resource="http://purl.org/dc/dcmitype/StillImage"/>    <dc:title/></cc:Work></rdf:RDF></metadata><g id="layer1" transform="translate(0 -597.03)"><g id="g20" fill-rule="evenodd"><path id="path4209" fill="#434343" d="m576.71 1052.4c42.015-1.9097 64.296-46.468 59.204-122.86-5.0928-76.387-27.374-175.69-44.562-224.7-17.188-49.015-25.501-62.531-26.737-65.565-3.7697-9.2504-11.278-19.949-62.379-27.691-28.97-4.3891-16.697-7.9577-27.084-9.4696-17.96-2.6141-43.609-1.229-52.203 1.6354-8.594 2.8645-12.709 29.16-24.486 35.207-11.777 6.0473-19.416 10.185-80.149 10.185s-68.372-4.1376-80.149-10.185c-11.777-6.0473-18.113-32.099-25.736-36.993-11.183-7.1796-26.985-5.6722-54.891-0.57481-5.64 1.0302-1.1304 7.6212-18.165 12.509-32.913 9.4438-52.094 3.7056-65.087 20.831-1.9807 2.6106-11.822 21.096-29.01 70.111-17.179 48.95-39.46 148.25-44.553 224.64-5.0929 76.39 17.188 120.99 59.204 122.89 73.339-1.7 55.219-116.53 258.4-116.53s185.05 114.82 258.4 116.49z"/><path id="path4366" fill="url(#linearGradient4368)" d="m249.77 838.51c-107.76 0-171.55 96.288-176.84 121.23-5.2294 24.634-17.658 55.705 3.8195 53.789 9.6996-0.8655 18.053-15.713 37.559-38.193 18.78-21.643 41.379-54.425 96.763-54.425s73.209-44.877 75.119-53.152c1.9098-8.2752 2.4146-27.976-36.418-29.25z"/><path id="path4217" fill="url(#linearGradient4364)" d="m385.23 838.51c107.76 0 171.55 96.288 176.84 121.23 5.2293 24.634 17.658 55.705-3.8195 53.789-9.6996-0.8655-18.053-15.713-37.559-38.193-18.78-21.643-41.379-54.425-96.763-54.425s-73.209-44.877-75.119-53.152c-1.9098-8.2752-2.4146-27.976 36.418-29.25z"/><path id="path4370" fill="url(#linearGradient4430)" d="m572.06 654.81c-60.48-19.09-76.79-18.6-89.84-17.96-13.05 0.63657-22.638 16.617-45.237 49.4s-67.48 125.27-116.23 125.27c-48.746 0-93.626-92.491-116.23-125.27-22.599-32.783-32.008-48.942-45.059-49.579-13.05-0.63648-35.251 1.8354-95.728 20.932l1.1161-2.3404c60.494-19.1 81.754-20.83 94.804-20.19 13.05 0.63657 22.281 13.049 44.88 45.832s67.48 123.49 116.23 123.49c48.746 0 93.626-90.709 116.23-123.49 22.599-32.783 31.83-45.195 44.88-45.832 13.05-0.63648 28.783-1.6248 89.26 17.472"/><path id="path4315" fill="#343434" d="m570.99 652.48c-60.477-19.097-76.074-18.269-89.124-17.633-13.05 0.63658-22.281 14.832-44.88 47.614-22.599 32.783-67.48 125.27-116.23 125.27-48.746 0-93.626-92.491-116.23-125.27-22.599-32.783-31.83-46.978-44.88-47.614-13.05-0.63648-34.715 1.2996-95.192 20.396l1.1161-2.3404c60.474-19.1 81.024-22.26 94.074-21.62 13.05 0.63658 22.281 13.049 44.88 45.832s67.48 123.49 116.23 123.49c48.746 0 93.626-90.709 116.23-123.49 22.599-32.783 31.83-45.195 44.88-45.832 13.05-0.63647 27.71-0.17274 88.186 18.924"/></g><g id="g15645" transform="matrix(.75439 0 0 1 1558.5 -6638.3)" fill-rule="evenodd"><rect id="rect15584" style="color-rendering:auto;color:#000000;isolation:auto;mix-blend-mode:normal;shape-rendering:auto;solid-color:#000000;image-rendering:auto" rx="2" ry="1.8461" height="44.307" width="570" y="6558.3" x="100.71" fill="#4164bb"/><rect id="rect15331" style="color-rendering:auto;color:#000000;isolation:auto;mix-blend-mode:normal;shape-rendering:auto;solid-color:#000000;image-rendering:auto" rx="2" ry="1.8461" height="44.307" width="570" y="6554.6" x="100.71" fill="#5276cf"/></g><text id="text15623-9" style="word-spacing:0px;letter-spacing:0px" font-weight="300" xml:space="preserve" font-size="22px" line-height="430.99999428%" y="-53.755863" x="1792.7805" font-family="&apos;Noto Sans CJK TC&apos;" fill="#ffffff"><tspan id="tspan15625-5" y="-53.755863" x="1792.7805"/></text><text id="text15657" style="word-spacing:0px;letter-spacing:0px" font-weight="300" xml:space="preserve" font-size="13px" line-height="430.99999428%" y="-3.7607465" x="1670.2437" font-family="&apos;Noto Sans CJK TC&apos;" fill="#828282"><tspan id="tspan15659" y="-3.7607465" x="1670.2437"/></text><g id="g34" fill-rule="evenodd"><path id="path4675" fill="#303030" d="m551.75 628.4c9.3003 4.1796 8.2375 11.558 2.1302 9.9581-6.1073-1.6003-33.792-9.1405-46.239-11.577-12.446-2.4363-34.904-3.0623-36.951-4.0165-2.0474-0.95416 0.93313-7.7247 5.491-7.3449 23.258 0.91012 59.905 6.0339 75.569 12.98z"/><path id="path4677" fill="#303030" d="m474.88 602.61c3.6488 0.63684 4.1169 1.3708 2.4115 5.2499-0.80967 1.8416-1.261 3.904-3.4715 3.7336-4.456-0.34344-16.578-1.2846-25.692-1.3764-9.1139-0.0918-23.83 1.217-25.307 0.79399-1.4771-0.42301-1.8834-4.9141 1.7769-6.7458 4.6221-1.3593 38.698-3.2021 50.281-1.6553z"/><path id="path4699" opacity=".384" fill="url(#linearGradient4701)" d="m475.53 611.7c-11.693-0.63604-8.4597-0.73151-44.068 54.448-6.5182 8.6489-22.874 37.231-36.865 35.326-6.7491-1.4177 15.436-67.299 22.724-75.767 11.112-12.911 19.255-16.122 58.209-14.007z"/><path id="path4703" fill="#303030" d="m84.068 628.4c-9.3003 4.1796-8.2375 11.558-2.1302 9.9581 6.1073-1.6003 33.792-9.1405 46.239-11.577 12.446-2.4363 34.904-3.0623 36.951-4.0165 2.0474-0.95416-0.93313-7.7247-5.491-7.3449-23.258 0.91012-59.905 6.0339-75.569 12.98z"/><path id="path4705" fill="#303030" d="m161.86 602.61c-3.6488 0.63684-4.1169 1.3708-2.4115 5.2499 0.80967 1.8416 1.261 3.904 3.4715 3.7336 4.456-0.34344 16.578-1.2846 25.692-1.3764 9.1139-0.0918 23.83 1.217 25.307 0.79399 1.4771-0.42301 1.8834-4.9141-1.7769-6.7458-4.6221-1.3593-38.698-3.2021-50.281-1.6553z"/><path id="path4711" opacity=".384" fill="url(#linearGradient4713)" d="m161.2 611.7c11.693-0.63604 8.4597-0.73151 44.068 54.448 6.5182 8.6489 22.874 37.231 36.865 35.326 6.7491-1.4177-15.436-67.299-22.724-75.767-11.112-12.911-19.255-16.122-58.209-14.007z"/><path id="path4717" opacity=".115" fill="url(#linearGradient4725)" d="m413.37 645.84c-9.0496 10.007-29.401 19.937-36.775 19.937h-52.205c-31.171 0-37.359 0.34506-47.75 0.51758-10.39 0.17253-18.682 0.65628-23.653-3.278-5.0513-3.9977-24-15.425-24-15.425 53.346 4.1464 144.49 4.3368 184.38-1.7523z"/></g></g><g id="layer1-0" fill-rule="evenodd" transform="translate(159.08 -720.76)"><g id="g4527-3" transform="translate(-961.22,330.69)"><ellipse id="circle4233-8" style="color-rendering:auto;color:#000000;isolation:auto;mix-blend-mode:normal;shape-rendering:auto;solid-color:#000000;image-rendering:auto" rx="66.284" ry="66.279" cy="655.39" cx="1027.5" fill="#303030"/><ellipse id="circle4235-8" style="color-rendering:auto;color:#000000;isolation:auto;mix-blend-mode:normal;shape-rendering:auto;solid-color:#000000;image-rendering:auto" rx="62.007" ry="62.003" cy="655.39" cx="1027.5" fill="#4c4c4c"/><ellipse id="circle4237-7" style="color-rendering:auto;color:#000000;isolation:auto;mix-blend-mode:normal;shape-rendering:auto;solid-color:#000000;image-rendering:auto" rx="43.41" ry="43.408" cy="655.39" cx="1027.5" fill="#303030"/></g><g id="g4523-1" transform="translate(-961.22,330.69)"><ellipse id="circle4239-4" style="color-rendering:auto;color:#000000;isolation:auto;mix-blend-mode:normal;shape-rendering:auto;solid-color:#000000;image-rendering:auto" rx="40.057" ry="40.054" cy="655.39" cx="1027.5" fill="#3b63c9"/><ellipse id="circle4243-3" style="color-rendering:auto;color:#000000;isolation:auto;mix-blend-mode:normal;shape-rendering:auto;solid-color:#000000;image-rendering:auto" rx="36.23" ry="36.228" cy="655.39" cx="1027.5" fill="#5276cf"/></g><g id="g3506" transform="translate(-961.22,330.69)"><ellipse id="ellipse3508" style="color-rendering:auto;color:#000000;isolation:auto;mix-blend-mode:normal;shape-rendering:auto;solid-color:#000000;image-rendering:auto" rx="66.284" ry="66.279" cy="655.39" cx="1027.5" fill="#303030"/><ellipse id="ellipse3510" style="color-rendering:auto;color:#000000;isolation:auto;mix-blend-mode:normal;shape-rendering:auto;solid-color:#000000;image-rendering:auto" rx="62.007" ry="62.003" cy="655.39" cx="1027.5" fill="#4c4c4c"/><ellipse id="ellipse3512" style="color-rendering:auto;color:#000000;isolation:auto;mix-blend-mode:normal;shape-rendering:auto;solid-color:#000000;image-rendering:auto" rx="43.41" ry="43.408" cy="655.39" cx="1027.5" fill="#303030"/></g></g><g id="layer1-7" fill-rule="evenodd" transform="translate(352.57 -719.72)"><g id="g4527-3-4" transform="translate(-961.22,330.69)"><ellipse id="circle4233-8-8" style="color-rendering:auto;color:#000000;isolation:auto;mix-blend-mode:normal;shape-rendering:auto;solid-color:#000000;image-rendering:auto" rx="66.284" ry="66.279" cy="655.39" cx="1027.5" fill="#303030"/><ellipse id="circle4235-8-9" style="color-rendering:auto;color:#000000;isolation:auto;mix-blend-mode:normal;shape-rendering:auto;solid-color:#000000;image-rendering:auto" rx="62.007" ry="62.003" cy="655.39" cx="1027.5" fill="#4c4c4c"/><ellipse id="circle4237-7-3" style="color-rendering:auto;color:#000000;isolation:auto;mix-blend-mode:normal;shape-rendering:auto;solid-color:#000000;image-rendering:auto" rx="43.41" ry="43.408" cy="655.39" cx="1027.5" fill="#303030"/></g><g id="g4523-1-1" transform="translate(-961.22,330.69)"><ellipse id="circle4239-4-4" style="color-rendering:auto;color:#000000;isolation:auto;mix-blend-mode:normal;shape-rendering:auto;solid-color:#000000;image-rendering:auto" rx="40.057" ry="40.054" cy="655.39" cx="1027.5" fill="#3b63c9"/><ellipse id="circle4243-3-5" style="color-rendering:auto;color:#000000;isolation:auto;mix-blend-mode:normal;shape-rendering:auto;solid-color:#000000;image-rendering:auto" rx="36.23" ry="36.228" cy="655.39" cx="1027.5" fill="#5276cf"/></g><g id="g3506-2" transform="translate(-961.22,330.69)"><ellipse id="ellipse3508-1" style="color-rendering:auto;color:#000000;isolation:auto;mix-blend-mode:normal;shape-rendering:auto;solid-color:#000000;image-rendering:auto" rx="66.284" ry="66.279" cy="655.39" cx="1027.5" fill="#303030"/><ellipse id="ellipse3510-1" style="color-rendering:auto;color:#000000;isolation:auto;mix-blend-mode:normal;shape-rendering:auto;solid-color:#000000;image-rendering:auto" rx="62.007" ry="62.003" cy="655.39" cx="1027.5" fill="#4c4c4c"/><ellipse id="ellipse3512-4" style="color-rendering:auto;color:#000000;isolation:auto;mix-blend-mode:normal;shape-rendering:auto;solid-color:#000000;image-rendering:auto" rx="43.41" ry="43.408" cy="655.39" cx="1027.5" fill="#303030"/></g></g></svg>';
	var dpad_svg = '<svg id="svg3904" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns="http://www.w3.org/2000/svg" height="35.924mm" width="35.926mm" version="1.1" xmlns:cc="http://creativecommons.org/ns#" xmlns:dc="http://purl.org/dc/elements/1.1/" viewBox="0 0 127.29808 127.28933"><metadata id="metadata3909"><rdf:RDF><cc:Work rdf:about=""><dc:format>image/svg+xml</dc:format><dc:type rdf:resource="http://purl.org/dc/dcmitype/StillImage"/><dc:title/></cc:Work></rdf:RDF></metadata><g id="layer1" fill-rule="evenodd" transform="translate(0 -925.07)"><ellipse id="circle4330" style="color-rendering:auto;color:#000000;isolation:auto;mix-blend-mode:normal;shape-rendering:auto;solid-color:#000000;image-rendering:auto" rx="63.649" ry="63.645" cy="988.72" cx="63.649" fill="#303030"/><ellipse id="circle4223" style="color-rendering:auto;color:#000000;isolation:auto;mix-blend-mode:normal;shape-rendering:auto;solid-color:#000000;image-rendering:auto" rx="59.705" ry="59.701" cy="988.72" cx="63.649" fill="#4c4c4c"/></g></svg>';
	var dpad_up_svg = '<svg id="svg3754" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns="http://www.w3.org/2000/svg" height="10.711mm" width="9.9653mm" version="1.1" xmlns:cc="http://creativecommons.org/ns#" xmlns:dc="http://purl.org/dc/elements/1.1/" viewBox="0 0 35.3101 37.950677"><metadata id="metadata3759"><rdf:RDF><cc:Work rdf:about=""><dc:format>image/svg+xml</dc:format><dc:type rdf:resource="http://purl.org/dc/dcmitype/StillImage"/><dc:title/></cc:Work></rdf:RDF></metadata><g id="layer1" transform="translate(0 -1014.4)"><path id="path4326" stroke-linejoin="round" style="color-rendering:auto;color:#000000;isolation:auto;mix-blend-mode:normal;shape-rendering:auto;solid-color:#000000;image-rendering:auto" d="m34.81 1017.1c-15.254-3.8172-24.634-1.7612-34.31 0v16.247h0.015c-0.013 0.097-0.013 0.1951-0.015 0.2928 0.0006 9.4753 7.6813 18.256 17.156 18.256 9.4739-0.0005 17.154-8.7813 17.154-18.256 0-0.097-0.014-0.1952-0.014-0.2928h0.014z" fill-rule="evenodd" stroke="#4364b2" stroke-linecap="round" fill="#5276cf"/></g></svg>';
	var dpad_right_svg = '<svg id="svg3790" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns="http://www.w3.org/2000/svg" height="9.9646mm" width="10.711mm" version="1.1" xmlns:cc="http://creativecommons.org/ns#" xmlns:dc="http://purl.org/dc/elements/1.1/" viewBox="0 0 37.953175 35.3077"><metadata id="metadata3795"><rdf:RDF><cc:Work rdf:about=""><dc:format>image/svg+xml</dc:format><dc:type rdf:resource="http://purl.org/dc/dcmitype/StillImage"/><dc:title/></cc:Work></rdf:RDF></metadata><g id="layer1" transform="translate(0 -1017.1)"><path id="path4324" stroke-linejoin="round" style="color-rendering:auto;color:#000000;isolation:auto;mix-blend-mode:normal;shape-rendering:auto;solid-color:#000000;image-rendering:auto" d="m35.298 1017.6c3.8175 15.253 1.7611 24.633 0 34.308h-16.248v-0.015c-0.098 0.01-0.1952 0.01-0.2928 0.015-9.476-0.0006-18.258-7.6807-18.257-17.154 0.0005-9.4733 8.7818-17.153 18.257-17.153 0.098 0 0.1952 0.01 0.2928 0.011v-0.011z" fill-rule="evenodd" stroke="#4364b2" stroke-linecap="round" fill="#5276cf"/></g></svg>';
	var dpad_down_svg = '<svg id="svg3754" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns="http://www.w3.org/2000/svg" height="10.711mm" width="9.9653mm" version="1.1" xmlns:cc="http://creativecommons.org/ns#" xmlns:dc="http://purl.org/dc/elements/1.1/" viewBox="0 0 35.3101 37.950677"><metadata id="metadata3759"><rdf:RDF><cc:Work rdf:about=""><dc:format>image/svg+xml</dc:format><dc:type rdf:resource="http://purl.org/dc/dcmitype/StillImage"/><dc:title/></cc:Work></rdf:RDF></metadata><g id="layer1" transform="translate(0 -1014.4)"><path id="path4328" stroke-linejoin="round" style="color-rendering:auto;color:#000000;isolation:auto;mix-blend-mode:normal;shape-rendering:auto;solid-color:#000000;image-rendering:auto" d="m34.81 1049.7c-15.254 3.8172-24.634 1.7612-34.31 0v-16.247h0.015c-0.013-0.097-0.013-0.1951-0.015-0.2928 0.0006-9.4753 7.6813-18.256 17.156-18.256 9.4739 0.0005 17.154 8.7813 17.154 18.256 0 0.097-0.014 0.1952-0.014 0.2928h0.014z" fill-rule="evenodd" stroke="#4364b2" stroke-linecap="round" fill="#5276cf"/></g></svg>';
	var dpad_left_svg = '<svg id="svg3790" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns="http://www.w3.org/2000/svg" height="9.9646mm" width="10.711mm" version="1.1" xmlns:cc="http://creativecommons.org/ns#" xmlns:dc="http://purl.org/dc/elements/1.1/" viewBox="0 0 37.953175 35.3077"><metadata id="metadata3795"><rdf:RDF><cc:Work rdf:about=""><dc:format>image/svg+xml</dc:format><dc:type rdf:resource="http://purl.org/dc/dcmitype/StillImage"/><dc:title/></cc:Work></rdf:RDF></metadata><g id="layer1" transform="translate(0 -1017.1)"><path id="path4324" stroke-linejoin="round" style="color-rendering:auto;color:#000000;isolation:auto;mix-blend-mode:normal;shape-rendering:auto;solid-color:#000000;image-rendering:auto" d="m2.6552 1051.9c-3.8175-15.253-1.7611-24.633 0-34.308h16.248v0.015c0.098-0.01 0.1952-0.01 0.2928-0.015 9.476 0.0006 18.258 7.6807 18.257 17.154-0.0005 9.4733-8.7818 17.153-18.257 17.153-0.098 0-0.1952-0.01-0.2928-0.011v0.011z" fill-rule="evenodd" stroke="#4364b2" stroke-linecap="round" fill="#5276cf"/></g></svg>';
	var face_btn_svg = '<svg id="svg3548" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns="http://www.w3.org/2000/svg" height="13.417mm" width="13.418mm" version="1.1" xmlns:cc="http://creativecommons.org/ns#" xmlns:dc="http://purl.org/dc/elements/1.1/" viewBox="0 0 47.543997 47.542"><metadata id="metadata3553"><rdf:RDF><cc:Work rdf:about=""><dc:format>image/svg+xml</dc:format><dc:type rdf:resource="http://purl.org/dc/dcmitype/StillImage"/><dc:title/></cc:Work></rdf:RDF></metadata><g id="layer1" transform="translate(0 -1004.8)"><ellipse id="circle4271" style="color-rendering:auto;color:#000000;isolation:auto;mix-blend-mode:normal;shape-rendering:auto;solid-color:#000000;image-rendering:auto" rx="23.772" ry="23.771" cy="1028.6" cx="23.772" fill="#303030"/><ellipse id="circle4273" stroke-linejoin="round" style="color-rendering:auto;color:#000000;isolation:auto;mix-blend-mode:normal;shape-rendering:auto;solid-color:#000000;image-rendering:auto" stroke-linecap="round" rx="18.668" ry="18.667" stroke="#3b63c9" cy="1028.6" cx="23.772" fill="#5276cf"/></g></svg>';
	var analog_btn_svg = '<svg id="svg3461" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns="http://www.w3.org/2000/svg" height="22.608mm" width="22.61mm" version="1.1" xmlns:cc="http://creativecommons.org/ns#" xmlns:dc="http://purl.org/dc/elements/1.1/" viewBox="0 0 80.114398 80.108405"><metadata id="metadata3466"><rdf:RDF><cc:Work rdf:about=""><dc:format>image/svg+xml</dc:format><dc:type rdf:resource="http://purl.org/dc/dcmitype/StillImage"/><dc:title/></cc:Work></rdf:RDF></metadata><g id="layer1" transform="translate(.0000019915 -972.25)"><g id="g3514-7" fill-rule="evenodd" transform="translate(-987.45 356.91)"><ellipse id="ellipse3516-7" style="color-rendering:auto;color:#000000;isolation:auto;mix-blend-mode:normal;shape-rendering:auto;solid-color:#000000;image-rendering:auto" rx="40.057" ry="40.054" cy="655.39" cx="1027.5" fill="#3b63c9"/><ellipse id="ellipse3518-7" style="color-rendering:auto;color:#000000;isolation:auto;mix-blend-mode:normal;shape-rendering:auto;solid-color:#000000;image-rendering:auto" rx="36.23" ry="36.228" cy="655.39" cx="1027.5" fill="#5276cf"/></g></g></svg>';
	var start_btn_svg = '<svg id="svg3699" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns="http://www.w3.org/2000/svg" height="9.2811mm" width="9.2817mm" version="1.1" xmlns:cc="http://creativecommons.org/ns#" xmlns:dc="http://purl.org/dc/elements/1.1/" viewBox="0 0 32.8879 32.88565"><metadata id="metadata3704"><rdf:RDF><cc:Work rdf:about=""><dc:format>image/svg+xml</dc:format><dc:type rdf:resource="http://purl.org/dc/dcmitype/StillImage"/><dc:title/></cc:Work></rdf:RDF></metadata><g id="layer1" fill-rule="evenodd" transform="translate(0 -1019.5)"><ellipse id="ellipse4575" style="color-rendering:auto;color:#000000;isolation:auto;mix-blend-mode:normal;shape-rendering:auto;solid-color:#000000;image-rendering:auto" rx="16.444" ry="16.443" cy="1035.9" cx="16.444" fill="#2e2e2e"/><ellipse id="ellipse4577" stroke-linejoin="round" style="color-rendering:auto;color:#000000;isolation:auto;mix-blend-mode:normal;shape-rendering:auto;solid-color:#000000;image-rendering:auto" stroke-linecap="round" rx="15.112" ry="15.11" stroke="#4364b2" cy="1035.9" cx="16.444" fill="#5276cf"/><ellipse id="ellipse4579" style="color-rendering:auto;color:#000000;isolation:auto;mix-blend-mode:normal;shape-rendering:auto;solid-color:#000000;image-rendering:auto" rx="11.867" ry="11.866" cy="1035.9" cx="16.444" fill="#434343"/></g></svg>';
	var trigger_btn_svg = '<svg id="svg3560" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns="http://www.w3.org/2000/svg" height="4.7796mm" width="13.57mm" version="1.1" xmlns:cc="http://creativecommons.org/ns#" xmlns:dc="http://purl.org/dc/elements/1.1/" viewBox="0 0 48.082162 16.935645"><metadata id="metadata3565"><rdf:RDF><cc:Work rdf:about=""><dc:format>image/svg+xml</dc:format><dc:type rdf:resource="http://purl.org/dc/dcmitype/StillImage"/><dc:title/></cc:Work></rdf:RDF></metadata><g id="layer1" transform="translate(0 -1035.4)"><path id="path4727" d="m42.857 1052.2c4.7071 0.4081 4.7981 0.6563 5.1414-4.9139 0.16344-2.6517 0.16699-6.1108-0.72615-8.0342-0.59471-1.2808-1.7793-2.049-3.7642-2.4662-2.5264-0.531-16.253-1.4345-26.685-1.3241-15.118 0.16-15.362 1.4769-15.855 4.1522-0.35071 1.9018-0.5016 3.5056-0.74837 5.5967-0.55261 7.0693-0.44908 7.0921 5.0452 6.5411 11.661-1.1062 25.929-0.7359 37.592 0.4484z" fill-rule="evenodd" fill="#5276cf"/></g></svg>';
	var bumper_left_svg = '<svg xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:cc="http://creativecommons.org/ns#" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" width="21.241671mm" height="8.8544388mm" viewBox="0 0 75.265762 31.373996" id="svg3447" version="1.1" inkscape:version="0.91 r13725" sodipodi:docname="l1.svg"><defs id="defs3449" /><sodipodi:namedview id="base" pagecolor="#ffffff" bordercolor="#666666" borderopacity="1.0" inkscape:pageopacity="0.0" inkscape:pageshadow="2" inkscape:zoom="1.4" inkscape:cx="-254.57869" inkscape:cy="228.81952" inkscape:document-units="px" inkscape:current-layer="layer1" showgrid="false" fit-margin-top="0" fit-margin-left="0" fit-margin-right="0" fit-margin-bottom="0" inkscape:window-width="1920" inkscape:window-height="1134" inkscape:window-x="0" inkscape:window-y="27" inkscape:window-maximized="1" /><metadata id="metadata3452"><rdf:RDF><cc:Work rdf:about=""><dc:format>image/svg+xml</dc:format><dc:type rdf:resource="http://purl.org/dc/dcmitype/StillImage" /><dc:title></dc:title></cc:Work></rdf:RDF></metadata><g inkscape:label="Layer 1" inkscape:groupmode="layer" id="layer1" transform="translate(1.5000945e-8,-1020.9882)"><path style="fill:#5276cf;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:0.99999994px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" d="m 11.026383,1051.1651 c -7.4440599,1.9144 -7.5133499,2.2466 -9.7963799,-4.4934 -1.81058997,-5.3452 -2.44278,-8.8152 4.01547,-12.116 2.74038,-1.4007 13.7365799,-5.877 38.4768299,-10.72 24.26031,-4.749 25.16653,-2.7967 26.79132,0.3418 1.15503,2.2311 1.8961,4.1561 2.94279,6.651 3.08552,8.5188 2.92609,8.5778 -6.08214,9.5501 -19.09891,2.1414 -37.95723,5.8307 -56.34789,10.7865 z" id="path4289" inkscape:connector-curvature="0" sodipodi:nodetypes="cssssccc" /></g></svg>';
	var bumper_right_svg = '<svg id="svg3447" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns="http://www.w3.org/2000/svg" height="8.8544mm" width="21.242mm" version="1.1" xmlns:cc="http://creativecommons.org/ns#" xmlns:dc="http://purl.org/dc/elements/1.1/" viewBox="0 0 75.265762 31.373996"><metadata id="metadata3452"><rdf:RDF><cc:Work rdf:about=""><dc:format>image/svg+xml</dc:format><dc:type rdf:resource="http://purl.org/dc/dcmitype/StillImage"/><dc:title/></cc:Work></rdf:RDF></metadata><g id="layer1" transform="translate(1.5001e-8 -1021)"><path id="path4715" d="m64.239 1051.2c7.4441 1.9144 7.5134 2.2466 9.7964-4.4934 1.8106-5.3452 2.4428-8.8152-4.0155-12.116-2.7404-1.4007-13.737-5.877-38.477-10.72-24.26-4.749-25.167-2.7967-26.791 0.3418-1.155 2.2311-1.8961 4.1561-2.9428 6.651-3.0855 8.5188-2.9261 8.5778 6.0822 9.5501 19.099 2.1414 37.957 5.8307 56.348 10.786z" fill-rule="evenodd" fill="#5276cf"/></g></svg>';
	var main_svg = '<svg xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:cc="http://creativecommons.org/ns#" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" width="24.603382mm" height="24.601696mm" viewBox="0 0 87.177338 87.171363" id="svg3640" version="1.1" inkscape:version="0.91 r13725" sodipodi:docname="main.svg"><defs id="defs3642" /><sodipodi:namedview id="base" pagecolor="#ffffff" bordercolor="#666666" borderopacity="1.0" inkscape:pageopacity="0.0" inkscape:pageshadow="2" inkscape:zoom="1.979899" inkscape:cx="61.113463" inkscape:cy="69.71796" inkscape:document-units="px" inkscape:current-layer="layer1" showgrid="false" fit-margin-top="0" fit-margin-left="0" fit-margin-right="0" fit-margin-bottom="0" inkscape:window-width="1920" inkscape:window-height="1134" inkscape:window-x="0" inkscape:window-y="27" inkscape:window-maximized="1" /><metadata id="metadata3645"><rdf:RDF><cc:Work rdf:about=""><dc:format>image/svg+xml</dc:format><dc:type rdf:resource="http://purl.org/dc/dcmitype/StillImage" /><dc:title></dc:title></cc:Work></rdf:RDF></metadata><g inkscape:label="Layer 1" inkscape:groupmode="layer" id="layer1" transform="translate(0,-965.19093)"><ellipse ry="43.585682" rx="43.588669" style="color:#000000;clip-rule:nonzero;display:inline;overflow:visible;visibility:visible;opacity:1;isolation:auto;mix-blend-mode:normal;color-interpolation:sRGB;color-interpolation-filters:linearRGB;solid-color:#000000;solid-opacity:1;fill:#2e2e2e;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:0.99999994;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;color-rendering:auto;image-rendering:auto;shape-rendering:auto;text-rendering:auto;enable-background:accumulate" id="ellipse4372" cx="43.588669" cy="1008.7766" /><ellipse cy="1008.7766" cx="43.588669" id="circle4239-1" style="color:#000000;clip-rule:nonzero;display:inline;overflow:visible;visibility:visible;opacity:1;isolation:auto;mix-blend-mode:normal;color-interpolation:sRGB;color-interpolation-filters:linearRGB;solid-color:#000000;solid-opacity:1;fill:#5276cf;fill-opacity:1;fill-rule:evenodd;stroke:#4364b2;stroke-width:0.99999994;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;color-rendering:auto;image-rendering:auto;shape-rendering:auto;text-rendering:auto;enable-background:accumulate" rx="40.056705" ry="40.053959" /><ellipse style="color:#000000;clip-rule:nonzero;display:inline;overflow:visible;visibility:visible;opacity:1;isolation:auto;mix-blend-mode:normal;color-interpolation:sRGB;color-interpolation-filters:linearRGB;solid-color:#000000;solid-opacity:1;fill:#434343;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:0.99999994;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;color-rendering:auto;image-rendering:auto;shape-rendering:auto;text-rendering:auto;enable-background:accumulate" id="circle4243-0" cx="43.588669" cy="1008.7766" rx="31.455994" ry="31.453836" /></g></svg>';

	var axis_setting_svg = '<svg id="svg3407" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns="http://www.w3.org/2000/svg" height="41.787mm" width="41.786mm" version="1.1" xmlns:cc="http://creativecommons.org/ns#" xmlns:dc="http://purl.org/dc/elements/1.1/" viewBox="0 0 148.0624 148.06251"><metadata id="metadata3412"><rdf:RDF><cc:Work rdf:about=""><dc:format>image/svg+xml</dc:format><dc:type rdf:resource="http://purl.org/dc/dcmitype/StillImage"/><dc:title/></cc:Work></rdf:RDF></metadata><g id="layer1" transform="translate(0 -904.3)" fill="#e6e6e6"><path id="rect4545" d="m74.031 904.3-14.469 22.156h8.0313v8.2187h12.875v-8.2187h8.0625l-14.5-22.156z"/><path id="rect4603" d="m125.94 963.86v8.0313h-8.25v12.906h8.25v8.0313l22.125-14.5-22.125-14.469z"/><path id="rect4609" d="m67.594 1022v8.25h-8.0313l14.469 22.125 14.5-22.125h-8.0625v-8.25h-12.875z"/><path id="rect4615" d="m22.156 963.86-22.156 14.47l22.156 14.5v-8.2188h8.2188v-12.906h-8.2188v-7.8438z"/><path id="path4619" style="color:#000000;text-indent:0;block-progression:tb;text-decoration-line:none;text-transform:none" d="m54.393 924.58c-15.821 5.7885-28.404 18.385-34.188 34.219h11.156c4.6667-10.175 12.865-18.361 23.031-23.031v-11.188zm39.219 0.031v11.156c10.167 4.6713 18.361 12.86 23.031 23.031h11.156c-5.7846-15.821-18.379-28.393-34.188-34.188zm-73.375 73.438c5.7899 15.816 18.348 28.403 34.156 34.188v-11.156c-10.163-4.6691-18.364-12.861-23.031-23.031h-11.125zm96.406 0c-4.6712 10.167-12.868 18.361-23.031 23.031v11.125c15.796-5.7901 28.366-18.352 34.156-34.156h-11.125z"/></g></svg>';
	// wheel
	var wheel_svg = '<svg xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:cc="http://creativecommons.org/ns#" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" width="112.08413mm" height="128.46834mm" viewBox="0 0 397.14849 455.20277" id="svg3440" version="1.1" inkscape:version="0.91 r13725" sodipodi:docname="wheel.svg"><defs id="defs3442" /><sodipodi:namedview id="base" pagecolor="#ffffff" bordercolor="#666666" borderopacity="1.0" inkscape:pageopacity="0.0" inkscape:pageshadow="2" inkscape:zoom="0.98994949" inkscape:cx="421.01508" inkscape:cy="52.510802" inkscape:document-units="px" inkscape:current-layer="g87" showgrid="false" fit-margin-top="0" fit-margin-left="0" fit-margin-right="0" fit-margin-bottom="0" inkscape:window-width="1920" inkscape:window-height="1134" inkscape:window-x="0" inkscape:window-y="27" inkscape:window-maximized="1" /><metadata id="metadata3445"><rdf:RDF><cc:Work rdf:about=""><dc:format>image/svg+xml</dc:format><dc:type rdf:resource="http://purl.org/dc/dcmitype/StillImage" /><dc:title /></cc:Work></rdf:RDF></metadata><g inkscape:label="Layer 1" inkscape:groupmode="layer" id="layer1" transform="translate(-2.3645008e-8,-597.15942)"><path inkscape:connector-curvature="0" style="fill:#4d4d4d;stroke:#6e6e6e;stroke-width:2.99125171;stroke-miterlimit:4;stroke-dasharray:none" id="path4140" d="m 307.84153,715.52552 c -4.35995,43.11849 -2.78952,86.66385 -15.90234,128.54337 -10.85452,25.86023 -13.33477,47.2976 6.91492,61.09536 7.23778,50.7442 78.38013,47.39232 82.20535,0 23.06079,-14.19054 13.49405,-42.79138 6.91492,-61.09536 -17.40045,-40.83001 -4.82581,-86.43019 -15.90235,-128.54337 -8.3177,-20.33228 -56.75348,-20.7661 -64.22927,0 z" stroke-miterlimit="4" /><path inkscape:connector-curvature="0" style="fill:#cccccc;stroke:#1a1a1a;stroke-width:2.09465766;stroke-miterlimit:4;stroke-dasharray:none" id="path4266" d="m 313.11812,724.1957 -3.84514,68.80568 c 4.64168,13.40814 62.19981,10.8172 61.83082,0 l -3.84515,-68.80568 c -4.46942,-24.00369 -52.58756,-18.95946 -54.13979,0 z" stroke-miterlimit="4" /><path inkscape:connector-curvature="0" style="fill:#353535;stroke:#2c2c2c;stroke-width:2.11880326;stroke-miterlimit:4;stroke-dasharray:none" id="path4156" d="m 304.91419,870.673 c -12.36924,67.40381 80.42804,69.69607 70.55134,0 -6.57605,-36.5947 -65.0964,-34.8253 -70.55134,0 z m 60.53812,3.9862 c 8.65841,48.24354 -57.58987,49.86644 -50.52489,0 4.7009,-26.27069 46.6394,-24.84292 50.52489,0 z" stroke-miterlimit="4" /><path inkscape:connector-curvature="0" style="fill:#e6e6e6;stroke:#969696;stroke-width:2.99125171;stroke-miterlimit:4;stroke-dasharray:none" id="path4011" d="m 106.04576,696.97906 c -11.197076,4.25792 -17.123706,8.24834 -17.123706,8.24834 l -66.18493,16.33946 1.40291,30.64619 46.54715,-7.67623 c 17.00932,-1.6438 32.551896,8.94676 38.302026,23.34506 l 2.78663,65.4778 27.6363,0 2.78663,-65.4778 c 8.0428,-15.3291 20.46247,-27.10803 38.30202,-23.34506 l 46.54716,7.67623 1.40291,-30.64619 -66.18493,-16.33946 c 0,0 -5.92627,-3.99074 -17.12371,-8.24834 -13.45408,-4.31874 -26.62772,-4.20804 -39.08982,0 z" stroke-miterlimit="4" /><path inkscape:connector-curvature="0" style="fill:#252525;stroke:#6e6e6e;stroke-width:2.99125171;stroke-miterlimit:4;stroke-dasharray:none" id="path2996" d="m 38.311064,931.09899 c -8.01574,5.05649 -22.76006,21.74743 -26.34852,58.0567 -4.1290804,35.18581 -4.8394604,60.59901 28.55878,61.68771 l 162.934726,0 c 39.19437,1.1693 30.46155,-41.5992 28.55878,-61.68771 -3.58839,-36.30927 -18.33277,-52.99983 -26.34851,-58.0567 z" stroke-miterlimit="4" /><path inkscape:connector-curvature="0" style="fill:#373737;stroke:#6e6e6e;stroke-width:2.83429575;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none" id="path3019" d="m 26.230254,979.1291 c -11.50334,14.44882 -11.98241,47.3999 -0.33519,57.1202 l 191.802226,0 c 12.10111,-12.3068 9.93082,-46.99573 -0.33518,-57.1202 z" stroke-miterlimit="4" /><path inkscape:connector-curvature="0" style="fill:#808080;stroke:#1a1a1a;stroke-width:2.14882827;stroke-linecap:square;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0" id="path4133" d="m 360.82498,854.6914 a 20.634815,21.265151 0 1 1 -41.269,0 20.634815,21.265151 0 1 1 41.269,0 z" stroke-miterlimit="4" /><path inkscape:connector-curvature="0" style="fill:#333333;stroke:#000000;stroke-width:2.11880326;stroke-linecap:square;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0" id="path4280" d="m 351.64051,761.132 a 11.444622,11.75148 0 1 1 -22.88896,0 11.444622,11.75148 0 1 1 22.88896,0 z" stroke-miterlimit="4" /><path inkscape:connector-curvature="0" style="fill:#313131;stroke:#565656;stroke-width:2.93434715;stroke-linecap:square;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0" id="path3993" d="m 125.52855,598.62659 c -68.528026,0 -124.0613764,57.81925 -124.0613764,129.13695 0,71.31265 55.5370404,129.13696 124.0613764,129.13696 68.52804,0 124.07984,-57.81926 124.07984,-129.13696 0,-71.31264 -55.55611,-129.13695 -124.07984,-129.13695 z m -1.00095,23.63932 c 10.01261,0.0734 20.238,1.32074 28.95237,3.51006 11.62203,3.80301 21.53624,8.52304 31.01135,16.15381 26.21752,19.0207 43.36275,50.36277 43.36275,85.83029 0,58.01564 -45.80548,105.05244 -102.30928,105.05244 -56.500726,0 -102.309276,-47.03364 -102.309276,-105.05244 0,-32.14848 14.06783,-60.91918 36.22336,-80.19121 11.45168,-11.11714 23.14136,-17.13322 37.3943,-21.79731 7.855846,-2.48302 17.655666,-3.5835 27.668276,-3.51006 z" stroke-miterlimit="4" /><g style="stroke-miterlimit:4;stroke-dasharray:none" id="g4127" stroke-miterlimit="4" transform="matrix(0.61498728,0,0,0.63147657,-18.171616,453.28593)"><g id="g4111"><path style="fill:#808080;stroke:#373737;stroke-width:3.56837296" inkscape:connector-curvature="0" id="rect3040" d="m 110.97,771.16 31.694,4.8776 1.3007,44.257 -32.995,0 z" /><path style="fill:#b3b3b3;stroke:#565656;stroke-width:3.4000001;stroke-linecap:butt;stroke-linejoin:miter" inkscape:connector-curvature="0" id="path3024" d="m 96.83,686.82 58.353,-5.0761 c 15.608,27.569 6.8304,64.333 -5.0761,90.545 l -53.841,-2.538 z" /></g><g id="g4115" transform="translate(97.984785,0)"><path style="fill:#808080;stroke:#373737;stroke-width:3.56837296" inkscape:connector-curvature="0" id="path4117" d="m 110.97,771.16 31.694,4.8776 1.3007,44.257 -32.995,0 z" /><path style="fill:#b3b3b3;stroke:#565656;stroke-width:3.4000001;stroke-linecap:butt;stroke-linejoin:miter" inkscape:connector-curvature="0" id="path4119" d="m 96.83,686.82 58.353,-5.0761 c 15.608,27.569 6.8304,64.333 -5.0761,90.545 l -53.841,-2.538 z" /></g><g id="g4121" transform="translate(195.96959,0)"><path style="fill:#808080;stroke:#373737;stroke-width:3.56837296" inkscape:connector-curvature="0" id="path4123" d="m 110.97,771.16 31.694,4.8776 1.3007,44.257 -32.995,0 z" /><path style="fill:#b3b3b3;stroke:#565656;stroke-width:3.4000001;stroke-linecap:butt;stroke-linejoin:miter" inkscape:connector-curvature="0" id="path4125" d="m 96.83,686.82 58.353,-5.0761 c 15.608,27.569 6.8304,64.333 -5.0761,90.545 l -53.841,-2.538 z" /></g></g><g style="fill:#666666;stroke:#969696;stroke-width:3.99777174;stroke-miterlimit:4;stroke-dasharray:none" id="g4051" transform="translate(-42.878584,98.083591)" stroke-miterlimit="4"><g id="g4437" transform="matrix(0.74686368,0,0,0.74686368,-73.374214,285.30447)"><path inkscape:connector-curvature="0" id="rect4348" style="color:#000000;text-indent:0;text-transform:none;block-progression:tb;fill:#ffffff" d="m 567.31,584.22 0,42.25 0,3.4062 0,42.25 3.375,0 0,-42.25 27.062,0 0,42.25 3.375,0 0,-42.25 27.062,0 0,42.25 3.375,0 0,-42.25 27.062,0 0,42.25 3.4062,0 0,-43.969 0,-1.6875 -1.7188,0 -28.75,0 0,-42.25 -3.375,0 0,42.25 -27.062,0 0,-42.25 -3.375,0 0,42.25 -27.062,0 0,-42.25 -3.375,0 z" /><g style="fill:#a02c2c;stroke:#ffffff;stroke-width:3.4000001;stroke-linecap:square" id="g87" /></g></g></g></svg>';
	var wheel_btn = '<svg xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:cc="http://creativecommons.org/ns#" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" width="5.4777083mm" height="5.5003009mm" viewBox="0 0 19.409203 19.489255" id="svg3402" version="1.1" inkscape:version="0.91 r13725" sodipodi:docname="wheel_btn.svg"><defs id="defs3404" /><sodipodi:namedview id="base" pagecolor="#ffffff" bordercolor="#666666" borderopacity="1.0" inkscape:pageopacity="0.0" inkscape:pageshadow="2" inkscape:zoom="22.4" inkscape:cx="4.7324003" inkscape:cy="15.245372" inkscape:document-units="px" inkscape:current-layer="layer1" showgrid="false" fit-margin-top="0" fit-margin-left="0" fit-margin-right="0" fit-margin-bottom="0" inkscape:window-width="1920" inkscape:window-height="1134" inkscape:window-x="0" inkscape:window-y="27" inkscape:window-maximized="1" /><metadata id="metadata3407"><rdf:RDF><cc:Work rdf:about=""><dc:format>image/svg+xml</dc:format><dc:type rdf:resource="http://purl.org/dc/dcmitype/StillImage" /><dc:title></dc:title></cc:Work></rdf:RDF></metadata><g inkscape:label="Layer 1" inkscape:groupmode="layer" id="layer1" transform="translate(8.5754969e-8,-1032.873)"><path inkscape:connector-curvature="0" style="fill:#5276cf;stroke:#000000;stroke-width:3.4000001;stroke-linecap:square;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;fill-opacity:1" id="path4272" d="m 17.709101,1042.6176 a 8.0046,8.0046 0 1 1 -16.0089998,0 8.0046,8.0046 0 1 1 16.0089998,0 z" stroke-miterlimit="4" /></g></svg>';
	var wheel_right_svg = '<svg id="svg3400" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns="http://www.w3.org/2000/svg" height="10.507mm" width="15.1mm" version="1.1" xmlns:cc="http://creativecommons.org/ns#" xmlns:dc="http://purl.org/dc/elements/1.1/" viewBox="0 0 53.504016 37.228838"><metadata id="metadata3405"><rdf:RDF><cc:Work rdf:about=""><dc:format>image/svg+xml</dc:format><dc:type rdf:resource="http://purl.org/dc/dcmitype/StillImage"/><dc:title/></cc:Work></rdf:RDF></metadata><g id="layer1" transform="translate(-2.847e-7 -1015.1)"><path id="path4049" d="m26.584 1016.1c-12.631 0-23.15 9.858-25.478 22.922l50.705 12.18c0.47921-2.1565 0.73023-4.4099 0.73023-6.7204 0-15.677-11.621-28.382-25.957-28.382z" stroke="#5276cf" stroke-linecap="square" stroke-width="1.9247" fill="#666"/></g></svg>';
	var wheel_left_svg = '<svg id="svg3400" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns="http://www.w3.org/2000/svg" height="10.507mm" width="15.1mm" version="1.1" xmlns:cc="http://creativecommons.org/ns#" xmlns:dc="http://purl.org/dc/elements/1.1/" viewBox="0 0 53.504016 37.228838"><metadata id="metadata3405"><rdf:RDF><cc:Work rdf:about=""><dc:format>image/svg+xml</dc:format><dc:type rdf:resource="http://purl.org/dc/dcmitype/StillImage"/><dc:title/></cc:Work></rdf:RDF></metadata><g id="layer1" transform="translate(-2.847e-7 -1015.1)"><path id="path4033" d="m26.92 1016.1c-14.337 0-25.957 12.707-25.957 28.382 0 2.3225 0.26742 4.5784 0.74876 6.7386l50.681-12.18c-2.321-13.072-12.841-22.944-25.476-22.944z" stroke="#5276cf" stroke-linecap="square" stroke-width="1.9247" fill="#666"/></g></svg>';

	var pedal_svg = '<svg id="svg3386" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns="http://www.w3.org/2000/svg" height="12.859mm" width="5.2917mm" version="1.1" xmlns:cc="http://creativecommons.org/ns#" xmlns:dc="http://purl.org/dc/elements/1.1/" viewBox="0 0 18.749999 45.562501"><metadata id="metadata3391"><rdf:RDF><cc:Work rdf:about=""><dc:format>image/svg+xml</dc:format><dc:type rdf:resource="http://purl.org/dc/dcmitype/StillImage"/><dc:title/></cc:Work></rdf:RDF></metadata><g id="layer1" transform="translate(0 -1006.8)"><path id="rect4575" d="m9.3125 1006.8-9.3125 14.25h5.3125v17.094h-5.1875l9.3125 14.219 9.3125-14.219h-5.1562v-17.094h5.0312l-9.3125-14.25z" fill="#e6e6e6"/></g></svg>';
	var wheel_settings_svg = '<svg id="svg3458" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns="http://www.w3.org/2000/svg" height="50.447mm" width="83.899mm" version="1.1" xmlns:cc="http://creativecommons.org/ns#" xmlns:dc="http://purl.org/dc/elements/1.1/" viewBox="0 0 297.28131 178.75"><metadata id="metadata3463"><rdf:RDF><cc:Work rdf:about=""><dc:format>image/svg+xml</dc:format><dc:type rdf:resource="http://purl.org/dc/dcmitype/StillImage"/><dc:title/></cc:Work></rdf:RDF></metadata><g id="layer1" transform="translate(0 -873.61)" fill="#e6e6e6"><path id="path4535" style="color:#000000;text-indent:0;block-progression:tb;text-decoration-line:none;text-transform:none" d="m33.875 873.61-18.5 8.8125 5.0626 3.0625c-12.899 22.78-20.438 49.17-20.438 77.44 0 28.284 7.5315 54.691 20.438 77.469l-5.0626 3.0625 18.5 8.8125 0.6563-20.469-5.531 3.3c-12.002-21.2-18.937-45.8-18.937-72.18 0-26.362 6.9415-50.99 18.937-72.188l5.5313 3.3438-0.6563-20.469z"/><path id="path4551" style="color:#000000;text-indent:0;block-progression:tb;text-decoration-line:none;text-transform:none" d="m263.38 873.71-0.6562 20.469 5.5312-3.3438c11.996 21.198 18.969 45.825 18.969 72.188 0 26.371-6.9672 51.011-18.969 72.219l-5.5312-3.3437 0.6562 20.469 18.5-8.8125-5.0312-3.0625c12.906-22.778 20.438-49.184 20.438-77.469 0-28.275-7.5391-54.665-20.438-77.438l5.0312-3.0625-18.5-8.8125z"/></g></svg>';
	var gearbox_hor_svg = '<svg id="svg3378" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns="http://www.w3.org/2000/svg" height="2.9016mm" width="9.2516mm" version="1.1" xmlns:cc="http://creativecommons.org/ns#" xmlns:dc="http://purl.org/dc/elements/1.1/" viewBox="0 0 32.781198 10.281199"><metadata id="metadata3383"><rdf:RDF><cc:Work rdf:about=""><dc:format>image/svg+xml</dc:format><dc:type rdf:resource="http://purl.org/dc/dcmitype/StillImage"/><dc:title/></cc:Work></rdf:RDF></metadata><g id="layer1" transform="translate(0 -1042.1)"><path id="rect4585" d="m32.781 1047.2-7.875-5.125v2.8437h-17.031v-2.8437l-7.875 5.1 7.875 5.1562v-2.8437h17.031v2.8437z" fill="#e6e6e6"/></g></svg>';
	var gearbox_vert_svg = '<svg id="svg3378" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns="http://www.w3.org/2000/svg" height="9.2516mm" width="2.9016mm" version="1.1" xmlns:cc="http://creativecommons.org/ns#" xmlns:dc="http://purl.org/dc/elements/1.1/" viewBox="0 0 10.281248 32.7812"><metadata id="metadata3383"><rdf:RDF><cc:Work rdf:about=""><dc:format>image/svg+xml</dc:format><dc:type rdf:resource="http://purl.org/dc/dcmitype/StillImage"/><dc:title/></cc:Work></rdf:RDF></metadata><g id="layer1" transform="translate(0 -1019.6)"><path id="rect4585" d="m5.125 1019.6-5.125 7.9h2.8437v17.031h-2.8437l5.125 7.875 5.1562-7.875h-2.8438v-17.031h2.8438z" fill="#e6e6e6"/></g></svg>';

	var _svg = [];
	var _selected_gamepad_num = -1;
	var _selected_btn = null;
	var _mode = VIEWER_MODE;
	var _main_element = null;
	var _device_elem = null;
	var _gamepad_elem = null;
	var _type_wheel_elem = null;
	var _type_pad_elem = null;
	var _device_id_label = null;
	var _tmp_gamepads = [];
	var _elems = [];
	var _axis_elems = [];
	var _axis_settings_elems = [];
	var _is_pad_mode = true;

	var _axes_prev_val = {};
	_axes_prev_val[m_input.GMPD_AXIS_0] = -2;
	_axes_prev_val[m_input.GMPD_AXIS_1] = -2;
	_axes_prev_val[m_input.GMPD_AXIS_2] = -2;
	_axes_prev_val[m_input.GMPD_AXIS_3] = -2;
	_axes_prev_val[m_input.GMPD_AXIS_4] = -2;
	_axes_prev_val[m_input.GMPD_AXIS_5] = -2;
	_axes_prev_val[m_input.GMPD_AXIS_6] = -2;
	_axes_prev_val[m_input.GMPD_AXIS_7] = -2;
	_axes_prev_val[m_input.GMPD_AXIS_8] = -2;
	_axes_prev_val[m_input.GMPD_AXIS_9] = -2;
	_axes_prev_val[m_input.GMPD_AXIS_10] = -2;
	_axes_prev_val[m_input.GMPD_AXIS_11] = -2;


	/**
	 * Show a gamepad configurator.
	 * @method module:gp_conf.show
	 */
	exports.show = function() {

	    // creating interface elements
	    var main_div = document.createElement("div");
	    _main_element = main_div;
	    main_div.style.cssText =
	        "position: absolute;" +
	        "width: 720px;" +
	        "height: 750px;" +
	        "top: 50%;" +
	        "left: 50%;" +
	        "-moz-transform: translateY(-50%) translateX(-50%);" +
	        "-ms-transform: translateY(-50%) translateX(-50%);" +
	        "-webkit-transform: translateY(-50%) translateX(-50%);" +
	        "transform: translateY(-50%) translateX(-50%);" +
	        "background-color: black;" +
	        "border: 4px solid white;" +
	        "border-radius: 35px;" +
	        "box-shadow: 0px 0px 20px 0px rgba(50, 50, 50, 1);";
	    m_cont.insert_to_container(main_div, "LAST");

	    create_pad_interface(main_div);

	    //creating another interface elements
	    var gamepad_data_cnt = document.createElement("div");
	    gamepad_data_cnt.style.cssText =
	        "position: absolute;" +
	        "width: 637px;" +
	        "top: 0px;" +
	        "font-family: sans-serif;" +
	        "text-align: center;" +
	        "margin-top: 40px;" +
	        "-moz-transform: translateX(-50%);" +
	        "-ms-transform: translateX(-50%);" +
	        "-webkit-transform: translateX(-50%);" +
	        "transform: translateX(-50%);" +
	        "left: 50%;";

	    var main_label = document.createElement("div");
	    main_label.innerHTML = MAIN_DEVICE_CAPTION;
	    main_label.style.cssText =
	        "color: #fff;" +
	        "display: inline-block;";
	    gamepad_data_cnt.appendChild(main_label);

	    for (var j = 0; j < 4; j++) {
	        var sensors = create_sensors(j);

	        var logic_func = function() {
	            return true;
	        };
	        var sensor_cb = function(obj, id, pulse) {
	            if (id != _selected_gamepad_num)
	                return;

	            for (var i = 0; i < _elems.length; i++) {
	                var elem = _elems[i];
	                set_btn_state(elem, m_ctrl.get_sensor_value(obj, id, i), i);
	            }
	        };
	        m_ctrl.create_sensor_manifold(null, j, m_ctrl.CT_CONTINUOUS,
	                sensors, logic_func, sensor_cb);
	    }

	    var gamepads = get_gamepads();
	    if (gamepads.length > 0)
	        _selected_gamepad_num = 0;
	    var gamepads_data = [];
	    var gamepads_data_container = document.createElement("div");
	    gamepads_data_container.style.cssText =
	        "margin-top: 20px;";
	    for (var i = 0; i < 4; i++) {
	        var gamepad_data_elem = create_device_icon_elem(i);
	        if (i == _selected_gamepad_num) {
	            gamepad_data_elem.style.backgroundColor = "green";
	            _gamepad_elem = gamepad_data_elem;
	        }
	        set_gmpd_config(i);
	        gamepads_data_container.appendChild(gamepad_data_elem);
	        gamepad_data_elem.setAttribute("data-device_type", "PAD");
	        gamepads_data.push(gamepad_data_elem);

	        var click_cb = function(e) {
	            var gamepads = get_gamepads();
	            var elem = e.target;
	            for (var j = 0; j < gamepads.length; j++) {
	                if (gamepads_data[j] == elem) {
	                    _selected_gamepad_num = j;
	                    _gamepad_elem = elem;
	                    set_gmpd_config(_selected_gamepad_num);
	                    change_device(elem.getAttribute("data-device_type"));
	                }
	            }
	        };

	        m_input.add_click_listener(gamepad_data_elem, click_cb);
	    }
	    gamepad_data_cnt.appendChild(gamepads_data_container);

	    _device_id_label = document.createElement("label");
	    _device_id_label.style.cssText =
	        "position: relative;" +
	        "display: block;" +
	        "color: white;";
	    gamepad_data_cnt.appendChild(_device_id_label);

	    var type_and_action_container = document.createElement("div");
	    type_and_action_container.style.cssText =
	        "margin-top: 20px;";

	    var select_pad_elem = append_type_elem(type_and_action_container, "Pad");
	    var select_wheel_elem = append_type_elem(type_and_action_container, "Wheel");
	    select_pad_elem.setAttribute("checked", "true");

	    select_pad_elem.onchange = function() {
	        change_device("PAD");
	        if (_gamepad_elem)
	            _gamepad_elem.setAttribute("data-device_type", "PAD");
	    };
	    select_wheel_elem.onchange = function() {
	        change_device("WHEEL");
	        if (_gamepad_elem)
	            _gamepad_elem.setAttribute("data-device_type", "WHEEL");
	    };
	    select_pad_elem.setAttribute("id", "test");
	    _type_pad_elem = select_pad_elem;
	    _type_wheel_elem = select_wheel_elem;

	    var action_label = document.createElement("label");
	    action_label.style.cssText +=
	        "color: #fff;" +
	        "display: block;";
	    type_and_action_container.appendChild(action_label);
	    action_label.textContent = SELECT_BTN_CAPTION;
	    action_label.setAttribute("id", "action_label");

	    gamepad_data_cnt.appendChild(type_and_action_container);

	    main_div.appendChild(gamepad_data_cnt);

	    var e_s = m_ctrl.create_elapsed_sensor();

	    function e_sensor_cb(obj, id, pulse) {
	        var gamepads = get_gamepads();
	        var num = gamepads.length;
	        if (_selected_gamepad_num == -1 && gamepads.length) {
	            _selected_gamepad_num = gamepads[0].index;
	            _gamepad_elem = gamepads_data[_selected_gamepad_num];
	        }
	        for (var i = 0; i < gamepads_data.length; i++)
	            if (i < num) {
	                gamepads_data[i].textContent = gamepads[i].index;
	                if (gamepads_data[i] == _gamepad_elem) {
	                    gamepads_data[i].style.backgroundColor = "green";
	                    _device_id_label.textContent = "Selected device: "
	                            + gamepads[i].index + ". Data: " + gamepads[i].id;
	                } else
	                    gamepads_data[i].style.backgroundColor = "blue";
	            } else {
	                gamepads_data[i].style.backgroundColor = "black";
	            }
	        if (!num) {
	            _selected_gamepad_num = -1;
	            _device_id_label.textContent = "";
	        }
	    }

	    m_ctrl.create_sensor_manifold(null, "UPDATE_GAMEPAD_DATA", m_ctrl.CT_CONTINUOUS,
	            [e_s], logic_func, e_sensor_cb);


	    for (var j = 0; j < 4; j++) {
	        var sensors = create_axis_sensors(j);

	        var axis_logic_func = function() {
	            return true;
	        };
	        var sensor_cb = function(obj, id, pulse) {
	            if (id != "AXES" + _selected_gamepad_num)
	                return;

	            for (var i = 0; i < _axis_elems.length; i=i+2) {
	                var elem = _axis_elems[i];
	                set_axis_state(elem, obj, id, i);
	            }
	            if (_is_pad_mode)
	                for (var i = 0; i < 12; i=i+2)
	                    change_dual_axis_setting_color(obj, id, i);
	            else
	                for (var i = 0; i < 12; i++)
	                    change_single_axis_setting_color(obj, id, i);
	        };
	        m_ctrl.create_sensor_manifold(null, "AXES" + j, m_ctrl.CT_CONTINUOUS,
	                sensors, axis_logic_func, sensor_cb);
	    }

	    zoom_main_div();
	    window.addEventListener("resize", zoom_main_div);
	};

	function set_axis_state(elem, obj, id, num) {
	    var x = m_ctrl.get_sensor_value(obj, id, num) * AXIS_STEP;
	    var y = m_ctrl.get_sensor_value(obj, id, num + 1) * AXIS_STEP;
	    elem.style.transform = "translate3d(" + x + "px, " + y + "px, 0px) rotate(" 
	                + 0 + "rad)";
	}

	function change_dual_axis_setting_color(obj, id, num) {

	    if (num + 1 > _axis_settings_elems.length * 2)
	        return;

	    var x = m_ctrl.get_sensor_value(obj, id, num);
	    var y = m_ctrl.get_sensor_value(obj, id, num + 1);

	    if (_axes_prev_val[num] > -2) {
	        var delta_x = x - _axes_prev_val[num];
	        var delta_y = y - _axes_prev_val[num + 1];
	        var elem = _axis_settings_elems[Math.floor(num / 2)];
	        var svg_id = elem.getAttribute("data-svgid");
	        if (_mode == VIEWER_MODE) {
	            if (delta_x || delta_y)
	                elem.style.backgroundImage = SVG_BASE64 + btoa(_svg[svg_id].replace(GREY_COLOR,
	                        GREEN_COLOR))  + "')";
	            else
	                elem.style.backgroundImage = SVG_BASE64 + btoa(_svg[svg_id])  + "')";
	        } else if (_mode == AXIS_EDIT_MODE) {
	            var moved_axis = m_input.get_moved_gmpd_axis(_selected_gamepad_num);
	            if (moved_axis >= 0) {
	                if (moved_axis % 2 != 0)
	                    moved_axis--;
	                _mode = VIEWER_MODE;
	                elem.style.backgroundImage = SVG_BASE64 + btoa(_svg[svg_id])  + "')";
	                var sel_axis = parseFloat(_selected_btn.getAttribute("data-key"));
	                m_input.set_gamepad_key(_selected_gamepad_num, sel_axis, moved_axis);
	                m_input.set_gamepad_key(_selected_gamepad_num, sel_axis + 1, moved_axis + 1);
	                _selected_btn = null;
	                document.getElementById("action_label").textContent =
	                            SELECT_BTN_CAPTION;
	            }
	        }
	    }

	    _axes_prev_val[num] = x;
	    _axes_prev_val[num + 1] = y;
	}

	function change_single_axis_setting_color(obj, id, num) {
	    if (num >= _axis_settings_elems.length)
	        return;

	    var val = m_ctrl.get_sensor_value(obj, id, num);
	    if (_axes_prev_val[num] > -2) {
	        var delta_val = val - _axes_prev_val[num];
	        var elem = _axis_settings_elems[num];
	        var svg_id = elem.getAttribute("data-svgid");
	        if (_mode == VIEWER_MODE) {
	            if (delta_val)
	                elem.style.backgroundImage = SVG_BASE64 + btoa(_svg[svg_id].replace(GREY_COLOR,
	                        GREEN_COLOR))  + "')";
	            else
	                elem.style.backgroundImage = SVG_BASE64 + btoa(_svg[svg_id])  + "')";
	        } else if (_mode == AXIS_EDIT_MODE) {
	            var moved_axis = m_input.get_moved_gmpd_axis(_selected_gamepad_num);
	            if (moved_axis >= 0) {
	                _mode = VIEWER_MODE;
	                elem.style.backgroundImage = SVG_BASE64 + btoa(_svg[svg_id])  + "')";
	                var sel_axis = parseFloat(_selected_btn.getAttribute("data-key"));
	                m_input.set_gamepad_key(_selected_gamepad_num, sel_axis, moved_axis);
	                _selected_btn = null;
	                document.getElementById("action_label").textContent =
	                            SELECT_BTN_CAPTION;
	            }
	        }
	    }

	    _axes_prev_val[num] = val;
	}

	function set_btn_state(elem, pressed, num) {
	    if (_mode == VIEWER_MODE) {
	        if (pressed && elem.getAttribute("data-colorstate") == "B") {
	            var svg = _svg[num];
	            elem.style.backgroundImage = SVG_BASE64 + btoa(svg.replace(BLUE_COLOR_REGEXP,
	                    GREEN_COLOR))  + "')";
	            elem.setAttribute("data-colorstate", "G");
	        }
	        if (!pressed && elem.getAttribute("data-colorstate") != "B") {
	            var svg = _svg[num];
	            elem.style.backgroundImage = SVG_BASE64 + btoa(svg)  + "')";
	            elem.setAttribute("data-colorstate", "B");
	        }
	    } else {
	        var pressed_btn_key = m_input.get_pressed_gmpd_btn(_selected_gamepad_num);
	        if (pressed_btn_key >= 0 && _selected_btn && _mode == BTN_EDIT_MODE) {
	            var red_btn_val = _selected_btn.getAttribute("data-key");
	            m_input.set_gamepad_key(_selected_gamepad_num, red_btn_val,
	                    pressed_btn_key);
	            save_config_to_local_mem(red_btn_val, pressed_btn_key);
	            _selected_btn = null;
	            document.getElementById("action_label").textContent = SELECT_BTN_CAPTION;
	            _mode = VIEWER_MODE;
	        }
	    }
	}
	/**
	 * Hide a gamepad configurator.
	 * @method module:gp_conf.hide
	 */
	exports.hide = function() {
	    _mode = VIEWER_MODE;
	    _selected_gamepad_num = -1;
	    _gamepad_elem = null;
	    _selected_btn = null;
	    _type_wheel_elem = null;
	    _type_pad_elem = null;
	    _axis_elems.length = 0;
	    _elems.length = 0;
	    _axis_settings_elems.length = 0;

	    var main_container = m_cont.get_container();
	    main_container.removeChild(_main_element);
	    _main_element = null;
	    m_ctrl.remove_sensor_manifold(null, "UPDATE_GAMEPAD_DATA");
	    for (var i = 0; i < 4; i++) {
	        m_ctrl.remove_sensor_manifold(null, i);
	        m_ctrl.remove_sensor_manifold(null, "AXES" + i);
	    }

	    window.removeEventListener("resize", zoom_main_div);
	};

	function get_gamepads() {
	    _tmp_gamepads.length = 0;
	    var gamepads = navigator.getGamepads ? navigator.getGamepads() :
	            (navigator.webkitGetGamepads ? navigator.webkitGetGamepads : []);
	    for (var i = 0; i < gamepads.length; i++)
	        if (gamepads[i])
	            _tmp_gamepads.push(gamepads[i]);
	    return _tmp_gamepads;
	}

	function save_config_to_local_mem(red_btn_val, pressed_btn_key) {
	    var gmpd_stngs_str = m_storage.get(_selected_gamepad_num + "_gmpd_stngs", "b4w") || "{}";
	    var gmpd_stngs = JSON.parse(gmpd_stngs_str);
	    gmpd_stngs[red_btn_val] = pressed_btn_key;
	    m_storage.set(_selected_gamepad_num + "_gmpd_stngs", JSON.stringify(gmpd_stngs), "b4w");
	}

	function init_gmpd_stngs(gamepad_id) {
	    var settings = JSON.stringify(GMPD_DFLT_STNGS);
	    m_storage.set(gamepad_id + "_gmpd_stngs", settings, "b4w");
	}

	function apply_settings(settings, gamepad_id) {
	    for (var button in settings)
	        m_input.set_gamepad_key(gamepad_id, button,
	                    settings[button]);
	}

	function set_gmpd_config(gamepad_id) {
	    var gmpd_stngs = m_storage.get(gamepad_id + "_gmpd_stngs", "b4w");
	    if (gmpd_stngs) {
	        apply_settings(JSON.parse(gmpd_stngs), gamepad_id);
	    } else {
	        init_gmpd_stngs(gamepad_id);
	    }
	}

	/**
	 * Update gamepad device config without showing configurator
	 * @method module:gp_conf.update
	 */
	exports.update = function() {
	   for(var i = 0; i < 4; i++)
	       set_gmpd_config(i);
	};

	function create_pad_interface(main_div) {

	    _is_pad_mode = true;

	    var gamepad_elem = document.createElement("div");
	    var dpad_group = document.createElement("div");
	    var dpad_up_elem = document.createElement("div");
	    var dpad_right_elem = document.createElement("div");
	    var dpad_down_elem = document.createElement("div");
	    var dpad_left_elem = document.createElement("div");
	    var face_group = document.createElement("div");
	    var face_up_elem = document.createElement("div");
	    var face_right_elem = document.createElement("div");
	    var face_down_elem = document.createElement("div");
	    var face_left_elem = document.createElement("div");
	    var analog_left = document.createElement("div");
	    var analog_right = document.createElement("div");
	    var select_btn = document.createElement("div");
	    var start_btn = document.createElement("div");
	    var left_bumper = document.createElement("div");
	    var right_bumper = document.createElement("div");
	    var right_trigger = document.createElement("div");
	    var left_trigger = document.createElement("div");
	    var main_btn = document.createElement("div");

	    var left_axis_sittings = document.createElement("div");
	    var right_axis_sittings = document.createElement("div");

	    _device_elem = gamepad_elem;

	    //setting styles

	    gamepad_elem.style.cssText =
	        "position: absolute;" +
	        "height: auto;" +
	        "background-image: " + SVG_BASE64 + btoa(gamepad_svg) + "');" +
	        "width: 637px;" +
	        "height: 455px;" +
	        "background-size: 100% 100%;" +
	        "left: 50%;" +
	        "margin-bottom: 40px;" +
	        "-moz-transform: translateX(-50%);" +
	        "-ms-transform: translateX(-50%);" +
	        "-webkit-transform: translateX(-50%);" +
	        "bottom: 0px;";
	    
	    dpad_group.style.cssText =
	        "background-image: " + SVG_BASE64 + btoa(dpad_svg) + "');" +
	        "position: absolute;" + 
	        "top: 47px;" +
	        "left: 65px;" +
	        "width: 135px;" +
	        "height: 135px;";

	    dpad_up_elem.style.cssText =
	        "background-image: " + SVG_BASE64 + btoa(dpad_up_svg) + "');" +
	        "width: 36px;" +
	        "height: 38px;" +
	        "left: 49px;" +
	        "top: 8px;" +
	        "position: absolute;";

	    dpad_right_elem.style.cssText =
	        "background-image: " + SVG_BASE64 + btoa(dpad_right_svg) + "');" +
	        "width: 38px;" +
	        "height: 36px;" +
	        "top: 47px;" +
	        "left: 84px;" +
	        "position: absolute;";

	    dpad_down_elem.style.cssText =
	        "background-image: " + SVG_BASE64 + btoa(dpad_down_svg) + "');" +
	        "width: 36px;" +
	        "height: 38px;" +
	        "bottom: 11px;" +
	        "left: 51px;" +
	        "position: absolute;";

	    dpad_left_elem.style.cssText =
	        "background-image: " + SVG_BASE64 + btoa(dpad_left_svg) + "');" +
	        "width: 38px;" +
	        "height: 36px;" +
	        "top: 47px;" +
	        "left: 13px;" +
	        "position: absolute;";

	    face_group.style.cssText =
	        "position: absolute;" +
	        "top: 55px;" +
	        "left: 434px;" +
	        "width: 150px;" +
	        "height: 150px;";
	    
	    face_up_elem.style.cssText =
	        "background-image: " + SVG_BASE64 + btoa(face_btn_svg) + "');" +
	        "width: 50px;" +
	        "height: 50px;" +
	        "left: 53px;" +
	        "top: 0px;" +
	        "position: absolute;";

	    face_right_elem.style.cssText =
	        "background-image: " + SVG_BASE64 + btoa(face_btn_svg) + "');" +
	        "width: 50px;" +
	        "height: 50px;" +
	        "left: 107px;" +
	        "top: 51px;" +
	        "position: absolute;";

	    face_down_elem.style.cssText =
	        "background-image: " + SVG_BASE64 + btoa(face_btn_svg) + "');" +
	        "width: 50px;" +
	        "height: 50px;" +
	        "left: 53px;" +
	        "bottom: 0px;" +
	        "position: absolute;";

	    face_left_elem.style.cssText =
	        "background-image: " + SVG_BASE64 + btoa(face_btn_svg) + "');" +
	        "width: 50px;" +
	        "height: 50px;" +
	        "top: 51px;" +
	        "position: absolute;";

	    analog_left.style.cssText =
	        "background-image: " + SVG_BASE64 + btoa(analog_btn_svg) + "');" +
	        "position: absolute;" +
	        "top: 222px;" +
	        "left: 183px;" +
	        "width: 85px;" +
	        "height: 85px;";

	    analog_right.style.cssText =
	        "background-image: " + SVG_BASE64 + btoa(analog_btn_svg) + "');" +
	        "position: absolute;" +
	        "top: 223px;" +
	        "left: 376px;" +
	        "width: 85px;" +
	        "height: 85px;";

	    select_btn.style.cssText =
	        "background-image: " + SVG_BASE64 + btoa(start_btn_svg) + "');" +
	        "position: absolute;" +
	        "top: 76px;" +
	        "left: 227px;" +
	        "width: 34px;" +
	        "height: 34px;";

	    start_btn.style.cssText =
	        "background-image: " + SVG_BASE64 + btoa(start_btn_svg) + "');" +
	        "position: absolute;" +
	        "top: 76px;" +
	        "left: 376px;" +
	        "width: 34px;" +
	        "height: 34px;";

	    left_bumper.style.cssText =
	        "background-image: " + SVG_BASE64 + btoa(bumper_left_svg) + "');" +
	        "position: absolute;" +
	        "top: 4px;" +
	        "left: 78px;" +
	        "width: 79px;" +
	        "height: 33px;";

	    right_bumper.style.cssText =
	        "background-image: " + SVG_BASE64 + btoa(bumper_right_svg) + "');" +
	        "position: absolute;" +
	        "top: 4px;" +
	        "left: 477px;" +
	        "width: 79px;" +
	        "height: 33px;";

	    right_trigger.style.cssText =
	        "background-image: " + SVG_BASE64 + btoa(trigger_btn_svg) + "');" +
	        "position: absolute;" +
	        "top: -7px;" +
	        "left: 425px;" +
	        "width: 50px;" +
	        "height: 17px;";

	    left_trigger.style.cssText =
	        "background-image: " + SVG_BASE64 + btoa(trigger_btn_svg) + "');" +
	        "position: absolute;" +
	        "top: -7px;" +
	        "left: 164px;" +
	        "width: 50px;" +
	        "height: 17px;";

	    main_btn.style.cssText =
	        "background-image: " + SVG_BASE64 + btoa(main_svg) + "');" +
	        "position: absolute;" +
	        "top: 68px;" +
	        "left: 274px;" +
	        "width: 92px;" +
	        "height: 92px;";

	    left_axis_sittings.style.cssText =
	        "background-image: " + SVG_BASE64 + btoa(axis_setting_svg) + "');" +
	        "position: absolute;" +
	        "top: 186px;" +
	        "left: 148px;" +
	        "width: 157px;" +
	        "height: 157px;";

	    right_axis_sittings.style.cssText =
	        "background-image: " + SVG_BASE64 + btoa(axis_setting_svg) + "');" +
	        "position: absolute;" +
	        "top: 187px;" +
	        "left: 339px;" +
	        "width: 157px;" +
	        "height: 157px;";

	    //settings parents
	    gamepad_elem.appendChild(left_axis_sittings);
	    gamepad_elem.appendChild(right_axis_sittings);

	    dpad_group.appendChild(dpad_up_elem);
	    dpad_group.appendChild(dpad_right_elem);
	    dpad_group.appendChild(dpad_down_elem);
	    dpad_group.appendChild(dpad_left_elem);
	    gamepad_elem.appendChild(dpad_group);
	    face_group.appendChild(face_up_elem);
	    face_group.appendChild(face_right_elem);
	    face_group.appendChild(face_down_elem);
	    face_group.appendChild(face_left_elem);
	    gamepad_elem.appendChild(face_group);
	    gamepad_elem.appendChild(analog_left);
	    gamepad_elem.appendChild(analog_right);
	    gamepad_elem.appendChild(select_btn);
	    gamepad_elem.appendChild(start_btn);
	    gamepad_elem.appendChild(left_bumper);
	    gamepad_elem.appendChild(right_bumper);
	    gamepad_elem.appendChild(right_trigger);
	    main_div.appendChild(gamepad_elem);
	    gamepad_elem.appendChild(left_trigger);
	    gamepad_elem.appendChild(main_btn);

	    _elems.length = 0;
	    _svg.length = 0;
	    _axis_elems.length = 0;
	    _axis_settings_elems.length = 0;
	    _elems.push(face_down_elem, face_right_elem, face_left_elem, face_up_elem,
	            left_bumper, right_bumper, left_trigger, right_trigger,
	            select_btn, start_btn, analog_left, analog_right,
	            dpad_up_elem, dpad_down_elem, dpad_left_elem, dpad_right_elem,
	            main_btn);
	    _svg.push(face_btn_svg, face_btn_svg, face_btn_svg, face_btn_svg,
	        bumper_left_svg, bumper_right_svg, trigger_btn_svg, trigger_btn_svg,
	        start_btn_svg, start_btn_svg, analog_btn_svg, analog_btn_svg, 
	        dpad_up_svg, dpad_down_svg, dpad_left_svg, dpad_right_svg, main_svg);
	    _axis_elems.push(analog_left, analog_left, analog_right, analog_right);
	    _axis_settings_elems.push(left_axis_sittings, right_axis_sittings);

	    //setting attributes
	    for (var i = 0; i < _elems.length; i++) {
	        _elems[i].setAttribute("id", "pad_btn_" + i);
	        _elems[i].setAttribute("data-colorstate", "B");
	        _elems[i].setAttribute("data-key", i);
	        _elems[i].setAttribute("data-svgid", i);
	    }
	    left_axis_sittings.setAttribute("id", "pad_left_axis");
	    left_axis_sittings.setAttribute("data-colorstate", "GR");
	    left_axis_sittings.setAttribute("data-key", m_input.GMPD_AXIS_0);
	    left_axis_sittings.setAttribute("data-svgid", _svg.length);
	    right_axis_sittings.setAttribute("id", "pad_right_axis");
	    right_axis_sittings.setAttribute("data-colorstate", "GR");
	    right_axis_sittings.setAttribute("data-key", m_input.GMPD_AXIS_2);
	    right_axis_sittings.setAttribute("data-svgid", _svg.length + 1);
	    _svg.push(axis_setting_svg, axis_setting_svg);

	    append_elems_click_cb(_elems, BLUE_COLOR_REGEXP);
	    append_elems_click_cb(_axis_settings_elems, GREY_COLOR);
	}

	function create_wheel_interface(main_div) {

	    _is_pad_mode = false;

	    var wheel_elem = document.createElement("div");
	    var wheel_btn_0 = document.createElement("div");
	    var wheel_btn_1 = document.createElement("div");
	    var wheel_btn_2 = document.createElement("div");
	    var wheel_btn_3 = document.createElement("div");
	    var wheel_btn_4 = document.createElement("div");
	    var wheel_btn_5 = document.createElement("div");
	    var wheel_btn_6 = document.createElement("div");
	    var wheel_btn_7 = document.createElement("div");
	    var wheel_btn_8 = document.createElement("div");
	    var wheel_btn_9 = document.createElement("div");
	    var wheel_btn_10 = document.createElement("div");
	    var wheel_btn_11 = document.createElement("div");
	    var wheel_btn_12 = document.createElement("div");
	    var wheel_btn_13 = document.createElement("div");
	    var wheel_btn_14 = document.createElement("div");
	    var wheel_btn_15 = document.createElement("div");
	    var wheel_btn_16 = document.createElement("div");
	    var wheel_btn_17 = document.createElement("div");
	    var wheel_btn_18 = document.createElement("div");
	    var wheel_btn_19 = document.createElement("div");
	    var wheel_btn_20 = document.createElement("div");
	    var wheel_btn_21 = document.createElement("div");
	    var wheel_btn_22 = document.createElement("div");
	    var left_pedal_settings_elem = document.createElement("div");
	    var midle_pedal_settings_elem = document.createElement("div");
	    var right_pedal_settings_elem = document.createElement("div");
	    var wheel_settings_elem = document.createElement("div");
	    var gearbox_settings_hor_elem = document.createElement("div");
	    var gearbox_settings_vert_elem = document.createElement("div");

	    _device_elem = wheel_elem;

	    var btn_def_style =
	        "position: absolute;" +
	        "height: auto;" +
	        "background-image: " + SVG_BASE64 + btoa(wheel_btn) + "');" +
	        "width: 19px;" +
	        "height: 19px;" +
	        "background-size: 100% 100%;";

	    wheel_elem.style.cssText =
	        "position: absolute;" +
	        "background-image: " + SVG_BASE64 + btoa(wheel_svg) + "');" +
	        "width: 397px;" +
	        "height: 455px;" +
	        "-moz-transform: translateX(-50%);" +
	        "-ms-transform: translateX(-50%);" +
	        "-webkit-transform: translateX(-50%);" +
	        "transform: translateX(-50%);" +
	        "background-size: 100% 100%;" +
	        "left: 50%;" +
	        "margin-left: 25px;" +
	        "margin-bottom: 40px;" +
	        "bottom: 0px;";
	    wheel_btn_0.style.cssText =
	        btn_def_style + 
	        "top: 132px;" +
	        "left: 331px;";
	    wheel_btn_1.style.cssText =
	        btn_def_style + 
	        "top: 122px;" +
	        "left: 315px;";
	    wheel_btn_2.style.cssText =
	        btn_def_style + 
	        "top: 122px;" +
	        "left: 347px;";
	    wheel_btn_3.style.cssText =
	        btn_def_style + 
	        "top: 113px;" +
	        "left: 331px;";
	    wheel_btn_4.style.cssText =
	        "position: absolute;" +
	        "height: auto;" +
	        "background-image: " + SVG_BASE64 + btoa(wheel_right_svg) + "');" +
	        "width: 54px;" +
	        "height: 37px;" +
	        "background-size: 100% 100%;" + 
	        "top: 84px;" +
	        "left: 166px;";
	    wheel_btn_5.style.cssText =
	        "position: absolute;" +
	        "height: auto;" +
	        "background-image: " + SVG_BASE64 + btoa(wheel_left_svg) + "');" +
	        "width: 54px;" +
	        "height: 37px;" +
	        "background-size: 100% 100%;" + 
	        "top: 84px;" +
	        "left: 36px;";
	    wheel_btn_6.style.cssText =
	        btn_def_style + 
	        "top: 107px;" +
	        "left: 141px;";
	    wheel_btn_7.style.cssText =
	        btn_def_style + 
	        "top: 107px;" +
	        "left: 90px;";
	    wheel_btn_8.style.cssText =
	        btn_def_style + 
	        "top: 185px;" +
	        "left: 321px;";
	    wheel_btn_9.style.cssText =
	        btn_def_style + 
	        "top: 185px;" +
	        "left: 340px;";
	    wheel_btn_10.style.cssText =
	        btn_def_style + 
	        "top: 179px;" +
	        "left: 358px;";
	    wheel_btn_11.style.cssText =
	        btn_def_style + 
	        "top: 178px;" +
	        "left: 303px;";
	    wheel_btn_12.style.cssText =
	        btn_def_style + 
	        "top: 210px;" +
	        "left: 299px;";
	    wheel_btn_13.style.cssText =
	        btn_def_style + 
	        "top: 279px;" +
	        "left: 299px;";
	    wheel_btn_14.style.cssText =
	        btn_def_style + 
	        "top: 210px;" +
	        "left: 321px;";
	    wheel_btn_15.style.cssText =
	        btn_def_style + 
	        "top: 279px;" +
	        "left: 321px;";
	    wheel_btn_16.style.cssText =
	        btn_def_style + 
	        "top: 210px;" +
	        "left: 344px;";
	    wheel_btn_17.style.cssText =
	        btn_def_style + 
	        "top: 278px;" +
	        "left: 344px;";
	    wheel_btn_18.style.cssText =
	        btn_def_style + 
	        "top: 124px;" +
	        "left: 147px;";
	    wheel_btn_19.style.cssText =
	        btn_def_style + 
	        "top: 138px;" +
	        "left: 133px;";
	    wheel_btn_20.style.cssText =
	        btn_def_style + 
	        "top: 124px;" +
	        "left: 82px;";
	    wheel_btn_21.style.cssText =
	        btn_def_style + 
	        "top: 138px;" +
	        "left: 96px;";
	    wheel_btn_22.style.cssText =
	        btn_def_style + 
	        "top: 278px;" +
	        "left: 367px;";

	    var pedal_scc = "position: absolute;" +
	        "background-image: " + SVG_BASE64 + btoa(pedal_svg) + "');" +
	        "width: 19px;" +
	        "height: 46px;" +
	        "background-size: 100% 100%;";

	    left_pedal_settings_elem.style.cssText =
	        pedal_scc +
	        "top: 291px;" +
	        "left: 50px;";
	    midle_pedal_settings_elem.style.cssText =
	        pedal_scc +
	        "top: 291px;" +
	        "left: 111px;";
	    right_pedal_settings_elem.style.cssText =
	        pedal_scc +
	        "top: 291px;" +
	        "left: 171px;";
	    wheel_settings_elem.style.cssText =
	        "position: absolute;" +
	        "background-image: " + SVG_BASE64 + btoa(wheel_settings_svg) + "');" +
	        "width: 297px;" +
	        "height: 179px;" +
	        "background-size: 100% 100%;" +
	        "top: 43px;" +
	        "left: -25px;";
	    gearbox_settings_hor_elem.style.cssText =
	        "position: absolute;" +
	        "background-image: " + SVG_BASE64 + btoa(gearbox_hor_svg) + "');" +
	        "width: 33px;" +
	        "height: 10px;" +
	        "background-size: 100% 100%;" +
	        "top: 159px;" +
	        "left: 324px;";
	    gearbox_settings_vert_elem.style.cssText =
	        "position: absolute;" +
	        "background-image: " + SVG_BASE64 + btoa(gearbox_vert_svg) + "');" +
	        "width: 10px;" +
	        "height: 33px;" +
	        "background-size: 100% 100%;" +
	        "top: 148px;" +
	        "left: 335px;";

	    main_div.appendChild(wheel_elem);
	    wheel_elem.appendChild(left_pedal_settings_elem);
	    wheel_elem.appendChild(midle_pedal_settings_elem);
	    wheel_elem.appendChild(right_pedal_settings_elem);
	    wheel_elem.appendChild(wheel_settings_elem);
	    wheel_elem.appendChild(gearbox_settings_hor_elem);
	    wheel_elem.appendChild(gearbox_settings_vert_elem);
	    wheel_elem.appendChild(wheel_btn_0);
	    wheel_elem.appendChild(wheel_btn_1);
	    wheel_elem.appendChild(wheel_btn_2);
	    wheel_elem.appendChild(wheel_btn_3);
	    wheel_elem.appendChild(wheel_btn_4);
	    wheel_elem.appendChild(wheel_btn_5);
	    wheel_elem.appendChild(wheel_btn_6);
	    wheel_elem.appendChild(wheel_btn_7);
	    wheel_elem.appendChild(wheel_btn_8);
	    wheel_elem.appendChild(wheel_btn_9);
	    wheel_elem.appendChild(wheel_btn_10);
	    wheel_elem.appendChild(wheel_btn_11);
	    wheel_elem.appendChild(wheel_btn_12);
	    wheel_elem.appendChild(wheel_btn_13);
	    wheel_elem.appendChild(wheel_btn_14);
	    wheel_elem.appendChild(wheel_btn_15);
	    wheel_elem.appendChild(wheel_btn_16);
	    wheel_elem.appendChild(wheel_btn_17);
	    wheel_elem.appendChild(wheel_btn_18);
	    wheel_elem.appendChild(wheel_btn_19);
	    wheel_elem.appendChild(wheel_btn_20);
	    wheel_elem.appendChild(wheel_btn_21);
	    wheel_elem.appendChild(wheel_btn_22);

	    _elems.length = 0;
	    _svg.length = 0;
	    _axis_elems.length = 0;
	    _axis_settings_elems.length = 0;
	    _elems.push(wheel_btn_0, wheel_btn_1, wheel_btn_2, wheel_btn_3, wheel_btn_4,
	            wheel_btn_5, wheel_btn_6, wheel_btn_7, wheel_btn_8, wheel_btn_9,
	            wheel_btn_10, wheel_btn_11, wheel_btn_12, wheel_btn_13, wheel_btn_14,
	            wheel_btn_15, wheel_btn_16, wheel_btn_17, wheel_btn_18, wheel_btn_19,
	            wheel_btn_20, wheel_btn_21, wheel_btn_22);
	    _svg.push(wheel_btn, wheel_btn, wheel_btn, wheel_btn, wheel_right_svg, wheel_left_svg,
	            wheel_btn, wheel_btn, wheel_btn, wheel_btn, wheel_btn, wheel_btn,
	            wheel_btn, wheel_btn, wheel_btn, wheel_btn, wheel_btn, wheel_btn,
	            wheel_btn, wheel_btn, wheel_btn, wheel_btn, wheel_btn, wheel_btn);
	    _axis_settings_elems.push(wheel_settings_elem, left_pedal_settings_elem,
	            right_pedal_settings_elem, midle_pedal_settings_elem,
	            gearbox_settings_hor_elem, gearbox_settings_vert_elem);

	    //setting attributes

	    for (var i = 0; i < _elems.length; i++) {
	        _elems[i].setAttribute("id", "wheel_btn_" + i);
	        _elems[i].setAttribute("data-colorstate", "B");
	        _elems[i].setAttribute("data-key", i);
	        _elems[i].setAttribute("data-svgid", i);
	    }
	    for (var i = 0; i < _axis_settings_elems.length; i++) {
	        _elems[i].setAttribute("id", "wheel_axis_" + i);
	        _elems[i].setAttribute("data-colorstate", "GR");
	    }
	    wheel_settings_elem.setAttribute("data-key", m_input.GMPD_AXIS_0);
	    wheel_settings_elem.setAttribute("data-svgid", _svg.length);
	    left_pedal_settings_elem.setAttribute("data-key", m_input.GMPD_AXIS_1);
	    left_pedal_settings_elem.setAttribute("data-svgid", _svg.length + 1);
	    right_pedal_settings_elem.setAttribute("data-key", m_input.GMPD_AXIS_2);
	    right_pedal_settings_elem.setAttribute("data-svgid", _svg.length + 2);
	    midle_pedal_settings_elem.setAttribute("data-key", m_input.GMPD_AXIS_3);
	    midle_pedal_settings_elem.setAttribute("data-svgid", _svg.length + 3);
	    gearbox_settings_hor_elem.setAttribute("data-key", m_input.GMPD_AXIS_4);
	    gearbox_settings_hor_elem.setAttribute("data-svgid", _svg.length + 4);
	    gearbox_settings_vert_elem.setAttribute("data-key", m_input.GMPD_AXIS_5);
	    gearbox_settings_vert_elem.setAttribute("data-svgid", _svg.length + 5);
	    _svg.push(wheel_settings_svg, pedal_svg, pedal_svg, pedal_svg,
	            gearbox_hor_svg, gearbox_vert_svg);

	    append_elems_click_cb(_elems, BLUE_COLOR_REGEXP);
	    append_elems_click_cb(_axis_settings_elems, GREY_COLOR);
	}

	function create_sensors(gmpd_id) {
	    var sensors = [
	            m_ctrl.create_gamepad_btn_sensor(m_input.GMPD_BUTTON_0, gmpd_id),
	            m_ctrl.create_gamepad_btn_sensor(m_input.GMPD_BUTTON_1, gmpd_id),
	            m_ctrl.create_gamepad_btn_sensor(m_input.GMPD_BUTTON_2, gmpd_id),
	            m_ctrl.create_gamepad_btn_sensor(m_input.GMPD_BUTTON_3, gmpd_id),
	            m_ctrl.create_gamepad_btn_sensor(m_input.GMPD_BUTTON_4, gmpd_id),
	            m_ctrl.create_gamepad_btn_sensor(m_input.GMPD_BUTTON_5, gmpd_id),
	            m_ctrl.create_gamepad_btn_sensor(m_input.GMPD_BUTTON_6, gmpd_id),
	            m_ctrl.create_gamepad_btn_sensor(m_input.GMPD_BUTTON_7, gmpd_id),
	            m_ctrl.create_gamepad_btn_sensor(m_input.GMPD_BUTTON_8, gmpd_id),
	            m_ctrl.create_gamepad_btn_sensor(m_input.GMPD_BUTTON_9, gmpd_id),
	            m_ctrl.create_gamepad_btn_sensor(m_input.GMPD_BUTTON_10, gmpd_id),
	            m_ctrl.create_gamepad_btn_sensor(m_input.GMPD_BUTTON_11, gmpd_id),
	            m_ctrl.create_gamepad_btn_sensor(m_input.GMPD_BUTTON_12, gmpd_id),
	            m_ctrl.create_gamepad_btn_sensor(m_input.GMPD_BUTTON_13, gmpd_id),
	            m_ctrl.create_gamepad_btn_sensor(m_input.GMPD_BUTTON_14, gmpd_id),
	            m_ctrl.create_gamepad_btn_sensor(m_input.GMPD_BUTTON_15, gmpd_id),
	            m_ctrl.create_gamepad_btn_sensor(m_input.GMPD_BUTTON_16, gmpd_id),
	            m_ctrl.create_gamepad_btn_sensor(m_input.GMPD_BUTTON_17, gmpd_id),
	            m_ctrl.create_gamepad_btn_sensor(m_input.GMPD_BUTTON_18, gmpd_id),
	            m_ctrl.create_gamepad_btn_sensor(m_input.GMPD_BUTTON_19, gmpd_id),
	            m_ctrl.create_gamepad_btn_sensor(m_input.GMPD_BUTTON_20, gmpd_id),
	            m_ctrl.create_gamepad_btn_sensor(m_input.GMPD_BUTTON_21, gmpd_id),
	            m_ctrl.create_gamepad_btn_sensor(m_input.GMPD_BUTTON_22, gmpd_id),
	            m_ctrl.create_gamepad_btn_sensor(m_input.GMPD_BUTTON_23, gmpd_id),
	            m_ctrl.create_gamepad_btn_sensor(m_input.GMPD_BUTTON_24, gmpd_id),
	            m_ctrl.create_gamepad_btn_sensor(m_input.GMPD_BUTTON_25, gmpd_id)
	    ];
	    return sensors;
	}

	function create_axis_sensors(gmpd_id) {
	    var sensors = [
	            m_ctrl.create_gamepad_axis_sensor(m_input.GMPD_AXIS_0, gmpd_id),
	            m_ctrl.create_gamepad_axis_sensor(m_input.GMPD_AXIS_1, gmpd_id),
	            m_ctrl.create_gamepad_axis_sensor(m_input.GMPD_AXIS_2, gmpd_id),
	            m_ctrl.create_gamepad_axis_sensor(m_input.GMPD_AXIS_3, gmpd_id),
	            m_ctrl.create_gamepad_axis_sensor(m_input.GMPD_AXIS_4, gmpd_id),
	            m_ctrl.create_gamepad_axis_sensor(m_input.GMPD_AXIS_5, gmpd_id),
	            m_ctrl.create_gamepad_axis_sensor(m_input.GMPD_AXIS_6, gmpd_id),
	            m_ctrl.create_gamepad_axis_sensor(m_input.GMPD_AXIS_7, gmpd_id),
	            m_ctrl.create_gamepad_axis_sensor(m_input.GMPD_AXIS_8, gmpd_id),
	            m_ctrl.create_gamepad_axis_sensor(m_input.GMPD_AXIS_9, gmpd_id),
	            m_ctrl.create_gamepad_axis_sensor(m_input.GMPD_AXIS_10, gmpd_id),
	            m_ctrl.create_gamepad_axis_sensor(m_input.GMPD_AXIS_11, gmpd_id)
	    ];
	    return sensors;
	}

	function append_type_elem(parent, text) {
	    var select_type_elem = document.createElement("input");
	    select_type_elem.style.cssText =
	        "display: inline-block;" +
	        "position = relative;";
	    select_type_elem.setAttribute('type', 'radio');
	    select_type_elem.setAttribute('name', 'choice');
	    var select_type_label = document.createElement("label");
	    select_type_label.textContent = text;
	    select_type_label.style.cssText =
	        "position = relative;" +
	        "display: inline-block;" +
	        "color: white;";
	    parent.appendChild(select_type_elem);
	    parent.appendChild(select_type_label);
	    return select_type_elem;
	}

	function reset_device_type() {
	    _main_element.removeChild(_device_elem);
	    _device_elem = null;
	}

	function change_device(type) {
	    reset_device_type();
	    switch(type) {
	    case "PAD":
	        _type_pad_elem.checked = true;
	        create_pad_interface(_main_element);
	        break;
	    case "WHEEL":
	        _type_wheel_elem.checked = true;
	        create_wheel_interface(_main_element);
	        break;
	    }
	}

	function append_elems_click_cb(elems, original_color) {
	    var click_cb = function(e) {
	        var elem = e.target;
	        if(_selected_gamepad_num < 0 || elem.getAttribute("data-colorstate") == "G")
	                return;
	        if (_mode != VIEWER_MODE) {
	            if (elem.getAttribute("data-colorstate") == "R") {
	                _selected_btn = null;
	                document.getElementById("action_label").textContent =
	                        SELECT_BTN_CAPTION;
	                _mode = VIEWER_MODE;
	            }
	            if (elem.getAttribute("data-colorstate") == "B" || elem.getAttribute("data-colorstate") == "GR") {
	                var svg_num = parseFloat(_selected_btn.getAttribute("data-svgid"));
	                _selected_btn.style.backgroundImage = SVG_BASE64 + btoa(_svg[svg_num])  + "')";
	                _selected_btn.setAttribute("data-colorstate", elem.getAttribute("data-colorstate"));
	                _selected_btn = elem;
	                svg_num = parseFloat(elem.getAttribute("data-svgid"));
	                elem.style.backgroundImage = SVG_BASE64 + btoa(_svg[svg_num].replace(original_color,
	                        RED_COLOR))  + "')";
	                elem.setAttribute("data-colorstate", "R");
	            }
	        } else {
	            var svg_num = parseFloat(elem.getAttribute("data-svgid"));
	            var mode = elem.getAttribute("data-colorstate") == "B" ? BTN_EDIT_MODE : AXIS_EDIT_MODE;
	            _mode = mode;
	            elem.style.backgroundImage = SVG_BASE64 + btoa(_svg[svg_num].replace(original_color,
	                    RED_COLOR))  + "')";
	            elem.setAttribute("data-colorstate", "R");
	            if (mode == BTN_EDIT_MODE)
	                document.getElementById("action_label").textContent =
	                        PRESS_BTN_CAPTION;
	            else
	                document.getElementById("action_label").textContent =
	                        MOVE_AXIS_CAPTION;
	            _selected_btn = elem;
	        }
	    };
	    for (var i = 0; i < elems.length; i++) {
	        var elem = elems[i];
	        m_input.add_click_listener(elem, click_cb);
	    }
	}

	function create_device_icon_elem(number) {
	    var icon = document.createElement("label");
	    icon.style.cssText =
	        "position: relative;" +
	        "display: inline-block;" + 
	        "width: 50px;" +
	        "color: white;" +
	        "margin: 0 10px;" +
	        "font-size: 36px;" +
	        "line-height: 50px;" +
	        "background-color: black;" +
	        "border: 3px solid white;" +
	        "border-radius: 5px;" +
	        "height: 50px;";
	    icon.textContent = number;
	    return icon;
	}

	function zoom_main_div() {
	    var width  = window.innerWidth;
	    var height = window.innerHeight;

	    if ((height <= 750 && height > 400) || (width <= 750 && width > 400))
	        _main_element.style.zoom = "0.5";
	    else if (width <= 400 || height <= 400)
	        _main_element.style.zoom = "0.3";
	    else
	        _main_element.style.zoom = "1";
	}

	}

	var gp_config_factory = register("gp_conf", GP_config);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Gyroscope actions add-on.
	 * Provides support for gyroscope on mobile devices.
	 * @see http://www.w3.org/TR/orientation-event/
	 * @module gyroscope
	 */

	function Gyroscope(ns, exports) {

	var m_cam        = camera_factory(ns);
	var m_ctl        = controls_factory(ns);
	var m_scenes     = scenes_factory(ns);
	var m_trans      = transform_factory(ns);
	var m_util       = util_factory(ns);
	var m_vec3       = vec3_factory(ns);

	var _begin_angles = new Float32Array(3);
	var _curr_angles = new Float32Array(3);

	var _vec3_tmp = m_vec3.create();

	var VERTICAL_BETA_ANGLE_THRESHOLD_UP = m_util.deg_to_rad(110);
	var VERTICAL_BETA_ANGLE_THRESHOLD_DOWN = m_util.deg_to_rad(70);
	var VERTICAL_GAMMA_ANGLE_THRESHOLD_UP = m_util.deg_to_rad(70);
	var VERTICAL_GAMMA_ANGLE_THRESHOLD_DOWN = - m_util.deg_to_rad(70);

	/**
	 * Enable camera rotation according to orientation of mobile device.
	 * @method module:gyroscope.enable_camera_rotation
	 */
	exports.enable_camera_rotation = function() {
	    var cam_obj = m_scenes.get_active_camera();
	    create_camera_rotation_sensors(cam_obj);
	};

	function create_camera_rotation_sensors(obj) {
	    var g_a_sensor = m_ctl.create_gyro_angles_sensor();
	    var g_q_sensor = m_ctl.create_gyro_quat_sensor();
	    var save_angles = true;

	    var cam_rotate_cb = function(obj, id, pulse) {
	        if (pulse > 0) {
	            if (m_cam.is_eye_camera(obj)) {
	                var hmd_quat = m_ctl.get_sensor_payload(obj, id, 1);
	                var up_axis = m_vec3.transformQuat(m_util.AXIS_MY, hmd_quat, _vec3_tmp);
	                m_cam.set_vertical_axis(obj, up_axis);
	                m_trans.set_rotation_v(obj, hmd_quat);
	            } else {
	                _curr_angles = m_ctl.get_sensor_payload(obj, id, 0);

	                if (save_angles) {
	                    _begin_angles[0] = _curr_angles[0];
	                    _begin_angles[1] = _curr_angles[1];
	                    _begin_angles[2] = _curr_angles[2];
	                    save_angles = false;
	                }
	                var delta_beta = 0;
	                var delta_gamma = 0;

	                if (window.orientation == 0) {
	                    delta_beta = (_curr_angles[1] - _begin_angles[1]);
	                    delta_gamma = (_curr_angles[0] - _begin_angles[0]);
	                    if (_curr_angles[1] > VERTICAL_BETA_ANGLE_THRESHOLD_DOWN &&
	                            _curr_angles[1] < VERTICAL_BETA_ANGLE_THRESHOLD_UP)
	                        delta_gamma = 0;
	                }

	                if (window.orientation == 180) {
	                    delta_beta = (_curr_angles[1] - _begin_angles[1]);
	                    if (_curr_angles[1] < 0)
	                        delta_beta = -delta_beta;
	                    delta_gamma = (_begin_angles[0] - _curr_angles[0]);
	                    if (delta_beta > Math.PI / 2 || delta_beta < - Math.PI / 2)
	                        delta_beta = 0;
	                    if (_curr_angles[1] > - VERTICAL_BETA_ANGLE_THRESHOLD_UP &&
	                            _curr_angles[1] < - VERTICAL_BETA_ANGLE_THRESHOLD_DOWN)
	                        delta_gamma = 0;
	                }

	                if (window.orientation == -90) {
	                    delta_beta = (_curr_angles[0] - _begin_angles[0]);
	                    if (delta_beta > Math.PI / 2 || delta_beta < - Math.PI / 2)
	                        delta_beta = 0;
	                    delta_gamma = (_begin_angles[1] - _curr_angles[1]);
	                    if (_curr_angles[0] > VERTICAL_GAMMA_ANGLE_THRESHOLD_UP ||
	                            _curr_angles[0] < VERTICAL_GAMMA_ANGLE_THRESHOLD_DOWN)
	                        delta_gamma = 0;
	                }

	                if (window.orientation == 90) {
	                    delta_beta = (_begin_angles[0] - _curr_angles[0]);
	                    if (delta_beta > Math.PI / 2 || delta_beta < - Math.PI / 2)
	                        delta_beta = 0;
	                    delta_gamma = (_curr_angles[1] - _begin_angles[1]);
	                    if (_curr_angles[0] > VERTICAL_GAMMA_ANGLE_THRESHOLD_UP ||
	                            _curr_angles[0] < VERTICAL_GAMMA_ANGLE_THRESHOLD_DOWN)
	                        delta_gamma = 0;
	                }

	                m_cam.rotate_camera(obj, delta_gamma, delta_beta);
	                _begin_angles[0] = _curr_angles[0];
	                _begin_angles[1] = _curr_angles[1];
	                _begin_angles[2] = _curr_angles[2];
	            }
	        }
	    };
	    m_ctl.create_sensor_manifold(obj, "CAMERA_ROTATE_GYRO",
	            m_ctl.CT_CONTINUOUS, [g_a_sensor, g_q_sensor], null,
	            cam_rotate_cb);
	}

	/**
	 * Disable camera rotation according to orientation of mobile device.
	 * @method module:gyroscope.disable_camera_rotation
	 */
	exports.disable_camera_rotation = function() {
	    var cam_obj = m_scenes.get_active_camera();
	    m_ctl.remove_sensor_manifold(cam_obj, "CAMERA_ROTATE_GYRO");
	};

	}

	var gyroscope_factory = register("gyroscope", Gyroscope);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * HMD configurator add-on.
	 * @module hmd_conf
	 */
	function HMD_config(ns, exports) {

	var m_cont      = container_factory(ns);
	var m_ctl       = controls_factory(ns);
	var m_input     = input_factory(ns);
	var m_print     = print_factory(ns);
	var m_storage   = storage_factory(ns);
	var m_util      = util_factory(ns);

	var _is_shown = false;
	var _hmd_dialog = null;
	var _style = null;
	var _hmd_list = null;
	var _update = true;
	var _param_values = {
	    "profile": "custom",
	    "first_distortion": 0,
	    "second_distortion": 0,
	    "bevel_size": 0,
	    "screen_width": 0,
	    "screen_height": 0,
	    "screen_lense": 0,
	    "ipd": 0,
	    "baseline": 0
	};

	var DEFAULT_FIRST_DISTORTION = 0.34;
	var DEFAULT_SECOND_DISTORTION = 0.55;
	var DEFAULT_BEVEL_SIZE = 4;
	var DEFAULT_SCREEN_WIDTH = 110;
	var DEFAULT_SCREEN_HEIGHT = 65;
	var DEFAULT_SCREEN_LENSE_DIST = 50;
	var DEFAULT_EYE_DISTANCE = 64;
	var DEFAULT_BASELINE_DIST = 32;

	var INCH_TO_MM = 25.4;

	var IS_IOS = /iPad|iPhone|iPod/.test(navigator.platform);
	var MM_TO_M = 1 / 1000;

	var P_COMMON = 0;
	var P_MOBILE = 1;
	var P_WEBVR = 2;
	// use braces to prevent a obfuscation
	var _viewer_profiles = {
	    "oculus_dk2": {
	        name: "Oculus Rift DK2",
	        type: P_WEBVR,
	        "first_distortion": 0.22,
	        "second_distortion": 0.28
	        // don't forget to place comma if you uncomment the next line
	        // chromatic_aberration_coefs: [-0.015, 0.02, 0.025, 0.02]
	    },
	    "cardboard_1": {
	        name: "Cardboard (2014)",
	        type: P_MOBILE,
	        "ipd": 60,
	        "baseline": 35,
	        "screen_lense": 42,
	        "first_distortion": 0.441,
	        "second_distortion": 0.156
	        // don't forget to place comma if you uncomment the next line
	        // chromatic_aberration_coefs : [0.0, 0.0, 0.0, 0.0]
	    },
	    "cardboard_2": {
	        name: "Cardboard (2015)",
	        type: P_MOBILE,
	        "ipd": 64,
	        "baseline": 35,
	        "screen_lense": 39,
	        "first_distortion": 0.34,
	        "second_distortion": 0.55
	        // don't forget to place comma if you uncomment the next line
	        // chromatic_aberration_coefs : [0.0, 0.0, 0.0, 0.0]
	    },
	    "custom": {
	        name: "Custom",
	        type: P_COMMON,
	        "ipd": 64,
	        "baseline": 35,
	        "screen_lense": 39,
	        "first_distortion": 0.0,
	        "second_distortion": 0.0
	        // don't forget to place comma if you uncomment the next line
	        // chromatic_aberration_coefs: [0.0, 0.0, 0.0, 0.0]
	    }
	};

	var _param_list = [{
	        label: "Tray to lens-center distance.",
	        is_mobile: true,
	        inputs: [{
	                id: "baseline",
	                max: "50",
	                step: "0.5"
	            }
	        ]
	    }, {
	        label: "Interpupillary distance.",
	        is_mobile: true,
	        inputs: [{
	                id: "ipd",
	                max: "100",
	                step: "1"
	            }
	        ]
	    }, {
	        label: "Screen to lense distance.",
	        is_mobile: true,
	        inputs: [{
	                id: "screen_lense",
	                max: "100",
	                step: "1"
	            }
	        ]
	    }, {
	        label: "Screen height.",
	        is_mobile: true,
	        inputs: [{
	                id: "screen_height",
	                max: "150",
	                step: "1"
	            }
	        ]
	    }, {
	        label: "Screen width.",
	        is_mobile: true,
	        inputs: [{
	                id: "screen_width",
	                max: "200",
	                step: "1"
	            }
	        ]
	    }, {
	        label: "Bevel width.",
	        is_mobile: true,
	        inputs: [{
	                id: "bevel_size",
	                max: "20",
	                step: "1"
	            }
	        ]
	    }, {
	        label: "Distortion coefficients.",
	        inputs: [{
	                id: "first_distortion",
	                max: "1.0",
	                step: "0.01"
	            }, {
	                id: "second_distortion",
	                max: "1.0",
	                step: "0.01"
	            }
	        ]
	    }
	];

	/**
	 * Check if HMD configurator can be shown.
	 * @method module:hmd_conf.check
	 * @returns {boolean} The result of the checking.
	 */
	exports.check = check;
	function check() {
	    if (!m_input.can_use_device(m_input.DEVICE_HMD))
	        return false;

	    var device = m_input.get_device_by_type_element(m_input.DEVICE_HMD);
	    var hmd_type = m_input.get_value_param(device, m_input.HMD_WEBVR_TYPE);
	    return (hmd_type & (m_input.HMD_NON_WEBVR | m_input.HMD_WEBVR_MOBILE |
	            m_input.HMD_WEBVR_DESKTOP)) &&
	            !(hmd_type & m_input.HMD_WEBVR1);
	}

	/**
	 * Show HMD configurator.
	 * @method module:hmd_conf.show
	 * @param {string} css_class CSS class of HMD configurator element
	 */
	exports.show = function(css_class) {
	    if (!check())
	        return;

	    var container = m_cont.get_container();

	    _style = document.createElement("style");
	    _style.innerHTML = "." + css_class + " input[type=range]::-webkit-slider-runnable-track {width: 100%; height: 8px;cursor: pointer;background-color: #fff;border: 2px solid rgba(98, 98, 98, .2);box-shadow: 0px 0px 4px 0px rgba(98, 98, 98, .8);}." + css_class + " input[type=range]::-webkit-slider-thumb {box-shadow: 0px 0px 4px 0px rgba(98, 98, 98, .8);height: 30px;width: 16px;border-radius: 2px;background-color: #323232;cursor: pointer;margin-top: -13px;-webkit-appearance: none;}";

	    document.head.appendChild(_style);

	    if (_is_shown)
	        return;
	    _is_shown = true;
	    restore_params();

	    var mdevice = m_input.get_device_by_type_element(m_input.DEVICE_MOUSE, container);
	    m_input.switch_prevent_default(mdevice, false);
	    var tdevice = m_input.get_device_by_type_element(m_input.DEVICE_TOUCH, container);
	    m_input.switch_prevent_default(tdevice, false);

	    _hmd_dialog = document.createElement("div");
	    _hmd_dialog.className = css_class;
	    container.appendChild(_hmd_dialog);
	    _hmd_list = document.createElement("div");
	    _hmd_dialog.appendChild(_hmd_list);

	    _hmd_list.style.cssText =
	          "background-color: #484848;" +
	          "border: 2px solid rgba(150, 150, 150, 0.7);" +
	          "box-shadow: 0px 0px 10px 0px rgba(150, 150, 150, 0.7);" +
	          "position: relative;" +
	          "width: 524px;" +
	          "padding: 16px;" +
	          "overflow: hidden;";

	    var select = create_profiles_select();
	    _hmd_list.appendChild(select);

	    var device = m_input.get_device_by_type_element(m_input.DEVICE_HMD);
	    for (var i = 0; i < _param_list.length; i++) {
	        if (m_input.get_value_param(device, m_input.HMD_WEBVR_TYPE) &
	                (m_input.HMD_NON_WEBVR | m_input.HMD_WEBVR_MOBILE) ||
	                !_param_list[i].is_mobile) {
	            var param_cont = create_param(_param_list[i], i);
	            _hmd_list.appendChild(param_cont);
	        }
	    }

	    var buttons = create_buttons();
	    _hmd_list.appendChild(buttons);

	    var time = m_ctl.create_timeline_sensor();
	    m_ctl.create_sensor_manifold(null, "UPDATE_HMD_RENDERING",
	            m_ctl.CT_CONTINUOUS, [time], null, update_params);
	};

	function create_profiles_select() {
	    var hmd_conf_str = m_storage.get("hmd_conf", "b4w");
	    var hmd_conf_data = JSON.parse(hmd_conf_str? hmd_conf_str: "{}");
	    var cur_profile = hmd_conf_data["profile"] || "custom";

	    var select_cont = document.createElement("div");

	    var label = document.createElement("label");
	    label.innerHTML = "Profile: ";
	    label.className = "text_label";

	    label.style.cssText =
	        "background-color: #323232;" +
	        "border: 2px solid rgba(98, 98, 98, .2);" +
	        "border-radius: 2px;" +
	        "width: 120px;" +
	        "height: 30px;" +
	        "display: block;" +
	        "float: left;" +
	        "font-size: 16px;" +
	        "font-weight: normal;" +
	        "color: #fff;" +
	        "cursor: pointer;" +
	        "text-decoration: none;" +
	        "text-align: left;" +
	        "padding-left: 8px;" +
	        "line-height: 28px;" +
	        "margin-bottom: 4px;" +
	        "box-shadow: 0px 0px 4px 0px rgba(98, 98, 98, .8);";

	    select_cont.appendChild(label);

	    var select = document.createElement("select");
	    select_cont.appendChild(select);

	    select.style.cssText =
	        "background-color: #323232;" +
	        "border: 2px solid rgba(98, 98, 98, .2);" +
	        "border-radius: 2px;" +
	        "height: 30px;" +
	        "display: block;" +
	        "font-size: 16px;" +
	        "font-weight: normal;" +
	        "color: #fff;" +
	        "cursor: pointer;" +
	        "text-decoration: none;" +
	        "text-align: left;" +
	        "padding-left: 8px;" +
	        "line-height: 28px;" +
	        "margin-bottom: 4px;" +
	        "box-shadow: 0px 0px 4px 0px rgba(98, 98, 98, .8);";

	    var device = m_input.get_device_by_type_element(m_input.DEVICE_HMD);
	    if (device)
	        for (var i in _viewer_profiles) {
	            if (_viewer_profiles[i].type == P_COMMON ||
	                    (m_input.get_value_param(device, m_input.HMD_WEBVR_TYPE) &
	                    (m_input.HMD_NON_WEBVR | m_input.HMD_WEBVR_MOBILE) &&
	                    _viewer_profiles[i].type == P_MOBILE)) {
	                var option = document.createElement("option");
	                option.value = i;
	                option.text = _viewer_profiles[i].name;
	                select.appendChild(option);
	            }
	        }

	    select.value = cur_profile;
	    if (m_util.is_ie11())
	        select.onchange = change_select_cb;
	    else
	        select.oninput = change_select_cb;
	    return select_cont;
	}

	function change_select_cb(e){
	    var profile = e.target.value;
	    var profile_data = _viewer_profiles[profile];

	    for (var name in _param_values) {
	        if (name in profile_data) {
	            var slider = document.getElementById(name + "_slider");
	            if (slider) {
	                slider.disabled = profile !== "custom";
	                slider.value = profile_data[name];
	            }

	            var number = document.getElementById(name + "_number");
	            if (number) {
	                number.disabled = profile !== "custom";
	                number.value = profile_data[name];
	            }

	            _param_values[name] = profile_data[name];
	        }
	    }
	}


	/**
	 * Hide HMD configurator.
	 * @method module:hmd_conf.hide
	 */
	exports.hide = hide;
	function hide() {
	    m_ctl.remove_sensor_manifold(null, "UPDATE_HMD_RENDERING");
	    restore_params();
	    update_params();

	    if (!_is_shown)
	        return;
	    _is_shown = false;
	    remove_dom_tree();
	}

	/**
	 * Reset values of HMD config.
	 * @method module:hmd_conf.reset
	 */
	exports.reset = reset;
	function reset() {
	    restore_params(true);
	    update_params();
	    update_dom_tree();
	}

	/**
	 * Update HMD device config without showing HMD configurator
	 * @method module:hmd_conf.update
	 */
	exports.update = function() {
	    restore_params();
	    update_params();
	};

	function update_dom_tree() {
	    for (var i in _param_values) {
	        var slider = document.getElementById(i + "_slider");
	        if (slider)
	            slider.value = _param_values[i];
	        var number = document.getElementById(i + "_number");
	        if (number)
	            number.value = _param_values[i];
	    }
	}

	function remove_dom_tree() {
	    var container = m_cont.get_container();
	    container.removeChild(_hmd_dialog);
	    document.head.removeChild(_style);
	    _hmd_dialog = null;
	    _hmd_list = null;
	    _style = null;
	}

	function get_screen_width() {
	    return Math.max(window.screen.width, window.screen.height) *
	            window.devicePixelRatio;
	}

	function get_screen_height() {
	    return Math.min(window.screen.width, window.screen.height) *
	            window.devicePixelRatio;
	}

	function check_rule(rule, ua, screenWidth, screenHeight) {
	    return (rule["ua"] && ua.indexOf(rule["ua"]) >= 0) ||
	            !rule["ua"] && rule["res"] && rule["res"][0] && rule["res"][1] &&
	            Math.min(screenWidth, screenHeight) == Math.min(rule["res"][0], rule["res"][1]) &&
	            Math.max(screenWidth, screenHeight) == Math.max(rule["res"][0], rule["res"][1]);
	}

	function find_device_index(dpdb, user_agent, width, height) {
	    if (dpdb["format"] != 1 || !dpdb["devices"] || !dpdb["devices"].length) {
	        m_print.error("DPDB isn't correct.");
	        return -1;
	    }

	    for (var i = 0; i < dpdb["devices"].length; i++) {
	        var device = dpdb["devices"][i];
	        if (!device["rules"] ||
	                (device["type"] != "ios" || !IS_IOS) && device["type"] != "android")
	            continue;

	        var found = false;
	        for (var j = 0; j < device["rules"].length; j++) {
	            var rule = device["rules"][j];
	            if (check_rule(rule, user_agent, width, height)) {
	                found = true;
	                break;
	            }
	        }
	        if (found)
	            return i;
	    }
	    return -1;
	}

	function restore_params(ignore_storage) {
	    var user_agent = navigator.userAgent || navigator.vendor || window.opera;
	    var width = get_screen_width();
	    var height = get_screen_height();
	    var width_dpmm = 0;
	    var height_dpmm = 0;
	    var bevel_mm = 0;
	    var device_index = find_device_index(DPDB, user_agent, width, height);
	    if (device_index != -1) {
	        var device = DPDB["devices"][device_index];
	        var xdpi = device["dpi"][0] || device["dpi"];
	        var ydpi = device["dpi"][1] || device["dpi"];

	        width_dpmm = Math.round(width * INCH_TO_MM / xdpi);
	        height_dpmm = Math.round(height * INCH_TO_MM / ydpi);
	        bevel_mm = Math.round(device["bw"]);
	    }

	    var hmd_conf_str = m_storage.get("hmd_conf", "b4w");
	    var hmd_conf_data = JSON.parse(hmd_conf_str? hmd_conf_str: "{}");

	    if (ignore_storage) {
	        _param_values["first_distortion"] = DEFAULT_FIRST_DISTORTION;
	        _param_values["second_distortion"] = DEFAULT_SECOND_DISTORTION;
	        _param_values["bevel_size"] = bevel_mm || DEFAULT_BEVEL_SIZE;
	        _param_values["screen_width"] = width_dpmm || DEFAULT_SCREEN_WIDTH;
	        _param_values["screen_height"] = height_dpmm || DEFAULT_SCREEN_HEIGHT;
	        _param_values["screen_lense"] = DEFAULT_SCREEN_LENSE_DIST;
	        _param_values["ipd"] = DEFAULT_EYE_DISTANCE;
	        _param_values["baseline"] = DEFAULT_BASELINE_DIST;
	    } else {
	        _param_values["first_distortion"] = "first_distortion" in hmd_conf_data?
	                parseFloat(hmd_conf_data["first_distortion"]):
	                DEFAULT_FIRST_DISTORTION;
	        _param_values["second_distortion"] = "second_distortion" in hmd_conf_data?
	                parseFloat(hmd_conf_data["second_distortion"]):
	                DEFAULT_SECOND_DISTORTION;
	        _param_values["bevel_size"] = "bevel_size" in hmd_conf_data?
	                parseFloat(hmd_conf_data["bevel_size"]):
	                bevel_mm || DEFAULT_BEVEL_SIZE;
	        _param_values["screen_width"] = "screen_width" in hmd_conf_data?
	                parseFloat(hmd_conf_data["screen_width"]):
	                width_dpmm || DEFAULT_SCREEN_WIDTH;
	        _param_values["screen_height"] = "screen_height" in hmd_conf_data?
	                parseFloat(hmd_conf_data["screen_height"]):
	                height_dpmm || DEFAULT_SCREEN_HEIGHT;
	        _param_values["screen_lense"] = "screen_lense" in hmd_conf_data?
	                parseFloat(hmd_conf_data["screen_lense"]):
	                DEFAULT_SCREEN_LENSE_DIST;
	        _param_values["ipd"] = "ipd" in hmd_conf_data?
	                parseFloat(hmd_conf_data["ipd"]): DEFAULT_EYE_DISTANCE;
	        _param_values["baseline"] = "baseline" in hmd_conf_data?
	                parseFloat(hmd_conf_data["baseline"]): DEFAULT_BASELINE_DIST;
	    }

	    _update = true;
	}

	function save_changes() {
	    m_storage.set("hmd_conf", JSON.stringify(_param_values), "b4w");
	    hide();
	}

	function update_params() {
	    if (_update) {
	        var device = m_input.get_device_by_type_element(m_input.DEVICE_HMD);
	        if (device) {
	            m_input.set_config(device, m_input.HMD_DISTORTION,
	                    [_param_values["first_distortion"], _param_values["second_distortion"]]);

	            if (m_input.get_value_param(device, m_input.HMD_WEBVR_TYPE) &
	                    (m_input.HMD_NON_WEBVR | m_input.HMD_WEBVR_MOBILE)) {
	                m_input.set_config(device, m_input.HMD_BEVEL_SIZE,
	                        _param_values["bevel_size"] * MM_TO_M);
	                m_input.set_config(device, m_input.HMD_SCREEN_WIDTH,
	                        _param_values["screen_width"] * MM_TO_M);
	                m_input.set_config(device, m_input.HMD_SCREEN_HEIGHT,
	                        _param_values["screen_height"] * MM_TO_M);
	                m_input.set_config(device, m_input.HMD_SCREEN_LENS_DIST,
	                        _param_values["screen_lense"] * MM_TO_M);
	                m_input.set_config(device, m_input.HMD_EYE_DISTANCE,
	                        _param_values["ipd"] * MM_TO_M);
	                m_input.set_config(device, m_input.HMD_BASELINE_DIST,
	                        _param_values["baseline"] * MM_TO_M);
	            }
	        }
	        _update = false;
	    }

	}

	function change_slider_cb(e) {
	    var id = e.target.id;
	    var id_list = id.split("_");
	    var value_id = id_list.splice(0, id_list.length - 1).join("_");
	    if (value_id in _param_values && _param_values[value_id] != e.target.value) {
	        _update = true;
	        _param_values[value_id] = e.target.value;

	        var slider = document.getElementById(value_id + "_slider");
	        slider.value = e.target.value;

	        var number = document.getElementById(value_id + "_number");
	        number.value = e.target.value;
	    }
	}

	function create_param(param, i) {
	    var param_cont = document.createElement("div");

	    var label_d = document.createElement("label");
	    label_d.className = "text_label";

	    var margin_right = "8px";

	    if (i%2)
	        margin_right = "0";

	    label_d.style.cssText =
	        "background-color: #323232;" +
	        "border: 2px solid rgba(98, 98, 98, .2);" +
	        "border-radius: 2px;" +
	        "width: 100%;" +
	        "height: 30px;" +
	        "display: block;" +
	        "font-size: 16px;" +
	        "font-weight: normal;" +
	        "color: #fff;" +
	        "cursor: pointer;" +
	        "text-decoration: none;" +
	        "text-align: left;" +
	        "padding-left: 8px;" +
	        "line-height: 28px;" +
	        "margin-bottom: 4px;" +
	        "box-shadow: 0px 0px 4px 0px rgba(98, 98, 98, .8);";

	    label_d.textContent = param.label;
	    param_cont.appendChild(label_d);

	    param_cont.style.cssText = 
	        "margin-top: 16px;" +
	        "float: left;" +
	        "width: 240px;" +
	        "margin-right: " + margin_right + ";" +
	        "border-top: 2px solid rgba(98, 98, 98, .4);" +
	        "box-sizing: border-box;" +
	        "-webkit-box-sizing: border-box;" +
	        "padding-top: 8px;";

	    for (var j = 0; j < param.inputs.length; j++) {
	        var input_data = param.inputs[j];
	        var slider = create_slider(input_data);
	        param_cont.appendChild(slider);
	    }

	    return param_cont;
	}

	function create_slider(input_data) {
	    var container = document.createElement("div");
	    container.className = "row";

	    var input_s = document.createElement("input");
	    input_s.className = "input_slider";

	    input_s.style.cssText =
	        "-webkit-appearance: none;" +
	        "width: 192px;" +
	        "display: block;" +
	        "float: left;" +
	        "height: 8px;" +
	        "margin-bottom: 16px;" +
	        "margin-top: 16px;" +
	        "box-sizing: border-box;" +
	        "margin-right: 8px;" +
	        "margin-left: 0;";

	    input_s.setAttribute("id", input_data.id + "_slider");
	    input_s.setAttribute("type", "range");
	    input_s.setAttribute("min", "0.00");
	    input_s.setAttribute("step", input_data.step);
	    input_s.setAttribute("value", _param_values[input_data.id]);
	    input_s.setAttribute("max", input_data.max);

	    container.appendChild(input_s);

	    var input_d = document.createElement("input");
	    input_d.className = "input_text";
	    input_d.setAttribute("id", input_data.id + "_number");
	    input_d.setAttribute("type", "number");
	    input_d.setAttribute("min", "0.00");
	    input_d.setAttribute("step", input_data.step);
	    input_d.setAttribute("value", _param_values[input_data.id]);
	    input_d.setAttribute("max", input_data.max);
	    container.appendChild(input_d);
	    input_d.style.cssText =
	        "background-color: #323232;" +
	        "border: 2px solid rgba(98, 98, 98, .2);" +
	        "border-radius: 2px;" +
	        "width: 40px;" +
	        "height: 30px;" +
	        "display: block;" +
	        "float: left;" +
	        "font-size: 16px;" +
	        "font-weight: normal;" +
	        "color: #fff;" +
	        "cursor: pointer;" +
	        "text-decoration: none;" +
	        "text-align: center;" +
	        "box-sizing: border-box;" +
	        "line-height: 28px;" +
	        "margin-top: 4px;" +
	        "margin-right: 0;" +
	        "margin-left: 0;" +
	        "box-shadow: 0px 0px 4px 0px rgba(98, 98, 98, .8);";

	    if (m_util.is_ie11()) {
	        input_s.onchange = change_slider_cb;
	        input_d.onchange = change_slider_cb;
	    } else {
	        input_s.oninput = change_slider_cb;
	        input_d.oninput = change_slider_cb;
	    }

	    return container;
	}

	function create_buttons() {
	    var buttons_container = document.createElement("div");
	    var hmd_submit_button = create_button(save_changes, "SAVE", "4px");
	    var hmd_cancel_button = create_button(hide, "CANCEL", "4px");
	    var hmd_reset_button = create_button(reset, "RESET", "0px");

	    buttons_container.className = "row";
	    buttons_container.style.cssText =
	        "padding-top: 32px;" +
	        "clear: both;" +
	        "box-sizing: border-box;" +
	        "-webkit-box-sizing: border-box;";

	    buttons_container.appendChild(hmd_submit_button);
	    buttons_container.appendChild(hmd_cancel_button);
	    buttons_container.appendChild(hmd_reset_button);

	    // var common_style = "margin: 20px 0;" +
	    //                    "border: 0;" +
	    //                    "background-color: #337ab7;" +
	    //                    "border-radius: 4px;" +
	    //                    "margin-right:10px;" +
	    //                    "color:#fff;" +
	    //                    "padding: 10px 15px;" +
	    //                    "margin-right: 5px;" +
	    //                    "cursor:pointer;";

	    // hmd_submit_button.style.cssText = common_style;
	    // hmd_cancel_button.style.cssText = common_style;
	    // hmd_reset_button.style.cssText = common_style;

	    return buttons_container;
	}

	function create_button(callback, text_content, margin_right) {
	    var button = document.createElement("button");
	    button.onclick = callback;
	    button.style.cssText =
	        "background-color: #323232;" +
	        "border: 2px solid rgba(98, 98, 98, .2);" +
	        "border-radius: 2px;" +
	        "width: 160px;" +
	        "height: 30px;" +
	        "display: block;" +
	        "float: left;" +
	        "font-size: 16px;" +
	        "font-weight: normal;" +
	        "color: #fff;" +
	        "cursor: pointer;" +
	        "text-decoration: none;" +
	        "text-align: center;" +
	        "padding-left: 8px;" +
	        "line-height: 28px;" +
	        "margin-right:" + margin_right + ";" +
	        "box-shadow: 0px 0px 4px 0px rgba(98, 98, 98, .8);";

	    button.innerHTML = text_content;
	    return button;
	}

	/*
	 * Copyright 2015 Google Inc. All Rights Reserved.
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var DPDB = {"_comment":"AUTOMATICALLY GENERATED BY generate_dpdb.py. DO NOT EDIT.","format":1,"last_updated":"2016-01-26T23:11:18Z","devices":[{"type":"android","rules":[{"mdmh":"asus/*/Nexus 7/*"},{"ua":"Nexus 7"}],"dpi":[320.8,323],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"asus/*/ASUS_Z00AD/*"},{"ua":"ASUS_Z00AD"}],"dpi":[403,404.6],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"HTC/*/HTC6435LVW/*"},{"ua":"HTC6435LVW"}],"dpi":[449.7,443.3],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"HTC/*/HTC One XL/*"},{"ua":"HTC One XL"}],"dpi":[315.3,314.6],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"htc/*/Nexus 9/*"},{"ua":"Nexus 9"}],"dpi":289,"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"HTC/*/HTC One M9/*"},{"ua":"HTC One M9"}],"dpi":[442.5,443.3],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"HTC/*/HTC One_M8/*"},{"ua":"HTC One_M8"}],"dpi":[449.7,447.4],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"HTC/*/HTC One/*"},{"ua":"HTC One"}],"dpi":472.8,"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"Huawei/*/Nexus 6P/*"},{"ua":"Nexus 6P"}],"dpi":[515.1,518],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"LGE/*/Nexus 5X/*"},{"ua":"Nexus 5X"}],"dpi":[422,419.9],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"LGE/*/LGMS345/*"},{"ua":"LGMS345"}],"dpi":[221.7,219.1],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"LGE/*/LG-D800/*"},{"ua":"LG-D800"}],"dpi":[422,424.1],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"LGE/*/LG-D850/*"},{"ua":"LG-D850"}],"dpi":[537.9,541.9],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"LGE/*/VS985 4G/*"},{"ua":"VS985 4G"}],"dpi":[537.9,535.6],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"LGE/*/Nexus 5/*"},{"ua":"Nexus 5 B"}],"dpi":[442.4,444.8],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"LGE/*/Nexus 4/*"},{"ua":"Nexus 4"}],"dpi":[319.8,318.4],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"LGE/*/LG-P769/*"},{"ua":"LG-P769"}],"dpi":[240.6,247.5],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"LGE/*/LGMS323/*"},{"ua":"LGMS323"}],"dpi":[206.6,204.6],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"LGE/*/LGLS996/*"},{"ua":"LGLS996"}],"dpi":[403.4,401.5],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"Micromax/*/4560MMX/*"},{"ua":"4560MMX"}],"dpi":[240,219.4],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"Micromax/*/A250/*"},{"ua":"Micromax A250"}],"dpi":[480,446.4],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"Micromax/*/Micromax AQ4501/*"},{"ua":"Micromax AQ4501"}],"dpi":240,"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"motorola/*/DROID RAZR/*"},{"ua":"DROID RAZR"}],"dpi":[368.1,256.7],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"motorola/*/XT830C/*"},{"ua":"XT830C"}],"dpi":[254,255.9],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"motorola/*/XT1021/*"},{"ua":"XT1021"}],"dpi":[254,256.7],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"motorola/*/XT1023/*"},{"ua":"XT1023"}],"dpi":[254,256.7],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"motorola/*/XT1028/*"},{"ua":"XT1028"}],"dpi":[326.6,327.6],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"motorola/*/XT1034/*"},{"ua":"XT1034"}],"dpi":[326.6,328.4],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"motorola/*/XT1053/*"},{"ua":"XT1053"}],"dpi":[315.3,316.1],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"motorola/*/XT1562/*"},{"ua":"XT1562"}],"dpi":[403.4,402.7],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"motorola/*/Nexus 6/*"},{"ua":"Nexus 6 B"}],"dpi":[494.3,489.7],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"motorola/*/XT1063/*"},{"ua":"XT1063"}],"dpi":[295,296.6],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"motorola/*/XT1064/*"},{"ua":"XT1064"}],"dpi":[295,295.6],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"motorola/*/XT1092/*"},{"ua":"XT1092"}],"dpi":[422,424.1],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"motorola/*/XT1095/*"},{"ua":"XT1095"}],"dpi":[422,423.4],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"OnePlus/*/A0001/*"},{"ua":"A0001"}],"dpi":[403.4,401],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"OnePlus/*/ONE E1005/*"},{"ua":"ONE E1005"}],"dpi":[442.4,441.4],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"OnePlus/*/ONE A2005/*"},{"ua":"ONE A2005"}],"dpi":[391.9,405.4],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"OPPO/*/X909/*"},{"ua":"X909"}],"dpi":[442.4,444.1],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/GT-I9082/*"},{"ua":"GT-I9082"}],"dpi":[184.7,185.4],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G360P/*"},{"ua":"SM-G360P"}],"dpi":[196.7,205.4],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/Nexus S/*"},{"ua":"Nexus S"}],"dpi":[234.5,229.8],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/GT-I9300/*"},{"ua":"GT-I9300"}],"dpi":[304.8,303.9],"bw":5,"ac":500},{"type":"android","rules":[{"mdmh":"samsung/*/SM-T230NU/*"},{"ua":"SM-T230NU"}],"dpi":216,"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"samsung/*/SGH-T399/*"},{"ua":"SGH-T399"}],"dpi":[217.7,231.4],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-N9005/*"},{"ua":"SM-N9005"}],"dpi":[386.4,387],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"samsung/*/SAMSUNG-SM-N900A/*"},{"ua":"SAMSUNG-SM-N900A"}],"dpi":[386.4,387.7],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/GT-I9500/*"},{"ua":"GT-I9500"}],"dpi":[442.5,443.3],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"samsung/*/GT-I9505/*"},{"ua":"GT-I9505"}],"dpi":439.4,"bw":4,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G900F/*"},{"ua":"SM-G900F"}],"dpi":[415.6,431.6],"bw":5,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G900M/*"},{"ua":"SM-G900M"}],"dpi":[415.6,431.6],"bw":5,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G800F/*"},{"ua":"SM-G800F"}],"dpi":326.8,"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G906S/*"},{"ua":"SM-G906S"}],"dpi":[562.7,572.4],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/GT-I9300/*"},{"ua":"GT-I9300"}],"dpi":[306.7,304.8],"bw":5,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-T535/*"},{"ua":"SM-T535"}],"dpi":[142.6,136.4],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"samsung/*/SM-N920C/*"},{"ua":"SM-N920C"}],"dpi":[515.1,518.4],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/GT-I9300I/*"},{"ua":"GT-I9300I"}],"dpi":[304.8,305.8],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/GT-I9195/*"},{"ua":"GT-I9195"}],"dpi":[249.4,256.7],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"samsung/*/SPH-L520/*"},{"ua":"SPH-L520"}],"dpi":[249.4,255.9],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SAMSUNG-SGH-I717/*"},{"ua":"SAMSUNG-SGH-I717"}],"dpi":285.8,"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SPH-D710/*"},{"ua":"SPH-D710"}],"dpi":[217.7,204.2],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/GT-N7100/*"},{"ua":"GT-N7100"}],"dpi":265.1,"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SCH-I605/*"},{"ua":"SCH-I605"}],"dpi":265.1,"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/Galaxy Nexus/*"},{"ua":"Galaxy Nexus"}],"dpi":[315.3,314.2],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-N910H/*"},{"ua":"SM-N910H"}],"dpi":[515.1,518],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-N910C/*"},{"ua":"SM-N910C"}],"dpi":[515.2,520.2],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G130M/*"},{"ua":"SM-G130M"}],"dpi":[165.9,164.8],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G928I/*"},{"ua":"SM-G928I"}],"dpi":[515.1,518.4],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G920F/*"},{"ua":"SM-G920F"}],"dpi":580.6,"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G920P/*"},{"ua":"SM-G920P"}],"dpi":[522.5,577],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G925F/*"},{"ua":"SM-G925F"}],"dpi":580.6,"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G925V/*"},{"ua":"SM-G925V"}],"dpi":[522.5,576.6],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"Sony/*/C6903/*"},{"ua":"C6903"}],"dpi":[442.5,443.3],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"Sony/*/D6653/*"},{"ua":"D6653"}],"dpi":[428.6,427.6],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"Sony/*/E6653/*"},{"ua":"E6653"}],"dpi":[428.6,425.7],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"Sony/*/E6853/*"},{"ua":"E6853"}],"dpi":[403.4,401.9],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"Sony/*/SGP321/*"},{"ua":"SGP321"}],"dpi":[224.7,224.1],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"TCT/*/ALCATEL ONE TOUCH Fierce/*"},{"ua":"ALCATEL ONE TOUCH Fierce"}],"dpi":[240,247.5],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"THL/*/thl 5000/*"},{"ua":"thl 5000"}],"dpi":[480,443.3],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"ZTE/*/ZTE Blade L2/*"},{"ua":"ZTE Blade L2"}],"dpi":240,"bw":3,"ac":500},{"type":"ios","rules":[{"res":[640,960]}],"dpi":[325.1,328.4],"bw":4,"ac":1000},{"type":"ios","rules":[{"res":[640,1136]}],"dpi":[317.1,320.2],"bw":3,"ac":1000},{"type":"ios","rules":[{"res":[750,1334]}],"dpi":326.4,"bw":4,"ac":1000},{"type":"ios","rules":[{"res":[1242,2208]}],"dpi":[453.6,458.4],"bw":4,"ac":1000},{"type":"ios","rules":[{"res":[1125,2001]}],"dpi":[410.9,415.4],"bw":4,"ac":1000}]};

	}

	var hmd_conf_factory = register("hmd_conf", HMD_config);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/** 
	 * Sound effects API.
	 * Uses Web Audio API for sound effects and HTML5 audio for background music.
	 * @see https://www.blend4web.com/doc/en/audio.html
	 * @module sfx
	 * @cc_externs AudioContext webkitAudioContext MediaElementAudioSourceNode
	 */
	function SFX(ns, exports) {

	var m_obj_util = int_obj_util_factory(ns);
	var m_scs      = int_scenes_factory(ns);
	var m_sfx      = int_sfx_factory(ns);
	var m_print    = print_factory(ns);

	/**
	 * Play sound through the speaker.
	 * @method module:sfx.play
	 * @param {Object3D} obj Object 3D
	 * @param {number} [when=0] Delay after exec in seconds
	 * @param {number} [duration=0] Duration of the speaker's playback cycle (in
	 * seconds). duration=0 - assign default value according to sound playback length.
	 */
	exports.play = function(obj, when, duration) {
	    when = when || 0;
	    duration = duration || 0;
	    m_sfx.play(obj, when, duration);
	};
	/**
	 * Play sound through the speaker using the default delay and duration params.
	 * @method module:sfx.play_def
	 * @param {Object3D} obj Object 3D
	 */
	exports.play_def = function(obj) {
	    m_sfx.play_def(obj);
	};

	/**
	 * Check if sound is played through the speaker now.
	 * @method module:sfx.is_playing
	 * @param {Object3D} obj Object 3D
	 * @returns {boolean} Playing state
	 */
	exports.is_playing = function(obj) {
	    return m_sfx.is_playing(obj);
	};

	/**
	 * Stop the speaker.
	 * @method module:sfx.stop
	 * @param {Object3D} obj Object 3D
	 */
	exports.stop = function(obj) {
	    m_sfx.stop(obj);
	};


	/**
	 * Pause the speaker.
	 * @method module:sfx.pause
	 * @param {Object3D} obj Object 3D
	 */
	exports.pause = function(obj) {
	    m_sfx.speaker_pause(obj);
	};

	/**
	 * Resume the paused speaker.
	 * @method module:sfx.resume
	 * @param {Object3D} obj Object 3D
	 */
	exports.resume = function(obj) {
	    m_sfx.speaker_resume(obj);
	};

	/**
	 * Stop the speaker's looping playback.
	 * @method module:sfx.loop_stop
	 * @param {Object3D} obj Speaker object
	 * @param {number} [when=0] Delay after exec in seconds
	 * @param {boolean} [wait=false] Wait loop until currently played cycle is
	 * finished
	 */
	exports.loop_stop = function(obj, when, wait) {
	    when = when || 0;
	    wait = wait || false;
	    m_sfx.loop_stop(obj, when, wait);
	};


	/**
	 * Change the speaker playback rate value.
	 * @method module:sfx.playrate
	 * @param {Object3D} obj Object 3D
	 * @param {number} playrate Playback rate (1.0 - normal speed).
	 */
	exports.playrate = function(obj, playrate) {
	    m_sfx.playrate(obj, playrate);
	};

	/**
	 * Get the speaker playback rate value.
	 * @method module:sfx.playrate
	 * @param {Object3D} obj Object 3D
	 * @returns {number} Playback rate
	 */
	exports.get_playrate = function(obj) {
	    return m_sfx.get_playrate(obj);
	};

	/**
	 * Set cyclic flag.
	 * @method module:sfx.cyclic
	 * @param {Object3D} obj Speaker object.
	 * @param {boolean} cyclic New cyclic flag value.
	 */
	exports.cyclic = function(obj, cyclic) {
	    m_sfx.cyclic(obj, cyclic);
	};

	/**
	 * Check if the cyclic flag is set.
	 * @method module:sfx.is_cyclic
	 * @param {Object3D} obj Speaker object.
	 * @returns {boolean} Cyclic flag value.
	 */
	exports.is_cyclic = function(obj) {
	    return m_sfx.is_cyclic(obj);
	};

	/**
	 * Reset the listener speed.
	 * Use before rapid listener movements to neutralize undesirable doppler effect.
	 * @method module:sfx.listener_reset_speed
	 * @param {number} speed The listener new speed
	 * @param {?Float32Array} [dir=null] The listener new direction
	 * @deprecated Use {@link module:sfx.listener_stride|sfx.listener_stride} instead
	 */
	exports.listener_reset_speed = function(speed, dir) {
	    m_sfx.listener_stride();
	};

	/**
	 * Make a listener stride.
	 * Use before quick listener movements to neutralize undesirable doppler effect.
	 * @method module:sfx.listener_stride
	 */
	exports.listener_stride = function() {
	    m_sfx.listener_stride();
	};

	/**
	 * Reset the speaker speed.
	 * It's necessary to nullify speed before the speaker has moved quickly in order
	 * to neutralize the undesirable doppler effect.
	 * @method module:sfx.speaker_reset_speed
	 * @param {Object3D} obj Speaker object.
	 * @param {number} speed The speaker's new speed
	 * @param {?Float32Array} [dir=null] The speaker's new direction
	 * @deprecated Use {@link module:sfx.speaker_stride|sfx.speaker_stride} instead
	 */
	exports.speaker_reset_speed = function(obj, speed, dir) {
	    m_sfx.speaker_stride(obj);
	};

	/**
	 * Make a speaker stride.
	 * Use before rapid speaker movements to neutralize undesirable doppler effect.
	 * @method module:sfx.speaker_reset_speed
	 * @param {Object3D} obj Speaker object.
	 */
	exports.speaker_stride = function(obj) {
	    m_sfx.speaker_stride(obj);
	};

	/**
	 * Get volume level.
	 * @method module:sfx.get_volume
	 * @param {?Object3D} obj Object 3D or null for MASTER volume
	 * @returns {number} Volume (0..1)
	 */
	exports.get_volume = function(obj) {
	    if (obj && typeof obj === "object")
	        return m_sfx.get_volume(obj);
	    else
	        return m_sfx.get_master_volume();
	};
	/**
	 * Set volume level.
	 * @method module:sfx.set_volume
	 * @param {?Object3D} obj Object 3D or null for MASTER volume
	 * @param {number} volume Volume (0..1)
	 */
	exports.set_volume = function(obj, volume) {
	    if (obj && typeof obj === "object")
	        m_sfx.set_volume(obj, volume);
	    else
	        m_sfx.set_master_volume(volume);
	};

	/**
	 * Mute/unmute.
	 * @method module:sfx.mute
	 * @param {?Object3D} obj Speaker object or null to mute the whole scene.
	 * @param {boolean} muted New state
	 */
	exports.mute = function(obj, muted) {
	    if (obj && typeof obj === "object")
	        m_sfx.mute(obj, muted);
	    else
	        m_sfx.mute_master(muted);
	};

	/**
	 * Check if the speaker is muted.
	 * @method module:sfx.is_muted
	 * @param {?Object3D} obj Speaker object or null for the whole scene.
	 * @returns {boolean} Muted state.
	 */
	exports.is_muted = function(obj) {
	    if (obj && typeof obj === "object")
	        return m_sfx.is_muted(obj);
	    else
	        return m_sfx.is_master_muted();
	};

	/**
	 * Get the speaker objects which are used by the module.
	 * @returns {Array} Speaker object array
	 */
	exports.get_speaker_objects = function() {
	    return m_sfx.get_speaker_objects().slice(0);
	};

	/**
	 * Check if there are some active speakers in use or not.
	 * @method module:sfx.check_active_speakers
	 * @returns {boolean} Check result
	 */
	exports.check_active_speakers = m_sfx.check_active_speakers;

	/**
	 * Set compressor params.
	 * @method module:sfx.set_compressor_params
	 * @param {CompressorParams} params Params object
	 * @cc_externs threshold knee ratio attack release
	 */
	exports.set_compressor_params = function(params) {
	    m_sfx.set_compressor_params(m_scs.get_active(), params);
	};
	/**
	 * Get compressor params.
	 * @method module:sfx.get_compressor_params
	 * @returns {CompressorParams} Params object
	 */
	exports.get_compressor_params = function() {
	    return m_sfx.get_compressor_params(m_scs.get_active());
	};

	/**
	 * Duck (reduce the volume).
	 * works independently from the volume API and the volume randomization
	 * @method module:sfx.duck
	 * @param {?Object3D} obj Object 3D or null for MASTER
	 * @param {number} value Duck amount.
	 * @param {number} time Time to change volume.
	 */
	exports.duck = function(obj, value, time) {
	    if (obj && typeof obj === "object")
	        m_sfx.duck(obj, value, time);
	    else
	        m_sfx.duck_master(value, time);
	};

	/**
	 * Unduck (restore the volume).
	 * @method module:sfx.unduck
	 * @param {?Object3D} obj Object 3D or null for MASTER
	 */
	exports.unduck = function(obj) {
	    if (obj && typeof obj === "object")
	        m_sfx.unduck(obj);
	    else
	        m_sfx.unduck_master();
	};

	/**
	 * Apply the new playlist from the given set of speakers.
	 * The new playlist starts playing immediately.
	 * @method module:sfx.apply_playlist
	 * @param {Object3D[]} objs Array of objects.
	 * @param {number} delay Number of seconds between tracks
	 * @param {boolean} random Randomize playback sequence
	 */
	exports.apply_playlist = m_sfx.apply_playlist;
	/**
	 * Stop playback and clear the playlist.
	 * @method module:sfx.clear_playlist
	 */
	exports.clear_playlist = m_sfx.clear_playlist;

	/**
	 * Detect supported audio container.
	 * Containers have same meaning as file extension here, for each one possible
	 * fallback exists:
	 * <ul>
	 * <li>ogg -> mp4
	 * <li>mp3 -> ogg
	 * <li>mp4 -> ogg
	 * </ul>
	 * @method module:sfx.detect_audio_container
	 * @param {string} [hint="ogg"] Required container
	 * @returns {string} Supported container or ""
	 */
	exports.detect_audio_container = m_sfx.detect_audio_container;
	/**
	 * Detect supported video container.
	 * Containers have same meaning as file extension here, for each one possible
	 * fallback exists:
	 * <ul>
	 * <li>ogv -> m4v
	 * <li>m4v -> webm
	 * <li>webm -> m4v
	 * </ul>
	 * @method module:sfx.detect_video_container
	 * @param {string} [hint="webm"] Required container
	 * @returns {string} Supported container or ""
	 */
	exports.detect_video_container = m_sfx.detect_video_container;
	/**
	 * Set positional params.
	 * @method module:sfx.set_positional_params
	 * @param {Object3D} obj Object 3D
	 * @param {PositionalParams} params Params object
	 * @cc_externs dist_ref dist_max attenuation
	 */
	exports.set_positional_params = m_sfx.set_positional_params;
	/**
	 * Get positional params.
	 * @method module:sfx.get_positional_params
	 * @param {Object3D} obj Object 3D
	 * @returns {PositionalParams} Params object
	 */
	exports.get_positional_params = m_sfx.get_positional_params;

	/**
	 * Set filter params.
	 * @method module:sfx.set_filter_params
	 * @param {Object3D} obj Object 3D
	 * @param {FilterParams} params Params object
	 * @cc_externs freq Q gain
	 */
	exports.set_filter_params = m_sfx.set_filter_params;
	/**
	 * Get filter params.
	 * @method module:sfx.get_filter_params
	 * @param {Object3D} obj Object 3D
	 * @returns {FilterParams} Params object
	 */
	exports.get_filter_params = m_sfx.get_filter_params;

	/**
	 * Get filter frequency response.
	 * @method module:sfx.get_filter_freq_response
	 * @param {Object3D} obj Object 3D
	 * @param {Float32Array} freq_arr Input array with frequencies.
	 * @param {Float32Array} mag_arr Output array with filter response magnitudes.
	 * @param {Float32Array} phase_arr Output array with filter response phases.
	 */
	exports.get_filter_freq_response = m_sfx.get_filter_freq_response;

	/**
	 * Get duration of the speaker's playback cycle.
	 * Zero duration means looped or non-ready speaker
	 * @method module:sfx.get_duration
	 * @param {?Object3D} obj Speaker object.
	 * @returns {number} Duration
	 */
	exports.get_duration = function(obj) {
	    if (!obj || !m_obj_util.is_speaker(obj)) {
	        m_print.error("Object \"" + (obj ? obj.name : undefined) +
	                      "\" is not a valid speaker");
	        return 0;
	    }
	    return m_sfx.get_duration(obj);
	};

	}

	var sfx_factory = register("sfx", SFX);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Audio mixer add-on.
	 * Implements volume faders, positional params, parametric equalizers per
	 * channel and volume fader and compressor to the master section.
	 * @module mixer
	 */
	function Mixer(ns, exports) {

	var m_ctl    = controls_factory(ns);
	var m_scenes = scenes_factory(ns);
	var m_screen = screen_factory(ns);
	var m_sfx    = sfx_factory(ns);
	var m_util   = util_factory(ns);

	var TIMER_SLOW_PERIOD = 0.15;
	var TIMER_FAST_PERIOD = 0.05;

	var MIXER_CONTROLS_MANIFOLD = ["SWITCH_STRIP", "SWITCH_STRIP_HOLD",
	        "SWITCH_PARAM", "INC_DEC", "INC_DEC_HOLD", "MUTE_SOLO"];

	var _mixer_strips = [];
	var _active_strip = 0;

	var _filter_freq_arr = null;
	var _filter_mag_arr = null;
	var _filter_phase_arr = null;

	/**
	 * Enable mixer controls.
	 */
	exports.enable_mixer_controls = function() {
	    init();

	    // switch mixer strip
	    var key_num_left = m_ctl.create_keyboard_sensor(m_ctl.KEY_NUM4);
	    var key_num_right = m_ctl.create_keyboard_sensor(m_ctl.KEY_NUM6);

	    // switch mixer param
	    var key_num_up = m_ctl.create_keyboard_sensor(m_ctl.KEY_NUM8);
	    var key_num_down = m_ctl.create_keyboard_sensor(m_ctl.KEY_NUM2);

	    // change mixer param value
	    var key_num_add = m_ctl.create_keyboard_sensor(m_ctl.KEY_ADD);
	    var key_num_sub = m_ctl.create_keyboard_sensor(m_ctl.KEY_SUB);

	    // mute-solo
	    var key_num_home = m_ctl.create_keyboard_sensor(m_ctl.KEY_NUM7);
	    var key_num_pgup = m_ctl.create_keyboard_sensor(m_ctl.KEY_NUM9);

	    var timer_slow = m_ctl.create_timer_sensor(TIMER_SLOW_PERIOD, true);
	    var timer_fast = m_ctl.create_timer_sensor(TIMER_FAST_PERIOD, true);

	    var switch_strip_keys = [key_num_left, key_num_right, timer_slow];

	    var switch_strip_logic = function(s) {
	        return (s[0] || s[1]);
	    };
	    var switch_strip_logic_hold = function(s) {
	        return ((s[0] || s[1]) && s[2]);
	    };

	    var switch_spk_cb = function(obj, id, pulse) {
	        if (pulse == 1) {
	            var dir = Boolean(m_ctl.get_sensor_value(obj, id, 0)) ? -1 : 1;
	            switch_strip(dir);
	            if (id == "SWITCH_STRIP")
	                m_ctl.reset_timer_sensor(obj, id, 2, TIMER_SLOW_PERIOD + 0.3);
	            else
	                m_ctl.reset_timer_sensor(obj, id, 2, TIMER_SLOW_PERIOD);
	        } else {
	            // hold on some time
	            m_ctl.reset_timer_sensor(obj, id, 2, 10);
	        }
	    };
	    m_ctl.create_sensor_manifold(null, "SWITCH_STRIP", m_ctl.CT_TRIGGER, 
	            switch_strip_keys, switch_strip_logic, switch_spk_cb);
	    m_ctl.create_sensor_manifold(null, "SWITCH_STRIP_HOLD", m_ctl.CT_SHOT, 
	            switch_strip_keys, switch_strip_logic_hold, switch_spk_cb);

	    var switch_param_keys = [key_num_up, key_num_down];
	    var switch_param_logic = function(s) {
	        return (s[0] || s[1]);
	    };
	    var switch_param_cb = function(obj, id, pulse) {
	        var dir = Boolean(m_ctl.get_sensor_value(obj, id, 0)) ? -1 : 1;
	        switch_param(dir);
	    };
	    m_ctl.create_sensor_manifold(null, "SWITCH_PARAM", m_ctl.CT_SHOT, 
	            switch_param_keys, switch_param_logic, switch_param_cb);

	    var inc_dec_keys = [key_num_sub, key_num_add, timer_fast];

	    var inc_dec_cb = function(obj, id, pulse) {

	        if (pulse == 1) {
	            var dir = Boolean(m_ctl.get_sensor_value(obj, id, 0)) ? -1 : 1;
	            param_inc_dec(dir);

	            if (id == "INC_DEC")
	                m_ctl.reset_timer_sensor(obj, id, 2, TIMER_FAST_PERIOD + 0.3);
	            else
	                m_ctl.reset_timer_sensor(obj, id, 2, TIMER_FAST_PERIOD);
	        } else {
	            // hold on some time
	            m_ctl.reset_timer_sensor(obj, id, 2, 10);
	        }
	    };
	    var inc_dec_logic = function(s) {
	        return (s[0] || s[1]);
	    };
	    var inc_dec_logic_hold = function(s) {
	        return ((s[0] || s[1]) && s[2]);
	    };
	    m_ctl.create_sensor_manifold(null, "INC_DEC", m_ctl.CT_TRIGGER, 
	            inc_dec_keys, inc_dec_logic, inc_dec_cb);
	    m_ctl.create_sensor_manifold(null, "INC_DEC_HOLD", m_ctl.CT_SHOT, 
	            inc_dec_keys, inc_dec_logic_hold, inc_dec_cb);

	    var mute_solo_keys = [key_num_home, key_num_pgup];  

	    var mute_solo_cb = function(obj, id, pulse) {
	        var mute_solo = Boolean(m_ctl.get_sensor_value(obj, id, 0));
	        if (mute_solo)
	            switch_mute();
	        else
	            switch_solo();
	    };
	    var mute_solo_logic = function(s) {
	        return (s[0] || s[1]);
	    };
	    m_ctl.create_sensor_manifold(null, "MUTE_SOLO", m_ctl.CT_SHOT,
	            mute_solo_keys, mute_solo_logic, mute_solo_cb);

	    var elapsed = m_ctl.create_elapsed_sensor();

	    m_ctl.create_sensor_manifold(null, "MIXER_DRAW", m_ctl.CT_CONTINUOUS,
	        [elapsed], null, function() {draw();});

	    var timer = m_ctl.create_timer_sensor(1, true);
	    m_ctl.create_sensor_manifold(null, "MIXER_UPDATE", m_ctl.CT_TRIGGER,
	            [timer], null, function() {
	        var strip_range = active_strip_range();
	        for (var i = strip_range[0]; i <= strip_range[1]; i++)
	            update_strip_params(_mixer_strips[i]);
	    });
	};

	/**
	 * Disable mixer controls.
	 */
	exports.disable_mixer_controls = function() {
	    for (var i = 0; MIXER_CONTROLS_MANIFOLD.length; i++)
	        m_ctl.remove_sensor_manifold(null, MIXER_CONTROLS_MANIFOLD[i]);
	};

	/**
	 * Initialize mixer
	 */
	function init() {
	    _mixer_strips.length = 0;
	    _active_strip = 0;

	    _filter_freq_arr = gen_freq_arr(100);
	    _filter_mag_arr = new Float32Array(_filter_freq_arr.length);
	    _filter_phase_arr = new Float32Array(_filter_freq_arr.length);

	    var speakers = m_sfx.get_speaker_objects();
	    if (!speakers.length)
	        return;

	    _mixer_strips.push(create_master_strip());

	    for (var i = 0; i < speakers.length; i++) {
	        var spk = speakers[i];
	        _mixer_strips.push(create_speaker_strip(spk));
	    }

	    // special strips first, then by name
	    _mixer_strips.sort(function(a,b) {
	        if (a.id == "MASTER")
	            return -1;
	        else if (b.id == "MASTER")
	            return 1;
	        else if (a.id == "COMPRESSOR")
	            return -1;
	        else if (b.id == "COMPRESSOR")
	            return 1;
	        else if (a.id.toUpperCase() < b.id.toUpperCase())
	            return -1;
	        else if (a.id.toUpperCase() > b.id.toUpperCase())
	            return 1;
	        else
	            return 0;
	    });
	}

	function gen_freq_arr(steps) {
	    var FMIN = 20;
	    var FMAX = 20000;

	    var freq_arr = new Float32Array(steps);

	    var freq_base = FMAX/FMIN;
	    var freq_pow = 0;

	    for (var i = 0; i < steps; i++) {
	        freq_arr[i] = FMIN * Math.pow(freq_base, freq_pow);
	        freq_pow += 1 / (steps - 1);
	    }

	    return freq_arr;
	}

	function create_master_strip() {
	    var strip = init_strip("MASTER");

	    var cparams = m_sfx.get_compressor_params();
	    if (cparams) {
	        strip.params.push(["THRESHOLD", cparams["threshold"], -100, 0, 100, false]);
	        strip.params.push(["KNEE", cparams["knee"], 0, 40, 40, false]);
	        strip.params.push(["RATIO", cparams["ratio"], 1, 20, 20, false]);
	        strip.params.push(["ATTACK", cparams["attack"], 0, 1, 1000, false]);
	        strip.params.push(["RELEASE", cparams["release"], 0, 1, 1000, false]);
	    }

	    strip.params.push(["VOLUME", m_sfx.get_volume(null), 0, 1, 50, false]);

	    strip.mute = m_sfx.is_muted(null) ? 1 : 0;
	    strip.solo = -1;

	    return strip;
	}

	function init_strip(id) {
	    return {
	        id : id,
	        params : [],
	        active_param : 0,
	        mute: -1,
	        solo: -1,
	        speaker: null
	    }
	}

	function create_speaker_strip(spk) {
	    var strip = init_strip(m_scenes.get_object_name(spk));
	    strip.mute = m_sfx.is_muted(spk) ? 1 : 0;
	    strip.solo = 0;
	    strip.speaker = spk;
	    return strip;
	}

	function switch_strip(dir) {
	    if (!_mixer_strips.length)
	        return;

	    if (dir == 1 && _active_strip < (_mixer_strips.length - 1)) {
	        _active_strip++;
	    } else if (dir == -1 && _active_strip > 0) {
	        _active_strip--;
	    }

	    var strip_range = active_strip_range();
	    for (var i = strip_range[0]; i <= strip_range[1]; i++)
	        update_strip_params(_mixer_strips[i]);
	}

	function update_strip_params(strip) {

	    if (!strip.speaker)
	        return;

	    // cleanup
	    strip.params.length = 0;

	    var pparams = m_sfx.get_positional_params(strip.speaker);
	    if (pparams) {
	        strip.params.push(["DIST_REF", pparams["dist_ref"], 0, 1000, 10000, false]);
	        strip.params.push(["ATTENUATION", pparams["attenuation"], 0, 50, 1000, false]);
	        strip.params.push(["DIST_MAX", pparams["dist_max"], 0, 10000, 10000, false]);
	    }

	    var fparams = m_sfx.get_filter_params(strip.speaker);
	    if (fparams) {
	        strip.params.push(["EQ_FREQ", fparams["freq"], 20, 20000, 100, true]);
	        strip.params.push(["EQ_Q", fparams["Q"], 0, 10, 100, false]);
	        strip.params.push(["EQ_GAIN", fparams["gain"], -70, 30, 100, false]);
	    }

	    strip.params.push(["VOLUME", m_sfx.get_volume(strip.speaker), 0, 1, 50, false]);

	    // handle params decrease
	    m_util.clamp(strip.active_param, 0, strip.params.length - 1);
	}

	function switch_param(dir) {
	    var strip = _mixer_strips[_active_strip];
	    if (!strip)
	        return;

	    if (dir == 1 && strip.active_param < (strip.params.length - 1)) {
	        strip.active_param++;
	    } else if (dir == -1 && strip.active_param > 0) {
	        strip.active_param--;
	    }
	}

	function param_inc_dec(dir) {
	    var strip = _mixer_strips[_active_strip];
	    if (!strip)
	        return;

	    var param = strip.params[strip.active_param];

	    if (param[5])
	        param[1] *= Math.pow(param[3] / param[2], dir / param[4]);
	    else
	        param[1] += dir * ((param[3] - param[2]) / param[4]);

	    param[1] = m_util.clamp(param[1], param[2], param[3]);

	    switch (param[0]) {
	    case "VOLUME":
	        if (strip.id != "MASTER")
	            m_sfx.set_volume(strip.speaker, param[1]);
	        else
	            m_sfx.set_volume(null, param[1]);
	        break;
	    case "DIST_REF":
	        var pparams = m_sfx.get_positional_params(strip.speaker);
	        pparams["dist_ref"] = param[1];
	        m_sfx.set_positional_params(strip.speaker, pparams);
	        break;
	    case "ATTENUATION":
	        var pparams = m_sfx.get_positional_params(strip.speaker);
	        pparams["attenuation"] = param[1];
	        m_sfx.set_positional_params(strip.speaker, pparams);
	        break;
	    case "DIST_MAX":
	        var pparams = m_sfx.get_positional_params(strip.speaker);
	        pparams["dist_max"] = param[1];
	        m_sfx.set_positional_params(strip.speaker, pparams);
	        break;

	    case "EQ_FREQ":
	        var fparams = m_sfx.get_filter_params(strip.speaker);
	        fparams["freq"] = param[1];
	        m_sfx.set_filter_params(strip.speaker, fparams);
	        break;
	    case "EQ_Q":
	        var fparams = m_sfx.get_filter_params(strip.speaker);
	        fparams["Q"] = param[1];
	        m_sfx.set_filter_params(strip.speaker, fparams);
	        break;
	    case "EQ_GAIN":
	        var fparams = m_sfx.get_filter_params(strip.speaker);
	        fparams["gain"] = param[1];
	        m_sfx.set_filter_params(strip.speaker, fparams);
	        break;

	    case "THRESHOLD":
	        var cparams = m_sfx.get_compressor_params();
	        cparams["threshold"] = param[1];
	        m_sfx.set_compressor_params(cparams);
	        break;
	    case "KNEE":
	        var cparams = m_sfx.get_compressor_params();
	        cparams["knee"] = param[1];
	        m_sfx.set_compressor_params(cparams);
	        break;
	    case "RATIO":
	        var cparams = m_sfx.get_compressor_params();
	        cparams["ratio"] = param[1];
	        m_sfx.set_compressor_params(cparams);
	        break;
	    case "ATTACK":
	        var cparams = m_sfx.get_compressor_params();
	        cparams["attack"] = param[1];
	        m_sfx.set_compressor_params(cparams);
	        break;
	    case "RELEASE":
	        var cparams = m_sfx.get_compressor_params();
	        cparams["release"] = param[1];
	        m_sfx.set_compressor_params(cparams);
	        break;
	    default:
	        // TODO: fix
	        m_util.panic("Unknown strip param");
	        break;
	    }
	}

	function switch_mute() {
	    var strip = _mixer_strips[_active_strip];
	    if (!strip)
	        return;

	    if (strip.mute >= 0) {
	        flip_strip_mute(strip);
	    }
	}

	function flip_strip_mute(strip) {
	    var id = strip.id;

	    if (id != "MASTER") {
	        if (strip.mute == 0) {
	            strip.mute = 1;

	            m_sfx.mute(strip.speaker, true);

	            if (strip.solo == 1) {
	                strip.solo = 0;

	                if (!is_other_solo(strip))
	                    unmute_other(strip);
	            }
	        } else {
	            strip.mute = 0;

	            if (!is_other_solo(strip))
	                m_sfx.mute(strip.speaker, false);
	        }
	    } else {
	        if (strip.mute == 0) {
	            strip.mute = 1;
	            m_sfx.mute(null, true);
	        } else {
	            strip.mute = 0;
	            m_sfx.mute(null, false);
	        }
	    }
	}

	function is_other_solo(strip) {
	    for (var i = 0; i < _mixer_strips.length; i++) {
	        var strip_i = _mixer_strips[i];

	        if (strip_i != strip && strip_i.solo == 1)
	            return true;
	    }
	    return false;
	}

	function mute_other(strip) {
	    for (var i = 0; i < _mixer_strips.length; i++) {
	        var strip_i = _mixer_strips[i];

	        if (strip_i != strip && strip_i.mute == 0 && strip_i.solo == 0)
	            m_sfx.mute(strip_i.speaker, true);
	    }
	}

	function unmute_other(strip) {
	    for (var i = 0; i < _mixer_strips.length; i++) {
	        var strip_i = _mixer_strips[i];

	        if (strip_i != strip && strip_i.mute == 0 && strip_i.solo == 0)
	            m_sfx.mute(strip_i.speaker, false);
	    }
	}

	function switch_solo() {
	    var strip = _mixer_strips[_active_strip];
	    if (!strip)
	        return;

	    if (strip.solo >= 0) {
	        flip_strip_solo(strip);
	    }
	}

	function flip_strip_solo(strip) {

	    if (strip.solo == 0) {
	        strip.solo = 1;

	        m_sfx.mute(strip.speaker, false);

	        // flip muted current
	        if (strip.mute == 1)
	            strip.mute = 0;

	        mute_other(strip);

	    } else {
	        strip.solo = 0;

	        if (is_other_solo(strip))
	            m_sfx.mute(strip.speaker, true);
	        else
	            unmute_other(strip);
	    }
	}

	function draw() {
	    if (!_mixer_strips[_active_strip])
	        return;

	    var strip_range = active_strip_range();

	    for (var i = strip_range[0]; i <= strip_range[1]; i++) {

	        var strip = _mixer_strips[i];

	        m_screen.draw_mixer_strip(strip.id, i == _active_strip, i % 8,
	                strip.params, strip.active_param, strip.mute, strip.solo);

	        if (strip.speaker && m_sfx.get_filter_params(strip.speaker)) {
	            m_sfx.get_filter_freq_response(strip.speaker, _filter_freq_arr,
	                    _filter_mag_arr, _filter_phase_arr);

	            for (var j = 0; j < _filter_mag_arr.length; j++) {
	                var mag = _filter_mag_arr[j];
	                // log10()
	                _filter_mag_arr[j] = 20 * Math.log(mag) / Math.LN10;
	            }

	            m_screen.plot_array("EQ", i % 8, _filter_mag_arr, 20, 20000, -10, 10);
	        }
	    }
	}

	function active_strip_range() {

	    if (_mixer_strips.length == 0)
	        return [0, -1];

	    var strip_low = Math.floor(_active_strip / 8) * 8;
	    var strip_high = strip_low + 7;

	    strip_low = m_util.clamp(strip_low, 0, _mixer_strips.length-1);
	    strip_high = m_util.clamp(strip_high, 0, _mixer_strips.length-1);

	    return [strip_low, strip_high];
	}

	}

	var mixer_factory = register("mixer", Mixer);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Pointer lock and mouse actions add-on.
	 * Provides support for mouse pointer lock and low-level movement.
	 * For more generic cases use {@link module:controls|sensor-based API}.
	 * @see http://www.w3.org/TR/pointerlock/
	 * @module mouse
	 * @local UseMouseControlCallback
	 * @local PointerlockEnabledCallback
	 * @local PointerlockDisabledCallback
	 * @local PointerlockMouseMoveCallback
	 * @local RotationCallback
	 */
	function Mouse(ns, exports) {

	var m_cam   = camera_factory(ns);
	var m_cont  = container_factory(ns);
	var m_ctl   = controls_factory(ns);
	var m_phy   = physics_factory(ns);
	var m_print = print_factory(ns);
	var m_scs   = scenes_factory(ns);
	var m_util  = util_factory(ns);
	var m_main  = main_factory(ns);

	var FPS_MOUSE_MULT = 0.0004;
	var DRAG_MOUSE_DELTA_MULT = 2;

	var _smooth_factor = 1;
	var CAM_SMOOTH_CHARACTER_MOUSE = 0.1;
	var PLS_NONE = 0;
	var PLS_POINTERLOCK = 1;
	var PLS_DRAG = 2;

	// mouse drag control
	var _mouse_x = 0;
	var _mouse_y = 0;

	var _mouse_delta = new Float32Array(2);

	var _vec2_tmp = new Float32Array(2);

	var _use_mouse_control_cb = null;

	var _chosen_object = null;

	var _plock_state = PLS_NONE;

	var _hover_offset = false;
	var _drag_offset = false;

	/**
	 * Callback which allows user to specify whether the camera/character movement
	 * is controlled by mouse module or not.
	 * @callback UseMouseControlCallback
	 * @returns {boolean} False to disable mouse control of active camera/character
	 */

	/**
	 * Callback which will be executed when pointer lock is enable.
	 * @callback PointerlockEnabledCallback
	 */

	/**
	 * Callback which will be executed when pointer lock is disabled.
	 * @callback PointerlockDisabledCallback
	 */

	/**
	 * Mouse movement event callback
	 * @callback PointerlockMouseMoveCallback
	 * @param {MouseEvent} e mousemove event
	 */

	/**
	 * Callback for camera/characters rotation
	 * @callback RotationCallback
	 * @param {rot_x} x rotation around X-axis
	 * @param {rot_y} y rotation around Y-axis
	 */

	/**
	 * Request pointer lock mode.
	 * Security issues: execute by user event.
	 * @method module:mouse.request_pointerlock
	 * @param {HTMLElement} elem Element
	 * @param {PointerlockEnabledCallback} [enabled_cb] Enabled callback
	 * @param {PointerlockDisabledCallback} [disabled_cb] Disabled callback
	 * @param {PointerlockMouseMoveCallback} [mouse_move_cb] Mouse movement event callback
	 * @param {UseMouseControlCallback} [use_mouse_control_cb] Callback to check the camera/character control
	 * @param {RotationCallback} [rotation_cb] Callback for camera rotation. If not specified, the default one will be used.
	 */
	exports.request_pointerlock = function(elem, enabled_cb, disabled_cb,
	        mouse_move_cb, use_mouse_control_cb, rotation_cb) {

	    if (_plock_state == PLS_POINTERLOCK)
	        return;
	    _plock_state = PLS_POINTERLOCK;

	    enabled_cb  = enabled_cb  || function() {};
	    disabled_cb = disabled_cb || function() {};
	    rotation_cb = rotation_cb || default_rotation_cb;

	    use_mouse_control_cb = use_mouse_control_cb || function() {return true};

	    mouse_move_cb = mouse_move_cb || function(e) {
	        if (use_mouse_control_cb()) {
	            // NOTE: for compatibility with older browsers
	            if (typeof e.movementX == "number") {
	                var mx = e.movementX;
	                var my = e.movementY;
	            } else if (typeof e.webkitMovementX == "number") {
	                var mx = e.webkitMovementX;
	                var my = e.webkitMovementY;
	            } else if (typeof e.mozMovementX == "number") {
	                var mx = e.mozMovementX;
	                var my = e.mozMovementY;
	            } else {
	                var mx = 0;
	                var my = 0;
	            }

	            _mouse_delta[0] += mx;
	            _mouse_delta[1] += my;
	        }
	    };

	    function on_pointerlock_change() {
	        if (document.pointerLockElement === elem ||
	                document.webkitPointerLockElement === elem ||
	                document.mozPointerLockElement === elem) {
	            //m_print.log("Pointer Lock enabled");

	            exit_mouse_drag(elem);

	            elem.addEventListener("mousemove", mouse_move_cb, false);

	            var camera = m_scs.get_active_camera();

	            if (!m_ctl.check_sensor_manifold(camera, "SMOOTH_PL")) {
	                var elapsed = m_ctl.create_elapsed_sensor();

	                m_ctl.create_sensor_manifold(camera, "SMOOTH_PL", m_ctl.CT_CONTINUOUS,
	                    [elapsed], null, smooth_cb, rotation_cb);
	            }

	            enabled_cb();
	        } else {
	            //m_print.log("Pointer Lock disabled");
	            
	            elem.removeEventListener("mousemove", mouse_move_cb, false);

	            _plock_state = PLS_NONE;
	            document.removeEventListener("pointerlockchange", on_pointerlock_change, false);
	            document.removeEventListener("webkitpointerlockchange", on_pointerlock_change, false);
	            document.removeEventListener("mozpointerlockchange", on_pointerlock_change, false);

	            disabled_cb();
	        }
	    }

	    document.addEventListener("pointerlockchange", on_pointerlock_change, false);
	    document.addEventListener("webkitpointerlockchange", on_pointerlock_change, false);
	    document.addEventListener("mozpointerlockchange", on_pointerlock_change, false);

	    var request_plock = elem.requestPointerLock ||
	            elem.webkitRequestPointerLock || elem.mozRequestPointerLock;

	    if (typeof request_plock === "function")
	        request_plock.apply(elem);
	    else
	        m_print.error("Pointer lock is not available");
	};

	/**
	 * Exit the pointer lock mode.
	 * @method module:mouse.exit_pointerlock
	 */
	exports.exit_pointerlock = exit_pointerlock;
	function exit_pointerlock() {

	    if (_plock_state == PLS_POINTERLOCK)
	        _plock_state = PLS_NONE;

	    var exit_plock = document.exitPointerLock || document.webkitExitPointerLock ||
	        document.mozExitPointerLock;

	    if (typeof exit_plock === "function")
	        exit_plock.apply(document);

	    m_ctl.remove_sensor_manifold(m_scs.get_active_camera(), "SMOOTH_PL");
	}

	/**
	 * Check the pointer lock.
	 * @method module:mouse.check_pointerlock
	 * @param {HTMLElement} elem Element
	 * @returns {boolean} Check result
	 */
	exports.check_pointerlock = function(elem) {
	    var request_plock = elem.requestPointerLock ||
	            elem.webkitRequestPointerLock || elem.mozRequestPointerLock;

	    if (typeof request_plock === "function")
	        return true;
	    else
	        return false;
	};

	/**
	 * Request drag mode.
	 * @param {HTMLElement} elem Element
	 * @param {UseMouseControlCallback} [use_mouse_control_cb] Callback to check the mouse control
	 * @param {RotationCallback} [rotation_cb] Callback for camera rotation. If not specified, the default one will be used.
	 * @param {boolean} [relative_canvas=false] Calculate coordinates relative to canvas.
	 * @method module:mouse.request_mouse_drag
	 */
	exports.request_mouse_drag = request_mouse_drag;
	function request_mouse_drag(elem, use_mouse_control_cb, rotation_cb, relative_canvas) {

	    if (_plock_state == PLS_DRAG)
	        return;
	    _plock_state = PLS_DRAG;

	    exit_pointerlock();

	    _use_mouse_control_cb = use_mouse_control_cb || function() {return true};
	    rotation_cb = rotation_cb || default_rotation_cb;
	    _drag_offset = Boolean(relative_canvas);

	    elem.addEventListener("mousedown", drag_mouse_down_cb, false);
	    elem.addEventListener("mouseup",   drag_mouse_up_cb,   false);

	    var camera = m_scs.get_active_camera();

	    if (!m_ctl.check_sensor_manifold(camera, "SMOOTH_DRAG")) {
	        var elapsed = m_ctl.create_elapsed_sensor();

	        m_ctl.create_sensor_manifold(camera, "SMOOTH_DRAG", m_ctl.CT_CONTINUOUS,
	            [elapsed], null, smooth_cb, rotation_cb);
	    }
	}

	/**
	 * Exit drag mode.
	 * @param {HTMLElement} elem Element
	 * @method module:mouse.exit_mouse_drag
	 */
	exports.exit_mouse_drag = exit_mouse_drag;
	function exit_mouse_drag(elem) {
	    if (_plock_state == PLS_DRAG)
	        _plock_state = PLS_NONE;
	    elem.removeEventListener("mousedown", drag_mouse_down_cb, false);
	    elem.removeEventListener("mouseup",   drag_mouse_up_cb,   false);
	    elem.removeEventListener("mousemove", drag_mouse_move_cb, false);

	    m_ctl.remove_sensor_manifold(m_scs.get_active_camera(), "SMOOTH_DRAG");
	}

	function drag_mouse_move_cb(e) {
	    if (_use_mouse_control_cb()) {

	        if (_drag_offset)
	            var coords = m_cont.get_coords_target_space(e, _vec2_tmp);
	        else {
	            var coords = _vec2_tmp;
	            coords[0] = e.clientX;
	            coords[1] = e.clientY;
	        }
	        _mouse_delta[0] += (coords[0] - _mouse_x) * DRAG_MOUSE_DELTA_MULT;
	        _mouse_delta[1] += (coords[1] - _mouse_y) * DRAG_MOUSE_DELTA_MULT;

	        _mouse_x = coords[0];
	        _mouse_y = coords[1];
	    }
	    e.preventDefault();
	}

	function drag_mouse_down_cb(e) {
	    if (_drag_offset)
	        var coords = m_cont.get_coords_target_space(e, _vec2_tmp);
	    else {
	        var coords = _vec2_tmp;
	        coords[0] = e.clientX;
	        coords[1] = e.clientY;
	    }

	    _mouse_x = coords[0];
	    _mouse_y = coords[1];

	    e.currentTarget.addEventListener("mousemove", drag_mouse_move_cb, false);
	    e.preventDefault();
	}

	function drag_mouse_up_cb(e) {
	    e.currentTarget.removeEventListener("mousemove", drag_mouse_move_cb, false);
	    e.preventDefault();
	}

	function smooth_cb(obj, id, pulse, rot_callback) {
	    if (Math.abs(_mouse_delta[0]) > 0.01 || Math.abs(_mouse_delta[1]) > 0.01) {
	        var elapsed = m_ctl.get_sensor_value(obj, id, 0);
	        var rot_x = m_util.smooth(_mouse_delta[0], 0, elapsed, smooth_coeff_mouse());
	        var rot_y = m_util.smooth(_mouse_delta[1], 0, elapsed, smooth_coeff_mouse());
	        _mouse_delta[0] -= rot_x;
	        _mouse_delta[1] -= rot_y;

	        rot_callback(-rot_x * FPS_MOUSE_MULT, -rot_y * FPS_MOUSE_MULT);
	    }
	}

	function default_rotation_cb(rot_x, rot_y) {
	    var character = m_scs.get_first_character();
	    var camera    = m_scs.get_active_camera();
	    m_cam.rotate_camera(camera, rot_x, rot_y);
	    if (character) {
	        var angles = m_cam.get_camera_angles_char(camera, _vec2_tmp);
	        m_phy.set_character_rotation_h(character, angles[0]);
	        m_phy.set_character_vert_move_dir_angle(character, angles[1]);
	    }
	}
	/**
	 * Enable objects outlining by mouse hover.
	 * @param {boolean} [relative_canvas=false] Calculate coordinates relative to canvas.
	 * @method module:mouse.enable_mouse_hover_outline
	 */
	exports.enable_mouse_hover_outline = enable_mouse_hover_outline;
	function enable_mouse_hover_outline(relative_canvas) {
	    _hover_offset = Boolean(relative_canvas);
	    if (!m_main.detect_mobile()) {
	        var main_canvas = m_cont.get_canvas();
	        main_canvas.addEventListener("mousemove", objects_outline);
	    }
	}

	/**
	 * Disable objects outlining by mouse hover.
	 * @method module:mouse.disable_mouse_hover_outline
	 */
	exports.disable_mouse_hover_outline = disable_mouse_hover_outline;
	function disable_mouse_hover_outline() {
	    if (!m_main.detect_mobile()) {
	        var main_canvas = m_cont.get_canvas();
	        main_canvas.removeEventListener("mousemove", objects_outline);
	        if (_chosen_object)
	            m_scs.set_outline_intensity(_chosen_object, 0);
	    }
	}

	function objects_outline(e) {
	    if (_hover_offset) {
	        var c_coord = m_cont.get_coords_target_space(e, false, _vec2_tmp);
	        var obj = m_scs.pick_object(c_coord[0], c_coord[1]);
	    } else
	        var obj = m_scs.pick_object(e.clientX, e.clientY);

	    if (obj) {
	        if (m_scs.outlining_is_enabled(obj))
	            m_scs.set_outline_intensity(obj, 1);
	        if (m_scs.outlining_is_enabled(_chosen_object) && obj != _chosen_object)
	            m_scs.set_outline_intensity(_chosen_object, 0);
	    } else
	        if (m_scs.outlining_is_enabled(_chosen_object))
	            m_scs.set_outline_intensity(_chosen_object, 0);
	    _chosen_object = obj;
	}
	/**
	 * Get mouse/touch X coordinate.
	 * @param {MouseEvent|TouchEvent} event Mouse/touch event
	 * @param {boolean} [use_target_touches=false] Use only those touches that were 
	 * started on the event target element (the targetTouches property).
	 * @param {boolean} [relative_canvas=false] Return coordinates relative to event 
	 * target.
	 * @method module:mouse.get_coords_x
	 * @returns {number} Mouse/touch X coordinate or -1 if not defined.
	 * @example
	 * var m_cont = require("container");
	 * var m_input = require("input");
	 * var m_mouse = require("mouse");
	 *
	 * var canvas = m_cont.get_canvas();
	 * m_input.add_click_listener(canvas, function(event) {
	 *     var x = m_mouse.get_coords_x(event);
	 *     var y = m_mouse.get_coords_y(event);
	 * });
	 */
	exports.get_coords_x = get_coords_x;
	function get_coords_x(event, use_target_touches, relative_canvas) {

	    if (relative_canvas)
	        return m_cont.get_coords_target_space(event, use_target_touches, 
	                _vec2_tmp)[0];
	    
	    if ("clientX" in event)
	        return event.clientX;

	    if (event.type == "touchend")
	        var touches = event.changedTouches;
	    else
	        var touches = use_target_touches ? event.targetTouches : event.touches;
	    
	    if (touches && touches[0] && "clientX" in touches[0])
	        return touches[0].clientX;

	    return -1;
	}
	/**
	 * Get mouse/touch Y coordinate.
	 * @param {MouseEvent|TouchEvent} event Mouse/touch event
	 * @param {boolean} [use_target_touches=false] Use only those touches that were 
	 * started on the event target element (the targetTouches property).
	 * @param {boolean} [relative_canvas=false] Return coordinates relative to event 
	 * target.
	 * @method module:mouse.get_coords_y
	 * @returns {number} Mouse/touch Y coordinate or -1 if not defined.
	 * @example
	 * var m_cont = require("container");
	 * var m_input = require("input");
	 * var m_mouse = require("mouse");
	 *
	 * var canvas = m_cont.get_canvas();
	 * m_input.add_click_listener(canvas, function(event) {
	 *     var x = m_mouse.get_coords_x(event);
	 *     var y = m_mouse.get_coords_y(event);
	 * });
	 */
	exports.get_coords_y = get_coords_y;
	function get_coords_y(event, use_target_touches, relative_canvas) {

	    if (relative_canvas)
	        return m_cont.get_coords_target_space(event, use_target_touches, 
	                _vec2_tmp)[1];
	    
	    if ("clientY" in event)
	        return event.clientY;

	    if (event.type == "touchend")
	        var touches = event.changedTouches;
	    else
	        var touches = use_target_touches ? event.targetTouches : event.touches;
	    
	    if (touches && touches[0] && "clientY" in touches[0])
	        return touches[0].clientY;

	    return -1;
	}

	function smooth_coeff_mouse() {
	    return CAM_SMOOTH_CHARACTER_MOUSE * _smooth_factor;
	}

	exports.set_plock_smooth_factor = function(value) {
	    _smooth_factor = value;
	};

	/**
	 * Get smooth factor for camera rotation while in pointerlock mode.
	 * @method module:mouse.get_plock_smooth_factor
	 * @returns {number} Smooth factor
	 */
	exports.get_plock_smooth_factor = function() {
	    return _smooth_factor;
	};

	}

	var mouse_factory = register("mouse", Mouse);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * API methods for animation.
	 * @see https://www.blend4web.com/doc/en/animation.html
	 * @module animation
	 * @local AnimFinishCallback
	 * @local AnimBehavior
	 * @local AnimType
	 * @local AnimSlot
	 */
	function Animation(ns, exports) {

	var m_anim  = int_animation_factory(ns);
	var m_obj_util = int_obj_util_factory(ns);
	var m_print = print_factory(ns);

	/**
	 * Animation finish callback.
	 * @callback AnimFinishCallback
	 * @param {Object3D} obj Animated object.
	 * @param {AnimSlot} slot_num Animation slot.
	 */

	/**
	 * Animation blending finish callback.
	 * @callback AnimBlendingCallback
	 */

	/**
	 * Animation behavior enum.
	 * @see {@link module:animation.AB_CYCLIC},
	 * {@link module:animation.AB_FINISH_RESET},
	 * {@link module:animation.AB_FINISH_STOP}
	 * @typedef {number} AnimBehavior
	 */

	/**
	 * Animation type enum. One of OBJ_ANIM_TYPE_*.
	 * @typedef {number} AnimType
	 */

	/**
	 * Animation slot enum. One of SLOT_*.
	 * @typedef {number} AnimSlot
	 */

	/**
	 * Object's animation slot 0.
	 * @const {AnimSlot} module:animation.SLOT_0
	 */
	exports.SLOT_0   = m_anim.SLOT_0;

	/**
	 * Object's animation slot 1.
	 * @const {AnimSlot} module:animation.SLOT_1
	 */
	exports.SLOT_1   = m_anim.SLOT_1;

	/**
	 * Object's animation slot 2.
	 * @const {AnimSlot} module:animation.SLOT_2
	 */
	exports.SLOT_2   = m_anim.SLOT_2;

	/**
	 * Object's animation slot 3.
	 * @const {AnimSlot} module:animation.SLOT_3
	 */
	exports.SLOT_3   = m_anim.SLOT_3;

	/**
	 * Object's animation slot 4.
	 * @const {AnimSlot} module:animation.SLOT_4
	 */
	exports.SLOT_4   = m_anim.SLOT_4;

	/**
	 * Object's animation slot 5.
	 * @const {AnimSlot} module:animation.SLOT_5
	 */
	exports.SLOT_5   = m_anim.SLOT_5;

	/**
	 * Object's animation slot 6.
	 * @const {AnimSlot} module:animation.SLOT_6
	 */
	exports.SLOT_6   = m_anim.SLOT_6;

	/**
	 * Object's animation slot 7.
	 * @const {AnimSlot} module:animation.SLOT_7
	 */
	exports.SLOT_7   = m_anim.SLOT_7;

	/**
	 * All object's animation slots.
	 * @const {AnimSlot} module:animation.SLOT_ALL
	 */
	exports.SLOT_ALL = m_anim.SLOT_ALL;

	/**
	 * Animation type: none.
	 * @const {AnimType} module:animation.OBJ_ANIM_TYPE_NONE
	 */
	exports.OBJ_ANIM_TYPE_NONE      = m_anim.OBJ_ANIM_TYPE_NONE;

	/**
	 * Animation type: armature.
	 * @const {AnimType} module:animation.OBJ_ANIM_TYPE_ARMATURE
	 */
	exports.OBJ_ANIM_TYPE_ARMATURE  = m_anim.OBJ_ANIM_TYPE_ARMATURE;

	/**
	 * Animation type: object.
	 * @const {AnimType} module:animation.OBJ_ANIM_TYPE_OBJECT
	 */
	exports.OBJ_ANIM_TYPE_OBJECT    = m_anim.OBJ_ANIM_TYPE_OBJECT;

	/**
	 * Animation type: vertex.
	 * @const {AnimType} module:animation.OBJ_ANIM_TYPE_VERTEX
	 */
	exports.OBJ_ANIM_TYPE_VERTEX    = m_anim.OBJ_ANIM_TYPE_VERTEX;

	/**
	 * Animation type: sound.
	 * @const {AnimType} module:animation.OBJ_ANIM_TYPE_SOUND
	 */
	exports.OBJ_ANIM_TYPE_SOUND     = m_anim.OBJ_ANIM_TYPE_SOUND;

	/**
	 * Animation type: particles.
	 * @const {AnimType} module:animation.OBJ_ANIM_TYPE_PARTICLES
	 */
	exports.OBJ_ANIM_TYPE_PARTICLES = m_anim.OBJ_ANIM_TYPE_PARTICLES;

	/**
	 * Animation type: material.
	 * @const {AnimType} module:animation.OBJ_ANIM_TYPE_MATERIAL
	 */
	exports.OBJ_ANIM_TYPE_MATERIAL  = m_anim.OBJ_ANIM_TYPE_MATERIAL;

	/**
	 * Animation type: static.
	 * @const {AnimType} module:animation.OBJ_ANIM_TYPE_STATIC
	 */
	exports.OBJ_ANIM_TYPE_STATIC    = m_anim.OBJ_ANIM_TYPE_STATIC;

	/**
	 * Animation behavior: cyclic.
	 * @const {AnimBehavior} module:animation.AB_CYCLIC
	 */
	exports.AB_CYCLIC = m_anim.AB_CYCLIC;
	/**
	 * Animation behavior: go back to the zero frame after finishing.
	 * @const {AnimBehavior} module:animation.AB_FINISH_RESET
	 */
	exports.AB_FINISH_RESET = m_anim.AB_FINISH_RESET;
	/**
	 * Animation behavior: stop the animation after finishing.
	 * @const {AnimBehavior} module:animation.AB_FINISH_STOP
	 */
	exports.AB_FINISH_STOP = m_anim.AB_FINISH_STOP;

	/**
	 * Check if the object is animated.
	 * @method module:animation.is_animated
	 * @param {Object3D} obj Object 3D
	 * @returns {boolean} Checking result.
	 */
	exports.is_animated = function(obj) {
	    return m_anim.is_animated(obj);
	};

	/**
	 * Return the names of all available animations.
	 * @method module:animation.get_anim_names
	 * @param {Object3D} obj Object 3D
	 * @returns {string[]} Array of animation names.
	 */
	exports.get_anim_names = function(obj) {
	    if (!m_anim.obj_is_animatable(obj))
	        return [];

	    return m_anim.get_anim_names(obj);
	};

	/**
	 * Return the name of the applied animation.
	 * @method module:animation.get_current_anim_name
	 * @param {Object3D} obj Object 3D
	 * @param {AnimSlot} [slot_num = SLOT_0] Animation slot number
	 * @returns {?string} Current animation name or null.
	 */
	exports.get_current_anim_name = function(obj, slot_num) {
	    if (!m_anim.is_animated(obj))
	        return null;

	    slot_num = slot_num || m_anim.SLOT_0;
	    return m_anim.get_anim_by_slot_num(obj, slot_num);
	};

	/**
	 * Apply the animation to the object.
	 * @method module:animation.apply
	 * @param {Object3D} obj Object 3D
	 * @param {string} name Animation name
	 * @param {AnimSlot} [slot_num = SLOT_0] Animation slot number.
	 */
	exports.apply = function(obj, name, slot_num) {
	    if (slot_num > m_anim.SLOT_7) {
	        m_print.error("Can't apply animation to slot " + slot_num +
	                      " for object \"" + obj.name +
	                      "\". Object can have maximum of 8 animation slots");
	        return;
	    }
	    slot_num = slot_num || m_anim.SLOT_0;

	    if (m_anim.is_animated(obj)) {
	        var applied_slot = m_anim.get_slot_num_by_anim(obj, name);
	        if (applied_slot != -1 && applied_slot != slot_num) {
	            m_print.error("Animation \"" + name +
	                          "\" is already applied to object \"" + obj.name +
	                          "\" (slot \"" + applied_slot + "\").");
	            return;
	        }
	    }

	    if (!m_anim.validate_action_by_name(obj, name)) {
	        m_print.error("No fcurves in action \"" + name + "\"");
	        return;
	    }

	    m_anim.apply(obj, null, name, slot_num);
	};

	/**
	 * Apply the animation to the object.
	 * @method module:animation.apply_ext
	 * @param {Object3D} obj Object 3D
	 * @param {?String[]} name_list Array of material and nested groups names and
	 * animation name.
	 * @param {AnimSlot} [slot_num = SLOT_0] Animation slot number.
	 */
	exports.apply_ext = function(obj, name_list, slot_num) {
	    if (slot_num > m_anim.SLOT_7) {
	        m_print.error("Can't apply animation to slot " + slot_num +
	                      " for object \"" + obj.name +
	                      "\". Object can have maximum of 8 animation slots");
	        return;
	    }
	    slot_num = slot_num || m_anim.SLOT_0;

	    var name = name_list[0];

	    if (!m_anim.validate_action_by_name(obj, name)) {
	        m_print.error("No fcurves in action \"" + name + "\"");
	        return;
	    }
	    var new_name_list = name_list.slice(1);

	    m_anim.apply(obj, new_name_list, name, slot_num);
	};

	/**
	 * Remove the animation from the object.
	 * @method module:animation.remove
	 * @param {Object3D} obj Object 3D
	 */
	exports.remove = function(obj) {
	    m_anim.remove(obj);
	};

	/**
	 * Remove the animation from the given animation slot of the object.
	 * @method module:animation.remove_slot_animation
	 * @param {Object3D} obj Object 3D
	 * @param {AnimSlot} [slot_num = SLOT_0] Animation slot number.
	 */
	exports.remove_slot_animation = function(obj, slot_num) {
	    if (!m_anim.is_animated(obj))
	        return;

	    slot_num = slot_num || m_anim.SLOT_0;
	    m_anim.remove_slot_animation(obj, slot_num);
	};

	/**
	 * Apply the default animation (i.e. assigned in Blender) to the object.
	 * @method module:animation.apply_def
	 * @param {Object3D} obj Object 3D
	 */
	exports.apply_def = function(obj) {
	    m_anim.apply_def(obj);
	};

	/**
	 * Play the object's animation. 
	 * The animation must be applied to the object before,
	 * or the object must have the default animation (i.e. assigned in Blender).
	 * @method module:animation.play
	 * @param {Object3D} obj Object 3D
	 * @param {AnimFinishCallback} [finish_callback] Callback to execute on finished animation
	 * @param {AnimSlot} [slot_num = SLOT_0] Animation slot number.
	 */
	exports.play = function(obj, finish_callback, slot_num) {
	    if (!m_anim.is_animated(obj)) {
	        m_print.error("Object \"" + obj.name + "\" has no applied animation");
	        return;
	    }

	    slot_num = slot_num || m_anim.SLOT_0;
	    m_anim.play(obj, finish_callback, slot_num);
	    m_anim.update_object_animation(obj, 0, slot_num, true);
	};

	/**
	 * Stop the object's animation.
	 * @method module:animation.stop
	 * @param {Object3D} obj Object 3D
	 * @param {AnimSlot} [slot_num = SLOT_0] Animation slot number
	 */
	exports.stop = function(obj, slot_num) {
	    if (m_anim.is_animated(obj)) {
	        slot_num = slot_num || m_anim.SLOT_0;
	        m_anim.stop(obj, slot_num);
	    }
	};
	/**
	 * Check if the object's animation is being played back.
	 * @method module:animation.is_play
	 * @param {Object3D} obj Object 3D
	 * @param {AnimSlot} [slot_num = SLOT_0] Animation slot number
	 * @returns {boolean} Checking result.
	 */
	exports.is_play = function(obj, slot_num) {
	    if (!m_anim.is_animated(obj))
	        return false;

	    slot_num = slot_num || m_anim.SLOT_0;
	    return m_anim.is_play(obj, slot_num);
	};

	/**
	 * Set the current frame of the object's animation.
	 * @method module:animation.set_frame
	 * @param {Object3D} obj Object 3D
	 * @param {number} frame Current frame (float)
	 * @param {AnimSlot} [slot_num = SLOT_0] Animation slot number
	 */
	exports.set_frame = function(obj, frame, slot_num) {
	    if (!m_anim.is_animated(obj))
	        return;

	    slot_num = slot_num || m_anim.SLOT_0;
	    m_anim.set_frame(obj, frame, slot_num);
	};

	/**
	 * Set the first frame of the object's animation.
	 * @method module:animation.set_first_frame
	 * @param {Object3D} obj Object 3D
	 * @param {AnimSlot} [slot_num = SLOT_0] Animation slot number
	 */
	exports.set_first_frame = function(obj, slot_num) {
	    if (!m_anim.is_animated(obj))
	        return;
	    m_anim.set_first_frame(obj, slot_num);
	};

	/**
	 * Set the last frame of the object's animation.
	 * @method module:animation.set_last_frame
	 * @param {Object3D} obj Object 3D
	 * @param {AnimSlot} [slot_num = SLOT_0] Animation slot number
	 */
	exports.set_last_frame = function(obj, slot_num) {
	    if (!m_anim.is_animated(obj))
	        return;

	    slot_num = slot_num || m_anim.SLOT_0;

	    var start = m_anim.get_anim_start_frame(obj, slot_num);
	    var len = m_anim.get_anim_length(obj, slot_num);

	    m_anim.set_frame(obj, start + len -
	            m_anim.LAST_FRAME_EPSILON, slot_num);
	};

	/**
	 * Get the current frame of the object's animation.
	 * @method module:animation.get_frame
	 * @param {Object3D} obj Object 3D
	 * @param {AnimSlot} [slot_num = SLOT_0] Animation slot number
	 * @returns {number} Current frame
	 */
	exports.get_frame = function(obj, slot_num) {
	    if (!m_anim.is_animated(obj))
	        return 0.0;

	    slot_num = slot_num || m_anim.SLOT_0;
	    return m_anim.get_current_frame_float(obj, slot_num);
	};

	/**
	 * Set the speed of the object's animation.
	 * @method module:animation.set_speed
	 * @param {Object3D} obj Object 3D
	 * @param {number} speed Speed (may be negative) (float)
	 * @param {AnimSlot} [slot_num = SLOT_0] Animation slot number
	 */
	exports.set_speed = function(obj, speed, slot_num) {
	    if (!m_anim.is_animated(obj))
	        return;

	    slot_num = slot_num || m_anim.SLOT_0;
	    speed = speed || 1;
	    m_anim.set_speed(obj, speed, slot_num);
	};

	/**
	 * Get the speed of the object's animation.
	 * @method module:animation.get_speed
	 * @param {Object3D} obj Object 3D
	 * @param {AnimSlot} [slot_num = SLOT_0] Animation slot number
	 * @returns {number} Animation speed.
	 */
	exports.get_speed = function(obj, slot_num) {
	    if (!m_anim.is_animated(obj))
	        return 0;

	    slot_num = slot_num || m_anim.SLOT_0;

	    if (!obj.anim_slots[slot_num])
	        return 0;

	    return m_anim.get_speed(obj, slot_num);
	};

	/**
	 * Get the starting frame of the object's animation.
	 * @method module:animation.get_anim_start_frame
	 * @param {Object3D} obj Object 3D
	 * @param {AnimSlot} [slot_num = SLOT_0] Animation slot number
	 * @returns {number} Animation start frame or -1 for incorrect object
	 */
	exports.get_anim_start_frame = function(obj, slot_num) {
	    if (m_anim.is_animated(obj)) {
	        slot_num = slot_num || m_anim.SLOT_0;

	        if (!obj.anim_slots[slot_num])
	            return -1;
	        else
	            return m_anim.get_anim_start_frame(obj, slot_num);
	    }

	    return -1;
	};

	/**
	 * Get the length of the object's animation measured in frames.
	 * @method module:animation.get_anim_length
	 * @param {Object3D} obj Object 3D
	 * @param {AnimSlot} [slot_num = SLOT_0] Animation slot number
	 * @returns {number} Animation length or -1 for incorrect object
	 */
	exports.get_anim_length = function(obj, slot_num) {
	    if (m_anim.is_animated(obj)) {
	        slot_num = slot_num || m_anim.SLOT_0;

	        if (!obj.anim_slots[slot_num])
	            return -1;
	        else
	            return m_anim.get_anim_length(obj, slot_num);
	    }

	    return -1;
	};

	/**
	 * Set behavior for the object's animation.
	 * @method module:animation.set_behavior
	 * @param {Object3D} obj Object 3D
	 * @param {AnimBehavior} behavior Behavior enum
	 * @param {AnimSlot} [slot_num = SLOT_0] Animation slot number
	 */
	exports.set_behavior = function(obj, behavior, slot_num) {
	    if (!m_anim.is_animated(obj))
	        return;

	    slot_num = slot_num || m_anim.SLOT_0;
	    m_anim.set_behavior(obj, behavior, slot_num);
	};

	/**
	 * Get behavior of the object's animation.
	 * @method module:animation.get_behavior
	 * @param {Object3D} obj Object 3D
	 * @param {AnimSlot} [slot_num = SLOT_0] Animation slot number
	 * @returns {AnimBehavior} Behavior enum
	 */
	exports.get_behavior = function(obj, slot_num) {
	    if (!m_anim.is_animated(obj))
	        return null;

	    slot_num = slot_num || m_anim.SLOT_0;
	    return m_anim.get_behavior(obj, slot_num);
	};

	/**
	 * Apply smoothing to the object's animation.
	 * In order to disable the smoothing, specify the zero periods.
	 * @method module:animation.apply_smoothing
	 * @param {Object3D} obj Object 3D
	 * @param {number} [trans_period=0] Translation smoothing period
	 * @param {number} [quat_period=0] Rotation smoothing period
	 * @param {AnimSlot} [slot_num = SLOT_0] Animation slot number
	 */
	exports.apply_smoothing = function(obj, trans_period, quat_period, slot_num) {
	    slot_num = slot_num || m_anim.SLOT_0;
	    if (m_anim.is_animated(obj))
	        m_anim.apply_smoothing(obj, trans_period, quat_period, slot_num);
	};

	/**
	 * Convert animation frames to seconds.
	 * @method module:animation.frame_to_sec
	 * @param {number} frame Frame number
	 * @returns {number} Number of seconds
	 */
	exports.frame_to_sec = function(frame) {
	    return m_anim.frame_to_sec(frame);
	};

	/**
	 * Get the slot number of the object to which the animation is assigned.
	 * @method module:animation.get_slot_num_by_anim
	 * @param {Object3D} obj Object 3D
	 * @param {string} anim_name Animation name
	 * @returns {?number} Animation slot number
	 */
	exports.get_slot_num_by_anim = function(obj, anim_name) {
	    if (!m_anim.is_animated(obj) || !anim_name)
	        return -1;

	    return m_anim.get_slot_num_by_anim(obj, anim_name);
	};

	/**
	 * Get the object's animation type.
	 * @method module:animation.get_anim_type
	 * @param {Object3D} obj Object 3D
	 * @param {AnimSlot} [slot_num = SLOT_0] Slot number
	 * @returns {?AnimType} Animation type
	 */
	exports.get_anim_type = function(obj, slot_num) {
	    if (!m_anim.is_animated(obj))
	        return null;

	    return m_anim.get_anim_type(obj, slot_num);
	};

	/**
	 * Apply the animation to the first available animation slot.
	 * @method module:animation.apply_to_first_empty_slot
	 * @param {Object3D} obj Object 3D
	 * @param {string} name Animation name.
	 * @returns {number} Slot number or -1 if no empty slots found.
	 */
	exports.apply_to_first_empty_slot = function(obj, name) {
	    return m_anim.apply_to_first_empty_slot(obj, name);
	};

	/**
	 * Get the mix factor for the skeletal animations assigned to the last two animation slots.
	 * @method module:animation.get_skel_mix_factor
	 * @param {Object3D} armobj Armature object.
	 * @returns {number} Mix factor.
	 */
	exports.get_skel_mix_factor = function(armobj) {
	    return armobj.render.anim_mix_factor;
	};

	/**
	 * Set the mix factor for the skeletal animations assigned to the last two animation slots.
	 * Specify the non-zero time for smooth animation transitions.
	 * @method module:animation.set_skel_mix_factor
	 * @param {Object3D} armobj Armature object.
	 * @param {number} factor Target animation mix factor.
	 * @param {number} [time=0] Time interval for changing the mix factor from
	 * the current to the target value.
	 * @param {AnimBlendingCallback} [callback=null] Callback to execute on finished blending.
	 */
	exports.set_skel_mix_factor = function(armobj, factor, time, callback) {
	    if (!m_obj_util.is_armature(armobj)) {
	        m_print.error("Can't blend animation. Object \"" + armobj.name + "\" is not armature");
	        return;
	    }
	    factor = Math.min(Math.max(factor, 0), 1);
	    if (armobj.render.anim_mix_factor == factor)
	        return;

	    time = time || 0;
	    callback = callback || null;

	    m_anim.set_skel_mix_factor(armobj, factor, time, callback);
	};
	/**
	 * Set the blended skeletal animation slots.
	 * @method module:animation.set_skeletal_slots
	 * @param {Object3D} armobj Armature object.
	 * @param {number} [slot_1=-1] First blended animation slot.
	 * @param {number} [slot_2=-1] Second blended animation slot.
	 * @param {number} [factor=0] Start animation mix factor.
	 */
	exports.set_skeletal_slots = function(armobj, slot_1, slot_2, factor) {
	    slot_1 = slot_1 == undefined ? -1 : slot_1;
	    slot_2 = slot_1 == undefined ? -1 : slot_2;
	    factor = factor || 0;
	    var render = armobj.render;
	    var skeletal_slots = render.blend_skel_slots;
	    if (slot_1 >= 0)
	        skeletal_slots[0] = slot_1;
	    if (slot_2 >= 0)
	        skeletal_slots[1] = slot_2;
	    armobj.render.anim_mix_factor = factor;
	};
	/**
	 * Get the first blended animation slot.
	 * @method module:animation.get_first_skeletal_slot
	 * @param {Object3D} armobj Armature object.
	 * @returns {slot_1} First blended animation slot.
	 */
	exports.get_first_skeletal_slot = function(armobj) {
	    return armobj.render.blend_skel_slots[0];
	};
	/**
	 * Get the second blended animation slot.
	 * @method module:animation.get_second_skeletal_slot
	 * @param {Object3D} armobj Armature object.
	 * @returns {slot_2} Second blended animation slot.
	 */
	exports.get_second_skeletal_slot = function(armobj) {
	    return armobj.render.blend_skel_slots[1];
	};
	/**
	 * Set the mix factor for the skeletal animations assigned to the last two animation slots.
	 * @method module:animation.mix_from_cur_pos
	 * @param {Object3D} armobj Armature object.
	 * @param {AnimSlot} slot Animation slot number.
	 * @param {number} [time=0] Time interval for changing the mix factor from
	 * the current to the target value.
	 * @param {AnimBlendingCallback} [callback=null] Callback to execute on finished blending.
	 */
	exports.mix_from_cur_pos = function(armobj, slot, time, callback) {
	    callback = callback || null;
	    time = time || 0;
	    m_anim.mix_from_cur_pos(armobj, slot, time, callback);
	};

	}

	var animation_factory = register("animation", Animation);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Non-player character add-on.
	 * Provides animated moves for NPC with a specified behavior.
	 * @module npc_ai
	 * @local GraphActions
	 */
	function NPC_AI(ns, exports) {

	var m_anim  = animation_factory(ns);
	var m_ctl   = controls_factory(ns);
	var m_quat  = quat_factory(ns);
	var m_scs   = scenes_factory(ns);
	var m_time  = time_factory(ns);
	var m_trans = transform_factory(ns);
	var m_vec3  = vec3_factory(ns);
	var m_phy   = physics_factory(ns);
	var m_print = print_factory(ns);
	var m_util  = util_factory(ns);

	var _ev_tracks = [];

	var _vec3_tmp    = new Float32Array(3);
	var _vec3_tmp_2  = new Float32Array(3);
	var _vec3_tmp_3  = new Float32Array(3);
	var _vec3_tmp_4  = new Float32Array(3);
	var _quat4_tmp   = new Float32Array(4);
	var _quat4_tmp_2 = new Float32Array(4);
	var _quat4_tmp_3 = new Float32Array(4);

	/**
	 * NPC movement type - walking.
	 * @const {number} module:npc_ai.NT_WALKING
	 */
	var NT_WALKING  = exports.NT_WALKING  = 10;
	/**
	 * NPC movement type - flying.
	 * @const {number} module:npc_ai.NT_FLYING
	 */
	var NT_FLYING   = exports.NT_FLYING   = 20;
	/**
	 * NPC movement type - swimming.
	 * @const {number} module:npc_ai.NT_SWIMMING
	 */
	var NT_SWIMMING = exports.NT_SWIMMING = 30;

	var MS_IDLE   = 10;
	var MS_MOVING = 20;

	/**
	 * An object containing actions for every movement type.
	 * @typedef {Object} GraphActions
	 * @property {Array} idle An array of "idle" animations.
	 * @property {Array} move An array of "move" animations.
	 * @property {Array} move_start An array of "move_start" animations.
	 * @property {Array} move_blends An array of "move_blends" animations.
	 * @cc_externs idle move move_start move_blends
	 */

	/**
	 * Creates a new event track based on a given graph.
	 * @param {Object} graph Animation graph with a number of movement params.
	 * @param {Array} graph.path A list of [x,y,z] points NPC will be moving around.
	 * @param {number} graph.delay Time delay before each path step.
	 * @param {GraphActions} graph.actions Actions for every movement type (move, idle, etc).
	 * @param {Object3D} graph.obj Animated object.
	 * @param {Object3D} graph.rig Armature object.
	 * @param {Object3D} graph.collider Collider object which will be used for 
	 * collision detection. Should be a valid physics object.
	 * @param {number} graph.speed Movement speed.
	 * @param {number} graph.rot_speed Rotation speed.
	 * @param {boolean} graph.random Determines whether the object will perform random moves or not.
	 * @param {number} graph.type NPC movement type (NT_WALKING, NT_FLYING, etc).
	 * @method module:npc_ai.new_event_track
	 * @cc_externs path delay actions obj collider speed random rig
	 * @cc_externs type rot_speed max_height min_height
	 */
	exports.new_event_track = function(graph) {

	    var track = init_event_track();

	    if (typeof graph.obj != "object") {
	        m_print.error("Can't create event track. Wrong object.");
	        return;
	    }

	    if (typeof graph.rig != "object") {
	        m_print.error("Can't create event track. Wrong rig object.");
	        return;
	    }

	    if (typeof graph.collider != "object" || !m_phy.has_physics(graph.collider)) {
	        m_print.error("Can't create event track. Wrong collider object.");
	        return;
	    }

	    track.obj = graph.obj;
	    track.collider = graph.collider;
	    track.rig = graph.rig;
	    m_trans.get_translation(graph.collider, track.base_pos);

	    if (typeof graph.actions == "object")
	        track.actions = graph.actions;
	    if (typeof graph.random == "boolean")
	        track.random = graph.random;
	    if (typeof graph.type == "number")
	        track.type = graph.type;
	    if (typeof graph.speed == "number")
	        track.speed = graph.speed;
	    if (typeof graph.rot_speed == "number")
	        track.rot_speed = graph.rot_speed;
	    if (typeof graph.max_height == "number")
	        track.max_height = graph.max_height;
	    if (typeof graph.min_height == "number")
	        track.min_height = graph.min_height;

	    if (!track.random) {
	        for (var i = 0; i < graph.path.length; i++) {
	            track.start[i] = -1; // starting time for current move
	            track.ended[i] = false;
	            track.fired[i] = false;
	        }
	        track.path = graph.path;
	        track.delay = graph.delay;
	    }

	    // apply all available animations so that they are precached
	    var actions = graph.actions;
	    var cur_anim = m_anim.get_current_anim_name(track.rig);
	    for (var list in actions) {
	        var act_list = actions[list];
	        for (var j = 0; j < act_list.length; j++)
	            m_anim.apply(track.rig, act_list[j]);
	    }

	    // restore animation
	    if (cur_anim)
	        m_anim.apply(track.rig, cur_anim);

	    _ev_tracks.push(track);
	};

	function init_event_track() {
	    return {

	        obj: null,
	        rig: null,
	        collider: null,
	        empty: null,

	        type: NT_WALKING,
	        state: MS_IDLE,

	        actions: {},

	        base_pos: new Float32Array(3),
	        destination: new Float32Array(3),

	        path:  [],
	        start: [],
	        ended: [],
	        fired: [],
	        delay: [],

	        random: true,
	        reached: true,
	        ground_level: 0,
	        vert_correction: 0,
	        vert_cor_water: 0,
	        rotation_mult: 1.0,
	        speed: 1,
	        rot_speed: 0.1,
	        max_height: 0,
	        min_height: 0,
	        max_depth: 0,
	        min_depth: 0
	    }
	}

	/**
	 * Calculates destination coordinates and
	 * runs anim_translation function
	 */
	function run_track(elapsed, ev_track) {

	    var destination = ev_track.destination;
	    var base_pos = ev_track.base_pos;

	    var current_loc = _vec3_tmp_2;

	    m_trans.get_translation(ev_track.collider, current_loc);

	    var vert_correction = 0;
	    var cur_height = current_loc[2];
	    destination[2] = cur_height;

	    switch (ev_track.type) {
	    case NT_WALKING:
	        if (ev_track.random && ev_track.reached) {
	            destination[0] = (Math.random()*12 - 6)*ev_track.speed + base_pos[0];
	            destination[1] = -(Math.random()*12 - 6)*ev_track.speed + base_pos[1];

	            move_destination_if_too_close(ev_track, destination, current_loc);
	            ev_track.reached = false;
	        }

	        if (ev_track.ground_level) {
	            vert_correction = ev_track.ground_level - cur_height;
	            var vert_delta = ev_track.speed * elapsed;

	            if (vert_correction > vert_delta)
	                vert_correction = vert_delta;
	            else if (vert_correction < -vert_delta)
	                vert_correction = -vert_delta;
	        }

	        ev_track.vert_correction = vert_correction;

	        break;
	    case NT_FLYING:
	    case NT_SWIMMING:

	        if (ev_track.vert_cor_water) {
	            vert_correction = ev_track.vert_cor_water;
	        } else if (ev_track.vert_correction) {
	            vert_correction = ev_track.vert_correction;
	            if (ev_track.type == NT_SWIMMING)
	                vert_correction *= elapsed;
	        }

	        if (ev_track.random && ev_track.reached) {
	            if (ev_track.type == NT_SWIMMING) {
	                ev_track.speed = Math.random() + 0.1;
	                var magnitude = ev_track.max_depth - ev_track.min_depth;
	            } else
	                var magnitude = ev_track.max_height - ev_track.min_height;

	            destination[0] = Math.random() * 10 - 5 + base_pos[0];
	            destination[1] = Math.random() * 10 - 5 + base_pos[1];
	            destination[2] = cur_height - (Math.random() * magnitude - 0.5 * magnitude);
	            ev_track.reached = false;
	        }
	        break;
	    }

	    if (vert_correction)
	        destination[2] = cur_height + vert_correction;

	    anim_translation(elapsed, ev_track);
	}

	function move_destination_if_too_close(ev_track, dest, cur_loc) {

	    var cur_rot_q = _quat4_tmp_2;
	    var cur_hor_dir = _vec3_tmp_3;

	    var speed = ev_track.speed;
	    var rot_speed = ev_track.rot_speed;

	    m_trans.get_rotation(ev_track.collider, cur_rot_q);
	    m_vec3.transformQuat(m_util.AXIS_MY, cur_rot_q, cur_hor_dir);
	    cur_hor_dir[2] = 0;
	    m_vec3.normalize(cur_hor_dir, cur_hor_dir);

	    var sin_half_rot_angle = Math.sin(rot_speed/2);
	    var walk_radius = 0.5 * speed / sin_half_rot_angle;

	    var dist = m_vec3.dist(dest, cur_loc);
	    if (dist < 2.0 * walk_radius)
	        m_vec3.scaleAndAdd(dest, cur_hor_dir, (2.0 * walk_radius - dist), dest);
	}

	function anim_translation(elapsed, ev_track) {

	    var cur_loc     = _vec3_tmp;
	    var cur_dir     = _vec3_tmp_2;
	    var new_hor_dir = _vec3_tmp_3;
	    var new_rot_q   = _quat4_tmp_3;

	    var rig        = ev_track.rig;
	    var collider   = ev_track.collider;
	    var dest       = ev_track.destination;
	    var speed      = ev_track.speed;
	    var actions    = ev_track.actions;

	    var cur_anim   = m_anim.get_current_anim_name(rig);

	    // skip iteration if idle animation is playing
	    if (m_anim.is_play(rig) && actions.idle
	                            && actions.idle.indexOf(cur_anim) != -1)
	        return;

	    m_trans.get_translation(collider, cur_loc);

	    var delta_x = dest[0] - cur_loc[0];
	    var delta_z = dest[1] - cur_loc[1];
	    var left_to_pass = Math.sqrt(delta_x * delta_x + delta_z * delta_z);

	    if (left_to_pass > 2.0 * speed * elapsed) {

	        ev_track.state = MS_MOVING;
	        m_util.horizontal_direction(dest, cur_loc, new_hor_dir);
	        dest_anim_correction(ev_track, dest, left_to_pass, new_hor_dir);

	        // rotation
	        hor_rot (ev_track, cur_dir, elapsed, new_rot_q, new_hor_dir);
	        vert_rot(ev_track, cur_dir, elapsed, new_rot_q);

	        m_trans.set_rotation_v(collider, new_rot_q);

	        // translation
	        trans_obj(elapsed, new_rot_q, ev_track, cur_loc, dest);

	    } else if (ev_track.type == NT_WALKING) {
	        if (!actions.move) {
	            ev_track.state = MS_IDLE;
	            ev_track.reached = true;
	        } else if (cur_anim && actions.move.indexOf(cur_anim) != -1
	                            && m_anim.is_play(rig))
	            ev_track.state = MS_MOVING;
	        else {
	            ev_track.state = MS_IDLE;
	            ev_track.reached = true;
	        }

	    } else if (ev_track.type == NT_SWIMMING || ev_track.type == NT_FLYING)
	        ev_track.reached = true;

	    if (need_proper_animation(ev_track))
	        apply_animation(ev_track);
	}

	function hor_rot(ev_track, cur_dir, elapsed, new_rot_q, new_hor_dir) {

	    var cur_rot_q   = _quat4_tmp_2;
	    var cur_hor_dir = _vec3_tmp_4;

	    m_trans.get_rotation(ev_track.collider, cur_rot_q);
	    m_vec3.transformQuat(m_util.AXIS_MY, cur_rot_q, cur_dir);

	    cur_hor_dir[0]  = cur_dir[0];
	    cur_hor_dir[1]  = cur_dir[1];
	    cur_hor_dir[2]  = 0;
	    m_vec3.normalize(cur_hor_dir, cur_hor_dir);

	    var vec_dot = m_vec3.dot(cur_hor_dir, new_hor_dir);

	    var angle_to_turn = Math.acos(vec_dot);
	    var angle_ratio   = Math.abs(angle_to_turn) / Math.PI;
	    var slerp         = elapsed / angle_ratio * ev_track.rot_speed * ev_track.rotation_mult;

	    m_quat.rotationTo(cur_hor_dir, new_hor_dir, new_rot_q);
	    m_quat.rotationTo(m_util.AXIS_MY, cur_hor_dir, cur_rot_q);

	    if (Math.abs(vec_dot) >= 1) {
	        m_quat.copy(cur_rot_q, new_rot_q);
	        return;
	    }

	    m_quat.multiply(new_rot_q, cur_rot_q, new_rot_q);
	    m_quat.slerp(cur_rot_q, new_rot_q, Math.min(slerp, 1), new_rot_q);
	}

	function vert_rot(ev_track, cur_dir, elapsed, new_rot_q) {

	    if (ev_track.type == NT_FLYING)
	        return;

	    // synchronization with physics engine
	    elapsed = Math.max(elapsed, 1/60);

	    var new_vert_q = _quat4_tmp;
	    var cur_vert_q = _quat4_tmp_2;

	    var cur_vert_angle  = Math.asin(-cur_dir[2]);
	    m_quat.setAxisAngle(m_util.AXIS_X, -cur_vert_angle, cur_vert_q);

	    var delta_hor_dist  = ev_track.speed * elapsed;
	    var delta_vert_dist = ev_track.vert_correction;
	    var new_vert_angle  = Math.atan(delta_vert_dist / delta_hor_dist);
	    m_quat.setAxisAngle(m_util.AXIS_X, -new_vert_angle, new_vert_q);
	    m_quat.slerp(cur_vert_q, new_vert_q, elapsed, new_vert_q);
	    m_quat.multiply(new_rot_q, new_vert_q, new_rot_q);
	}

	function trans_obj(elapsed, new_rot_q, ev_track, cur_loc, dest) {

	    var new_dir = _vec3_tmp_3;
	    var new_loc = _vec3_tmp_4;
	    var def_dir = m_util.AXIS_MY;

	    m_util.quat_to_dir(new_rot_q, def_dir, new_dir);

	    m_vec3.scale(new_dir, ev_track.speed * elapsed, new_loc);
	    m_vec3.add(new_loc, cur_loc, new_loc);

	    if (ev_track.type != NT_WALKING)
	        new_loc[2] = (dest[2] - cur_loc[2]) * elapsed * 0.1 + cur_loc[2];
	    else
	        new_loc[2] = dest[2];

	    m_trans.set_translation_v(ev_track.collider, new_loc);
	}

	/**
	 * Attaches sensors to characters and runs elapsed_cb every frame.
	 */
	exports.enable_animation = function () {

	    if(!_ev_tracks.length)
	        return;

	    create_sensors();

	    var elapsed_cb = function(obj, id, pulse) {
	        if (pulse == 1) {
	            var elapsed = m_ctl.get_sensor_value(obj, id, 0);
	            for (var i = 0; i < _ev_tracks.length; i++)
	                process_event_track(_ev_tracks[i], elapsed);
	        }
	    };
	    var elapsed_sensor = m_ctl.create_elapsed_sensor();

	    m_ctl.create_sensor_manifold(_ev_tracks[0].collider,
	                "ELAPSED", m_ctl.CT_CONTINUOUS, [elapsed_sensor],
	                function(s){return s[0]}, elapsed_cb);
	};

	/**
	 * Removes all sensors attached to animated objects and stops animation
	 */
	exports.disable_animation = function() {
	    if(_ev_tracks.length <= 0)
	        return;

	    for (var i = 0; i < _ev_tracks.length; i++) {
	        var ev = _ev_tracks[i];

	        if (m_ctl.check_sensor_manifolds(ev.collider))
	            m_ctl.remove_sensor_manifold(ev.collider);

	        if (m_anim.is_play(ev.rig))
	            m_anim.stop(ev.rig);

	    }
	};

	function process_event_track(ev_track, elapsed) {

	    if (!m_scs.is_visible(ev_track.obj))
	        return;

	    if (ev_track.random) {
	        run_track(elapsed, ev_track);
	    } else {
	        var focus_time = m_time.get_timeline();
	        for (var j = 0; j < ev_track.path.length; j++) {

	            if (ev_track.ended[j])
	                continue;

	            if (!ev_track.fired[j]) {
	                ev_track.fired[j] = true;
	                ev_track.destination[0] = ev_track.path[j][0];
	                ev_track.destination[1] = ev_track.path[j][1];
	                ev_track.destination[2] = ev_track.path[j][2];
	                ev_track.start[j] = focus_time + ev_track.delay[j];
	            }

	            if (focus_time < ev_track.start[j])
	                break;

	            run_track(elapsed, ev_track);
	            ev_track.ended[j] = ev_track.reached;
	            break;
	        }

	        if (is_all_ended(ev_track))
	            unset_all_fired(ev_track);
	    }
	}

	function unset_all_fired(track) {
	    for (var i = 0; i < track.path.length; i++) {
	        track.fired[i] = false;
	        track.ended[i] = false;
	    }
	}

	function is_all_ended(track) {
	    for (var i = 0; i < track.path.length; i++)
	        if (track.ended[i] == false)
	            return false;
	    return true;
	}

	function ground_cb(obj, id, pulse, ev) {

	    if (!ev)
	        return;

	    if (pulse == 1) {

	        switch(ev.type) {
	            case NT_FLYING:
	                var hit_fract = 100 * flying_npc_hit_fract(obj, id);
	                if (hit_fract < ev.min_height) {
	                    ev.vert_correction = 10;
	                } else if (hit_fract > ev.max_height) {
	                    ev.vert_correction = -10;
	                } else
	                    ev.vert_correction = 0;
	            break;
	            case NT_WALKING:
	                var payload = m_ctl.get_sensor_payload(obj, id, 0);
	                ev.ground_level = payload.hit_pos[2];
	            break;
	            case NT_SWIMMING:
	                var payload = m_ctl.get_sensor_payload(obj, id, 0);
	                if (id == "CLOSE_GROUND") {
	                    ev.vert_correction = payload.hit_fract * 100 - 1;

	                    if (ev.vert_correction < 0.1)
	                        ev.vert_correction = 0.05;
	                    else
	                        ev.vert_correction = 0;

	                } else if (id == "CLOSE_WATER") {
	                    ev.vert_cor_water = payload.hit_fract * 100;

	                    if (ev.vert_cor_water < ev.min_depth)
	                        ev.vert_cor_water = -0.02;
	                    else if (ev.vert_cor_water > ev.max_depth)
	                        ev.vert_cor_water = 0.02;
	                    else
	                        ev.vert_cor_water = 0;
	                }
	            break;
	        }

	    } else
	        ev.vert_correction = 0;
	}

	function flying_npc_hit_fract(obj, id) {
	    for (var i = 0; i < 3; i++) {
	        var hit_pos = m_ctl.get_sensor_payload(obj, id, i).hit_fract;
	        if (hit_pos)
	            return hit_pos;
	    }
	}

	function create_sensors() {
	    for (var i = 0; i < _ev_tracks.length; i++) {

	        var ev_track = _ev_tracks[i];

	        create_track_ray_sensors(ev_track);
	        create_track_collision_sensors(ev_track);

	        if (m_anim.get_current_anim_name(ev_track.rig))
	            m_anim.play(ev_track.rig);
	    }
	}

	function create_track_ray_sensors(ev_track) {

	    var ZERO_POINT = m_vec3.create();

	    var collider = ev_track.collider;

	    switch (ev_track.type) {
	    case NT_FLYING:
	        var near_ground_sens = m_ctl.create_ray_sensor(collider,
	                ZERO_POINT, [0, 0, -100], "TERRAIN", true, true);
	        var near_stone_sens = m_ctl.create_ray_sensor(collider,
	                ZERO_POINT, [0, 0, -100], "STONE", true, true);
	        var near_water_sens = m_ctl.create_ray_sensor(collider,
	                ZERO_POINT, [0, 0, -100], "WATER", true, true);

	        var ground_sens_arr = [near_ground_sens, near_stone_sens, near_water_sens];

	        m_ctl.create_sensor_manifold(collider,
	                "CLOSE_GROUND", m_ctl.CT_CONTINUOUS, ground_sens_arr,
	                function(s){return s[0] || s[1] || s[2]}, ground_cb, ev_track);

	        break;
	    case NT_WALKING:
	        var near_ground_sens = m_ctl.create_ray_sensor(collider,
	                [0, 0, 1], [0, 0, -99], "TERRAIN", true, true);

	        var ground_sens_arr = [near_ground_sens];
	        m_ctl.create_sensor_manifold(collider,
	                "CLOSE_GROUND", m_ctl.CT_CONTINUOUS, ground_sens_arr,
	                null, ground_cb, ev_track);

	        break;
	    case NT_SWIMMING:
	        var near_ground_sens = m_ctl.create_ray_sensor(collider,
	                [0, 0, 1], [0, 0, -99], "TERRAIN", true, true);
	        var near_water_sens = m_ctl.create_ray_sensor(collider,
	                ZERO_POINT, [0, 0, 100], "WATER", true, true);

	        var ground_sens_arr = [near_ground_sens];
	        var water_sens_arr  = [near_water_sens];

	        m_ctl.create_sensor_manifold(collider,
	                "CLOSE_WATER", m_ctl.CT_CONTINUOUS, water_sens_arr,
	                null, ground_cb, ev_track);
	        m_ctl.create_sensor_manifold(collider,
	                "CLOSE_GROUND", m_ctl.CT_CONTINUOUS, ground_sens_arr,
	                null, ground_cb, ev_track);
	        break;
	    }
	}

	function create_track_collision_sensors(ev_track) {

	    var collider = ev_track.collider;

	    if (ev_track.type != NT_WALKING)
	        return;

	    var need_payload = false;
	    var collision_sensor = m_ctl.create_collision_sensor(collider, "CONSTRUCTION",
	                                                         need_payload);
	    function collision_cb(obj, id, pulse) {
	        if (pulse == 1) {
	            m_vec3.copy(ev_track.base_pos, ev_track.destination);
	            ev_track.rotation_mult = 4.0;

	        } else {
	            ev_track.rotation_mult = 1.0;
	        }
	    }

	    m_ctl.create_sensor_manifold(collider,
	            "CONSTRUCTION_COLL", m_ctl.CT_CONTINUOUS, [collision_sensor],
	            null, collision_cb);
	}

	function need_proper_animation(ev_track) {

	    var obj = ev_track.rig;
	    if (!m_anim.is_play(obj)) {
	        return true;
	    }

	    var cur_anim  = m_anim.get_current_anim_name(obj);
	    if (!cur_anim)
	        return true;

	    var actions = ev_track.actions;
	    switch (ev_track.state) {
	    case MS_IDLE:
	        if (!actions.idle)
	            return false;

	        if (actions.idle.indexOf(cur_anim) == -1)
	            return true;

	        break;
	    case MS_MOVING:
	        if (!actions.move)
	            return false;

	        if (actions.move.indexOf(cur_anim) != -1)
	            return false;

	        if (actions.move_start && actions.move_start.indexOf(cur_anim) != -1)
	            return false;

	        if (actions.move_blends && actions.move_blends.indexOf(cur_anim) != -1)
	            return false;

	        break;
	    default:
	        return false;
	    }

	    return true;
	}

	function apply_animation(ev_track) {

	    var obj = ev_track.rig;
	    if (m_anim.is_play(obj))
	        return;

	    var anim_to_play = null;

	    switch (ev_track.state) {
	    case MS_IDLE:
	        anim_to_play = get_idle_animation(ev_track);
	        break;
	    case MS_MOVING:
	        anim_to_play = get_move_animation(ev_track);
	        break;
	    }

	    if (anim_to_play) {
	        m_anim.apply(obj, anim_to_play);
	        m_anim.set_behavior(obj, m_anim.AB_FINISH_RESET);
	        m_anim.set_frame(obj, 0);
	        m_anim.play(obj);
	    }
	}

	function get_idle_animation(ev_track) {

	    var actions = ev_track.actions;
	    if (!actions.idle)
	        return null;

	    return m_util.random_from_array(actions.idle);
	}

	function get_move_animation(ev_track) {

	    var cur_anim = m_anim.get_current_anim_name(ev_track.rig);
	    var actions = ev_track.actions;

	    if (need_move_blend_animation(ev_track, cur_anim)) {
	        return get_proper_move_blend_animation(ev_track, cur_anim);
	    }

	    if (need_move_animation(ev_track, cur_anim)) {
	        return get_proper_move_animation(ev_track, cur_anim);
	    }

	    if (need_move_start_animation(ev_track, cur_anim)) {
	        return m_util.random_from_array(actions.move_start);
	    }

	    return null;
	}

	function need_move_animation(ev_track, cur_anim) {

	    var actions = ev_track.actions;
	    if (!actions.move)
	        return false;

	    if (actions.move.indexOf(cur_anim) != -1)
	        return true;

	    if (!(actions.move_blends || actions.move_start))
	        return true;

	    if (!actions.move_start && !cur_anim)
	        return true;

	    if (actions.move_blends && actions.move_blends.indexOf(cur_anim) != -1)
	        return true;

	    if (actions.move_start && actions.move_start.indexOf(cur_anim) != -1)
	        return true;

	    return false;
	}

	function need_move_blend_animation(ev_track, cur_anim) {

	    var actions = ev_track.actions;
	    if (!actions.move_blends)
	        return false;

	    if (actions.move_blends.indexOf(cur_anim) != -1)
	        return false;

	    if (actions.move && actions.move.indexOf(cur_anim) != -1) {
	        var identifier = Math.random();
	        return identifier > 0.33;
	    }

	    return false;
	}

	function need_move_start_animation(ev_track, cur_anim) {

	    var actions = ev_track.actions;
	    if (!actions.move_start)
	        return false;

	    if (actions.move_start.indexOf(cur_anim) != -1)
	        return false;

	    if (actions.move && actions.move.indexOf(cur_anim) == -1)
	        return true;

	    return false;
	}

	function get_proper_move_blend_animation(ev_track, cur_anim) {

	    var actions = ev_track.actions;
	    var ind = actions.move.indexOf(cur_anim);
	    return actions.move_blends[ind];
	}

	function get_proper_move_animation(ev_track, cur_anim) {

	    var actions = ev_track.actions;
	    if (!actions.move_blends)
	        return m_util.random_from_array(actions.move);

	    var move_blend_anim_ind = actions.move_blends.indexOf(cur_anim);
	    if (move_blend_anim_ind != -1) {
	        var ind = move_blend_anim_ind + 1;
	        ind = ind < actions.move.length? ind: 0;
	        return actions.move[ind];
	    }

	    if (actions.move.indexOf(cur_anim) != -1)
	        return cur_anim;
	    else
	        return m_util.random_from_array(actions.move);
	}

	function dest_anim_correction(ev_track, dest, l_to_p, new_dir) {

	    var obj = ev_track.rig;
	    if (!m_anim.is_animated(obj))
	        return

	    var speed        = ev_track.speed;
	    var left_to_pass = l_to_p;

	    var cur_frame         = m_anim.get_frame(obj);
	    var anim_length       = m_anim.get_anim_length(obj);
	    var path_per_cycle    = anim_length / 24 * speed;
	    var left_to_pass_anim = (1 - cur_frame / anim_length) * path_per_cycle;
	    var correlation       = left_to_pass / left_to_pass_anim;

	    if (correlation < 0.9) {
	        var scale = left_to_pass_anim - left_to_pass;
	        m_vec3.scaleAndAdd(dest, new_dir, scale, dest);
	    }
	}

	}

	var npc_ai_factory = register("npc_ai", NPC_AI);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Preloader add-on.
	 * Provides API to create various types of standard preloaders.
	 * @module preloader
	 */
	function Preloader(ns, exports) {

	var m_cont = container_factory(ns);

	var PL_CONT_BG_COLOR    = "#484848";
	var PL_BAR_BG_COLOR     = "#5276cf";
	var PL_BAR_BORDER_COLOR = "rgba(150, 150, 150, 0.7)";
	var PL_FONT_COLOR       = "#fff";

	var _preloader = {};
	var _canvas_container_elem = null;

	/**
	 * Create a preloader.
	 * @param {Object} options Initialization options.
	 * @param {string} [options.container_color] The CSS background color of the preloader container.
	 * @param {string} [options.bar_color] The CSS background color of the preloader bar.
	 * @param {string} [options.frame_color] The CSS color of the preloader frame border.
	 * @param {string} [options.font_color] The CSS color of the preloader font.
	 * @cc_externs container_color bar_color frame_color font_color
	 */
	exports.create_preloader = function(options) {
	    var container_color = PL_CONT_BG_COLOR;
	    var bar_color       = PL_BAR_BG_COLOR;
	    var frame_color     = PL_BAR_BORDER_COLOR;
	    var font_color      = PL_FONT_COLOR;

	    for (var opt in options) {
	        switch (opt) {
	        case "container_color":
	            container_color = options.container_color;
	            break;
	        case "bar_color":
	            bar_color = options.bar_color;
	            break;
	        case "frame_color":
	            frame_color = options.frame_color;
	            break;
	        case "font_color":
	            font_color = options.font_color;
	            break;
	        }
	    }

	    var pl_cont     = document.createElement("div");
	    var pl_bar      = pl_cont.cloneNode(false);
	    var pl_frame    = pl_cont.cloneNode(false);
	    var pl_caption  = pl_cont.cloneNode(false);
	    var canvas_cont = m_cont.get_container();

	    pl_frame.appendChild(pl_bar);
	    pl_frame.appendChild(pl_caption);
	    pl_cont.appendChild(pl_frame);
	    canvas_cont.appendChild(pl_cont);

	    pl_cont.style.cssText =
	        "background-color: " + container_color + ";" +
	        "width: 100%;" +
	        "height: 100%;" +
	        "position: absolute;" +
	        "top: 0;" +
	        "left: 0;";

	    pl_frame.style.cssText =
	        "position: absolute;" +
	        "left: 50%;" +
	        "top: 50%;" +
	        "margin-left: -150px;" +
	        "margin-top: -30px;" +
	        "width: 300px;" +
	        "height: 28px;" +
	        "box-shadow: 0px 0px 10px 0px " + frame_color + ";" +
	        "border: 2px solid " + frame_color + ";";

	    pl_bar.style.cssText =
	        "position: absolute;" +
	        "width: 0%;" +
	        "top: 0;" +
	        "left: 0;" +
	        "background-color: " + bar_color + ";" +
	        "height: 100%;";

	    pl_caption.style.cssText =
	        "font-family: Arial, sans-serif;" +
	        "line-height: 28px;" +
	        "height: 100%;" +
	        "width: 100%;" +
	        "top: 0;" +
	        "left: 0;" +
	        "text-align: center;" +
	        "position: absolute;" +
	        "font-size: 16px;" +
	        "font-weight: bold;" +
	        "text-shadow: 0px 0px 6px " + frame_color + ";" +
	        "color: " + font_color + ";";

	    _preloader.bar = pl_bar;
	    _preloader.caption = pl_caption;
	    _preloader.container = pl_cont;
	    _preloader.type = "DEFAULT";
	};

	/**
	 * Create a simple preloader.
	 * @param {Object} options Initialization options.
	 * @param {string} options.canvas_container_id Canvas container ID.
	 * @param {string} [options.background_container_id] Background container ID.
	 * @param {string} [options.bg_color] Background color.
	 * @param {string} [options.bar_color] Load bar color.
	 * @cc_externs bar_color bg_color background_container_id
	 * @cc_externs canvas_container_id preloader_fadeout
	 * @deprecated Use custom preloader or {@link module:preloader.create_preloader|preloader.create_preloader}.
	 */
	exports.create_simple_preloader = function(options) {
	    var canvas_container_id = null;
	    var background_container_id = null;
	    var bar_color = "#bf9221";
	    var bg_color = "#000";

	    for (var opt in options) {
	        switch (opt) {
	        case "canvas_container_id":
	            canvas_container_id = options.canvas_container_id;
	            break;
	        case "background_container_id":
	            background_container_id = options.background_container_id;
	            break;
	        case "bg_color":
	            bg_color = options.bg_color;
	            break;
	        case "bar_color":
	            bar_color = options.bar_color;
	            break;
	        case "preloader_fadeout":
	            _preloader.fadeout = options.preloader_fadeout;
	            break;
	        }
	    }

	    var container = document.createElement("div");
	    var frame = document.createElement("div");
	    container.id = "simple_preloader_container";
	    var bar = document.createElement("div");
	    var caption = document.createElement("div");
	    var background_container = document.getElementById(background_container_id);

	    _canvas_container_elem = document.getElementById(canvas_container_id);

	    container.style.cssText =
	        "z-index: 4;" +
	        "background-color: " + bg_color + ";" +
	        "width: 100%;" +
	        "height: 100%;" +
	        "position: absolute;" +
	        "margin: 0;" +
	        "padding: 0;" +
	        "top: 0;" +
	        "left: 0;";

	    frame.style.cssText =
	        "position: absolute;" +
	        "left: 50%;" +
	        "top: 82%;" +
	        "width: 300px;" +
	        "height: 20px;" +
	        "margin-left: -150px;" +
	        "margin-top: -10px;" +
	        "border-style:solid;" +
	        "border-width:4px;" +
	        "border-color: " + "#000" + ";" +
	        "border-radius: 0px;";

	    bar.style.cssText =
	        "position: absolute;" +
	        "left: 0px;" +
	        "top: 1px;" +
	        "width: 0px;" +
	        "height: 18px;" +
	        "background-color: " + bar_color + ";" +
	        "border-radius: 0px;";

	    caption.style.cssText =
	        "position: absolute;" +
	        "left: 50%;" +
	        "top: 50%;" +
	        "width: 100%;" +
	        "height: 100%;" +
	        "margin-left: -150px;" +
	        "margin-top: -10px;" +
	        "text-align: center;" +
	        "font-size: 17px;" +
	        "font-weight: bold;" +
	        "color: #000;" +
	        "font-family: Verdana;" +

	    frame.appendChild(bar);
	    frame.appendChild(caption);
	    container.appendChild(frame);

	    document.body.appendChild(container);

	    _preloader.type = "SIMPLE";
	    _preloader.container = container;
	    _preloader.bar = bar;
	    _preloader.caption = caption;
	    _preloader.background = background_container;
	};

	/**
	 * Create a rotation preloader.
	 * @param {Object} options Initialization options.
	 * @param {string} options.canvas_container_id Canvas container ID.
	 * @param {string} [options.background_container_id] Background container ID.
	 * @param {string} [options.bg_color] Background color.
	 * @param {string} [options.frame_bg_color] Frame background color.
	 * @param {string} [options.frame_class] CSS frame class.
	 * @param {string} [options.anim_elem_class] Animated element class.
	 * @cc_externs frame_bg_color frame_class anim_elem_class
	 * @deprecated Use custom preloader or {@link module:preloader.create_preloader|preloader.create_preloader}.
	 */
	exports.create_rotation_preloader = function(options) {
	    var canvas_container_id = null;
	    var background_container_id = null;
	    var frame_bg_color = "rgba(0,0,0,0)";
	    var frame_class = "";
	    var anim_elem_class = "";
	    var bg_color = "rgba(0,0,0,0)";

	    for (var opt in options) {
	        switch (opt) {
	        case "canvas_container_id":
	            canvas_container_id = options.canvas_container_id;
	            break;
	        case "background_container_id":
	            background_container_id = options.background_container_id;
	            break;
	        case "frame_bg_color":
	            frame_bg_color = options.frame_bg_color;
	            break;
	        case "bg_color":
	            bg_color = options.bg_color;
	            break;
	        case "frame_class":
	            frame_class = options.frame_class;
	            break;
	        case "anim_elem_class":
	            anim_elem_class = options.anim_elem_class;
	            break;
	        }
	    }

	    var container = document.createElement("div");
	    var frame = document.createElement("div");
	    var anim_elem = document.createElement("div");
	    var caption = document.createElement("div");
	    var background_container = document.getElementById(background_container_id);

	    _canvas_container_elem = document.getElementById(canvas_container_id);

	    container.style.cssText =
	        "z-index: 4;" +
	        "background-color: " + bg_color + ";" +
	        "width: 100%;" +
	        "height: 100%;" +
	        "position: absolute;" +
	        "margin: 0;" +
	        "padding: 0;" +
	        "top: 0;" +
	        "left: 0;";

	    frame.style.cssText =
	        "position: absolute;" +
	        "left: 50%;" +
	        "top: 50%;" +
	        "width: 117px;" +
	        "height: 117px;" +
	        "margin-left: -58px;" +
	        "margin-top: -58px;" +
	        "background-color: " + frame_bg_color + ";";

	    anim_elem.style.cssText =
	        "position: absolute;" +
	        "left: 0px;" +
	        "top: 0px;" +
	        "width: 100%;" +
	        "height: 100%;" +
	        "background-position: center;" +
	        "background-repeat: no-repeat;";

	    caption.style.cssText =
	        "position: absolute;" +
	        "width: 100%;" +
	        "height: 100%;" +
	        "text-align: center;" +
	        "margin-top: 38px;" +
	        "font-size: 36px;" +
	        "color: #ffffff;" +
	        "font-family: Arial;" +
	        "font-weight: bold;";

	    anim_elem.className = anim_elem_class;
	    frame.appendChild(anim_elem);
	    frame.className = frame_class;
	    frame.appendChild(caption);
	    container.appendChild(frame);

	    _canvas_container_elem.appendChild(container);

	    _preloader.type = "ROTATION";
	    _preloader.container = container;
	    _preloader.anim_elem = anim_elem;
	    _preloader.caption = caption;
	    _preloader.background = background_container;
	};

	/**
	 * Create an advanced preloader.
	 * @param {Object} options Initialization options.
	 * @param {string} options.canvas_container_id Canvas container ID.
	 * @param {string} options.background_container_id Background container ID.
	 * @param {string} options.preloader_bar_id Preloader bar ID.
	 * @param {string} options.fill_band_id Preloader band ID.
	 * @param {string} options.preloader_caption_id Preloader caption ID.
	 * @param {string} options.preloader_container_id Preloader container ID.
	 * @param {number} options.img_width Device image width.
	 * @param {number} options.preloader_width Preloader width.
	 * @cc_externs fill_band_id preloader_bar_id preloader_caption_id
	 * @cc_externs preloader_container_id img_width preloader_width
	 * @deprecated Use custom preloader or {@link module:preloader.create_preloader|preloader.create_preloader}.
	 */
	exports.create_advanced_preloader = function(options) {
	    var img_width = options.img_width;
	    var preloader_width = options.preloader_width;
	    var canvas_container_id = options.canvas_container_id;

	    var band_width = preloader_width - img_width;
	    var ratio = preloader_width / band_width;

	    var preloader_bar = document.getElementById(options.preloader_bar_id);
	    var fill_band = document.getElementById(options.fill_band_id);
	    var preloader_caption = document.getElementById(options.preloader_caption_id);
	    var preloader_container = document.getElementById(options.preloader_container_id);
	    var background_container = document.getElementById(options.background_container_id);

	    _canvas_container_elem = document.getElementById(canvas_container_id);

	    _preloader.type = "ADVANCED";
	    _preloader.bar = preloader_bar;
	    _preloader.fill = fill_band;
	    _preloader.ratio = ratio;

	    _preloader.caption = preloader_caption;
	    _preloader.container = preloader_container;
	    _preloader.background = background_container;
	};

	/**
	 * Update the preloader bar status.
	 * @param {number} percentage The new preloader bar percentage
	 */
	exports.update_preloader = function(percentage) {
	    _preloader.caption.innerHTML = percentage + "%";

	    if (_preloader.type == "SIMPLE")
	        _preloader.bar.style.width = percentage + "%";
	    else if (_preloader.type == "ADVANCED") {
	        _preloader.bar.style.width = percentage / _preloader.ratio + "%";
	        _preloader.fill.style.width = (100 - percentage) + "%";
	    } else if (_preloader.type == "ROTATION")
	        _preloader.anim_elem.style.transform = "rotate(" + percentage + "deg)";
	    else if (_preloader.type == "DEFAULT")
	        _preloader.bar.style.width = percentage + "%";

	    if (percentage == 100) {
	        _preloader.container.parentNode.removeChild(_preloader.container);

	        if (_preloader.background)
	            _preloader.background.parentNode.removeChild(_preloader.background);
	    }
	};

	}

	var preloader_factory = register("preloader", Preloader);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Screen shooter add-on.
	 * @module screenshooter
	 */
	function Screenshooter(ns, exports) {

	var m_screen = screen_factory(ns);
	var m_print  = print_factory(ns);

	/**
	 * Take a screenshot and download as screenshot.png image.
	 * @method module:screenshooter.shot
	 * @param {string} [format="image/png"] The MIME image format ("image/png",
	 * "image/jpeg", "image/webp" and so on)
	 * @param {number} [quality=1.0] Number between 0 and 1 for types: "image/jpeg",
	 * "image/webp"
	 * @example
	 * var m_scrn = require("screenshooter");
	 * m_scrn.shot();
	 * @deprecated Use {@link module:screen.shot} instead
	 */
	exports.shot = function(format, quality) {
	    m_print.error_deprecated("shot", "screen.shot");
	    m_screen.shot(format, quality);
	};

	}

	var screenshooter_factory = register("screenshooter", Screenshooter);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Anchors are Empty objects assigned in Blender.
	 * They are used to project 3D points or HTML elements to the 2D screen.
	 * <p>For more info about anchor configuration check out the {@link https://www.blend4web.com/doc/en/objects.html#anchor-settings|user manual}.
	 * @module anchors
	 * @local AnchorMoveCallback
	 */
	function Anchors(ns, exports) {

	var m_anchors = int_anchors_factory(ns);

	/**
	 * The callback for the movement of the anchor.
	 * @callback AnchorMoveCallback
	 * @param {number} x X (left) canvas coordinate.
	 * @param {number} y Y (top) canvas coordinate.
	 * @param {string} appearance Anchor appearance, one of "visible", "out",
	 * "covered"
	 * @param {Object3D} obj Anchor object.
	 * @param {?HTMLElement} anchor Anchor HTML element
	 */

	/**
	 * Attach the movement callback to the anchor object.
	 * @method module:anchors.attach_move_cb
	 * @param {Object3D} obj Anchor object.
	 * @param {AnchorMoveCallback} anchor_move_cb Anchor movement callback
	 */
	exports.attach_move_cb = m_anchors.attach_move_cb;

	/**
	 * Detach the movement callback from the anchor object.
	 * @method module:anchors.detach_move_cb
	 * @param {Object3D} obj Anchor object.
	 */
	exports.detach_move_cb = m_anchors.detach_move_cb;

	/**
	 * Check if the given object is an anchor.
	 * @method module:anchors.is_anchor
	 * @param {Object3D} obj Anchor object.
	 * @returns {boolean} Check result.
	 */
	exports.is_anchor = m_anchors.is_anchor;

	/**
	 * Get anchor element ID.
	 * @method module:anchors.get_element_id
	 * @param {Object3D} obj Anchor object.
	 * @returns {string|boolean} Element ID or FALSE if the given object is not a 
	 * valid anchor.
	 */
	exports.get_element_id = m_anchors.get_element_id;

	/**
	 * Force update positions of anchors.
	 * @method module:anchors.update
	 */
	exports.update = function() {
	    m_anchors.update(true);
	};

	}

	var anchors_factory = register("anchors", Anchors);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * API methods to control armature objects.
	 * @module armature
	 */
	function Armature(ns, exports) {

	var m_armat    = int_armature_factory(ns);
	var m_obj_util = int_obj_util_factory(ns);
	var m_trans    = int_transform_factory(ns);
	var m_print    = print_factory(ns);

	/**
	 * Get translation, scale and rotation quaternion of the armature's bone,
	 * defined in armature space.
	 * @method module:armature.get_bone_tsr
	 * @param {Object3D} armobj Armature object
	 * @param {string} bone_name Bone name
	 * @param {TSR} [dest] Destination vector
	 * @returns {?TSR} Destination vector
	 */
	exports.get_bone_tsr = function(armobj, bone_name, dest) {
	    if (!m_obj_util.is_armature(armobj))
	        return null;

	    if (!m_armat.check_bone(armobj, bone_name)) {
	        m_print.error("There is no bone: \"", bone_name, "\" in \"", armobj.name, "\".");
	        return null;
	    }

	    if (!dest)
	        dest = new Float32Array(8);

	    m_armat.get_bone_tsr(armobj, bone_name, false, false, dest);
	    return dest;
	};

	/**
	 * Get translation, scale and rotation quaternion of the armature's bone,
	 * defined in parent bone space.
	 * @method module:armature.get_bone_tsr_rel
	 * @param {Object3D} armobj Armature object
	 * @param {string} bone_name Bone name
	 * @param {TSR} [dest] Destination vector
	 * @returns {?TSR} Destination vector
	 */
	exports.get_bone_tsr_rel = function(armobj, bone_name, dest) {
	    if (!m_obj_util.is_armature(armobj))
	        return null;

	    if (!m_armat.check_bone(armobj, bone_name)) {
	        m_print.error("There is no bone: \"", bone_name, "\" in \"", armobj.name, "\".");
	        return null;
	    }

	    if (!dest)
	        dest = new Float32Array(8);

	    m_armat.get_bone_tsr(armobj, bone_name, false, true, dest);
	    return dest;
	};

	/**
	 * Set translation, scale and rotation quaternion of the armature's bone,
	 * defined in armature space.
	 * @method module:armature.set_bone_tsr
	 * @param {Object3D} armobj Armature object
	 * @param {string} bone_name Bone name
	 * @param {TSR} tsr Translation, scale and rotation quaternion
	 */
	exports.set_bone_tsr = function(armobj, bone_name, tsr) {
	    if (!m_obj_util.is_armature(armobj))
	        return;

	    if (!m_armat.check_bone(armobj, bone_name)) {
	        m_print.error("There is no bone: \"", bone_name, "\" in \"", armobj.name, "\".");
	        return;
	    }

	    m_armat.set_bone_tsr(armobj, bone_name, tsr, false);
	    m_trans.update_transform(armobj);
	};

	/**
	 * Set translation, scale and rotation quaternion of the armature's bone,
	 * defined in parent bone space.
	 * @method module:armature.set_bone_tsr_rel
	 * @param {Object3D} armobj Armature object
	 * @param {string} bone_name Bone name
	 * @param {TSR} tsr Translation, scale and rotation quaternion
	 */
	exports.set_bone_tsr_rel = function(armobj, bone_name, tsr) {
	    if (!m_obj_util.is_armature(armobj))
	        return;

	    if (!m_armat.check_bone(armobj, bone_name)) {
	        m_print.error("There is no bone: \"", bone_name, "\" in \"", armobj.name, "\".");
	        return;
	    }

	    m_armat.set_bone_tsr(armobj, bone_name, tsr, true);
	    m_trans.update_transform(armobj);
	};

	}

	var armature_factory = register("armature", Armature);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/** 
	 * Low-level resource loader. In order to load exported scenes, use the {@link module:data|data} module instead.
	 * @module assets
	 * @local AssetRequest
	 * @local AssetType
	 * @local AssetCallback
	 * @local ProgressCallback
	 * @local PackCallback
	 */
	function Assets(ns, exports) {

	var m_assets = int_assets_factory(ns);

	/**
	 * An object that defines how the asset resource should be loaded.
	 * @typedef {Object} AssetRequest
	 * @property {*} id Asset identifier. Passed to the 
	 * {@link AssetCallback|AssetCallback} as a parameter. Can be unique to  
	 * distinguish asset requests if needed.
	 * @property {AssetType} type Asset type.
	 * @property {string} url URL of a resource.
	 * @property {string} [request_method="GET"] Request method. Supported are "GET" and "POST".
	 * @property {Object} [overwrite_header] An object containing fields for 
	 * overwriting request headers. For example: { "Content-Type": "image/png" }.
	 * @property {*} [post_data] The request body that will be sent in a "POST" request. 
	 * @property {*} [param] An optional parameter that will be passed to the 
	 * {@link AssetCallback|AssetCallback}.
	 * @cc_externs id type url request_method overwrite_header post_data param
	 */

	/**
	 * Asset type. Defines which type of data will be loaded, e.g: json, plain text,
	 * binary buffer, ...
	 * @typedef {number} AssetType
	 * @see {@link module:assets.AT_ARRAYBUFFER|AT_ARRAYBUFFER},
	 * {@link module:assets.AT_ARRAYBUFFER_ZIP|AT_ARRAYBUFFER_ZIP},
	 * {@link module:assets.AT_JSON|AT_JSON},
	 * {@link module:assets.AT_JSON_ZIP|AT_JSON_ZIP},
	 * {@link module:assets.AT_TEXT|AT_TEXT},
	 * {@link module:assets.AT_AUDIOBUFFER|AT_AUDIOBUFFER},
	 * {@link module:assets.AT_IMAGE_ELEMENT|AT_IMAGE_ELEMENT},
	 * {@link module:assets.AT_AUDIO_ELEMENT|AT_AUDIO_ELEMENT},
	 * {@link module:assets.AT_VIDEO_ELEMENT|AT_VIDEO_ELEMENT},
	 * {@link module:assets.AT_SEQ_VIDEO_ELEMENT|AT_SEQ_VIDEO_ELEMENT},
	 */

	/**
	 * Callback executed after a single asset is loaded.
	 * @callback AssetCallback
	 * @param {Data} data Loaded data.
	 * @param {*} id Data asset ID.
	 * @param {AssetType} type Data type.
	 * @param {string} url URL of a resource.
	 * @param {*} [opt_param] Optional parameter
	 */

	/**
	 * Callback executed after the whole pack of assets is loaded.
	 * @callback PackCallback
	 */

	/**
	 * Callback for the progress of loading.
	 * @callback ProgressCallback
	 * @param {number} rate Amount of loaded data: 0 to 1.
	 */

	/**
	 * Asset type intended for loading various binary data. The loaded data will be 
	 * available as an ArrayBuffer object. Supported request methods: "GET".
	 * @const {AssetType} module:assets.AT_ARRAYBUFFER
	 */
	exports.AT_ARRAYBUFFER = m_assets.AT_ARRAYBUFFER;

	/**
	 * Asset type intended for loading compressed binary data of a GZIP format. The 
	 * loaded data will be available as an ArrayBuffer object. Supported request 
	 * methods: "GET".
	 * @const {AssetType} module:assets.AT_ARRAYBUFFER_ZIP
	 */
	exports.AT_ARRAYBUFFER_ZIP = m_assets.AT_ARRAYBUFFER_ZIP;

	/**
	 * Asset type intended for loading JSON files. The loaded data will be available 
	 * as a JSON object. Supported request methods: "GET", "POST".
	 * @const {AssetType} module:assets.AT_JSON
	 */
	exports.AT_JSON = m_assets.AT_JSON;

	/**
	 * Asset type intended for loading JSON files compressed in a GZIP format. The 
	 * loaded data will be available as a JSON object. Supported request methods: 
	 * "GET".
	 * @const {AssetType} module:assets.AT_JSON_ZIP
	 */
	exports.AT_JSON_ZIP = m_assets.AT_JSON_ZIP;

	/**
	 * Asset type intended for loading files with a plain text. The loaded data will
	 * be available as a String object. Supported request methods: "GET", "POST".
	 * @const {AssetType} module:assets.AT_TEXT
	 */
	exports.AT_TEXT = m_assets.AT_TEXT;

	/**
	 * Asset type intended for loading audio files (preferably short audio assets). 
	 * The loaded data will be available as an AudioBuffer object. Supported request 
	 * methods: "GET".
	 * @const {AssetType} module:assets.AT_AUDIOBUFFER
	 */
	exports.AT_AUDIOBUFFER = m_assets.AT_AUDIOBUFFER;

	/**
	 * Asset type intended for loading common image files (JPEG, PNG, GIF). The 
	 * loaded data will be available as an HTMLImageElement object. Supported 
	 * request methods: "GET".
	 * @const {AssetType} module:assets.AT_IMAGE_ELEMENT
	 */
	exports.AT_IMAGE_ELEMENT = m_assets.AT_IMAGE_ELEMENT;

	/**
	 * Asset type intended for loading common audio files. The loaded data will be 
	 * available as an HTMLAudioElement object. Supported request methods: "GET".
	 * @const {AssetType} module:assets.AT_AUDIO_ELEMENT
	 */
	exports.AT_AUDIO_ELEMENT = m_assets.AT_AUDIO_ELEMENT;

	/**
	 * Asset type intended for loading common video files. The loaded data will be 
	 * available as an HTMLVideoElement object. Supported request methods: "GET".
	 * @const {AssetType} module:assets.AT_VIDEO_ELEMENT
	 */
	exports.AT_VIDEO_ELEMENT = m_assets.AT_VIDEO_ELEMENT;

	/**
	 * Asset type intended for loading video files of a special ".seq" format. The 
	 * loaded data will be available as an object of the following structure:
	 * { images: [HTMLImageElement, ...], fps: number }. Supported request methods: 
	 * "GET".
	 * @see https://www.blend4web.com/doc/en/developers.html#seq-video-format
	 * @const {AssetType} module:assets.AT_SEQ_VIDEO_ELEMENT
	 */
	exports.AT_SEQ_VIDEO_ELEMENT = m_assets.AT_SEQ_VIDEO_ELEMENT;


	/**
	 * Add the assets to the loading queue.
	 * @method module:assets.enqueue
	 * @param {AssetRequest[]} assets_pack Array of the asset requests.
	 * @param {AssetCallback} [asset_cb] Callback executed after a single asset is loaded
	 * @param {PackCallback} [pack_cb] Callback executed after the whole pack of assets is loaded
	 * @param {ProgressCallback} [progress_cb] Callback for the progress of loading.
	 * @example var m_assets = require("assets");
	 *
	 * var asset_cb = function(data, id, type, url) {
	 *      console.log("LOADED:", url);
	 * }
	 * 
	 * var pack_cb() {
	 *      console.log("ALL DATA LOADED!");
	 * }
	 *
	 * var progress_cb = function(rate) {
	 *      console.log(rate * 100 + "% LOADED");
	 * }
	 *
	 * m_assets.enqueue([
	 *      {id: "my_json001", type: m_assets.AT_JSON, url: "./my_json.json"}, 
	 *      {id: "my_img001", type: m_assets.AT_IMAGE_ELEMENT, url: "./my_image.jpg"}
	 *      ], asset_cb, pack_cb, progress_cb);
	 */
	exports.enqueue = function(assets_pack, asset_cb, pack_cb, progress_cb) {
	    if (assets_pack.length)
	        m_assets.enqueue(assets_pack, asset_cb, pack_cb, progress_cb);
	};

	}

	var assets_factory = register("assets", Assets);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Low-level geometry API.
	 * Enable the "Dynamic geometry" checkbox for the objects to allow geometry modification.
	 * @module geometry
	 */
	function Geometry(ns, exports) {

	var m_batch  = int_batch_factory(ns);
	var m_geom   = int_geometry_factory(ns);
	var m_print  = print_factory(ns);
	var m_render = int_renderer_factory(ns);
	var m_tbn    = int_tbn_factory(ns);

	/**
	 * Extract the vertex array from the object.
	 * @method module:geometry.extract_vertex_array
	 * @param {Object3D} obj Object 3D
	 * @param {string} mat_name Material name
	 * @param {string} attrib_name Attribute name (a_position, a_tbn, a_normal)
	 * @returns {Float32Array} Vertex array
	 */
	exports.extract_vertex_array = function(obj, mat_name, attrib_name) {

	    if (!m_geom.has_dyn_geom(obj)) {
	        m_print.error("Wrong object:", obj.name);
	        return null;
	    }

	    var batch = m_batch.find_batch_material(obj, mat_name, "MAIN");
	    if (batch) {
	        var bufs_data = batch.bufs_data;
	        if (bufs_data && bufs_data.pointers &&
	                (attrib_name == "a_normal" && bufs_data.pointers["a_tbn"] ||
	                bufs_data.pointers[attrib_name])) {
	            return m_geom.extract_array_float(bufs_data, attrib_name);
	        } else {
	            m_print.error("Attribute not found:" + attrib_name);
	            return null;
	        }
	    } else {
	        m_print.error("Wrong material:", mat_name);
	        return null;
	    }
	};

	/**
	 * Extract the array of triangulated face indices from the given object.
	 * @method module:geometry.extract_index_array
	 * @param {Object3D} obj Object 3D
	 * @param {string} mat_name Material name
	 * @returns {Uint16Array|Uint32Array} Array of triangle indices
	 */
	exports.extract_index_array = function(obj, mat_name) {

	    if (!m_geom.has_dyn_geom(obj)) {
	        m_print.error("Wrong object:", obj.name);
	        return null;
	    }

	    var batch = m_batch.find_batch_material(obj, mat_name, "MAIN");

	    if (batch) {
	        var bufs_data = batch.bufs_data;
	        if (bufs_data && bufs_data.pointers) {
	            return bufs_data.ibo_array;
	        } else {
	            m_print.error("Buffer data not found");
	            return null;
	        }
	    } else {
	        m_print.error("Wrong material:", mat_name);
	        return null;
	    }
	};

	/**
	 * Update the vertex array for the given object.
	 * @method module:geometry.update_vertex_array
	 * @param {Object3D} obj Object 3D
	 * @param {string} mat_name Material name
	 * @param {string} attrib_name Attribute name (a_position, a_tbn, a_normal)
	 * @param {Float32Array} array The new array
	 */
	exports.update_vertex_array = function(obj, mat_name, attrib_name, array) {
	    if (!m_geom.has_dyn_geom(obj)) {
	        m_print.error("Wrong object:", obj.name);
	        return;
	    }

	    var types = ["MAIN", "SHADOW", "COLOR_ID"];
	    for (var i = 0; i < types.length; i++) {
	        var type = types[i];

	        var batch = m_batch.find_batch_material(obj, mat_name, type);

	        if (batch) {
	            var bufs_data = batch.bufs_data;

	            if (bufs_data && bufs_data.pointers &&
	                    (attrib_name == "a_normal" && bufs_data.pointers["a_tbn"] ||
	                    bufs_data.pointers[attrib_name]))
	                m_geom.update_bufs_data_array(bufs_data, attrib_name, 0, array);
	        }
	    }
	};

	/**
	 * Override geometry for the given object.
	 * @method module:geometry.override_geometry
	 * @param {Object3D} obj Object 3D
	 * @param {string} mat_name Material name
	 * @param {Uint16Array|Uint32Array} ibo_array Array of triangle indices
	 * @param {Float32Array} positions_array New vertex positions array
	 * @param {boolean} smooth_normals Enable normals smoothing
	 */
	exports.override_geometry = function(obj, mat_name, ibo_array,
	                                        positions_array, smooth_normals) {
	    if (!m_geom.has_dyn_geom(obj)) {
	        m_print.error("Wrong object:", obj.name);
	        return;
	    }

	    if (!(ibo_array instanceof Uint16Array) &&
	        !(ibo_array instanceof Uint32Array)) {
	            m_print.error("Wrong ibo_array type");
	            return;
	    }

	    if (!(positions_array instanceof Float32Array)) {
	        m_print.error("Wrong positions_array type");
	        return;
	    }

	    var types = ["MAIN", "SHADOW", "COLOR_ID"];
	    for (var i = 0; i < types.length; i++) {
	        var batch_type = types[i];
	        var batch = m_batch.find_batch_material(obj, mat_name, batch_type);

	        if (batch) {
	            var bufs_data = batch.bufs_data;

	            if (bufs_data) {
	                m_geom.update_bufs_data_index_array(bufs_data, batch.draw_mode,
	                        ibo_array);

	                var lengths = {};
	                for (var attr in bufs_data.pointers) {
	                    var pointer = bufs_data.pointers[attr];

	                    var len = positions_array.length / 3 * pointer.num_comp;
	                    var type = m_geom.get_vbo_type_by_attr_name(attr);

	                    if (!lengths[type])
	                        lengths[type] = 0;
	                    lengths[type] += len;
	                }

	                var vbo_source_data = m_geom.init_vbo_source_data(lengths);
	                bufs_data.vbo_source_data = vbo_source_data;

	                var offsets = {};
	                for (var attr in bufs_data.pointers) {
	                    var pointer = bufs_data.pointers[attr];
	                    var type = m_geom.get_vbo_type_by_attr_name(attr);

	                    if (!offsets[type])
	                        offsets[type] = 0;

	                    switch (attr) {
	                    case "a_position":
	                        m_geom.vbo_source_data_set_attr(bufs_data.vbo_source_data, 
	                                "a_position", positions_array, offsets[type]);
	                        pointer.offset = offsets[type];
	                        pointer.length = positions_array.length;
	                        offsets[type] += pointer.length;
	                        break;
	                    case "a_tbn":
	                        var shared_indices;

	                        if (smooth_normals)
	                            shared_indices = m_geom.calc_shared_indices(
	                                ibo_array, positions_array, positions_array);

	                        var normals = m_geom.calc_normals(ibo_array,
	                                      positions_array, shared_indices);

	                        pointer.length = positions_array.length / 3 * pointer.num_comp;
	                        var tangents = new Float32Array(pointer.length);

	                        for (var j = 0; j < tangents.length; j +=4) {
	                            tangents[j] = 1;
	                            tangents[j + 3] = 1;
	                        }

	                        var a_tbn = m_tbn.from_norm_tan(normals, tangents);
	                        m_geom.vbo_source_data_set_attr(bufs_data.vbo_source_data, 
	                                "a_tbn", a_tbn, offsets[type]);
	                        pointer.offset = offsets[type];
	                        offsets[type] += pointer.length;
	                        break;
	                    default:
	                        pointer.offset = offsets[type];
	                        pointer.length = positions_array.length / 3 * pointer.num_comp;

	                        var constructor = m_geom.get_constructor_by_type(type);
	                        var new_array = new constructor(pointer.length);
	                        m_geom.vbo_source_data_set_attr(bufs_data.vbo_source_data, 
	                                attr, new_array, offsets[type]);
	                        offsets[type] += pointer.length;
	                        break;
	                    }
	                }

	                m_geom.update_gl_buffers(bufs_data);
	                m_render.assign_attribute_setters(batch);

	                // NOTE: process child batches if bufs_data was copied not by link
	                var child_batch = m_batch.find_batch_material_forked(obj, batch);
	                if (child_batch && child_batch.bufs_data)
	                    child_batch.bufs_data = bufs_data;

	            }
	        }
	    }
	};
	/**
	 * Apply shape key to the object. If the object is supposed to be available for 
	 * selecting (for example, via the {@link module:scenes.pick_object|pick_object} 
	 * method) call the {@link module:objects.update_boundings|update_boundings} method 
	 * after applying a shape key or override object bounding volumes in Blender 
	 * beforehand so that the boundings can contain the object in its largest shape.
	 * @method module:geometry.set_shape_key_value
	 * @param {Object3D} obj Object 3D
	 * @param {string} key_name Shape key name
	 * @param {number} value Shape key value
	 * @example var m_geom = require("geometry");
	 * var m_scenes = require("scenes");
	 *
	 * var cube = m_scenes.get_object_by_name("Cube");
	 * m_geom.set_shape_key_value(cube, "Key 1", 0.5);
	 */
	exports.set_shape_key_value = function(obj, key_name, value) {
	    if (!m_geom.check_shape_keys(obj)) {
	        m_print.error("Wrong object:", obj.name);
	        return;
	    }

	    if (!m_geom.has_shape_key(obj, key_name)) {
	        m_print.error("Wrong key name:", key_name);
	        return;
	    }

	    var float_value = parseFloat(value);

	    m_geom.apply_shape_key(obj, key_name, float_value);
	};
	/**
	 * Check if object has got shape keys.
	 * @method module:geometry.check_shape_keys
	 * @param {Object3D} obj Object 3D
	 * @returns {boolean} Checking result.
	 */
	exports.check_shape_keys = function(obj) {
	    return m_geom.check_shape_keys(obj);
	};
	/**
	 * Return all available shape keys names.
	 * @method module:geometry.get_shape_keys_names
	 * @param {Object3D} obj Object 3D
	 * @returns {string[]} Array of animation names
	 */
	exports.get_shape_keys_names = function(obj) {

	    if (!m_geom.check_shape_keys(obj)) {
	        m_print.error("Wrong object:", obj.name);
	        return [];
	    }

	    return m_geom.get_shape_keys_names(obj);
	};
	/**
	 * Return shape key current value.
	 * @method module:geometry.get_shape_key_value
	 * @param {Object3D} obj Object 3D
	 * @param {string} key_name Shape key name
	 * @returns {number} value Shape key value
	 */
	exports.get_shape_key_value = function(obj, key_name) {

	    if (!m_geom.check_shape_keys(obj)) {
	        m_print.error("Wrong object:", obj.name);
	        return 0;
	    }

	    if (!m_geom.has_shape_key(obj, key_name)) {
	        m_print.error("Wrong key name:", key_name);
	        return 0;
	    }

	    return m_geom.get_shape_key_value(obj, key_name);
	};

	/**
	 * Draw a line.
	 * @method module:geometry.draw_line
	 * @param {Object3D} obj Line object
	 * @param {Float32Array} positions Line points [X0,Y0,Z0,X1,Y1,Z1...] in the 
	 * local space of the given line object.
	 * @param {boolean} [is_split=false] True - draw a split line
	 * (points specified in pairs), false - draw continuous line
	 * @example 
	 * var m_geom = require("geometry");
	 * var m_scenes = require("scenes");
	 * 
	 * var empty = m_scenes.get_object_by_name("Empty");
	 * var points = new Float32Array([0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0]); // draw a triangle
	 * m_geom.draw_line(empty, points);
	 */
	exports.draw_line = function(obj, positions, is_split) {
	    is_split = is_split || false;

	    if (!(positions instanceof Float32Array)) {
	        m_print.error("Wrong positions type");
	        return;
	    }

	    var batch = m_batch.get_first_batch(obj);

	    if (batch) {
	        m_geom.draw_line(batch, positions, is_split);
	        m_render.assign_attribute_setters(batch);
	    }
	};

	}

	var geometry_factory = register("geometry", Geometry);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/** 
	 * Head-up display functions.
	 * To work properly requires initialization of the separate canvas element.
	 * @see module:main.init
	 * @module hud
	 */
	function HUD(ns, exports) {

	var m_hud   = int_hud_factory(ns);
	var m_print = print_factory(ns);

	/**
	 * Draw the mixer strip.
	 * Used by mixer addon.
	 * @method module:hud.draw_mixer_strip
	 * @deprecated Use {@link module:screen.draw_mixer_strip} instead
	 */
	exports.draw_mixer_strip = function(id, is_active, slot, params, active_param,
	        mute, solo) {
	    m_print.error_deprecated("draw_mixer_strip", "screen.draw_mixer_strip");
	    m_hud.draw_mixer_strip(id, is_active, slot, params, active_param,
	            mute, solo);
	};

	/**
	 * Plot the array.
	 * @method module:hud.plot_array
	 * @param {string} header Plot header
	 * @param {number} slot Slot number
	 * @param {Float32Array} arr Array
	 * @param {number} arg_min Minimum plot argument value
	 * @param {number} arg_max Maximum plot argument value
	 * @param {number} val_min Minimum plot value
	 * @param {number} val_max Maximum plot value
	 * @deprecated Use {@link module:screen.plot_array} instead
	 */
	exports.plot_array = function(header, slot, arr, arg_min, arg_max, val_min,
	        val_max) {
	    m_print.error_deprecated("plot_array", "screen.plot_array");
	    m_hud.plot_array(header, slot, arr, arg_min, arg_max, val_min, val_max);
	};

	}

	var hud_factory = register("hud", HUD);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * API to control light sources.
	 * @module lights
	 * @local LightParams
	 * @see https://www.blend4web.com/doc/en/lighting.html#lighting-with-light-sources
	 */
	function Lights(ns, exports) {

	// TODO: consider use of standard translation/rotation functions from transform module

	var m_lights   = int_lights_factory(ns);
	var m_obj      = int_objects_factory(ns);
	var m_obj_util = int_obj_util_factory(ns);
	var m_print    = print_factory(ns);
	var m_scenes   = int_scenes_factory(ns);
	var m_trans    = int_transform_factory(ns);
	var m_tsr      = int_tsr_factory(ns);
	var m_util     = int_util_factory(ns);
	var m_vec3     = vec3_factory(ns);

	var _sun_pos        = new Float32Array(3);
	var _date           = {};
	var _max_sun_angle  = 60;

	/**
	 * @typedef {Object} LightParams
	 * @property {string} light_type Light type
	 * @property {number} light_energy Light energy
	 * @property {RGB} light_color Light color
	 * @property {number} light_spot_blend Blend parameter of SPOT light
	 * @property {number} light_spot_size Size parameter of SPOT light
	 * @property {number} light_distance Light falloff distance for POINT and SPOT
	 * lights
	 * @cc_externs light_type light_energy light_color
	 * @cc_externs light_spot_blend light_spot_size light_distance
	*/

	/**
	 * Get lamp objects.
	 * If lamps_type is defined, creates a new array
	 * @method module:lights.get_lamps
	 * @param {string} [lamps_type] Lamps type ("POINT", "SPOT", "SUN", "HEMI")
	 * @returns {Object3D[]} Array with lamp objects.
	 */
	exports.get_lamps = function(lamps_type) {

	    var scene = m_scenes.get_active();
	    var lamps = m_obj.get_scene_objs(scene, "LAMP", m_obj.DATA_ID_ALL);

	    if (!lamps_type)
	        return lamps;

	    var rslt = [];
	    for (var i = 0; i < lamps.length; i++) {
	        var lamp = lamps[i];
	        if (lamp.light.type === lamps_type)
	            rslt.push(lamp);
	    }
	    return rslt;
	};

	exports.get_sun_params = get_sun_params;
	/**
	 * Get the sun parameters.
	 * @method module:lights.get_sun_params
	 * @returns {SunParams} Sun params object
	 * @cc_externs hor_position vert_position
	 */
	function get_sun_params() {
	    var scene = m_scenes.get_active();
	    var lamps = m_obj.get_scene_objs(scene, "LAMP", m_obj.DATA_ID_ALL);
	    var sun = null;

	    for (var i = 0; i < lamps.length; i++) {
	        var lamp = lamps[i];
	        var light = lamp.light;
	        if (light.type == "SUN") {
	            sun = lamp;
	            break
	        }
	    }

	    if (sun) {
	        var cur_dir = sun.light.direction;

	        // sun azimuth
	        var angle_hor = m_util.rad_to_deg(Math.atan2(-cur_dir[1], cur_dir[0])) + 90;
	        if (angle_hor > 180)
	            angle_hor -= 360;

	        // sun altitude
	        var angle_vert = m_util.rad_to_deg(Math.atan2(
	                cur_dir[2],
	                Math.sqrt(cur_dir[0]*cur_dir[0] + cur_dir[1]*cur_dir[1])
	                ));

	        var sun_params = {};
	        sun_params.hor_position  = angle_hor;
	        sun_params.vert_position = angle_vert;
	        return sun_params;
	    } else
	        return null;
	}

	exports.set_sun_params = set_sun_params;
	/**
	 * Set the sun parameters.
	 * @method module:lights.set_sun_params
	 * @param {SunParams} sun_params sun parameters
	 */
	function set_sun_params(sun_params) {

	    var scene = m_scenes.get_active();
	    var lamps = m_obj.get_scene_objs(scene, "LAMP", m_obj.DATA_ID_ALL);

	    // Index of lamp(sun) on the scene

	    for (var i = 0; i < lamps.length; i++) {
	        var lamp = lamps[i];
	        var light = lamp.light;
	        if (light.type == "SUN") {
	            var sun = lamp;
	            break;
	        }
	    }

	    if (!sun) {
	        m_print.error("There is no sun on the scene");
	        return;
	    }

	    if (typeof sun_params.hor_position == "number" &&
	        typeof sun_params.vert_position == "number") {
	        // convert to radians
	        var angle_hor  =  m_util.deg_to_rad(180 - sun_params.hor_position);
	        var angle_vert =  m_util.deg_to_rad(90 - sun_params.vert_position);

	        var sun_render = sun.render;

	        // rotate sun
	        m_trans.set_rotation_euler(sun, [angle_vert, 0, angle_hor]);
	        var dir = new Float32Array(3);
	        var sun_quat = m_tsr.get_quat_view(sun_render.world_tsr);
	        m_util.quat_to_dir(sun_quat, m_util.AXIS_Z, dir);

	        var trans = m_tsr.get_trans_view(sun_render.world_tsr);
	        var dist_to_center = m_vec3.length(trans);

	        m_vec3.copy(dir, _sun_pos);
	        m_vec3.scale(_sun_pos, dist_to_center, _sun_pos);

	        // translate sun
	        m_trans.set_translation(sun, _sun_pos);
	        m_trans.update_transform(sun);

	        var sun_light = sun.light;

	        if (sun_light.dynamic_intensity) {

	            // set amplitude lighting params
	            var def_env_color = scene["world"]["light_settings"]["environment_energy"];
	            var def_horizon_color = scene["world"]["horizon_color"];
	            var def_zenith_color = scene["world"]["zenith_color"];

	            // change sun intensity dependent to its position
	            var energy     = Math.cos(Math.abs(angle_vert));
	            var sun_energy = Math.max( Math.min(3.0 * energy, 1.0), 0.0) * sun_light.default_energy;
	            var env_energy = Math.max(energy, 0.1) * def_env_color;

	            m_lights.set_light_energy(sun_light, sun_energy);

	            m_scenes.set_environment_colors(scene, env_energy, def_horizon_color, def_zenith_color);
	        }
	        m_scenes.update_lamp_scene(sun, scene);
	    }
	}

	exports.set_day_time = set_day_time;
	/**
	 * Set the time of day.
	 * @method module:lights.set_day_time
	 * @param {number} time new time (0.0...24.0)
	 */
	function set_day_time(time) {
	    var scene = m_scenes.get_active();
	    var lamps = m_obj.get_scene_objs(scene, "LAMP", m_obj.DATA_ID_ALL);

	    for (var i = 0; i < lamps.length; i++) {
	        var lamp = lamps[i];
	        var light = lamp.light;
	        if (light.type == "SUN") {
	            var sun = lamp;
	            break;
	        }
	    }

	    if (!sun) {
	        m_print.error("There is no sun on the scene");
	        return;
	    }

	    update_sun_position(time);
	}

	/**
	 * Set the date.
	 * @method module:lights.set_date
	 * @param {Date} date new date
	 */
	exports.set_date = function(date) {
	    _date.y = date.getFullYear();
	    _date.m = date.getMonth();
	    _date.d = date.getDate();
	    if(!_date.y) {
	        m_print.error("There is no year 0 in the Julian system!");
	        return;
	    }
	    if( _date.y == 1582 && _date.m == 9 && _date.d > 4 && _date.d < 15 ) {
	        m_print.error("The dates 5 through 14 October, 1582, do not exist in the Gregorian system!");
	        return;
	    }
	};

	/**
	 * Set the maximum sun angle
	 * @method module:lights.set_max_sun_angle
	 * @param {number} angle New angle in degrees (0..90)
	 */
	exports.set_max_sun_angle = function(angle) {
	    _max_sun_angle = Math.min(Math.max(angle, 0), 90);
	};

	/**
	 * Get the light params.
	 * @method module:lights.get_light_params
	 * @param {Object3D} lamp_obj Lamp object
	 * @returns {LightParams | null} Light params or null in case of error
	 */
	exports.get_light_params = function(lamp_obj) {

	    if (m_obj_util.is_lamp(lamp_obj))
	        var light = lamp_obj.light;
	    else {
	        m_print.error("get_light_params(): Wrong object");
	        return null;
	    }

	    var type = get_light_type(lamp_obj);

	    if (type)
	        switch (type) {
	        case "SPOT":
	            var rslt = {
	                "light_type": type,
	                "light_color": new Float32Array(3),
	                "light_energy": light.energy,
	                "light_spot_blend": light.spot_blend,
	                "light_spot_size": light.spot_size,
	                "light_distance" : light.distance
	            };
	            rslt["light_color"].set(light.color);
	            break;
	        case "POINT":
	            var rslt = {
	                "light_type": type,
	                "light_color": new Float32Array(3),
	                "light_energy": light.energy,
	                "light_distance" : light.distance
	            };
	            rslt["light_color"].set(light.color);
	            break;
	        default:
	            var rslt = {
	                "light_type": type,
	                "light_color": new Float32Array(3),
	                "light_energy": light.energy
	            };
	            rslt["light_color"].set(light.color);
	            break;
	        }
	    if (rslt)
	        return rslt;
	    else
	        return null;
	};

	exports.get_light_type = get_light_type;
	/**
	 * Get the light type.
	 * @method module:lights.get_light_type
	 * @param {Object3D} lamp_obj Lamp object.
	 * @returns {string} Light type
	 */
	function get_light_type(lamp_obj) {
	    if (m_obj_util.is_lamp(lamp_obj))
	        return lamp_obj.light.type;
	    else
	        m_print.error("get_light_type(): Wrong object");
	    return "";
	}
	/**
	 * Set the light params.
	 * @method module:lights.set_light_params
	 * @param {Object3D} lamp_obj Lamp object
	 * @param {LightParams} light_params Light params
	 */
	exports.set_light_params = function(lamp_obj, light_params) {

	    if (m_obj_util.is_lamp(lamp_obj))
	        var light = lamp_obj.light;
	    else {
	        m_print.error("set_light_params(): Wrong object");
	        return;
	    }

	    var scene = m_scenes.get_active();

	    var need_update_shaders = false;

	    if (typeof light_params.light_energy == "number")
	        m_lights.set_light_energy(light, light_params.light_energy);

	    if (typeof light_params.light_color == "object")
	        m_lights.set_light_color(light, light_params.light_color);

	    if (typeof light_params.light_spot_blend == "number") {
	        m_lights.set_light_spot_blend(light, light_params.light_spot_blend);
	        need_update_shaders = true;        
	    }

	    if (typeof light_params.light_spot_size == "number") {
	        m_lights.set_light_spot_size(light, light_params.light_spot_size);
	        need_update_shaders = true;
	    }

	    if (typeof light_params.light_distance == "number") {
	        m_lights.set_light_distance(light, light_params.light_distance);
	        need_update_shaders = true;
	    }

	    m_scenes.update_lamp_scene(lamp_obj, scene);

	    if (need_update_shaders)
	        m_scenes.update_all_mesh_shaders(scene);
	};

	/**
	 * Get the light energy.
	 * @method module:lights.get_light_energy
	 * @param {Object3D} lamp_obj Lamp object
	 * @returns {number} Light energy value
	 */
	exports.get_light_energy = function(lamp_obj) {
	    if (!m_obj_util.is_lamp(lamp_obj)) {
	        m_print.error("get_light_energy(): Wrong object");
	        return 0;
	    }

	    return lamp_obj.light.energy;
	};

	/**
	 * Set the light energy.
	 * @method module:lights.set_light_energy
	 * @param {Object3D} lamp_obj Lamp object
	 * @param {number} energy Light energy value
	 */
	exports.set_light_energy = function(lamp_obj, energy) {
	    if (!m_obj_util.is_lamp(lamp_obj)) {
	        m_print.error("set_light_energy(): Wrong object");
	        return;
	    }

	    var scene = m_scenes.get_active();
	    m_lights.set_light_energy(lamp_obj.light, energy);
	    m_scenes.update_lamp_scene(lamp_obj, scene);
	};

	/**
	 * Get the light color.
	 * @method module:lights.get_light_color
	 * @param {Object3D} lamp_obj Lamp object
	 * @param {?RGB} [dest=new Float32Array(3)] Destination RGB vector
	 * @returns {?RGB} Destination RGB vector
	 */
	exports.get_light_color = function(lamp_obj, dest) {
	    if (!m_obj_util.is_lamp(lamp_obj)) {
	        m_print.error("get_light_color(): Wrong object");
	        return null;
	    }

	    dest = dest || new Float32Array(3);
	    dest.set(lamp_obj.light.color);
	    return dest;
	};

	/**
	 * Set the light color.
	 * @method module:lights.set_light_color
	 * @param {Object3D} lamp_obj Lamp object
	 * @param {RGB} color Light color
	 */
	exports.set_light_color = function(lamp_obj, color) {
	    if (!m_obj_util.is_lamp(lamp_obj)) {
	        m_print.error("set_light_color(): Wrong object");
	        return;
	    }

	    var scene = m_scenes.get_active();
	    m_lights.set_light_color(lamp_obj.light, color);
	    m_scenes.update_lamp_scene(lamp_obj, scene);
	};

	function update_sun_position(time) {

	    // var day   = _date.d;
	    // var month = _date.m;
	    // var year  = _date.y;

	    // TODO: Calculate real sun position depending on date

	    // Detect if current year is leap
	    //var leap_year = (year % 4 == 0) ? 0: 1;

	    // Number of days after January 1st
	    //var days_passed = day + 31 * (month - 1);

	    //if (month <= 2)
	    //    {}
	    //else if (month <= 4)
	    //    days_passed += leap_year - 3;
	    //else if (month <= 6)
	    //    days_passed += leap_year - 4;
	    //else if (month <= 9)
	    //    days_passed += leap_year - 5;
	    //else if (month <= 11)
	    //    days_passed += leap_year - 6;
	    //else
	    //    days_passed += leap_year - 7;

	    //var angle = get_sun_coordinates (_julian_date, (days_passed - 1));

	    var angle_hor  = time < 12 ? time * 15 : (time - 24) * 15;
	    var angle_vert = -Math.cos(time / 12 * Math.PI) * _max_sun_angle;

	    var sun_params = {};
	    sun_params.hor_position  = angle_hor;
	    sun_params.vert_position = angle_vert;

	    set_sun_params(sun_params);
	}



	}

	var lights_factory = register("lights", Lights);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * API methods to control the {@link https://www.blend4web.com/doc/en/logic_editor.html|Logic Editor}.
	 * @module logic_nodes
	 */
	function Logic_nodes(ns, exports) {

	var m_logn = int_logic_nodes_factory(ns);

	/**
	 * Register custom callback, used in logic editor.
	 * @method module:logic_nodes.append_custom_callback
	 * @param {string} cb_id Callback ID.
	 * @param {Function} cb Callback function.
	 * @example var m_log_nodes = require("logic_nodes");
	 * var cb = function() {
	 *     console.log("Blend4Web rules!");
	 * }
	 *
	 * m_log_nodes.append_custom_callback("cb_ID", cb);
	 */
	exports.append_custom_callback = function(cb_id, cb) {
	    m_logn.append_custom_cb(cb_id, cb);
	};

	/**
	 * Remove registered custom callback by its ID.
	 * @method module:logic_nodes.remove_custom_callback
	 * @param {string} cb_id Callback ID.
	 * @example var m_log_nodes = require("logic_nodes");
	 *
	 * m_log_nodes.remove_custom_callback("cb_ID");
	 */
	exports.remove_custom_callback = function(cb_id) {
	    m_logn.remove_custom_cb(cb_id);
	};

	/**
	 * Activate Entry Point node, used in logic editor.
	 * @method module:logic_nodes.run_entrypoint
	 * @param {string} scene_name Scene name.
	 * @param {string} ep_name Entry Point node name.
	 * @example var m_log_nodes = require("logic_nodes");
	 * m_log_nodes.run_entrypoint("Scene", "B4WLogicNode");
	 */
	exports.run_entrypoint = function(scene_name, ep_name) {
	    m_logn.run_ep(scene_name, ep_name);
	};

	}

	var logic_nodes_factory = register("logic_nodes", Logic_nodes);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Material API.
	 * Contains methods to control parameters of materials.
	 * @module material
	 * @local LineParams
	 * @local MaterialExtParams
	 * @local WaterMaterialParams
	 */
	function Material(ns, exports) {

	var m_batch    = int_batch_factory(ns);
	var m_cfg      = int_config_factory(ns);
	var m_geom     = int_geometry_factory(ns);
	var m_obj      = int_objects_factory(ns);
	var m_obj_util = int_obj_util_factory(ns);
	var m_print    = print_factory(ns);
	var m_shaders  = int_shaders_factory(ns);
	var m_util     = int_util_factory(ns);
	var m_scenes   = int_scenes_factory(ns);

	var cfg_def = m_cfg.defaults;

	/**
	 * Line params.
	 * @typedef {Object} LineParams
	 * @property {RGBA} [color] Line diffuse color
	 * @property {number} [width] Line width in pixels
	 * @cc_externs color width
	 */

	/**
	 * Additional group of parameters for a non-node material.
	 * @typedef {Object} MaterialExtParams
	 * @property {number} [fresnel] Power of Fresnel for mirror reflection.
	 * @property {number} [fresnel_factor] Blending factor for Fresnel.
	 * @property {number} [parallax_scale] Scale parameter for texture wrapping. 
	 * Available if the parallax effect is enabled on the material's normal map texture.
	 * @property {number} [parallax_steps] Number of steps taken to build a parallax surface.
	 * Available if the parallax effect is enabled on the material's normal map texture.
	 * @property {number} [reflect_factor] Amount of mirror reflection.
	 * @cc_externs fresnel fresnel_factor parallax_scale parallax_steps reflect_factor
	 */

	/**
	 * Parameters for a water material.
	 * @typedef {Object} WaterMaterialParams
	 * @property {boolean} [shore_smoothing] Perform the smoothing between the water 
	 * and the shore objects. Can be used only for Add, Alpha Blend and Alpha Sort 
	 * materials.
	 * @property {number} [absorb_factor] Water absorb factor. Used only if the 
	 * "shore_smoothing" parameter is true for this material.
	 * @property {number} [foam_factor] Water foam intensity factor. Can be used if 
	 * there is a foam texture in this material.
	 * @property {RGB} [shallow_water_col] Color of the shallow water.
	 * @property {RGB} [shore_water_col] Color of the shore water.
	 * @property {number} [shallow_water_col_fac] Shallow water color factor.
	 * @property {number} [shore_water_col_fac] Shore water color factor.
	 * @property {number} [norm_uv_velocity] Water normalmap UV velocity. Can be used 
	 * if there is a normalmap texture in this material.
	 * @property {boolean} [water_dynamic] Dynamic water surface. If disabled in the 
	 * blend-file, then this option cannot be enabled via API.
	 * @property {number} [sss_strength] Strength of subsurface scattering. Used if 
	 * the "water_dynamic" parameter is true.
	 * @property {number} [sss_width] Width of subsurface scattering. Used if the 
	 * "water_dynamic" parameter is true.
	 * @property {number} [waves_height] Waves height. Used if the "water_dynamic" 
	 * parameter is true.
	 * @property {number} [waves_length] Waves length. Used if the "water_dynamic" 
	 * parameter is true.
	 * @property {number} [dst_noise_scale0] Distant waves noise scale (first 
	 * component). Used if the "water_dynamic" parameter is true.
	 * @property {number} [dst_noise_scale1] Distant waves noise scale (second 
	 * component). Used if the "water_dynamic" parameter is true.
	 * @property {number} [dst_noise_freq0] Distant waves noise frequency (first 
	 * component). Used if the "water_dynamic" parameter is true.
	 * @property {number} [dst_noise_freq1] Distant waves noise frequency (second 
	 * component). Used if the "water_dynamic" parameter is true.
	 * @property {number} [dir_min_shore_fac] Minimum shore factor for directional 
	 * waves. Used if the "water_dynamic" parameter is true.
	 * @property {number} [dir_freq] Directional waves frequency. Used if the 
	 * "water_dynamic" parameter is true.
	 * @property {number} [dir_noise_scale] Directional waves noise scale. Used if the 
	 * "water_dynamic" parameter is true.
	 * @property {number} [dir_noise_freq] Directional waves noise frequency. Used if 
	 * the"water_dynamic" parameter is true.
	 * @property {number} [dir_min_noise_fac] Directional waves minimum noise factor. 
	 * Used if the "water_dynamic" parameter is true.
	 * @property {number} [dst_min_fac] Distant waves min factor. Used if the
	 * "water_dynamic" parameter is true.
	 * @property {number} [waves_hor_fac] Strength of horizontal waves inclination. 
	 * Used if the "water_dynamic" parameter is true.
	 * @cc_externs shore_smoothing absorb_factor foam_factor shallow_water_col 
	 * @cc_externs shore_water_col shallow_water_col_fac shore_water_col_fac 
	 * @cc_externs sss_strength sss_width norm_uv_velocity water_dynamic 
	 * @cc_externs waves_height waves_length dst_noise_scale0 dst_noise_scale1 
	 * @cc_externs dst_noise_freq0 dst_noise_freq1 dir_min_shore_fac dir_freq 
	 * @cc_externs dir_noise_scale dir_noise_freq dir_min_noise_fac dst_min_fac 
	 * @cc_externs waves_hor_fac 
	 */

	/**
	 * Inherit the batch material from another object.
	 * @method module:material.inherit_material
	 * @param {Object3D} obj_from Source Object 3D
	 * @param {string} mat_from_name Source material name
	 * @param {Object3D} obj_to Destination Object 3D
	 * @param {string} mat_to_name Destination material name
	 * @example 
	 * var m_mat = require("material");
	 * var m_scenes = require("scenes");
	 *
	 * var cube = m_scenes.get_object_by_name("Cube");
	 * var cube_001 = m_scenes.get_object_by_name("Cube.001");
	 * m_mat.inherit_material(cube, "MyMaterial_1", cube_001, "MyMaterial_2");
	 */
	exports.inherit_material = function(obj_from, mat_from_name, obj_to, mat_to_name) {
	    if (!m_geom.has_dyn_geom(obj_to) || !m_geom.has_dyn_geom(obj_from)) {
	        m_print.error("inherit_material(): both objects \"" 
	                + obj_from.origin_name + "\" and \"" + obj_to.origin_name 
	                + "\" must have the \"Dynamic Geometry & Materials\" flag enabled.");
	        return;
	    }

	    var bpy_mat_from_index = obj_from.mat_inheritance_data.original_mat_names.indexOf(mat_from_name);
	    if (bpy_mat_from_index == -1) {
	        m_print.error("inherit_material(): material \"" + mat_from_name 
	                + "\" not found on the object \"" + obj_from.origin_name + "\".");
	        return;   
	    }

	    var bpy_mat_to_index = obj_to.mat_inheritance_data.original_mat_names.indexOf(mat_to_name);
	    if (bpy_mat_to_index == -1) {
	        m_print.error("inherit_material(): material \"" + mat_to_name 
	                + "\" not found on the object \"" + obj_to.origin_name + "\".");
	        return;   
	    }

	    if (obj_to._bpy_obj["data"]["submeshes"][bpy_mat_to_index]["shade_tangs"].length == 0 
	            && obj_from.materials[bpy_mat_from_index].use_tangent_shading) {
	        m_print.warn("The target material \"" + mat_to_name + "\" was exported " 
	                + "without tangent shading data. However, the \"" + mat_from_name 
	                + "\" material requires it. It's needed to enable the \"Tangent Shading\" " 
	                + "option on the target material for correct rendering.");
	    }

	    m_obj.inherit_material(obj_from, mat_from_name, obj_to, mat_to_name);
	};

	/**
	 * Get materials' names for the given object.
	 * @method module:material.get_materials_names
	 * @param {Object3D} obj Object 3D
	 * @returns {string[]} Array of materials' names
	 * @example var m_scenes = require("scenes");
	 * var m_mat = require("material");
	 *
	 * var cube = m_scenes.get_object_by_name("Cube");
	 * var material_list = m_mat.get_materials_names(cube);
	 */
	exports.get_materials_names = function(obj) {

	    var mat_names = [];

	    if (!m_obj_util.is_dynamic_mesh(obj)) {
	        m_print.error("get_materials_names(): Object \"" + obj.name 
	                + "\" is not a dynamic MESH.");
	        return mat_names;
	    }

	    var scenes_data = obj.scenes_data;
	    for (var i = 0; i < scenes_data.length; i++) {
	        var batches = scenes_data[i].batches;
	        for (var j = 0; j < batches.length; j++) {
	            var batch = batches[j];
	            if (batch.type == "MAIN")
	                for (var k = 0; k < batch.material_names.length; k++)
	                    if (mat_names.indexOf(batch.material_names[k]) == -1)
	                        mat_names.push(batch.material_names[k]);
	        }
	    }

	    return mat_names;
	};

	/**
	 * Set the diffuse color and alpha for the object non-node material.
	 * @method module:material.set_diffuse_color
	 * @param {Object3D} obj Object 3D 
	 * @param {string} mat_name Material name
	 * @param {RGBA} color Color+alpha vector
	 * @example 
	 * var m_mat = require("material");
	 * var m_scenes = require("scenes");
	 * var m_rgba = require("rgba");
	 *
	 * var cube = m_scenes.get_object_by_name("Cube");
	 * m_mat.set_diffuse_color(cube, "MyMaterial", m_rgba.from_values(1.0, 0.0, 0.0, 1.0));
	 */
	exports.set_diffuse_color = function(obj, mat_name, color) {

	    if (!m_obj_util.is_dynamic_mesh(obj)) {
	        m_print.error("set_diffuse_color(): Object \"" + obj.name 
	                + "\" is not a dynamic MESH.");
	        return;
	    }

	    var batch = m_batch.find_batch_material(obj, mat_name, "MAIN");
	    if (!batch) {
	        m_print.error("set_diffuse_color(): Material \"" + mat_name 
	                + "\" wasn't found on the object \"" + obj.name + "\".");
	        return;
	    }

	    if (batch.has_nodes) {
	        m_print.error("set_diffuse_color(): Not allowed for node materials! " 
	                + "Use set_nodemat_value/set_nodemat_rgb methods instead.");
	        return;
	    }

	    batch.diffuse_color.set(color);
	    var reflect_batch = m_batch.find_batch_material_forked(obj, mat_name, "MAIN");
	    if (reflect_batch)
	        reflect_batch.diffuse_color.set(color);
	};

	/**
	 * Get the diffuse color and alpha for the object non-node material.
	 * @method module:material.get_diffuse_color
	 * @param {Object3D} obj Object 3D 
	 * @param {string} mat_name Material name
	 * @returns {RGBA} Material diffuse color+alpha
	 * @example var m_scenes = require("scenes");
	 * var m_mat = require("material");
	 *
	 * var cube = m_scenes.get_object_by_name("Cube");
	 * var diffuse_color = m_mat.get_diffuse_color(cube, "MyMaterial");
	 */
	exports.get_diffuse_color = function(obj, mat_name) {

	    var color = new Float32Array(4);

	    if (!m_obj_util.is_dynamic_mesh(obj)) {
	        m_print.error("get_diffuse_color(): Object \"" + obj.name 
	                + "\" is not a dynamic MESH.");
	        return color;
	    }

	    var batch = m_batch.find_batch_material(obj, mat_name, "MAIN");
	    if (!batch) {
	        m_print.error("get_diffuse_color(): Material \"" + mat_name 
	                + "\" wasn't found on the object \"" + obj.name + "\".");
	        return color;
	    }

	    if (batch.has_nodes) {
	        m_print.error("get_diffuse_color(): Not allowed for node materials! " 
	                + "Use get_nodemat_value/get_nodemat_rgb methods instead.");
	        return color;
	    }

	    color.set(batch.diffuse_color);
	    return color;
	};

	/**
	 * Set the diffuse color intensity for the object non-node material.
	 * @method module:material.set_diffuse_intensity
	 * @param {Object3D} obj Object 3D 
	 * @param {string} mat_name Material name
	 * @param {number} intensity Diffuse intensity value
	 * @example var m_scenes = require("scenes");
	 * var m_mat = require("material");
	 *
	 * var cube = m_scenes.get_object_by_name("Cube");
	 * m_mat.set_diffuse_intensity(cube, "MyMaterial", 0.5);
	 */
	exports.set_diffuse_intensity = function(obj, mat_name, intensity) {

	    if (!m_obj_util.is_dynamic_mesh(obj)) {
	        m_print.error("set_diffuse_intensity(): Object \"" + obj.name 
	                + "\" is not a dynamic MESH.");
	        return;
	    }

	    var batch = m_batch.find_batch_material(obj, mat_name, "MAIN");
	    if (!batch) {
	        m_print.error("set_diffuse_intensity(): Material \"" + mat_name 
	                + "\" wasn't found on the object \"" + obj.name + "\".");
	        return;
	    }

	    if (batch.has_nodes) {
	        m_print.error("set_diffuse_intensity(): Not allowed for node materials! " 
	                + "Use set_nodemat_value/set_nodemat_rgb methods instead.");
	        return;
	    }

	    batch.diffuse_intensity = intensity;
	    var reflect_batch = m_batch.find_batch_material_forked(obj, mat_name, "MAIN");
	    if (reflect_batch)
	        reflect_batch.diffuse_intensity = intensity;
	};

	/**
	 * Get the diffuse color intensity for the object non-node material.
	 * @method module:material.get_diffuse_intensity
	 * @param {Object3D} obj Object 3D 
	 * @param {string} mat_name Material name
	 * @returns {number} Diffuse intensity value
	 * @example var m_scenes = require("scenes");
	 * var m_mat = require("material");
	 *
	 * var cube = m_scenes.get_object_by_name("Cube");
	 * var diffuse_intensity = m_mat.get_diffuse_intensity(cube, "MyMaterial");
	 */
	exports.get_diffuse_intensity = function(obj, mat_name) {

	    if (!m_obj_util.is_dynamic_mesh(obj)) {
	        m_print.error("get_diffuse_intensity(): Object \"" + obj.name 
	                + "\" is not a dynamic MESH.");
	        return 0;
	    }

	    var batch = m_batch.find_batch_material(obj, mat_name, "MAIN");
	    if (!batch) {
	        m_print.error("get_diffuse_intensity(): Material \"" + mat_name 
	                + "\" wasn't found on the object \"" + obj.name + "\".");
	        return 0;
	    }

	    if (batch.has_nodes) {
	        m_print.error("get_diffuse_intensity(): Not allowed for node materials! " 
	                + "Use get_nodemat_value/get_nodemat_rgb methods instead.");
	        return 0;
	    }

	    return batch.diffuse_intensity;
	};

	/**
	 * Set the specular color for the object non-node material.
	 * @method module:material.set_specular_color
	 * @param {Object3D} obj Object 3D 
	 * @param {string} mat_name Material name
	 * @param {RGB} color Color vector
	 * @example 
	 * var m_mat = require("material");
	 * var m_scenes = require("scenes");
	 *
	 * var cube = m_scenes.get_object_by_name("Cube");
	 * m_mat.set_specular_color(cube, "MyMaterial", [0, 0.8, 0]);
	 */
	exports.set_specular_color = function(obj, mat_name, color) {

	    if (!m_obj_util.is_dynamic_mesh(obj)) {
	        m_print.error("set_specular_color(): Object \"" + obj.name 
	                + "\" is not a dynamic MESH.");
	        return;
	    }

	    var batch = m_batch.find_batch_material(obj, mat_name, "MAIN");
	    if (!batch) {
	        m_print.error("set_specular_color(): Material \"" + mat_name 
	                + "\" wasn't found on the object \"" + obj.name + "\".");
	        return;
	    }

	    if (batch.has_nodes) {
	        m_print.error("set_specular_color(): Not allowed for node materials! " 
	                + "Use set_nodemat_value/set_nodemat_rgb methods instead.");
	        return;
	    }

	    batch.specular_color.set(color);
	    var reflect_batch = m_batch.find_batch_material_forked(obj, mat_name, "MAIN");
	    if (reflect_batch)
	        reflect_batch.specular_color.set(color);
	};

	/**
	 * Get the specular color for the object non-node material.
	 * @method module:material.get_specular_color
	 * @param {Object3D} obj Object 3D 
	 * @param {string} mat_name Material name
	 * @returns {RGB} Specular color
	 * @example var m_scenes = require("scenes");
	 * var m_mat = require("material");
	 *
	 * var cube = m_scenes.get_object_by_name("Cube");
	 * var specular_color = m_mat.get_specular_color(cube, "MyMaterial");
	 */
	exports.get_specular_color = function(obj, mat_name) {

	    var color = new Float32Array(3);

	    if (!m_obj_util.is_dynamic_mesh(obj)) {
	        m_print.error("get_specular_color(): Object \"" + obj.name 
	                + "\" is not a dynamic MESH.");
	        return color;
	    }

	    var batch = m_batch.find_batch_material(obj, mat_name, "MAIN");
	    if (!batch) {
	        m_print.error("get_specular_color(): Material \"" + mat_name 
	                + "\" wasn't found on the object \"" + obj.name + "\".");
	        return color;
	    }

	    if (batch.has_nodes) {
	        m_print.error("get_specular_color(): Not allowed for node materials! " 
	                + "Use get_nodemat_value/get_nodemat_rgb methods instead.");
	        return color;
	    }

	    color.set(batch.specular_color);
	    return color;
	};

	/**
	 * Set the specular color factor for the object non-node material.
	 * @method module:material.set_specular_color_factor
	 * @param {Object3D} obj Object 3D 
	 * @param {string} mat_name Material name
	 * @param {number} factor Specular color factor
	 * @example var m_scenes = require("scenes");
	 * var m_mat = require("material");
	 *
	 * var cube = m_scenes.get_object_by_name("Cube");
	 * m_mat.set_specular_color_factor(cube, "MyMaterial", 0.8);
	 */
	exports.set_specular_color_factor = function(obj, mat_name, factor) {

	    if (!m_obj_util.is_dynamic_mesh(obj)) {
	        m_print.error("set_specular_color_factor(): Object \"" + obj.name 
	                + "\" is not a dynamic MESH.");
	        return;
	    }

	    var batch = m_batch.find_batch_material(obj, mat_name, "MAIN");
	    if (!batch) {
	        m_print.error("set_specular_color_factor(): Material \"" + mat_name 
	                + "\" wasn't found on the object \"" + obj.name + "\".");
	        return;
	    }

	    if (batch.has_nodes) {
	        m_print.error("set_specular_color_factor(): Not allowed for node materials! " 
	                + "Use set_nodemat_value/set_nodemat_rgb methods instead.");
	        return;
	    }

	    batch.specular_color_factor = factor;
	    var reflect_batch = m_batch.find_batch_material_forked(obj, mat_name, "MAIN");
	    if (reflect_batch)
	        reflect_batch.specular_color_factor = factor;
	};

	/**
	 * Get the specular color factor for the object non-node material.
	 * @method module:material.get_specular_color_factor
	 * @param {Object3D} obj Object 3D 
	 * @param {string} mat_name Material name
	 * @returns {number} Specular color factor
	 * @example var m_scenes = require("scenes");
	 * var m_mat = require("material");
	 *
	 * var cube = m_scenes.get_object_by_name("Cube");
	 * var specular_color_factor = m_mat.get_specular_color_factor(cube, "MyMaterial");
	 */
	exports.get_specular_color_factor = function(obj, mat_name) {

	    if (!m_obj_util.is_dynamic_mesh(obj)) {
	        m_print.error("get_specular_color_factor(): Object \"" + obj.name 
	                + "\" is not a dynamic MESH.");
	        return 0;
	    }

	    var batch = m_batch.find_batch_material(obj, mat_name, "MAIN");
	    if (!batch) {
	        m_print.error("get_specular_color_factor(): Material \"" + mat_name 
	                + "\" wasn't found on the object \"" + obj.name + "\".");
	        return 0;
	    }

	    if (batch.has_nodes) {
	        m_print.error("get_specular_color_factor(): Not allowed for node materials! " 
	                + "Use get_nodemat_value/get_nodemat_rgb methods instead.");
	        return 0;
	    }

	    return batch.specular_color_factor;
	};

	/**
	 * Set the specular color intensity for the object non-node material.
	 * @method module:material.set_specular_intensity
	 * @param {Object3D} obj Object 3D 
	 * @param {string} mat_name Material name
	 * @param {number} intensity Specular intensity value
	 * @example 
	 * var m_mat = require("material");
	 * var m_scenes = require("scenes");
	 *
	 * var cube = m_scenes.get_object_by_name("Cube");
	 * m_mat.set_specular_intensity(cube, "MyMaterial", 0.7);
	 */
	exports.set_specular_intensity = function(obj, mat_name, intensity) {

	    if (!m_obj_util.is_dynamic_mesh(obj)) {
	        m_print.error("set_specular_intensity(): Object \"" + obj.name 
	                + "\" is not a dynamic MESH.");
	        return;
	    }

	    var batch = m_batch.find_batch_material(obj, mat_name, "MAIN");
	    if (!batch) {
	        m_print.error("set_specular_intensity(): Material \"" + mat_name 
	                + "\" wasn't found on the object \"" + obj.name + "\".");
	        return;
	    }

	    if (batch.has_nodes) {
	        m_print.error("set_specular_intensity(): Not allowed for node materials! " 
	                + "Use set_nodemat_value/set_nodemat_rgb methods instead.");
	        return;
	    }

	    batch.specular_params[0] = intensity;
	    var reflect_batch = m_batch.find_batch_material_forked(obj, mat_name, "MAIN");
	    if (reflect_batch)
	        reflect_batch.specular_params[0] = intensity;
	};

	/**
	 * Get the specular color intensity for the object non-node material.
	 * @method module:material.get_specular_intensity
	 * @param {Object3D} obj Object 3D 
	 * @param {string} mat_name Material name
	 * @returns {number} Specular color intensity
	 * @example var m_scenes = require("scenes");
	 * var m_mat = require("material");
	 *
	 * var cube = m_scenes.get_object_by_name("Cube");
	 * var specular_intensity = m_mat.get_specular_intensity(cube, "MyMaterial");
	 */
	exports.get_specular_intensity = function(obj, mat_name) {

	    if (!m_obj_util.is_dynamic_mesh(obj)) {
	        m_print.error("get_specular_intensity(): Object \"" + obj.name 
	                + "\" is not a dynamic MESH.");
	        return 0;
	    }

	    var batch = m_batch.find_batch_material(obj, mat_name, "MAIN");
	    if (!batch) {
	        m_print.error("get_specular_intensity(): Material \"" + mat_name 
	                + "\" wasn't found on the object \"" + obj.name + "\".");
	        return 0;
	    }

	    if (batch.has_nodes) {
	        m_print.error("get_specular_intensity(): Not allowed for node materials! " 
	                + "Use get_nodemat_value/get_nodemat_rgb methods instead.");
	        return 0;
	    }

	    return batch.specular_params[0];
	};

	/**
	 * Check the specular intensity for the object material.
	 * @method module:material.check_specular_intensity
	 * @param {Object3D} obj Object 3D 
	 * @param {string} mat_name Material name
	 * @returns {boolean} Specular intensity presence
	 * @deprecated [17.06] not needed anymore.
	 * @example var m_scenes = require("scenes");
	 * var m_mat = require("material");
	 *
	 * var cube = m_scenes.get_object_by_name("Cube");
	 * var has_specular_intensity = m_mat.check_specular_intensity(cube, "MyMaterial");
	 */
	exports.check_specular_intensity = function(obj, mat_name) {
	    m_print.error_once("check_specular_intensity() is deprecated, not needed anymore");

	    var batch = m_batch.find_batch_material(obj, mat_name, "MAIN");
	    return Boolean(batch && batch.specular_params[0]);
	};

	/**
	 * Set the specular color hardness for the object non-node material.
	 * @method module:material.set_specular_hardness
	 * @param {Object3D} obj Object 3D 
	 * @param {string} mat_name Material name
	 * @param {number} hardness Specular hardness value
	 * @example 
	 * var m_mat = require("material");
	 * var m_scenes = require("scenes");
	 *
	 * var cube = m_scenes.get_object_by_name("Cube");
	 * m_mat.set_specular_hardness(cube, "MyMaterial", 0.8);
	 */
	exports.set_specular_hardness = function(obj, mat_name, hardness) {

	    if (!m_obj_util.is_dynamic_mesh(obj)) {
	        m_print.error("set_specular_hardness(): Object \"" + obj.name 
	                + "\" is not a dynamic MESH.");
	        return;
	    }

	    var batch = m_batch.find_batch_material(obj, mat_name, "MAIN");
	    if (!batch) {
	        m_print.error("set_specular_hardness(): Material \"" + mat_name 
	                + "\" wasn't found on the object \"" + obj.name + "\".");
	        return;
	    }

	    if (batch.has_nodes) {
	        m_print.error("set_specular_hardness(): Not allowed for node materials! " 
	                + "Use set_nodemat_value/set_nodemat_rgb methods instead.");
	        return;
	    }

	    batch.specular_params[1] = hardness;
	    var reflect_batch = m_batch.find_batch_material_forked(obj, mat_name, "MAIN");
	    if (reflect_batch)
	        reflect_batch.specular_params[1] = hardness;
	};

	/**
	 * Get the specular color hardness for the object non-node material.
	 * @method module:material.get_specular_hardness
	 * @param {Object3D} obj Object 3D 
	 * @param {string} mat_name Material name
	 * @returns {number} Specular color hardness
	 * @example var m_scenes = require("scenes");
	 * var m_mat = require("material");
	 *
	 * var cube = m_scenes.get_object_by_name("Cube");
	 * var specular_hardness = m_mat.get_specular_hardness(cube, "MyMaterial");
	 */
	exports.get_specular_hardness = function(obj, mat_name) {

	    if (!m_obj_util.is_dynamic_mesh(obj)) {
	        m_print.error("get_specular_hardness(): Object \"" + obj.name 
	                + "\" is not a dynamic MESH.");
	        return 0;
	    }

	    var batch = m_batch.find_batch_material(obj, mat_name, "MAIN");
	    if (!batch) {
	        m_print.error("get_specular_hardness(): Material \"" + mat_name 
	                + "\" wasn't found on the object \"" + obj.name + "\".");
	        return 0;
	    }

	    if (batch.has_nodes) {
	        m_print.error("get_specular_hardness(): Not allowed for node materials! " 
	                + "Use get_nodemat_value/get_nodemat_rgb methods instead.");
	        return 0;
	    }

	    return batch.specular_params[1];
	};

	/**
	 * Check the specular hardness for the object material.
	 * @method module:material.check_specular_hardness
	 * @param {Object3D} obj Object 3D 
	 * @param {string} mat_name Material name
	 * @returns {boolean} Specular hardness presence
	 * @deprecated [17.06] not needed anymore.
	 * @example var m_scenes = require("scenes");
	 * var m_mat = require("material");
	 *
	 * var cube = m_scenes.get_object_by_name("Cube");
	 * var has_specular_hardness = m_mat.check_specular_hardness(cube, "MyMaterial");
	 */
	exports.check_specular_hardness = function(obj, mat_name) {
	    m_print.error_once("check_specular_hardness() is deprecated, not needed anymore");
	    
	    var batch = m_batch.find_batch_material(obj, mat_name, "MAIN");
	    return Boolean(batch && batch.specular_params[1]);
	};

	/**
	 * Set the emit factor for the object non-node material.
	 * @method module:material.set_emit_factor
	 * @param {Object3D} obj Object 3D 
	 * @param {string} mat_name Material name
	 * @param {number} emit_factor Emit factor value
	 * @example 
	 * var m_mat = require("material");
	 * var m_scenes = require("scenes");
	 *
	 * var cube = m_scenes.get_object_by_name("Cube");
	 * m_mat.set_emit_factor(cube, "MyMaterial", 1);
	 */
	exports.set_emit_factor = function(obj, mat_name, emit_factor) {

	    if (!m_obj_util.is_dynamic_mesh(obj)) {
	        m_print.error("set_emit_factor(): Object \"" + obj.name 
	                + "\" is not a dynamic MESH.");
	        return;
	    }

	    var batch = m_batch.find_batch_material(obj, mat_name, "MAIN");
	    if (!batch) {
	        m_print.error("set_emit_factor(): Material \"" + mat_name 
	                + "\" wasn't found on the object \"" + obj.name + "\".");
	        return;
	    }

	    if (batch.has_nodes) {
	        m_print.error("set_emit_factor(): Not allowed for node materials! " 
	                + "Use set_nodemat_value/set_nodemat_rgb methods instead.");
	        return;
	    }

	    batch.emit = emit_factor;
	    var reflect_batch = m_batch.find_batch_material_forked(obj, mat_name, "MAIN");
	    if (reflect_batch)
	        reflect_batch.emit = emit_factor;
	};

	/**
	 * Get the emit factor for the object non-node material.
	 * @method module:material.get_emit_factor
	 * @param {Object3D} obj Object 3D 
	 * @param {string} mat_name Material name
	 * @returns {number} Emit factor value
	 * @example var m_scenes = require("scenes");
	 * var m_mat = require("material");
	 *
	 * var cube = m_scenes.get_object_by_name("Cube");
	 * var emit_factor = m_mat.get_emit_factor(cube, "MyMaterial");
	 */
	exports.get_emit_factor = function(obj, mat_name) {

	    if (!m_obj_util.is_dynamic_mesh(obj)) {
	        m_print.error("get_emit_factor(): Object \"" + obj.name 
	                + "\" is not a dynamic MESH.");
	        return 0;
	    }

	    var batch = m_batch.find_batch_material(obj, mat_name, "MAIN");
	    if (!batch) {
	        m_print.error("get_emit_factor(): Material \"" + mat_name 
	                + "\" wasn't found on the object \"" + obj.name + "\".");
	        return 0;
	    }

	    if (batch.has_nodes) {
	        m_print.error("get_emit_factor(): Not allowed for node materials! " 
	                + "Use get_nodemat_value/get_nodemat_rgb methods instead.");
	        return 0;
	    }

	    return batch.emit;
	};

	/**
	 * Set the ambient factor for the object non-node material.
	 * @method module:material.set_ambient_factor
	 * @param {Object3D} obj Object 3D 
	 * @param {string} mat_name Material name
	 * @param {number} ambient_factor Ambient factor value
	 * @example var m_scenes = require("scenes");
	 * var m_mat = require("material");
	 *
	 * var cube = m_scenes.get_object_by_name("Cube");
	 * m_mat.set_ambient_factor(cube, "MyMaterial", 0.6);
	 */
	exports.set_ambient_factor = function(obj, mat_name, ambient_factor) {

	    if (!m_obj_util.is_dynamic_mesh(obj)) {
	        m_print.error("set_ambient_factor(): Object \"" + obj.name 
	                + "\" is not a dynamic MESH.");
	        return;
	    }

	    var batch = m_batch.find_batch_material(obj, mat_name, "MAIN");
	    if (!batch) {
	        m_print.error("set_ambient_factor(): Material \"" + mat_name 
	                + "\" wasn't found on the object \"" + obj.name + "\".");
	        return;
	    }

	    if (batch.has_nodes) {
	        m_print.error("set_ambient_factor(): Not allowed for node materials! " 
	                + "Use set_nodemat_value/set_nodemat_rgb methods instead.");
	        return;
	    }

	    batch.ambient = ambient_factor;
	    var reflect_batch = m_batch.find_batch_material_forked(obj, mat_name, "MAIN");
	    if (reflect_batch)
	        reflect_batch.ambient = ambient_factor;
	};

	/**
	 * Get the ambient factor for the object non-node material.
	 * @method module:material.get_ambient_factor
	 * @param {Object3D} obj Object 3D 
	 * @param {string} mat_name Material name
	 * @returns {number} Ambient factor value
	 * @example var m_scenes = require("scenes");
	 * var m_mat = require("material");
	 *
	 * var cube = m_scenes.get_object_by_name("Cube");
	 * var ambient_factor = m_mat.get_ambient_factor(cube, "MyMaterial");
	 */
	exports.get_ambient_factor = function(obj, mat_name) {

	    if (!m_obj_util.is_dynamic_mesh(obj)) {
	        m_print.error("get_ambient_factor(): Object \"" + obj.name 
	                + "\" is not a dynamic MESH.");
	        return 0;
	    }

	    var batch = m_batch.find_batch_material(obj, mat_name, "MAIN");
	    if (!batch) {
	        m_print.error("get_ambient_factor(): Material \"" + mat_name 
	                + "\" wasn't found on the object \"" + obj.name + "\".");
	        return 0;
	    }

	    if (batch.has_nodes) {
	        m_print.error("get_ambient_factor(): Not allowed for node materials! " 
	                + "Use get_nodemat_value/get_nodemat_rgb methods instead.");
	        return 0;
	    }

	    return batch.ambient;
	};

	/**
	 * Set the diffuse color factor for the object non-node material.
	 * @method module:material.set_diffuse_color_factor
	 * @param {Object3D} obj Object 3D 
	 * @param {string} mat_name Material name
	 * @param {number} diffuse_color_factor Diffuse color factor value
	 * @example var m_scenes = require("scenes");
	 * var m_mat = require("material");
	 *
	 * var cube = m_scenes.get_object_by_name("Cube");
	 * m_mat.set_diffuse_color_factor(cube, "MyMaterial", 0.05);
	 */
	exports.set_diffuse_color_factor = function(obj, mat_name, diffuse_color_factor) {

	    if (!m_obj_util.is_dynamic_mesh(obj)) {
	        m_print.error("set_diffuse_color_factor(): Object \"" + obj.name 
	                + "\" is not a dynamic MESH.");
	        return;
	    }

	    var batch = m_batch.find_batch_material(obj, mat_name, "MAIN");
	    if (!batch) {
	        m_print.error("set_diffuse_color_factor(): Material \"" + mat_name 
	                + "\" wasn't found on the object \"" + obj.name + "\".");
	        return;
	    }

	    if (batch.has_nodes) {
	        m_print.error("set_diffuse_color_factor(): Not allowed for node materials! " 
	                + "Use set_nodemat_value/set_nodemat_rgb methods instead.");
	        return;
	    }

	    batch.diffuse_color_factor = diffuse_color_factor;
	    var reflect_batch = m_batch.find_batch_material_forked(obj, mat_name, "MAIN");
	    if (reflect_batch)
	        reflect_batch.diffuse_color_factor = diffuse_color_factor;
	};

	/**
	 * Get the diffuse color factor for the object non-node material.
	 * @method module:material.get_diffuse_color_factor
	 * @param {Object3D} obj Object 3D 
	 * @param {string} mat_name Material name
	 * @returns {number} Diffuse color factor value
	 * @example var m_scenes = require("scenes");
	 * var m_mat = require("material");
	 *
	 * var cube = m_scenes.get_object_by_name("Cube");
	 * var diffuse_color_factor = m_mat.get_diffuse_color_factor(cube, "MyMaterial");
	 */
	exports.get_diffuse_color_factor = function(obj, mat_name) {

	    if (!m_obj_util.is_dynamic_mesh(obj)) {
	        m_print.error("get_diffuse_color_factor(): Object \"" + obj.name 
	                + "\" is not a dynamic MESH.");
	        return 0;
	    }

	    var batch = m_batch.find_batch_material(obj, mat_name, "MAIN");
	    if (!batch) {
	        m_print.error("get_diffuse_color_factor(): Material \"" + mat_name 
	                + "\" wasn't found on the object \"" + obj.name + "\".");
	        return 0;
	    }

	    if (batch.has_nodes) {
	        m_print.error("get_diffuse_color_factor(): Not allowed for node materials! " 
	                + "Use get_nodemat_value/get_nodemat_rgb methods instead.");
	        return 0;
	    }

	    return batch.diffuse_color_factor;
	};

	/**
	 * Set the alpha factor for the object non-node material.
	 * @method module:material.set_alpha_factor
	 * @param {Object3D} obj Object 3D
	 * @param {string} mat_name Material name
	 * @param {number} alpha_factor Alpha factor value
	 * @example 
	 * var m_mat = require("material");
	 * var m_scenes = require("scenes");
	 *
	 * var cube = m_scenes.get_object_by_name("Cube");
	 * m_mat.set_alpha_factor(cube, "MyMaterial", 0.2);
	 */
	exports.set_alpha_factor = function(obj, mat_name, alpha_factor) {

	    if (!m_obj_util.is_dynamic_mesh(obj)) {
	        m_print.error("set_alpha_factor(): Object \"" + obj.name 
	                + "\" is not a dynamic MESH.");
	        return;
	    }

	    var batch = m_batch.find_batch_material(obj, mat_name, "MAIN");
	    if (!batch) {
	        m_print.error("set_alpha_factor(): Material \"" + mat_name 
	                + "\" wasn't found on the object \"" + obj.name + "\".");
	        return;
	    }

	    if (batch.has_nodes) {
	        m_print.error("set_alpha_factor(): Not allowed for node materials! " 
	                + "Use set_nodemat_value/set_nodemat_rgb methods instead.");
	        return;
	    }

	    batch.alpha_factor = alpha_factor;
	    var reflect_batch = m_batch.find_batch_material_forked(obj, mat_name, "MAIN");
	    if (reflect_batch)
	        reflect_batch.alpha_factor = alpha_factor;
	};

	/**
	 * Get the diffuse alpha factor for the object non-node material.
	 * @method module:material.get_alpha_factor
	 * @param {Object3D} obj Object 3D
	 * @param {string} mat_name Material name
	 * @returns {number} Diffuse alpha factor value
	 * @example var m_scenes = require("scenes");
	 * var m_mat = require("material");
	 *
	 * var cube = m_scenes.get_object_by_name("Cube");
	 * var alpha_factor = m_mat.get_alpha_factor(cube, "MyMaterial");
	 */
	exports.get_alpha_factor = function(obj, mat_name) {

	    if (!m_obj_util.is_dynamic_mesh(obj)) {
	        m_print.error("get_alpha_factor(): Object \"" + obj.name 
	                + "\" is not a dynamic MESH.");
	        return 0;
	    }

	    var batch = m_batch.find_batch_material(obj, mat_name, "MAIN");
	    if (!batch) {
	        m_print.error("get_alpha_factor(): Material \"" + mat_name 
	                + "\" wasn't found on the object \"" + obj.name + "\".");
	        return 0;
	    }

	    if (batch.has_nodes) {
	        m_print.error("get_alpha_factor(): Not allowed for node materials! " 
	                + "Use get_nodemat_value/get_nodemat_rgb methods instead.");
	        return 0;
	    }

	    return batch.alpha_factor;
	};

	/**
	 * Get the material extended params for the object non-node material.
	 * @method module:material.get_material_extended_params
	 * @param {Object3D} obj Object 3D
	 * @param {string} mat_name Material name
	 * @returns {?MaterialExtParams} Material extended params or null
	 * @example var m_scenes = require("scenes");
	 * var m_mat = require("material");
	 *
	 * var cube = m_scenes.get_object_by_name("Cube");
	 * var extended_parameters = m_mat.get_material_extended_params(cube, "MyMaterial");
	 */
	exports.get_material_extended_params = function(obj, mat_name) {

	    if (!m_obj_util.is_dynamic_mesh(obj)) {
	        m_print.error("get_material_extended_params(): Object \"" + obj.name 
	                + "\" is not a dynamic MESH.");
	        return null;
	    }

	    var batch = m_batch.find_batch_material(obj, mat_name, "MAIN");
	    if (!batch) {
	        m_print.error("get_material_extended_params(): Material \"" + mat_name 
	                + "\" wasn't found on the object \"" + obj.name + "\".");
	        return null;
	    }

	    if (batch.has_nodes) {
	        m_print.error("get_material_extended_params(): Not allowed for node materials! " 
	                + "Use get_nodemat_value/get_nodemat_rgb methods instead.");
	        return null;
	    }

	    var mat_params = {};

	    mat_params.reflect_factor = batch.reflect_factor;
	    mat_params.fresnel        = batch.fresnel_params[0];
	    mat_params.fresnel_factor = 5 * (1 - batch.fresnel_params[1]);
	    mat_params.parallax_scale = batch.parallax_scale;
	    mat_params.parallax_steps = parseFloat(m_batch.get_batch_directive(batch,
	            "PARALLAX_STEPS")[1]);

	    return mat_params;
	};

	/**
	 * Set the material extended params for the object non-node material.
	 * @method module:material.set_material_extended_params
	 * @param {Object3D} obj Object 3D
	 * @param {string} mat_name Material name
	 * @param {MaterialExtParams} mat_params Material params
	 * @example var m_scenes = require("scenes");
	 * var m_mat = require("material");
	 *
	 * var cube = m_scenes.get_object_by_name("Cube");
	 * m_mat.set_material_extended_params(cube, "MyMaterial", {
	 *     fresnel: 0,
	 *     fresnel_factor: 1.25,
	 *     parallax_scale: 0,
	 *     parallax_steps: 5,
	 *     reflect_factor: 0
	 * });
	 */
	exports.set_material_extended_params = function(obj, mat_name, mat_params) {

	    if (!m_obj_util.is_dynamic_mesh(obj)) {
	        m_print.error("set_material_extended_params(): Object \"" + obj.name 
	                + "\" is not a dynamic MESH.");
	        return;
	    }

	    var batch = m_batch.find_batch_material(obj, mat_name, "MAIN");
	    if (!batch) {
	        m_print.error("set_material_extended_params(): Material \"" + mat_name 
	                + "\" wasn't found on the object \"" + obj.name + "\".");
	        return;
	    }

	    if (batch.has_nodes) {
	        m_print.error("set_material_extended_params(): Not allowed for node materials! " 
	                + "Use set_nodemat_value/set_nodemat_rgb methods instead.");
	        return;
	    }

	    var batches = [batch];
	    var reflect_batch = m_batch.find_batch_material_forked(obj, mat_name, "MAIN");
	    if (reflect_batch)
	        batches.push(reflect_batch);

	    for (var i = 0; i < batches.length; i++) {
	        batch = batches[i];
	        if (typeof mat_params.reflect_factor == "number")
	            batch.reflect_factor = mat_params.reflect_factor;

	        if (typeof mat_params.fresnel == "number")
	            batch.fresnel_params[0] = mat_params.fresnel;

	        if (typeof mat_params.fresnel_factor == "number")
	            batch.fresnel_params[1] = 1 - mat_params.fresnel_factor / 5;

	        if (typeof mat_params.parallax_scale == "number")
	            batch.parallax_scale = mat_params.parallax_scale;

	        if (typeof mat_params.parallax_steps == "number") {
	            m_batch.set_batch_directive(batch, "PARALLAX_STEPS", 
	                    m_shaders.glsl_value(mat_params.parallax_steps));
	            m_batch.update_shader(batch);
	            m_scenes.recalculate_draw_data(batch);
	        }
	    }
	};

	/**
	 * Get the parameters of a water non-node material.
	 * @method module:material.get_water_material_params
	 * @param {Object3D} obj Object 3D
	 * @param {string} mat_name Water material name
	 * @returns {?WaterMaterialParams} Water material params or null.
	 * @example var m_scenes = require("scenes");
	 * var m_mat = require("material");
	 *
	 * var water = m_scenes.get_object_by_name("MyWater");
	 * var water_params = m_mat.get_water_material_params(water, "MyMaterial");
	 */
	exports.get_water_material_params = function(obj, mat_name) {

	    if (!m_obj_util.is_dynamic_mesh(obj)) {
	        m_print.error("get_water_material_params(): Object \"" + obj.name 
	                + "\" is not a dynamic MESH.");
	        return null;
	    }

	    var batch = m_batch.find_batch_material(obj, mat_name, "MAIN");
	    if (!batch || !batch.water) {
	        m_print.error("get_water_material_params(): Material \"" + mat_name 
	                + "\" wasn't found on the object \"" + obj.name 
	                + "\" or it's not a water material.");
	        return null;
	    }

	    if (batch.has_nodes) {
	        m_print.error("get_water_material_params(): Not allowed for node materials! " 
	                + "Use get_nodemat_value/get_nodemat_rgb methods instead.");
	        return null;
	    }


	    var water_mat_params = {};

	    water_mat_params.shore_smoothing = cfg_def.shore_smoothing 
	            && batch.water_shore_smoothing && Boolean(parseFloat(
	            m_batch.get_batch_directive(batch, "SHORE_SMOOTHING")[1]));

	    water_mat_params.absorb_factor = parseFloat(m_batch.get_batch_directive(
	            batch, "ABSORB")[1]);
	    water_mat_params.foam_factor = batch.foam_factor;

	    water_mat_params.shallow_water_col = new Float32Array(3);
	    water_mat_params.shore_water_col = new Float32Array(3);
	    water_mat_params.shallow_water_col_fac = 0;
	    water_mat_params.shore_water_col_fac = 0;

	    if (cfg_def.shore_distance) {
	        water_mat_params.shallow_water_col.set(batch.shallow_water_col);
	        water_mat_params.shore_water_col.set(batch.shore_water_col);
	        water_mat_params.shallow_water_col_fac = batch.shallow_water_col_fac;
	        water_mat_params.shore_water_col_fac = batch.shore_water_col_fac;
	    }

	    water_mat_params.norm_uv_velocity = batch.water_norm_uv_velocity;

	    water_mat_params.water_dynamic = cfg_def.water_dynamic 
	            && batch.water_dynamic && Boolean(parseFloat(
	            m_batch.get_batch_directive(batch, "DYNAMIC")[1]));
	    water_mat_params.sss_strength = parseFloat(m_batch.get_batch_directive(
	            batch, "SSS_STRENGTH")[1]);
	    water_mat_params.sss_width = parseFloat(m_batch.get_batch_directive(
	            batch, "SSS_WIDTH")[1]);
	    water_mat_params.waves_height = parseFloat(m_batch.get_batch_directive(
	            batch, "WAVES_HEIGHT")[1]);
	    water_mat_params.waves_length = parseFloat(m_batch.get_batch_directive(
	            batch, "WAVES_LENGTH")[1]);

	    water_mat_params.dst_noise_scale0 = parseFloat(m_batch.get_batch_directive(
	            batch, "DST_NOISE_SCALE_0")[1]);
	    water_mat_params.dst_noise_scale1 = parseFloat(m_batch.get_batch_directive(
	            batch, "DST_NOISE_SCALE_1")[1]);
	    water_mat_params.dst_noise_freq0 = parseFloat(m_batch.get_batch_directive(
	            batch, "DST_NOISE_FREQ_0")[1]);
	    water_mat_params.dst_noise_freq1 = parseFloat(m_batch.get_batch_directive(
	            batch, "DST_NOISE_FREQ_1")[1]);
	    water_mat_params.dir_min_shore_fac = parseFloat(m_batch.get_batch_directive(
	            batch, "DIR_MIN_SHR_FAC")[1]);
	    water_mat_params.dir_freq = parseFloat(m_batch.get_batch_directive(batch,
	            "DIR_FREQ")[1]);
	    water_mat_params.dir_noise_scale = parseFloat(m_batch.get_batch_directive(
	            batch, "DIR_NOISE_SCALE")[1]);
	    water_mat_params.dir_noise_freq = parseFloat(m_batch.get_batch_directive(
	            batch, "DIR_NOISE_FREQ")[1]);

	    water_mat_params.dir_min_noise_fac = parseFloat(m_batch.get_batch_directive(
	            batch, "DIR_MIN_NOISE_FAC")[1]);
	    water_mat_params.dst_min_fac = parseFloat(m_batch.get_batch_directive(batch,
	            "DST_MIN_FAC")[1]);
	    water_mat_params.waves_hor_fac = parseFloat(m_batch.get_batch_directive(
	            batch, "WAVES_HOR_FAC")[1]);

	    return water_mat_params;
	};

	/**
	 * Set parameters for a water non-node material.
	 * @method module:material.set_water_material_params
	 * @param {Object3D} obj Object 3D
	 * @param {string} mat_name Water material name
	 * @param {WaterMaterialParams} water_mat_params Water material parameters.
	 * @example var m_scenes = require("scenes");
	 * var m_mat = require("material");
	 *
	 * var water = m_scenes.get_object_by_name("MyWater");
	 * var water_params = m_mat.set_water_material_params(water, "MyMaterial", {
	 *     waves_height: 2, 
	 *     waves_length: 20, 
	 *     shallow_water_col: [0, 0.3, 0.8]
	 * });
	 */
	exports.set_water_material_params = function(obj, mat_name, water_mat_params) {

	    if (!m_obj_util.is_dynamic_mesh(obj)) {
	        m_print.error("set_water_material_params(): Object \"" + obj.name 
	                + "\" is not a dynamic MESH.");
	        return;
	    }

	    var batch = m_batch.find_batch_material(obj, mat_name, "MAIN");
	    if (!batch || !batch.water) {
	        m_print.error("set_water_material_params(): Material \"" + mat_name 
	                + "\" wasn't found on the object \"" + obj.name 
	                + "\" or it's not a water material.");
	        return;
	    }

	    if (batch.has_nodes) {
	        m_print.error("set_water_material_params(): Not allowed for node materials! " 
	                + "Use set_nodemat_value/set_nodemat_rgb methods instead.");
	        return;
	    }

	    var batches = [batch];
	    var reflect_batch = m_batch.find_batch_material_forked(obj, mat_name, "MAIN");
	    if (reflect_batch)
	        batches.push(reflect_batch);

	    for (var i = 0; i < batches.length; i++) {
	        batch = batches[i];


	        if (typeof water_mat_params.shore_smoothing == "boolean")
	            if (cfg_def.shore_smoothing && batch.water_shore_smoothing 
	                    && water_mat_params.shore_smoothing)
	                m_batch.set_batch_directive(batch, "SHORE_SMOOTHING", 1);
	            else
	                m_batch.set_batch_directive(batch, "SHORE_SMOOTHING", 0);

	        if (typeof water_mat_params.absorb_factor == "number") {
	            var absorb_factor = m_shaders.glsl_value(parseFloat(
	                    water_mat_params.absorb_factor));
	            m_batch.set_batch_directive(batch, "ABSORB", absorb_factor);
	        }

	        if (typeof water_mat_params.foam_factor == "number" && cfg_def.foam)
	            batch.foam_factor = water_mat_params.foam_factor;

	        if (cfg_def.shore_distance) {
	            if (typeof water_mat_params.shallow_water_col == "object")
	                batch.shallow_water_col.set(water_mat_params.shallow_water_col);
	            if (typeof water_mat_params.shallow_water_col_fac == "number")
	                batch.shallow_water_col_fac = water_mat_params.shallow_water_col_fac;
	            if (typeof water_mat_params.shore_water_col == "object")
	                batch.shore_water_col.set(water_mat_params.shore_water_col);
	            if (typeof water_mat_params.shore_water_col_fac == "number")
	                batch.shore_water_col_fac = water_mat_params.shore_water_col_fac;
	        }

	        if (typeof water_mat_params.norm_uv_velocity == "number")
	            batch.water_norm_uv_velocity = water_mat_params.norm_uv_velocity;

	        if (cfg_def.water_dynamic && batch.water_dynamic) {
	            if (typeof water_mat_params.water_dynamic == "boolean") {
	                if (water_mat_params.water_dynamic)
	                    m_batch.set_batch_directive(batch, "DYNAMIC", 1);
	                else
	                    m_batch.set_batch_directive(batch, "DYNAMIC", 0);
	            }
	            if (typeof water_mat_params.sss_strength == "number") {
	                var waves_length = m_shaders.glsl_value(parseFloat(
	                        water_mat_params.sss_strength));
	                m_batch.set_batch_directive(batch, "SSS_STRENGTH", waves_length);
	            }
	            if (typeof water_mat_params.sss_width == "number") {
	                var waves_length = m_shaders.glsl_value(parseFloat(
	                        water_mat_params.sss_width));
	                m_batch.set_batch_directive(batch, "SSS_WIDTH", waves_length);
	            }
	            if (typeof water_mat_params.waves_height == "number") {
	                var waves_height = m_shaders.glsl_value(parseFloat(
	                        water_mat_params.waves_height));
	                m_batch.set_batch_directive(batch, "WAVES_HEIGHT", waves_height);
	            }
	            if (typeof water_mat_params.waves_length  == "number") {
	                var waves_length = m_shaders.glsl_value(parseFloat(
	                        water_mat_params.waves_length));
	                m_batch.set_batch_directive(batch, "WAVES_LENGTH", waves_length);
	            }
	            if (typeof water_mat_params.dst_noise_scale0 == "number") {
	                var dst_noise_scale0 = m_shaders.glsl_value(parseFloat(
	                        water_mat_params.dst_noise_scale0));
	                m_batch.set_batch_directive(batch, "DST_NOISE_SCALE_0", dst_noise_scale0);
	            }
	            if (typeof water_mat_params.dst_noise_scale1 == "number") {
	                var dst_noise_scale1 = m_shaders.glsl_value(parseFloat(
	                        water_mat_params.dst_noise_scale1));
	                m_batch.set_batch_directive(batch, "DST_NOISE_SCALE_1", dst_noise_scale1);
	            }
	            if (typeof water_mat_params.dst_noise_freq0 == "number") {
	                var dst_noise_freq0 = m_shaders.glsl_value(parseFloat(
	                        water_mat_params.dst_noise_freq0));
	                m_batch.set_batch_directive(batch, "DST_NOISE_FREQ_0", dst_noise_freq0);
	            }
	            if (typeof water_mat_params.dst_noise_freq1 == "number") {
	                var dst_noise_freq1 = m_shaders.glsl_value(parseFloat(
	                        water_mat_params.dst_noise_freq1));
	                m_batch.set_batch_directive(batch, "DST_NOISE_FREQ_1", dst_noise_freq1);
	            }
	            if (typeof water_mat_params.dir_min_shore_fac == "number") {
	                var dir_min_shore_fac = m_shaders.glsl_value(parseFloat(
	                        water_mat_params.dir_min_shore_fac));
	                m_batch.set_batch_directive(batch, "DIR_MIN_SHR_FAC", dir_min_shore_fac);
	            }
	            if (typeof water_mat_params.dir_freq == "number") {
	                var dir_freq = m_shaders.glsl_value(parseFloat(
	                        water_mat_params.dir_freq));
	                m_batch.set_batch_directive(batch, "DIR_FREQ", dir_freq);
	            }
	            if (typeof water_mat_params.dir_noise_scale == "number") {
	                var dir_noise_scale = m_shaders.glsl_value(parseFloat(
	                        water_mat_params.dir_noise_scale));
	                m_batch.set_batch_directive(batch, "DIR_NOISE_SCALE", dir_noise_scale);
	            }
	            if (typeof water_mat_params.dir_noise_freq == "number") {
	                var dir_noise_freq = m_shaders.glsl_value(parseFloat(
	                        water_mat_params.dir_noise_freq));
	                m_batch.set_batch_directive(batch, "DIR_NOISE_FREQ", dir_noise_freq);
	            }
	            if (typeof water_mat_params.dir_min_noise_fac == "number") {
	                var dir_min_noise_fac = m_shaders.glsl_value(parseFloat(
	                        water_mat_params.dir_min_noise_fac));
	                m_batch.set_batch_directive(batch, "DIR_MIN_NOISE_FAC", dir_min_noise_fac);
	            }
	            if (typeof water_mat_params.dst_min_fac == "number") {
	                var dst_min_fac = m_shaders.glsl_value(parseFloat(
	                        water_mat_params.dst_min_fac));
	                m_batch.set_batch_directive(batch, "DST_MIN_FAC", dst_min_fac);
	            }
	            if (typeof water_mat_params.waves_hor_fac == "number") {
	                var waves_hor_fac = m_shaders.glsl_value(parseFloat(
	                        water_mat_params.waves_hor_fac));
	                m_batch.set_batch_directive(batch, "WAVES_HOR_FAC", waves_hor_fac);
	            }
	        }
	        m_batch.update_shader(batch);
	        m_scenes.recalculate_draw_data(batch);
	    }
	};

	/**
	 * Set parameters for a LINE object.
	 * @method module:material.set_line_params
	 * @param {Object3D} obj Line object 3D
	 * @param {LineParams} line_params Line parameters
	 * @example 
	 * var m_mat = require("material");
	 * var m_scenes = require("scenes");
	 *
	 * var empty = m_scenes.get_object_by_name("Empty");
	 * m_mat.set_line_params(empty, {
	 *     color: [1.0, 0.0, 0.0, 1.0],
	 *     width: 5
	 * });
	 */
	exports.set_line_params = function(obj, line_params) {

	    if (!m_obj_util.is_line(obj)) {
	        m_print.error("set_line_params(): Object \"" + obj.name 
	                + "\" is not a LINE object.");
	        return;
	    }

	    var batch = m_batch.get_first_batch(obj);
	    if (!batch) {
	        m_print.error("set_line_params(): Couldn't set line parameters!");
	        return;
	    }

	    if (m_util.isdef(line_params.color))
	        batch.diffuse_color.set(line_params.color);
	    if (m_util.isdef(line_params.width))
	        batch.line_width = line_params.width;
	};

	/**
	 * Get the parameters of a LINE object.
	 * @method module:material.get_line_params
	 * @param {Object3D} obj Line object 3D
	 * @returns {?LineParams} Line parameters
	 * @example var m_scenes = require("scenes");
	 * var m_mat  = require("material");
	 *
	 * var line_object = m_scenes.get_object_by_name("MyLine");
	 * var line_params = m_mat.get_line_params(line_object);
	 */
	exports.get_line_params = function(obj) {

	    if (!m_obj_util.is_line(obj)) {
	        m_print.error("get_line_params(): Object \"" + obj.name 
	                + "\" is not a LINE object.");
	        return null;
	    }

	    var batch = m_batch.get_first_batch(obj);
	    if (!batch) {
	        m_print.error("get_line_params(): Couldn't get line parameters!");
	        return null;
	    }

	    var line_params = {
	        color : new Float32Array(batch.diffuse_color),
	        width: batch.line_width
	    };

	    return line_params;
	};

	/**
	 * Set value of the Value node in the object's material.
	 * @method module:material.set_nodemat_value
	 * @param {Object3D} obj Object 3D
	 * @param {string[]} name_list List consisting of the material name, the names of
	 * nested node groups (if any) and the name of the Value node itself. Should
	 * have at least 2 elements ["Mat","Node"]. For a world node material the 
	 * material name should be omitted.
	 * @param {number} value The value to set the Value node to
	 * @example 
	 * var m_mat = require("material");
	 * var m_scenes = require("scenes");
	 *
	 * var cube = m_scenes.get_object_by_name("Cube");
	 * m_mat.set_nodemat_value(cube, ["MyMaterial", "Value.001"], 20);
	 */
	exports.set_nodemat_value = function(obj, name_list, value) {

	    var is_dyn_mesh = m_obj_util.is_dynamic_mesh(obj);
	    var is_world = m_obj_util.is_world(obj);

	    var obj_name = is_world ? m_obj.get_world_name(obj) : obj.name;

	    if (!is_dyn_mesh && !is_world) {
	        m_print.error("set_nodemat_value(): Object \"" + obj_name 
	                + "\" is not a dynamic MESH or WORLD.");
	        return;
	    }

	    if (is_dyn_mesh) {
	        var mat_name = name_list[0];
	        var node_name_prefix_offset = 1;

	        var mat_batch = m_batch.find_batch_material_any(obj, mat_name, "MAIN") 
	                || m_batch.find_batch_material_any(obj, mat_name, "PARTICLES");
	        if (!mat_batch) {
	            m_print.error("set_nodemat_value(): Material \"" + mat_name 
	                    + "\" wasn't found on the object \"" + obj_name + "\".");
	            return;
	        }
	    } else if (is_world) {
	        var active_scene = m_scenes.get_active();
	        var mat_name = "";
	        var node_name_prefix_offset = 0;

	        var mat_batch = m_batch.get_batch_by_type(obj, "SKY", active_scene);
	        if (!mat_batch) {
	            m_print.error("set_nodemat_value(): Sky node material wasn't found on the world object \"" 
	                    + obj_name + "\".");
	            return;
	        }
	    }

	    var ind = m_obj.get_node_val_ind_by_name_list(mat_batch.node_value_inds,
	            name_list, node_name_prefix_offset);
	    if (ind === null) {
	        m_print.error("set_nodemat_value(): Value node \"" 
	                + name_list[name_list.length - 1] 
	                + "\" was not found in the object \"" + obj_name + "\".");
	        return;
	    }

	    m_obj.set_nodemat_value(obj, mat_name, ind, value);
	};

	/**
	 * Get value of the Value node in the object's material.
	 * @method module:material.get_nodemat_value
	 * @param {Object3D} obj Object 3D
	 * @param {string[]} name_list List consisting of the material name, the names of
	 * nested node groups (if any) and the name of the Value node itself. Should
	 * have at least 2 elements ["Mat","Node"]. For a world node material the 
	 * material name should be omitted.
	 * @returns {number} Value.
	 * @example var m_scenes = require("scenes");
	 * var m_mat  = require("material");
	 *
	 * var cube = m_scenes.get_object_by_name("Cube");
	 * var node_value = m_mat.get_nodemat_value(cube, ["MyMaterial", "MyValue"]);
	 */
	exports.get_nodemat_value = function(obj, name_list) {

	    var is_dyn_mesh = m_obj_util.is_dynamic_mesh(obj);
	    var is_world = m_obj_util.is_world(obj);

	    var obj_name = is_world ? m_obj.get_world_name(obj) : obj.name;

	    if (!is_dyn_mesh && !is_world) {
	        m_print.error("get_nodemat_value(): Object \"" + obj_name 
	                + "\" is not a dynamic MESH or WORLD.");
	        return 0;
	    }

	    if (is_dyn_mesh) {
	        var mat_name = name_list[0];
	        var node_name_prefix_offset = 1;

	        var mat_batch = m_batch.find_batch_material_any(obj, mat_name, "MAIN") 
	                || m_batch.find_batch_material_any(obj, mat_name, "PARTICLES");
	        if (!mat_batch) {
	            m_print.error("get_nodemat_value(): Material \"" + mat_name 
	                    + "\" wasn't found on the object \"" + obj_name + "\".");
	            return 0;
	        }
	    } else if (is_world) {
	        var active_scene = m_scenes.get_active();
	        var mat_name = "";
	        var node_name_prefix_offset = 0;

	        var mat_batch = m_batch.get_batch_by_type(obj, "SKY", active_scene);
	        if (!mat_batch) {
	            m_print.error("get_nodemat_value(): Sky node material wasn't found on the world object \"" 
	                    + obj_name + "\".");
	            return 0;
	        }
	    }

	    var ind = m_obj.get_node_val_ind_by_name_list(mat_batch.node_value_inds,
	            name_list, node_name_prefix_offset);
	    if (ind === null) {
	        m_print.error("get_nodemat_value(): Value node \"" 
	                + name_list[name_list.length - 1] 
	                + "\" was not found in the object \"" + obj_name + "\".");
	        return 0;
	    }

	    return m_obj.get_nodemat_value(mat_batch, ind);
	};

	/**
	 * Set color of the RGB node in the object's material.
	 * @method module:material.set_nodemat_rgb
	 * @param {Object3D} obj Object 3D
	 * @param {string[]} name_list List consisting of the material name, the names of
	 * nested node groups (if any) and the name of the RGB node itself. For a world 
	 * node material the material name should be omitted.
	 * @param {number} r The value to set the red channel of the RGB node to [0..1]
	 * @param {number} g The value to set the green channel of the RGB node to [0..1]
	 * @param {number} b The value to set the blue channel of the RGB node to [0..1]
	 * @example 
	 * var m_mat = require("material");
	 * var m_scenes = require("scenes");
	 *
	 * var cube = m_scenes.get_object_by_name("Cube");
	 * m_mat.set_nodemat_rgb(cube, ["MyMaterial", "RGB.001"], 1, 0, 1);
	 */
	exports.set_nodemat_rgb = function(obj, name_list, r, g, b) {

	    var is_dyn_mesh = m_obj_util.is_dynamic_mesh(obj);
	    var is_world = m_obj_util.is_world(obj);

	    var obj_name = is_world ? m_obj.get_world_name(obj) : obj.name;

	    if (!is_dyn_mesh && !is_world) {
	        m_print.error("set_nodemat_rgb(): Object \"" + obj_name 
	                + "\" is not a dynamic MESH or WORLD.");
	        return;
	    }

	    if (is_dyn_mesh) {
	        var mat_name = name_list[0];
	        var node_name_prefix_offset = 1;

	        var mat_batch = m_batch.find_batch_material_any(obj, mat_name, "MAIN") 
	                || m_batch.find_batch_material_any(obj, mat_name, "PARTICLES");
	        if (!mat_batch) {
	            m_print.error("set_nodemat_rgb(): Material \"" + mat_name 
	                    + "\" wasn't found on the object \"" + obj_name + "\".");
	            return;
	        }
	    } else if (is_world) {
	        var active_scene = m_scenes.get_active();
	        var mat_name = "";
	        var node_name_prefix_offset = 0;

	        var mat_batch = m_batch.get_batch_by_type(obj, "SKY", active_scene);
	        if (!mat_batch) {
	            m_print.error("set_nodemat_rgb(): Sky node material wasn't found on the world object \"" 
	                    + obj_name + "\".");
	            return;
	        }
	    }

	    var ind = m_obj.get_node_rgb_ind_by_name_list(mat_batch.node_rgb_inds,
	            name_list, node_name_prefix_offset);
	    if (ind === null) {
	        m_print.error("set_nodemat_rgb(): RGB node \"" 
	                + name_list[name_list.length - 1] 
	                + "\" was not found in the object \"" + obj_name + "\".");
	        return;
	    }

	    m_obj.set_nodemat_rgb(obj, mat_name, ind, r, g, b);
	};

	/**
	 * Get color of the RGB node in the object's material.
	 * @method module:material.get_nodemat_rgb
	 * @param {Object3D} obj Object 3D
	 * @param {string[]} name_list List consisting of the material name, the names of
	 * nested node groups (if any) and the name of the RGB node itself.
	 * For a world node material the material name should be omitted.
	 * @param {Vec3} [dest] Destination color
	 * @returns {?RGB} Destination color
	 * @example var m_scenes = require("scenes");
	 * var m_mat  = require("material");
	 *
	 * var cube = m_scenes.get_object_by_name("Cube");
	 * var rgb_node_values = m_mat.get_nodemat_rgb(cube, ["MyMaterial", "MyRGB"]);
	 */
	exports.get_nodemat_rgb = function(obj, name_list, dest) {

	    var is_dyn_mesh = m_obj_util.is_dynamic_mesh(obj);
	    var is_world = m_obj_util.is_world(obj);

	    var obj_name = is_world ? m_obj.get_world_name(obj) : obj.name;

	    if (!is_dyn_mesh && !is_world) {
	        m_print.error("get_nodemat_rgb(): Object \"" + obj_name 
	                + "\" is not a dynamic MESH or WORLD.");
	        return null;
	    }

	    if (is_dyn_mesh) {
	        var mat_name = name_list[0];
	        var node_name_prefix_offset = 1;

	        var mat_batch = m_batch.find_batch_material_any(obj, mat_name, "MAIN") 
	                || m_batch.find_batch_material_any(obj, mat_name, "PARTICLES");
	        if (!mat_batch) {
	            m_print.error("get_nodemat_rgb(): Material \"" + mat_name 
	                    + "\" wasn't found on the object \"" + obj_name + "\".");
	            return null;
	        }
	    } else if (is_world) {
	        var active_scene = m_scenes.get_active();
	        var mat_name = "";
	        var node_name_prefix_offset = 0;

	        var mat_batch = m_batch.get_batch_by_type(obj, "SKY", active_scene);
	        if (!mat_batch) {
	            m_print.error("get_nodemat_rgb(): Sky node material wasn't found on the world object \"" 
	                    + obj_name + "\".");
	            return null;
	        }
	    }

	    var ind = m_obj.get_node_rgb_ind_by_name_list(mat_batch.node_rgb_inds,
	            name_list, node_name_prefix_offset);
	    if (ind === null) {
	        m_print.error("get_nodemat_rgb(): RGB node \"" 
	                + name_list[name_list.length - 1] 
	                + "\" was not found in the object \"" + obj_name + "\".");
	        return null;
	    }

	    if (!dest)
	        dest = new Float32Array(3);

	    return m_obj.get_nodemat_rgb(mat_batch, ind, dest);
	};

	/**
	 * Check if the object's material is a node material.
	 * @method module:material.is_node_material
	 * @param {Object3D} obj Object 3D
	 * @param {string} mat_name Material name
	 * @returns {boolean} The result of the checking.
	 * @example var m_scenes = require("scenes");
	 * var m_mat = require("material");
	 *
	 * var cube = m_scenes.get_object_by_name("Cube");
	 * var has_nodes = m_mat.is_node_material(cube, "MyMaterial");
	 */
	exports.is_node_material = function(obj, mat_name) {

	    if (!m_obj_util.is_dynamic_mesh(obj)) {
	        m_print.error("is_node_material(): Object \"" + obj.name 
	                + "\" is not a dynamic MESH.");
	        return false;
	    }

	    var batch = m_batch.find_batch_material(obj, mat_name, "MAIN");
	    if (!batch) {
	        m_print.error("is_node_material(): Material \"" + mat_name 
	                + "\" wasn't found on the object \"" + obj.name + "\".");
	        return false;
	    }

	    return batch.has_nodes;
	};

	/**
	 * Check if the object's material is a water material.
	 * @method module:material.is_water_material
	 * @param {Object3D} obj Object 3D
	 * @param {string} mat_name Material name
	 * @returns {boolean} The result of the checking.
	 * @example var m_scenes = require("scenes");
	 * var m_mat = require("material");
	 *
	 * var cube = m_scenes.get_object_by_name("Cube");
	 * var is_water = m_mat.is_water_material(cube, "MyMaterial");
	 */
	exports.is_water_material = function(obj, mat_name) {
	    if (!m_obj_util.is_dynamic_mesh(obj)) {
	        m_print.error("is_water_material(): Object \"" + obj.name 
	                + "\" is not a dynamic MESH.");
	        return false;
	    }

	    var batch = m_batch.find_batch_material(obj, mat_name, "MAIN");
	    if (!batch) {
	        m_print.error("is_water_material(): Material \"" + mat_name 
	                + "\" wasn't found on the object \"" + obj.name + "\".");
	        return false;
	    }

	    return batch.water && !batch.has_nodes;
	};

	}

	var material_factory = register("material", Material);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Auxiliary math methods. For math methods operating on vectors, matrices or quaternions see the
	 * corresponding modules.
	 * @module math
	 * @local Plane
	 */
	function Math$1(ns, exports) {

	var m_vec3     = vec3_factory(ns);
	var m_util     = int_util_factory(ns);
	var m_math     = int_math_factory(ns);

	var _vec3_tmp = new Float32Array(3);

	/**
	 * Plane represented as vec3 normal and distance to the origin.
	 * @typedef {Float32Array(4)} Plane
	 */

	/**
	 * Get the parametric line.
	 * @method module:math.create_pline_from_points
	 * @param {Vec3} point1 First point.
	 * @param {Vec3} point2 Second point.
	 * @returns {ParametricLine} Parametric line.
	 */
	exports.create_pline_from_points = function(point1, point2) {
	    var dest = new Float32Array(6);
	    m_math.set_pline_initial_point(dest, point1);

	    m_vec3.subtract(point2, point1, _vec3_tmp);

	    m_math.set_pline_directional_vec(dest, _vec3_tmp);

	    return dest;
	};

	/**
	 * Get the parametric line.
	 * @method module:math.create_pline_from_point_vec
	 * @param {Vec3} point First point.
	 * @param {Vec3} vec Directional vector.
	 * @returns {ParametricLine} Parametric line.
	 */
	exports.create_pline_from_point_vec = function(point, vec) {
	    var dest = new Float32Array(6);
	    m_math.set_pline_initial_point(dest, point);
	    m_math.set_pline_directional_vec(dest, vec);

	    return dest;
	};

	/**
	 * Init the parametric line.
	 * @method module:math.create_pline
	 * @returns {ParametricLine} pline Parametric line.
	 */
	exports.create_pline = function() {
	    return new Float32Array(6);
	};
	/**
	 * Get the parametric line directional vector.
	 * @method module:math.get_pline_directional_vec
	 * @param {ParametricLine} pline Parametric line.
	 * @param {?Vec3} [dest=new Float32Array(3);] Destination vector.
	 * @returns {?Vec3} Destination vector.
	 */
	exports.get_pline_directional_vec = m_math.get_pline_directional_vec;
	/**
	 * Get the parametric line initial point.
	 * @method module:math.get_pline_initial_point
	 * @param {ParametricLine} pline Parametric line.
	 * @param {?Vec3} [dest=new Float32Array(3);] Destination point.
	 * @returns {?Vec3} Destination point.
	 */
	exports.get_pline_initial_point = m_math.get_pline_initial_point;
	/**
	 * Set the parametric line initial point.
	 * @method module:math.set_pline_initial_point
	 * @param {ParametricLine} pline Parametric line.
	 * @param {Vec3} vec3 Point.
	 */
	exports.set_pline_initial_point = m_math.set_pline_initial_point;
	/**
	 * Set the parametric line directional vector.
	 * @method module:math.set_pline_directional_vec
	 * @param {ParametricLine} pline Parametric line.
	 * @param {Vec3} vec3 Vector.
	 */
	exports.set_pline_directional_vec = m_math.set_pline_directional_vec;
	/**
	 * Calculate intersection point of a line and a plane.
	 * @method module:math.line_plane_intersect
	 * @see Lengyel E. - Mathematics for 3D Game Programming and Computer Graphics,
	 * Third Edition. Chapter 5.2.1 Intersection of a Line and a Plane
	 * @param {Vec3} pn Plane normal.
	 * @param {number} p_dist Plane signed distance from the origin.
	 * @param {ParametricLine} pline Parametric line.
	 * @param {Vec3} dest Destination vector.
	 * @returns {?Vec3} Intersection point or null if the line is parallel to the plane.
	 */
	exports.line_plane_intersect = m_util.line_plane_intersect;
	/**
	 * Get the coordinates of a certain point on the given parametric line.
	 * @method module:math.calc_pline_point
	 * @param {ParametricLine} pline Parametric line.
	 * @param {number} t Parameter - distance from the line initial point to a certain point.
	 * @param {?Vec3} [dest=new Float32Array(3);] Destination point.
	 * @returns {?Vec3} Destination point.
	 */
	exports.calc_pline_point = m_math.calc_pline_point;
	/**
	 * Calculate distance from point to plane.
	 * @method module:math.point_plane_dist
	 * @param {Vec3} point Point.
	 * @param {Plane} plane Plane.
	 * @returns {number} Distance.
	 */
	exports.point_plane_dist = m_math.point_plane_dist;
	/**
	 * Interpolate value with no easing, no acceleration.
	 * @method module:math.linear_tween
	 * @param {number} t Current time.
	 * @param {number} b Start value.
	 * @param {number} c Change in value.
	 * @param {number} d Duration.
	 * @returns {number} Interpolated value.
	 */
	exports.linear_tween = m_math.linear_tween;
	/**
	 * Interpolate value with accelerating from zero velocity.
	 * @method module:math.ease_in_quad
	 * @param {number} t Current time.
	 * @param {number} b Start value.
	 * @param {number} c Change in value.
	 * @param {number} d Duration.
	 * @returns {number} Interpolated value.
	 */
	exports.ease_in_quad = m_math.ease_in_quad;
	/**
	 * Interpolate value with decelerating to zero velocity.
	 * @method module:math.ease_out_quad
	 * @param {number} t Current time.
	 * @param {number} b Start value.
	 * @param {number} c Change in value.
	 * @param {number} d Duration.
	 * @returns {number} Interpolated value.
	 */
	exports.ease_out_quad = m_math.ease_out_quad;
	/**
	 * Interpolate value with acceleration until halfway, then deceleration.
	 * @method module:math.ease_in_out_quad
	 * @param {number} t Current time.
	 * @param {number} b Start value.
	 * @param {number} c Change in value.
	 * @param {number} d Duration.
	 * @returns {number} Interpolated value.
	 */
	exports.ease_in_out_quad = m_math.ease_in_out_quad;
	/**
	 * Interpolate value with accelerating from zero velocity.
	 * @method module:math.ease_in_cubic
	 * @param {number} t Current time.
	 * @param {number} b Start value.
	 * @param {number} c Change in value.
	 * @param {number} d Duration.
	 * @returns {number} Interpolated value.
	 */
	exports.ease_in_cubic = m_math.ease_in_cubic;
	/**
	 * Interpolate value with decelerating to zero velocity.
	 * @method module:math.ease_out_cubic
	 * @param {number} t Current time.
	 * @param {number} b Start value.
	 * @param {number} c Change in value.
	 * @param {number} d Duration.
	 * @returns {number} Interpolated value.
	 */
	exports.ease_out_cubic = m_math.ease_out_cubic;
	/**
	 * Interpolate value with acceleration until halfway, then deceleration.
	 * @method module:math.ease_in_out_cubic
	 * @param {number} t Current time.
	 * @param {number} b Start value.
	 * @param {number} c Change in value.
	 * @param {number} d Duration.
	 * @returns {number} Interpolated value.
	 */
	exports.ease_in_out_cubic = m_math.ease_in_out_cubic;
	/**
	 * Interpolate value with accelerating from zero velocity.
	 * @method module:math.ease_in_quart
	 * @param {number} t Current time.
	 * @param {number} b Start value.
	 * @param {number} c Change in value.
	 * @param {number} d Duration.
	 * @returns {number} Interpolated value.
	 */
	exports.ease_in_quart = m_math.ease_in_quart;
	/**
	 * Interpolate value with decelerating to zero velocity.
	 * @method module:math.ease_out_quart
	 * @param {number} t Current time.
	 * @param {number} b Start value.
	 * @param {number} c Change in value.
	 * @param {number} d Duration.
	 * @returns {number} Interpolated value.
	 */
	exports.ease_out_quart = m_math.ease_out_quart;
	/**
	 * Interpolate value with acceleration until halfway, then deceleration.
	 * @method module:math.ease_in_out_quart
	 * @param {number} t Current time.
	 * @param {number} b Start value.
	 * @param {number} c Change in value.
	 * @param {number} d Duration.
	 * @returns {number} Interpolated value.
	 */
	exports.ease_in_out_quart = m_math.ease_in_out_quart;
	/**
	 * Interpolate value with decelerating from zero velocity.
	 * @method module:math.ease_in_quint
	 * @param {number} t Current time.
	 * @param {number} b Start value.
	 * @param {number} c Change in value.
	 * @param {number} d Duration.
	 * @returns {number} Interpolated value.
	 */
	exports.ease_in_quint = m_math.ease_in_quint;
	/**
	 * Interpolate value with decelerating to zero velocity.
	 * @method module:math.ease_out_quint
	 * @param {number} t Current time.
	 * @param {number} b Start value.
	 * @param {number} c Change in value.
	 * @param {number} d Duration.
	 * @returns {number} Interpolated value.
	 */
	exports.ease_out_quint = m_math.ease_out_quint;
	/**
	 * Interpolate value with acceleration until halfway, then deceleration.
	 * @method module:math.ease_in_out_quint
	 * @param {number} t Current time.
	 * @param {number} b Start value.
	 * @param {number} c Change in value.
	 * @param {number} d Duration.
	 * @returns {number} Interpolated value.
	 */
	exports.ease_in_out_quint = m_math.ease_in_out_quint;
	/**
	 * Interpolate value with decelerating from zero velocity.
	 * @method module:math.ease_in_sine
	 * @param {number} t Current time.
	 * @param {number} b Start value.
	 * @param {number} c Change in value.
	 * @param {number} d Duration.
	 * @returns {number} Interpolated value.
	 */
	exports.ease_in_sine = m_math.ease_in_sine;
	/**
	 * Interpolate value with decelerating to zero velocity.
	 * @method module:math.ease_out_sine
	 * @param {number} t Current time.
	 * @param {number} b Start value.
	 * @param {number} c Change in value.
	 * @param {number} d Duration.
	 * @returns {number} Interpolated value.
	 */
	exports.ease_out_sine = m_math.ease_out_sine;
	/**
	 * Interpolate value with acceleration until halfway, then decelerating.
	 * @method module:math.ease_in_out_sine
	 * @param {number} t Current time.
	 * @param {number} b Start value.
	 * @param {number} c Change in value.
	 * @param {number} d Duration.
	 * @returns {number} Interpolated value.
	 */
	exports.ease_in_out_sine = m_math.ease_in_out_sine;
	/**
	 * Interpolate value with decelerating from zero velocity.
	 * @method module:math.ease_in_expo
	 * @param {number} t Current time.
	 * @param {number} b Start value.
	 * @param {number} c Change in value.
	 * @param {number} d Duration.
	 * @returns {number} Interpolated value.
	 */
	exports.ease_in_expo = m_math.ease_in_expo;
	/**
	 * Interpolate value with decelerating to zero velocity.
	 * @method module:math.ease_out_expo
	 * @param {number} t Current time.
	 * @param {number} b Start value.
	 * @param {number} c Change in value.
	 * @param {number} d Duration.
	 * @returns {number} Interpolated value.
	 */
	exports.ease_out_expo = m_math.ease_out_expo;
	/**
	 * Interpolate value with acceleration until halfway, then decelerating.
	 * @method module:math.ease_in_out_expo
	 * @param {number} t Current time.
	 * @param {number} b Start value.
	 * @param {number} c Change in value.
	 * @param {number} d Duration.
	 * @returns {number} Interpolated value.
	 */
	exports.ease_in_out_expo = m_math.ease_in_out_expo;
	/**
	 * Interpolate value with decelerating from zero velocity.
	 * @method module:math.ease_in_circ
	 * @param {number} t Current time.
	 * @param {number} b Start value.
	 * @param {number} c Change in value.
	 * @param {number} d Duration.
	 * @returns {number} Interpolated value.
	 */
	exports.ease_in_circ = m_math.ease_in_circ;
	/**
	 * Interpolate value with decelerating to zero velocity.
	 * @method module:math.ease_out_circ
	 * @param {number} t Current time.
	 * @param {number} b Start value.
	 * @param {number} c Change in value.
	 * @param {number} d Duration.
	 * @returns {number} Interpolated value.
	 */
	exports.ease_out_circ = m_math.ease_out_circ;
	/**
	 * Interpolate value with acceleration until halfway, then deceleration.
	 * @method module:math.ease_in_out_circ
	 * @param {number} t Current time.
	 * @param {number} b Start value.
	 * @param {number} c Change in value.
	 * @param {number} d Duration.
	 * @returns {number} Interpolated value.
	 */
	exports.ease_in_out_circ = m_math.ease_in_out_circ;
	/**
	 * Interpolate value with decelerating from zero velocity.
	 * @method module:math.ease_in_elastic
	 * @param {number} t Current time.
	 * @param {number} b Start value.
	 * @param {number} c Change in value.
	 * @param {number} d Duration.
	 * @returns {number} Interpolated value.
	 */
	exports.ease_in_elastic = m_math.ease_in_elastic;
	/**
	 * Interpolate value with decelerating to zero velocity.
	 * @method module:math.ease_out_elastic
	 * @param {number} t Current time.
	 * @param {number} b Start value.
	 * @param {number} c Change in value.
	 * @param {number} d Duration.
	 * @returns {number} Interpolated value.
	 */
	exports.ease_out_elastic = m_math.ease_out_elastic;
	/**
	 * Interpolate value with acceleration until halfway, then deceleration.
	 * @method module:math.ease_in_out_elastic
	 * @param {number} t Current time.
	 * @param {number} b Start value.
	 * @param {number} c Change in value.
	 * @param {number} d Duration.
	 * @returns {number} Interpolated value.
	 */
	exports.ease_in_out_elastic = m_math.ease_in_out_elastic;
	/**
	 * Interpolate value with decelerating from zero velocity.
	 * @method module:math.ease_in_back
	 * @param {number} t Current time.
	 * @param {number} b Start value.
	 * @param {number} c Change in value.
	 * @param {number} d Duration.
	 * @returns {number} Interpolated value.
	 */
	exports.ease_in_back = m_math.ease_in_back;
	/**
	 * Interpolate value with decelerating to zero velocity.
	 * @method module:math.ease_out_back
	 * @param {number} t Current time.
	 * @param {number} b Start value.
	 * @param {number} c Change in value.
	 * @param {number} d Duration.
	 * @returns {number} Interpolated value.
	 */
	exports.ease_out_back = m_math.ease_out_back;
	/**
	 * Interpolate value with acceleration until halfway, then deceleration.
	 * @method module:math.ease_in_out_back
	 * @param {number} t Current time.
	 * @param {number} b Start value.
	 * @param {number} c Change in value.
	 * @param {number} d Duration.
	 * @returns {number} Interpolated value.
	 */
	exports.ease_in_out_back = m_math.ease_in_out_back;
	/**
	 * Interpolate value with decelerating from zero velocity.
	 * @method module:math.ease_in_bounce
	 * @param {number} t Current time.
	 * @param {number} b Start value.
	 * @param {number} c Change in value.
	 * @param {number} d Duration.
	 * @returns {number} Interpolated value.
	 */
	exports.ease_in_bounce = m_math.ease_in_bounce;
	/**
	 * Interpolate value with decelerating to zero velocity.
	 * @method module:math.ease_out_bounce
	 * @param {number} t Current time.
	 * @param {number} b Start value.
	 * @param {number} c Change in value.
	 * @param {number} d Duration.
	 * @returns {number} Interpolated value.
	 */
	exports.ease_out_bounce = m_math.ease_out_bounce;
	/**
	 * Interpolate value with acceleration until halfway, then deceleration.
	 * @method module:math.ease_in_out_bounce
	 * @param {number} t Current time.
	 * @param {number} b Start value.
	 * @param {number} c Change in value.
	 * @param {number} d Duration.
	 * @returns {number} Interpolated value.
	 */
	exports.ease_in_out_bounce = m_math.ease_in_out_bounce;

	}

	var math_factory = register("math", Math$1);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * API methods to control {@link https://www.blend4web.com/doc/en/animation.html#non-linear-animation|non linear animation}.
	 * @module nla
	 * @local NlaFinishCallback
	 */
	function NLA(ns, exports) {

	var m_nla    = int_nla_factory(ns);
	var m_time   = int_time_factory(ns);
	var m_print  = print_factory(ns);
	var m_util   = int_util_factory(ns);

	/**
	 * Callback executed after the NLA animation has finished.
	 * @callback NlaFinishCallback
	 */

	/**
	 * Set NLA animation frame for the active scene.
	 * @method module:nla.set_frame
	 * @param {number} frame NLA animation frame
	 */
	exports.set_frame = function(frame) {
	    
	    frame = m_util.clamp(frame, m_nla.get_frame_start(), 
	            m_nla.get_frame_end());

	    if (m_nla.check_logic_nodes()) {
	        m_print.error("The active scene is using the Logic Editor.");
	        return;
	    }
	    m_nla.set_frame(frame, m_time.get_timeline());
	};
	/**
	 * Get NLA animation frame from the active scene
	 * @method module:nla.get_frame
	 * @returns {number} NLA animation current frame.
	 */
	exports.get_frame = function() {
	    return m_nla.get_frame(m_time.get_timeline());
	};

	/**
	 * Stop NLA animation for the active scene.
	 * @method module:nla.stop
	 */
	exports.stop = function() {
	    if (m_nla.check_logic_nodes())
	        m_print.warn("The active scene is using the Logic Editor. It may conflicts with your JS-code.");

	    m_nla.stop_nla();
	};

	/**
	 * Play NLA animation for the active scene
	 * @method module:nla.play
	 * @param {?NlaFinishCallback} [callback=null] Nla finish callback.
	 */
	exports.play = function(callback) {
	    if (m_nla.check_logic_nodes())
	        m_print.warn("The active scene is using the Logic Editor. It may conflicts with your JS-code.");

	    m_nla.play_nla(callback);
	};

	/**
	 * Check if NLA animation is being run for the active scene
	 * @method module:nla.is_play
	 * @returns {boolean} Check result.
	 */
	exports.is_play = function() {
	    return m_nla.is_play();
	};
	/**
	 * Get NLA animation starting frame for the active scene
	 * @method module:nla.get_frame_start
	 * @returns {number} Start frame.
	 */
	exports.get_frame_start = function() {
	    return m_nla.get_frame_start();
	};
	/**
	 * Get NLA animation ending frame for the active scene
	 * @method module:nla.get_frame_end
	 * @returns {number} End frame.
	 */
	exports.get_frame_end = function() {
	    return m_nla.get_frame_end();
	};
	/**
	 * Check if the current scene is currently NLA animated.
	 * @method module:nla.check_nla
	 * @returns {boolean} Check result.
	 */
	exports.check_nla = function() {
	    return m_nla.check_nla();
	};

	/**
	 * Check if the current scene has logic nodes
	 * @method module:nla.check_logic_nodes
	 * @returns {boolean} Check result.
	 */
	exports.check_logic_nodes = function() {
	    return m_nla.check_logic_nodes();
	};

	/**
	 * Play NLA animation for the active scene from start frame to end frame.
	 * @method module:nla.set_range
	 * @param {number} start_frame Start NLA animation frame
	 * @param {number} end_frame End NLA animation frame
	 */
	exports.set_range = function(start_frame, end_frame) {

	    if (m_nla.check_logic_nodes()) {
	        m_print.error("The active scene is using the Logic Editor.");
	        return;
	    }

	    end_frame = parseFloat(end_frame) || m_nla.get_frame_end();
	    start_frame = parseFloat(start_frame) || m_nla.get_frame_end();

	    end_frame = m_util.clamp(end_frame, m_nla.get_frame_start(), 
	            m_nla.get_frame_end());

	    start_frame = m_util.clamp(start_frame, m_nla.get_frame_start(), 
	            end_frame);

	    m_nla.set_range(start_frame, end_frame);
	};
	/**
	 * Reset NLA animation playing range
	 * @method module:nla.reset_range
	 */
	exports.reset_range = function() {
	    if (m_nla.check_logic_nodes()) {
	        m_print.error("The active scene is using the Logic Editor.");
	        return;
	    }
	    m_nla.reset_range();
	};
	/**
	 * Set cyclic behaviour for the active scene
	 * @method module:nla.set_cyclic
	 * @param {boolean} is_cyclic Cyclic behavior.
	 */
	exports.set_cyclic = function(is_cyclic) {
	    if (m_nla.check_logic_nodes()) {
	        m_print.error("The active scene is using the Logic Editor.");
	        return;
	    }
	    m_nla.set_cyclic(is_cyclic);
	};
	/**
	 * Clear callback executed after the NLA animation finished
	 * @method module:nla.clear_callback
	 */
	exports.clear_callback = function() {
	    if (m_nla.check_logic_nodes()) {
	        m_print.error("The active scene is using the Logic Editor.");
	        return;
	    }
	    m_nla.clear_callback();
	};
	}

	var nla_factory = register("nla", NLA);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Objects API.
	 * <p>Additional topics in the User Manual: {@link
	 * https://www.blend4web.com/doc/en/objects.html#object-transform-api|Object Transform API}, 
	 * {@link https://www.blend4web.com/doc/en/objects.html#get-object-api|Get
	 * Object API}, {@link
	 * https://www.blend4web.com/doc/en/objects.html#object-selection|Object
	 * Selection}, {@link
	 * https://www.blend4web.com/doc/en/objects.html#copying-objects-instancing|Copying
	 * Objects (Instancing)}
	 * @module objects
	 * @local ObjectMetaTags
	 * @local WindBendingParams
	 */
	function Objects(ns, exports) {

	var m_geom     = int_geometry_factory(ns);
	var m_obj      = int_objects_factory(ns);
	var m_batch    = int_batch_factory(ns);
	var m_obj_util = int_obj_util_factory(ns);
	var m_print    = print_factory(ns);
	var m_scenes   = int_scenes_factory(ns);
	var m_util     = int_util_factory(ns);

	/**
	 * @typedef {Object} ObjectMetaTags
	 * @property {string} title The title meta tag.
	 * @property {string} description The description meta tag.
	 * @property {string} category The category meta tag.
	 */

	/**
	 * Wind bending params.
	 * @typedef {Object} WindBendingParams
	 * @property {number} angle Angle of main wind bending in degrees
	 * @property {number} main_frequency Frequency of main wind bending
	 * @property {number} detail_frequency Frequency of detail wind bending
	 * @property {number} detail_amplitude Amplitude of detail wind bending
	 * @property {number} branch_amplitude Amplitude of branches wind bending
	 * @cc_externs angle main_frequency detail_frequency
	 * @cc_externs detail_amplitude branch_amplitude
	 */

	/**
	 * Get the Blender-assigned meta tags from the object.
	 * @method module:objects.get_meta_tags
	 * @param {Object3D} obj Object 3D
	 * @returns {ObjectMetaTags} Object meta tags
	 * @cc_externs title description category
	 */
	exports.get_meta_tags = function(obj) {
	    if (obj)
	        return m_obj.get_meta_tags(obj);
	};

	/**
	 * Get the Blender-assigned custom property field from the object.
	 * @method module:objects.get_custom_prop
	 * @param {Object3D} obj Object 3D
	 * @returns {*} Object custom property field
	 */
	exports.get_custom_prop = function(obj) {
	    if (obj)
	        return m_obj.get_custom_prop(obj);
	};
	/**
	 * Copy MESH object.
	 * @method module:objects.copy
	 * @param {Object3D} obj Object 3D
	 * @param {string} name New unique object name
	 * @param {boolean} [deep_copy=false] Copy WebGL buffers
	 * @returns {Object3D} New object.
	 */
	exports.copy = function(obj, name, deep_copy) {

	    if (!m_obj_util.is_mesh(obj)) {
	        m_print.error("object \"" + obj.name + "\" is not of type \"MESH\".");
	        return false;
	    }

	    if (!m_obj_util.is_dynamic(obj)) {
	        m_print.error("object \"" + obj.name + "\" is not dynamic.");
	        return false;
	    }
	    if (!(m_geom.has_dyn_geom(obj) || m_geom.check_shape_keys(obj)) && deep_copy) {
	        m_print.error("object \"" + obj.name + "\" has not dynamic " 
	                + "geometry for deep copying.");
	        return false;
	    }
	    // HACK: a temporary (provisional) solution
	    var objs = m_obj.get_scene_objs(m_scenes.get_active(), "MESH", m_obj.DATA_ID_ALL);
	    if (objs.indexOf(obj) == - 1) {
	        m_print.error("object \"" + obj.name + "\" does not belong to the " 
	                + "active scene.");
	        return false;
	    }
	    name = name || "";
	    return m_obj.copy(obj, name, deep_copy);
	};

	/**
	 * Set value of the Value node in the object's material.
	 * @method module:objects.set_nodemat_value
	 * @param {Object3D} obj Object 3D
	 * @param {string[]} name_list List consisting of the material name, the names of
	 * nested node groups (if any) and the name of the Value node itself. Should
	 * have at least 2 elements ["Mat","Node"]
	 * @param {number} value The value to set the Value node to
	 * @deprecated Use {@link module:material.set_nodemat_value|material.set_nodemat_value} instead
	 */
	exports.set_nodemat_value = function(obj, name_list, value) {
	    m_print.error_deprecated("set_nodemat_value", "material.set_nodemat_value");
	    if (!m_obj_util.is_dynamic_mesh(obj)) {
	        m_print.error("The type of the object \"" + obj.name +
	            "\" is not \"MESH\" or it is not dynamic.");
	        return;
	    }

	    var mat_name = name_list[0];
	    var batch_main = m_batch.find_batch_material(obj, mat_name, "MAIN");
	    if (batch_main === null) {
	        m_print.error("Material \"" + mat_name +
	                      "\" was not found in the object \"" + obj.name + "\".");
	        return null;
	    }

	    var ind = m_obj.get_node_val_ind_by_name_list(batch_main.node_value_inds,
	                                                name_list, 1);
	    if (ind === null) {
	        m_print.error("Value node \"" + name_list[name_list.length - 1] +
	        "\" was not found in the object \"" + obj.name + "\".");
	        return null;
	    }

	    m_obj.set_nodemat_value(obj, mat_name, ind, value);
	};

	/**
	 * Get value of the Value node in the object's material.
	 * @method module:objects.get_nodemat_value
	 * @param {Object3D} obj Object 3D
	 * @param {string[]} name_list List consisting of the material name, the names of
	 * nested node groups (if any) and the name of the Value node itself. Should
	 * have at least 2 elements ["Mat","Node"]
	 * @returns {number} Value.
	 * @deprecated Use {@link module:material.get_nodemat_value|material.get_nodemat_value} instead
	 */
	exports.get_nodemat_value = function(obj, name_list) {
	    m_print.error_deprecated("get_nodemat_value", "material.get_nodemat_value");
	    if (!m_obj_util.is_dynamic_mesh(obj)) {
	        m_print.error("The type of the object \"" + obj.name +
	            "\" is not \"MESH\" or it is not dynamic.");
	        return 0;
	    }

	    var mat_name = name_list[0];
	    var batch_main = m_batch.find_batch_material(obj, mat_name, "MAIN");
	    if (batch_main === null) {
	        m_print.error("Material \"" + mat_name +
	                      "\" was not found in the object \"" + obj.name + "\".");
	        return 0;
	    }

	    var ind = m_obj.get_node_val_ind_by_name_list(batch_main.node_value_inds,
	                                                name_list, 1);
	    if (ind === null) {
	        m_print.error("Value node \"" + name_list[name_list.length - 1] +
	        "\" was not found in the object \"" + obj.name + "\".");
	        return 0;
	    }

	    return m_obj.get_nodemat_value(batch_main, ind);
	};

	/**
	 * Set color of the RGB node in the object's material.
	 * @method module:objects.set_nodemat_rgb
	 * @param {Object3D} obj Object 3D
	 * @param {string[]} name_list List consisting of the material name, the names of
	 * nested node groups (if any) and the name of the RGB node itself
	 * @param {number} r The value to set the red channel of the RGB node to [0..1]
	 * @param {number} g The value to set the green channel of the RGB node to [0..1]
	 * @param {number} b The value to set the blue channel of the RGB node to [0..1]
	 * @deprecated Use {@link module:material.set_nodemat_rgb|material.set_nodemat_rgb} instead
	 */
	exports.set_nodemat_rgb = function(obj, name_list, r, g, b) {
	    m_print.error_deprecated("set_nodemat_rgb", "material.set_nodemat_rgb");
	    if (!m_obj_util.is_dynamic_mesh(obj)) {
	        m_print.error("The type of the object \"" + obj.name +
	            "\" is not \"MESH\" or it is not dynamic.");
	        return;
	    }

	    var mat_name = name_list[0];
	    var batch_main = m_batch.find_batch_material(obj, mat_name, "MAIN");
	    if (batch_main === null) {
	        m_print.error("Material \"" + mat_name +
	                      "\" was not found in the object \"" + obj.name + "\".");
	        return;
	    }

	    // node index is assumed to be similar for all batches with the same material
	    var ind = m_obj.get_node_rgb_ind_by_name_list(batch_main.node_rgb_inds,
	                                                name_list, 1);
	    if (ind === null) {
	        m_print.error("RGB node \"" + name_list[name_list.length - 1] +
	                      "\" was not found in the object \"" + obj.name + "\".");
	        return;
	    }

	    m_obj.set_nodemat_rgb(obj, mat_name, ind, r, g, b);
	};

	/**
	 * Get color of the RGB node in the object's material.
	 * @method module:objects.get_nodemat_rgb
	 * @param {Object3D} obj Object 3D
	 * @param {string[]} name_list List consisting of the material name, the names of
	 * nested node groups (if any) and the name of the RGB node itself
	 * @param {Vec3} [dest] Destination color
	 * @returns {RGB} Destination color
	 * @deprecated Use {@link module:material.get_nodemat_rgb|material.get_nodemat_rgb} instead
	 */
	exports.get_nodemat_rgb = function(obj, name_list, dest) {
	    m_print.error_deprecated("get_nodemat_rgb", "material.get_nodemat_rgb");
	    if (!m_obj_util.is_dynamic_mesh(obj)) {
	        m_print.error("The type of the object \"" + obj.name +
	            "\" is not \"MESH\" or it is not dynamic.");
	        return null;
	    }

	    var mat_name = name_list[0];
	    var batch_main = m_batch.find_batch_material(obj, mat_name, "MAIN");
	    if (batch_main === null) {
	        m_print.error("Material \"" + mat_name +
	                      "\" was not found in the object \"" + obj.name + "\".");
	        return null;
	    }

	    var ind = m_obj.get_node_rgb_ind_by_name_list(batch_main.node_rgb_inds,
	                                                name_list);
	    if (ind === null) {
	        m_print.error("RGB node \"" + name_list[name_list.length - 1] +
	                      "\" was not found in the object \"" + obj.name + "\".");
	        return null;
	    }

	    if (!dest)
	        dest = new Float32Array(3);

	    return m_obj.get_nodemat_rgb(batch_main, ind, dest);
	};

	/**
	 * Update object's boundings (box, cone, cylinder, ellipsoid, sphere, capsule).
	 * @method module:objects.update_boundings
	 * @param {Object3D} obj Object 3D
	 */
	exports.update_boundings = function(obj) {

	    if (!m_obj_util.is_mesh(obj)) {
	        m_print.error("The type of the object \"" + obj.name +
	            "\" is not \"MESH\".");
	        return;
	    }

	    if (!(m_geom.has_dyn_geom(obj) || m_geom.check_shape_keys(obj))) {
	        m_print.error("object \"" + obj.name + "\" has not dynamic " 
	                + "geometry.");
	        return;
	    }
	    m_obj.update_boundings(obj);
	};

	/**
	 * Get parent object.
	 * @method module:objects.get_parent
	 * @param {Object3D} obj Child object
	 * @returns {?Object3D} Parent object
	 */
	exports.get_parent = m_obj_util.get_parent;

	/**
	 * Get DupliGroup parent object.
	 * @method module:objects.get_dg_parent
	 * @param {Object3D} obj Child object
	 * @returns {?Object3D} Parent object
	 */
	exports.get_dg_parent = m_obj_util.get_dg_parent;

	/**
	 * Check if the object is a MESH.
	 * @method module:objects.is_mesh
	 * @param {Object3D} obj Object 3D
	 * @returns {boolean} Checking result.
	 */
	exports.is_mesh = m_obj_util.is_mesh;

	/**
	 * Check if the object is an ARMATURE.
	 * @method module:objects.is_armature
	 * @param {Object3D} obj Object 3D
	 * @returns {boolean} Checking result.
	 */
	exports.is_armature = m_obj_util.is_armature;

	/**
	 * Check if the object is a SPEAKER.
	 * @method module:objects.is_speaker
	 * @param {Object3D} obj Object 3D
	 * @returns {boolean} Checking result.
	 */
	exports.is_speaker = m_obj_util.is_speaker;

	/**
	 * Check if the object is a CAMERA.
	 * @method module:objects.is_camera
	 * @param {Object3D} obj Object 3D
	 * @returns {boolean} Checking result.
	 */
	exports.is_camera = m_obj_util.is_camera;

	/**
	 * Check if the object is a LAMP.
	 * @method module:objects.is_lamp
	 * @param {Object3D} obj Object 3D
	 * @returns {boolean} Checking result.
	 */
	exports.is_lamp = m_obj_util.is_lamp;

	/**
	 * Check if the object is an EMPTY.
	 * @method module:objects.is_empty
	 * @param {Object3D} obj Object 3D
	 * @returns {boolean} Checking result.
	 */
	exports.is_empty = m_obj_util.is_empty;

	/**
	 * Check if the object is a LINE.
	 * @method module:objects.is_line
	 * @param {Object3D} obj Object 3D
	 * @returns {boolean} Checking result.
	 */
	exports.is_line = m_obj_util.is_line;

	/**
	 * Check if the object is a WORLD.
	 * @method module:objects.is_world
	 * @param {Object3D} obj Object 3D
	 * @returns {boolean} Checking result.
	 */
	exports.is_world = m_obj_util.is_world;

	/**
	 * Get all scene selectable objects.
	 * @method module:objects.get_selectable_objects
	 * @returns {Object3D[]} Array with selectable objects.
	 */
	exports.get_selectable_objects = function() {

	    return m_obj.get_selectable_objects();
	};
	/**
	 * Get all scene outlining objects.
	 * @method module:objects.get_outlining_objects
	 * @returns {Object3D[]} Array with outlining objects.
	 */
	exports.get_outlining_objects = function() {

	    return m_obj.get_outlining_objects();
	};
	/**
	 * Check if object is dynamic.
	 * @method module:objects.is_dynamic
	 * @param {Object3D} obj Object 3D
	 * @returns {boolean} Checking result.
	 */
	exports.is_dynamic = m_obj_util.is_dynamic;

	/**
	 * Set object's wind bending parameters. Object must be dynamic.
	 * @param {Object3D} obj Object 3D
	 * @param {WindBendingParams} wb_params Wind Bending parameters
	 * @example
	 * var m_obj = require("objects");
	 * var wb_params =
	 * {
	 *     angle: 45,
	 *     main_frequency: 0.25,
	 *     detail_frequency: 1,
	 *     detail_amplitude: 0.1,
	 *     branch_amplitude: 0.3
	 * };
	 * m_obj.set_wind_bending_params(obj, wb_params);
	 */
	exports.set_wind_bending_params = function(obj, wb_params) {

	    if (!m_obj_util.is_dynamic_mesh(obj)) {
	        m_print.error("The type of the object \"" + obj.name +
	            "\" is not \"MESH\" or it is not dynamic.");
	        return;
	    }

	    var render = obj.render;
	    if (!render.wind_bending) {
	        m_print.error("The \"" + obj.name + "\" object " +
	            "doesn't have wind bending parameters.");
	        return;
	    }

	    if (typeof wb_params.angle == "number") {
	        var amp = m_batch.wb_angle_to_amp(m_util.deg_to_rad(wb_params.angle), 
	                render.bb_original, render.world_tsr[3]);
	        render.wind_bending_amp = amp;
	    }

	    if (typeof wb_params.main_frequency == "number")
	        render.wind_bending_freq = wb_params.main_frequency;

	    if (typeof wb_params.detail_frequency == "number")
	        render.detail_bending_freq = wb_params.detail_frequency;

	    if (typeof wb_params.detail_amplitude == "number")
	        render.detail_bending_amp = wb_params.detail_amplitude;

	    if (typeof wb_params.branch_amplitude == "number")
	        render.branch_bending_amp = wb_params.branch_amplitude;

	    m_obj.set_hair_particles_wind_bend_params(obj);
	};

	/**
	 * Get object's wind bending parameters. Object must be dynamic.
	 * @param {Object3D} obj Object 3D
	 * @returns {WindBendingParams} Wind Bending parameters
	 */
	exports.get_wind_bending_params = function(obj) {

	    var render = obj.render;

	    if (!render.wind_bending)
	        return null;

	    var wb_params = {};

	    var angle = m_util.rad_to_deg(m_batch.wb_amp_to_angle(render.wind_bending_amp,
	            render.bb_original, render.world_tsr[3]));

	    wb_params.angle = angle;
	    wb_params.main_frequency = render.wind_bending_freq;
	    wb_params.detail_frequency = render.detail_bending_freq;
	    wb_params.detail_amplitude = render.detail_bending_amp;
	    wb_params.branch_amplitude = render.branch_bending_amp;

	    return wb_params;
	};

	/**
	 * Create line object
	 * @param {string} name Line object name
	 */
	exports.create_line = function(name) {
	    return m_obj.create_line(name);
	};

	/**
	 * Hide objects that have the given data_id.
	 * @param {number} data_id ID of loaded data.
	 * @example
	 * var m_obj = require("objects");
	 * m_obj.hide_all_by_data_id(0);
	 */
	exports.hide_all_by_data_id = function(data_id) {
	    var objs = m_obj.get_all_objects("ALL", data_id);
	    for (var i = 0; i < objs.length; i++)
	        m_scenes.change_visibility(objs[i], true);
	};

	/**
	 * Show objects that have the given data_id.
	 * @param {number} data_id ID of loaded data.
	 * @example
	 * var m_obj = require("objects");
	 * m_obj.show_all_by_data_id(1);
	 */
	exports.show_all_by_data_id = function(data_id) {
	    var objs = m_obj.get_all_objects("ALL", data_id);
	    for (var i = 0; i < objs.length; i++)
	        m_scenes.change_visibility(objs[i], false);
	};

	}

	var objects_factory = register("objects", Objects);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * {@link https://www.blend4web.com/doc/en/particles.html|Particle system} API. Please note that particle emission itself is controlled by the {@link module:animation} module.
	 * @module particles
	 */
	function Particles(ns, exports) {

	var m_particles = int_particles_factory(ns);
	var m_print     = print_factory(ns);

	/**
	 * Set particle size.
	 * @method module:particles.set_size
	 * @param {Object3D} obj Emitter object.
	 * @param {string} psys_name Particle system name.
	 * @param {number} size Particle size.
	 * @example var m_particles = require("particles");
	 * var m_scenes = require("scenes");
	 *
	 * var cube = m_scenes.get_object_by_name("Cube");
	 * m_particles.set_size(cube, "MyParticleSystem", 2.4);
	 */
	exports.set_size = function(obj, psys_name, size) {
	    if (!m_particles.obj_has_psys(obj, psys_name)) {
	        m_print.error("set_size(): Object \"" + obj.name + "\" has not a particle system named \"" 
	                + psys_name + "\"");
	        return;
	    }
	    m_particles.set_size(obj, psys_name, size);
	};


	/**
	 * Set particle normal factor.
	 * @method module:particles.set_normal_factor
	 * @param {Object3D} obj Emitter object.
	 * @param {string} psys_name Particle system name.
	 * @param {number} nfactor Particle normal factor.
	 * @example var m_particles = require("particles");
	 * var m_scenes = require("scenes");
	 *
	 * var cube = m_scenes.get_object_by_name("Cube");
	 * m_particles.set_normal_factor(cube, "MyParticleSystem", 15);
	 */
	exports.set_normal_factor = function(obj, psys_name, nfactor) {
	    if (!m_particles.obj_has_psys(obj, psys_name)) {
	        m_print.error("set_normal_factor(): Object \"" + obj.name + "\" has not a particle system named \"" 
	                + psys_name + "\"");
	        return;
	    }
	    m_particles.set_normal_factor(obj, psys_name, nfactor);
	};

	/**
	 * Set particle number factor.
	 * @method module:particles.set_factor
	 * @param {Object3D} obj Emitter object.
	 * @param {string} psys_name Particle system name.
	 * @param {number} factor Particle number factor. A coefficient defining the 
	 * number of particles to be emitted. 1 - all particles, 0 - none.
	 * @example var m_particles = require("particles");
	 * var m_scenes = require("scenes");
	 *
	 * var cube = m_scenes.get_object_by_name("Cube");
	 * m_particles.set_factor(cube, "MyParticleSystem", 0.3);
	 */
	exports.set_factor = function(obj, psys_name, factor) {
	    if (!m_particles.obj_has_psys(obj, psys_name)) {
	        m_print.error("set_factor(): Object \"" + obj.name + "\" has not a particle system named \"" 
	                + psys_name + "\"");
	        return;
	    }
	    factor = Math.min(factor, 1);
	    factor = Math.max(factor, 0);

	    m_particles.set_factor(obj, psys_name, factor);
	};

	}

	var particles_factory = register("particles", Particles);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * RGB colors API.
	 * To match standard Blender behavior colors in Blend4Web are always stored in linear space, for more info check the {@link https://www.blend4web.com/doc/en/colors.html documentation}.
	 * @module rgb
	 */
	function RGB(ns, exports) {

	var m_util  = int_util_factory(ns);

	var _rgb_tmp = new Float32Array(3);

	/**
	 * Creates a new empty RGB vector representing black color.
	 * @returns {RGB} A new RGB vector.
	 * @alias module:rgb.create
	 * @example var m_rgb = require("rgb");
	 *
	 * var new_color = m_rgb.create();
	 */
	exports.create = function() {
	    var dest = new Float32Array(3);
	    return dest;
	};

	/**
	 * Creates a new RGB vector initialized with the given values.
	 *
	 * @param {number} r Red component.
	 * @param {number} g Green component.
	 * @param {number} b Blue component.
	 * @returns {RGB} A new RGB vector.
	 * @alias module:rgb.from_values
	 * @example var m_rgb = require("rgb");
	 *
	 * var new_color = m_rgb.from_values(0.5, 0.5, 0.5);
	 */
	exports.from_values = function(r, g, b) {
	    var dest = new Float32Array(3);
	    dest[0] = r;
	    dest[1] = g;
	    dest[2] = b;
	    return dest;
	};

	/**
	 * Set the components of RGB vector to the given values.
	 *
	 * @param {number} r Red component.
	 * @param {number} g Green component.
	 * @param {number} b Blue component.
	 * @param {RGB} dest Destination RGB vector.
	 * @returns {RGB} Destination RGB vector.
	 * @alias module:rgb.set
	 * @example var m_rgb = require("rgb");
	 *
	 * var new_color = new Float32Array(3);
	 * 
	 * m_rgb.set(0.7, 0.5, 0.1, new_color);
	 */
	exports.set = function(r, g, b, dest) {
	    dest[0] = r;
	    dest[1] = g;
	    dest[2] = b;
	    return dest;
	};

	/**
	 * Convert CSS color components to RGB.
	 * @param {number} css_red CSS color red component (0-255).
	 * @param {number} css_green CSS color green component (0-255).
	 * @param {number} css_blue CSS color blue component (0-255).
	 * @param {RGB} [dest=rgb.create()] Destination RGB vector.
	 * @returns {RGB} Destination RGB vector.
	 * @alias module:rgb.css_to_rgb
	 * @example var m_rgb = require("rgb");
	 *
	 * // #808080 or rgb(128, 128, 128) converted to [0.219, 0.219, 0.219]
	 * var rgb_color = m_rgb.css_to_rgb(128, 128, 128);
	 */
	exports.css_to_rgb = function(css_red, css_green, css_blue, dest) {

	    dest = dest || new Float32Array(3);

	    dest[0] = css_red / 255;
	    dest[1] = css_green / 255;
	    dest[2] = css_blue / 255;
	    m_util.srgb_to_lin(dest, dest);

	    return dest;
	};

	/**
	 * Convert RGB color components to CSS color.
	 * @param {RGB} rgb RGB color vector.
	 * @returns {number[]} Array with CSS colors.
	 * @alias module:rgb.rgb_to_css
	 * @example
	 * var m_rgb = require("rgb");
	 *
	 * var rgb_color = m_rgb.from_values(0.219, 0.219, 0.219);
	 * // [0.219, 0.219, 0.219] converted to [128, 128, 128]
	 * var color = m_rgb.rgb_to_css(rgb_color);
	 */
	exports.rgb_to_css = function(rgb) {

	    var srgb = m_util.lin_to_srgb(rgb, _rgb_tmp);

	    return [Math.round(255*srgb[0]), Math.round(255*srgb[1]), Math.round(255*srgb[2])];
	};

	/**
	 * Convert RGB color components to CSS color hex string.
	 * @param {RGB} rgb RGB color vector.
	 * @returns {string} CSS color hex string.
	 * @alias module:rgb.rgb_to_css_hex
	 * @example
	 * var m_rgb = require("rgb");
	 *
	 * var rgb_color = m_rgb.from_values(0.219, 0.219, 0.219);
	 * // [0.219, 0.219, 0.219] converted to "#808080"
	 * var hex_color = m_rgb.rgb_to_css_hex(rgb_color);
	 */
	exports.rgb_to_css_hex = function(rgb) {

	    var col_to_hex = function(num) {
	        var s = Math.round(255*num).toString(16);
	        return s.length == 1 ? "0" + s : s;
	    };

	    var srgb = m_util.lin_to_srgb(rgb, _rgb_tmp);

	    return "#" + col_to_hex(srgb[0]) + col_to_hex(srgb[1]) + col_to_hex(srgb[2]);
	};

	}

	var rgb_factory = register("rgb", RGB);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * API methods to control textures.
	 * @module textures
	 * @local TexChangingFinishCallback
	 * @see https://www.blend4web.com/doc/en/textures.html
	 */
	function Textures(ns, exports) {

	var m_print    = print_factory(ns);
	var m_scenes   = int_scenes_factory(ns);
	var m_textures = int_textures_factory(ns);
	var m_obj_util = int_obj_util_factory(ns);
	var m_util     = int_util_factory(ns);
	var m_assets   = int_assets_factory(ns);

	/**
	 * Texture changing finish callback.
	 * @callback TexChangingFinishCallback
	 * @param {boolean} success Operation result
	 */

	/**
	 * Play video.
	 * @see https://www.blend4web.com/doc/en/textures.html#video-texture
	 * @method module:textures.play_video
	 * @param {string} texture_name Texture name
	 * @param {number} [data_id=0] ID of loaded data
	 */
	exports.play_video = function(texture_name, data_id) {
	    if (!data_id)
	        data_id = 0;

	    var vtex = m_textures.get_video_texture(texture_name, data_id);
	    if (!vtex) {
	        m_print.error("Texture with name \"" + texture_name + "\" not found!");
	        return;
	    }

	    var scene = m_scenes.get_active();
	    if (scene["b4w_use_nla"] && m_textures.video_allow_nla(vtex)) {
	        m_print.error("NLA texture can't be controlled directly through API.");
	        return;
	    }

	    m_textures.play_video(vtex);
	};

	/**
	 * Pause video.
	 * @method module:textures.pause_video
	 * @param {string} texture_name Texture name
	 * @param {number} [data_id=0] ID of loaded data
	 */
	exports.pause_video = function(texture_name, data_id) {
	    if (!data_id)
	        data_id = 0;

	    var vtex = m_textures.get_video_texture(texture_name, data_id);
	    if (!vtex) {
	        m_print.error("Texture with name \"" + texture_name + "\" not found!");
	        return;
	    }

	    var scene = m_scenes.get_active();
	    if (scene["b4w_use_nla"] && m_textures.video_allow_nla(vtex)) {
	        m_print.error("NLA texture can't be controlled directly through API.");
	        return;
	    }

	    m_textures.pause_video(vtex);
	};

	/**
	 * Reset video (considering frame_offset value from Blender).
	 * @method module:textures.reset_video
	 * @param {string} texture_name Texture name
	 * @param {number} [data_id=0] ID of loaded data
	 */
	exports.reset_video = function(texture_name, data_id) {
	    if (!data_id)
	        data_id = 0;

	    var vtex = m_textures.get_video_texture(texture_name, data_id);
	    if (!vtex) {
	        m_print.error("Texture with name \"" + texture_name + "\" not found!");
	        return;
	    }

	    var scene = m_scenes.get_active();
	    if (scene["b4w_use_nla"] && m_textures.video_allow_nla(vtex)) {
	        m_print.error("NLA texture can't be controlled directly through API.");
	        return;
	    }

	    m_textures.reset_video(vtex);
	};
	/**
	 * Returns canvas texture context.
	 * @see https://www.blend4web.com/doc/en/textures.html#canvas
	 * @method module:textures.get_canvas_ctx
	 * @param {Object3D} obj Object 3D
	 * @param {string} text_name Texture name specified in Blender
	 * @returns {CanvasRenderingContext2D} Canvas texture context
	 * @example 
	 * var m_scenes = require("scenes");
	 * var m_tex = require("textures");
	 *
	 * var cube = m_scenes.get_object_by_name("Cube");
	 * var ctx = m_tex.get_canvas_ctx(cube, "Texture");
	 */
	exports.get_canvas_ctx = function(obj, text_name) {

	    if (!m_obj_util.is_mesh(obj))
	        m_print.error("Object must be type of mesh.");
	    else {
	        var canvas_context = m_textures.get_canvas_context_by_object(obj, text_name);
	        if (canvas_context)
	            return canvas_context;
	        m_print.error("Couldn't find canvas texture with this name: " + text_name);
	    }
	    return null;
	};
	/**
	 * Update canvas texture context.
	 * @see https://www.blend4web.com/doc/en/textures.html#canvas
	 * @method module:textures.update_canvas_ctx
	 * @param {Object3D} obj Object 3D
	 * @param {string} text_name Texture name specified in Blender
	 * @example 
	 * var m_scenes = require("scenes");
	 * var m_tex = require("textures");
	 *
	 * var cube = m_scenes.get_object_by_name("Cube");
	 * m_tex.update_canvas_ctx(cube, "Texture");
	 */
	exports.update_canvas_ctx = function(obj, text_name) {
	    if (!m_obj_util.is_mesh(obj)) {
	        m_print.error("Object must be type of mesh.");
	        return false;
	    }

	    var tex = m_textures.get_texture_by_name(obj, text_name);
	    if (!tex || tex.source != "CANVAS") {
	        m_print.error("Couldn't find canvas texture \"" + text_name + "\" in object \"" + obj.name + "\".");
	        return false;
	    }

	    m_textures.update_texture_canvas(tex);
	    return true;
	};
	/**
	 * Change texture image. Changing video textures is forbidden.
	 * @method module:textures.change_image
	 * @param {Object3D} obj Object 3D
	 * @param {string} text_name Texture name specified in Blender
	 * @param {string} image_path Path to image (relative to the main html file)
	 * @param {TexChangingFinishCallback} [callback] Callback to be executed after changing
	 * @deprecated [17.08] Use {@link module:textures.replace_image} instead
	 * @example 
	 * var m_scenes  = require("scenes");
	 * var m_tex = require("textures");
	 *
	 * var cube = m_scenes.get_object_by_name("Cube");
	 * m_tex.change_image(cube, "Texture", "./test.png");
	 */
	exports.change_image = function(obj, text_name, image_path, callback) {
	    m_print.error_deprecated("change_image", "replace_image");
	    callback = callback || function() {};
	    var tex = m_textures.get_texture_by_name(obj, text_name);
	    if (!tex) {
	        m_print.error("Couldn't find texture \"" + text_name + "\" in object \"" + obj.name + "\".");
	        callback(false);
	        return;
	    }

	    if (tex.is_movie) {
	        m_print.error("Changing video textures is forbidden.");
	        callback(false);
	        return;
	    }

	    var norm_path = m_util.normpath_preserve_protocol(image_path);
	    if (tex.img_full_filepath == norm_path) {
	        callback(true);
	        return;
	    }

	    var asset = {
	        id: image_path,
	        type: m_assets.AT_IMAGE_ELEMENT,
	        url: image_path,
	        request_method: "GET"
	    };

	    var asset_cb = function(data, id, type, url) {
	        if (data) {
	            m_textures.change_image(obj, tex, text_name, data, image_path);
	            callback(true);
	        } else
	            callback(false);
	    };
	    m_assets.enqueue([asset], asset_cb, null, null);
	};

	/**
	 * Change texture image. Changing video textures is forbidden.
	 * @method module:textures.replace_image
	 * @param {Object3D} obj Object 3D
	 * @param {string} text_name Texture name specified in Blender
	 * @param {HTMLElement} image HTML element Image.
	 * @param {TexChangingFinishCallback} [callback] Callback to be executed after changing
	 * @example 
	 * var m_scenes  = require("scenes");
	 * var m_tex = require("textures");
	 *
	 * var cube = m_scenes.get_object_by_name("Cube");
	 * var image = new Image();
	 * image.onload = function() {
	 *     m_tex.replace_image(cube, "Texture", image);
	 * }
	 * image.src = "./test.png";
	 */
	exports.replace_image = function(obj, text_name, image, callback) {
	    callback = callback || function() {};
	    var tex = m_textures.get_texture_by_name(obj, text_name);

	    if (!tex) {
	        m_print.error("Couldn't find texture \"" + text_name + "\" in object \"" + obj.name + "\".");
	        callback(false);
	        return;
	    }

	    if (tex.is_movie) {
	        m_print.error("Changing video textures is forbidden.");
	        callback(false);
	        return;
	    }

	    if (!("src" in image)) {
	        m_print.error("Incorrect image.");
	        callback(false);
	        return;
	    }

	    var image_path = image.src;
	    m_textures.change_image(obj, tex, text_name, image, image_path);
	};
	/**
	 * Get texture names.
	 * @method module:textures.get_texture_names
	 * @param {Object3D} obj Object 3D
	 * @returns {Array} Texture names array
	 */
	exports.get_texture_names = function(obj) {
	    if (!m_obj_util.is_mesh(obj)) {
	        m_print.error("Object must be type of mesh.");
	        return [];
	    } else
	        return m_textures.get_texture_names(obj);
	};

	}

	var textures_factory = register("textures", Textures);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Version API. Allows to query various information about the current release.
	 * @module version
	 */
	function Version(ns, exports) {

	var m_version = int_version_factory(ns);

	/**
	 * Get the version.
	 * The version is an array of the format: [yy, mm] or [yy, mm, bugfix] for "RELEASE"
	 * version or [yy, mm] for "DEBUG" version.
	 * @method module:version.version
	 * @returns {Array} Version: [yy, mm]
	 */
	exports.version = m_version.version;

	/**
	 * Get the version.
	 * The version string has the format: "yy.mm" or "yy.mm.bugfix" for "RELEASE"
	 * version or "yy.mm" for "DEBUG" version.
	 * @method module:version.version_str
	 * @returns {string} Version string
	 */
	exports.version_str = m_version.version_str;

	/**
	 * Get the release type: "DEBUG" or "RELEASE".
	 * @method module:version.type
	 * @returns {string} Release type
	 */
	exports.type = m_version.type;

	/**
	 * Return the build date or the current date for the "DEBUG" version.
	 * @method module:version.date
	 * @returns {Date} Date
	 */
	exports.date = m_version.date;

	/**
	 * Return the build date or the current date for the "DEBUG" version.
	 * @method module:version.date_str
	 * @returns {string} Date string in the format: "dd.mm.yyyy hh.mm.ss"
	 */
	exports.date_str = m_version.date_str;

	/**
	 * Returns a string representing the application version based on build time. 
	 * Returns the current timestamp in the "DEBUG" mode.
	 * @method module:version.get_build_version
	 * @returns {string} Build version.
	 */
	exports.get_build_version = m_version.get_build_version;

	}

	var version_factory = register("version", Version);

	/**
	 * Copyright (C) 2014-2017 Triumph LLC
	 * 
	 * This program is free software: you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation, either version 3 of the License, or
	 * (at your option) any later version.
	 * 
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 * 
	 * You should have received a copy of the GNU General Public License
	 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
	 */
	"use strict";

	/**
	 * Auto-generated GLSL parser
	 */
	function GPP_parser(ps, exports) {

	exports.parser = (function() {
	  /*
	   * Generated by PEG.js 0.8.0.
	   *
	   * http://pegjs.org/
	   */

	  function peg$subclass(child, parent) {
	    function ctor() { this.constructor = child; }
	    ctor.prototype = parent.prototype;
	    child.prototype = new ctor();
	  }

	  function peg$SyntaxError(message, expected, found, offset, line, column) {
	    this.message  = message;
	    this.expected = expected;
	    this.found    = found;
	    this.offset   = offset;
	    this.line     = line;
	    this.column   = column;

	    this.name     = "SyntaxError";
	  }

	  peg$subclass(peg$SyntaxError, Error);

	  function peg$parse(input) {
	    var options = arguments.length > 1 ? arguments[1] : {},
	        parser  = this,

	        peg$FAILED = {},

	        peg$startRuleFunctions = { start: peg$parsestart },
	        peg$startRuleFunction  = peg$parsestart,

	        peg$c0 = function(group) { return group; },
	        peg$c1 = function(parts) {
	              return {
	                TYPE: "grp",
	                PARTS: parts !== null ? parts : []
	              };
	            },
	        peg$c2 = function(head, tail) {
	              var result = [head];
	              for (var i = 0; i < tail.length; i++) {
	                result.push(tail[i][1]);
	              }
	              return result;
	            },
	        peg$c3 = function(ifgroup, elifgroups, elsegroup) {
	              var parts = [ifgroup];

	              for (var i = 0; i < elifgroups.length; i++)
	                parts.push(elifgroups[i]);

	              if (elsegroup !== null)
	                parts.push(elsegroup);

	              return {
	                TYPE: "cond",
	                PARTS:parts
	              }
	            },
	        peg$c4 = "#",
	        peg$c5 = { type: "literal", value: "#", description: "\"#\"" },
	        peg$c6 = "if",
	        peg$c7 = { type: "literal", value: "if", description: "\"if\"" },
	        peg$c8 = function(expression, group) {
	              return {
	                TYPE: "if",
	                EXPRESSION: expression,
	                GROUP: group
	              };
	            },
	        peg$c9 = "ifdef",
	        peg$c10 = { type: "literal", value: "ifdef", description: "\"ifdef\"" },
	        peg$c11 = function(name, group) {
	              return {
	                TYPE: "ifdef",
	                NAME: name,
	                GROUP: group
	              };
	            },
	        peg$c12 = "ifndef",
	        peg$c13 = { type: "literal", value: "ifndef", description: "\"ifndef\"" },
	        peg$c14 = function(name, group) {
	              return {
	                TYPE: "ifndef",
	                NAME: name,
	                GROUP: group
	              };
	            },
	        peg$c15 = "elif",
	        peg$c16 = { type: "literal", value: "elif", description: "\"elif\"" },
	        peg$c17 = function(expression, group) {
	              return {
	                TYPE: "elif",
	                EXPRESSION: expression,
	                GROUP: group
	              };
	            },
	        peg$c18 = "else",
	        peg$c19 = { type: "literal", value: "else", description: "\"else\"" },
	        peg$c20 = function(group) {
	              return {
	                TYPE: "else",
	                GROUP: group
	              };
	            },
	        peg$c21 = "endif",
	        peg$c22 = { type: "literal", value: "endif", description: "\"endif\"" },
	        peg$c23 = "include",
	        peg$c24 = { type: "literal", value: "include", description: "\"include\"" },
	        peg$c25 = function(file) {
	              return {
	                TYPE: "include",
	                FILE: file
	              };
	            },
	        peg$c26 = "define",
	        peg$c27 = { type: "literal", value: "define", description: "\"define\"" },
	        peg$c28 = "var",
	        peg$c29 = { type: "literal", value: "var", description: "\"var\"" },
	        peg$c30 = function(type, name, toks) {
	              var tokens = [];

	              if (toks === null) 
	                tokens.push("");
	              else
	                for (var i = 0; i < toks[1].length; i++)
	                  tokens.push(toks[1][i]);

	              return {
	                TYPE: type,
	                NAME: name,
	                TOKENS: tokens
	              };
	            },
	        peg$c31 = "error",
	        peg$c32 = { type: "literal", value: "error", description: "\"error\"" },
	        peg$c33 = function(toks) {
	              var tokens = [];

	              if (toks !== null)
	                for (var i = 0; i < toks[1].length; i++)
	                  tokens.push(toks[1][i]);

	              return {
	                TYPE: "error",
	                TOKENS: tokens
	              };
	            },
	        peg$c34 = "line",
	        peg$c35 = { type: "literal", value: "line", description: "\"line\"" },
	        peg$c36 = function(tokens) {
	              return {
	                TYPE: "line",
	                TOKENS: tokens
	              };
	            },
	        peg$c37 = "pragma",
	        peg$c38 = { type: "literal", value: "pragma", description: "\"pragma\"" },
	        peg$c39 = function(name, tokens) {
	              return {
	                TYPE: "pragma",
	                NAME: name,
	                TOKENS: tokens
	              };
	            },
	        peg$c40 = "undef",
	        peg$c41 = { type: "literal", value: "undef", description: "\"undef\"" },
	        peg$c42 = function(name) {
	              return {
	                TYPE: "undef",
	                NAME: name
	              };
	            },
	        peg$c43 = "warning",
	        peg$c44 = { type: "literal", value: "warning", description: "\"warning\"" },
	        peg$c45 = function(toks) {
	              var tokens = [];

	              if (toks !== null)
	                for (var i = 0; i < toks[1].length; i++)
	                  tokens.push(toks[1][i]);

	              return {
	                TYPE: "warning",
	                TOKENS: tokens
	              };
	            },
	        peg$c46 = "extension",
	        peg$c47 = { type: "literal", value: "extension", description: "\"extension\"" },
	        peg$c48 = function(toks) {
	              var tokens = [];

	              if (toks !== null)
	                for (var i = 0; i < toks[1].length; i++)
	                  tokens.push(toks[1][i]);

	            return {
	              TYPE: "extension",
	              TOKENS: tokens
	            }
	          },
	        peg$c49 = "version",
	        peg$c50 = { type: "literal", value: "version", description: "\"version\"" },
	        peg$c51 = function(version) {
	              var tokens = [];
	              if (version !== null)
	                tokens.push(version);
	            return {
	              TYPE: "version",
	              TOKENS: tokens
	            }
	          },
	        peg$c52 = function() {
	              return {
	                TYPE: "#"
	              };
	            },
	        peg$c53 = function(nodegroup) {
	              return nodegroup;
	            },
	        peg$c54 = "node",
	        peg$c55 = { type: "literal", value: "node", description: "\"node\"" },
	        peg$c56 = function(name, vars, decl, stat) {

	              var node_vars = [];
	              for (var i = 0; i < vars.length; i++)
	                node_vars.push(vars[i][0]);

	              var declarations = [];
	              for (var i = 0; i < decl.length; i++)
	                declarations.push(decl[i][0]);

	              var statements = [];
	              for (var i = 0; i < stat.length; i++)
	                statements.push(stat[i][0]);

	              return {
	                TYPE: "node",
	                NAME: name,
	                NODE_VARS: node_vars,
	                DECLARATIONS: declarations,
	                STATEMENTS: statements
	              };
	            },
	        peg$c57 = "endnode",
	        peg$c58 = { type: "literal", value: "endnode", description: "\"endnode\"" },
	        peg$c59 = "node_var",
	        peg$c60 = { type: "literal", value: "node_var", description: "\"node_var\"" },
	        peg$c61 = function(name, toks) {
	              var tokens = [];

	              if (toks === null) 
	                tokens.push("");
	              else
	                for (var i = 0; i < toks[1].length; i++)
	                  tokens.push(toks[1][i]);

	              return {
	                TYPE: "node_var",
	                NAME: name,
	                TOKENS: tokens
	              };
	            },
	        peg$c62 = function(ifgroup, elifgroups, elsegroup) {
	              var parts = [ifgroup];

	              for (var i = 0; i < elifgroups.length; i++)
	                parts.push(elifgroups[i]);

	              if (elsegroup !== null)
	                parts.push(elsegroup);

	              return {
	                TYPE: "node_cond",
	                PARTS: parts
	              }
	            },
	        peg$c63 = "node_if",
	        peg$c64 = { type: "literal", value: "node_if", description: "\"node_if\"" },
	        peg$c65 = function(expression, stat) {
	              var statements = [];
	              for (var i = 0; i < stat.length; i++)
	                statements.push(stat[i][0]);

	              return {
	                TYPE: "node_if",
	                EXPRESSION: expression,
	                STATEMENTS: statements
	              };
	            },
	        peg$c66 = "node_ifdef",
	        peg$c67 = { type: "literal", value: "node_ifdef", description: "\"node_ifdef\"" },
	        peg$c68 = function(name, stat) {
	              var statements = [];
	              for (var i = 0; i < stat.length; i++)
	                statements.push(stat[i][0]);

	              return {
	                TYPE: "node_ifdef",
	                NAME: name,
	                STATEMENTS: statements
	              };
	            },
	        peg$c69 = "node_ifndef",
	        peg$c70 = { type: "literal", value: "node_ifndef", description: "\"node_ifndef\"" },
	        peg$c71 = function(name, stat) {
	              var statements = [];
	              for (var i = 0; i < stat.length; i++)
	                statements.push(stat[i][0]);

	              return {
	                TYPE: "node_ifndef",
	                NAME: name,
	                STATEMENTS: statements
	              };
	            },
	        peg$c72 = "node_elif",
	        peg$c73 = { type: "literal", value: "node_elif", description: "\"node_elif\"" },
	        peg$c74 = function(expression, stat) {
	              var statements = [];
	              for (var i = 0; i < stat.length; i++)
	                statements.push(stat[i][0]);

	              return {
	                TYPE: "node_elif",
	                EXPRESSION: expression,
	                STATEMENTS: statements
	              };
	            },
	        peg$c75 = "node_else",
	        peg$c76 = { type: "literal", value: "node_else", description: "\"node_else\"" },
	        peg$c77 = function(stat) {
	              var statements = [];
	              for (var i = 0; i < stat.length; i++)
	                statements.push(stat[i][0]);

	              return {
	                TYPE: "node_else",
	                STATEMENTS: statements
	              };
	            },
	        peg$c78 = "node_endif",
	        peg$c79 = { type: "literal", value: "node_endif", description: "\"node_endif\"" },
	        peg$c80 = "node_in",
	        peg$c81 = { type: "literal", value: "node_in", description: "\"node_in\"" },
	        peg$c82 = "optional",
	        peg$c83 = { type: "literal", value: "optional", description: "\"optional\"" },
	        peg$c84 = function(opt, toks) {
	              var tokens = [];

	              if (toks !== null)
	                for (var i = 0; i < toks[1].length; i++)
	                  tokens.push(toks[1][i]);

	              var last = tokens.pop();

	              return {
	                TYPE: "node_in",
	                NAME: last,
	                QUALIFIER:tokens,
	                IS_OPTIONAL: Boolean(opt)
	              };
	            },
	        peg$c85 = "node_out",
	        peg$c86 = { type: "literal", value: "node_out", description: "\"node_out\"" },
	        peg$c87 = function(opt, toks) {
	              var tokens = [];

	              if (toks !== null)
	                for (var i = 0; i < toks[1].length; i++)
	                  tokens.push(toks[1][i]);

	              var last = tokens.pop();

	              return {
	                TYPE: "node_out",
	                NAME: last,
	                QUALIFIER:tokens,
	                IS_OPTIONAL: Boolean(opt)
	              };
	            },
	        peg$c88 = "node_param",
	        peg$c89 = { type: "literal", value: "node_param", description: "\"node_param\"" },
	        peg$c90 = function(opt, toks) {
	              var tokens = [];

	              if (toks !== null)
	                for (var i = 0; i < toks[1].length; i++)
	                  tokens.push(toks[1][i]);

	              var last = tokens.pop();

	              return {
	                TYPE: "node_param",
	                NAME: last,
	                QUALIFIER: tokens,
	                IS_OPTIONAL: Boolean(opt)
	              };
	            },
	        peg$c91 = "nodes_global",
	        peg$c92 = { type: "literal", value: "nodes_global", description: "\"nodes_global\"" },
	        peg$c93 = function() {
	              return {
	                TYPE: "nodes_global"
	              }
	            },
	        peg$c94 = "nodes_main",
	        peg$c95 = { type: "literal", value: "nodes_main", description: "\"nodes_main\"" },
	        peg$c96 = function() {
	              return {
	                TYPE: "nodes_main"
	              }
	            },
	        peg$c97 = function(tokens) {
	              return {
	                TYPE: "txt",
	                TOKENS: tokens
	              }
	            },
	        peg$c98 = ",",
	        peg$c99 = { type: "literal", value: ",", description: "\",\"" },
	        peg$c100 = function(head, tail) {
	              if (tail.length == 0)
	                return head;
	              else
	                return tail[tail.length-1];
	            },
	        peg$c101 = "?",
	        peg$c102 = { type: "literal", value: "?", description: "\"?\"" },
	        peg$c103 = ":",
	        peg$c104 = { type: "literal", value: ":", description: "\":\"" },
	        peg$c105 = function(condition, trueExpression, falseExpression) {
	              var result = condition;
	              var op = {
	                TYPE: "conditional_expr",
	                PLACES: 3
	              };
	              result.push.apply(result, trueExpression);
	              result.push.apply(result, falseExpression);
	              result.push(op);
	              return result;
	            },
	        peg$c106 = function(head, tail) {
	              var result = head;
	              if (tail.length) {
	                var op = {
	                  TYPE: "logical_or_expr",
	                  PLACES: tail.length + 1
	                };
	                for (var i = 0; i < tail.length; i++)
	                  result.push.apply(result, tail[i][3]);
	                result.push(op);
	              }
	              return result;
	            },
	        peg$c107 = function(head, tail) {
	              var result = head;
	              if (tail.length) {
	                var op = {
	                  TYPE: "logical_and_expr",
	                  PLACES: tail.length + 1
	                };
	                for (var i = 0; i < tail.length; i++)
	                  result.push.apply(result, tail[i][3]);
	                result.push(op);
	              }
	              return result;
	            },
	        peg$c108 = function(head, tail) {
	              var result = head;
	              if (tail.length) {
	                var op = {
	                  TYPE: "logical_bitor_expr",
	                  PLACES: tail.length + 1
	                };
	                for (var i = 0; i < tail.length; i++)
	                  result.push.apply(result, tail[i][3]);
	                result.push(op);
	              }
	              return result;
	            },
	        peg$c109 = function(head, tail) {
	              var result = head;
	              if (tail.length) {
	                var op = {
	                  TYPE: "logical_bitxor_expr",
	                  PLACES: tail.length + 1
	                };
	                for (var i = 0; i < tail.length; i++)
	                  result.push.apply(result, tail[i][3]);
	                result.push(op);
	              }
	              return result;
	            },
	        peg$c110 = function(head, tail) {
	              var result = head;
	              if (tail.length) {
	                var op = {
	                  TYPE: "logical_bitand_expr",
	                  PLACES: tail.length + 1
	                };
	                for (var i = 0; i < tail.length; i++)
	                  result.push.apply(result, tail[i][3]);
	                result.push(op);
	              }
	              return result;
	            },
	        peg$c111 = function(head, tail) {
	              var result = head;
	              for (var i = 0; i < tail.length; i++) {
	                switch (tail[i][1]) {
	                case "==":
	                  var op = {
	                    TYPE: "equal_expr",
	                    PLACES: 2
	                  };
	                  result.push.apply(result, tail[i][3]);
	                  result.push(op);
	                  break;
	                case "!=":
	                  var op = {
	                    TYPE: "non_equal_expr",
	                    PLACES: 2
	                  };
	                  result.push.apply(result, tail[i][3]);
	                  result.push(op);
	                  break;
	                }
	              }
	              return result;
	            },
	        peg$c112 = function(head, tail) {
	              var result = head;
	              for (var i = 0; i < tail.length; i++) {
	                switch (tail[i][1]) {
	                case "<=":
	                  var op = {
	                    TYPE: "le_expr",
	                    PLACES: 2
	                  };
	                  result.push.apply(result, tail[i][3]);
	                  result.push(op);
	                  break;
	                case ">=":
	                  var op = {
	                    TYPE: "ge_expr",
	                    PLACES: 2
	                  };
	                  result.push.apply(result, tail[i][3]);
	                  result.push(op);
	                  break;
	                case "<":
	                  var op = {
	                    TYPE: "l_expr",
	                    PLACES: 2
	                  };
	                  result.push.apply(result, tail[i][3]);
	                  result.push(op);
	                  break;
	                case ">":
	                  var op = {
	                    TYPE: "g_expr",
	                    PLACES: 2
	                  };
	                  result.push.apply(result, tail[i][3]);
	                  result.push(op);
	                  break;
	                }
	              }
	              return result;
	            },
	        peg$c113 = function(head, tail) {
	              var result = head;
	              for (var i = 0; i < tail.length; i++) {
	                switch (tail[i][1]) {
	                case "<<":
	                  var op = {
	                    TYPE: "left_shift_expr",
	                    PLACES: 2
	                  };
	                  result.push.apply(result, tail[i][3]);
	                  result.push(op);
	                  break;
	                case ">>":
	                  var op = {
	                    TYPE: "right_shift_expr",
	                    PLACES: 2
	                  };
	                  result.push.apply(result, tail[i][3]);
	                  result.push(op);
	                  break;
	                }
	              }
	              return result;
	            },
	        peg$c114 = function(head, tail) {
	              var result = head;
	              for (var i = 0; i < tail.length; i++) {
	                switch (tail[i][1]) {
	                case "+":
	                  var op = {
	                    TYPE: "add_expr",
	                    PLACES: 2
	                  };
	                  result.push.apply(result, tail[i][3]);
	                  result.push(op);
	                  break;
	                case "-":
	                  var op = {
	                    TYPE: "sub_expr",
	                    PLACES: 2
	                  };
	                  result.push.apply(result, tail[i][3]);
	                  result.push(op);
	                  break;
	                }
	              }
	              return result;
	            },
	        peg$c115 = function(head, tail) {
	              var result = head;
	              for (var i = 0; i < tail.length; i++) {
	                switch (tail[i][1]) {
	                case "*":
	                  var op = {
	                    TYPE: "mul_expr",
	                    PLACES: 2
	                  };
	                  result.push.apply(result, tail[i][3]);
	                  result.push(op);
	                  break;
	                case "/":
	                  var op = {
	                    TYPE: "div_expr",
	                    PLACES: 2
	                  };
	                  result.push.apply(result, tail[i][3]);
	                  result.push(op);
	                  break;
	                case "%":
	                  var op = {
	                    TYPE: "mod_expr",
	                    PLACES: 2
	                  };
	                  result.push.apply(result, tail[i][3]);
	                  result.push(op);
	                  break;
	                }
	              }
	              return result;
	            },
	        peg$c116 = "defined",
	        peg$c117 = { type: "literal", value: "defined", description: "\"defined\"" },
	        peg$c118 = function(expression) {
	              return expression;
	            },
	        peg$c119 = function(operator, expression) {
	              var result = expression;
	              switch (operator) {
	                case "++":
	                  var op = {
	                    TYPE: "pre_inc_expr",
	                    PLACES: 1
	                  };
	                  result.push(op);
	                  break;
	                case "--":
	                  var op = {
	                    TYPE: "pre_dec_expr",
	                    PLACES: 1
	                  };
	                  result.push(op);
	                  break;
	                case "+":
	                  var op = {
	                    TYPE: "positive_expr",
	                    PLACES: 1
	                  };
	                  result.push(op);
	                  break;
	                case "-":
	                  var op = {
	                    TYPE: "negative_expr",
	                    PLACES: 1
	                  };
	                  result.push(op);
	                  break;
	                case "~":
	                  var op = {
	                    TYPE: "one_compl_expr",
	                    PLACES: 1
	                  };
	                  result.push(op);
	                  break;
	                case "!":
	                  var op = {
	                    TYPE: "logic_negative_expr",
	                    PLACES: 1
	                  };
	                  result.push(op);
	                  break;
	              }
	              return result;
	            },
	        peg$c120 = function(expression, operator) {
	              var result = expression;
	              switch (operator) {
	                case "++":
	                  var op = {
	                    TYPE: "post_inc_expr",
	                    PLACES: 1
	                  };
	                  result.push(op);
	                  break;
	                case "--":
	                  var op = {
	                    TYPE: "post_dec_expr",
	                    PLACES: 1
	                  };
	                  result.push(op);
	                  break;
	              }
	              return result;
	            },
	        peg$c121 = function(number) { return [number]; },
	        peg$c122 = function(identifier) { return [identifier]; },
	        peg$c123 = "(",
	        peg$c124 = { type: "literal", value: "(", description: "\"(\"" },
	        peg$c125 = ")",
	        peg$c126 = { type: "literal", value: ")", description: "\")\"" },
	        peg$c127 = function(expression) { return expression; },
	        peg$c128 = function() { return 1; },
	        peg$c129 = { type: "other", description: "number" },
	        peg$c130 = function(literal) {
	              return literal;
	            },
	        peg$c131 = function(parts) { return parseInt(parts); },
	        peg$c132 = { type: "other", description: "identifier" },
	        peg$c133 = function(name) { return name; },
	        peg$c134 = "++",
	        peg$c135 = { type: "literal", value: "++", description: "\"++\"" },
	        peg$c136 = "--",
	        peg$c137 = { type: "literal", value: "--", description: "\"--\"" },
	        peg$c138 = "+",
	        peg$c139 = { type: "literal", value: "+", description: "\"+\"" },
	        peg$c140 = "-",
	        peg$c141 = { type: "literal", value: "-", description: "\"-\"" },
	        peg$c142 = "~",
	        peg$c143 = { type: "literal", value: "~", description: "\"~\"" },
	        peg$c144 = "!",
	        peg$c145 = { type: "literal", value: "!", description: "\"!\"" },
	        peg$c146 = "*",
	        peg$c147 = { type: "literal", value: "*", description: "\"*\"" },
	        peg$c148 = "/",
	        peg$c149 = { type: "literal", value: "/", description: "\"/\"" },
	        peg$c150 = "%",
	        peg$c151 = { type: "literal", value: "%", description: "\"%\"" },
	        peg$c152 = "=",
	        peg$c153 = { type: "literal", value: "=", description: "\"=\"" },
	        peg$c154 = function(operator) { return operator; },
	        peg$c155 = function() { return "+"; },
	        peg$c156 = function() { return "-"; },
	        peg$c157 = "<<",
	        peg$c158 = { type: "literal", value: "<<", description: "\"<<\"" },
	        peg$c159 = ">>",
	        peg$c160 = { type: "literal", value: ">>", description: "\">>\"" },
	        peg$c161 = "<=",
	        peg$c162 = { type: "literal", value: "<=", description: "\"<=\"" },
	        peg$c163 = ">=",
	        peg$c164 = { type: "literal", value: ">=", description: "\">=\"" },
	        peg$c165 = "<",
	        peg$c166 = { type: "literal", value: "<", description: "\"<\"" },
	        peg$c167 = ">",
	        peg$c168 = { type: "literal", value: ">", description: "\">\"" },
	        peg$c169 = "==",
	        peg$c170 = { type: "literal", value: "==", description: "\"==\"" },
	        peg$c171 = "!=",
	        peg$c172 = { type: "literal", value: "!=", description: "\"!=\"" },
	        peg$c173 = "&",
	        peg$c174 = { type: "literal", value: "&", description: "\"&\"" },
	        peg$c175 = function() { return "&"; },
	        peg$c176 = "^",
	        peg$c177 = { type: "literal", value: "^", description: "\"^\"" },
	        peg$c178 = function() { return "^"; },
	        peg$c179 = "|",
	        peg$c180 = { type: "literal", value: "|", description: "\"|\"" },
	        peg$c181 = function() { return "|"; },
	        peg$c182 = "&&",
	        peg$c183 = { type: "literal", value: "&&", description: "\"&&\"" },
	        peg$c184 = function() { return "&&"; },
	        peg$c185 = "||",
	        peg$c186 = { type: "literal", value: "||", description: "\"||\"" },
	        peg$c187 = function() { return "||"; },
	        peg$c188 = "\"",
	        peg$c189 = { type: "literal", value: "\"", description: "\"\\\"\"" },
	        peg$c190 = function(chars) {
	              var line = "";
	              for (var i = 0; i < chars.length; i++) {
	                line += chars[i][1];
	              }
	              return line;
	            },
	        peg$c191 = function(start, parts) {
	              return start + parts.join("");
	            },
	        peg$c192 = "$",
	        peg$c193 = { type: "literal", value: "$", description: "\"$\"" },
	        peg$c194 = "_",
	        peg$c195 = { type: "literal", value: "_", description: "\"_\"" },
	        peg$c196 = /^[a-zA-Z]/,
	        peg$c197 = { type: "class", value: "[a-zA-Z]", description: "[a-zA-Z]" },
	        peg$c198 = "#define",
	        peg$c199 = { type: "literal", value: "#define", description: "\"#define\"" },
	        peg$c200 = "#elif",
	        peg$c201 = { type: "literal", value: "#elif", description: "\"#elif\"" },
	        peg$c202 = "#else",
	        peg$c203 = { type: "literal", value: "#else", description: "\"#else\"" },
	        peg$c204 = "#endif",
	        peg$c205 = { type: "literal", value: "#endif", description: "\"#endif\"" },
	        peg$c206 = "#error",
	        peg$c207 = { type: "literal", value: "#error", description: "\"#error\"" },
	        peg$c208 = "#if",
	        peg$c209 = { type: "literal", value: "#if", description: "\"#if\"" },
	        peg$c210 = "#ifdef",
	        peg$c211 = { type: "literal", value: "#ifdef", description: "\"#ifdef\"" },
	        peg$c212 = "#ifndef",
	        peg$c213 = { type: "literal", value: "#ifndef", description: "\"#ifndef\"" },
	        peg$c214 = "#include",
	        peg$c215 = { type: "literal", value: "#include", description: "\"#include\"" },
	        peg$c216 = "#line",
	        peg$c217 = { type: "literal", value: "#line", description: "\"#line\"" },
	        peg$c218 = "#pragma",
	        peg$c219 = { type: "literal", value: "#pragma", description: "\"#pragma\"" },
	        peg$c220 = "#warning",
	        peg$c221 = { type: "literal", value: "#warning", description: "\"#warning\"" },
	        peg$c222 = "#version",
	        peg$c223 = { type: "literal", value: "#version", description: "\"#version\"" },
	        peg$c224 = ".",
	        peg$c225 = { type: "literal", value: ".", description: "\".\"" },
	        peg$c226 = function(parts) {
	              
	            },
	        peg$c227 = function(parts) {
	              
	            },
	        peg$c228 = function(parts) {
	              
	            },
	        peg$c229 = "0",
	        peg$c230 = { type: "literal", value: "0", description: "\"0\"" },
	        peg$c231 = /^[xX]/,
	        peg$c232 = { type: "class", value: "[xX]", description: "[xX]" },
	        peg$c233 = function(digits) {
	              
	            },
	        peg$c234 = function(parts) {
	              return parts;
	            },
	        peg$c235 = function(parts) { return parts; },
	        peg$c236 = function(digits) { return String(parseInt("0x" + digits)); },
	        peg$c237 = /^[0-9]/,
	        peg$c238 = { type: "class", value: "[0-9]", description: "[0-9]" },
	        peg$c239 = /^[1-9]/,
	        peg$c240 = { type: "class", value: "[1-9]", description: "[1-9]" },
	        peg$c241 = /^[eE]/,
	        peg$c242 = { type: "class", value: "[eE]", description: "[eE]" },
	        peg$c243 = /^[\-+]/,
	        peg$c244 = { type: "class", value: "[-+]", description: "[-+]" },
	        peg$c245 = /^[0-9a-fA-F]/,
	        peg$c246 = { type: "class", value: "[0-9a-fA-F]", description: "[0-9a-fA-F]" },
	        peg$c247 = { type: "other", description: "string" },
	        peg$c248 = "'",
	        peg$c249 = { type: "literal", value: "'", description: "\"'\"" },
	        peg$c250 = function(parts) {
	              return "\"" + parts[1] + "\"";
	            },
	        peg$c251 = function(chars) { return chars.join(""); },
	        peg$c252 = "\\",
	        peg$c253 = { type: "literal", value: "\\", description: "\"\\\\\"" },
	        peg$c254 = function(char_) { return char_;     },
	        peg$c255 = function(sequence) { return sequence;  },
	        peg$c256 = function(sequence) { return sequence; },
	        peg$c257 = function() { return "\0"; },
	        peg$c258 = /^['"\\bfnrtv]/,
	        peg$c259 = { type: "class", value: "['\"\\\\bfnrtv]", description: "['\"\\\\bfnrtv]" },
	        peg$c260 = function(char_) {
	              return char_
	                .replace("b", "\b")
	                .replace("f", "\f")
	                .replace("n", "\n")
	                .replace("r", "\r")
	                .replace("t", "\t")
	                .replace("v", "\x0B") // IE does not recognize "\v".
	            },
	        peg$c261 = function(char_) { return char_; },
	        peg$c262 = "x",
	        peg$c263 = { type: "literal", value: "x", description: "\"x\"" },
	        peg$c264 = "u",
	        peg$c265 = { type: "literal", value: "u", description: "\"u\"" },
	        peg$c266 = function(digits) {
	              return String.fromCharCode(parseInt("0x" + digits));
	            },
	        peg$c267 = { type: "other", description: "punctuation" },
	        peg$c268 = "+=",
	        peg$c269 = { type: "literal", value: "+=", description: "\"+=\"" },
	        peg$c270 = "-=",
	        peg$c271 = { type: "literal", value: "-=", description: "\"-=\"" },
	        peg$c272 = "*=",
	        peg$c273 = { type: "literal", value: "*=", description: "\"*=\"" },
	        peg$c274 = "/=",
	        peg$c275 = { type: "literal", value: "/=", description: "\"/=\"" },
	        peg$c276 = "%=",
	        peg$c277 = { type: "literal", value: "%=", description: "\"%=\"" },
	        peg$c278 = "^=",
	        peg$c279 = { type: "literal", value: "^=", description: "\"^=\"" },
	        peg$c280 = "&=",
	        peg$c281 = { type: "literal", value: "&=", description: "\"&=\"" },
	        peg$c282 = "|=",
	        peg$c283 = { type: "literal", value: "|=", description: "\"|=\"" },
	        peg$c284 = "<<=",
	        peg$c285 = { type: "literal", value: "<<=", description: "\"<<=\"" },
	        peg$c286 = ">>=",
	        peg$c287 = { type: "literal", value: ">>=", description: "\">>=\"" },
	        peg$c288 = "{",
	        peg$c289 = { type: "literal", value: "{", description: "\"{\"" },
	        peg$c290 = "}",
	        peg$c291 = { type: "literal", value: "}", description: "\"}\"" },
	        peg$c292 = "[",
	        peg$c293 = { type: "literal", value: "[", description: "\"[\"" },
	        peg$c294 = "]",
	        peg$c295 = { type: "literal", value: "]", description: "\"]\"" },
	        peg$c296 = ";",
	        peg$c297 = { type: "literal", value: ";", description: "\";\"" },
	        peg$c298 = function(head, tail) {
	              
	            },
	        peg$c299 = { type: "other", description: "whitespace" },
	        peg$c300 = /^[\t\x0B\f ]/,
	        peg$c301 = { type: "class", value: "[\\t\\v\\f ]", description: "[\\t\\v\\f ]" },
	        peg$c302 = /^[\n\r]/,
	        peg$c303 = { type: "class", value: "[\\n\\r]", description: "[\\n\\r]" },
	        peg$c304 = { type: "other", description: "end of line" },
	        peg$c305 = "\n",
	        peg$c306 = { type: "literal", value: "\n", description: "\"\\n\"" },
	        peg$c307 = "\r\n",
	        peg$c308 = { type: "literal", value: "\r\n", description: "\"\\r\\n\"" },
	        peg$c309 = "\r",
	        peg$c310 = { type: "literal", value: "\r", description: "\"\\r\"" },
	        peg$c311 = { type: "other", description: "comment" },
	        peg$c312 = "/*",
	        peg$c313 = { type: "literal", value: "/*", description: "\"/*\"" },
	        peg$c314 = "*/",
	        peg$c315 = { type: "literal", value: "*/", description: "\"*/\"" },
	        peg$c316 = "//",
	        peg$c317 = { type: "literal", value: "//", description: "\"//\"" },
	        peg$c318 = { type: "any", description: "any character" },

	        peg$currPos          = 0,
	        peg$reportedPos      = 0,
	        peg$cachedPos        = 0,
	        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },
	        peg$maxFailPos       = 0,
	        peg$maxFailExpected  = [],
	        peg$silentFails      = 0,

	        peg$result;

	    if ("startRule" in options) {
	      if (!(options.startRule in peg$startRuleFunctions)) {
	        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
	      }

	      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
	    }

	    function peg$computePosDetails(pos) {
	      function advance(details, startPos, endPos) {
	        var p, ch;

	        for (p = startPos; p < endPos; p++) {
	          ch = input.charAt(p);
	          if (ch === "\n") {
	            if (!details.seenCR) { details.line++; }
	            details.column = 1;
	            details.seenCR = false;
	          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
	            details.line++;
	            details.column = 1;
	            details.seenCR = true;
	          } else {
	            details.column++;
	            details.seenCR = false;
	          }
	        }
	      }

	      if (peg$cachedPos !== pos) {
	        if (peg$cachedPos > pos) {
	          peg$cachedPos = 0;
	          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
	        }
	        advance(peg$cachedPosDetails, peg$cachedPos, pos);
	        peg$cachedPos = pos;
	      }

	      return peg$cachedPosDetails;
	    }

	    function peg$fail(expected) {
	      if (peg$currPos < peg$maxFailPos) { return; }

	      if (peg$currPos > peg$maxFailPos) {
	        peg$maxFailPos = peg$currPos;
	        peg$maxFailExpected = [];
	      }

	      peg$maxFailExpected.push(expected);
	    }

	    function peg$buildException(message, expected, pos) {
	      function cleanupExpected(expected) {
	        var i = 1;

	        expected.sort(function(a, b) {
	          if (a.description < b.description) {
	            return -1;
	          } else if (a.description > b.description) {
	            return 1;
	          } else {
	            return 0;
	          }
	        });

	        while (i < expected.length) {
	          if (expected[i - 1] === expected[i]) {
	            expected.splice(i, 1);
	          } else {
	            i++;
	          }
	        }
	      }

	      function buildMessage(expected, found) {
	        function stringEscape(s) {
	          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }

	          return s
	            .replace(/\\/g,   '\\\\')
	            .replace(/"/g,    '\\"')
	            .replace(/\x08/g, '\\b')
	            .replace(/\t/g,   '\\t')
	            .replace(/\n/g,   '\\n')
	            .replace(/\f/g,   '\\f')
	            .replace(/\r/g,   '\\r')
	            .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) { return '\\x0' + hex(ch); })
	            .replace(/[\x10-\x1F\x80-\xFF]/g,    function(ch) { return '\\x'  + hex(ch); })
	            .replace(/[\u0100-\u0FFF]/g,         function(ch) { return '\\u0' + hex(ch); })
	            .replace(/[\u1000-\uFFFF]/g,         function(ch) { return '\\u'  + hex(ch); });
	        }

	        var expectedDescs = new Array(expected.length),
	            expectedDesc, foundDesc, i;

	        for (i = 0; i < expected.length; i++) {
	          expectedDescs[i] = expected[i].description;
	        }

	        expectedDesc = expected.length > 1
	          ? expectedDescs.slice(0, -1).join(", ")
	              + " or "
	              + expectedDescs[expected.length - 1]
	          : expectedDescs[0];

	        foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";

	        return "Expected " + expectedDesc + " but " + foundDesc + " found.";
	      }

	      var posDetails = peg$computePosDetails(pos),
	          found      = pos < input.length ? input.charAt(pos) : null;

	      if (expected !== null) {
	        cleanupExpected(expected);
	      }

	      return new peg$SyntaxError(
	        message !== null ? message : buildMessage(expected, found),
	        expected,
	        found,
	        pos,
	        posDetails.line,
	        posDetails.column
	      );
	    }

	    function peg$parsestart() {
	      var s0, s1, s2, s3;

	      s0 = peg$currPos;
	      s1 = peg$parse__();
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parseGroup();
	        if (s2 !== peg$FAILED) {
	          s3 = peg$parse__();
	          if (s3 !== peg$FAILED) {
	            s1 = peg$c0(s2);
	            s0 = s1;
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseGroup() {
	      var s0, s1;

	      s0 = peg$currPos;
	      s1 = peg$parseGroupParts();
	      if (s1 === peg$FAILED) {
	        s1 = null;
	      }
	      if (s1 !== peg$FAILED) {
	        s1 = peg$c1(s1);
	      }
	      s0 = s1;

	      return s0;
	    }

	    function peg$parseGroupParts() {
	      var s0, s1, s2, s3, s4, s5;

	      s0 = peg$currPos;
	      s1 = peg$parseGroupPart();
	      if (s1 !== peg$FAILED) {
	        s2 = [];
	        s3 = peg$currPos;
	        s4 = peg$parse__();
	        if (s4 !== peg$FAILED) {
	          s5 = peg$parseGroupPart();
	          if (s5 !== peg$FAILED) {
	            s4 = [s4, s5];
	            s3 = s4;
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s3;
	          s3 = peg$FAILED;
	        }
	        while (s3 !== peg$FAILED) {
	          s2.push(s3);
	          s3 = peg$currPos;
	          s4 = peg$parse__();
	          if (s4 !== peg$FAILED) {
	            s5 = peg$parseGroupPart();
	            if (s5 !== peg$FAILED) {
	              s4 = [s4, s5];
	              s3 = s4;
	            } else {
	              peg$currPos = s3;
	              s3 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = peg$c2(s1, s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseGroupPart() {
	      var s0;

	      s0 = peg$parseIfSection();
	      if (s0 === peg$FAILED) {
	        s0 = peg$parseControlLine();
	        if (s0 === peg$FAILED) {
	          s0 = peg$parseNodes();
	          if (s0 === peg$FAILED) {
	            s0 = peg$parseTextLine();
	          }
	        }
	      }

	      return s0;
	    }

	    function peg$parseIfSection() {
	      var s0, s1, s2, s3, s4, s5, s6, s7;

	      s0 = peg$currPos;
	      s1 = peg$parseIfGroup();
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parse__();
	        if (s2 !== peg$FAILED) {
	          s3 = [];
	          s4 = peg$parseElIfGroup();
	          while (s4 !== peg$FAILED) {
	            s3.push(s4);
	            s4 = peg$parseElIfGroup();
	          }
	          if (s3 !== peg$FAILED) {
	            s4 = peg$parse__();
	            if (s4 !== peg$FAILED) {
	              s5 = peg$parseElseGroup();
	              if (s5 === peg$FAILED) {
	                s5 = null;
	              }
	              if (s5 !== peg$FAILED) {
	                s6 = peg$parse__();
	                if (s6 !== peg$FAILED) {
	                  s7 = peg$parseEndIfLine();
	                  if (s7 !== peg$FAILED) {
	                    s1 = peg$c3(s1, s3, s5);
	                    s0 = s1;
	                  } else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                  }
	                } else {
	                  peg$currPos = s0;
	                  s0 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseIfGroup() {
	      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

	      s0 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 35) {
	        s1 = peg$c4;
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c5); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parse_();
	        if (s2 !== peg$FAILED) {
	          if (input.substr(peg$currPos, 2) === peg$c6) {
	            s3 = peg$c6;
	            peg$currPos += 2;
	          } else {
	            s3 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c7); }
	          }
	          if (s3 !== peg$FAILED) {
	            s4 = peg$parseMSS();
	            if (s4 !== peg$FAILED) {
	              s5 = peg$parsePPExpression();
	              if (s5 !== peg$FAILED) {
	                s6 = peg$parse_();
	                if (s6 !== peg$FAILED) {
	                  s7 = peg$parseLineTerminatorSequence();
	                  if (s7 !== peg$FAILED) {
	                    s8 = peg$parse__();
	                    if (s8 !== peg$FAILED) {
	                      s9 = peg$parseGroup();
	                      if (s9 !== peg$FAILED) {
	                        s1 = peg$c8(s5, s9);
	                        s0 = s1;
	                      } else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                      }
	                    } else {
	                      peg$currPos = s0;
	                      s0 = peg$FAILED;
	                    }
	                  } else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                  }
	                } else {
	                  peg$currPos = s0;
	                  s0 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	      if (s0 === peg$FAILED) {
	        s0 = peg$currPos;
	        if (input.charCodeAt(peg$currPos) === 35) {
	          s1 = peg$c4;
	          peg$currPos++;
	        } else {
	          s1 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c5); }
	        }
	        if (s1 !== peg$FAILED) {
	          s2 = peg$parse_();
	          if (s2 !== peg$FAILED) {
	            if (input.substr(peg$currPos, 5) === peg$c9) {
	              s3 = peg$c9;
	              peg$currPos += 5;
	            } else {
	              s3 = peg$FAILED;
	              if (peg$silentFails === 0) { peg$fail(peg$c10); }
	            }
	            if (s3 !== peg$FAILED) {
	              s4 = peg$parseMSS();
	              if (s4 !== peg$FAILED) {
	                s5 = peg$parseIdentifier();
	                if (s5 !== peg$FAILED) {
	                  s6 = peg$parse_();
	                  if (s6 !== peg$FAILED) {
	                    s7 = peg$parseLineTerminatorSequence();
	                    if (s7 !== peg$FAILED) {
	                      s8 = peg$parse__();
	                      if (s8 !== peg$FAILED) {
	                        s9 = peg$parseGroup();
	                        if (s9 !== peg$FAILED) {
	                          s1 = peg$c11(s5, s9);
	                          s0 = s1;
	                        } else {
	                          peg$currPos = s0;
	                          s0 = peg$FAILED;
	                        }
	                      } else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                      }
	                    } else {
	                      peg$currPos = s0;
	                      s0 = peg$FAILED;
	                    }
	                  } else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                  }
	                } else {
	                  peg$currPos = s0;
	                  s0 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	        if (s0 === peg$FAILED) {
	          s0 = peg$currPos;
	          if (input.charCodeAt(peg$currPos) === 35) {
	            s1 = peg$c4;
	            peg$currPos++;
	          } else {
	            s1 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c5); }
	          }
	          if (s1 !== peg$FAILED) {
	            s2 = peg$parse_();
	            if (s2 !== peg$FAILED) {
	              if (input.substr(peg$currPos, 6) === peg$c12) {
	                s3 = peg$c12;
	                peg$currPos += 6;
	              } else {
	                s3 = peg$FAILED;
	                if (peg$silentFails === 0) { peg$fail(peg$c13); }
	              }
	              if (s3 !== peg$FAILED) {
	                s4 = peg$parseMSS();
	                if (s4 !== peg$FAILED) {
	                  s5 = peg$parseIdentifier();
	                  if (s5 !== peg$FAILED) {
	                    s6 = peg$parse_();
	                    if (s6 !== peg$FAILED) {
	                      s7 = peg$parseLineTerminatorSequence();
	                      if (s7 !== peg$FAILED) {
	                        s8 = peg$parse__();
	                        if (s8 !== peg$FAILED) {
	                          s9 = peg$parseGroup();
	                          if (s9 !== peg$FAILED) {
	                            s1 = peg$c14(s5, s9);
	                            s0 = s1;
	                          } else {
	                            peg$currPos = s0;
	                            s0 = peg$FAILED;
	                          }
	                        } else {
	                          peg$currPos = s0;
	                          s0 = peg$FAILED;
	                        }
	                      } else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                      }
	                    } else {
	                      peg$currPos = s0;
	                      s0 = peg$FAILED;
	                    }
	                  } else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                  }
	                } else {
	                  peg$currPos = s0;
	                  s0 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        }
	      }

	      return s0;
	    }

	    function peg$parseElIfGroup() {
	      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;

	      s0 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 35) {
	        s1 = peg$c4;
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c5); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parse_();
	        if (s2 !== peg$FAILED) {
	          if (input.substr(peg$currPos, 4) === peg$c15) {
	            s3 = peg$c15;
	            peg$currPos += 4;
	          } else {
	            s3 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c16); }
	          }
	          if (s3 !== peg$FAILED) {
	            s4 = peg$parseMSS();
	            if (s4 !== peg$FAILED) {
	              s5 = peg$parsePPExpression();
	              if (s5 !== peg$FAILED) {
	                s6 = peg$parse_();
	                if (s6 !== peg$FAILED) {
	                  s7 = peg$parseLineTerminatorSequence();
	                  if (s7 !== peg$FAILED) {
	                    s8 = peg$parse__();
	                    if (s8 !== peg$FAILED) {
	                      s9 = peg$parseGroup();
	                      if (s9 !== peg$FAILED) {
	                        s10 = peg$parse__();
	                        if (s10 !== peg$FAILED) {
	                          s1 = peg$c17(s5, s9);
	                          s0 = s1;
	                        } else {
	                          peg$currPos = s0;
	                          s0 = peg$FAILED;
	                        }
	                      } else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                      }
	                    } else {
	                      peg$currPos = s0;
	                      s0 = peg$FAILED;
	                    }
	                  } else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                  }
	                } else {
	                  peg$currPos = s0;
	                  s0 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseElseGroup() {
	      var s0, s1, s2, s3, s4, s5, s6, s7;

	      s0 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 35) {
	        s1 = peg$c4;
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c5); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parse_();
	        if (s2 !== peg$FAILED) {
	          if (input.substr(peg$currPos, 4) === peg$c18) {
	            s3 = peg$c18;
	            peg$currPos += 4;
	          } else {
	            s3 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c19); }
	          }
	          if (s3 !== peg$FAILED) {
	            s4 = peg$parse_();
	            if (s4 !== peg$FAILED) {
	              s5 = peg$parseLineTerminatorSequence();
	              if (s5 !== peg$FAILED) {
	                s6 = peg$parse__();
	                if (s6 !== peg$FAILED) {
	                  s7 = peg$parseGroup();
	                  if (s7 !== peg$FAILED) {
	                    s1 = peg$c20(s7);
	                    s0 = s1;
	                  } else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                  }
	                } else {
	                  peg$currPos = s0;
	                  s0 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseEndIfLine() {
	      var s0, s1, s2, s3, s4, s5;

	      s0 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 35) {
	        s1 = peg$c4;
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c5); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parse_();
	        if (s2 !== peg$FAILED) {
	          if (input.substr(peg$currPos, 5) === peg$c21) {
	            s3 = peg$c21;
	            peg$currPos += 5;
	          } else {
	            s3 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c22); }
	          }
	          if (s3 !== peg$FAILED) {
	            s4 = peg$parse_();
	            if (s4 !== peg$FAILED) {
	              s5 = peg$parseLineTerminatorSequenceEOF();
	              if (s5 !== peg$FAILED) {
	                s1 = [s1, s2, s3, s4, s5];
	                s0 = s1;
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseControlLine() {
	      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

	      s0 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 35) {
	        s1 = peg$c4;
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c5); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parse_();
	        if (s2 !== peg$FAILED) {
	          if (input.substr(peg$currPos, 7) === peg$c23) {
	            s3 = peg$c23;
	            peg$currPos += 7;
	          } else {
	            s3 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c24); }
	          }
	          if (s3 !== peg$FAILED) {
	            s4 = peg$parse_();
	            if (s4 !== peg$FAILED) {
	              s5 = peg$parseHeaderFile();
	              if (s5 !== peg$FAILED) {
	                s6 = peg$parse_();
	                if (s6 !== peg$FAILED) {
	                  s7 = peg$parseLineTerminatorSequenceEOF();
	                  if (s7 !== peg$FAILED) {
	                    s1 = peg$c25(s5);
	                    s0 = s1;
	                  } else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                  }
	                } else {
	                  peg$currPos = s0;
	                  s0 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	      if (s0 === peg$FAILED) {
	        s0 = peg$currPos;
	        if (input.charCodeAt(peg$currPos) === 35) {
	          s1 = peg$c4;
	          peg$currPos++;
	        } else {
	          s1 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c5); }
	        }
	        if (s1 !== peg$FAILED) {
	          s2 = peg$parse_();
	          if (s2 !== peg$FAILED) {
	            if (input.substr(peg$currPos, 6) === peg$c26) {
	              s3 = peg$c26;
	              peg$currPos += 6;
	            } else {
	              s3 = peg$FAILED;
	              if (peg$silentFails === 0) { peg$fail(peg$c27); }
	            }
	            if (s3 === peg$FAILED) {
	              if (input.substr(peg$currPos, 3) === peg$c28) {
	                s3 = peg$c28;
	                peg$currPos += 3;
	              } else {
	                s3 = peg$FAILED;
	                if (peg$silentFails === 0) { peg$fail(peg$c29); }
	              }
	            }
	            if (s3 !== peg$FAILED) {
	              s4 = peg$parseMSS();
	              if (s4 !== peg$FAILED) {
	                s5 = peg$parseIdentifier();
	                if (s5 !== peg$FAILED) {
	                  s6 = peg$currPos;
	                  s7 = peg$parseMSS();
	                  if (s7 !== peg$FAILED) {
	                    s8 = peg$parseTokens();
	                    if (s8 !== peg$FAILED) {
	                      s7 = [s7, s8];
	                      s6 = s7;
	                    } else {
	                      peg$currPos = s6;
	                      s6 = peg$FAILED;
	                    }
	                  } else {
	                    peg$currPos = s6;
	                    s6 = peg$FAILED;
	                  }
	                  if (s6 === peg$FAILED) {
	                    s6 = null;
	                  }
	                  if (s6 !== peg$FAILED) {
	                    s7 = peg$parse_();
	                    if (s7 !== peg$FAILED) {
	                      s8 = peg$parseLineTerminatorSequenceEOF();
	                      if (s8 !== peg$FAILED) {
	                        s1 = peg$c30(s3, s5, s6);
	                        s0 = s1;
	                      } else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                      }
	                    } else {
	                      peg$currPos = s0;
	                      s0 = peg$FAILED;
	                    }
	                  } else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                  }
	                } else {
	                  peg$currPos = s0;
	                  s0 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	        if (s0 === peg$FAILED) {
	          s0 = peg$currPos;
	          if (input.charCodeAt(peg$currPos) === 35) {
	            s1 = peg$c4;
	            peg$currPos++;
	          } else {
	            s1 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c5); }
	          }
	          if (s1 !== peg$FAILED) {
	            s2 = peg$parse_();
	            if (s2 !== peg$FAILED) {
	              if (input.substr(peg$currPos, 5) === peg$c31) {
	                s3 = peg$c31;
	                peg$currPos += 5;
	              } else {
	                s3 = peg$FAILED;
	                if (peg$silentFails === 0) { peg$fail(peg$c32); }
	              }
	              if (s3 !== peg$FAILED) {
	                s4 = peg$currPos;
	                s5 = peg$parseMSS();
	                if (s5 !== peg$FAILED) {
	                  s6 = peg$parseTokens();
	                  if (s6 !== peg$FAILED) {
	                    s5 = [s5, s6];
	                    s4 = s5;
	                  } else {
	                    peg$currPos = s4;
	                    s4 = peg$FAILED;
	                  }
	                } else {
	                  peg$currPos = s4;
	                  s4 = peg$FAILED;
	                }
	                if (s4 === peg$FAILED) {
	                  s4 = null;
	                }
	                if (s4 !== peg$FAILED) {
	                  s5 = peg$parse_();
	                  if (s5 !== peg$FAILED) {
	                    s6 = peg$parseLineTerminatorSequenceEOF();
	                    if (s6 !== peg$FAILED) {
	                      s1 = peg$c33(s4);
	                      s0 = s1;
	                    } else {
	                      peg$currPos = s0;
	                      s0 = peg$FAILED;
	                    }
	                  } else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                  }
	                } else {
	                  peg$currPos = s0;
	                  s0 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	          if (s0 === peg$FAILED) {
	            s0 = peg$currPos;
	            if (input.charCodeAt(peg$currPos) === 35) {
	              s1 = peg$c4;
	              peg$currPos++;
	            } else {
	              s1 = peg$FAILED;
	              if (peg$silentFails === 0) { peg$fail(peg$c5); }
	            }
	            if (s1 !== peg$FAILED) {
	              s2 = peg$parse_();
	              if (s2 !== peg$FAILED) {
	                if (input.substr(peg$currPos, 4) === peg$c34) {
	                  s3 = peg$c34;
	                  peg$currPos += 4;
	                } else {
	                  s3 = peg$FAILED;
	                  if (peg$silentFails === 0) { peg$fail(peg$c35); }
	                }
	                if (s3 !== peg$FAILED) {
	                  s4 = peg$parseMSS();
	                  if (s4 !== peg$FAILED) {
	                    s5 = peg$parseTokens();
	                    if (s5 !== peg$FAILED) {
	                      s6 = peg$parse_();
	                      if (s6 !== peg$FAILED) {
	                        s7 = peg$parseLineTerminatorSequenceEOF();
	                        if (s7 !== peg$FAILED) {
	                          s1 = peg$c36(s5);
	                          s0 = s1;
	                        } else {
	                          peg$currPos = s0;
	                          s0 = peg$FAILED;
	                        }
	                      } else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                      }
	                    } else {
	                      peg$currPos = s0;
	                      s0 = peg$FAILED;
	                    }
	                  } else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                  }
	                } else {
	                  peg$currPos = s0;
	                  s0 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	            if (s0 === peg$FAILED) {
	              s0 = peg$currPos;
	              if (input.charCodeAt(peg$currPos) === 35) {
	                s1 = peg$c4;
	                peg$currPos++;
	              } else {
	                s1 = peg$FAILED;
	                if (peg$silentFails === 0) { peg$fail(peg$c5); }
	              }
	              if (s1 !== peg$FAILED) {
	                s2 = peg$parse_();
	                if (s2 !== peg$FAILED) {
	                  if (input.substr(peg$currPos, 6) === peg$c37) {
	                    s3 = peg$c37;
	                    peg$currPos += 6;
	                  } else {
	                    s3 = peg$FAILED;
	                    if (peg$silentFails === 0) { peg$fail(peg$c38); }
	                  }
	                  if (s3 !== peg$FAILED) {
	                    s4 = peg$parseMSS();
	                    if (s4 !== peg$FAILED) {
	                      s5 = peg$parseIdentifier();
	                      if (s5 !== peg$FAILED) {
	                        s6 = peg$parseMSS();
	                        if (s6 !== peg$FAILED) {
	                          s7 = peg$parseTokens();
	                          if (s7 !== peg$FAILED) {
	                            s8 = peg$parse_();
	                            if (s8 !== peg$FAILED) {
	                              s9 = peg$parseLineTerminatorSequenceEOF();
	                              if (s9 !== peg$FAILED) {
	                                s1 = peg$c39(s5, s7);
	                                s0 = s1;
	                              } else {
	                                peg$currPos = s0;
	                                s0 = peg$FAILED;
	                              }
	                            } else {
	                              peg$currPos = s0;
	                              s0 = peg$FAILED;
	                            }
	                          } else {
	                            peg$currPos = s0;
	                            s0 = peg$FAILED;
	                          }
	                        } else {
	                          peg$currPos = s0;
	                          s0 = peg$FAILED;
	                        }
	                      } else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                      }
	                    } else {
	                      peg$currPos = s0;
	                      s0 = peg$FAILED;
	                    }
	                  } else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                  }
	                } else {
	                  peg$currPos = s0;
	                  s0 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	              if (s0 === peg$FAILED) {
	                s0 = peg$currPos;
	                if (input.charCodeAt(peg$currPos) === 35) {
	                  s1 = peg$c4;
	                  peg$currPos++;
	                } else {
	                  s1 = peg$FAILED;
	                  if (peg$silentFails === 0) { peg$fail(peg$c5); }
	                }
	                if (s1 !== peg$FAILED) {
	                  s2 = peg$parse_();
	                  if (s2 !== peg$FAILED) {
	                    if (input.substr(peg$currPos, 5) === peg$c40) {
	                      s3 = peg$c40;
	                      peg$currPos += 5;
	                    } else {
	                      s3 = peg$FAILED;
	                      if (peg$silentFails === 0) { peg$fail(peg$c41); }
	                    }
	                    if (s3 !== peg$FAILED) {
	                      s4 = peg$parseMSS();
	                      if (s4 !== peg$FAILED) {
	                        s5 = peg$parseIdentifier();
	                        if (s5 !== peg$FAILED) {
	                          s6 = peg$parse_();
	                          if (s6 !== peg$FAILED) {
	                            s7 = peg$parseLineTerminatorSequenceEOF();
	                            if (s7 !== peg$FAILED) {
	                              s1 = peg$c42(s5);
	                              s0 = s1;
	                            } else {
	                              peg$currPos = s0;
	                              s0 = peg$FAILED;
	                            }
	                          } else {
	                            peg$currPos = s0;
	                            s0 = peg$FAILED;
	                          }
	                        } else {
	                          peg$currPos = s0;
	                          s0 = peg$FAILED;
	                        }
	                      } else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                      }
	                    } else {
	                      peg$currPos = s0;
	                      s0 = peg$FAILED;
	                    }
	                  } else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                  }
	                } else {
	                  peg$currPos = s0;
	                  s0 = peg$FAILED;
	                }
	                if (s0 === peg$FAILED) {
	                  s0 = peg$currPos;
	                  if (input.charCodeAt(peg$currPos) === 35) {
	                    s1 = peg$c4;
	                    peg$currPos++;
	                  } else {
	                    s1 = peg$FAILED;
	                    if (peg$silentFails === 0) { peg$fail(peg$c5); }
	                  }
	                  if (s1 !== peg$FAILED) {
	                    s2 = peg$parse_();
	                    if (s2 !== peg$FAILED) {
	                      if (input.substr(peg$currPos, 7) === peg$c43) {
	                        s3 = peg$c43;
	                        peg$currPos += 7;
	                      } else {
	                        s3 = peg$FAILED;
	                        if (peg$silentFails === 0) { peg$fail(peg$c44); }
	                      }
	                      if (s3 !== peg$FAILED) {
	                        s4 = peg$currPos;
	                        s5 = peg$parseMSS();
	                        if (s5 !== peg$FAILED) {
	                          s6 = peg$parseTokens();
	                          if (s6 !== peg$FAILED) {
	                            s5 = [s5, s6];
	                            s4 = s5;
	                          } else {
	                            peg$currPos = s4;
	                            s4 = peg$FAILED;
	                          }
	                        } else {
	                          peg$currPos = s4;
	                          s4 = peg$FAILED;
	                        }
	                        if (s4 === peg$FAILED) {
	                          s4 = null;
	                        }
	                        if (s4 !== peg$FAILED) {
	                          s5 = peg$parse_();
	                          if (s5 !== peg$FAILED) {
	                            s6 = peg$parseLineTerminatorSequenceEOF();
	                            if (s6 !== peg$FAILED) {
	                              s1 = peg$c45(s4);
	                              s0 = s1;
	                            } else {
	                              peg$currPos = s0;
	                              s0 = peg$FAILED;
	                            }
	                          } else {
	                            peg$currPos = s0;
	                            s0 = peg$FAILED;
	                          }
	                        } else {
	                          peg$currPos = s0;
	                          s0 = peg$FAILED;
	                        }
	                      } else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                      }
	                    } else {
	                      peg$currPos = s0;
	                      s0 = peg$FAILED;
	                    }
	                  } else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                  }
	                  if (s0 === peg$FAILED) {
	                    s0 = peg$currPos;
	                    if (input.charCodeAt(peg$currPos) === 35) {
	                      s1 = peg$c4;
	                      peg$currPos++;
	                    } else {
	                      s1 = peg$FAILED;
	                      if (peg$silentFails === 0) { peg$fail(peg$c5); }
	                    }
	                    if (s1 !== peg$FAILED) {
	                      s2 = peg$parse_();
	                      if (s2 !== peg$FAILED) {
	                        if (input.substr(peg$currPos, 9) === peg$c46) {
	                          s3 = peg$c46;
	                          peg$currPos += 9;
	                        } else {
	                          s3 = peg$FAILED;
	                          if (peg$silentFails === 0) { peg$fail(peg$c47); }
	                        }
	                        if (s3 !== peg$FAILED) {
	                          s4 = peg$currPos;
	                          s5 = peg$parseMSS();
	                          if (s5 !== peg$FAILED) {
	                            s6 = peg$parseTokens();
	                            if (s6 !== peg$FAILED) {
	                              s5 = [s5, s6];
	                              s4 = s5;
	                            } else {
	                              peg$currPos = s4;
	                              s4 = peg$FAILED;
	                            }
	                          } else {
	                            peg$currPos = s4;
	                            s4 = peg$FAILED;
	                          }
	                          if (s4 === peg$FAILED) {
	                            s4 = null;
	                          }
	                          if (s4 !== peg$FAILED) {
	                            s5 = peg$parse_();
	                            if (s5 !== peg$FAILED) {
	                              s6 = peg$parseLineTerminatorSequenceEOF();
	                              if (s6 !== peg$FAILED) {
	                                s1 = peg$c48(s4);
	                                s0 = s1;
	                              } else {
	                                peg$currPos = s0;
	                                s0 = peg$FAILED;
	                              }
	                            } else {
	                              peg$currPos = s0;
	                              s0 = peg$FAILED;
	                            }
	                          } else {
	                            peg$currPos = s0;
	                            s0 = peg$FAILED;
	                          }
	                        } else {
	                          peg$currPos = s0;
	                          s0 = peg$FAILED;
	                        }
	                      } else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                      }
	                    } else {
	                      peg$currPos = s0;
	                      s0 = peg$FAILED;
	                    }
	                    if (s0 === peg$FAILED) {
	                      s0 = peg$currPos;
	                      if (input.charCodeAt(peg$currPos) === 35) {
	                        s1 = peg$c4;
	                        peg$currPos++;
	                      } else {
	                        s1 = peg$FAILED;
	                        if (peg$silentFails === 0) { peg$fail(peg$c5); }
	                      }
	                      if (s1 !== peg$FAILED) {
	                        s2 = peg$parse_();
	                        if (s2 !== peg$FAILED) {
	                          if (input.substr(peg$currPos, 7) === peg$c49) {
	                            s3 = peg$c49;
	                            peg$currPos += 7;
	                          } else {
	                            s3 = peg$FAILED;
	                            if (peg$silentFails === 0) { peg$fail(peg$c50); }
	                          }
	                          if (s3 !== peg$FAILED) {
	                            s4 = peg$parseMSS();
	                            if (s4 !== peg$FAILED) {
	                              s5 = peg$parseToken();
	                              if (s5 !== peg$FAILED) {
	                                s6 = peg$parse_();
	                                if (s6 !== peg$FAILED) {
	                                  s7 = peg$parseLineTerminatorSequenceEOF();
	                                  if (s7 !== peg$FAILED) {
	                                    s1 = peg$c51(s5);
	                                    s0 = s1;
	                                  } else {
	                                    peg$currPos = s0;
	                                    s0 = peg$FAILED;
	                                  }
	                                } else {
	                                  peg$currPos = s0;
	                                  s0 = peg$FAILED;
	                                }
	                              } else {
	                                peg$currPos = s0;
	                                s0 = peg$FAILED;
	                              }
	                            } else {
	                              peg$currPos = s0;
	                              s0 = peg$FAILED;
	                            }
	                          } else {
	                            peg$currPos = s0;
	                            s0 = peg$FAILED;
	                          }
	                        } else {
	                          peg$currPos = s0;
	                          s0 = peg$FAILED;
	                        }
	                      } else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                      }
	                      if (s0 === peg$FAILED) {
	                        s0 = peg$currPos;
	                        if (input.charCodeAt(peg$currPos) === 35) {
	                          s1 = peg$c4;
	                          peg$currPos++;
	                        } else {
	                          s1 = peg$FAILED;
	                          if (peg$silentFails === 0) { peg$fail(peg$c5); }
	                        }
	                        if (s1 !== peg$FAILED) {
	                          s2 = peg$parse_();
	                          if (s2 !== peg$FAILED) {
	                            s3 = peg$parseLineTerminatorSequenceEOF();
	                            if (s3 !== peg$FAILED) {
	                              s1 = peg$c52();
	                              s0 = s1;
	                            } else {
	                              peg$currPos = s0;
	                              s0 = peg$FAILED;
	                            }
	                          } else {
	                            peg$currPos = s0;
	                            s0 = peg$FAILED;
	                          }
	                        } else {
	                          peg$currPos = s0;
	                          s0 = peg$FAILED;
	                        }
	                      }
	                    }
	                  }
	                }
	              }
	            }
	          }
	        }
	      }

	      return s0;
	    }

	    function peg$parseNodes() {
	      var s0, s1, s2, s3;

	      s0 = peg$currPos;
	      s1 = peg$parseNodeGroup();
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parse__();
	        if (s2 !== peg$FAILED) {
	          s3 = peg$parseEndNodeLine();
	          if (s3 !== peg$FAILED) {
	            s1 = peg$c53(s1);
	            s0 = s1;
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	      if (s0 === peg$FAILED) {
	        s0 = peg$parseNodesGlobalLine();
	        if (s0 === peg$FAILED) {
	          s0 = peg$parseNodesMainLine();
	        }
	      }

	      return s0;
	    }

	    function peg$parseNodeGroup() {
	      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14;

	      s0 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 35) {
	        s1 = peg$c4;
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c5); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parse_();
	        if (s2 !== peg$FAILED) {
	          if (input.substr(peg$currPos, 4) === peg$c54) {
	            s3 = peg$c54;
	            peg$currPos += 4;
	          } else {
	            s3 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c55); }
	          }
	          if (s3 !== peg$FAILED) {
	            s4 = peg$parseMSS();
	            if (s4 !== peg$FAILED) {
	              s5 = peg$parseIdentifier();
	              if (s5 !== peg$FAILED) {
	                s6 = peg$parse_();
	                if (s6 !== peg$FAILED) {
	                  s7 = peg$parseLineTerminatorSequence();
	                  if (s7 !== peg$FAILED) {
	                    s8 = peg$parse__();
	                    if (s8 !== peg$FAILED) {
	                      s9 = [];
	                      s10 = peg$currPos;
	                      s11 = peg$parseNodeVar();
	                      if (s11 !== peg$FAILED) {
	                        s12 = peg$parse__();
	                        if (s12 !== peg$FAILED) {
	                          s11 = [s11, s12];
	                          s10 = s11;
	                        } else {
	                          peg$currPos = s10;
	                          s10 = peg$FAILED;
	                        }
	                      } else {
	                        peg$currPos = s10;
	                        s10 = peg$FAILED;
	                      }
	                      while (s10 !== peg$FAILED) {
	                        s9.push(s10);
	                        s10 = peg$currPos;
	                        s11 = peg$parseNodeVar();
	                        if (s11 !== peg$FAILED) {
	                          s12 = peg$parse__();
	                          if (s12 !== peg$FAILED) {
	                            s11 = [s11, s12];
	                            s10 = s11;
	                          } else {
	                            peg$currPos = s10;
	                            s10 = peg$FAILED;
	                          }
	                        } else {
	                          peg$currPos = s10;
	                          s10 = peg$FAILED;
	                        }
	                      }
	                      if (s9 !== peg$FAILED) {
	                        s10 = [];
	                        s11 = peg$currPos;
	                        s12 = peg$parseNodeDeclarationLine();
	                        if (s12 !== peg$FAILED) {
	                          s13 = peg$parse__();
	                          if (s13 !== peg$FAILED) {
	                            s12 = [s12, s13];
	                            s11 = s12;
	                          } else {
	                            peg$currPos = s11;
	                            s11 = peg$FAILED;
	                          }
	                        } else {
	                          peg$currPos = s11;
	                          s11 = peg$FAILED;
	                        }
	                        while (s11 !== peg$FAILED) {
	                          s10.push(s11);
	                          s11 = peg$currPos;
	                          s12 = peg$parseNodeDeclarationLine();
	                          if (s12 !== peg$FAILED) {
	                            s13 = peg$parse__();
	                            if (s13 !== peg$FAILED) {
	                              s12 = [s12, s13];
	                              s11 = s12;
	                            } else {
	                              peg$currPos = s11;
	                              s11 = peg$FAILED;
	                            }
	                          } else {
	                            peg$currPos = s11;
	                            s11 = peg$FAILED;
	                          }
	                        }
	                        if (s10 !== peg$FAILED) {
	                          s11 = [];
	                          s12 = peg$currPos;
	                          s13 = peg$parseNodeStatement();
	                          if (s13 !== peg$FAILED) {
	                            s14 = peg$parse__();
	                            if (s14 !== peg$FAILED) {
	                              s13 = [s13, s14];
	                              s12 = s13;
	                            } else {
	                              peg$currPos = s12;
	                              s12 = peg$FAILED;
	                            }
	                          } else {
	                            peg$currPos = s12;
	                            s12 = peg$FAILED;
	                          }
	                          while (s12 !== peg$FAILED) {
	                            s11.push(s12);
	                            s12 = peg$currPos;
	                            s13 = peg$parseNodeStatement();
	                            if (s13 !== peg$FAILED) {
	                              s14 = peg$parse__();
	                              if (s14 !== peg$FAILED) {
	                                s13 = [s13, s14];
	                                s12 = s13;
	                              } else {
	                                peg$currPos = s12;
	                                s12 = peg$FAILED;
	                              }
	                            } else {
	                              peg$currPos = s12;
	                              s12 = peg$FAILED;
	                            }
	                          }
	                          if (s11 !== peg$FAILED) {
	                            s1 = peg$c56(s5, s9, s10, s11);
	                            s0 = s1;
	                          } else {
	                            peg$currPos = s0;
	                            s0 = peg$FAILED;
	                          }
	                        } else {
	                          peg$currPos = s0;
	                          s0 = peg$FAILED;
	                        }
	                      } else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                      }
	                    } else {
	                      peg$currPos = s0;
	                      s0 = peg$FAILED;
	                    }
	                  } else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                  }
	                } else {
	                  peg$currPos = s0;
	                  s0 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseEndNodeLine() {
	      var s0, s1, s2, s3, s4, s5;

	      s0 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 35) {
	        s1 = peg$c4;
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c5); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parse_();
	        if (s2 !== peg$FAILED) {
	          if (input.substr(peg$currPos, 7) === peg$c57) {
	            s3 = peg$c57;
	            peg$currPos += 7;
	          } else {
	            s3 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c58); }
	          }
	          if (s3 !== peg$FAILED) {
	            s4 = peg$parse_();
	            if (s4 !== peg$FAILED) {
	              s5 = peg$parseLineTerminatorSequenceEOF();
	              if (s5 === peg$FAILED) {
	                s5 = null;
	              }
	              if (s5 !== peg$FAILED) {
	                s1 = [s1, s2, s3, s4, s5];
	                s0 = s1;
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseNodeVar() {
	      var s0, s1, s2, s3, s4, s5, s6, s7, s8;

	      s0 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 35) {
	        s1 = peg$c4;
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c5); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parse_();
	        if (s2 !== peg$FAILED) {
	          if (input.substr(peg$currPos, 8) === peg$c59) {
	            s3 = peg$c59;
	            peg$currPos += 8;
	          } else {
	            s3 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c60); }
	          }
	          if (s3 !== peg$FAILED) {
	            s4 = peg$parseMSS();
	            if (s4 !== peg$FAILED) {
	              s5 = peg$parseIdentifier();
	              if (s5 !== peg$FAILED) {
	                s6 = peg$currPos;
	                s7 = peg$parseMSS();
	                if (s7 !== peg$FAILED) {
	                  s8 = peg$parseTokens();
	                  if (s8 !== peg$FAILED) {
	                    s7 = [s7, s8];
	                    s6 = s7;
	                  } else {
	                    peg$currPos = s6;
	                    s6 = peg$FAILED;
	                  }
	                } else {
	                  peg$currPos = s6;
	                  s6 = peg$FAILED;
	                }
	                if (s6 === peg$FAILED) {
	                  s6 = null;
	                }
	                if (s6 !== peg$FAILED) {
	                  s7 = peg$parse_();
	                  if (s7 !== peg$FAILED) {
	                    s8 = peg$parseLineTerminatorSequence();
	                    if (s8 !== peg$FAILED) {
	                      s1 = peg$c61(s5, s6);
	                      s0 = s1;
	                    } else {
	                      peg$currPos = s0;
	                      s0 = peg$FAILED;
	                    }
	                  } else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                  }
	                } else {
	                  peg$currPos = s0;
	                  s0 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseNodeDeclarationLine() {
	      var s0;

	      s0 = peg$parseNodeInLine();
	      if (s0 === peg$FAILED) {
	        s0 = peg$parseNodeOutLine();
	        if (s0 === peg$FAILED) {
	          s0 = peg$parseNodeParamLine();
	        }
	      }

	      return s0;
	    }

	    function peg$parseNodeStatement() {
	      var s0;

	      s0 = peg$parseNodeIfSection();
	      if (s0 === peg$FAILED) {
	        s0 = peg$parseTextLine();
	      }

	      return s0;
	    }

	    function peg$parseNodeIfSection() {
	      var s0, s1, s2, s3, s4, s5, s6, s7;

	      s0 = peg$currPos;
	      s1 = peg$parseNodeIfGroup();
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parse__();
	        if (s2 !== peg$FAILED) {
	          s3 = [];
	          s4 = peg$parseNodeElIfGroup();
	          while (s4 !== peg$FAILED) {
	            s3.push(s4);
	            s4 = peg$parseNodeElIfGroup();
	          }
	          if (s3 !== peg$FAILED) {
	            s4 = peg$parse__();
	            if (s4 !== peg$FAILED) {
	              s5 = peg$parseNodeElseGroup();
	              if (s5 === peg$FAILED) {
	                s5 = null;
	              }
	              if (s5 !== peg$FAILED) {
	                s6 = peg$parse__();
	                if (s6 !== peg$FAILED) {
	                  s7 = peg$parseNodeEndIfLine();
	                  if (s7 !== peg$FAILED) {
	                    s1 = peg$c62(s1, s3, s5);
	                    s0 = s1;
	                  } else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                  }
	                } else {
	                  peg$currPos = s0;
	                  s0 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseNodeIfGroup() {
	      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12;

	      s0 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 35) {
	        s1 = peg$c4;
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c5); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parse_();
	        if (s2 !== peg$FAILED) {
	          if (input.substr(peg$currPos, 7) === peg$c63) {
	            s3 = peg$c63;
	            peg$currPos += 7;
	          } else {
	            s3 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c64); }
	          }
	          if (s3 !== peg$FAILED) {
	            s4 = peg$parseMSS();
	            if (s4 !== peg$FAILED) {
	              s5 = peg$parsePPExpression();
	              if (s5 !== peg$FAILED) {
	                s6 = peg$parse_();
	                if (s6 !== peg$FAILED) {
	                  s7 = peg$parseLineTerminatorSequence();
	                  if (s7 !== peg$FAILED) {
	                    s8 = peg$parse__();
	                    if (s8 !== peg$FAILED) {
	                      s9 = [];
	                      s10 = peg$currPos;
	                      s11 = peg$parseNodeStatement();
	                      if (s11 !== peg$FAILED) {
	                        s12 = peg$parse__();
	                        if (s12 !== peg$FAILED) {
	                          s11 = [s11, s12];
	                          s10 = s11;
	                        } else {
	                          peg$currPos = s10;
	                          s10 = peg$FAILED;
	                        }
	                      } else {
	                        peg$currPos = s10;
	                        s10 = peg$FAILED;
	                      }
	                      while (s10 !== peg$FAILED) {
	                        s9.push(s10);
	                        s10 = peg$currPos;
	                        s11 = peg$parseNodeStatement();
	                        if (s11 !== peg$FAILED) {
	                          s12 = peg$parse__();
	                          if (s12 !== peg$FAILED) {
	                            s11 = [s11, s12];
	                            s10 = s11;
	                          } else {
	                            peg$currPos = s10;
	                            s10 = peg$FAILED;
	                          }
	                        } else {
	                          peg$currPos = s10;
	                          s10 = peg$FAILED;
	                        }
	                      }
	                      if (s9 !== peg$FAILED) {
	                        s1 = peg$c65(s5, s9);
	                        s0 = s1;
	                      } else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                      }
	                    } else {
	                      peg$currPos = s0;
	                      s0 = peg$FAILED;
	                    }
	                  } else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                  }
	                } else {
	                  peg$currPos = s0;
	                  s0 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	      if (s0 === peg$FAILED) {
	        s0 = peg$currPos;
	        if (input.charCodeAt(peg$currPos) === 35) {
	          s1 = peg$c4;
	          peg$currPos++;
	        } else {
	          s1 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c5); }
	        }
	        if (s1 !== peg$FAILED) {
	          s2 = peg$parse_();
	          if (s2 !== peg$FAILED) {
	            if (input.substr(peg$currPos, 10) === peg$c66) {
	              s3 = peg$c66;
	              peg$currPos += 10;
	            } else {
	              s3 = peg$FAILED;
	              if (peg$silentFails === 0) { peg$fail(peg$c67); }
	            }
	            if (s3 !== peg$FAILED) {
	              s4 = peg$parseMSS();
	              if (s4 !== peg$FAILED) {
	                s5 = peg$parseIdentifier();
	                if (s5 !== peg$FAILED) {
	                  s6 = peg$parse_();
	                  if (s6 !== peg$FAILED) {
	                    s7 = peg$parseLineTerminatorSequence();
	                    if (s7 !== peg$FAILED) {
	                      s8 = peg$parse__();
	                      if (s8 !== peg$FAILED) {
	                        s9 = [];
	                        s10 = peg$currPos;
	                        s11 = peg$parseNodeStatement();
	                        if (s11 !== peg$FAILED) {
	                          s12 = peg$parse__();
	                          if (s12 !== peg$FAILED) {
	                            s11 = [s11, s12];
	                            s10 = s11;
	                          } else {
	                            peg$currPos = s10;
	                            s10 = peg$FAILED;
	                          }
	                        } else {
	                          peg$currPos = s10;
	                          s10 = peg$FAILED;
	                        }
	                        while (s10 !== peg$FAILED) {
	                          s9.push(s10);
	                          s10 = peg$currPos;
	                          s11 = peg$parseNodeStatement();
	                          if (s11 !== peg$FAILED) {
	                            s12 = peg$parse__();
	                            if (s12 !== peg$FAILED) {
	                              s11 = [s11, s12];
	                              s10 = s11;
	                            } else {
	                              peg$currPos = s10;
	                              s10 = peg$FAILED;
	                            }
	                          } else {
	                            peg$currPos = s10;
	                            s10 = peg$FAILED;
	                          }
	                        }
	                        if (s9 !== peg$FAILED) {
	                          s1 = peg$c68(s5, s9);
	                          s0 = s1;
	                        } else {
	                          peg$currPos = s0;
	                          s0 = peg$FAILED;
	                        }
	                      } else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                      }
	                    } else {
	                      peg$currPos = s0;
	                      s0 = peg$FAILED;
	                    }
	                  } else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                  }
	                } else {
	                  peg$currPos = s0;
	                  s0 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	        if (s0 === peg$FAILED) {
	          s0 = peg$currPos;
	          if (input.charCodeAt(peg$currPos) === 35) {
	            s1 = peg$c4;
	            peg$currPos++;
	          } else {
	            s1 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c5); }
	          }
	          if (s1 !== peg$FAILED) {
	            s2 = peg$parse_();
	            if (s2 !== peg$FAILED) {
	              if (input.substr(peg$currPos, 11) === peg$c69) {
	                s3 = peg$c69;
	                peg$currPos += 11;
	              } else {
	                s3 = peg$FAILED;
	                if (peg$silentFails === 0) { peg$fail(peg$c70); }
	              }
	              if (s3 !== peg$FAILED) {
	                s4 = peg$parseMSS();
	                if (s4 !== peg$FAILED) {
	                  s5 = peg$parseIdentifier();
	                  if (s5 !== peg$FAILED) {
	                    s6 = peg$parse_();
	                    if (s6 !== peg$FAILED) {
	                      s7 = peg$parseLineTerminatorSequence();
	                      if (s7 !== peg$FAILED) {
	                        s8 = peg$parse__();
	                        if (s8 !== peg$FAILED) {
	                          s9 = [];
	                          s10 = peg$currPos;
	                          s11 = peg$parseNodeStatement();
	                          if (s11 !== peg$FAILED) {
	                            s12 = peg$parse__();
	                            if (s12 !== peg$FAILED) {
	                              s11 = [s11, s12];
	                              s10 = s11;
	                            } else {
	                              peg$currPos = s10;
	                              s10 = peg$FAILED;
	                            }
	                          } else {
	                            peg$currPos = s10;
	                            s10 = peg$FAILED;
	                          }
	                          while (s10 !== peg$FAILED) {
	                            s9.push(s10);
	                            s10 = peg$currPos;
	                            s11 = peg$parseNodeStatement();
	                            if (s11 !== peg$FAILED) {
	                              s12 = peg$parse__();
	                              if (s12 !== peg$FAILED) {
	                                s11 = [s11, s12];
	                                s10 = s11;
	                              } else {
	                                peg$currPos = s10;
	                                s10 = peg$FAILED;
	                              }
	                            } else {
	                              peg$currPos = s10;
	                              s10 = peg$FAILED;
	                            }
	                          }
	                          if (s9 !== peg$FAILED) {
	                            s1 = peg$c71(s5, s9);
	                            s0 = s1;
	                          } else {
	                            peg$currPos = s0;
	                            s0 = peg$FAILED;
	                          }
	                        } else {
	                          peg$currPos = s0;
	                          s0 = peg$FAILED;
	                        }
	                      } else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                      }
	                    } else {
	                      peg$currPos = s0;
	                      s0 = peg$FAILED;
	                    }
	                  } else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                  }
	                } else {
	                  peg$currPos = s0;
	                  s0 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        }
	      }

	      return s0;
	    }

	    function peg$parseNodeElIfGroup() {
	      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12;

	      s0 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 35) {
	        s1 = peg$c4;
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c5); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parse_();
	        if (s2 !== peg$FAILED) {
	          if (input.substr(peg$currPos, 9) === peg$c72) {
	            s3 = peg$c72;
	            peg$currPos += 9;
	          } else {
	            s3 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c73); }
	          }
	          if (s3 !== peg$FAILED) {
	            s4 = peg$parseMSS();
	            if (s4 !== peg$FAILED) {
	              s5 = peg$parsePPExpression();
	              if (s5 !== peg$FAILED) {
	                s6 = peg$parse_();
	                if (s6 !== peg$FAILED) {
	                  s7 = peg$parseLineTerminatorSequence();
	                  if (s7 !== peg$FAILED) {
	                    s8 = peg$parse__();
	                    if (s8 !== peg$FAILED) {
	                      s9 = [];
	                      s10 = peg$currPos;
	                      s11 = peg$parseNodeStatement();
	                      if (s11 !== peg$FAILED) {
	                        s12 = peg$parse__();
	                        if (s12 !== peg$FAILED) {
	                          s11 = [s11, s12];
	                          s10 = s11;
	                        } else {
	                          peg$currPos = s10;
	                          s10 = peg$FAILED;
	                        }
	                      } else {
	                        peg$currPos = s10;
	                        s10 = peg$FAILED;
	                      }
	                      while (s10 !== peg$FAILED) {
	                        s9.push(s10);
	                        s10 = peg$currPos;
	                        s11 = peg$parseNodeStatement();
	                        if (s11 !== peg$FAILED) {
	                          s12 = peg$parse__();
	                          if (s12 !== peg$FAILED) {
	                            s11 = [s11, s12];
	                            s10 = s11;
	                          } else {
	                            peg$currPos = s10;
	                            s10 = peg$FAILED;
	                          }
	                        } else {
	                          peg$currPos = s10;
	                          s10 = peg$FAILED;
	                        }
	                      }
	                      if (s9 !== peg$FAILED) {
	                        s10 = peg$parse__();
	                        if (s10 !== peg$FAILED) {
	                          s1 = peg$c74(s5, s9);
	                          s0 = s1;
	                        } else {
	                          peg$currPos = s0;
	                          s0 = peg$FAILED;
	                        }
	                      } else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                      }
	                    } else {
	                      peg$currPos = s0;
	                      s0 = peg$FAILED;
	                    }
	                  } else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                  }
	                } else {
	                  peg$currPos = s0;
	                  s0 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseNodeElseGroup() {
	      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;

	      s0 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 35) {
	        s1 = peg$c4;
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c5); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parse_();
	        if (s2 !== peg$FAILED) {
	          if (input.substr(peg$currPos, 9) === peg$c75) {
	            s3 = peg$c75;
	            peg$currPos += 9;
	          } else {
	            s3 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c76); }
	          }
	          if (s3 !== peg$FAILED) {
	            s4 = peg$parse_();
	            if (s4 !== peg$FAILED) {
	              s5 = peg$parseLineTerminatorSequence();
	              if (s5 !== peg$FAILED) {
	                s6 = peg$parse__();
	                if (s6 !== peg$FAILED) {
	                  s7 = [];
	                  s8 = peg$currPos;
	                  s9 = peg$parseNodeStatement();
	                  if (s9 !== peg$FAILED) {
	                    s10 = peg$parse__();
	                    if (s10 !== peg$FAILED) {
	                      s9 = [s9, s10];
	                      s8 = s9;
	                    } else {
	                      peg$currPos = s8;
	                      s8 = peg$FAILED;
	                    }
	                  } else {
	                    peg$currPos = s8;
	                    s8 = peg$FAILED;
	                  }
	                  while (s8 !== peg$FAILED) {
	                    s7.push(s8);
	                    s8 = peg$currPos;
	                    s9 = peg$parseNodeStatement();
	                    if (s9 !== peg$FAILED) {
	                      s10 = peg$parse__();
	                      if (s10 !== peg$FAILED) {
	                        s9 = [s9, s10];
	                        s8 = s9;
	                      } else {
	                        peg$currPos = s8;
	                        s8 = peg$FAILED;
	                      }
	                    } else {
	                      peg$currPos = s8;
	                      s8 = peg$FAILED;
	                    }
	                  }
	                  if (s7 !== peg$FAILED) {
	                    s1 = peg$c77(s7);
	                    s0 = s1;
	                  } else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                  }
	                } else {
	                  peg$currPos = s0;
	                  s0 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseNodeEndIfLine() {
	      var s0, s1, s2, s3, s4, s5;

	      s0 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 35) {
	        s1 = peg$c4;
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c5); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parse_();
	        if (s2 !== peg$FAILED) {
	          if (input.substr(peg$currPos, 10) === peg$c78) {
	            s3 = peg$c78;
	            peg$currPos += 10;
	          } else {
	            s3 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c79); }
	          }
	          if (s3 !== peg$FAILED) {
	            s4 = peg$parse_();
	            if (s4 !== peg$FAILED) {
	              s5 = peg$parseLineTerminatorSequenceEOF();
	              if (s5 !== peg$FAILED) {
	                s1 = [s1, s2, s3, s4, s5];
	                s0 = s1;
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseNodeInLine() {
	      var s0, s1, s2, s3, s4, s5, s6, s7;

	      s0 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 35) {
	        s1 = peg$c4;
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c5); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parse_();
	        if (s2 !== peg$FAILED) {
	          if (input.substr(peg$currPos, 7) === peg$c80) {
	            s3 = peg$c80;
	            peg$currPos += 7;
	          } else {
	            s3 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c81); }
	          }
	          if (s3 !== peg$FAILED) {
	            s4 = peg$currPos;
	            s5 = peg$parseMSS();
	            if (s5 !== peg$FAILED) {
	              if (input.substr(peg$currPos, 8) === peg$c82) {
	                s6 = peg$c82;
	                peg$currPos += 8;
	              } else {
	                s6 = peg$FAILED;
	                if (peg$silentFails === 0) { peg$fail(peg$c83); }
	              }
	              if (s6 !== peg$FAILED) {
	                s5 = [s5, s6];
	                s4 = s5;
	              } else {
	                peg$currPos = s4;
	                s4 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s4;
	              s4 = peg$FAILED;
	            }
	            if (s4 === peg$FAILED) {
	              s4 = null;
	            }
	            if (s4 !== peg$FAILED) {
	              s5 = peg$currPos;
	              s6 = peg$parseMSS();
	              if (s6 !== peg$FAILED) {
	                s7 = peg$parseTokens();
	                if (s7 !== peg$FAILED) {
	                  s6 = [s6, s7];
	                  s5 = s6;
	                } else {
	                  peg$currPos = s5;
	                  s5 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s5;
	                s5 = peg$FAILED;
	              }
	              if (s5 === peg$FAILED) {
	                s5 = null;
	              }
	              if (s5 !== peg$FAILED) {
	                s6 = peg$parse_();
	                if (s6 !== peg$FAILED) {
	                  s7 = peg$parseLineTerminatorSequence();
	                  if (s7 !== peg$FAILED) {
	                    s1 = peg$c84(s4, s5);
	                    s0 = s1;
	                  } else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                  }
	                } else {
	                  peg$currPos = s0;
	                  s0 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseNodeOutLine() {
	      var s0, s1, s2, s3, s4, s5, s6, s7;

	      s0 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 35) {
	        s1 = peg$c4;
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c5); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parse_();
	        if (s2 !== peg$FAILED) {
	          if (input.substr(peg$currPos, 8) === peg$c85) {
	            s3 = peg$c85;
	            peg$currPos += 8;
	          } else {
	            s3 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c86); }
	          }
	          if (s3 !== peg$FAILED) {
	            s4 = peg$currPos;
	            s5 = peg$parseMSS();
	            if (s5 !== peg$FAILED) {
	              if (input.substr(peg$currPos, 8) === peg$c82) {
	                s6 = peg$c82;
	                peg$currPos += 8;
	              } else {
	                s6 = peg$FAILED;
	                if (peg$silentFails === 0) { peg$fail(peg$c83); }
	              }
	              if (s6 !== peg$FAILED) {
	                s5 = [s5, s6];
	                s4 = s5;
	              } else {
	                peg$currPos = s4;
	                s4 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s4;
	              s4 = peg$FAILED;
	            }
	            if (s4 === peg$FAILED) {
	              s4 = null;
	            }
	            if (s4 !== peg$FAILED) {
	              s5 = peg$currPos;
	              s6 = peg$parseMSS();
	              if (s6 !== peg$FAILED) {
	                s7 = peg$parseTokens();
	                if (s7 !== peg$FAILED) {
	                  s6 = [s6, s7];
	                  s5 = s6;
	                } else {
	                  peg$currPos = s5;
	                  s5 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s5;
	                s5 = peg$FAILED;
	              }
	              if (s5 === peg$FAILED) {
	                s5 = null;
	              }
	              if (s5 !== peg$FAILED) {
	                s6 = peg$parse_();
	                if (s6 !== peg$FAILED) {
	                  s7 = peg$parseLineTerminatorSequence();
	                  if (s7 !== peg$FAILED) {
	                    s1 = peg$c87(s4, s5);
	                    s0 = s1;
	                  } else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                  }
	                } else {
	                  peg$currPos = s0;
	                  s0 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseNodeParamLine() {
	      var s0, s1, s2, s3, s4, s5, s6, s7;

	      s0 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 35) {
	        s1 = peg$c4;
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c5); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parse_();
	        if (s2 !== peg$FAILED) {
	          if (input.substr(peg$currPos, 10) === peg$c88) {
	            s3 = peg$c88;
	            peg$currPos += 10;
	          } else {
	            s3 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c89); }
	          }
	          if (s3 !== peg$FAILED) {
	            s4 = peg$currPos;
	            s5 = peg$parseMSS();
	            if (s5 !== peg$FAILED) {
	              if (input.substr(peg$currPos, 8) === peg$c82) {
	                s6 = peg$c82;
	                peg$currPos += 8;
	              } else {
	                s6 = peg$FAILED;
	                if (peg$silentFails === 0) { peg$fail(peg$c83); }
	              }
	              if (s6 !== peg$FAILED) {
	                s5 = [s5, s6];
	                s4 = s5;
	              } else {
	                peg$currPos = s4;
	                s4 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s4;
	              s4 = peg$FAILED;
	            }
	            if (s4 === peg$FAILED) {
	              s4 = null;
	            }
	            if (s4 !== peg$FAILED) {
	              s5 = peg$currPos;
	              s6 = peg$parseMSS();
	              if (s6 !== peg$FAILED) {
	                s7 = peg$parseTokens();
	                if (s7 !== peg$FAILED) {
	                  s6 = [s6, s7];
	                  s5 = s6;
	                } else {
	                  peg$currPos = s5;
	                  s5 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s5;
	                s5 = peg$FAILED;
	              }
	              if (s5 === peg$FAILED) {
	                s5 = null;
	              }
	              if (s5 !== peg$FAILED) {
	                s6 = peg$parse_();
	                if (s6 !== peg$FAILED) {
	                  s7 = peg$parseLineTerminatorSequence();
	                  if (s7 !== peg$FAILED) {
	                    s1 = peg$c90(s4, s5);
	                    s0 = s1;
	                  } else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                  }
	                } else {
	                  peg$currPos = s0;
	                  s0 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseNodesGlobalLine() {
	      var s0, s1, s2, s3, s4, s5;

	      s0 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 35) {
	        s1 = peg$c4;
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c5); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parse_();
	        if (s2 !== peg$FAILED) {
	          if (input.substr(peg$currPos, 12) === peg$c91) {
	            s3 = peg$c91;
	            peg$currPos += 12;
	          } else {
	            s3 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c92); }
	          }
	          if (s3 !== peg$FAILED) {
	            s4 = peg$parse_();
	            if (s4 !== peg$FAILED) {
	              s5 = peg$parseLineTerminatorSequenceEOF();
	              if (s5 !== peg$FAILED) {
	                s1 = peg$c93();
	                s0 = s1;
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseNodesMainLine() {
	      var s0, s1, s2, s3, s4, s5;

	      s0 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 35) {
	        s1 = peg$c4;
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c5); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parse_();
	        if (s2 !== peg$FAILED) {
	          if (input.substr(peg$currPos, 10) === peg$c94) {
	            s3 = peg$c94;
	            peg$currPos += 10;
	          } else {
	            s3 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c95); }
	          }
	          if (s3 !== peg$FAILED) {
	            s4 = peg$parse_();
	            if (s4 !== peg$FAILED) {
	              s5 = peg$parseLineTerminatorSequenceEOF();
	              if (s5 !== peg$FAILED) {
	                s1 = peg$c96();
	                s0 = s1;
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseTextLine() {
	      var s0, s1;

	      s0 = peg$currPos;
	      s1 = peg$parseTokens();
	      if (s1 !== peg$FAILED) {
	        s1 = peg$c97(s1);
	      }
	      s0 = s1;

	      return s0;
	    }

	    function peg$parseTokens() {
	      var s0, s1, s2, s3, s4, s5;

	      s0 = peg$currPos;
	      s1 = peg$parseToken();
	      if (s1 !== peg$FAILED) {
	        s2 = [];
	        s3 = peg$currPos;
	        s4 = peg$parse_();
	        if (s4 !== peg$FAILED) {
	          s5 = peg$parseToken();
	          if (s5 !== peg$FAILED) {
	            s4 = [s4, s5];
	            s3 = s4;
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s3;
	          s3 = peg$FAILED;
	        }
	        while (s3 !== peg$FAILED) {
	          s2.push(s3);
	          s3 = peg$currPos;
	          s4 = peg$parse_();
	          if (s4 !== peg$FAILED) {
	            s5 = peg$parseToken();
	            if (s5 !== peg$FAILED) {
	              s4 = [s4, s5];
	              s3 = s4;
	            } else {
	              peg$currPos = s3;
	              s3 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = peg$c2(s1, s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parsePPExpression() {
	      var s0, s1, s2, s3, s4, s5, s6, s7;

	      s0 = peg$currPos;
	      s1 = peg$parseConditionalExpression();
	      if (s1 !== peg$FAILED) {
	        s2 = [];
	        s3 = peg$currPos;
	        s4 = peg$parse_();
	        if (s4 !== peg$FAILED) {
	          if (input.charCodeAt(peg$currPos) === 44) {
	            s5 = peg$c98;
	            peg$currPos++;
	          } else {
	            s5 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c99); }
	          }
	          if (s5 !== peg$FAILED) {
	            s6 = peg$parse_();
	            if (s6 !== peg$FAILED) {
	              s7 = peg$parseConditionalExpression();
	              if (s7 !== peg$FAILED) {
	                s4 = [s4, s5, s6, s7];
	                s3 = s4;
	              } else {
	                peg$currPos = s3;
	                s3 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s3;
	              s3 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s3;
	          s3 = peg$FAILED;
	        }
	        while (s3 !== peg$FAILED) {
	          s2.push(s3);
	          s3 = peg$currPos;
	          s4 = peg$parse_();
	          if (s4 !== peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 44) {
	              s5 = peg$c98;
	              peg$currPos++;
	            } else {
	              s5 = peg$FAILED;
	              if (peg$silentFails === 0) { peg$fail(peg$c99); }
	            }
	            if (s5 !== peg$FAILED) {
	              s6 = peg$parse_();
	              if (s6 !== peg$FAILED) {
	                s7 = peg$parseConditionalExpression();
	                if (s7 !== peg$FAILED) {
	                  s4 = [s4, s5, s6, s7];
	                  s3 = s4;
	                } else {
	                  peg$currPos = s3;
	                  s3 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s3;
	                s3 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s3;
	              s3 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = peg$c100(s1, s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseConditionalExpression() {
	      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

	      s0 = peg$currPos;
	      s1 = peg$parseLogicalORExpression();
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parse_();
	        if (s2 !== peg$FAILED) {
	          if (input.charCodeAt(peg$currPos) === 63) {
	            s3 = peg$c101;
	            peg$currPos++;
	          } else {
	            s3 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c102); }
	          }
	          if (s3 !== peg$FAILED) {
	            s4 = peg$parse_();
	            if (s4 !== peg$FAILED) {
	              s5 = peg$parsePPExpression();
	              if (s5 !== peg$FAILED) {
	                s6 = peg$parse_();
	                if (s6 !== peg$FAILED) {
	                  if (input.charCodeAt(peg$currPos) === 58) {
	                    s7 = peg$c103;
	                    peg$currPos++;
	                  } else {
	                    s7 = peg$FAILED;
	                    if (peg$silentFails === 0) { peg$fail(peg$c104); }
	                  }
	                  if (s7 !== peg$FAILED) {
	                    s8 = peg$parse_();
	                    if (s8 !== peg$FAILED) {
	                      s9 = peg$parsePPExpression();
	                      if (s9 !== peg$FAILED) {
	                        s1 = peg$c105(s1, s5, s9);
	                        s0 = s1;
	                      } else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                      }
	                    } else {
	                      peg$currPos = s0;
	                      s0 = peg$FAILED;
	                    }
	                  } else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                  }
	                } else {
	                  peg$currPos = s0;
	                  s0 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	      if (s0 === peg$FAILED) {
	        s0 = peg$parseLogicalORExpression();
	      }

	      return s0;
	    }

	    function peg$parseLogicalORExpression() {
	      var s0, s1, s2, s3, s4, s5, s6, s7;

	      s0 = peg$currPos;
	      s1 = peg$parseLogicalANDExpression();
	      if (s1 !== peg$FAILED) {
	        s2 = [];
	        s3 = peg$currPos;
	        s4 = peg$parse_();
	        if (s4 !== peg$FAILED) {
	          s5 = peg$parseLogicalOROperator();
	          if (s5 !== peg$FAILED) {
	            s6 = peg$parse_();
	            if (s6 !== peg$FAILED) {
	              s7 = peg$parseLogicalANDExpression();
	              if (s7 !== peg$FAILED) {
	                s4 = [s4, s5, s6, s7];
	                s3 = s4;
	              } else {
	                peg$currPos = s3;
	                s3 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s3;
	              s3 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s3;
	          s3 = peg$FAILED;
	        }
	        while (s3 !== peg$FAILED) {
	          s2.push(s3);
	          s3 = peg$currPos;
	          s4 = peg$parse_();
	          if (s4 !== peg$FAILED) {
	            s5 = peg$parseLogicalOROperator();
	            if (s5 !== peg$FAILED) {
	              s6 = peg$parse_();
	              if (s6 !== peg$FAILED) {
	                s7 = peg$parseLogicalANDExpression();
	                if (s7 !== peg$FAILED) {
	                  s4 = [s4, s5, s6, s7];
	                  s3 = s4;
	                } else {
	                  peg$currPos = s3;
	                  s3 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s3;
	                s3 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s3;
	              s3 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = peg$c106(s1, s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseLogicalANDExpression() {
	      var s0, s1, s2, s3, s4, s5, s6, s7;

	      s0 = peg$currPos;
	      s1 = peg$parseBitwiseORExpression();
	      if (s1 !== peg$FAILED) {
	        s2 = [];
	        s3 = peg$currPos;
	        s4 = peg$parse_();
	        if (s4 !== peg$FAILED) {
	          s5 = peg$parseLogicalANDOperator();
	          if (s5 !== peg$FAILED) {
	            s6 = peg$parse_();
	            if (s6 !== peg$FAILED) {
	              s7 = peg$parseBitwiseORExpression();
	              if (s7 !== peg$FAILED) {
	                s4 = [s4, s5, s6, s7];
	                s3 = s4;
	              } else {
	                peg$currPos = s3;
	                s3 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s3;
	              s3 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s3;
	          s3 = peg$FAILED;
	        }
	        while (s3 !== peg$FAILED) {
	          s2.push(s3);
	          s3 = peg$currPos;
	          s4 = peg$parse_();
	          if (s4 !== peg$FAILED) {
	            s5 = peg$parseLogicalANDOperator();
	            if (s5 !== peg$FAILED) {
	              s6 = peg$parse_();
	              if (s6 !== peg$FAILED) {
	                s7 = peg$parseBitwiseORExpression();
	                if (s7 !== peg$FAILED) {
	                  s4 = [s4, s5, s6, s7];
	                  s3 = s4;
	                } else {
	                  peg$currPos = s3;
	                  s3 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s3;
	                s3 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s3;
	              s3 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = peg$c107(s1, s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseBitwiseORExpression() {
	      var s0, s1, s2, s3, s4, s5, s6, s7;

	      s0 = peg$currPos;
	      s1 = peg$parseBitwiseXORExpression();
	      if (s1 !== peg$FAILED) {
	        s2 = [];
	        s3 = peg$currPos;
	        s4 = peg$parse_();
	        if (s4 !== peg$FAILED) {
	          s5 = peg$parseBitwiseOROperator();
	          if (s5 !== peg$FAILED) {
	            s6 = peg$parse_();
	            if (s6 !== peg$FAILED) {
	              s7 = peg$parseBitwiseXORExpression();
	              if (s7 !== peg$FAILED) {
	                s4 = [s4, s5, s6, s7];
	                s3 = s4;
	              } else {
	                peg$currPos = s3;
	                s3 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s3;
	              s3 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s3;
	          s3 = peg$FAILED;
	        }
	        while (s3 !== peg$FAILED) {
	          s2.push(s3);
	          s3 = peg$currPos;
	          s4 = peg$parse_();
	          if (s4 !== peg$FAILED) {
	            s5 = peg$parseBitwiseOROperator();
	            if (s5 !== peg$FAILED) {
	              s6 = peg$parse_();
	              if (s6 !== peg$FAILED) {
	                s7 = peg$parseBitwiseXORExpression();
	                if (s7 !== peg$FAILED) {
	                  s4 = [s4, s5, s6, s7];
	                  s3 = s4;
	                } else {
	                  peg$currPos = s3;
	                  s3 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s3;
	                s3 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s3;
	              s3 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = peg$c108(s1, s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseBitwiseXORExpression() {
	      var s0, s1, s2, s3, s4, s5, s6, s7;

	      s0 = peg$currPos;
	      s1 = peg$parseBitwiseANDExpression();
	      if (s1 !== peg$FAILED) {
	        s2 = [];
	        s3 = peg$currPos;
	        s4 = peg$parse_();
	        if (s4 !== peg$FAILED) {
	          s5 = peg$parseBitwiseXOROperator();
	          if (s5 !== peg$FAILED) {
	            s6 = peg$parse_();
	            if (s6 !== peg$FAILED) {
	              s7 = peg$parseBitwiseANDExpression();
	              if (s7 !== peg$FAILED) {
	                s4 = [s4, s5, s6, s7];
	                s3 = s4;
	              } else {
	                peg$currPos = s3;
	                s3 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s3;
	              s3 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s3;
	          s3 = peg$FAILED;
	        }
	        while (s3 !== peg$FAILED) {
	          s2.push(s3);
	          s3 = peg$currPos;
	          s4 = peg$parse_();
	          if (s4 !== peg$FAILED) {
	            s5 = peg$parseBitwiseXOROperator();
	            if (s5 !== peg$FAILED) {
	              s6 = peg$parse_();
	              if (s6 !== peg$FAILED) {
	                s7 = peg$parseBitwiseANDExpression();
	                if (s7 !== peg$FAILED) {
	                  s4 = [s4, s5, s6, s7];
	                  s3 = s4;
	                } else {
	                  peg$currPos = s3;
	                  s3 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s3;
	                s3 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s3;
	              s3 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = peg$c109(s1, s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseBitwiseANDExpression() {
	      var s0, s1, s2, s3, s4, s5, s6, s7;

	      s0 = peg$currPos;
	      s1 = peg$parseEqualityExpression();
	      if (s1 !== peg$FAILED) {
	        s2 = [];
	        s3 = peg$currPos;
	        s4 = peg$parse_();
	        if (s4 !== peg$FAILED) {
	          s5 = peg$parseBitwiseANDOperator();
	          if (s5 !== peg$FAILED) {
	            s6 = peg$parse_();
	            if (s6 !== peg$FAILED) {
	              s7 = peg$parseEqualityExpression();
	              if (s7 !== peg$FAILED) {
	                s4 = [s4, s5, s6, s7];
	                s3 = s4;
	              } else {
	                peg$currPos = s3;
	                s3 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s3;
	              s3 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s3;
	          s3 = peg$FAILED;
	        }
	        while (s3 !== peg$FAILED) {
	          s2.push(s3);
	          s3 = peg$currPos;
	          s4 = peg$parse_();
	          if (s4 !== peg$FAILED) {
	            s5 = peg$parseBitwiseANDOperator();
	            if (s5 !== peg$FAILED) {
	              s6 = peg$parse_();
	              if (s6 !== peg$FAILED) {
	                s7 = peg$parseEqualityExpression();
	                if (s7 !== peg$FAILED) {
	                  s4 = [s4, s5, s6, s7];
	                  s3 = s4;
	                } else {
	                  peg$currPos = s3;
	                  s3 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s3;
	                s3 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s3;
	              s3 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = peg$c110(s1, s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseEqualityExpression() {
	      var s0, s1, s2, s3, s4, s5, s6, s7;

	      s0 = peg$currPos;
	      s1 = peg$parseRelationalExpression();
	      if (s1 !== peg$FAILED) {
	        s2 = [];
	        s3 = peg$currPos;
	        s4 = peg$parse_();
	        if (s4 !== peg$FAILED) {
	          s5 = peg$parseEqualityOperator();
	          if (s5 !== peg$FAILED) {
	            s6 = peg$parse_();
	            if (s6 !== peg$FAILED) {
	              s7 = peg$parseRelationalExpression();
	              if (s7 !== peg$FAILED) {
	                s4 = [s4, s5, s6, s7];
	                s3 = s4;
	              } else {
	                peg$currPos = s3;
	                s3 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s3;
	              s3 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s3;
	          s3 = peg$FAILED;
	        }
	        while (s3 !== peg$FAILED) {
	          s2.push(s3);
	          s3 = peg$currPos;
	          s4 = peg$parse_();
	          if (s4 !== peg$FAILED) {
	            s5 = peg$parseEqualityOperator();
	            if (s5 !== peg$FAILED) {
	              s6 = peg$parse_();
	              if (s6 !== peg$FAILED) {
	                s7 = peg$parseRelationalExpression();
	                if (s7 !== peg$FAILED) {
	                  s4 = [s4, s5, s6, s7];
	                  s3 = s4;
	                } else {
	                  peg$currPos = s3;
	                  s3 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s3;
	                s3 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s3;
	              s3 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = peg$c111(s1, s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseRelationalExpression() {
	      var s0, s1, s2, s3, s4, s5, s6, s7;

	      s0 = peg$currPos;
	      s1 = peg$parseShiftExpression();
	      if (s1 !== peg$FAILED) {
	        s2 = [];
	        s3 = peg$currPos;
	        s4 = peg$parse_();
	        if (s4 !== peg$FAILED) {
	          s5 = peg$parseRelationalOperator();
	          if (s5 !== peg$FAILED) {
	            s6 = peg$parse_();
	            if (s6 !== peg$FAILED) {
	              s7 = peg$parseShiftExpression();
	              if (s7 !== peg$FAILED) {
	                s4 = [s4, s5, s6, s7];
	                s3 = s4;
	              } else {
	                peg$currPos = s3;
	                s3 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s3;
	              s3 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s3;
	          s3 = peg$FAILED;
	        }
	        while (s3 !== peg$FAILED) {
	          s2.push(s3);
	          s3 = peg$currPos;
	          s4 = peg$parse_();
	          if (s4 !== peg$FAILED) {
	            s5 = peg$parseRelationalOperator();
	            if (s5 !== peg$FAILED) {
	              s6 = peg$parse_();
	              if (s6 !== peg$FAILED) {
	                s7 = peg$parseShiftExpression();
	                if (s7 !== peg$FAILED) {
	                  s4 = [s4, s5, s6, s7];
	                  s3 = s4;
	                } else {
	                  peg$currPos = s3;
	                  s3 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s3;
	                s3 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s3;
	              s3 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = peg$c112(s1, s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseShiftExpression() {
	      var s0, s1, s2, s3, s4, s5, s6, s7;

	      s0 = peg$currPos;
	      s1 = peg$parseAdditiveExpression();
	      if (s1 !== peg$FAILED) {
	        s2 = [];
	        s3 = peg$currPos;
	        s4 = peg$parse_();
	        if (s4 !== peg$FAILED) {
	          s5 = peg$parseShiftOperator();
	          if (s5 !== peg$FAILED) {
	            s6 = peg$parse_();
	            if (s6 !== peg$FAILED) {
	              s7 = peg$parseAdditiveExpression();
	              if (s7 !== peg$FAILED) {
	                s4 = [s4, s5, s6, s7];
	                s3 = s4;
	              } else {
	                peg$currPos = s3;
	                s3 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s3;
	              s3 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s3;
	          s3 = peg$FAILED;
	        }
	        while (s3 !== peg$FAILED) {
	          s2.push(s3);
	          s3 = peg$currPos;
	          s4 = peg$parse_();
	          if (s4 !== peg$FAILED) {
	            s5 = peg$parseShiftOperator();
	            if (s5 !== peg$FAILED) {
	              s6 = peg$parse_();
	              if (s6 !== peg$FAILED) {
	                s7 = peg$parseAdditiveExpression();
	                if (s7 !== peg$FAILED) {
	                  s4 = [s4, s5, s6, s7];
	                  s3 = s4;
	                } else {
	                  peg$currPos = s3;
	                  s3 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s3;
	                s3 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s3;
	              s3 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = peg$c113(s1, s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseAdditiveExpression() {
	      var s0, s1, s2, s3, s4, s5, s6, s7;

	      s0 = peg$currPos;
	      s1 = peg$parseMultiplicativeExpression();
	      if (s1 !== peg$FAILED) {
	        s2 = [];
	        s3 = peg$currPos;
	        s4 = peg$parse_();
	        if (s4 !== peg$FAILED) {
	          s5 = peg$parseAdditiveOperator();
	          if (s5 !== peg$FAILED) {
	            s6 = peg$parse_();
	            if (s6 !== peg$FAILED) {
	              s7 = peg$parseMultiplicativeExpression();
	              if (s7 !== peg$FAILED) {
	                s4 = [s4, s5, s6, s7];
	                s3 = s4;
	              } else {
	                peg$currPos = s3;
	                s3 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s3;
	              s3 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s3;
	          s3 = peg$FAILED;
	        }
	        while (s3 !== peg$FAILED) {
	          s2.push(s3);
	          s3 = peg$currPos;
	          s4 = peg$parse_();
	          if (s4 !== peg$FAILED) {
	            s5 = peg$parseAdditiveOperator();
	            if (s5 !== peg$FAILED) {
	              s6 = peg$parse_();
	              if (s6 !== peg$FAILED) {
	                s7 = peg$parseMultiplicativeExpression();
	                if (s7 !== peg$FAILED) {
	                  s4 = [s4, s5, s6, s7];
	                  s3 = s4;
	                } else {
	                  peg$currPos = s3;
	                  s3 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s3;
	                s3 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s3;
	              s3 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = peg$c114(s1, s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseMultiplicativeExpression() {
	      var s0, s1, s2, s3, s4, s5, s6, s7;

	      s0 = peg$currPos;
	      s1 = peg$parseUnaryExpression();
	      if (s1 !== peg$FAILED) {
	        s2 = [];
	        s3 = peg$currPos;
	        s4 = peg$parse_();
	        if (s4 !== peg$FAILED) {
	          s5 = peg$parseMultiplicativeOperator();
	          if (s5 !== peg$FAILED) {
	            s6 = peg$parse_();
	            if (s6 !== peg$FAILED) {
	              s7 = peg$parseUnaryExpression();
	              if (s7 !== peg$FAILED) {
	                s4 = [s4, s5, s6, s7];
	                s3 = s4;
	              } else {
	                peg$currPos = s3;
	                s3 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s3;
	              s3 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s3;
	          s3 = peg$FAILED;
	        }
	        while (s3 !== peg$FAILED) {
	          s2.push(s3);
	          s3 = peg$currPos;
	          s4 = peg$parse_();
	          if (s4 !== peg$FAILED) {
	            s5 = peg$parseMultiplicativeOperator();
	            if (s5 !== peg$FAILED) {
	              s6 = peg$parse_();
	              if (s6 !== peg$FAILED) {
	                s7 = peg$parseUnaryExpression();
	                if (s7 !== peg$FAILED) {
	                  s4 = [s4, s5, s6, s7];
	                  s3 = s4;
	                } else {
	                  peg$currPos = s3;
	                  s3 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s3;
	                s3 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s3;
	              s3 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = peg$c115(s1, s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseUnaryExpression() {
	      var s0, s1, s2, s3;

	      s0 = peg$currPos;
	      if (input.substr(peg$currPos, 7) === peg$c116) {
	        s1 = peg$c116;
	        peg$currPos += 7;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c117); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parse_();
	        if (s2 !== peg$FAILED) {
	          s3 = peg$parseDefinedExpression();
	          if (s3 !== peg$FAILED) {
	            s1 = peg$c118(s3);
	            s0 = s1;
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	      if (s0 === peg$FAILED) {
	        s0 = peg$parsePostfixExpression();
	        if (s0 === peg$FAILED) {
	          s0 = peg$currPos;
	          s1 = peg$parseUnaryOperator();
	          if (s1 !== peg$FAILED) {
	            s2 = peg$parse_();
	            if (s2 !== peg$FAILED) {
	              s3 = peg$parseUnaryExpression();
	              if (s3 !== peg$FAILED) {
	                s1 = peg$c119(s1, s3);
	                s0 = s1;
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        }
	      }

	      return s0;
	    }

	    function peg$parsePostfixExpression() {
	      var s0, s1, s2, s3;

	      s0 = peg$currPos;
	      s1 = peg$parsePrimaryExpression();
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parse_();
	        if (s2 !== peg$FAILED) {
	          s3 = peg$parsePostfixOperator();
	          if (s3 !== peg$FAILED) {
	            s1 = peg$c120(s1, s3);
	            s0 = s1;
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	      if (s0 === peg$FAILED) {
	        s0 = peg$parsePrimaryExpression();
	      }

	      return s0;
	    }

	    function peg$parsePrimaryExpression() {
	      var s0, s1, s2, s3, s4, s5;

	      s0 = peg$currPos;
	      s1 = peg$parseNumericLiteral();
	      if (s1 !== peg$FAILED) {
	        s1 = peg$c121(s1);
	      }
	      s0 = s1;
	      if (s0 === peg$FAILED) {
	        s0 = peg$currPos;
	        s1 = peg$parseIdentifier();
	        if (s1 !== peg$FAILED) {
	          s1 = peg$c122(s1);
	        }
	        s0 = s1;
	        if (s0 === peg$FAILED) {
	          s0 = peg$currPos;
	          if (input.charCodeAt(peg$currPos) === 40) {
	            s1 = peg$c123;
	            peg$currPos++;
	          } else {
	            s1 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c124); }
	          }
	          if (s1 !== peg$FAILED) {
	            s2 = peg$parse_();
	            if (s2 !== peg$FAILED) {
	              s3 = peg$parsePPExpression();
	              if (s3 !== peg$FAILED) {
	                s4 = peg$parse_();
	                if (s4 !== peg$FAILED) {
	                  if (input.charCodeAt(peg$currPos) === 41) {
	                    s5 = peg$c125;
	                    peg$currPos++;
	                  } else {
	                    s5 = peg$FAILED;
	                    if (peg$silentFails === 0) { peg$fail(peg$c126); }
	                  }
	                  if (s5 !== peg$FAILED) {
	                    s1 = peg$c127(s3);
	                    s0 = s1;
	                  } else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                  }
	                } else {
	                  peg$currPos = s0;
	                  s0 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        }
	      }

	      return s0;
	    }

	    function peg$parseDefinedExpression() {
	      var s0, s1, s2, s3, s4, s5;

	      s0 = peg$currPos;
	      s1 = peg$parseIdentifier();
	      if (s1 !== peg$FAILED) {
	        s1 = peg$c122(s1);
	      }
	      s0 = s1;
	      if (s0 === peg$FAILED) {
	        s0 = peg$currPos;
	        s1 = [];
	        s2 = peg$currPos;
	        s3 = peg$currPos;
	        peg$silentFails++;
	        if (input.charCodeAt(peg$currPos) === 40) {
	          s4 = peg$c123;
	          peg$currPos++;
	        } else {
	          s4 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c124); }
	        }
	        if (s4 === peg$FAILED) {
	          if (input.charCodeAt(peg$currPos) === 41) {
	            s4 = peg$c125;
	            peg$currPos++;
	          } else {
	            s4 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c126); }
	          }
	        }
	        peg$silentFails--;
	        if (s4 === peg$FAILED) {
	          s3 = void 0;
	        } else {
	          peg$currPos = s3;
	          s3 = peg$FAILED;
	        }
	        if (s3 !== peg$FAILED) {
	          s4 = peg$parseSourceCharacter();
	          if (s4 !== peg$FAILED) {
	            s3 = [s3, s4];
	            s2 = s3;
	          } else {
	            peg$currPos = s2;
	            s2 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s2;
	          s2 = peg$FAILED;
	        }
	        if (s2 !== peg$FAILED) {
	          while (s2 !== peg$FAILED) {
	            s1.push(s2);
	            s2 = peg$currPos;
	            s3 = peg$currPos;
	            peg$silentFails++;
	            if (input.charCodeAt(peg$currPos) === 40) {
	              s4 = peg$c123;
	              peg$currPos++;
	            } else {
	              s4 = peg$FAILED;
	              if (peg$silentFails === 0) { peg$fail(peg$c124); }
	            }
	            if (s4 === peg$FAILED) {
	              if (input.charCodeAt(peg$currPos) === 41) {
	                s4 = peg$c125;
	                peg$currPos++;
	              } else {
	                s4 = peg$FAILED;
	                if (peg$silentFails === 0) { peg$fail(peg$c126); }
	              }
	            }
	            peg$silentFails--;
	            if (s4 === peg$FAILED) {
	              s3 = void 0;
	            } else {
	              peg$currPos = s3;
	              s3 = peg$FAILED;
	            }
	            if (s3 !== peg$FAILED) {
	              s4 = peg$parseSourceCharacter();
	              if (s4 !== peg$FAILED) {
	                s3 = [s3, s4];
	                s2 = s3;
	              } else {
	                peg$currPos = s2;
	                s2 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s2;
	              s2 = peg$FAILED;
	            }
	          }
	        } else {
	          s1 = peg$FAILED;
	        }
	        if (s1 !== peg$FAILED) {
	          s1 = peg$c128();
	        }
	        s0 = s1;
	        if (s0 === peg$FAILED) {
	          s0 = peg$currPos;
	          if (input.charCodeAt(peg$currPos) === 40) {
	            s1 = peg$c123;
	            peg$currPos++;
	          } else {
	            s1 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c124); }
	          }
	          if (s1 !== peg$FAILED) {
	            s2 = peg$parse_();
	            if (s2 !== peg$FAILED) {
	              s3 = peg$parseDefinedExpression();
	              if (s3 !== peg$FAILED) {
	                s4 = peg$parse_();
	                if (s4 !== peg$FAILED) {
	                  if (input.charCodeAt(peg$currPos) === 41) {
	                    s5 = peg$c125;
	                    peg$currPos++;
	                  } else {
	                    s5 = peg$FAILED;
	                    if (peg$silentFails === 0) { peg$fail(peg$c126); }
	                  }
	                  if (s5 !== peg$FAILED) {
	                    s1 = peg$c127(s3);
	                    s0 = s1;
	                  } else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                  }
	                } else {
	                  peg$currPos = s0;
	                  s0 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        }
	      }

	      return s0;
	    }

	    function peg$parseNumericLiteral() {
	      var s0, s1;

	      peg$silentFails++;
	      s0 = peg$currPos;
	      s1 = peg$parseHexIntegerLiteral();
	      if (s1 === peg$FAILED) {
	        s1 = peg$parseIntegerLiteral();
	      }
	      if (s1 !== peg$FAILED) {
	        s1 = peg$c130(s1);
	      }
	      s0 = s1;
	      peg$silentFails--;
	      if (s0 === peg$FAILED) {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c129); }
	      }

	      return s0;
	    }

	    function peg$parseIntegerLiteral() {
	      var s0, s1, s2;

	      s0 = peg$currPos;
	      s1 = peg$currPos;
	      s2 = peg$parseDecimalIntegerLiteral();
	      if (s2 !== peg$FAILED) {
	        s1 = input.substring(s1, peg$currPos);
	      } else {
	        s1 = s2;
	      }
	      if (s1 !== peg$FAILED) {
	        s1 = peg$c131(s1);
	      }
	      s0 = s1;

	      return s0;
	    }

	    function peg$parseIdentifier() {
	      var s0, s1, s2;

	      peg$silentFails++;
	      s0 = peg$currPos;
	      s1 = peg$currPos;
	      peg$silentFails++;
	      s2 = peg$parseReservedWord();
	      peg$silentFails--;
	      if (s2 === peg$FAILED) {
	        s1 = void 0;
	      } else {
	        peg$currPos = s1;
	        s1 = peg$FAILED;
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parseIdentifierName();
	        if (s2 !== peg$FAILED) {
	          s1 = peg$c133(s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	      peg$silentFails--;
	      if (s0 === peg$FAILED) {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c132); }
	      }

	      return s0;
	    }

	    function peg$parseReservedWord() {
	      var s0, s1, s2, s3;

	      s0 = peg$currPos;
	      if (input.substr(peg$currPos, 7) === peg$c116) {
	        s1 = peg$c116;
	        peg$currPos += 7;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c117); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$currPos;
	        peg$silentFails++;
	        s3 = peg$parseIdentifierPart();
	        peg$silentFails--;
	        if (s3 === peg$FAILED) {
	          s2 = void 0;
	        } else {
	          peg$currPos = s2;
	          s2 = peg$FAILED;
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = [s1, s2];
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parsePostfixOperator() {
	      var s0;

	      if (input.substr(peg$currPos, 2) === peg$c134) {
	        s0 = peg$c134;
	        peg$currPos += 2;
	      } else {
	        s0 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c135); }
	      }
	      if (s0 === peg$FAILED) {
	        if (input.substr(peg$currPos, 2) === peg$c136) {
	          s0 = peg$c136;
	          peg$currPos += 2;
	        } else {
	          s0 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c137); }
	        }
	      }

	      return s0;
	    }

	    function peg$parseUnaryOperator() {
	      var s0;

	      if (input.substr(peg$currPos, 2) === peg$c134) {
	        s0 = peg$c134;
	        peg$currPos += 2;
	      } else {
	        s0 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c135); }
	      }
	      if (s0 === peg$FAILED) {
	        if (input.substr(peg$currPos, 2) === peg$c136) {
	          s0 = peg$c136;
	          peg$currPos += 2;
	        } else {
	          s0 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c137); }
	        }
	        if (s0 === peg$FAILED) {
	          if (input.charCodeAt(peg$currPos) === 43) {
	            s0 = peg$c138;
	            peg$currPos++;
	          } else {
	            s0 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c139); }
	          }
	          if (s0 === peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 45) {
	              s0 = peg$c140;
	              peg$currPos++;
	            } else {
	              s0 = peg$FAILED;
	              if (peg$silentFails === 0) { peg$fail(peg$c141); }
	            }
	            if (s0 === peg$FAILED) {
	              if (input.charCodeAt(peg$currPos) === 126) {
	                s0 = peg$c142;
	                peg$currPos++;
	              } else {
	                s0 = peg$FAILED;
	                if (peg$silentFails === 0) { peg$fail(peg$c143); }
	              }
	              if (s0 === peg$FAILED) {
	                if (input.charCodeAt(peg$currPos) === 33) {
	                  s0 = peg$c144;
	                  peg$currPos++;
	                } else {
	                  s0 = peg$FAILED;
	                  if (peg$silentFails === 0) { peg$fail(peg$c145); }
	                }
	              }
	            }
	          }
	        }
	      }

	      return s0;
	    }

	    function peg$parseMultiplicativeOperator() {
	      var s0, s1, s2, s3;

	      s0 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 42) {
	        s1 = peg$c146;
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c147); }
	      }
	      if (s1 === peg$FAILED) {
	        if (input.charCodeAt(peg$currPos) === 47) {
	          s1 = peg$c148;
	          peg$currPos++;
	        } else {
	          s1 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c149); }
	        }
	        if (s1 === peg$FAILED) {
	          if (input.charCodeAt(peg$currPos) === 37) {
	            s1 = peg$c150;
	            peg$currPos++;
	          } else {
	            s1 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c151); }
	          }
	        }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$currPos;
	        peg$silentFails++;
	        if (input.charCodeAt(peg$currPos) === 61) {
	          s3 = peg$c152;
	          peg$currPos++;
	        } else {
	          s3 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c153); }
	        }
	        peg$silentFails--;
	        if (s3 === peg$FAILED) {
	          s2 = void 0;
	        } else {
	          peg$currPos = s2;
	          s2 = peg$FAILED;
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = peg$c154(s1);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseAdditiveOperator() {
	      var s0, s1, s2, s3;

	      s0 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 43) {
	        s1 = peg$c138;
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c139); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$currPos;
	        peg$silentFails++;
	        if (input.charCodeAt(peg$currPos) === 43) {
	          s3 = peg$c138;
	          peg$currPos++;
	        } else {
	          s3 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c139); }
	        }
	        if (s3 === peg$FAILED) {
	          if (input.charCodeAt(peg$currPos) === 61) {
	            s3 = peg$c152;
	            peg$currPos++;
	          } else {
	            s3 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c153); }
	          }
	        }
	        peg$silentFails--;
	        if (s3 === peg$FAILED) {
	          s2 = void 0;
	        } else {
	          peg$currPos = s2;
	          s2 = peg$FAILED;
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = peg$c155();
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	      if (s0 === peg$FAILED) {
	        s0 = peg$currPos;
	        if (input.charCodeAt(peg$currPos) === 45) {
	          s1 = peg$c140;
	          peg$currPos++;
	        } else {
	          s1 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c141); }
	        }
	        if (s1 !== peg$FAILED) {
	          s2 = peg$currPos;
	          peg$silentFails++;
	          if (input.charCodeAt(peg$currPos) === 45) {
	            s3 = peg$c140;
	            peg$currPos++;
	          } else {
	            s3 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c141); }
	          }
	          if (s3 === peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 61) {
	              s3 = peg$c152;
	              peg$currPos++;
	            } else {
	              s3 = peg$FAILED;
	              if (peg$silentFails === 0) { peg$fail(peg$c153); }
	            }
	          }
	          peg$silentFails--;
	          if (s3 === peg$FAILED) {
	            s2 = void 0;
	          } else {
	            peg$currPos = s2;
	            s2 = peg$FAILED;
	          }
	          if (s2 !== peg$FAILED) {
	            s1 = peg$c156();
	            s0 = s1;
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      }

	      return s0;
	    }

	    function peg$parseShiftOperator() {
	      var s0;

	      if (input.substr(peg$currPos, 2) === peg$c157) {
	        s0 = peg$c157;
	        peg$currPos += 2;
	      } else {
	        s0 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c158); }
	      }
	      if (s0 === peg$FAILED) {
	        if (input.substr(peg$currPos, 2) === peg$c159) {
	          s0 = peg$c159;
	          peg$currPos += 2;
	        } else {
	          s0 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c160); }
	        }
	      }

	      return s0;
	    }

	    function peg$parseRelationalOperator() {
	      var s0;

	      if (input.substr(peg$currPos, 2) === peg$c161) {
	        s0 = peg$c161;
	        peg$currPos += 2;
	      } else {
	        s0 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c162); }
	      }
	      if (s0 === peg$FAILED) {
	        if (input.substr(peg$currPos, 2) === peg$c163) {
	          s0 = peg$c163;
	          peg$currPos += 2;
	        } else {
	          s0 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c164); }
	        }
	        if (s0 === peg$FAILED) {
	          if (input.charCodeAt(peg$currPos) === 60) {
	            s0 = peg$c165;
	            peg$currPos++;
	          } else {
	            s0 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c166); }
	          }
	          if (s0 === peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 62) {
	              s0 = peg$c167;
	              peg$currPos++;
	            } else {
	              s0 = peg$FAILED;
	              if (peg$silentFails === 0) { peg$fail(peg$c168); }
	            }
	          }
	        }
	      }

	      return s0;
	    }

	    function peg$parseEqualityOperator() {
	      var s0;

	      if (input.substr(peg$currPos, 2) === peg$c169) {
	        s0 = peg$c169;
	        peg$currPos += 2;
	      } else {
	        s0 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c170); }
	      }
	      if (s0 === peg$FAILED) {
	        if (input.substr(peg$currPos, 2) === peg$c171) {
	          s0 = peg$c171;
	          peg$currPos += 2;
	        } else {
	          s0 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c172); }
	        }
	      }

	      return s0;
	    }

	    function peg$parseBitwiseANDOperator() {
	      var s0, s1, s2, s3;

	      s0 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 38) {
	        s1 = peg$c173;
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c174); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$currPos;
	        peg$silentFails++;
	        if (input.charCodeAt(peg$currPos) === 38) {
	          s3 = peg$c173;
	          peg$currPos++;
	        } else {
	          s3 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c174); }
	        }
	        peg$silentFails--;
	        if (s3 === peg$FAILED) {
	          s2 = void 0;
	        } else {
	          peg$currPos = s2;
	          s2 = peg$FAILED;
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = peg$c175();
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseBitwiseXOROperator() {
	      var s0, s1, s2, s3;

	      s0 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 94) {
	        s1 = peg$c176;
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c177); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$currPos;
	        peg$silentFails++;
	        if (input.charCodeAt(peg$currPos) === 94) {
	          s3 = peg$c176;
	          peg$currPos++;
	        } else {
	          s3 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c177); }
	        }
	        peg$silentFails--;
	        if (s3 === peg$FAILED) {
	          s2 = void 0;
	        } else {
	          peg$currPos = s2;
	          s2 = peg$FAILED;
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = peg$c178();
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseBitwiseOROperator() {
	      var s0, s1, s2, s3;

	      s0 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 124) {
	        s1 = peg$c179;
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c180); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$currPos;
	        peg$silentFails++;
	        if (input.charCodeAt(peg$currPos) === 124) {
	          s3 = peg$c179;
	          peg$currPos++;
	        } else {
	          s3 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c180); }
	        }
	        peg$silentFails--;
	        if (s3 === peg$FAILED) {
	          s2 = void 0;
	        } else {
	          peg$currPos = s2;
	          s2 = peg$FAILED;
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = peg$c181();
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseLogicalANDOperator() {
	      var s0, s1;

	      s0 = peg$currPos;
	      if (input.substr(peg$currPos, 2) === peg$c182) {
	        s1 = peg$c182;
	        peg$currPos += 2;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c183); }
	      }
	      if (s1 !== peg$FAILED) {
	        s1 = peg$c184();
	      }
	      s0 = s1;

	      return s0;
	    }

	    function peg$parseLogicalOROperator() {
	      var s0, s1;

	      s0 = peg$currPos;
	      if (input.substr(peg$currPos, 2) === peg$c185) {
	        s1 = peg$c185;
	        peg$currPos += 2;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c186); }
	      }
	      if (s1 !== peg$FAILED) {
	        s1 = peg$c187();
	      }
	      s0 = s1;

	      return s0;
	    }

	    function peg$parseHeaderFile() {
	      var s0, s1, s2, s3, s4, s5;

	      s0 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 60) {
	        s1 = peg$c165;
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c166); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parse_();
	        if (s2 !== peg$FAILED) {
	          s3 = peg$parseHCharSequence();
	          if (s3 !== peg$FAILED) {
	            s4 = peg$parse_();
	            if (s4 !== peg$FAILED) {
	              if (input.charCodeAt(peg$currPos) === 62) {
	                s5 = peg$c167;
	                peg$currPos++;
	              } else {
	                s5 = peg$FAILED;
	                if (peg$silentFails === 0) { peg$fail(peg$c168); }
	              }
	              if (s5 !== peg$FAILED) {
	                s1 = peg$c133(s3);
	                s0 = s1;
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	      if (s0 === peg$FAILED) {
	        s0 = peg$currPos;
	        if (input.charCodeAt(peg$currPos) === 34) {
	          s1 = peg$c188;
	          peg$currPos++;
	        } else {
	          s1 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c189); }
	        }
	        if (s1 !== peg$FAILED) {
	          s2 = peg$parse_();
	          if (s2 !== peg$FAILED) {
	            s3 = peg$parseQCharSequence();
	            if (s3 !== peg$FAILED) {
	              s4 = peg$parse_();
	              if (s4 !== peg$FAILED) {
	                if (input.charCodeAt(peg$currPos) === 34) {
	                  s5 = peg$c188;
	                  peg$currPos++;
	                } else {
	                  s5 = peg$FAILED;
	                  if (peg$silentFails === 0) { peg$fail(peg$c189); }
	                }
	                if (s5 !== peg$FAILED) {
	                  s1 = peg$c133(s3);
	                  s0 = s1;
	                } else {
	                  peg$currPos = s0;
	                  s0 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      }

	      return s0;
	    }

	    function peg$parseHCharSequence() {
	      var s0, s1, s2, s3, s4;

	      s0 = peg$currPos;
	      s1 = [];
	      s2 = peg$currPos;
	      s3 = peg$currPos;
	      peg$silentFails++;
	      s4 = peg$parseLineTerminatorSequenceEOF();
	      if (s4 === peg$FAILED) {
	        if (input.charCodeAt(peg$currPos) === 62) {
	          s4 = peg$c167;
	          peg$currPos++;
	        } else {
	          s4 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c168); }
	        }
	      }
	      peg$silentFails--;
	      if (s4 === peg$FAILED) {
	        s3 = void 0;
	      } else {
	        peg$currPos = s3;
	        s3 = peg$FAILED;
	      }
	      if (s3 !== peg$FAILED) {
	        s4 = peg$parseSourceCharacter();
	        if (s4 !== peg$FAILED) {
	          s3 = [s3, s4];
	          s2 = s3;
	        } else {
	          peg$currPos = s2;
	          s2 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s2;
	        s2 = peg$FAILED;
	      }
	      while (s2 !== peg$FAILED) {
	        s1.push(s2);
	        s2 = peg$currPos;
	        s3 = peg$currPos;
	        peg$silentFails++;
	        s4 = peg$parseLineTerminatorSequenceEOF();
	        if (s4 === peg$FAILED) {
	          if (input.charCodeAt(peg$currPos) === 62) {
	            s4 = peg$c167;
	            peg$currPos++;
	          } else {
	            s4 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c168); }
	          }
	        }
	        peg$silentFails--;
	        if (s4 === peg$FAILED) {
	          s3 = void 0;
	        } else {
	          peg$currPos = s3;
	          s3 = peg$FAILED;
	        }
	        if (s3 !== peg$FAILED) {
	          s4 = peg$parseSourceCharacter();
	          if (s4 !== peg$FAILED) {
	            s3 = [s3, s4];
	            s2 = s3;
	          } else {
	            peg$currPos = s2;
	            s2 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s2;
	          s2 = peg$FAILED;
	        }
	      }
	      if (s1 !== peg$FAILED) {
	        s1 = peg$c190(s1);
	      }
	      s0 = s1;

	      return s0;
	    }

	    function peg$parseQCharSequence() {
	      var s0, s1, s2, s3, s4;

	      s0 = peg$currPos;
	      s1 = [];
	      s2 = peg$currPos;
	      s3 = peg$currPos;
	      peg$silentFails++;
	      s4 = peg$parseLineTerminatorSequenceEOF();
	      if (s4 === peg$FAILED) {
	        if (input.charCodeAt(peg$currPos) === 34) {
	          s4 = peg$c188;
	          peg$currPos++;
	        } else {
	          s4 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c189); }
	        }
	      }
	      peg$silentFails--;
	      if (s4 === peg$FAILED) {
	        s3 = void 0;
	      } else {
	        peg$currPos = s3;
	        s3 = peg$FAILED;
	      }
	      if (s3 !== peg$FAILED) {
	        s4 = peg$parseSourceCharacter();
	        if (s4 !== peg$FAILED) {
	          s3 = [s3, s4];
	          s2 = s3;
	        } else {
	          peg$currPos = s2;
	          s2 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s2;
	        s2 = peg$FAILED;
	      }
	      while (s2 !== peg$FAILED) {
	        s1.push(s2);
	        s2 = peg$currPos;
	        s3 = peg$currPos;
	        peg$silentFails++;
	        s4 = peg$parseLineTerminatorSequenceEOF();
	        if (s4 === peg$FAILED) {
	          if (input.charCodeAt(peg$currPos) === 34) {
	            s4 = peg$c188;
	            peg$currPos++;
	          } else {
	            s4 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c189); }
	          }
	        }
	        peg$silentFails--;
	        if (s4 === peg$FAILED) {
	          s3 = void 0;
	        } else {
	          peg$currPos = s3;
	          s3 = peg$FAILED;
	        }
	        if (s3 !== peg$FAILED) {
	          s4 = peg$parseSourceCharacter();
	          if (s4 !== peg$FAILED) {
	            s3 = [s3, s4];
	            s2 = s3;
	          } else {
	            peg$currPos = s2;
	            s2 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s2;
	          s2 = peg$FAILED;
	        }
	      }
	      if (s1 !== peg$FAILED) {
	        s1 = peg$c190(s1);
	      }
	      s0 = s1;

	      return s0;
	    }

	    function peg$parseToken() {
	      var s0;

	      s0 = peg$parseIdentifier();
	      if (s0 === peg$FAILED) {
	        s0 = peg$parseNumber();
	        if (s0 === peg$FAILED) {
	          s0 = peg$parseStringLiteral();
	          if (s0 === peg$FAILED) {
	            s0 = peg$parseOpOrPunc();
	          }
	        }
	      }

	      return s0;
	    }

	    function peg$parseIdentifier() {
	      var s0, s1, s2;

	      peg$silentFails++;
	      s0 = peg$currPos;
	      s1 = peg$currPos;
	      peg$silentFails++;
	      s2 = peg$parseKeyword();
	      peg$silentFails--;
	      if (s2 === peg$FAILED) {
	        s1 = void 0;
	      } else {
	        peg$currPos = s1;
	        s1 = peg$FAILED;
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parseIdentifierName();
	        if (s2 !== peg$FAILED) {
	          s1 = peg$c133(s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	      peg$silentFails--;
	      if (s0 === peg$FAILED) {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c132); }
	      }

	      return s0;
	    }

	    function peg$parseIdentifierName() {
	      var s0, s1, s2, s3;

	      peg$silentFails++;
	      s0 = peg$currPos;
	      s1 = peg$parseIdentifierStart();
	      if (s1 !== peg$FAILED) {
	        s2 = [];
	        s3 = peg$parseIdentifierPart();
	        while (s3 !== peg$FAILED) {
	          s2.push(s3);
	          s3 = peg$parseIdentifierPart();
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = peg$c191(s1, s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	      peg$silentFails--;
	      if (s0 === peg$FAILED) {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c132); }
	      }

	      return s0;
	    }

	    function peg$parseIdentifierStart() {
	      var s0;

	      s0 = peg$parseLetter();
	      if (s0 === peg$FAILED) {
	        if (input.charCodeAt(peg$currPos) === 36) {
	          s0 = peg$c192;
	          peg$currPos++;
	        } else {
	          s0 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c193); }
	        }
	        if (s0 === peg$FAILED) {
	          if (input.charCodeAt(peg$currPos) === 95) {
	            s0 = peg$c194;
	            peg$currPos++;
	          } else {
	            s0 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c195); }
	          }
	        }
	      }

	      return s0;
	    }

	    function peg$parseIdentifierPart() {
	      var s0;

	      s0 = peg$parseIdentifierStart();
	      if (s0 === peg$FAILED) {
	        s0 = peg$parseDecimalDigit();
	      }

	      return s0;
	    }

	    function peg$parseLetter() {
	      var s0;

	      if (peg$c196.test(input.charAt(peg$currPos))) {
	        s0 = input.charAt(peg$currPos);
	        peg$currPos++;
	      } else {
	        s0 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c197); }
	      }

	      return s0;
	    }

	    function peg$parseKeyword() {
	      var s0, s1, s2, s3;

	      s0 = peg$currPos;
	      if (input.substr(peg$currPos, 7) === peg$c198) {
	        s1 = peg$c198;
	        peg$currPos += 7;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c199); }
	      }
	      if (s1 === peg$FAILED) {
	        if (input.substr(peg$currPos, 5) === peg$c200) {
	          s1 = peg$c200;
	          peg$currPos += 5;
	        } else {
	          s1 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c201); }
	        }
	        if (s1 === peg$FAILED) {
	          if (input.substr(peg$currPos, 5) === peg$c202) {
	            s1 = peg$c202;
	            peg$currPos += 5;
	          } else {
	            s1 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c203); }
	          }
	          if (s1 === peg$FAILED) {
	            if (input.substr(peg$currPos, 6) === peg$c204) {
	              s1 = peg$c204;
	              peg$currPos += 6;
	            } else {
	              s1 = peg$FAILED;
	              if (peg$silentFails === 0) { peg$fail(peg$c205); }
	            }
	            if (s1 === peg$FAILED) {
	              if (input.substr(peg$currPos, 6) === peg$c206) {
	                s1 = peg$c206;
	                peg$currPos += 6;
	              } else {
	                s1 = peg$FAILED;
	                if (peg$silentFails === 0) { peg$fail(peg$c207); }
	              }
	              if (s1 === peg$FAILED) {
	                if (input.substr(peg$currPos, 3) === peg$c208) {
	                  s1 = peg$c208;
	                  peg$currPos += 3;
	                } else {
	                  s1 = peg$FAILED;
	                  if (peg$silentFails === 0) { peg$fail(peg$c209); }
	                }
	                if (s1 === peg$FAILED) {
	                  if (input.substr(peg$currPos, 6) === peg$c210) {
	                    s1 = peg$c210;
	                    peg$currPos += 6;
	                  } else {
	                    s1 = peg$FAILED;
	                    if (peg$silentFails === 0) { peg$fail(peg$c211); }
	                  }
	                  if (s1 === peg$FAILED) {
	                    if (input.substr(peg$currPos, 7) === peg$c212) {
	                      s1 = peg$c212;
	                      peg$currPos += 7;
	                    } else {
	                      s1 = peg$FAILED;
	                      if (peg$silentFails === 0) { peg$fail(peg$c213); }
	                    }
	                    if (s1 === peg$FAILED) {
	                      if (input.substr(peg$currPos, 8) === peg$c214) {
	                        s1 = peg$c214;
	                        peg$currPos += 8;
	                      } else {
	                        s1 = peg$FAILED;
	                        if (peg$silentFails === 0) { peg$fail(peg$c215); }
	                      }
	                      if (s1 === peg$FAILED) {
	                        if (input.substr(peg$currPos, 5) === peg$c216) {
	                          s1 = peg$c216;
	                          peg$currPos += 5;
	                        } else {
	                          s1 = peg$FAILED;
	                          if (peg$silentFails === 0) { peg$fail(peg$c217); }
	                        }
	                        if (s1 === peg$FAILED) {
	                          if (input.substr(peg$currPos, 7) === peg$c218) {
	                            s1 = peg$c218;
	                            peg$currPos += 7;
	                          } else {
	                            s1 = peg$FAILED;
	                            if (peg$silentFails === 0) { peg$fail(peg$c219); }
	                          }
	                          if (s1 === peg$FAILED) {
	                            if (input.substr(peg$currPos, 8) === peg$c220) {
	                              s1 = peg$c220;
	                              peg$currPos += 8;
	                            } else {
	                              s1 = peg$FAILED;
	                              if (peg$silentFails === 0) { peg$fail(peg$c221); }
	                            }
	                            if (s1 === peg$FAILED) {
	                              if (input.substr(peg$currPos, 8) === peg$c222) {
	                                s1 = peg$c222;
	                                peg$currPos += 8;
	                              } else {
	                                s1 = peg$FAILED;
	                                if (peg$silentFails === 0) { peg$fail(peg$c223); }
	                              }
	                              if (s1 === peg$FAILED) {
	                                if (input.substr(peg$currPos, 3) === peg$c28) {
	                                  s1 = peg$c28;
	                                  peg$currPos += 3;
	                                } else {
	                                  s1 = peg$FAILED;
	                                  if (peg$silentFails === 0) { peg$fail(peg$c29); }
	                                }
	                              }
	                            }
	                          }
	                        }
	                      }
	                    }
	                  }
	                }
	              }
	            }
	          }
	        }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$currPos;
	        peg$silentFails++;
	        s3 = peg$parseIdentifierPart();
	        peg$silentFails--;
	        if (s3 === peg$FAILED) {
	          s2 = void 0;
	        } else {
	          peg$currPos = s2;
	          s2 = peg$FAILED;
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = [s1, s2];
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseNumber() {
	      var s0, s1, s2, s3;

	      peg$silentFails++;
	      s0 = peg$currPos;
	      s1 = peg$parseHexIntegerLiteral();
	      if (s1 === peg$FAILED) {
	        s1 = peg$parseDecimalLiteral();
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$currPos;
	        peg$silentFails++;
	        s3 = peg$parseIdentifierStart();
	        peg$silentFails--;
	        if (s3 === peg$FAILED) {
	          s2 = void 0;
	        } else {
	          peg$currPos = s2;
	          s2 = peg$FAILED;
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = peg$c130(s1);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	      peg$silentFails--;
	      if (s0 === peg$FAILED) {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c129); }
	      }

	      return s0;
	    }

	    function peg$parseDecimalLiteral() {
	      var s0, s1, s2, s3, s4, s5, s6;

	      s0 = peg$currPos;
	      s1 = peg$currPos;
	      s2 = peg$currPos;
	      s3 = peg$parseDecimalIntegerLiteral();
	      if (s3 !== peg$FAILED) {
	        if (input.charCodeAt(peg$currPos) === 46) {
	          s4 = peg$c224;
	          peg$currPos++;
	        } else {
	          s4 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c225); }
	        }
	        if (s4 !== peg$FAILED) {
	          s5 = peg$parseDecimalDigits();
	          if (s5 === peg$FAILED) {
	            s5 = null;
	          }
	          if (s5 !== peg$FAILED) {
	            s6 = peg$parseExponentPart();
	            if (s6 === peg$FAILED) {
	              s6 = null;
	            }
	            if (s6 !== peg$FAILED) {
	              s3 = [s3, s4, s5, s6];
	              s2 = s3;
	            } else {
	              peg$currPos = s2;
	              s2 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s2;
	            s2 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s2;
	          s2 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s2;
	        s2 = peg$FAILED;
	      }
	      if (s2 !== peg$FAILED) {
	        s1 = input.substring(s1, peg$currPos);
	      } else {
	        s1 = s2;
	      }
	      if (s1 !== peg$FAILED) {
	        s1 = peg$c234(s1);
	      }
	      s0 = s1;
	      if (s0 === peg$FAILED) {
	        s0 = peg$currPos;
	        s1 = peg$currPos;
	        s2 = peg$currPos;
	        if (input.charCodeAt(peg$currPos) === 46) {
	          s3 = peg$c224;
	          peg$currPos++;
	        } else {
	          s3 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c225); }
	        }
	        if (s3 !== peg$FAILED) {
	          s4 = peg$parseDecimalDigits();
	          if (s4 !== peg$FAILED) {
	            s5 = peg$parseExponentPart();
	            if (s5 === peg$FAILED) {
	              s5 = null;
	            }
	            if (s5 !== peg$FAILED) {
	              s3 = [s3, s4, s5];
	              s2 = s3;
	            } else {
	              peg$currPos = s2;
	              s2 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s2;
	            s2 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s2;
	          s2 = peg$FAILED;
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = input.substring(s1, peg$currPos);
	        } else {
	          s1 = s2;
	        }
	        if (s1 !== peg$FAILED) {
	          s1 = peg$c235(s1);
	        }
	        s0 = s1;
	        if (s0 === peg$FAILED) {
	          s0 = peg$currPos;
	          s1 = peg$currPos;
	          s2 = peg$currPos;
	          s3 = peg$parseDecimalIntegerLiteral();
	          if (s3 !== peg$FAILED) {
	            s4 = peg$parseExponentPart();
	            if (s4 === peg$FAILED) {
	              s4 = null;
	            }
	            if (s4 !== peg$FAILED) {
	              s3 = [s3, s4];
	              s2 = s3;
	            } else {
	              peg$currPos = s2;
	              s2 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s2;
	            s2 = peg$FAILED;
	          }
	          if (s2 !== peg$FAILED) {
	            s1 = input.substring(s1, peg$currPos);
	          } else {
	            s1 = s2;
	          }
	          if (s1 !== peg$FAILED) {
	            s1 = peg$c235(s1);
	          }
	          s0 = s1;
	        }
	      }

	      return s0;
	    }

	    function peg$parseHexIntegerLiteral() {
	      var s0, s1, s2, s3, s4, s5;

	      s0 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 48) {
	        s1 = peg$c229;
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c230); }
	      }
	      if (s1 !== peg$FAILED) {
	        if (peg$c231.test(input.charAt(peg$currPos))) {
	          s2 = input.charAt(peg$currPos);
	          peg$currPos++;
	        } else {
	          s2 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c232); }
	        }
	        if (s2 !== peg$FAILED) {
	          s3 = peg$currPos;
	          s4 = [];
	          s5 = peg$parseHexDigit();
	          if (s5 !== peg$FAILED) {
	            while (s5 !== peg$FAILED) {
	              s4.push(s5);
	              s5 = peg$parseHexDigit();
	            }
	          } else {
	            s4 = peg$FAILED;
	          }
	          if (s4 !== peg$FAILED) {
	            s3 = input.substring(s3, peg$currPos);
	          } else {
	            s3 = s4;
	          }
	          if (s3 !== peg$FAILED) {
	            s1 = peg$c236(s3);
	            s0 = s1;
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseDecimalIntegerLiteral() {
	      var s0, s1, s2;

	      if (input.charCodeAt(peg$currPos) === 48) {
	        s0 = peg$c229;
	        peg$currPos++;
	      } else {
	        s0 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c230); }
	      }
	      if (s0 === peg$FAILED) {
	        s0 = peg$currPos;
	        s1 = peg$parseNonZeroDigit();
	        if (s1 !== peg$FAILED) {
	          s2 = peg$parseDecimalDigits();
	          if (s2 === peg$FAILED) {
	            s2 = null;
	          }
	          if (s2 !== peg$FAILED) {
	            s1 = [s1, s2];
	            s0 = s1;
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      }

	      return s0;
	    }

	    function peg$parseDecimalDigits() {
	      var s0, s1;

	      s0 = [];
	      s1 = peg$parseDecimalDigit();
	      if (s1 !== peg$FAILED) {
	        while (s1 !== peg$FAILED) {
	          s0.push(s1);
	          s1 = peg$parseDecimalDigit();
	        }
	      } else {
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseDecimalDigit() {
	      var s0;

	      if (peg$c237.test(input.charAt(peg$currPos))) {
	        s0 = input.charAt(peg$currPos);
	        peg$currPos++;
	      } else {
	        s0 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c238); }
	      }

	      return s0;
	    }

	    function peg$parseNonZeroDigit() {
	      var s0;

	      if (peg$c239.test(input.charAt(peg$currPos))) {
	        s0 = input.charAt(peg$currPos);
	        peg$currPos++;
	      } else {
	        s0 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c240); }
	      }

	      return s0;
	    }

	    function peg$parseExponentPart() {
	      var s0, s1, s2;

	      s0 = peg$currPos;
	      s1 = peg$parseExponentIndicator();
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parseSignedInteger();
	        if (s2 !== peg$FAILED) {
	          s1 = [s1, s2];
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseExponentIndicator() {
	      var s0;

	      if (peg$c241.test(input.charAt(peg$currPos))) {
	        s0 = input.charAt(peg$currPos);
	        peg$currPos++;
	      } else {
	        s0 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c242); }
	      }

	      return s0;
	    }

	    function peg$parseSignedInteger() {
	      var s0, s1, s2;

	      s0 = peg$currPos;
	      if (peg$c243.test(input.charAt(peg$currPos))) {
	        s1 = input.charAt(peg$currPos);
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c244); }
	      }
	      if (s1 === peg$FAILED) {
	        s1 = null;
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parseDecimalDigits();
	        if (s2 !== peg$FAILED) {
	          s1 = [s1, s2];
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseHexDigit() {
	      var s0;

	      if (peg$c245.test(input.charAt(peg$currPos))) {
	        s0 = input.charAt(peg$currPos);
	        peg$currPos++;
	      } else {
	        s0 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c246); }
	      }

	      return s0;
	    }

	    function peg$parseStringLiteral() {
	      var s0, s1, s2, s3, s4;

	      peg$silentFails++;
	      s0 = peg$currPos;
	      s1 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 34) {
	        s2 = peg$c188;
	        peg$currPos++;
	      } else {
	        s2 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c189); }
	      }
	      if (s2 !== peg$FAILED) {
	        s3 = peg$parseDoubleStringCharacters();
	        if (s3 === peg$FAILED) {
	          s3 = null;
	        }
	        if (s3 !== peg$FAILED) {
	          if (input.charCodeAt(peg$currPos) === 34) {
	            s4 = peg$c188;
	            peg$currPos++;
	          } else {
	            s4 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c189); }
	          }
	          if (s4 !== peg$FAILED) {
	            s2 = [s2, s3, s4];
	            s1 = s2;
	          } else {
	            peg$currPos = s1;
	            s1 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s1;
	          s1 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s1;
	        s1 = peg$FAILED;
	      }
	      if (s1 === peg$FAILED) {
	        s1 = peg$currPos;
	        if (input.charCodeAt(peg$currPos) === 39) {
	          s2 = peg$c248;
	          peg$currPos++;
	        } else {
	          s2 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c249); }
	        }
	        if (s2 !== peg$FAILED) {
	          s3 = peg$parseSingleStringCharacters();
	          if (s3 === peg$FAILED) {
	            s3 = null;
	          }
	          if (s3 !== peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 39) {
	              s4 = peg$c248;
	              peg$currPos++;
	            } else {
	              s4 = peg$FAILED;
	              if (peg$silentFails === 0) { peg$fail(peg$c249); }
	            }
	            if (s4 !== peg$FAILED) {
	              s2 = [s2, s3, s4];
	              s1 = s2;
	            } else {
	              peg$currPos = s1;
	              s1 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s1;
	            s1 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s1;
	          s1 = peg$FAILED;
	        }
	      }
	      if (s1 !== peg$FAILED) {
	        s1 = peg$c250(s1);
	      }
	      s0 = s1;
	      peg$silentFails--;
	      if (s0 === peg$FAILED) {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c247); }
	      }

	      return s0;
	    }

	    function peg$parseDoubleStringCharacters() {
	      var s0, s1, s2;

	      s0 = peg$currPos;
	      s1 = [];
	      s2 = peg$parseDoubleStringCharacter();
	      if (s2 !== peg$FAILED) {
	        while (s2 !== peg$FAILED) {
	          s1.push(s2);
	          s2 = peg$parseDoubleStringCharacter();
	        }
	      } else {
	        s1 = peg$FAILED;
	      }
	      if (s1 !== peg$FAILED) {
	        s1 = peg$c251(s1);
	      }
	      s0 = s1;

	      return s0;
	    }

	    function peg$parseSingleStringCharacters() {
	      var s0, s1, s2;

	      s0 = peg$currPos;
	      s1 = [];
	      s2 = peg$parseSingleStringCharacter();
	      if (s2 !== peg$FAILED) {
	        while (s2 !== peg$FAILED) {
	          s1.push(s2);
	          s2 = peg$parseSingleStringCharacter();
	        }
	      } else {
	        s1 = peg$FAILED;
	      }
	      if (s1 !== peg$FAILED) {
	        s1 = peg$c251(s1);
	      }
	      s0 = s1;

	      return s0;
	    }

	    function peg$parseDoubleStringCharacter() {
	      var s0, s1, s2;

	      s0 = peg$currPos;
	      s1 = peg$currPos;
	      peg$silentFails++;
	      if (input.charCodeAt(peg$currPos) === 34) {
	        s2 = peg$c188;
	        peg$currPos++;
	      } else {
	        s2 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c189); }
	      }
	      if (s2 === peg$FAILED) {
	        if (input.charCodeAt(peg$currPos) === 92) {
	          s2 = peg$c252;
	          peg$currPos++;
	        } else {
	          s2 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c253); }
	        }
	        if (s2 === peg$FAILED) {
	          s2 = peg$parseLineTerminator();
	        }
	      }
	      peg$silentFails--;
	      if (s2 === peg$FAILED) {
	        s1 = void 0;
	      } else {
	        peg$currPos = s1;
	        s1 = peg$FAILED;
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parseSourceCharacter();
	        if (s2 !== peg$FAILED) {
	          s1 = peg$c254(s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	      if (s0 === peg$FAILED) {
	        s0 = peg$currPos;
	        if (input.charCodeAt(peg$currPos) === 92) {
	          s1 = peg$c252;
	          peg$currPos++;
	        } else {
	          s1 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c253); }
	        }
	        if (s1 !== peg$FAILED) {
	          s2 = peg$parseEscapeSequence();
	          if (s2 !== peg$FAILED) {
	            s1 = peg$c255(s2);
	            s0 = s1;
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	        if (s0 === peg$FAILED) {
	          s0 = peg$parseLineContinuation();
	        }
	      }

	      return s0;
	    }

	    function peg$parseSingleStringCharacter() {
	      var s0, s1, s2;

	      s0 = peg$currPos;
	      s1 = peg$currPos;
	      peg$silentFails++;
	      if (input.charCodeAt(peg$currPos) === 39) {
	        s2 = peg$c248;
	        peg$currPos++;
	      } else {
	        s2 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c249); }
	      }
	      if (s2 === peg$FAILED) {
	        if (input.charCodeAt(peg$currPos) === 92) {
	          s2 = peg$c252;
	          peg$currPos++;
	        } else {
	          s2 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c253); }
	        }
	        if (s2 === peg$FAILED) {
	          s2 = peg$parseLineTerminator();
	        }
	      }
	      peg$silentFails--;
	      if (s2 === peg$FAILED) {
	        s1 = void 0;
	      } else {
	        peg$currPos = s1;
	        s1 = peg$FAILED;
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parseSourceCharacter();
	        if (s2 !== peg$FAILED) {
	          s1 = peg$c254(s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	      if (s0 === peg$FAILED) {
	        s0 = peg$currPos;
	        if (input.charCodeAt(peg$currPos) === 92) {
	          s1 = peg$c252;
	          peg$currPos++;
	        } else {
	          s1 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c253); }
	        }
	        if (s1 !== peg$FAILED) {
	          s2 = peg$parseEscapeSequence();
	          if (s2 !== peg$FAILED) {
	            s1 = peg$c255(s2);
	            s0 = s1;
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	        if (s0 === peg$FAILED) {
	          s0 = peg$parseLineContinuation();
	        }
	      }

	      return s0;
	    }

	    function peg$parseLineContinuation() {
	      var s0, s1, s2;

	      s0 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 92) {
	        s1 = peg$c252;
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c253); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parseLineTerminatorSequenceEOF();
	        if (s2 !== peg$FAILED) {
	          s1 = peg$c256(s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseEscapeSequence() {
	      var s0, s1, s2, s3;

	      s0 = peg$parseCharacterEscapeSequence();
	      if (s0 === peg$FAILED) {
	        s0 = peg$currPos;
	        if (input.charCodeAt(peg$currPos) === 48) {
	          s1 = peg$c229;
	          peg$currPos++;
	        } else {
	          s1 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c230); }
	        }
	        if (s1 !== peg$FAILED) {
	          s2 = peg$currPos;
	          peg$silentFails++;
	          s3 = peg$parseDecimalDigit();
	          peg$silentFails--;
	          if (s3 === peg$FAILED) {
	            s2 = void 0;
	          } else {
	            peg$currPos = s2;
	            s2 = peg$FAILED;
	          }
	          if (s2 !== peg$FAILED) {
	            s1 = peg$c257();
	            s0 = s1;
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	        if (s0 === peg$FAILED) {
	          s0 = peg$parseHexEscapeSequence();
	        }
	      }

	      return s0;
	    }

	    function peg$parseCharacterEscapeSequence() {
	      var s0;

	      s0 = peg$parseSingleEscapeCharacter();
	      if (s0 === peg$FAILED) {
	        s0 = peg$parseNonEscapeCharacter();
	      }

	      return s0;
	    }

	    function peg$parseSingleEscapeCharacter() {
	      var s0, s1;

	      s0 = peg$currPos;
	      if (peg$c258.test(input.charAt(peg$currPos))) {
	        s1 = input.charAt(peg$currPos);
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c259); }
	      }
	      if (s1 !== peg$FAILED) {
	        s1 = peg$c260(s1);
	      }
	      s0 = s1;

	      return s0;
	    }

	    function peg$parseNonEscapeCharacter() {
	      var s0, s1, s2;

	      s0 = peg$currPos;
	      s1 = peg$currPos;
	      peg$silentFails++;
	      s2 = peg$parseEscapeCharacter();
	      peg$silentFails--;
	      if (s2 === peg$FAILED) {
	        s1 = void 0;
	      } else {
	        peg$currPos = s1;
	        s1 = peg$FAILED;
	      }
	      if (s1 === peg$FAILED) {
	        s1 = peg$parseLineTerminator();
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parseSourceCharacter();
	        if (s2 !== peg$FAILED) {
	          s1 = peg$c261(s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseEscapeCharacter() {
	      var s0;

	      s0 = peg$parseSingleEscapeCharacter();
	      if (s0 === peg$FAILED) {
	        s0 = peg$parseDecimalDigit();
	        if (s0 === peg$FAILED) {
	          if (input.charCodeAt(peg$currPos) === 120) {
	            s0 = peg$c262;
	            peg$currPos++;
	          } else {
	            s0 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c263); }
	          }
	          if (s0 === peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 117) {
	              s0 = peg$c264;
	              peg$currPos++;
	            } else {
	              s0 = peg$FAILED;
	              if (peg$silentFails === 0) { peg$fail(peg$c265); }
	            }
	          }
	        }
	      }

	      return s0;
	    }

	    function peg$parseHexEscapeSequence() {
	      var s0, s1, s2, s3, s4, s5;

	      s0 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 120) {
	        s1 = peg$c262;
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c263); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$currPos;
	        s3 = peg$currPos;
	        s4 = peg$parseHexDigit();
	        if (s4 !== peg$FAILED) {
	          s5 = peg$parseHexDigit();
	          if (s5 !== peg$FAILED) {
	            s4 = [s4, s5];
	            s3 = s4;
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s3;
	          s3 = peg$FAILED;
	        }
	        if (s3 !== peg$FAILED) {
	          s2 = input.substring(s2, peg$currPos);
	        } else {
	          s2 = s3;
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = peg$c266(s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseOpOrPunc() {
	      var s0;

	      peg$silentFails++;
	      if (input.substr(peg$currPos, 2) === peg$c268) {
	        s0 = peg$c268;
	        peg$currPos += 2;
	      } else {
	        s0 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c269); }
	      }
	      if (s0 === peg$FAILED) {
	        if (input.substr(peg$currPos, 2) === peg$c270) {
	          s0 = peg$c270;
	          peg$currPos += 2;
	        } else {
	          s0 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c271); }
	        }
	        if (s0 === peg$FAILED) {
	          if (input.substr(peg$currPos, 2) === peg$c272) {
	            s0 = peg$c272;
	            peg$currPos += 2;
	          } else {
	            s0 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c273); }
	          }
	          if (s0 === peg$FAILED) {
	            if (input.substr(peg$currPos, 2) === peg$c274) {
	              s0 = peg$c274;
	              peg$currPos += 2;
	            } else {
	              s0 = peg$FAILED;
	              if (peg$silentFails === 0) { peg$fail(peg$c275); }
	            }
	            if (s0 === peg$FAILED) {
	              if (input.substr(peg$currPos, 2) === peg$c276) {
	                s0 = peg$c276;
	                peg$currPos += 2;
	              } else {
	                s0 = peg$FAILED;
	                if (peg$silentFails === 0) { peg$fail(peg$c277); }
	              }
	              if (s0 === peg$FAILED) {
	                if (input.substr(peg$currPos, 2) === peg$c278) {
	                  s0 = peg$c278;
	                  peg$currPos += 2;
	                } else {
	                  s0 = peg$FAILED;
	                  if (peg$silentFails === 0) { peg$fail(peg$c279); }
	                }
	                if (s0 === peg$FAILED) {
	                  if (input.substr(peg$currPos, 2) === peg$c280) {
	                    s0 = peg$c280;
	                    peg$currPos += 2;
	                  } else {
	                    s0 = peg$FAILED;
	                    if (peg$silentFails === 0) { peg$fail(peg$c281); }
	                  }
	                  if (s0 === peg$FAILED) {
	                    if (input.substr(peg$currPos, 2) === peg$c282) {
	                      s0 = peg$c282;
	                      peg$currPos += 2;
	                    } else {
	                      s0 = peg$FAILED;
	                      if (peg$silentFails === 0) { peg$fail(peg$c283); }
	                    }
	                    if (s0 === peg$FAILED) {
	                      if (input.substr(peg$currPos, 2) === peg$c157) {
	                        s0 = peg$c157;
	                        peg$currPos += 2;
	                      } else {
	                        s0 = peg$FAILED;
	                        if (peg$silentFails === 0) { peg$fail(peg$c158); }
	                      }
	                      if (s0 === peg$FAILED) {
	                        if (input.substr(peg$currPos, 2) === peg$c159) {
	                          s0 = peg$c159;
	                          peg$currPos += 2;
	                        } else {
	                          s0 = peg$FAILED;
	                          if (peg$silentFails === 0) { peg$fail(peg$c160); }
	                        }
	                        if (s0 === peg$FAILED) {
	                          if (input.substr(peg$currPos, 3) === peg$c284) {
	                            s0 = peg$c284;
	                            peg$currPos += 3;
	                          } else {
	                            s0 = peg$FAILED;
	                            if (peg$silentFails === 0) { peg$fail(peg$c285); }
	                          }
	                          if (s0 === peg$FAILED) {
	                            if (input.substr(peg$currPos, 3) === peg$c286) {
	                              s0 = peg$c286;
	                              peg$currPos += 3;
	                            } else {
	                              s0 = peg$FAILED;
	                              if (peg$silentFails === 0) { peg$fail(peg$c287); }
	                            }
	                            if (s0 === peg$FAILED) {
	                              if (input.substr(peg$currPos, 2) === peg$c169) {
	                                s0 = peg$c169;
	                                peg$currPos += 2;
	                              } else {
	                                s0 = peg$FAILED;
	                                if (peg$silentFails === 0) { peg$fail(peg$c170); }
	                              }
	                              if (s0 === peg$FAILED) {
	                                if (input.substr(peg$currPos, 2) === peg$c171) {
	                                  s0 = peg$c171;
	                                  peg$currPos += 2;
	                                } else {
	                                  s0 = peg$FAILED;
	                                  if (peg$silentFails === 0) { peg$fail(peg$c172); }
	                                }
	                                if (s0 === peg$FAILED) {
	                                  if (input.substr(peg$currPos, 2) === peg$c161) {
	                                    s0 = peg$c161;
	                                    peg$currPos += 2;
	                                  } else {
	                                    s0 = peg$FAILED;
	                                    if (peg$silentFails === 0) { peg$fail(peg$c162); }
	                                  }
	                                  if (s0 === peg$FAILED) {
	                                    if (input.substr(peg$currPos, 2) === peg$c163) {
	                                      s0 = peg$c163;
	                                      peg$currPos += 2;
	                                    } else {
	                                      s0 = peg$FAILED;
	                                      if (peg$silentFails === 0) { peg$fail(peg$c164); }
	                                    }
	                                    if (s0 === peg$FAILED) {
	                                      if (input.substr(peg$currPos, 2) === peg$c182) {
	                                        s0 = peg$c182;
	                                        peg$currPos += 2;
	                                      } else {
	                                        s0 = peg$FAILED;
	                                        if (peg$silentFails === 0) { peg$fail(peg$c183); }
	                                      }
	                                      if (s0 === peg$FAILED) {
	                                        if (input.substr(peg$currPos, 2) === peg$c185) {
	                                          s0 = peg$c185;
	                                          peg$currPos += 2;
	                                        } else {
	                                          s0 = peg$FAILED;
	                                          if (peg$silentFails === 0) { peg$fail(peg$c186); }
	                                        }
	                                        if (s0 === peg$FAILED) {
	                                          if (input.substr(peg$currPos, 2) === peg$c134) {
	                                            s0 = peg$c134;
	                                            peg$currPos += 2;
	                                          } else {
	                                            s0 = peg$FAILED;
	                                            if (peg$silentFails === 0) { peg$fail(peg$c135); }
	                                          }
	                                          if (s0 === peg$FAILED) {
	                                            if (input.substr(peg$currPos, 2) === peg$c136) {
	                                              s0 = peg$c136;
	                                              peg$currPos += 2;
	                                            } else {
	                                              s0 = peg$FAILED;
	                                              if (peg$silentFails === 0) { peg$fail(peg$c137); }
	                                            }
	                                            if (s0 === peg$FAILED) {
	                                              if (input.charCodeAt(peg$currPos) === 123) {
	                                                s0 = peg$c288;
	                                                peg$currPos++;
	                                              } else {
	                                                s0 = peg$FAILED;
	                                                if (peg$silentFails === 0) { peg$fail(peg$c289); }
	                                              }
	                                              if (s0 === peg$FAILED) {
	                                                if (input.charCodeAt(peg$currPos) === 125) {
	                                                  s0 = peg$c290;
	                                                  peg$currPos++;
	                                                } else {
	                                                  s0 = peg$FAILED;
	                                                  if (peg$silentFails === 0) { peg$fail(peg$c291); }
	                                                }
	                                                if (s0 === peg$FAILED) {
	                                                  if (input.charCodeAt(peg$currPos) === 91) {
	                                                    s0 = peg$c292;
	                                                    peg$currPos++;
	                                                  } else {
	                                                    s0 = peg$FAILED;
	                                                    if (peg$silentFails === 0) { peg$fail(peg$c293); }
	                                                  }
	                                                  if (s0 === peg$FAILED) {
	                                                    if (input.charCodeAt(peg$currPos) === 93) {
	                                                      s0 = peg$c294;
	                                                      peg$currPos++;
	                                                    } else {
	                                                      s0 = peg$FAILED;
	                                                      if (peg$silentFails === 0) { peg$fail(peg$c295); }
	                                                    }
	                                                    if (s0 === peg$FAILED) {
	                                                      if (input.charCodeAt(peg$currPos) === 40) {
	                                                        s0 = peg$c123;
	                                                        peg$currPos++;
	                                                      } else {
	                                                        s0 = peg$FAILED;
	                                                        if (peg$silentFails === 0) { peg$fail(peg$c124); }
	                                                      }
	                                                      if (s0 === peg$FAILED) {
	                                                        if (input.charCodeAt(peg$currPos) === 41) {
	                                                          s0 = peg$c125;
	                                                          peg$currPos++;
	                                                        } else {
	                                                          s0 = peg$FAILED;
	                                                          if (peg$silentFails === 0) { peg$fail(peg$c126); }
	                                                        }
	                                                        if (s0 === peg$FAILED) {
	                                                          if (input.charCodeAt(peg$currPos) === 59) {
	                                                            s0 = peg$c296;
	                                                            peg$currPos++;
	                                                          } else {
	                                                            s0 = peg$FAILED;
	                                                            if (peg$silentFails === 0) { peg$fail(peg$c297); }
	                                                          }
	                                                          if (s0 === peg$FAILED) {
	                                                            if (input.charCodeAt(peg$currPos) === 58) {
	                                                              s0 = peg$c103;
	                                                              peg$currPos++;
	                                                            } else {
	                                                              s0 = peg$FAILED;
	                                                              if (peg$silentFails === 0) { peg$fail(peg$c104); }
	                                                            }
	                                                            if (s0 === peg$FAILED) {
	                                                              if (input.charCodeAt(peg$currPos) === 63) {
	                                                                s0 = peg$c101;
	                                                                peg$currPos++;
	                                                              } else {
	                                                                s0 = peg$FAILED;
	                                                                if (peg$silentFails === 0) { peg$fail(peg$c102); }
	                                                              }
	                                                              if (s0 === peg$FAILED) {
	                                                                if (input.charCodeAt(peg$currPos) === 46) {
	                                                                  s0 = peg$c224;
	                                                                  peg$currPos++;
	                                                                } else {
	                                                                  s0 = peg$FAILED;
	                                                                  if (peg$silentFails === 0) { peg$fail(peg$c225); }
	                                                                }
	                                                                if (s0 === peg$FAILED) {
	                                                                  if (input.charCodeAt(peg$currPos) === 43) {
	                                                                    s0 = peg$c138;
	                                                                    peg$currPos++;
	                                                                  } else {
	                                                                    s0 = peg$FAILED;
	                                                                    if (peg$silentFails === 0) { peg$fail(peg$c139); }
	                                                                  }
	                                                                  if (s0 === peg$FAILED) {
	                                                                    if (input.charCodeAt(peg$currPos) === 45) {
	                                                                      s0 = peg$c140;
	                                                                      peg$currPos++;
	                                                                    } else {
	                                                                      s0 = peg$FAILED;
	                                                                      if (peg$silentFails === 0) { peg$fail(peg$c141); }
	                                                                    }
	                                                                    if (s0 === peg$FAILED) {
	                                                                      if (input.charCodeAt(peg$currPos) === 42) {
	                                                                        s0 = peg$c146;
	                                                                        peg$currPos++;
	                                                                      } else {
	                                                                        s0 = peg$FAILED;
	                                                                        if (peg$silentFails === 0) { peg$fail(peg$c147); }
	                                                                      }
	                                                                      if (s0 === peg$FAILED) {
	                                                                        if (input.charCodeAt(peg$currPos) === 47) {
	                                                                          s0 = peg$c148;
	                                                                          peg$currPos++;
	                                                                        } else {
	                                                                          s0 = peg$FAILED;
	                                                                          if (peg$silentFails === 0) { peg$fail(peg$c149); }
	                                                                        }
	                                                                        if (s0 === peg$FAILED) {
	                                                                          if (input.charCodeAt(peg$currPos) === 37) {
	                                                                            s0 = peg$c150;
	                                                                            peg$currPos++;
	                                                                          } else {
	                                                                            s0 = peg$FAILED;
	                                                                            if (peg$silentFails === 0) { peg$fail(peg$c151); }
	                                                                          }
	                                                                          if (s0 === peg$FAILED) {
	                                                                            if (input.charCodeAt(peg$currPos) === 94) {
	                                                                              s0 = peg$c176;
	                                                                              peg$currPos++;
	                                                                            } else {
	                                                                              s0 = peg$FAILED;
	                                                                              if (peg$silentFails === 0) { peg$fail(peg$c177); }
	                                                                            }
	                                                                            if (s0 === peg$FAILED) {
	                                                                              if (input.charCodeAt(peg$currPos) === 38) {
	                                                                                s0 = peg$c173;
	                                                                                peg$currPos++;
	                                                                              } else {
	                                                                                s0 = peg$FAILED;
	                                                                                if (peg$silentFails === 0) { peg$fail(peg$c174); }
	                                                                              }
	                                                                              if (s0 === peg$FAILED) {
	                                                                                if (input.charCodeAt(peg$currPos) === 124) {
	                                                                                  s0 = peg$c179;
	                                                                                  peg$currPos++;
	                                                                                } else {
	                                                                                  s0 = peg$FAILED;
	                                                                                  if (peg$silentFails === 0) { peg$fail(peg$c180); }
	                                                                                }
	                                                                                if (s0 === peg$FAILED) {
	                                                                                  if (input.charCodeAt(peg$currPos) === 126) {
	                                                                                    s0 = peg$c142;
	                                                                                    peg$currPos++;
	                                                                                  } else {
	                                                                                    s0 = peg$FAILED;
	                                                                                    if (peg$silentFails === 0) { peg$fail(peg$c143); }
	                                                                                  }
	                                                                                  if (s0 === peg$FAILED) {
	                                                                                    if (input.charCodeAt(peg$currPos) === 33) {
	                                                                                      s0 = peg$c144;
	                                                                                      peg$currPos++;
	                                                                                    } else {
	                                                                                      s0 = peg$FAILED;
	                                                                                      if (peg$silentFails === 0) { peg$fail(peg$c145); }
	                                                                                    }
	                                                                                    if (s0 === peg$FAILED) {
	                                                                                      if (input.charCodeAt(peg$currPos) === 61) {
	                                                                                        s0 = peg$c152;
	                                                                                        peg$currPos++;
	                                                                                      } else {
	                                                                                        s0 = peg$FAILED;
	                                                                                        if (peg$silentFails === 0) { peg$fail(peg$c153); }
	                                                                                      }
	                                                                                      if (s0 === peg$FAILED) {
	                                                                                        if (input.charCodeAt(peg$currPos) === 60) {
	                                                                                          s0 = peg$c165;
	                                                                                          peg$currPos++;
	                                                                                        } else {
	                                                                                          s0 = peg$FAILED;
	                                                                                          if (peg$silentFails === 0) { peg$fail(peg$c166); }
	                                                                                        }
	                                                                                        if (s0 === peg$FAILED) {
	                                                                                          if (input.charCodeAt(peg$currPos) === 62) {
	                                                                                            s0 = peg$c167;
	                                                                                            peg$currPos++;
	                                                                                          } else {
	                                                                                            s0 = peg$FAILED;
	                                                                                            if (peg$silentFails === 0) { peg$fail(peg$c168); }
	                                                                                          }
	                                                                                          if (s0 === peg$FAILED) {
	                                                                                            if (input.charCodeAt(peg$currPos) === 44) {
	                                                                                              s0 = peg$c98;
	                                                                                              peg$currPos++;
	                                                                                            } else {
	                                                                                              s0 = peg$FAILED;
	                                                                                              if (peg$silentFails === 0) { peg$fail(peg$c99); }
	                                                                                            }
	                                                                                          }
	                                                                                        }
	                                                                                      }
	                                                                                    }
	                                                                                  }
	                                                                                }
	                                                                              }
	                                                                            }
	                                                                          }
	                                                                        }
	                                                                      }
	                                                                    }
	                                                                  }
	                                                                }
	                                                              }
	                                                            }
	                                                          }
	                                                        }
	                                                      }
	                                                    }
	                                                  }
	                                                }
	                                              }
	                                            }
	                                          }
	                                        }
	                                      }
	                                    }
	                                  }
	                                }
	                              }
	                            }
	                          }
	                        }
	                      }
	                    }
	                  }
	                }
	              }
	            }
	          }
	        }
	      }
	      peg$silentFails--;
	      if (s0 === peg$FAILED) {
	        if (peg$silentFails === 0) { peg$fail(peg$c267); }
	      }

	      return s0;
	    }

	    function peg$parse_() {
	      var s0, s1;

	      s0 = [];
	      s1 = peg$parseWhiteSpace();
	      if (s1 === peg$FAILED) {
	        s1 = peg$parseLineContinuation();
	        if (s1 === peg$FAILED) {
	          s1 = peg$parseMultiLineCommentNoLineTerminator();
	          if (s1 === peg$FAILED) {
	            s1 = peg$parseSingleLineComment();
	          }
	        }
	      }
	      while (s1 !== peg$FAILED) {
	        s0.push(s1);
	        s1 = peg$parseWhiteSpace();
	        if (s1 === peg$FAILED) {
	          s1 = peg$parseLineContinuation();
	          if (s1 === peg$FAILED) {
	            s1 = peg$parseMultiLineCommentNoLineTerminator();
	            if (s1 === peg$FAILED) {
	              s1 = peg$parseSingleLineComment();
	            }
	          }
	        }
	      }

	      return s0;
	    }

	    function peg$parseMSS() {
	      var s0, s1;

	      s0 = [];
	      s1 = peg$parseWhiteSpace();
	      if (s1 === peg$FAILED) {
	        s1 = peg$parseLineContinuation();
	        if (s1 === peg$FAILED) {
	          s1 = peg$parseMultiLineCommentNoLineTerminator();
	          if (s1 === peg$FAILED) {
	            s1 = peg$parseSingleLineComment();
	          }
	        }
	      }
	      if (s1 !== peg$FAILED) {
	        while (s1 !== peg$FAILED) {
	          s0.push(s1);
	          s1 = peg$parseWhiteSpace();
	          if (s1 === peg$FAILED) {
	            s1 = peg$parseLineContinuation();
	            if (s1 === peg$FAILED) {
	              s1 = peg$parseMultiLineCommentNoLineTerminator();
	              if (s1 === peg$FAILED) {
	                s1 = peg$parseSingleLineComment();
	              }
	            }
	          }
	        }
	      } else {
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parse__() {
	      var s0, s1;

	      s0 = [];
	      s1 = peg$parseWhiteSpace();
	      if (s1 === peg$FAILED) {
	        s1 = peg$parseLineContinuation();
	        if (s1 === peg$FAILED) {
	          s1 = peg$parseLineTerminatorSequence();
	          if (s1 === peg$FAILED) {
	            s1 = peg$parseComment();
	          }
	        }
	      }
	      while (s1 !== peg$FAILED) {
	        s0.push(s1);
	        s1 = peg$parseWhiteSpace();
	        if (s1 === peg$FAILED) {
	          s1 = peg$parseLineContinuation();
	          if (s1 === peg$FAILED) {
	            s1 = peg$parseLineTerminatorSequence();
	            if (s1 === peg$FAILED) {
	              s1 = peg$parseComment();
	            }
	          }
	        }
	      }

	      return s0;
	    }

	    function peg$parseWhiteSpace() {
	      var s0;

	      peg$silentFails++;
	      if (peg$c300.test(input.charAt(peg$currPos))) {
	        s0 = input.charAt(peg$currPos);
	        peg$currPos++;
	      } else {
	        s0 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c301); }
	      }
	      peg$silentFails--;
	      if (s0 === peg$FAILED) {
	        if (peg$silentFails === 0) { peg$fail(peg$c299); }
	      }

	      return s0;
	    }

	    function peg$parseLineTerminator() {
	      var s0;

	      if (peg$c302.test(input.charAt(peg$currPos))) {
	        s0 = input.charAt(peg$currPos);
	        peg$currPos++;
	      } else {
	        s0 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c303); }
	      }

	      return s0;
	    }

	    function peg$parseLineTerminatorSequence() {
	      var s0;

	      peg$silentFails++;
	      if (input.charCodeAt(peg$currPos) === 10) {
	        s0 = peg$c305;
	        peg$currPos++;
	      } else {
	        s0 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c306); }
	      }
	      if (s0 === peg$FAILED) {
	        if (input.substr(peg$currPos, 2) === peg$c307) {
	          s0 = peg$c307;
	          peg$currPos += 2;
	        } else {
	          s0 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c308); }
	        }
	        if (s0 === peg$FAILED) {
	          if (input.charCodeAt(peg$currPos) === 13) {
	            s0 = peg$c309;
	            peg$currPos++;
	          } else {
	            s0 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c310); }
	          }
	        }
	      }
	      peg$silentFails--;
	      if (s0 === peg$FAILED) {
	        if (peg$silentFails === 0) { peg$fail(peg$c304); }
	      }

	      return s0;
	    }

	    function peg$parseLineTerminatorSequenceEOF() {
	      var s0;

	      s0 = peg$parseLineTerminatorSequence();
	      if (s0 === peg$FAILED) {
	        s0 = peg$parseEOF();
	      }

	      return s0;
	    }

	    function peg$parseComment() {
	      var s0;

	      peg$silentFails++;
	      s0 = peg$parseMultiLineComment();
	      if (s0 === peg$FAILED) {
	        s0 = peg$parseSingleLineComment();
	      }
	      peg$silentFails--;
	      if (s0 === peg$FAILED) {
	        if (peg$silentFails === 0) { peg$fail(peg$c311); }
	      }

	      return s0;
	    }

	    function peg$parseMultiLineComment() {
	      var s0, s1, s2, s3, s4, s5;

	      s0 = peg$currPos;
	      if (input.substr(peg$currPos, 2) === peg$c312) {
	        s1 = peg$c312;
	        peg$currPos += 2;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c313); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = [];
	        s3 = peg$currPos;
	        s4 = peg$currPos;
	        peg$silentFails++;
	        if (input.substr(peg$currPos, 2) === peg$c314) {
	          s5 = peg$c314;
	          peg$currPos += 2;
	        } else {
	          s5 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c315); }
	        }
	        peg$silentFails--;
	        if (s5 === peg$FAILED) {
	          s4 = void 0;
	        } else {
	          peg$currPos = s4;
	          s4 = peg$FAILED;
	        }
	        if (s4 !== peg$FAILED) {
	          s5 = peg$parseSourceCharacter();
	          if (s5 !== peg$FAILED) {
	            s4 = [s4, s5];
	            s3 = s4;
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s3;
	          s3 = peg$FAILED;
	        }
	        while (s3 !== peg$FAILED) {
	          s2.push(s3);
	          s3 = peg$currPos;
	          s4 = peg$currPos;
	          peg$silentFails++;
	          if (input.substr(peg$currPos, 2) === peg$c314) {
	            s5 = peg$c314;
	            peg$currPos += 2;
	          } else {
	            s5 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c315); }
	          }
	          peg$silentFails--;
	          if (s5 === peg$FAILED) {
	            s4 = void 0;
	          } else {
	            peg$currPos = s4;
	            s4 = peg$FAILED;
	          }
	          if (s4 !== peg$FAILED) {
	            s5 = peg$parseSourceCharacter();
	            if (s5 !== peg$FAILED) {
	              s4 = [s4, s5];
	              s3 = s4;
	            } else {
	              peg$currPos = s3;
	              s3 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        }
	        if (s2 !== peg$FAILED) {
	          if (input.substr(peg$currPos, 2) === peg$c314) {
	            s3 = peg$c314;
	            peg$currPos += 2;
	          } else {
	            s3 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c315); }
	          }
	          if (s3 !== peg$FAILED) {
	            s1 = [s1, s2, s3];
	            s0 = s1;
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseMultiLineCommentNoLineTerminator() {
	      var s0, s1, s2, s3, s4, s5;

	      s0 = peg$currPos;
	      if (input.substr(peg$currPos, 2) === peg$c312) {
	        s1 = peg$c312;
	        peg$currPos += 2;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c313); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = [];
	        s3 = peg$currPos;
	        s4 = peg$currPos;
	        peg$silentFails++;
	        if (input.substr(peg$currPos, 2) === peg$c314) {
	          s5 = peg$c314;
	          peg$currPos += 2;
	        } else {
	          s5 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c315); }
	        }
	        if (s5 === peg$FAILED) {
	          s5 = peg$parseLineTerminator();
	        }
	        peg$silentFails--;
	        if (s5 === peg$FAILED) {
	          s4 = void 0;
	        } else {
	          peg$currPos = s4;
	          s4 = peg$FAILED;
	        }
	        if (s4 !== peg$FAILED) {
	          s5 = peg$parseSourceCharacter();
	          if (s5 !== peg$FAILED) {
	            s4 = [s4, s5];
	            s3 = s4;
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s3;
	          s3 = peg$FAILED;
	        }
	        while (s3 !== peg$FAILED) {
	          s2.push(s3);
	          s3 = peg$currPos;
	          s4 = peg$currPos;
	          peg$silentFails++;
	          if (input.substr(peg$currPos, 2) === peg$c314) {
	            s5 = peg$c314;
	            peg$currPos += 2;
	          } else {
	            s5 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c315); }
	          }
	          if (s5 === peg$FAILED) {
	            s5 = peg$parseLineTerminator();
	          }
	          peg$silentFails--;
	          if (s5 === peg$FAILED) {
	            s4 = void 0;
	          } else {
	            peg$currPos = s4;
	            s4 = peg$FAILED;
	          }
	          if (s4 !== peg$FAILED) {
	            s5 = peg$parseSourceCharacter();
	            if (s5 !== peg$FAILED) {
	              s4 = [s4, s5];
	              s3 = s4;
	            } else {
	              peg$currPos = s3;
	              s3 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        }
	        if (s2 !== peg$FAILED) {
	          if (input.substr(peg$currPos, 2) === peg$c314) {
	            s3 = peg$c314;
	            peg$currPos += 2;
	          } else {
	            s3 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c315); }
	          }
	          if (s3 !== peg$FAILED) {
	            s1 = [s1, s2, s3];
	            s0 = s1;
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseSingleLineComment() {
	      var s0, s1, s2, s3, s4, s5;

	      s0 = peg$currPos;
	      if (input.substr(peg$currPos, 2) === peg$c316) {
	        s1 = peg$c316;
	        peg$currPos += 2;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c317); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = [];
	        s3 = peg$currPos;
	        s4 = peg$currPos;
	        peg$silentFails++;
	        s5 = peg$parseLineTerminator();
	        peg$silentFails--;
	        if (s5 === peg$FAILED) {
	          s4 = void 0;
	        } else {
	          peg$currPos = s4;
	          s4 = peg$FAILED;
	        }
	        if (s4 !== peg$FAILED) {
	          s5 = peg$parseSourceCharacter();
	          if (s5 !== peg$FAILED) {
	            s4 = [s4, s5];
	            s3 = s4;
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s3;
	          s3 = peg$FAILED;
	        }
	        while (s3 !== peg$FAILED) {
	          s2.push(s3);
	          s3 = peg$currPos;
	          s4 = peg$currPos;
	          peg$silentFails++;
	          s5 = peg$parseLineTerminator();
	          peg$silentFails--;
	          if (s5 === peg$FAILED) {
	            s4 = void 0;
	          } else {
	            peg$currPos = s4;
	            s4 = peg$FAILED;
	          }
	          if (s4 !== peg$FAILED) {
	            s5 = peg$parseSourceCharacter();
	            if (s5 !== peg$FAILED) {
	              s4 = [s4, s5];
	              s3 = s4;
	            } else {
	              peg$currPos = s3;
	              s3 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s3;
	            s3 = peg$FAILED;
	          }
	        }
	        if (s2 !== peg$FAILED) {
	          s1 = [s1, s2];
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseSourceCharacter() {
	      var s0;

	      if (input.length > peg$currPos) {
	        s0 = input.charAt(peg$currPos);
	        peg$currPos++;
	      } else {
	        s0 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c318); }
	      }

	      return s0;
	    }

	    function peg$parseEOF() {
	      var s0, s1;

	      s0 = peg$currPos;
	      peg$silentFails++;
	      if (input.length > peg$currPos) {
	        s1 = input.charAt(peg$currPos);
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c318); }
	      }
	      peg$silentFails--;
	      if (s1 === peg$FAILED) {
	        s0 = void 0;
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    peg$result = peg$startRuleFunction();

	    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
	      return peg$result;
	    } else {
	      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
	        peg$fail({ type: "end", description: "end of input" });
	      }

	      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
	    }
	  }

	  return {
	    SyntaxError: peg$SyntaxError,
	    parse:       peg$parse
	  };
	})();

	}

	var gpp_parser_factory = register("__gpp_parser", GPP_parser);

	var index = {};

	return index;

})));
//# sourceMappingURL=build.js.map
